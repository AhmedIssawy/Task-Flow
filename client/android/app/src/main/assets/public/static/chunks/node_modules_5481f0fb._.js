(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ __turbopack_context__.s({
    "__addDisposableResource": ()=>__addDisposableResource,
    "__assign": ()=>__assign,
    "__asyncDelegator": ()=>__asyncDelegator,
    "__asyncGenerator": ()=>__asyncGenerator,
    "__asyncValues": ()=>__asyncValues,
    "__await": ()=>__await,
    "__awaiter": ()=>__awaiter,
    "__classPrivateFieldGet": ()=>__classPrivateFieldGet,
    "__classPrivateFieldIn": ()=>__classPrivateFieldIn,
    "__classPrivateFieldSet": ()=>__classPrivateFieldSet,
    "__createBinding": ()=>__createBinding,
    "__decorate": ()=>__decorate,
    "__disposeResources": ()=>__disposeResources,
    "__esDecorate": ()=>__esDecorate,
    "__exportStar": ()=>__exportStar,
    "__extends": ()=>__extends,
    "__generator": ()=>__generator,
    "__importDefault": ()=>__importDefault,
    "__importStar": ()=>__importStar,
    "__makeTemplateObject": ()=>__makeTemplateObject,
    "__metadata": ()=>__metadata,
    "__param": ()=>__param,
    "__propKey": ()=>__propKey,
    "__read": ()=>__read,
    "__rest": ()=>__rest,
    "__rewriteRelativeImportExtension": ()=>__rewriteRelativeImportExtension,
    "__runInitializers": ()=>__runInitializers,
    "__setFunctionName": ()=>__setFunctionName,
    "__spread": ()=>__spread,
    "__spreadArray": ()=>__spreadArray,
    "__spreadArrays": ()=>__spreadArrays,
    "__values": ()=>__values,
    "default": ()=>__TURBOPACK__default__export__
});
var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return extendStatics(d, b);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
}
;
function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++){
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
}
;
function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
}
;
function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", {
        configurable: true,
        value: prefix ? "".concat(prefix, " ", name) : name
    });
}
;
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    //TURBOPACK unreachable
    ;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
};
function __exportStar(m, o) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function __spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
}
function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: false
            } : f ? f(v) : v;
        } : f;
    }
}
function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    //TURBOPACK unreachable
    ;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", {
            value: raw
        });
    } else {
        cooked.raw = raw;
    }
    return cooked;
}
;
var __setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
};
var ownKeys = function(o) {
    ownKeys = Object.getOwnPropertyNames || function(o) {
        var ar = [];
        for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
    };
    return ownKeys(o);
};
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
    }
    __setModuleDefault(result, mod);
    return result;
}
function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() {
            try {
                inner.call(this);
            } catch (e) {
                return Promise.reject(e);
            }
        };
        env.stack.push({
            value: value,
            dispose: dispose,
            async: async
        });
    } else if (async) {
        env.stack.push({
            async: true
        });
    }
    return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
    function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
    }
    var r, s = 0;
    function next() {
        while(r = env.stack.pop()){
            try {
                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                if (r.dispose) {
                    var result = r.dispose.call(r.value);
                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                        fail(e);
                        return next();
                    });
                } else s |= 1;
            } catch (e) {
                fail(e);
            }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
    }
    return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
            return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
    }
    return path;
}
const __TURBOPACK__default__export__ = {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __esDecorate,
    __runInitializers,
    __propKey,
    __setFunctionName,
    __metadata,
    __awaiter,
    __generator,
    __createBinding,
    __exportStar,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources,
    __rewriteRelativeImportExtension
};
}),
"[project]/node_modules/@formatjs/fast-memoize/lib/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

//
// Main
//
__turbopack_context__.s({
    "memoize": ()=>memoize,
    "strategies": ()=>strategies
});
function memoize(fn, options) {
    var cache = options && options.cache ? options.cache : cacheDefault;
    var serializer = options && options.serializer ? options.serializer : serializerDefault;
    var strategy = options && options.strategy ? options.strategy : strategyDefault;
    return strategy(fn, {
        cache: cache,
        serializer: serializer
    });
}
//
// Strategy
//
function isPrimitive(value) {
    return value == null || typeof value === 'number' || typeof value === 'boolean'; // || typeof value === "string" 'unsafe' primitive for our needs
}
function monadic(fn, cache, serializer, arg) {
    var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
    var computedValue = cache.get(cacheKey);
    if (typeof computedValue === 'undefined') {
        computedValue = fn.call(this, arg);
        cache.set(cacheKey, computedValue);
    }
    return computedValue;
}
function variadic(fn, cache, serializer) {
    var args = Array.prototype.slice.call(arguments, 3);
    var cacheKey = serializer(args);
    var computedValue = cache.get(cacheKey);
    if (typeof computedValue === 'undefined') {
        computedValue = fn.apply(this, args);
        cache.set(cacheKey, computedValue);
    }
    return computedValue;
}
function assemble(fn, context, strategy, cache, serialize) {
    return strategy.bind(context, fn, cache, serialize);
}
function strategyDefault(fn, options) {
    var strategy = fn.length === 1 ? monadic : variadic;
    return assemble(fn, this, strategy, options.cache.create(), options.serializer);
}
function strategyVariadic(fn, options) {
    return assemble(fn, this, variadic, options.cache.create(), options.serializer);
}
function strategyMonadic(fn, options) {
    return assemble(fn, this, monadic, options.cache.create(), options.serializer);
}
//
// Serializer
//
var serializerDefault = function() {
    return JSON.stringify(arguments);
};
//
// Cache
//
var ObjectWithoutPrototypeCache = function() {
    function ObjectWithoutPrototypeCache() {
        this.cache = Object.create(null);
    }
    ObjectWithoutPrototypeCache.prototype.get = function(key) {
        return this.cache[key];
    };
    ObjectWithoutPrototypeCache.prototype.set = function(key, value) {
        this.cache[key] = value;
    };
    return ObjectWithoutPrototypeCache;
}();
var cacheDefault = {
    create: function create() {
        return new ObjectWithoutPrototypeCache();
    }
};
var strategies = {
    variadic: strategyVariadic,
    monadic: strategyMonadic
};
}),
"[project]/node_modules/@formatjs/icu-messageformat-parser/lib/error.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ErrorKind": ()=>ErrorKind
});
var ErrorKind;
(function(ErrorKind) {
    /** Argument is unclosed (e.g. `{0`) */ ErrorKind[ErrorKind["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
    /** Argument is empty (e.g. `{}`). */ ErrorKind[ErrorKind["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
    /** Argument is malformed (e.g. `{foo!}``) */ ErrorKind[ErrorKind["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
    /** Expect an argument type (e.g. `{foo,}`) */ ErrorKind[ErrorKind["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
    /** Unsupported argument type (e.g. `{foo,foo}`) */ ErrorKind[ErrorKind["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
    /** Expect an argument style (e.g. `{foo, number, }`) */ ErrorKind[ErrorKind["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
    /** The number skeleton is invalid. */ ErrorKind[ErrorKind["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
    /** The date time skeleton is invalid. */ ErrorKind[ErrorKind["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
    /** Exepct a number skeleton following the `::` (e.g. `{foo, number, ::}`) */ ErrorKind[ErrorKind["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
    /** Exepct a date time skeleton following the `::` (e.g. `{foo, date, ::}`) */ ErrorKind[ErrorKind["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
    /** Unmatched apostrophes in the argument style (e.g. `{foo, number, 'test`) */ ErrorKind[ErrorKind["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
    /** Missing select argument options (e.g. `{foo, select}`) */ ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
    /** Expecting an offset value in `plural` or `selectordinal` argument (e.g `{foo, plural, offset}`) */ ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
    /** Offset value in `plural` or `selectordinal` is invalid (e.g. `{foo, plural, offset: x}`) */ ErrorKind[ErrorKind["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
    /** Expecting a selector in `select` argument (e.g `{foo, select}`) */ ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
    /** Expecting a selector in `plural` or `selectordinal` argument (e.g `{foo, plural}`) */ ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
    /** Expecting a message fragment after the `select` selector (e.g. `{foo, select, apple}`) */ ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
    /**
     * Expecting a message fragment after the `plural` or `selectordinal` selector
     * (e.g. `{foo, plural, one}`)
     */ ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
    /** Selector in `plural` or `selectordinal` is malformed (e.g. `{foo, plural, =x {#}}`) */ ErrorKind[ErrorKind["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
    /**
     * Duplicate selectors in `plural` or `selectordinal` argument.
     * (e.g. {foo, plural, one {#} one {#}})
     */ ErrorKind[ErrorKind["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
    /** Duplicate selectors in `select` argument.
     * (e.g. {foo, select, apple {apple} apple {apple}})
     */ ErrorKind[ErrorKind["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
    /** Plural or select argument option must have `other` clause. */ ErrorKind[ErrorKind["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
    /** The tag is malformed. (e.g. `<bold!>foo</bold!>) */ ErrorKind[ErrorKind["INVALID_TAG"] = 23] = "INVALID_TAG";
    /** The tag name is invalid. (e.g. `<123>foo</123>`) */ ErrorKind[ErrorKind["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
    /** The closing tag does not match the opening tag. (e.g. `<bold>foo</italic>`) */ ErrorKind[ErrorKind["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
    /** The opening tag has unmatched closing tag. (e.g. `<bold>foo`) */ ErrorKind[ErrorKind["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
})(ErrorKind || (ErrorKind = {}));
}),
"[project]/node_modules/@formatjs/icu-messageformat-parser/lib/types.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "SKELETON_TYPE": ()=>SKELETON_TYPE,
    "TYPE": ()=>TYPE,
    "createLiteralElement": ()=>createLiteralElement,
    "createNumberElement": ()=>createNumberElement,
    "isArgumentElement": ()=>isArgumentElement,
    "isDateElement": ()=>isDateElement,
    "isDateTimeSkeleton": ()=>isDateTimeSkeleton,
    "isLiteralElement": ()=>isLiteralElement,
    "isNumberElement": ()=>isNumberElement,
    "isNumberSkeleton": ()=>isNumberSkeleton,
    "isPluralElement": ()=>isPluralElement,
    "isPoundElement": ()=>isPoundElement,
    "isSelectElement": ()=>isSelectElement,
    "isTagElement": ()=>isTagElement,
    "isTimeElement": ()=>isTimeElement
});
var TYPE;
(function(TYPE) {
    /**
     * Raw text
     */ TYPE[TYPE["literal"] = 0] = "literal";
    /**
     * Variable w/o any format, e.g `var` in `this is a {var}`
     */ TYPE[TYPE["argument"] = 1] = "argument";
    /**
     * Variable w/ number format
     */ TYPE[TYPE["number"] = 2] = "number";
    /**
     * Variable w/ date format
     */ TYPE[TYPE["date"] = 3] = "date";
    /**
     * Variable w/ time format
     */ TYPE[TYPE["time"] = 4] = "time";
    /**
     * Variable w/ select format
     */ TYPE[TYPE["select"] = 5] = "select";
    /**
     * Variable w/ plural format
     */ TYPE[TYPE["plural"] = 6] = "plural";
    /**
     * Only possible within plural argument.
     * This is the `#` symbol that will be substituted with the count.
     */ TYPE[TYPE["pound"] = 7] = "pound";
    /**
     * XML-like tag
     */ TYPE[TYPE["tag"] = 8] = "tag";
})(TYPE || (TYPE = {}));
var SKELETON_TYPE;
(function(SKELETON_TYPE) {
    SKELETON_TYPE[SKELETON_TYPE["number"] = 0] = "number";
    SKELETON_TYPE[SKELETON_TYPE["dateTime"] = 1] = "dateTime";
})(SKELETON_TYPE || (SKELETON_TYPE = {}));
function isLiteralElement(el) {
    return el.type === TYPE.literal;
}
function isArgumentElement(el) {
    return el.type === TYPE.argument;
}
function isNumberElement(el) {
    return el.type === TYPE.number;
}
function isDateElement(el) {
    return el.type === TYPE.date;
}
function isTimeElement(el) {
    return el.type === TYPE.time;
}
function isSelectElement(el) {
    return el.type === TYPE.select;
}
function isPluralElement(el) {
    return el.type === TYPE.plural;
}
function isPoundElement(el) {
    return el.type === TYPE.pound;
}
function isTagElement(el) {
    return el.type === TYPE.tag;
}
function isNumberSkeleton(el) {
    return !!(el && typeof el === 'object' && el.type === SKELETON_TYPE.number);
}
function isDateTimeSkeleton(el) {
    return !!(el && typeof el === 'object' && el.type === SKELETON_TYPE.dateTime);
}
function createLiteralElement(value) {
    return {
        type: TYPE.literal,
        value: value
    };
}
function createNumberElement(value, style) {
    return {
        type: TYPE.number,
        value: value,
        style: style
    };
}
}),
"[project]/node_modules/@formatjs/icu-messageformat-parser/lib/regex.generated.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// @generated from regex-gen.ts
__turbopack_context__.s({
    "SPACE_SEPARATOR_REGEX": ()=>SPACE_SEPARATOR_REGEX,
    "WHITE_SPACE_REGEX": ()=>WHITE_SPACE_REGEX
});
var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/;
}),
"[project]/node_modules/@formatjs/icu-skeleton-parser/lib/date-time.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * Credit: https://github.com/caridy/intl-datetimeformat-pattern/blob/master/index.js
 * with some tweaks
 */ __turbopack_context__.s({
    "parseDateTimeSkeleton": ()=>parseDateTimeSkeleton
});
var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function parseDateTimeSkeleton(skeleton) {
    var result = {};
    skeleton.replace(DATE_TIME_REGEX, function(match) {
        var len = match.length;
        switch(match[0]){
            // Era
            case 'G':
                result.era = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';
                break;
            // Year
            case 'y':
                result.year = len === 2 ? '2-digit' : 'numeric';
                break;
            case 'Y':
            case 'u':
            case 'U':
            case 'r':
                throw new RangeError('`Y/u/U/r` (year) patterns are not supported, use `y` instead');
            // Quarter
            case 'q':
            case 'Q':
                throw new RangeError('`q/Q` (quarter) patterns are not supported');
            // Month
            case 'M':
            case 'L':
                result.month = [
                    'numeric',
                    '2-digit',
                    'short',
                    'long',
                    'narrow'
                ][len - 1];
                break;
            // Week
            case 'w':
            case 'W':
                throw new RangeError('`w/W` (week) patterns are not supported');
            case 'd':
                result.day = [
                    'numeric',
                    '2-digit'
                ][len - 1];
                break;
            case 'D':
            case 'F':
            case 'g':
                throw new RangeError('`D/F/g` (day) patterns are not supported, use `d` instead');
            // Weekday
            case 'E':
                result.weekday = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';
                break;
            case 'e':
                if (len < 4) {
                    throw new RangeError('`e..eee` (weekday) patterns are not supported');
                }
                result.weekday = [
                    'short',
                    'long',
                    'narrow',
                    'short'
                ][len - 4];
                break;
            case 'c':
                if (len < 4) {
                    throw new RangeError('`c..ccc` (weekday) patterns are not supported');
                }
                result.weekday = [
                    'short',
                    'long',
                    'narrow',
                    'short'
                ][len - 4];
                break;
            // Period
            case 'a':
                result.hour12 = true;
                break;
            case 'b':
            case 'B':
                throw new RangeError('`b/B` (period) patterns are not supported, use `a` instead');
            // Hour
            case 'h':
                result.hourCycle = 'h12';
                result.hour = [
                    'numeric',
                    '2-digit'
                ][len - 1];
                break;
            case 'H':
                result.hourCycle = 'h23';
                result.hour = [
                    'numeric',
                    '2-digit'
                ][len - 1];
                break;
            case 'K':
                result.hourCycle = 'h11';
                result.hour = [
                    'numeric',
                    '2-digit'
                ][len - 1];
                break;
            case 'k':
                result.hourCycle = 'h24';
                result.hour = [
                    'numeric',
                    '2-digit'
                ][len - 1];
                break;
            case 'j':
            case 'J':
            case 'C':
                throw new RangeError('`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead');
            // Minute
            case 'm':
                result.minute = [
                    'numeric',
                    '2-digit'
                ][len - 1];
                break;
            // Second
            case 's':
                result.second = [
                    'numeric',
                    '2-digit'
                ][len - 1];
                break;
            case 'S':
            case 'A':
                throw new RangeError('`S/A` (second) patterns are not supported, use `s` instead');
            // Zone
            case 'z':
                result.timeZoneName = len < 4 ? 'short' : 'long';
                break;
            case 'Z':
            case 'O':
            case 'v':
            case 'V':
            case 'X':
            case 'x':
                throw new RangeError('`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead');
        }
        return '';
    });
    return result;
}
}),
"[project]/node_modules/@formatjs/icu-skeleton-parser/lib/regex.generated.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// @generated from regex-gen.ts
__turbopack_context__.s({
    "WHITE_SPACE_REGEX": ()=>WHITE_SPACE_REGEX
});
var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;
}),
"[project]/node_modules/@formatjs/icu-skeleton-parser/lib/number.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "parseNumberSkeleton": ()=>parseNumberSkeleton,
    "parseNumberSkeletonFromString": ()=>parseNumberSkeletonFromString
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$skeleton$2d$parser$2f$lib$2f$regex$2e$generated$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-skeleton-parser/lib/regex.generated.js [app-client] (ecmascript)");
;
;
function parseNumberSkeletonFromString(skeleton) {
    if (skeleton.length === 0) {
        throw new Error('Number skeleton cannot be empty');
    }
    // Parse the skeleton
    var stringTokens = skeleton.split(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$skeleton$2d$parser$2f$lib$2f$regex$2e$generated$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WHITE_SPACE_REGEX"]).filter(function(x) {
        return x.length > 0;
    });
    var tokens = [];
    for(var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++){
        var stringToken = stringTokens_1[_i];
        var stemAndOptions = stringToken.split('/');
        if (stemAndOptions.length === 0) {
            throw new Error('Invalid number skeleton');
        }
        var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
        for(var _a = 0, options_1 = options; _a < options_1.length; _a++){
            var option = options_1[_a];
            if (option.length === 0) {
                throw new Error('Invalid number skeleton');
            }
        }
        tokens.push({
            stem: stem,
            options: options
        });
    }
    return tokens;
}
function icuUnitToEcma(unit) {
    return unit.replace(/^(.*?)-/, '');
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
function parseSignificantPrecision(str) {
    var result = {};
    if (str[str.length - 1] === 'r') {
        result.roundingPriority = 'morePrecision';
    } else if (str[str.length - 1] === 's') {
        result.roundingPriority = 'lessPrecision';
    }
    str.replace(SIGNIFICANT_PRECISION_REGEX, function(_, g1, g2) {
        // @@@ case
        if (typeof g2 !== 'string') {
            result.minimumSignificantDigits = g1.length;
            result.maximumSignificantDigits = g1.length;
        } else if (g2 === '+') {
            result.minimumSignificantDigits = g1.length;
        } else if (g1[0] === '#') {
            result.maximumSignificantDigits = g1.length;
        } else {
            result.minimumSignificantDigits = g1.length;
            result.maximumSignificantDigits = g1.length + (typeof g2 === 'string' ? g2.length : 0);
        }
        return '';
    });
    return result;
}
function parseSign(str) {
    switch(str){
        case 'sign-auto':
            return {
                signDisplay: 'auto'
            };
        case 'sign-accounting':
        case '()':
            return {
                currencySign: 'accounting'
            };
        case 'sign-always':
        case '+!':
            return {
                signDisplay: 'always'
            };
        case 'sign-accounting-always':
        case '()!':
            return {
                signDisplay: 'always',
                currencySign: 'accounting'
            };
        case 'sign-except-zero':
        case '+?':
            return {
                signDisplay: 'exceptZero'
            };
        case 'sign-accounting-except-zero':
        case '()?':
            return {
                signDisplay: 'exceptZero',
                currencySign: 'accounting'
            };
        case 'sign-never':
        case '+_':
            return {
                signDisplay: 'never'
            };
    }
}
function parseConciseScientificAndEngineeringStem(stem) {
    // Engineering
    var result;
    if (stem[0] === 'E' && stem[1] === 'E') {
        result = {
            notation: 'engineering'
        };
        stem = stem.slice(2);
    } else if (stem[0] === 'E') {
        result = {
            notation: 'scientific'
        };
        stem = stem.slice(1);
    }
    if (result) {
        var signDisplay = stem.slice(0, 2);
        if (signDisplay === '+!') {
            result.signDisplay = 'always';
            stem = stem.slice(2);
        } else if (signDisplay === '+?') {
            result.signDisplay = 'exceptZero';
            stem = stem.slice(2);
        }
        if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
            throw new Error('Malformed concise eng/scientific notation');
        }
        result.minimumIntegerDigits = stem.length;
    }
    return result;
}
function parseNotationOptions(opt) {
    var result = {};
    var signOpts = parseSign(opt);
    if (signOpts) {
        return signOpts;
    }
    return result;
}
function parseNumberSkeleton(tokens) {
    var result = {};
    for(var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++){
        var token = tokens_1[_i];
        switch(token.stem){
            case 'percent':
            case '%':
                result.style = 'percent';
                continue;
            case '%x100':
                result.style = 'percent';
                result.scale = 100;
                continue;
            case 'currency':
                result.style = 'currency';
                result.currency = token.options[0];
                continue;
            case 'group-off':
            case ',_':
                result.useGrouping = false;
                continue;
            case 'precision-integer':
            case '.':
                result.maximumFractionDigits = 0;
                continue;
            case 'measure-unit':
            case 'unit':
                result.style = 'unit';
                result.unit = icuUnitToEcma(token.options[0]);
                continue;
            case 'compact-short':
            case 'K':
                result.notation = 'compact';
                result.compactDisplay = 'short';
                continue;
            case 'compact-long':
            case 'KK':
                result.notation = 'compact';
                result.compactDisplay = 'long';
                continue;
            case 'scientific':
                result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, result), {
                    notation: 'scientific'
                }), token.options.reduce(function(all, opt) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, all), parseNotationOptions(opt));
                }, {}));
                continue;
            case 'engineering':
                result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, result), {
                    notation: 'engineering'
                }), token.options.reduce(function(all, opt) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, all), parseNotationOptions(opt));
                }, {}));
                continue;
            case 'notation-simple':
                result.notation = 'standard';
                continue;
            // https://github.com/unicode-org/icu/blob/master/icu4c/source/i18n/unicode/unumberformatter.h
            case 'unit-width-narrow':
                result.currencyDisplay = 'narrowSymbol';
                result.unitDisplay = 'narrow';
                continue;
            case 'unit-width-short':
                result.currencyDisplay = 'code';
                result.unitDisplay = 'short';
                continue;
            case 'unit-width-full-name':
                result.currencyDisplay = 'name';
                result.unitDisplay = 'long';
                continue;
            case 'unit-width-iso-code':
                result.currencyDisplay = 'symbol';
                continue;
            case 'scale':
                result.scale = parseFloat(token.options[0]);
                continue;
            case 'rounding-mode-floor':
                result.roundingMode = 'floor';
                continue;
            case 'rounding-mode-ceiling':
                result.roundingMode = 'ceil';
                continue;
            case 'rounding-mode-down':
                result.roundingMode = 'trunc';
                continue;
            case 'rounding-mode-up':
                result.roundingMode = 'expand';
                continue;
            case 'rounding-mode-half-even':
                result.roundingMode = 'halfEven';
                continue;
            case 'rounding-mode-half-down':
                result.roundingMode = 'halfTrunc';
                continue;
            case 'rounding-mode-half-up':
                result.roundingMode = 'halfExpand';
                continue;
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width
            case 'integer-width':
                if (token.options.length > 1) {
                    throw new RangeError('integer-width stems only accept a single optional option');
                }
                token.options[0].replace(INTEGER_WIDTH_REGEX, function(_, g1, g2, g3, g4, g5) {
                    if (g1) {
                        result.minimumIntegerDigits = g2.length;
                    } else if (g3 && g4) {
                        throw new Error('We currently do not support maximum integer digits');
                    } else if (g5) {
                        throw new Error('We currently do not support exact integer digits');
                    }
                    return '';
                });
                continue;
        }
        // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width
        if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {
            result.minimumIntegerDigits = token.stem.length;
            continue;
        }
        if (FRACTION_PRECISION_REGEX.test(token.stem)) {
            // Precision
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#fraction-precision
            // precision-integer case
            if (token.options.length > 1) {
                throw new RangeError('Fraction-precision stems only accept a single optional option');
            }
            token.stem.replace(FRACTION_PRECISION_REGEX, function(_, g1, g2, g3, g4, g5) {
                // .000* case (before ICU67 it was .000+)
                if (g2 === '*') {
                    result.minimumFractionDigits = g1.length;
                } else if (g3 && g3[0] === '#') {
                    result.maximumFractionDigits = g3.length;
                } else if (g4 && g5) {
                    result.minimumFractionDigits = g4.length;
                    result.maximumFractionDigits = g4.length + g5.length;
                } else {
                    result.minimumFractionDigits = g1.length;
                    result.maximumFractionDigits = g1.length;
                }
                return '';
            });
            var opt = token.options[0];
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#trailing-zero-display
            if (opt === 'w') {
                result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, result), {
                    trailingZeroDisplay: 'stripIfInteger'
                });
            } else if (opt) {
                result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, result), parseSignificantPrecision(opt));
            }
            continue;
        }
        // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#significant-digits-precision
        if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
            result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, result), parseSignificantPrecision(token.stem));
            continue;
        }
        var signOpts = parseSign(token.stem);
        if (signOpts) {
            result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, result), signOpts);
        }
        var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);
        if (conciseScientificAndEngineeringOpts) {
            result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, result), conciseScientificAndEngineeringOpts);
        }
    }
    return result;
}
}),
"[project]/node_modules/@formatjs/icu-skeleton-parser/lib/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$skeleton$2d$parser$2f$lib$2f$date$2d$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-skeleton-parser/lib/date-time.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$skeleton$2d$parser$2f$lib$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-skeleton-parser/lib/number.js [app-client] (ecmascript)");
;
;
}),
"[project]/node_modules/@formatjs/icu-skeleton-parser/lib/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$skeleton$2d$parser$2f$lib$2f$date$2d$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-skeleton-parser/lib/date-time.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$skeleton$2d$parser$2f$lib$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-skeleton-parser/lib/number.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$skeleton$2d$parser$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-skeleton-parser/lib/index.js [app-client] (ecmascript) <locals>");
}),
"[project]/node_modules/@formatjs/icu-messageformat-parser/lib/time-data.generated.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// @generated from time-data-gen.ts
// prettier-ignore  
__turbopack_context__.s({
    "timeData": ()=>timeData
});
var timeData = {
    "001": [
        "H",
        "h"
    ],
    "419": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "AC": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "AD": [
        "H",
        "hB"
    ],
    "AE": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "AF": [
        "H",
        "hb",
        "hB",
        "h"
    ],
    "AG": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "AI": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "AL": [
        "h",
        "H",
        "hB"
    ],
    "AM": [
        "H",
        "hB"
    ],
    "AO": [
        "H",
        "hB"
    ],
    "AR": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "AS": [
        "h",
        "H"
    ],
    "AT": [
        "H",
        "hB"
    ],
    "AU": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "AW": [
        "H",
        "hB"
    ],
    "AX": [
        "H"
    ],
    "AZ": [
        "H",
        "hB",
        "h"
    ],
    "BA": [
        "H",
        "hB",
        "h"
    ],
    "BB": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "BD": [
        "h",
        "hB",
        "H"
    ],
    "BE": [
        "H",
        "hB"
    ],
    "BF": [
        "H",
        "hB"
    ],
    "BG": [
        "H",
        "hB",
        "h"
    ],
    "BH": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "BI": [
        "H",
        "h"
    ],
    "BJ": [
        "H",
        "hB"
    ],
    "BL": [
        "H",
        "hB"
    ],
    "BM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "BN": [
        "hb",
        "hB",
        "h",
        "H"
    ],
    "BO": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "BQ": [
        "H"
    ],
    "BR": [
        "H",
        "hB"
    ],
    "BS": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "BT": [
        "h",
        "H"
    ],
    "BW": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "BY": [
        "H",
        "h"
    ],
    "BZ": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "CA": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "CC": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "CD": [
        "hB",
        "H"
    ],
    "CF": [
        "H",
        "h",
        "hB"
    ],
    "CG": [
        "H",
        "hB"
    ],
    "CH": [
        "H",
        "hB",
        "h"
    ],
    "CI": [
        "H",
        "hB"
    ],
    "CK": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "CL": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "CM": [
        "H",
        "h",
        "hB"
    ],
    "CN": [
        "H",
        "hB",
        "hb",
        "h"
    ],
    "CO": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "CP": [
        "H"
    ],
    "CR": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "CU": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "CV": [
        "H",
        "hB"
    ],
    "CW": [
        "H",
        "hB"
    ],
    "CX": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "CY": [
        "h",
        "H",
        "hb",
        "hB"
    ],
    "CZ": [
        "H"
    ],
    "DE": [
        "H",
        "hB"
    ],
    "DG": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "DJ": [
        "h",
        "H"
    ],
    "DK": [
        "H"
    ],
    "DM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "DO": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "DZ": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "EA": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "EC": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "EE": [
        "H",
        "hB"
    ],
    "EG": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "EH": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "ER": [
        "h",
        "H"
    ],
    "ES": [
        "H",
        "hB",
        "h",
        "hb"
    ],
    "ET": [
        "hB",
        "hb",
        "h",
        "H"
    ],
    "FI": [
        "H"
    ],
    "FJ": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "FK": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "FM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "FO": [
        "H",
        "h"
    ],
    "FR": [
        "H",
        "hB"
    ],
    "GA": [
        "H",
        "hB"
    ],
    "GB": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "GD": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "GE": [
        "H",
        "hB",
        "h"
    ],
    "GF": [
        "H",
        "hB"
    ],
    "GG": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "GH": [
        "h",
        "H"
    ],
    "GI": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "GL": [
        "H",
        "h"
    ],
    "GM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "GN": [
        "H",
        "hB"
    ],
    "GP": [
        "H",
        "hB"
    ],
    "GQ": [
        "H",
        "hB",
        "h",
        "hb"
    ],
    "GR": [
        "h",
        "H",
        "hb",
        "hB"
    ],
    "GT": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "GU": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "GW": [
        "H",
        "hB"
    ],
    "GY": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "HK": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "HN": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "HR": [
        "H",
        "hB"
    ],
    "HU": [
        "H",
        "h"
    ],
    "IC": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "ID": [
        "H"
    ],
    "IE": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "IL": [
        "H",
        "hB"
    ],
    "IM": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "IN": [
        "h",
        "H"
    ],
    "IO": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "IQ": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "IR": [
        "hB",
        "H"
    ],
    "IS": [
        "H"
    ],
    "IT": [
        "H",
        "hB"
    ],
    "JE": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "JM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "JO": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "JP": [
        "H",
        "K",
        "h"
    ],
    "KE": [
        "hB",
        "hb",
        "H",
        "h"
    ],
    "KG": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "KH": [
        "hB",
        "h",
        "H",
        "hb"
    ],
    "KI": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "KM": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "KN": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "KP": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "KR": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "KW": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "KY": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "KZ": [
        "H",
        "hB"
    ],
    "LA": [
        "H",
        "hb",
        "hB",
        "h"
    ],
    "LB": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "LC": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "LI": [
        "H",
        "hB",
        "h"
    ],
    "LK": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "LR": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "LS": [
        "h",
        "H"
    ],
    "LT": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "LU": [
        "H",
        "h",
        "hB"
    ],
    "LV": [
        "H",
        "hB",
        "hb",
        "h"
    ],
    "LY": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "MA": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "MC": [
        "H",
        "hB"
    ],
    "MD": [
        "H",
        "hB"
    ],
    "ME": [
        "H",
        "hB",
        "h"
    ],
    "MF": [
        "H",
        "hB"
    ],
    "MG": [
        "H",
        "h"
    ],
    "MH": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "MK": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "ML": [
        "H"
    ],
    "MM": [
        "hB",
        "hb",
        "H",
        "h"
    ],
    "MN": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "MO": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "MP": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "MQ": [
        "H",
        "hB"
    ],
    "MR": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "MS": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "MT": [
        "H",
        "h"
    ],
    "MU": [
        "H",
        "h"
    ],
    "MV": [
        "H",
        "h"
    ],
    "MW": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "MX": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "MY": [
        "hb",
        "hB",
        "h",
        "H"
    ],
    "MZ": [
        "H",
        "hB"
    ],
    "NA": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "NC": [
        "H",
        "hB"
    ],
    "NE": [
        "H"
    ],
    "NF": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "NG": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "NI": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "NL": [
        "H",
        "hB"
    ],
    "NO": [
        "H",
        "h"
    ],
    "NP": [
        "H",
        "h",
        "hB"
    ],
    "NR": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "NU": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "NZ": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "OM": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "PA": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "PE": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "PF": [
        "H",
        "h",
        "hB"
    ],
    "PG": [
        "h",
        "H"
    ],
    "PH": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "PK": [
        "h",
        "hB",
        "H"
    ],
    "PL": [
        "H",
        "h"
    ],
    "PM": [
        "H",
        "hB"
    ],
    "PN": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "PR": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "PS": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "PT": [
        "H",
        "hB"
    ],
    "PW": [
        "h",
        "H"
    ],
    "PY": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "QA": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "RE": [
        "H",
        "hB"
    ],
    "RO": [
        "H",
        "hB"
    ],
    "RS": [
        "H",
        "hB",
        "h"
    ],
    "RU": [
        "H"
    ],
    "RW": [
        "H",
        "h"
    ],
    "SA": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "SB": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "SC": [
        "H",
        "h",
        "hB"
    ],
    "SD": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "SE": [
        "H"
    ],
    "SG": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "SH": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "SI": [
        "H",
        "hB"
    ],
    "SJ": [
        "H"
    ],
    "SK": [
        "H"
    ],
    "SL": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "SM": [
        "H",
        "h",
        "hB"
    ],
    "SN": [
        "H",
        "h",
        "hB"
    ],
    "SO": [
        "h",
        "H"
    ],
    "SR": [
        "H",
        "hB"
    ],
    "SS": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "ST": [
        "H",
        "hB"
    ],
    "SV": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "SX": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "SY": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "SZ": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "TA": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "TC": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "TD": [
        "h",
        "H",
        "hB"
    ],
    "TF": [
        "H",
        "h",
        "hB"
    ],
    "TG": [
        "H",
        "hB"
    ],
    "TH": [
        "H",
        "h"
    ],
    "TJ": [
        "H",
        "h"
    ],
    "TL": [
        "H",
        "hB",
        "hb",
        "h"
    ],
    "TM": [
        "H",
        "h"
    ],
    "TN": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "TO": [
        "h",
        "H"
    ],
    "TR": [
        "H",
        "hB"
    ],
    "TT": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "TW": [
        "hB",
        "hb",
        "h",
        "H"
    ],
    "TZ": [
        "hB",
        "hb",
        "H",
        "h"
    ],
    "UA": [
        "H",
        "hB",
        "h"
    ],
    "UG": [
        "hB",
        "hb",
        "H",
        "h"
    ],
    "UM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "US": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "UY": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "UZ": [
        "H",
        "hB",
        "h"
    ],
    "VA": [
        "H",
        "h",
        "hB"
    ],
    "VC": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "VE": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "VG": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "VI": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "VN": [
        "H",
        "h"
    ],
    "VU": [
        "h",
        "H"
    ],
    "WF": [
        "H",
        "hB"
    ],
    "WS": [
        "h",
        "H"
    ],
    "XK": [
        "H",
        "hB",
        "h"
    ],
    "YE": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "YT": [
        "H",
        "hB"
    ],
    "ZA": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "ZM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "ZW": [
        "H",
        "h"
    ],
    "af-ZA": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "ar-001": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "ca-ES": [
        "H",
        "h",
        "hB"
    ],
    "en-001": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "en-HK": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "en-IL": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "en-MY": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "es-BR": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "es-ES": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "es-GQ": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "fr-CA": [
        "H",
        "h",
        "hB"
    ],
    "gl-ES": [
        "H",
        "h",
        "hB"
    ],
    "gu-IN": [
        "hB",
        "hb",
        "h",
        "H"
    ],
    "hi-IN": [
        "hB",
        "h",
        "H"
    ],
    "it-CH": [
        "H",
        "h",
        "hB"
    ],
    "it-IT": [
        "H",
        "h",
        "hB"
    ],
    "kn-IN": [
        "hB",
        "h",
        "H"
    ],
    "ml-IN": [
        "hB",
        "h",
        "H"
    ],
    "mr-IN": [
        "hB",
        "hb",
        "h",
        "H"
    ],
    "pa-IN": [
        "hB",
        "hb",
        "h",
        "H"
    ],
    "ta-IN": [
        "hB",
        "h",
        "hb",
        "H"
    ],
    "te-IN": [
        "hB",
        "h",
        "H"
    ],
    "zu-ZA": [
        "H",
        "hB",
        "hb",
        "h"
    ]
};
}),
"[project]/node_modules/@formatjs/icu-messageformat-parser/lib/date-time-pattern-generator.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "getBestPattern": ()=>getBestPattern
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$time$2d$data$2e$generated$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/time-data.generated.js [app-client] (ecmascript)");
;
function getBestPattern(skeleton, locale) {
    var skeletonCopy = '';
    for(var patternPos = 0; patternPos < skeleton.length; patternPos++){
        var patternChar = skeleton.charAt(patternPos);
        if (patternChar === 'j') {
            var extraLength = 0;
            while(patternPos + 1 < skeleton.length && skeleton.charAt(patternPos + 1) === patternChar){
                extraLength++;
                patternPos++;
            }
            var hourLen = 1 + (extraLength & 1);
            var dayPeriodLen = extraLength < 2 ? 1 : 3 + (extraLength >> 1);
            var dayPeriodChar = 'a';
            var hourChar = getDefaultHourSymbolFromLocale(locale);
            if (hourChar == 'H' || hourChar == 'k') {
                dayPeriodLen = 0;
            }
            while(dayPeriodLen-- > 0){
                skeletonCopy += dayPeriodChar;
            }
            while(hourLen-- > 0){
                skeletonCopy = hourChar + skeletonCopy;
            }
        } else if (patternChar === 'J') {
            skeletonCopy += 'H';
        } else {
            skeletonCopy += patternChar;
        }
    }
    return skeletonCopy;
}
/**
 * Maps the [hour cycle type](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale/hourCycle)
 * of the given `locale` to the corresponding time pattern.
 * @param locale
 */ function getDefaultHourSymbolFromLocale(locale) {
    var hourCycle = locale.hourCycle;
    if (hourCycle === undefined && // @ts-ignore hourCycle(s) is not identified yet
    locale.hourCycles && // @ts-ignore
    locale.hourCycles.length) {
        // @ts-ignore
        hourCycle = locale.hourCycles[0];
    }
    if (hourCycle) {
        switch(hourCycle){
            case 'h24':
                return 'k';
            case 'h23':
                return 'H';
            case 'h12':
                return 'h';
            case 'h11':
                return 'K';
            default:
                throw new Error('Invalid hourCycle');
        }
    }
    // TODO: Once hourCycle is fully supported remove the following with data generation
    var languageTag = locale.language;
    var regionTag;
    if (languageTag !== 'root') {
        regionTag = locale.maximize().region;
    }
    var hourCycles = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$time$2d$data$2e$generated$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeData"][regionTag || ''] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$time$2d$data$2e$generated$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeData"][languageTag || ''] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$time$2d$data$2e$generated$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeData"]["".concat(languageTag, "-001")] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$time$2d$data$2e$generated$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeData"]['001'];
    return hourCycles[0];
}
}),
"[project]/node_modules/@formatjs/icu-messageformat-parser/lib/parser.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Parser": ()=>Parser
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/error.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/types.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$regex$2e$generated$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/regex.generated.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$skeleton$2d$parser$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-skeleton-parser/lib/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$skeleton$2d$parser$2f$lib$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-skeleton-parser/lib/number.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$skeleton$2d$parser$2f$lib$2f$date$2d$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-skeleton-parser/lib/date-time.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$date$2d$time$2d$pattern$2d$generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/date-time-pattern-generator.js [app-client] (ecmascript)");
var _a;
;
;
;
;
;
;
var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$regex$2e$generated$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SPACE_SEPARATOR_REGEX"].source, "*"));
var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$regex$2e$generated$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SPACE_SEPARATOR_REGEX"].source, "*$"));
function createLocation(start, end) {
    return {
        start: start,
        end: end
    };
}
// #region Ponyfills
// Consolidate these variables up top for easier toggling during debugging
var hasNativeStartsWith = !!String.prototype.startsWith && '_a'.startsWith('a', 1);
var hasNativeFromCodePoint = !!String.fromCodePoint;
var hasNativeFromEntries = !!Object.fromEntries;
var hasNativeCodePointAt = !!String.prototype.codePointAt;
var hasTrimStart = !!String.prototype.trimStart;
var hasTrimEnd = !!String.prototype.trimEnd;
var hasNativeIsSafeInteger = !!Number.isSafeInteger;
var isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function(n) {
    return typeof n === 'number' && isFinite(n) && Math.floor(n) === n && Math.abs(n) <= 0x1fffffffffffff;
};
// IE11 does not support y and u.
var REGEX_SUPPORTS_U_AND_Y = true;
try {
    var re = RE('([^\\p{White_Space}\\p{Pattern_Syntax}]*)', 'yu');
    /**
     * legacy Edge or Xbox One browser
     * Unicode flag support: supported
     * Pattern_Syntax support: not supported
     * See https://github.com/formatjs/formatjs/issues/2822
     */ REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';
} catch (_) {
    REGEX_SUPPORTS_U_AND_Y = false;
}
var startsWith = hasNativeStartsWith ? function startsWith(s, search, position) {
    return s.startsWith(search, position);
} : function startsWith(s, search, position) {
    return s.slice(position, position + search.length) === search;
};
var fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : function fromCodePoint() {
    var codePoints = [];
    for(var _i = 0; _i < arguments.length; _i++){
        codePoints[_i] = arguments[_i];
    }
    var elements = '';
    var length = codePoints.length;
    var i = 0;
    var code;
    while(length > i){
        code = codePoints[i++];
        if (code > 0x10ffff) throw RangeError(code + ' is not a valid code point');
        elements += code < 0x10000 ? String.fromCharCode(code) : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00);
    }
    return elements;
};
var fromEntries = // native
hasNativeFromEntries ? Object.fromEntries : function fromEntries(entries) {
    var obj = {};
    for(var _i = 0, entries_1 = entries; _i < entries_1.length; _i++){
        var _a = entries_1[_i], k = _a[0], v = _a[1];
        obj[k] = v;
    }
    return obj;
};
var codePointAt = hasNativeCodePointAt ? function codePointAt(s, index) {
    return s.codePointAt(index);
} : function codePointAt(s, index) {
    var size = s.length;
    if (index < 0 || index >= size) {
        return undefined;
    }
    var first = s.charCodeAt(index);
    var second;
    return first < 0xd800 || first > 0xdbff || index + 1 === size || (second = s.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? first : (first - 0xd800 << 10) + (second - 0xdc00) + 0x10000;
};
var trimStart = hasTrimStart ? function trimStart(s) {
    return s.trimStart();
} : function trimStart(s) {
    return s.replace(SPACE_SEPARATOR_START_REGEX, '');
};
var trimEnd = hasTrimEnd ? function trimEnd(s) {
    return s.trimEnd();
} : function trimEnd(s) {
    return s.replace(SPACE_SEPARATOR_END_REGEX, '');
};
// Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.
function RE(s, flag) {
    return new RegExp(s, flag);
}
// #endregion
var matchIdentifierAtIndex;
if (REGEX_SUPPORTS_U_AND_Y) {
    // Native
    var IDENTIFIER_PREFIX_RE_1 = RE('([^\\p{White_Space}\\p{Pattern_Syntax}]*)', 'yu');
    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {
        var _a;
        IDENTIFIER_PREFIX_RE_1.lastIndex = index;
        var match = IDENTIFIER_PREFIX_RE_1.exec(s);
        return (_a = match[1]) !== null && _a !== void 0 ? _a : '';
    };
} else {
    // IE11
    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {
        var match = [];
        while(true){
            var c = codePointAt(s, index);
            if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {
                break;
            }
            match.push(c);
            index += c >= 0x10000 ? 2 : 1;
        }
        return fromCodePoint.apply(void 0, match);
    };
}
var Parser = function() {
    function Parser(message, options) {
        if (options === void 0) {
            options = {};
        }
        this.message = message;
        this.position = {
            offset: 0,
            line: 1,
            column: 1
        };
        this.ignoreTag = !!options.ignoreTag;
        this.locale = options.locale;
        this.requiresOtherClause = !!options.requiresOtherClause;
        this.shouldParseSkeletons = !!options.shouldParseSkeletons;
    }
    Parser.prototype.parse = function() {
        if (this.offset() !== 0) {
            throw Error('parser can only be used once');
        }
        return this.parseMessage(0, '', false);
    };
    Parser.prototype.parseMessage = function(nestingLevel, parentArgType, expectingCloseTag) {
        var elements = [];
        while(!this.isEOF()){
            var char = this.char();
            if (char === 123 /* `{` */ ) {
                var result = this.parseArgument(nestingLevel, expectingCloseTag);
                if (result.err) {
                    return result;
                }
                elements.push(result.val);
            } else if (char === 125 /* `}` */  && nestingLevel > 0) {
                break;
            } else if (char === 35 /* `#` */  && (parentArgType === 'plural' || parentArgType === 'selectordinal')) {
                var position = this.clonePosition();
                this.bump();
                elements.push({
                    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE"].pound,
                    location: createLocation(position, this.clonePosition())
                });
            } else if (char === 60 /* `<` */  && !this.ignoreTag && this.peek() === 47 // char code for '/'
            ) {
                if (expectingCloseTag) {
                    break;
                } else {
                    return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
                }
            } else if (char === 60 /* `<` */  && !this.ignoreTag && _isAlpha(this.peek() || 0)) {
                var result = this.parseTag(nestingLevel, parentArgType);
                if (result.err) {
                    return result;
                }
                elements.push(result.val);
            } else {
                var result = this.parseLiteral(nestingLevel, parentArgType);
                if (result.err) {
                    return result;
                }
                elements.push(result.val);
            }
        }
        return {
            val: elements,
            err: null
        };
    };
    /**
     * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the
     * [custom element name][] except that a dash is NOT always mandatory and uppercase letters
     * are accepted:
     *
     * ```
     * tag ::= "<" tagName (whitespace)* "/>" | "<" tagName (whitespace)* ">" message "</" tagName (whitespace)* ">"
     * tagName ::= [a-z] (PENChar)*
     * PENChar ::=
     *     "-" | "." | [0-9] | "_" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |
     *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |
     *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
     * ```
     *
     * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
     * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do
     * since other tag-based engines like React allow it
     */ Parser.prototype.parseTag = function(nestingLevel, parentArgType) {
        var startPosition = this.clonePosition();
        this.bump(); // `<`
        var tagName = this.parseTagName();
        this.bumpSpace();
        if (this.bumpIf('/>')) {
            // Self closing tag
            return {
                val: {
                    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE"].literal,
                    value: "<".concat(tagName, "/>"),
                    location: createLocation(startPosition, this.clonePosition())
                },
                err: null
            };
        } else if (this.bumpIf('>')) {
            var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
            if (childrenResult.err) {
                return childrenResult;
            }
            var children = childrenResult.val;
            // Expecting a close tag
            var endTagStartPosition = this.clonePosition();
            if (this.bumpIf('</')) {
                if (this.isEOF() || !_isAlpha(this.char())) {
                    return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
                }
                var closingTagNameStartPosition = this.clonePosition();
                var closingTagName = this.parseTagName();
                if (tagName !== closingTagName) {
                    return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
                }
                this.bumpSpace();
                if (!this.bumpIf('>')) {
                    return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
                }
                return {
                    val: {
                        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE"].tag,
                        value: tagName,
                        children: children,
                        location: createLocation(startPosition, this.clonePosition())
                    },
                    err: null
                };
            } else {
                return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
            }
        } else {
            return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].INVALID_TAG, createLocation(startPosition, this.clonePosition()));
        }
    };
    /**
     * This method assumes that the caller has peeked ahead for the first tag character.
     */ Parser.prototype.parseTagName = function() {
        var startOffset = this.offset();
        this.bump(); // the first tag name character
        while(!this.isEOF() && _isPotentialElementNameChar(this.char())){
            this.bump();
        }
        return this.message.slice(startOffset, this.offset());
    };
    Parser.prototype.parseLiteral = function(nestingLevel, parentArgType) {
        var start = this.clonePosition();
        var value = '';
        while(true){
            var parseQuoteResult = this.tryParseQuote(parentArgType);
            if (parseQuoteResult) {
                value += parseQuoteResult;
                continue;
            }
            var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
            if (parseUnquotedResult) {
                value += parseUnquotedResult;
                continue;
            }
            var parseLeftAngleResult = this.tryParseLeftAngleBracket();
            if (parseLeftAngleResult) {
                value += parseLeftAngleResult;
                continue;
            }
            break;
        }
        var location = createLocation(start, this.clonePosition());
        return {
            val: {
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE"].literal,
                value: value,
                location: location
            },
            err: null
        };
    };
    Parser.prototype.tryParseLeftAngleBracket = function() {
        if (!this.isEOF() && this.char() === 60 /* `<` */  && (this.ignoreTag || // If at the opening tag or closing tag position, bail.
        !_isAlphaOrSlash(this.peek() || 0))) {
            this.bump(); // `<`
            return '<';
        }
        return null;
    };
    /**
     * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes
     * a character that requires quoting (that is, "only where needed"), and works the same in
     * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.
     */ Parser.prototype.tryParseQuote = function(parentArgType) {
        if (this.isEOF() || this.char() !== 39 /* `'` */ ) {
            return null;
        }
        // Parse escaped char following the apostrophe, or early return if there is no escaped char.
        // Check if is valid escaped character
        switch(this.peek()){
            case 39 /* `'` */ :
                // double quote, should return as a single quote.
                this.bump();
                this.bump();
                return "'";
            // '{', '<', '>', '}'
            case 123:
            case 60:
            case 62:
            case 125:
                break;
            case 35:
                if (parentArgType === 'plural' || parentArgType === 'selectordinal') {
                    break;
                }
                return null;
            default:
                return null;
        }
        this.bump(); // apostrophe
        var codePoints = [
            this.char()
        ]; // escaped char
        this.bump();
        // read chars until the optional closing apostrophe is found
        while(!this.isEOF()){
            var ch = this.char();
            if (ch === 39 /* `'` */ ) {
                if (this.peek() === 39 /* `'` */ ) {
                    codePoints.push(39);
                    // Bump one more time because we need to skip 2 characters.
                    this.bump();
                } else {
                    // Optional closing apostrophe.
                    this.bump();
                    break;
                }
            } else {
                codePoints.push(ch);
            }
            this.bump();
        }
        return fromCodePoint.apply(void 0, codePoints);
    };
    Parser.prototype.tryParseUnquoted = function(nestingLevel, parentArgType) {
        if (this.isEOF()) {
            return null;
        }
        var ch = this.char();
        if (ch === 60 /* `<` */  || ch === 123 /* `{` */  || ch === 35 /* `#` */  && (parentArgType === 'plural' || parentArgType === 'selectordinal') || ch === 125 /* `}` */  && nestingLevel > 0) {
            return null;
        } else {
            this.bump();
            return fromCodePoint(ch);
        }
    };
    Parser.prototype.parseArgument = function(nestingLevel, expectingCloseTag) {
        var openingBracePosition = this.clonePosition();
        this.bump(); // `{`
        this.bumpSpace();
        if (this.isEOF()) {
            return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
        }
        if (this.char() === 125 /* `}` */ ) {
            this.bump();
            return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
        }
        // argument name
        var value = this.parseIdentifierIfPossible().value;
        if (!value) {
            return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
        }
        this.bumpSpace();
        if (this.isEOF()) {
            return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
        }
        switch(this.char()){
            // Simple argument: `{name}`
            case 125 /* `}` */ :
                {
                    this.bump(); // `}`
                    return {
                        val: {
                            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE"].argument,
                            // value does not include the opening and closing braces.
                            value: value,
                            location: createLocation(openingBracePosition, this.clonePosition())
                        },
                        err: null
                    };
                }
            // Argument with options: `{name, format, ...}`
            case 44 /* `,` */ :
                {
                    this.bump(); // `,`
                    this.bumpSpace();
                    if (this.isEOF()) {
                        return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
                    }
                    return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);
                }
            default:
                return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
        }
    };
    /**
     * Advance the parser until the end of the identifier, if it is currently on
     * an identifier character. Return an empty string otherwise.
     */ Parser.prototype.parseIdentifierIfPossible = function() {
        var startingPosition = this.clonePosition();
        var startOffset = this.offset();
        var value = matchIdentifierAtIndex(this.message, startOffset);
        var endOffset = startOffset + value.length;
        this.bumpTo(endOffset);
        var endPosition = this.clonePosition();
        var location = createLocation(startingPosition, endPosition);
        return {
            value: value,
            location: location
        };
    };
    Parser.prototype.parseArgumentOptions = function(nestingLevel, expectingCloseTag, value, openingBracePosition) {
        var _a;
        // Parse this range:
        // {name, type, style}
        //        ^---^
        var typeStartPosition = this.clonePosition();
        var argType = this.parseIdentifierIfPossible().value;
        var typeEndPosition = this.clonePosition();
        switch(argType){
            case '':
                // Expecting a style string number, date, time, plural, selectordinal, or select.
                return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
            case 'number':
            case 'date':
            case 'time':
                {
                    // Parse this range:
                    // {name, number, style}
                    //              ^-------^
                    this.bumpSpace();
                    var styleAndLocation = null;
                    if (this.bumpIf(',')) {
                        this.bumpSpace();
                        var styleStartPosition = this.clonePosition();
                        var result = this.parseSimpleArgStyleIfPossible();
                        if (result.err) {
                            return result;
                        }
                        var style = trimEnd(result.val);
                        if (style.length === 0) {
                            return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
                        }
                        var styleLocation = createLocation(styleStartPosition, this.clonePosition());
                        styleAndLocation = {
                            style: style,
                            styleLocation: styleLocation
                        };
                    }
                    var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                    if (argCloseResult.err) {
                        return argCloseResult;
                    }
                    var location_1 = createLocation(openingBracePosition, this.clonePosition());
                    // Extract style or skeleton
                    if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {
                        // Skeleton starts with `::`.
                        var skeleton = trimStart(styleAndLocation.style.slice(2));
                        if (argType === 'number') {
                            var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
                            if (result.err) {
                                return result;
                            }
                            return {
                                val: {
                                    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE"].number,
                                    value: value,
                                    location: location_1,
                                    style: result.val
                                },
                                err: null
                            };
                        } else {
                            if (skeleton.length === 0) {
                                return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].EXPECT_DATE_TIME_SKELETON, location_1);
                            }
                            var dateTimePattern = skeleton;
                            // Get "best match" pattern only if locale is passed, if not, let it
                            // pass as-is where `parseDateTimeSkeleton()` will throw an error
                            // for unsupported patterns.
                            if (this.locale) {
                                dateTimePattern = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$date$2d$time$2d$pattern$2d$generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBestPattern"])(skeleton, this.locale);
                            }
                            var style = {
                                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SKELETON_TYPE"].dateTime,
                                pattern: dateTimePattern,
                                location: styleAndLocation.styleLocation,
                                parsedOptions: this.shouldParseSkeletons ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$skeleton$2d$parser$2f$lib$2f$date$2d$time$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseDateTimeSkeleton"])(dateTimePattern) : {}
                            };
                            var type = argType === 'date' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE"].date : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE"].time;
                            return {
                                val: {
                                    type: type,
                                    value: value,
                                    location: location_1,
                                    style: style
                                },
                                err: null
                            };
                        }
                    }
                    // Regular style or no style.
                    return {
                        val: {
                            type: argType === 'number' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE"].number : argType === 'date' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE"].date : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE"].time,
                            value: value,
                            location: location_1,
                            style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null
                        },
                        err: null
                    };
                }
            case 'plural':
            case 'selectordinal':
            case 'select':
                {
                    // Parse this range:
                    // {name, plural, options}
                    //              ^---------^
                    var typeEndPosition_1 = this.clonePosition();
                    this.bumpSpace();
                    if (!this.bumpIf(',')) {
                        return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, typeEndPosition_1)));
                    }
                    this.bumpSpace();
                    // Parse offset:
                    // {name, plural, offset:1, options}
                    //                ^-----^
                    //
                    // or the first option:
                    //
                    // {name, plural, one {...} other {...}}
                    //                ^--^
                    var identifierAndLocation = this.parseIdentifierIfPossible();
                    var pluralOffset = 0;
                    if (argType !== 'select' && identifierAndLocation.value === 'offset') {
                        if (!this.bumpIf(':')) {
                            return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
                        }
                        this.bumpSpace();
                        var result = this.tryParseDecimalInteger(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
                        if (result.err) {
                            return result;
                        }
                        // Parse another identifier for option parsing
                        this.bumpSpace();
                        identifierAndLocation = this.parseIdentifierIfPossible();
                        pluralOffset = result.val;
                    }
                    var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
                    if (optionsResult.err) {
                        return optionsResult;
                    }
                    var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                    if (argCloseResult.err) {
                        return argCloseResult;
                    }
                    var location_2 = createLocation(openingBracePosition, this.clonePosition());
                    if (argType === 'select') {
                        return {
                            val: {
                                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE"].select,
                                value: value,
                                options: fromEntries(optionsResult.val),
                                location: location_2
                            },
                            err: null
                        };
                    } else {
                        return {
                            val: {
                                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE"].plural,
                                value: value,
                                options: fromEntries(optionsResult.val),
                                offset: pluralOffset,
                                pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',
                                location: location_2
                            },
                            err: null
                        };
                    }
                }
            default:
                return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
        }
    };
    Parser.prototype.tryParseArgumentClose = function(openingBracePosition) {
        // Parse: {value, number, ::currency/GBP }
        //
        if (this.isEOF() || this.char() !== 125 /* `}` */ ) {
            return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
        }
        this.bump(); // `}`
        return {
            val: true,
            err: null
        };
    };
    /**
     * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659
     */ Parser.prototype.parseSimpleArgStyleIfPossible = function() {
        var nestedBraces = 0;
        var startPosition = this.clonePosition();
        while(!this.isEOF()){
            var ch = this.char();
            switch(ch){
                case 39 /* `'` */ :
                    {
                        // Treat apostrophe as quoting but include it in the style part.
                        // Find the end of the quoted literal text.
                        this.bump();
                        var apostrophePosition = this.clonePosition();
                        if (!this.bumpUntil("'")) {
                            return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
                        }
                        this.bump();
                        break;
                    }
                case 123 /* `{` */ :
                    {
                        nestedBraces += 1;
                        this.bump();
                        break;
                    }
                case 125 /* `}` */ :
                    {
                        if (nestedBraces > 0) {
                            nestedBraces -= 1;
                        } else {
                            return {
                                val: this.message.slice(startPosition.offset, this.offset()),
                                err: null
                            };
                        }
                        break;
                    }
                default:
                    this.bump();
                    break;
            }
        }
        return {
            val: this.message.slice(startPosition.offset, this.offset()),
            err: null
        };
    };
    Parser.prototype.parseNumberSkeletonFromString = function(skeleton, location) {
        var tokens = [];
        try {
            tokens = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$skeleton$2d$parser$2f$lib$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseNumberSkeletonFromString"])(skeleton);
        } catch (e) {
            return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].INVALID_NUMBER_SKELETON, location);
        }
        return {
            val: {
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SKELETON_TYPE"].number,
                tokens: tokens,
                location: location,
                parsedOptions: this.shouldParseSkeletons ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$skeleton$2d$parser$2f$lib$2f$number$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseNumberSkeleton"])(tokens) : {}
            },
            err: null
        };
    };
    /**
     * @param nesting_level The current nesting level of messages.
     *     This can be positive when parsing message fragment in select or plural argument options.
     * @param parent_arg_type The parent argument's type.
     * @param parsed_first_identifier If provided, this is the first identifier-like selector of
     *     the argument. It is a by-product of a previous parsing attempt.
     * @param expecting_close_tag If true, this message is directly or indirectly nested inside
     *     between a pair of opening and closing tags. The nested message will not parse beyond
     *     the closing tag boundary.
     */ Parser.prototype.tryParsePluralOrSelectOptions = function(nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
        var _a;
        var hasOtherClause = false;
        var options = [];
        var parsedSelectors = new Set();
        var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
        // Parse:
        // one {one apple}
        // ^--^
        while(true){
            if (selector.length === 0) {
                var startPosition = this.clonePosition();
                if (parentArgType !== 'select' && this.bumpIf('=')) {
                    // Try parse `={number}` selector
                    var result = this.tryParseDecimalInteger(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].EXPECT_PLURAL_ARGUMENT_SELECTOR, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].INVALID_PLURAL_ARGUMENT_SELECTOR);
                    if (result.err) {
                        return result;
                    }
                    selectorLocation = createLocation(startPosition, this.clonePosition());
                    selector = this.message.slice(startPosition.offset, this.offset());
                } else {
                    break;
                }
            }
            // Duplicate selector clauses
            if (parsedSelectors.has(selector)) {
                return this.error(parentArgType === 'select' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].DUPLICATE_SELECT_ARGUMENT_SELECTOR : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
            }
            if (selector === 'other') {
                hasOtherClause = true;
            }
            // Parse:
            // one {one apple}
            //     ^----------^
            this.bumpSpace();
            var openingBracePosition = this.clonePosition();
            if (!this.bumpIf('{')) {
                return this.error(parentArgType === 'select' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
            }
            var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
            if (fragmentResult.err) {
                return fragmentResult;
            }
            var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
            if (argCloseResult.err) {
                return argCloseResult;
            }
            options.push([
                selector,
                {
                    value: fragmentResult.val,
                    location: createLocation(openingBracePosition, this.clonePosition())
                }
            ]);
            // Keep track of the existing selectors
            parsedSelectors.add(selector);
            // Prep next selector clause.
            this.bumpSpace();
            _a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location;
        }
        if (options.length === 0) {
            return this.error(parentArgType === 'select' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].EXPECT_SELECT_ARGUMENT_SELECTOR : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
        }
        if (this.requiresOtherClause && !hasOtherClause) {
            return this.error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"].MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
        }
        return {
            val: options,
            err: null
        };
    };
    Parser.prototype.tryParseDecimalInteger = function(expectNumberError, invalidNumberError) {
        var sign = 1;
        var startingPosition = this.clonePosition();
        if (this.bumpIf('+')) {} else if (this.bumpIf('-')) {
            sign = -1;
        }
        var hasDigits = false;
        var decimal = 0;
        while(!this.isEOF()){
            var ch = this.char();
            if (ch >= 48 /* `0` */  && ch <= 57 /* `9` */ ) {
                hasDigits = true;
                decimal = decimal * 10 + (ch - 48);
                this.bump();
            } else {
                break;
            }
        }
        var location = createLocation(startingPosition, this.clonePosition());
        if (!hasDigits) {
            return this.error(expectNumberError, location);
        }
        decimal *= sign;
        if (!isSafeInteger(decimal)) {
            return this.error(invalidNumberError, location);
        }
        return {
            val: decimal,
            err: null
        };
    };
    Parser.prototype.offset = function() {
        return this.position.offset;
    };
    Parser.prototype.isEOF = function() {
        return this.offset() === this.message.length;
    };
    Parser.prototype.clonePosition = function() {
        // This is much faster than `Object.assign` or spread.
        return {
            offset: this.position.offset,
            line: this.position.line,
            column: this.position.column
        };
    };
    /**
     * Return the code point at the current position of the parser.
     * Throws if the index is out of bound.
     */ Parser.prototype.char = function() {
        var offset = this.position.offset;
        if (offset >= this.message.length) {
            throw Error('out of bound');
        }
        var code = codePointAt(this.message, offset);
        if (code === undefined) {
            throw Error("Offset ".concat(offset, " is at invalid UTF-16 code unit boundary"));
        }
        return code;
    };
    Parser.prototype.error = function(kind, location) {
        return {
            val: null,
            err: {
                kind: kind,
                message: this.message,
                location: location
            }
        };
    };
    /** Bump the parser to the next UTF-16 code unit. */ Parser.prototype.bump = function() {
        if (this.isEOF()) {
            return;
        }
        var code = this.char();
        if (code === 10 /* '\n' */ ) {
            this.position.line += 1;
            this.position.column = 1;
            this.position.offset += 1;
        } else {
            this.position.column += 1;
            // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.
            this.position.offset += code < 0x10000 ? 1 : 2;
        }
    };
    /**
     * If the substring starting at the current position of the parser has
     * the given prefix, then bump the parser to the character immediately
     * following the prefix and return true. Otherwise, don't bump the parser
     * and return false.
     */ Parser.prototype.bumpIf = function(prefix) {
        if (startsWith(this.message, prefix, this.offset())) {
            for(var i = 0; i < prefix.length; i++){
                this.bump();
            }
            return true;
        }
        return false;
    };
    /**
     * Bump the parser until the pattern character is found and return `true`.
     * Otherwise bump to the end of the file and return `false`.
     */ Parser.prototype.bumpUntil = function(pattern) {
        var currentOffset = this.offset();
        var index = this.message.indexOf(pattern, currentOffset);
        if (index >= 0) {
            this.bumpTo(index);
            return true;
        } else {
            this.bumpTo(this.message.length);
            return false;
        }
    };
    /**
     * Bump the parser to the target offset.
     * If target offset is beyond the end of the input, bump the parser to the end of the input.
     */ Parser.prototype.bumpTo = function(targetOffset) {
        if (this.offset() > targetOffset) {
            throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
        }
        targetOffset = Math.min(targetOffset, this.message.length);
        while(true){
            var offset = this.offset();
            if (offset === targetOffset) {
                break;
            }
            if (offset > targetOffset) {
                throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
            }
            this.bump();
            if (this.isEOF()) {
                break;
            }
        }
    };
    /** advance the parser through all whitespace to the next non-whitespace code unit. */ Parser.prototype.bumpSpace = function() {
        while(!this.isEOF() && _isWhiteSpace(this.char())){
            this.bump();
        }
    };
    /**
     * Peek at the *next* Unicode codepoint in the input without advancing the parser.
     * If the input has been exhausted, then this returns null.
     */ Parser.prototype.peek = function() {
        if (this.isEOF()) {
            return null;
        }
        var code = this.char();
        var offset = this.offset();
        var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));
        return nextCode !== null && nextCode !== void 0 ? nextCode : null;
    };
    return Parser;
}();
;
/**
 * This check if codepoint is alphabet (lower & uppercase)
 * @param codepoint
 * @returns
 */ function _isAlpha(codepoint) {
    return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;
}
function _isAlphaOrSlash(codepoint) {
    return _isAlpha(codepoint) || codepoint === 47; /* '/' */ 
}
/** See `parseTag` function docs. */ function _isPotentialElementNameChar(c) {
    return c === 45 /* '-' */  || c === 46 /* '.' */  || c >= 48 && c <= 57 || c === 95 /* '_' */  || c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 0xb7 || c >= 0xc0 && c <= 0xd6 || c >= 0xd8 && c <= 0xf6 || c >= 0xf8 && c <= 0x37d || c >= 0x37f && c <= 0x1fff || c >= 0x200c && c <= 0x200d || c >= 0x203f && c <= 0x2040 || c >= 0x2070 && c <= 0x218f || c >= 0x2c00 && c <= 0x2fef || c >= 0x3001 && c <= 0xd7ff || c >= 0xf900 && c <= 0xfdcf || c >= 0xfdf0 && c <= 0xfffd || c >= 0x10000 && c <= 0xeffff;
}
/**
 * Code point equivalent of regex `\p{White_Space}`.
 * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
 */ function _isWhiteSpace(c) {
    return c >= 0x0009 && c <= 0x000d || c === 0x0020 || c === 0x0085 || c >= 0x200e && c <= 0x200f || c === 0x2028 || c === 0x2029;
}
/**
 * Code point equivalent of regex `\p{Pattern_Syntax}`.
 * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
 */ function _isPatternSyntax(c) {
    return c >= 0x0021 && c <= 0x0023 || c === 0x0024 || c >= 0x0025 && c <= 0x0027 || c === 0x0028 || c === 0x0029 || c === 0x002a || c === 0x002b || c === 0x002c || c === 0x002d || c >= 0x002e && c <= 0x002f || c >= 0x003a && c <= 0x003b || c >= 0x003c && c <= 0x003e || c >= 0x003f && c <= 0x0040 || c === 0x005b || c === 0x005c || c === 0x005d || c === 0x005e || c === 0x0060 || c === 0x007b || c === 0x007c || c === 0x007d || c === 0x007e || c === 0x00a1 || c >= 0x00a2 && c <= 0x00a5 || c === 0x00a6 || c === 0x00a7 || c === 0x00a9 || c === 0x00ab || c === 0x00ac || c === 0x00ae || c === 0x00b0 || c === 0x00b1 || c === 0x00b6 || c === 0x00bb || c === 0x00bf || c === 0x00d7 || c === 0x00f7 || c >= 0x2010 && c <= 0x2015 || c >= 0x2016 && c <= 0x2017 || c === 0x2018 || c === 0x2019 || c === 0x201a || c >= 0x201b && c <= 0x201c || c === 0x201d || c === 0x201e || c === 0x201f || c >= 0x2020 && c <= 0x2027 || c >= 0x2030 && c <= 0x2038 || c === 0x2039 || c === 0x203a || c >= 0x203b && c <= 0x203e || c >= 0x2041 && c <= 0x2043 || c === 0x2044 || c === 0x2045 || c === 0x2046 || c >= 0x2047 && c <= 0x2051 || c === 0x2052 || c === 0x2053 || c >= 0x2055 && c <= 0x205e || c >= 0x2190 && c <= 0x2194 || c >= 0x2195 && c <= 0x2199 || c >= 0x219a && c <= 0x219b || c >= 0x219c && c <= 0x219f || c === 0x21a0 || c >= 0x21a1 && c <= 0x21a2 || c === 0x21a3 || c >= 0x21a4 && c <= 0x21a5 || c === 0x21a6 || c >= 0x21a7 && c <= 0x21ad || c === 0x21ae || c >= 0x21af && c <= 0x21cd || c >= 0x21ce && c <= 0x21cf || c >= 0x21d0 && c <= 0x21d1 || c === 0x21d2 || c === 0x21d3 || c === 0x21d4 || c >= 0x21d5 && c <= 0x21f3 || c >= 0x21f4 && c <= 0x22ff || c >= 0x2300 && c <= 0x2307 || c === 0x2308 || c === 0x2309 || c === 0x230a || c === 0x230b || c >= 0x230c && c <= 0x231f || c >= 0x2320 && c <= 0x2321 || c >= 0x2322 && c <= 0x2328 || c === 0x2329 || c === 0x232a || c >= 0x232b && c <= 0x237b || c === 0x237c || c >= 0x237d && c <= 0x239a || c >= 0x239b && c <= 0x23b3 || c >= 0x23b4 && c <= 0x23db || c >= 0x23dc && c <= 0x23e1 || c >= 0x23e2 && c <= 0x2426 || c >= 0x2427 && c <= 0x243f || c >= 0x2440 && c <= 0x244a || c >= 0x244b && c <= 0x245f || c >= 0x2500 && c <= 0x25b6 || c === 0x25b7 || c >= 0x25b8 && c <= 0x25c0 || c === 0x25c1 || c >= 0x25c2 && c <= 0x25f7 || c >= 0x25f8 && c <= 0x25ff || c >= 0x2600 && c <= 0x266e || c === 0x266f || c >= 0x2670 && c <= 0x2767 || c === 0x2768 || c === 0x2769 || c === 0x276a || c === 0x276b || c === 0x276c || c === 0x276d || c === 0x276e || c === 0x276f || c === 0x2770 || c === 0x2771 || c === 0x2772 || c === 0x2773 || c === 0x2774 || c === 0x2775 || c >= 0x2794 && c <= 0x27bf || c >= 0x27c0 && c <= 0x27c4 || c === 0x27c5 || c === 0x27c6 || c >= 0x27c7 && c <= 0x27e5 || c === 0x27e6 || c === 0x27e7 || c === 0x27e8 || c === 0x27e9 || c === 0x27ea || c === 0x27eb || c === 0x27ec || c === 0x27ed || c === 0x27ee || c === 0x27ef || c >= 0x27f0 && c <= 0x27ff || c >= 0x2800 && c <= 0x28ff || c >= 0x2900 && c <= 0x2982 || c === 0x2983 || c === 0x2984 || c === 0x2985 || c === 0x2986 || c === 0x2987 || c === 0x2988 || c === 0x2989 || c === 0x298a || c === 0x298b || c === 0x298c || c === 0x298d || c === 0x298e || c === 0x298f || c === 0x2990 || c === 0x2991 || c === 0x2992 || c === 0x2993 || c === 0x2994 || c === 0x2995 || c === 0x2996 || c === 0x2997 || c === 0x2998 || c >= 0x2999 && c <= 0x29d7 || c === 0x29d8 || c === 0x29d9 || c === 0x29da || c === 0x29db || c >= 0x29dc && c <= 0x29fb || c === 0x29fc || c === 0x29fd || c >= 0x29fe && c <= 0x2aff || c >= 0x2b00 && c <= 0x2b2f || c >= 0x2b30 && c <= 0x2b44 || c >= 0x2b45 && c <= 0x2b46 || c >= 0x2b47 && c <= 0x2b4c || c >= 0x2b4d && c <= 0x2b73 || c >= 0x2b74 && c <= 0x2b75 || c >= 0x2b76 && c <= 0x2b95 || c === 0x2b96 || c >= 0x2b97 && c <= 0x2bff || c >= 0x2e00 && c <= 0x2e01 || c === 0x2e02 || c === 0x2e03 || c === 0x2e04 || c === 0x2e05 || c >= 0x2e06 && c <= 0x2e08 || c === 0x2e09 || c === 0x2e0a || c === 0x2e0b || c === 0x2e0c || c === 0x2e0d || c >= 0x2e0e && c <= 0x2e16 || c === 0x2e17 || c >= 0x2e18 && c <= 0x2e19 || c === 0x2e1a || c === 0x2e1b || c === 0x2e1c || c === 0x2e1d || c >= 0x2e1e && c <= 0x2e1f || c === 0x2e20 || c === 0x2e21 || c === 0x2e22 || c === 0x2e23 || c === 0x2e24 || c === 0x2e25 || c === 0x2e26 || c === 0x2e27 || c === 0x2e28 || c === 0x2e29 || c >= 0x2e2a && c <= 0x2e2e || c === 0x2e2f || c >= 0x2e30 && c <= 0x2e39 || c >= 0x2e3a && c <= 0x2e3b || c >= 0x2e3c && c <= 0x2e3f || c === 0x2e40 || c === 0x2e41 || c === 0x2e42 || c >= 0x2e43 && c <= 0x2e4f || c >= 0x2e50 && c <= 0x2e51 || c === 0x2e52 || c >= 0x2e53 && c <= 0x2e7f || c >= 0x3001 && c <= 0x3003 || c === 0x3008 || c === 0x3009 || c === 0x300a || c === 0x300b || c === 0x300c || c === 0x300d || c === 0x300e || c === 0x300f || c === 0x3010 || c === 0x3011 || c >= 0x3012 && c <= 0x3013 || c === 0x3014 || c === 0x3015 || c === 0x3016 || c === 0x3017 || c === 0x3018 || c === 0x3019 || c === 0x301a || c === 0x301b || c === 0x301c || c === 0x301d || c >= 0x301e && c <= 0x301f || c === 0x3020 || c === 0x3030 || c === 0xfd3e || c === 0xfd3f || c >= 0xfe45 && c <= 0xfe46;
}
}),
"[project]/node_modules/@formatjs/icu-messageformat-parser/lib/manipulator.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "hoistSelectors": ()=>hoistSelectors,
    "isStructurallySame": ()=>isStructurallySame
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/types.js [app-client] (ecmascript)");
;
;
function cloneDeep(obj) {
    if (Array.isArray(obj)) {
        // @ts-expect-error meh
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__spreadArray"])([], obj.map(cloneDeep), true);
    }
    if (obj !== null && typeof obj === 'object') {
        // @ts-expect-error meh
        return Object.keys(obj).reduce(function(cloned, k) {
            // @ts-expect-error meh
            cloned[k] = cloneDeep(obj[k]);
            return cloned;
        }, {});
    }
    return obj;
}
function hoistPluralOrSelectElement(ast, el, positionToInject) {
    // pull this out of the ast and move it to the top
    var cloned = cloneDeep(el);
    var options = cloned.options;
    cloned.options = Object.keys(options).reduce(function(all, k) {
        var newValue = hoistSelectors((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__spreadArray"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__spreadArray"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__spreadArray"])([], ast.slice(0, positionToInject), true), options[k].value, true), ast.slice(positionToInject + 1), true));
        all[k] = {
            value: newValue
        };
        return all;
    }, {});
    return cloned;
}
function isPluralOrSelectElement(el) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPluralElement"])(el) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectElement"])(el);
}
function findPluralOrSelectElement(ast) {
    return !!ast.find(function(el) {
        if (isPluralOrSelectElement(el)) {
            return true;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTagElement"])(el)) {
            return findPluralOrSelectElement(el.children);
        }
        return false;
    });
}
function hoistSelectors(ast) {
    for(var i = 0; i < ast.length; i++){
        var el = ast[i];
        if (isPluralOrSelectElement(el)) {
            return [
                hoistPluralOrSelectElement(ast, el, i)
            ];
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTagElement"])(el) && findPluralOrSelectElement([
            el
        ])) {
            throw new Error('Cannot hoist plural/select within a tag element. Please put the tag element inside each plural/select option');
        }
    }
    return ast;
}
/**
 * Collect all variables in an AST to Record<string, TYPE>
 * @param ast AST to collect variables from
 * @param vars Record of variable name to variable type
 */ function collectVariables(ast, vars) {
    if (vars === void 0) {
        vars = new Map();
    }
    ast.forEach(function(el) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArgumentElement"])(el) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDateElement"])(el) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTimeElement"])(el) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberElement"])(el)) {
            if (el.value in vars && vars.get(el.value) !== el.type) {
                throw new Error("Variable ".concat(el.value, " has conflicting types"));
            }
            vars.set(el.value, el.type);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPluralElement"])(el) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectElement"])(el)) {
            vars.set(el.value, el.type);
            Object.keys(el.options).forEach(function(k) {
                collectVariables(el.options[k].value, vars);
            });
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTagElement"])(el)) {
            vars.set(el.value, el.type);
            collectVariables(el.children, vars);
        }
    });
}
function isStructurallySame(a, b) {
    var aVars = new Map();
    var bVars = new Map();
    collectVariables(a, aVars);
    collectVariables(b, bVars);
    if (aVars.size !== bVars.size) {
        return {
            success: false,
            error: new Error("Different number of variables: [".concat(Array.from(aVars.keys()).join(', '), "] vs [").concat(Array.from(bVars.keys()).join(', '), "]"))
        };
    }
    return Array.from(aVars.entries()).reduce(function(result, _a) {
        var key = _a[0], type = _a[1];
        if (!result.success) {
            return result;
        }
        var bType = bVars.get(key);
        if (bType == null) {
            return {
                success: false,
                error: new Error("Missing variable ".concat(key, " in message"))
            };
        }
        if (bType !== type) {
            return {
                success: false,
                error: new Error("Variable ".concat(key, " has conflicting types: ").concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE"][type], " vs ").concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TYPE"][bType]))
            };
        }
        return result;
    }, {
        success: true
    });
}
}),
"[project]/node_modules/@formatjs/icu-messageformat-parser/lib/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "_Parser": ()=>_Parser,
    "parse": ()=>parse
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/error.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/parser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/types.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$manipulator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/manipulator.js [app-client] (ecmascript)");
;
;
;
;
function pruneLocation(els) {
    els.forEach(function(el) {
        delete el.location;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectElement"])(el) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPluralElement"])(el)) {
            for(var k in el.options){
                delete el.options[k].location;
                pruneLocation(el.options[k].value);
            }
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberElement"])(el) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberSkeleton"])(el.style)) {
            delete el.style.location;
        } else if (((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDateElement"])(el) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTimeElement"])(el)) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDateTimeSkeleton"])(el.style)) {
            delete el.style.location;
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTagElement"])(el)) {
            pruneLocation(el.children);
        }
    });
}
function parse(message, opts) {
    if (opts === void 0) {
        opts = {};
    }
    opts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({
        shouldParseSkeletons: true,
        requiresOtherClause: true
    }, opts);
    var result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Parser"](message, opts).parse();
    if (result.err) {
        var error = SyntaxError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorKind"][result.err.kind]);
        // @ts-expect-error Assign to error object
        error.location = result.err.location;
        // @ts-expect-error Assign to error object
        error.originalMessage = result.err.message;
        throw error;
    }
    if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
        pruneLocation(result.val);
    }
    return result.val;
}
;
var _Parser = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Parser"];
;
}),
"[project]/node_modules/@formatjs/icu-messageformat-parser/lib/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/error.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/parser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/types.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$manipulator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/manipulator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/index.js [app-client] (ecmascript) <locals>");
}),
"[project]/node_modules/intl-messageformat/lib/src/error.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ErrorCode": ()=>ErrorCode,
    "FormatError": ()=>FormatError,
    "InvalidValueError": ()=>InvalidValueError,
    "InvalidValueTypeError": ()=>InvalidValueTypeError,
    "MissingValueError": ()=>MissingValueError
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
;
var ErrorCode;
(function(ErrorCode) {
    // When we have a placeholder but no value to format
    ErrorCode["MISSING_VALUE"] = "MISSING_VALUE";
    // When value supplied is invalid
    ErrorCode["INVALID_VALUE"] = "INVALID_VALUE";
    // When we need specific Intl API but it's not available
    ErrorCode["MISSING_INTL_API"] = "MISSING_INTL_API";
})(ErrorCode || (ErrorCode = {}));
var FormatError = function(_super) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__extends"])(FormatError, _super);
    function FormatError(msg, code, originalMessage) {
        var _this = _super.call(this, msg) || this;
        _this.code = code;
        _this.originalMessage = originalMessage;
        return _this;
    }
    FormatError.prototype.toString = function() {
        return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
    };
    return FormatError;
}(Error);
;
var InvalidValueError = function(_super) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__extends"])(InvalidValueError, _super);
    function InvalidValueError(variableId, value, options, originalMessage) {
        return _super.call(this, "Invalid values for \"".concat(variableId, "\": \"").concat(value, "\". Options are \"").concat(Object.keys(options).join('", "'), "\""), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueError;
}(FormatError);
;
var InvalidValueTypeError = function(_super) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__extends"])(InvalidValueTypeError, _super);
    function InvalidValueTypeError(value, type, originalMessage) {
        return _super.call(this, "Value for \"".concat(value, "\" must be of type ").concat(type), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueTypeError;
}(FormatError);
;
var MissingValueError = function(_super) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__extends"])(MissingValueError, _super);
    function MissingValueError(variableId, originalMessage) {
        return _super.call(this, "The intl string context variable \"".concat(variableId, "\" was not provided to the string \"").concat(originalMessage, "\""), ErrorCode.MISSING_VALUE, originalMessage) || this;
    }
    return MissingValueError;
}(FormatError);
;
}),
"[project]/node_modules/intl-messageformat/lib/src/formatters.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "PART_TYPE": ()=>PART_TYPE,
    "formatToParts": ()=>formatToParts,
    "isFormatXMLElementFn": ()=>isFormatXMLElementFn
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/types.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$intl$2d$messageformat$2f$lib$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/intl-messageformat/lib/src/error.js [app-client] (ecmascript)");
;
;
var PART_TYPE;
(function(PART_TYPE) {
    PART_TYPE[PART_TYPE["literal"] = 0] = "literal";
    PART_TYPE[PART_TYPE["object"] = 1] = "object";
})(PART_TYPE || (PART_TYPE = {}));
function mergeLiteral(parts) {
    if (parts.length < 2) {
        return parts;
    }
    return parts.reduce(function(all, part) {
        var lastPart = all[all.length - 1];
        if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {
            all.push(part);
        } else {
            lastPart.value += part.value;
        }
        return all;
    }, []);
}
function isFormatXMLElementFn(el) {
    return typeof el === 'function';
}
function formatToParts(els, locales, formatters, formats, values, currentPluralValue, // For debugging
originalMessage) {
    // Hot path for straight simple msg translations
    if (els.length === 1 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLiteralElement"])(els[0])) {
        return [
            {
                type: PART_TYPE.literal,
                value: els[0].value
            }
        ];
    }
    var result = [];
    for(var _i = 0, els_1 = els; _i < els_1.length; _i++){
        var el = els_1[_i];
        // Exit early for string parts.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLiteralElement"])(el)) {
            result.push({
                type: PART_TYPE.literal,
                value: el.value
            });
            continue;
        }
        // TODO: should this part be literal type?
        // Replace `#` in plural rules with the actual numeric value.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPoundElement"])(el)) {
            if (typeof currentPluralValue === 'number') {
                result.push({
                    type: PART_TYPE.literal,
                    value: formatters.getNumberFormat(locales).format(currentPluralValue)
                });
            }
            continue;
        }
        var varName = el.value;
        // Enforce that all required values are provided by the caller.
        if (!(values && varName in values)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$intl$2d$messageformat$2f$lib$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MissingValueError"](varName, originalMessage);
        }
        var value = values[varName];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArgumentElement"])(el)) {
            if (!value || typeof value === 'string' || typeof value === 'number') {
                value = typeof value === 'string' || typeof value === 'number' ? String(value) : '';
            }
            result.push({
                type: typeof value === 'string' ? PART_TYPE.literal : PART_TYPE.object,
                value: value
            });
            continue;
        }
        // Recursively format plural and select parts' option  which can be a
        // nested pattern structure. The choosing of the option to use is
        // abstracted-by and delegated-to the part helper object.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDateElement"])(el)) {
            var style = typeof el.style === 'string' ? formats.date[el.style] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDateTimeSkeleton"])(el.style) ? el.style.parsedOptions : undefined;
            result.push({
                type: PART_TYPE.literal,
                value: formatters.getDateTimeFormat(locales, style).format(value)
            });
            continue;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTimeElement"])(el)) {
            var style = typeof el.style === 'string' ? formats.time[el.style] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDateTimeSkeleton"])(el.style) ? el.style.parsedOptions : formats.time.medium;
            result.push({
                type: PART_TYPE.literal,
                value: formatters.getDateTimeFormat(locales, style).format(value)
            });
            continue;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberElement"])(el)) {
            var style = typeof el.style === 'string' ? formats.number[el.style] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberSkeleton"])(el.style) ? el.style.parsedOptions : undefined;
            if (style && style.scale) {
                value = value * (style.scale || 1);
            }
            result.push({
                type: PART_TYPE.literal,
                value: formatters.getNumberFormat(locales, style).format(value)
            });
            continue;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTagElement"])(el)) {
            var children = el.children, value_1 = el.value;
            var formatFn = values[value_1];
            if (!isFormatXMLElementFn(formatFn)) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$intl$2d$messageformat$2f$lib$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InvalidValueTypeError"](value_1, 'function', originalMessage);
            }
            var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);
            var chunks = formatFn(parts.map(function(p) {
                return p.value;
            }));
            if (!Array.isArray(chunks)) {
                chunks = [
                    chunks
                ];
            }
            result.push.apply(result, chunks.map(function(c) {
                return {
                    type: typeof c === 'string' ? PART_TYPE.literal : PART_TYPE.object,
                    value: c
                };
            }));
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectElement"])(el)) {
            var opt = el.options[value] || el.options.other;
            if (!opt) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$intl$2d$messageformat$2f$lib$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InvalidValueError"](el.value, value, Object.keys(el.options), originalMessage);
            }
            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
            continue;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPluralElement"])(el)) {
            var opt = el.options["=".concat(value)];
            if (!opt) {
                if (!Intl.PluralRules) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$intl$2d$messageformat$2f$lib$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FormatError"]("Intl.PluralRules is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-pluralrules\"\n", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$intl$2d$messageformat$2f$lib$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorCode"].MISSING_INTL_API, originalMessage);
                }
                var rule = formatters.getPluralRules(locales, {
                    type: el.pluralType
                }).select(value - (el.offset || 0));
                opt = el.options[rule] || el.options.other;
            }
            if (!opt) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$intl$2d$messageformat$2f$lib$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InvalidValueError"](el.value, value, Object.keys(el.options), originalMessage);
            }
            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));
            continue;
        }
    }
    return mergeLiteral(result);
}
}),
"[project]/node_modules/intl-messageformat/lib/src/core.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/*
Copyright (c) 2014, Yahoo! Inc. All rights reserved.
Copyrights licensed under the New BSD License.
See the accompanying LICENSE file for terms.
*/ __turbopack_context__.s({
    "IntlMessageFormat": ()=>IntlMessageFormat
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$fast$2d$memoize$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/fast-memoize/lib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/icu-messageformat-parser/lib/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$intl$2d$messageformat$2f$lib$2f$src$2f$formatters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/intl-messageformat/lib/src/formatters.js [app-client] (ecmascript)");
;
;
;
;
// -- MessageFormat --------------------------------------------------------
function mergeConfig(c1, c2) {
    if (!c2) {
        return c1;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, c1 || {}), c2 || {}), Object.keys(c1).reduce(function(all, k) {
        all[k] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, c1[k]), c2[k] || {});
        return all;
    }, {}));
}
function mergeConfigs(defaultConfig, configs) {
    if (!configs) {
        return defaultConfig;
    }
    return Object.keys(defaultConfig).reduce(function(all, k) {
        all[k] = mergeConfig(defaultConfig[k], configs[k]);
        return all;
    }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, defaultConfig));
}
function createFastMemoizeCache(store) {
    return {
        create: function() {
            return {
                get: function(key) {
                    return store[key];
                },
                set: function(key, value) {
                    store[key] = value;
                }
            };
        }
    };
}
function createDefaultFormatters(cache) {
    if (cache === void 0) {
        cache = {
            number: {},
            dateTime: {},
            pluralRules: {}
        };
    }
    return {
        getNumberFormat: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$fast$2d$memoize$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memoize"])(function() {
            var _a;
            var args = [];
            for(var _i = 0; _i < arguments.length; _i++){
                args[_i] = arguments[_i];
            }
            return new ((_a = Intl.NumberFormat).bind.apply(_a, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__spreadArray"])([
                void 0
            ], args, false)))();
        }, {
            cache: createFastMemoizeCache(cache.number),
            strategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$fast$2d$memoize$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strategies"].variadic
        }),
        getDateTimeFormat: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$fast$2d$memoize$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memoize"])(function() {
            var _a;
            var args = [];
            for(var _i = 0; _i < arguments.length; _i++){
                args[_i] = arguments[_i];
            }
            return new ((_a = Intl.DateTimeFormat).bind.apply(_a, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__spreadArray"])([
                void 0
            ], args, false)))();
        }, {
            cache: createFastMemoizeCache(cache.dateTime),
            strategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$fast$2d$memoize$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strategies"].variadic
        }),
        getPluralRules: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$fast$2d$memoize$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memoize"])(function() {
            var _a;
            var args = [];
            for(var _i = 0; _i < arguments.length; _i++){
                args[_i] = arguments[_i];
            }
            return new ((_a = Intl.PluralRules).bind.apply(_a, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__spreadArray"])([
                void 0
            ], args, false)))();
        }, {
            cache: createFastMemoizeCache(cache.pluralRules),
            strategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$fast$2d$memoize$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strategies"].variadic
        })
    };
}
var IntlMessageFormat = function() {
    function IntlMessageFormat(message, locales, overrideFormats, opts) {
        if (locales === void 0) {
            locales = IntlMessageFormat.defaultLocale;
        }
        var _this = this;
        this.formatterCache = {
            number: {},
            dateTime: {},
            pluralRules: {}
        };
        this.format = function(values) {
            var parts = _this.formatToParts(values);
            // Hot path for straight simple msg translations
            if (parts.length === 1) {
                return parts[0].value;
            }
            var result = parts.reduce(function(all, part) {
                if (!all.length || part.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$intl$2d$messageformat$2f$lib$2f$src$2f$formatters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PART_TYPE"].literal || typeof all[all.length - 1] !== 'string') {
                    all.push(part.value);
                } else {
                    all[all.length - 1] += part.value;
                }
                return all;
            }, []);
            if (result.length <= 1) {
                return result[0] || '';
            }
            return result;
        };
        this.formatToParts = function(values) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$intl$2d$messageformat$2f$lib$2f$src$2f$formatters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatToParts"])(_this.ast, _this.locales, _this.formatters, _this.formats, values, undefined, _this.message);
        };
        this.resolvedOptions = function() {
            var _a;
            return {
                locale: ((_a = _this.resolvedLocale) === null || _a === void 0 ? void 0 : _a.toString()) || Intl.NumberFormat.supportedLocalesOf(_this.locales)[0]
            };
        };
        this.getAst = function() {
            return _this.ast;
        };
        // Defined first because it's used to build the format pattern.
        this.locales = locales;
        this.resolvedLocale = IntlMessageFormat.resolveLocale(locales);
        if (typeof message === 'string') {
            this.message = message;
            if (!IntlMessageFormat.__parse) {
                throw new TypeError('IntlMessageFormat.__parse must be set to process `message` of type `string`');
            }
            var _a = opts || {}, formatters = _a.formatters, parseOpts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__rest"])(_a, [
                "formatters"
            ]);
            // Parse string messages into an AST.
            this.ast = IntlMessageFormat.__parse(message, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__assign"])({}, parseOpts), {
                locale: this.resolvedLocale
            }));
        } else {
            this.ast = message;
        }
        if (!Array.isArray(this.ast)) {
            throw new TypeError('A message must be provided as a String or AST.');
        }
        // Creates a new object with the specified `formats` merged with the default
        // formats.
        this.formats = mergeConfigs(IntlMessageFormat.formats, overrideFormats);
        this.formatters = opts && opts.formatters || createDefaultFormatters(this.formatterCache);
    }
    Object.defineProperty(IntlMessageFormat, "defaultLocale", {
        get: function() {
            if (!IntlMessageFormat.memoizedDefaultLocale) {
                IntlMessageFormat.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale;
            }
            return IntlMessageFormat.memoizedDefaultLocale;
        },
        enumerable: false,
        configurable: true
    });
    IntlMessageFormat.memoizedDefaultLocale = null;
    IntlMessageFormat.resolveLocale = function(locales) {
        if (typeof Intl.Locale === 'undefined') {
            return;
        }
        var supportedLocales = Intl.NumberFormat.supportedLocalesOf(locales);
        if (supportedLocales.length > 0) {
            return new Intl.Locale(supportedLocales[0]);
        }
        return new Intl.Locale(typeof locales === 'string' ? locales : locales[0]);
    };
    IntlMessageFormat.__parse = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$icu$2d$messageformat$2d$parser$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parse"];
    // Default format options used as the prototype of the `formats` provided to the
    // constructor. These are used when constructing the internal Intl.NumberFormat
    // and Intl.DateTimeFormat instances.
    IntlMessageFormat.formats = {
        number: {
            integer: {
                maximumFractionDigits: 0
            },
            currency: {
                style: 'currency'
            },
            percent: {
                style: 'percent'
            }
        },
        date: {
            short: {
                month: 'numeric',
                day: 'numeric',
                year: '2-digit'
            },
            medium: {
                month: 'short',
                day: 'numeric',
                year: 'numeric'
            },
            long: {
                month: 'long',
                day: 'numeric',
                year: 'numeric'
            },
            full: {
                weekday: 'long',
                month: 'long',
                day: 'numeric',
                year: 'numeric'
            }
        },
        time: {
            short: {
                hour: 'numeric',
                minute: 'numeric'
            },
            medium: {
                hour: 'numeric',
                minute: 'numeric',
                second: 'numeric'
            },
            long: {
                hour: 'numeric',
                minute: 'numeric',
                second: 'numeric',
                timeZoneName: 'short'
            },
            full: {
                hour: 'numeric',
                minute: 'numeric',
                second: 'numeric',
                timeZoneName: 'short'
            }
        }
    };
    return IntlMessageFormat;
}();
;
}),
"[project]/node_modules/use-intl/dist/esm/development/initializeConfig-CRD6euuK.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "I": ()=>IntlError,
    "a": ()=>IntlErrorCode,
    "b": ()=>createIntlFormatters,
    "c": ()=>createFormatter,
    "d": ()=>createCache,
    "e": ()=>createBaseTranslator,
    "f": ()=>defaultGetMessageFallback,
    "g": ()=>defaultOnError,
    "i": ()=>initializeConfig,
    "r": ()=>resolveNamespace
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$intl$2d$messageformat$2f$lib$2f$src$2f$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/intl-messageformat/lib/src/core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$fast$2d$memoize$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@formatjs/fast-memoize/lib/index.js [app-client] (ecmascript)");
;
;
;
class IntlError extends Error {
    constructor(code, originalMessage){
        let message = code;
        if (originalMessage) {
            message += ': ' + originalMessage;
        }
        super(message);
        this.code = code;
        if (originalMessage) {
            this.originalMessage = originalMessage;
        }
    }
}
var IntlErrorCode = /*#__PURE__*/ function(IntlErrorCode) {
    IntlErrorCode["MISSING_MESSAGE"] = "MISSING_MESSAGE";
    IntlErrorCode["MISSING_FORMAT"] = "MISSING_FORMAT";
    IntlErrorCode["ENVIRONMENT_FALLBACK"] = "ENVIRONMENT_FALLBACK";
    IntlErrorCode["INSUFFICIENT_PATH"] = "INSUFFICIENT_PATH";
    IntlErrorCode["INVALID_MESSAGE"] = "INVALID_MESSAGE";
    IntlErrorCode["INVALID_KEY"] = "INVALID_KEY";
    IntlErrorCode["FORMATTING_ERROR"] = "FORMATTING_ERROR";
    return IntlErrorCode;
}(IntlErrorCode || {});
/**
 * `intl-messageformat` uses separate keys for `date` and `time`, but there's
 * only one native API: `Intl.DateTimeFormat`. Additionally you might want to
 * include both a time and a date in a value, therefore the separation doesn't
 * seem so useful. We offer a single `dateTime` namespace instead, but we have
 * to convert the format before `intl-messageformat` can be used.
 */ function convertFormatsToIntlMessageFormat(globalFormats, inlineFormats, timeZone) {
    const mfDateDefaults = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$intl$2d$messageformat$2f$lib$2f$src$2f$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntlMessageFormat"].formats.date;
    const mfTimeDefaults = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$intl$2d$messageformat$2f$lib$2f$src$2f$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntlMessageFormat"].formats.time;
    const dateTimeFormats = {
        ...globalFormats === null || globalFormats === void 0 ? void 0 : globalFormats.dateTime,
        ...inlineFormats === null || inlineFormats === void 0 ? void 0 : inlineFormats.dateTime
    };
    const allFormats = {
        date: {
            ...mfDateDefaults,
            ...dateTimeFormats
        },
        time: {
            ...mfTimeDefaults,
            ...dateTimeFormats
        },
        number: {
            ...globalFormats === null || globalFormats === void 0 ? void 0 : globalFormats.number,
            ...inlineFormats === null || inlineFormats === void 0 ? void 0 : inlineFormats.number
        }
    };
    if (timeZone) {
        // The only way to set a time zone with `intl-messageformat` is to merge it into the formats
        // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15
        [
            'date',
            'time'
        ].forEach((property)=>{
            const formats = allFormats[property];
            for (const [key, value] of Object.entries(formats)){
                formats[key] = {
                    timeZone,
                    ...value
                };
            }
        });
    }
    return allFormats;
}
function joinPath() {
    for(var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++){
        parts[_key] = arguments[_key];
    }
    return parts.filter(Boolean).join('.');
}
/**
 * Contains defaults that are used for all entry points into the core.
 * See also `InitializedIntlConfiguration`.
 */ function defaultGetMessageFallback(props) {
    return joinPath(props.namespace, props.key);
}
function defaultOnError(error) {
    console.error(error);
}
function createCache() {
    return {
        dateTime: {},
        number: {},
        message: {},
        relativeTime: {},
        pluralRules: {},
        list: {},
        displayNames: {}
    };
}
function createMemoCache(store) {
    return {
        create () {
            return {
                get (key) {
                    return store[key];
                },
                set (key, value) {
                    store[key] = value;
                }
            };
        }
    };
}
function memoFn(fn, cache) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$fast$2d$memoize$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memoize"])(fn, {
        cache: createMemoCache(cache),
        strategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$formatjs$2f$fast$2d$memoize$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strategies"].variadic
    });
}
function memoConstructor(ConstructorFn, cache) {
    return memoFn(function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return new ConstructorFn(...args);
    }, cache);
}
function createIntlFormatters(cache) {
    const getDateTimeFormat = memoConstructor(Intl.DateTimeFormat, cache.dateTime);
    const getNumberFormat = memoConstructor(Intl.NumberFormat, cache.number);
    const getPluralRules = memoConstructor(Intl.PluralRules, cache.pluralRules);
    const getRelativeTimeFormat = memoConstructor(Intl.RelativeTimeFormat, cache.relativeTime);
    const getListFormat = memoConstructor(Intl.ListFormat, cache.list);
    const getDisplayNames = memoConstructor(Intl.DisplayNames, cache.displayNames);
    return {
        getDateTimeFormat,
        getNumberFormat,
        getPluralRules,
        getRelativeTimeFormat,
        getListFormat,
        getDisplayNames
    };
}
// Placed here for improved tree shaking. Somehow when this is placed in
// `formatters.tsx`, then it can't be shaken off from `next-intl`.
function createMessageFormatter(cache, intlFormatters) {
    const getMessageFormat = memoFn(function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$intl$2d$messageformat$2f$lib$2f$src$2f$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntlMessageFormat"](args[0], args[1], args[2], {
            formatters: intlFormatters,
            ...args[3]
        });
    }, cache.message);
    return getMessageFormat;
}
function resolvePath(locale, messages, key, namespace) {
    const fullKey = joinPath(namespace, key);
    if (!messages) {
        throw new Error("No messages available at `".concat(namespace, "`."));
    }
    let message = messages;
    key.split('.').forEach((part)=>{
        const next = message[part];
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (part == null || next == null) {
            throw new Error("Could not resolve `".concat(fullKey, "` in messages for locale `").concat(locale, "`."));
        }
        message = next;
    });
    return message;
}
function prepareTranslationValues(values) {
    // Workaround for https://github.com/formatjs/formatjs/issues/1467
    const transformedValues = {};
    Object.keys(values).forEach((key)=>{
        let index = 0;
        const value = values[key];
        let transformed;
        if (typeof value === 'function') {
            transformed = (chunks)=>{
                const result = value(chunks);
                return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidElement"])(result) ? /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneElement"])(result, {
                    key: key + index++
                }) : result;
            };
        } else {
            transformed = value;
        }
        transformedValues[key] = transformed;
    });
    return transformedValues;
}
function getMessagesOrError(locale, messages, namespace) {
    let onError = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : defaultOnError;
    try {
        if (!messages) {
            throw new Error("No messages were configured.");
        }
        const retrievedMessages = namespace ? resolvePath(locale, messages, namespace) : messages;
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (!retrievedMessages) {
            throw new Error("No messages for namespace `".concat(namespace, "` found."));
        }
        return retrievedMessages;
    } catch (error) {
        const intlError = new IntlError(IntlErrorCode.MISSING_MESSAGE, error.message);
        onError(intlError);
        return intlError;
    }
}
function getPlainMessage(candidate, values) {
    {
        // Keep fast path in development
        if (values) return undefined;
        // Despite potentially no values being available, there can still be
        // placeholders in the message if the user has forgotten to provide
        // values. In this case we compile the message to receive an error.
        const unescapedMessage = candidate.replace(/'([{}])/gi, '$1');
        const hasPlaceholders = /<|{/.test(unescapedMessage);
        if (!hasPlaceholders) {
            return unescapedMessage;
        }
    }
}
function createBaseTranslator(config) {
    const messagesOrError = getMessagesOrError(config.locale, config.messages, config.namespace, config.onError);
    return createBaseTranslatorImpl({
        ...config,
        messagesOrError
    });
}
function createBaseTranslatorImpl(param) {
    let { cache, formats: globalFormats, formatters, getMessageFallback = defaultGetMessageFallback, locale, messagesOrError, namespace, onError, timeZone } = param;
    const hasMessagesError = messagesOrError instanceof IntlError;
    function getFallbackFromErrorAndNotify(key, code, message) {
        const error = new IntlError(code, message);
        onError(error);
        return getMessageFallback({
            error,
            key,
            namespace
        });
    }
    function translateBaseFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats) {
        if (hasMessagesError) {
            // We have already warned about this during render
            return getMessageFallback({
                error: messagesOrError,
                key,
                namespace
            });
        }
        const messages = messagesOrError;
        let message;
        try {
            message = resolvePath(locale, messages, key, namespace);
        } catch (error) {
            return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message);
        }
        if (typeof message === 'object') {
            let code, errorMessage;
            if (Array.isArray(message)) {
                code = IntlErrorCode.INVALID_MESSAGE;
                {
                    errorMessage = "Message at `".concat(joinPath(namespace, key), "` resolved to an array, but only strings are supported. See https://next-intl.dev/docs/usage/messages#arrays-of-messages");
                }
            } else {
                code = IntlErrorCode.INSUFFICIENT_PATH;
                {
                    errorMessage = "Message at `".concat(joinPath(namespace, key), "` resolved to an object, but only strings are supported. Use a `.` to retrieve nested messages. See https://next-intl.dev/docs/usage/messages#structuring-messages");
                }
            }
            return getFallbackFromErrorAndNotify(key, code, errorMessage);
        }
        let messageFormat;
        // Hot path that avoids creating an `IntlMessageFormat` instance
        const plainMessage = getPlainMessage(message, values);
        if (plainMessage) return plainMessage;
        // Lazy init the message formatter for better tree
        // shaking in case message formatting is not used.
        if (!formatters.getMessageFormat) {
            formatters.getMessageFormat = createMessageFormatter(cache, formatters);
        }
        try {
            messageFormat = formatters.getMessageFormat(message, locale, convertFormatsToIntlMessageFormat(globalFormats, formats, timeZone), {
                formatters: {
                    ...formatters,
                    getDateTimeFormat (locales, options) {
                        // Workaround for https://github.com/formatjs/formatjs/issues/4279
                        return formatters.getDateTimeFormat(locales, {
                            timeZone,
                            ...options
                        });
                    }
                }
            });
        } catch (error) {
            const thrownError = error;
            return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, thrownError.message + ('originalMessage' in thrownError ? " (".concat(thrownError.originalMessage, ")") : ''));
        }
        try {
            const formattedMessage = messageFormat.format(// @ts-expect-error `intl-messageformat` expects a different format
            // for rich text elements since a recent minor update. This
            // needs to be evaluated in detail, possibly also in regards
            // to be able to format to parts.
            values ? prepareTranslationValues(values) : values);
            if (formattedMessage == null) {
                throw new Error("Unable to format `".concat(key, "` in ").concat(namespace ? "namespace `".concat(namespace, "`") : 'messages'));
            }
            // Limit the function signature to return strings or React elements
            return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidElement"])(formattedMessage) || // Arrays of React elements
            Array.isArray(formattedMessage) || typeof formattedMessage === 'string' ? formattedMessage : String(formattedMessage);
        } catch (error) {
            return getFallbackFromErrorAndNotify(key, IntlErrorCode.FORMATTING_ERROR, error.message);
        }
    }
    function translateFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats) {
        const result = translateBaseFn(key, values, formats);
        if (typeof result !== 'string') {
            return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, "The message `".concat(key, "` in ").concat(namespace ? "namespace `".concat(namespace, "`") : 'messages', " didn't resolve to a string. If you want to format rich text, use `t.rich` instead."));
        }
        return result;
    }
    translateFn.rich = translateBaseFn;
    // Augment `translateBaseFn` to return plain strings
    translateFn.markup = (key, values, formats)=>{
        const result = translateBaseFn(key, // @ts-expect-error -- `MarkupTranslationValues` is practically a sub type
        // of `RichTranslationValues` but TypeScript isn't smart enough here.
        values, formats);
        if (typeof result !== 'string') {
            const error = new IntlError(IntlErrorCode.FORMATTING_ERROR, "`t.markup` only accepts functions for formatting that receive and return strings.\n\nE.g. t.markup('markup', {b: (chunks) => `<b>${chunks}</b>`})");
            onError(error);
            return getMessageFallback({
                error,
                key,
                namespace
            });
        }
        return result;
    };
    translateFn.raw = (key)=>{
        if (hasMessagesError) {
            // We have already warned about this during render
            return getMessageFallback({
                error: messagesOrError,
                key,
                namespace
            });
        }
        const messages = messagesOrError;
        try {
            return resolvePath(locale, messages, key, namespace);
        } catch (error) {
            return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message);
        }
    };
    translateFn.has = (key)=>{
        if (hasMessagesError) {
            return false;
        }
        try {
            resolvePath(locale, messagesOrError, key, namespace);
            return true;
        } catch (e) {
            return false;
        }
    };
    return translateFn;
}
/**
 * For the strictly typed messages to work we have to wrap the namespace into
 * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045
 */ function resolveNamespace(namespace, namespacePrefix) {
    return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + '.').length);
}
const SECOND = 1;
const MINUTE = SECOND * 60;
const HOUR = MINUTE * 60;
const DAY = HOUR * 24;
const WEEK = DAY * 7;
const MONTH = DAY * (365 / 12); // Approximation
const QUARTER = MONTH * 3;
const YEAR = DAY * 365;
const UNIT_SECONDS = {
    second: SECOND,
    seconds: SECOND,
    minute: MINUTE,
    minutes: MINUTE,
    hour: HOUR,
    hours: HOUR,
    day: DAY,
    days: DAY,
    week: WEEK,
    weeks: WEEK,
    month: MONTH,
    months: MONTH,
    quarter: QUARTER,
    quarters: QUARTER,
    year: YEAR,
    years: YEAR
};
function resolveRelativeTimeUnit(seconds) {
    const absValue = Math.abs(seconds);
    if (absValue < MINUTE) {
        return 'second';
    } else if (absValue < HOUR) {
        return 'minute';
    } else if (absValue < DAY) {
        return 'hour';
    } else if (absValue < WEEK) {
        return 'day';
    } else if (absValue < MONTH) {
        return 'week';
    } else if (absValue < YEAR) {
        return 'month';
    }
    return 'year';
}
function calculateRelativeTimeValue(seconds, unit) {
    // We have to round the resulting values, as `Intl.RelativeTimeFormat`
    // will include fractions like '2.1 hours ago'.
    return Math.round(seconds / UNIT_SECONDS[unit]);
}
function createFormatter(props) {
    const { _cache: cache = createCache(), _formatters: formatters = createIntlFormatters(cache), formats, locale, onError = defaultOnError, timeZone: globalTimeZone } = props;
    function applyTimeZone(options) {
        if (!(options === null || options === void 0 ? void 0 : options.timeZone)) {
            if (globalTimeZone) {
                options = {
                    ...options,
                    timeZone: globalTimeZone
                };
            } else {
                onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, "The `timeZone` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl.dev/docs/configuration#time-zone"));
            }
        }
        return options;
    }
    function resolveFormatOrOptions(typeFormats, formatOrOptions, overrides) {
        let options;
        if (typeof formatOrOptions === 'string') {
            const formatName = formatOrOptions;
            options = typeFormats === null || typeFormats === void 0 ? void 0 : typeFormats[formatName];
            if (!options) {
                const error = new IntlError(IntlErrorCode.MISSING_FORMAT, "Format `".concat(formatName, "` is not available."));
                onError(error);
                throw error;
            }
        } else {
            options = formatOrOptions;
        }
        if (overrides) {
            options = {
                ...options,
                ...overrides
            };
        }
        return options;
    }
    function getFormattedValue(formatOrOptions, overrides, typeFormats, formatter, getFallback) {
        let options;
        try {
            options = resolveFormatOrOptions(typeFormats, formatOrOptions, overrides);
        } catch (e) {
            return getFallback();
        }
        try {
            return formatter(options);
        } catch (error) {
            onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));
            return getFallback();
        }
    }
    function dateTime(value, formatOrOptions, overrides) {
        return getFormattedValue(formatOrOptions, overrides, formats === null || formats === void 0 ? void 0 : formats.dateTime, (options)=>{
            options = applyTimeZone(options);
            return formatters.getDateTimeFormat(locale, options).format(value);
        }, ()=>String(value));
    }
    function dateTimeRange(start, end, formatOrOptions, overrides) {
        return getFormattedValue(formatOrOptions, overrides, formats === null || formats === void 0 ? void 0 : formats.dateTime, (options)=>{
            options = applyTimeZone(options);
            return formatters.getDateTimeFormat(locale, options).formatRange(start, end);
        }, ()=>[
                dateTime(start),
                dateTime(end)
            ].join(''));
    }
    function number(value, formatOrOptions, overrides) {
        return getFormattedValue(formatOrOptions, overrides, formats === null || formats === void 0 ? void 0 : formats.number, (options)=>formatters.getNumberFormat(locale, options).format(value), ()=>String(value));
    }
    function getGlobalNow() {
        // Only read when necessary to avoid triggering a `dynamicIO` error
        // unnecessarily (`now` is only needed for `format.relativeTime`)
        if (props.now) {
            return props.now;
        } else {
            onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, "The `now` parameter wasn't provided to `relativeTime` and there is no global default configured, therefore the current time will be used as a fallback. See https://next-intl.dev/docs/usage/dates-times#relative-times-usenow"));
            return new Date();
        }
    }
    function relativeTime(date, nowOrOptions) {
        try {
            let nowDate, unit;
            const opts = {};
            if (nowOrOptions instanceof Date || typeof nowOrOptions === 'number') {
                nowDate = new Date(nowOrOptions);
            } else if (nowOrOptions) {
                if (nowOrOptions.now != null) {
                    nowDate = new Date(nowOrOptions.now);
                } else {
                    nowDate = getGlobalNow();
                }
                unit = nowOrOptions.unit;
                opts.style = nowOrOptions.style;
                // @ts-expect-error -- Types are slightly outdated
                opts.numberingSystem = nowOrOptions.numberingSystem;
            }
            if (!nowDate) {
                nowDate = getGlobalNow();
            }
            const dateDate = new Date(date);
            const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;
            if (!unit) {
                unit = resolveRelativeTimeUnit(seconds);
            }
            // `numeric: 'auto'` can theoretically produce output like "yesterday",
            // but it only works with integers. E.g. -1 day will produce "yesterday",
            // but -1.1 days will produce "-1.1 days". Rounding before formatting is
            // not desired, as the given dates might cross a threshold were the
            // output isn't correct anymore. Example: 2024-01-08T23:00:00.000Z and
            // 2024-01-08T01:00:00.000Z would produce "yesterday", which is not the
            // case. By using `always` we can ensure correct output. The only exception
            // is the formatting of times <1 second as "now".
            opts.numeric = unit === 'second' ? 'auto' : 'always';
            const value = calculateRelativeTimeValue(seconds, unit);
            return formatters.getRelativeTimeFormat(locale, opts).format(value, unit);
        } catch (error) {
            onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));
            return String(date);
        }
    }
    function list(value, formatOrOptions, overrides) {
        const serializedValue = [];
        const richValues = new Map();
        // `formatToParts` only accepts strings, therefore we have to temporarily
        // replace React elements with a placeholder ID that can be used to retrieve
        // the original value afterwards.
        let index = 0;
        for (const item of value){
            let serializedItem;
            if (typeof item === 'object') {
                serializedItem = String(index);
                richValues.set(serializedItem, item);
            } else {
                serializedItem = String(item);
            }
            serializedValue.push(serializedItem);
            index++;
        }
        return getFormattedValue(formatOrOptions, overrides, formats === null || formats === void 0 ? void 0 : formats.list, // @ts-expect-error -- `richValues.size` is used to determine the return type, but TypeScript can't infer the meaning of this correctly
        (options)=>{
            const result = formatters.getListFormat(locale, options).formatToParts(serializedValue).map((part)=>part.type === 'literal' ? part.value : richValues.get(part.value) || part.value);
            if (richValues.size > 0) {
                return result;
            } else {
                return result.join('');
            }
        }, ()=>String(value));
    }
    return {
        dateTime,
        number,
        relativeTime,
        list,
        dateTimeRange
    };
}
function validateMessagesSegment(messages, invalidKeyLabels, parentPath) {
    Object.entries(messages).forEach((param)=>{
        let [key, messageOrMessages] = param;
        if (key.includes('.')) {
            let keyLabel = key;
            if (parentPath) keyLabel += " (at ".concat(parentPath, ")");
            invalidKeyLabels.push(keyLabel);
        }
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (messageOrMessages != null && typeof messageOrMessages === 'object') {
            validateMessagesSegment(messageOrMessages, invalidKeyLabels, joinPath(parentPath, key));
        }
    });
}
function validateMessages(messages, onError) {
    const invalidKeyLabels = [];
    validateMessagesSegment(messages, invalidKeyLabels);
    if (invalidKeyLabels.length > 0) {
        onError(new IntlError(IntlErrorCode.INVALID_KEY, 'Namespace keys can not contain the character "." as this is used to express nesting. Please remove it or replace it with another character.\n\nInvalid '.concat(invalidKeyLabels.length === 1 ? 'key' : 'keys', ": ").concat(invalidKeyLabels.join(', '), '\n\nIf you\'re migrating from a flat structure, you can convert your messages as follows:\n\nimport {set} from "lodash";\n\nconst input = {\n  "one.one": "1.1",\n  "one.two": "1.2",\n  "two.one.one": "2.1.1"\n};\n\nconst output = Object.entries(input).reduce(\n  (acc, [key, value]) => set(acc, key, value),\n  {}\n);\n\n// Output:\n//\n// {\n//   "one": {\n//     "one": "1.1",\n//     "two": "1.2"\n//   },\n//   "two": {\n//     "one": {\n//       "one": "2.1.1"\n//     }\n//   }\n// }\n')));
    }
}
/**
 * Enhances the incoming props with defaults.
 */ function initializeConfig(param) {
    let { formats, getMessageFallback, messages, onError, ...rest } = param;
    const finalOnError = onError || defaultOnError;
    const finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;
    {
        if (messages) {
            validateMessages(messages, finalOnError);
        }
    }
    return {
        ...rest,
        formats: formats || undefined,
        messages: messages || undefined,
        onError: finalOnError,
        getMessageFallback: finalGetMessageFallback
    };
}
;
}),
"[project]/node_modules/use-intl/dist/esm/development/react.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "IntlProvider": ()=>IntlProvider,
    "useFormatter": ()=>useFormatter,
    "useLocale": ()=>useLocale,
    "useMessages": ()=>useMessages,
    "useNow": ()=>useNow,
    "useTimeZone": ()=>useTimeZone,
    "useTranslations": ()=>useTranslations
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$intl$2f$dist$2f$esm$2f$development$2f$initializeConfig$2d$CRD6euuK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/use-intl/dist/esm/development/initializeConfig-CRD6euuK.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
;
;
;
const IntlContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(undefined);
function IntlProvider(param) {
    let { children, formats, getMessageFallback, locale, messages, now, onError, timeZone } = param;
    const prevContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(IntlContext);
    // The formatter cache is released when the locale changes. For
    // long-running apps with a persistent `IntlProvider` at the root,
    // this can reduce the memory footprint (e.g. in React Native).
    const cache = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "IntlProvider.useMemo[cache]": ()=>{
            return (prevContext === null || prevContext === void 0 ? void 0 : prevContext.cache) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$intl$2f$dist$2f$esm$2f$development$2f$initializeConfig$2d$CRD6euuK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])();
        }
    }["IntlProvider.useMemo[cache]"], [
        locale,
        prevContext === null || prevContext === void 0 ? void 0 : prevContext.cache
    ]);
    const formatters = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "IntlProvider.useMemo[formatters]": ()=>(prevContext === null || prevContext === void 0 ? void 0 : prevContext.formatters) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$intl$2f$dist$2f$esm$2f$development$2f$initializeConfig$2d$CRD6euuK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(cache)
    }["IntlProvider.useMemo[formatters]"], [
        cache,
        prevContext === null || prevContext === void 0 ? void 0 : prevContext.formatters
    ]);
    // Memoizing this value helps to avoid triggering a re-render of all
    // context consumers in case the configuration didn't change. However,
    // if some of the non-primitive values change, a re-render will still
    // be triggered. Note that there's no need to put `memo` on `IntlProvider`
    // itself, because the `children` typically change on every render.
    // There's some burden on the consumer side if it's important to reduce
    // re-renders, put that's how React works.
    // See: https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#context-updates-and-render-optimizations
    const value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "IntlProvider.useMemo[value]": ()=>({
                ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$intl$2f$dist$2f$esm$2f$development$2f$initializeConfig$2d$CRD6euuK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"])({
                    locale,
                    // (required by provider)
                    formats: formats === undefined ? prevContext === null || prevContext === void 0 ? void 0 : prevContext.formats : formats,
                    getMessageFallback: getMessageFallback || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.getMessageFallback),
                    messages: messages === undefined ? prevContext === null || prevContext === void 0 ? void 0 : prevContext.messages : messages,
                    now: now || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.now),
                    onError: onError || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.onError),
                    timeZone: timeZone || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.timeZone)
                }),
                formatters,
                cache
            })
    }["IntlProvider.useMemo[value]"], [
        cache,
        formats,
        formatters,
        getMessageFallback,
        locale,
        messages,
        now,
        onError,
        prevContext,
        timeZone
    ]);
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(IntlContext.Provider, {
        value: value,
        children: children
    });
}
function useIntlContext() {
    const context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(IntlContext);
    if (!context) {
        throw new Error('No intl context found. Have you configured the provider? See https://next-intl.dev/docs/usage/configuration#server-client-components');
    }
    return context;
}
let hasWarnedForMissingTimezone = false;
const isServer = typeof window === 'undefined';
function useTranslationsImpl(allMessagesPrefixed, namespacePrefixed, namespacePrefix) {
    const { cache, formats: globalFormats, formatters, getMessageFallback, locale, onError, timeZone } = useIntlContext();
    // The `namespacePrefix` is part of the type system.
    // See the comment in the hook invocation.
    const allMessages = allMessagesPrefixed[namespacePrefix];
    const namespace = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$intl$2f$dist$2f$esm$2f$development$2f$initializeConfig$2d$CRD6euuK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(namespacePrefixed, namespacePrefix);
    if (!timeZone && !hasWarnedForMissingTimezone && isServer) {
        // eslint-disable-next-line react-compiler/react-compiler
        hasWarnedForMissingTimezone = true;
        onError(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$intl$2f$dist$2f$esm$2f$development$2f$initializeConfig$2d$CRD6euuK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["I"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$intl$2f$dist$2f$esm$2f$development$2f$initializeConfig$2d$CRD6euuK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"].ENVIRONMENT_FALLBACK, "There is no `timeZone` configured, this can lead to markup mismatches caused by environment differences. Consider adding a global default: https://next-intl.dev/docs/configuration#time-zone"));
    }
    const translate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useTranslationsImpl.useMemo[translate]": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$intl$2f$dist$2f$esm$2f$development$2f$initializeConfig$2d$CRD6euuK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["e"])({
                cache,
                formatters,
                getMessageFallback,
                messages: allMessages,
                namespace,
                onError,
                formats: globalFormats,
                locale,
                timeZone
            })
    }["useTranslationsImpl.useMemo[translate]"], [
        cache,
        formatters,
        getMessageFallback,
        allMessages,
        namespace,
        onError,
        globalFormats,
        locale,
        timeZone
    ]);
    return translate;
}
/**
 * Translates messages from the given namespace by using the ICU syntax.
 * See https://formatjs.io/docs/core-concepts/icu-syntax.
 *
 * If no namespace is provided, all available messages are returned.
 * The namespace can also indicate nesting by using a dot
 * (e.g. `namespace.Component`).
 */ function useTranslations(namespace) {
    const context = useIntlContext();
    const messages = context.messages;
    // We have to wrap the actual hook so the type inference for the optional
    // namespace works correctly. See https://stackoverflow.com/a/71529575/343045
    // The prefix ("!") is arbitrary.
    // @ts-expect-error Use the explicit annotation instead
    return useTranslationsImpl({
        '!': messages
    }, // @ts-expect-error
    namespace ? "!.".concat(namespace) : '!', '!');
}
function useLocale() {
    return useIntlContext().locale;
}
function getNow() {
    return new Date();
}
/**
 * @see https://next-intl.dev/docs/usage/dates-times#relative-times-usenow
 */ function useNow(options) {
    const updateInterval = options === null || options === void 0 ? void 0 : options.updateInterval;
    const { now: globalNow } = useIntlContext();
    const [now, setNow] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(globalNow || getNow());
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useNow.useEffect": ()=>{
            if (!updateInterval) return;
            const intervalId = setInterval({
                "useNow.useEffect.intervalId": ()=>{
                    setNow(getNow());
                }
            }["useNow.useEffect.intervalId"], updateInterval);
            return ({
                "useNow.useEffect": ()=>{
                    clearInterval(intervalId);
                }
            })["useNow.useEffect"];
        }
    }["useNow.useEffect"], [
        globalNow,
        updateInterval
    ]);
    return updateInterval == null && globalNow ? globalNow : now;
}
function useTimeZone() {
    return useIntlContext().timeZone;
}
function useMessages() {
    const context = useIntlContext();
    if (!context.messages) {
        throw new Error('No messages found. Have you configured them correctly? See https://next-intl.dev/docs/configuration#messages');
    }
    return context.messages;
}
function useFormatter() {
    const { formats, formatters, locale, now: globalNow, onError, timeZone } = useIntlContext();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useFormatter.useMemo": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$intl$2f$dist$2f$esm$2f$development$2f$initializeConfig$2d$CRD6euuK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])({
                formats,
                locale,
                now: globalNow,
                onError,
                timeZone,
                _formatters: formatters
            })
    }["useFormatter.useMemo"], [
        formats,
        formatters,
        globalNow,
        locale,
        onError,
        timeZone
    ]);
}
;
}),
"[project]/node_modules/next-intl/dist/esm/development/shared/NextIntlClientProvider.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>NextIntlClientProvider
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$intl$2f$dist$2f$esm$2f$development$2f$react$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/use-intl/dist/esm/development/react.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
"use client";
;
;
function NextIntlClientProvider(param) {
    let { locale, ...rest } = param;
    if (!locale) {
        throw new Error("Couldn't infer the `locale` prop in `NextIntlClientProvider`, please provide it explicitly.\n\nSee https://next-intl.dev/docs/configuration#locale");
    }
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$intl$2f$dist$2f$esm$2f$development$2f$react$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntlProvider"], {
        locale: locale,
        ...rest
    });
}
;
}),
"[project]/node_modules/next-themes/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ThemeProvider": ()=>J,
    "useTheme": ()=>z
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
"use client";
;
var M = (e, i, s, u, m, a, l, h)=>{
    let d = document.documentElement, w = [
        "light",
        "dark"
    ];
    function p(n) {
        (Array.isArray(e) ? e : [
            e
        ]).forEach((y)=>{
            let k = y === "class", S = k && a ? m.map((f)=>a[f] || f) : m;
            k ? (d.classList.remove(...S), d.classList.add(a && a[n] ? a[n] : n)) : d.setAttribute(y, n);
        }), R(n);
    }
    function R(n) {
        h && w.includes(n) && (d.style.colorScheme = n);
    }
    function c() {
        return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    if (u) p(u);
    else try {
        let n = localStorage.getItem(i) || s, y = l && n === "system" ? c() : n;
        p(y);
    } catch (n) {}
};
var b = [
    "light",
    "dark"
], I = "(prefers-color-scheme: dark)", O = typeof window == "undefined", x = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"](void 0), U = {
    setTheme: (e)=>{},
    themes: []
}, z = ()=>{
    var e;
    return (e = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](x)) != null ? e : U;
}, J = (e)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](x) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], null, e.children) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](V, {
        ...e
    }), N = [
    "light",
    "dark"
], V = (param)=>{
    let { forcedTheme: e, disableTransitionOnChange: i = !1, enableSystem: s = !0, enableColorScheme: u = !0, storageKey: m = "theme", themes: a = N, defaultTheme: l = s ? "system" : "light", attribute: h = "data-theme", value: d, children: w, nonce: p, scriptProps: R } = param;
    let [c, n] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"]({
        "V.useState": ()=>H(m, l)
    }["V.useState"]), [T, y] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"]({
        "V.useState": ()=>c === "system" ? E() : c
    }["V.useState"]), k = d ? Object.values(d) : a, S = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "V.useCallback[S]": (o)=>{
            let r = o;
            if (!r) return;
            o === "system" && s && (r = E());
            let v = d ? d[r] : r, C = i ? W(p) : null, P = document.documentElement, L = {
                "V.useCallback[S].L": (g)=>{
                    g === "class" ? (P.classList.remove(...k), v && P.classList.add(v)) : g.startsWith("data-") && (v ? P.setAttribute(g, v) : P.removeAttribute(g));
                }
            }["V.useCallback[S].L"];
            if (Array.isArray(h) ? h.forEach(L) : L(h), u) {
                let g = b.includes(l) ? l : null, D = b.includes(r) ? r : g;
                P.style.colorScheme = D;
            }
            C == null || C();
        }
    }["V.useCallback[S]"], [
        p
    ]), f = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "V.useCallback[f]": (o)=>{
            let r = typeof o == "function" ? o(c) : o;
            n(r);
            try {
                localStorage.setItem(m, r);
            } catch (v) {}
        }
    }["V.useCallback[f]"], [
        c
    ]), A = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "V.useCallback[A]": (o)=>{
            let r = E(o);
            y(r), c === "system" && s && !e && S("system");
        }
    }["V.useCallback[A]"], [
        c,
        e
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "V.useEffect": ()=>{
            let o = window.matchMedia(I);
            return o.addListener(A), A(o), ({
                "V.useEffect": ()=>o.removeListener(A)
            })["V.useEffect"];
        }
    }["V.useEffect"], [
        A
    ]), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "V.useEffect": ()=>{
            let o = {
                "V.useEffect.o": (r)=>{
                    r.key === m && (r.newValue ? n(r.newValue) : f(l));
                }
            }["V.useEffect.o"];
            return window.addEventListener("storage", o), ({
                "V.useEffect": ()=>window.removeEventListener("storage", o)
            })["V.useEffect"];
        }
    }["V.useEffect"], [
        f
    ]), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "V.useEffect": ()=>{
            S(e != null ? e : c);
        }
    }["V.useEffect"], [
        e,
        c
    ]);
    let Q = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
        "V.useMemo[Q]": ()=>({
                theme: c,
                setTheme: f,
                forcedTheme: e,
                resolvedTheme: c === "system" ? T : c,
                themes: s ? [
                    ...a,
                    "system"
                ] : a,
                systemTheme: s ? T : void 0
            })
    }["V.useMemo[Q]"], [
        c,
        f,
        e,
        T,
        s,
        a
    ]);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](x.Provider, {
        value: Q
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](_, {
        forcedTheme: e,
        storageKey: m,
        attribute: h,
        enableSystem: s,
        enableColorScheme: u,
        defaultTheme: l,
        value: d,
        themes: a,
        nonce: p,
        scriptProps: R
    }), w);
}, _ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"]((param)=>{
    let { forcedTheme: e, storageKey: i, attribute: s, enableSystem: u, enableColorScheme: m, defaultTheme: a, value: l, themes: h, nonce: d, scriptProps: w } = param;
    let p = JSON.stringify([
        s,
        i,
        a,
        e,
        h,
        l,
        u,
        m
    ]).slice(1, -1);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"]("script", {
        ...w,
        suppressHydrationWarning: !0,
        nonce: typeof window == "undefined" ? d : "",
        dangerouslySetInnerHTML: {
            __html: "(".concat(M.toString(), ")(").concat(p, ")")
        }
    });
}), H = (e, i)=>{
    if (O) return;
    let s;
    try {
        s = localStorage.getItem(e) || void 0;
    } catch (u) {}
    return s || i;
}, W = (e)=>{
    let i = document.createElement("style");
    return e && i.setAttribute("nonce", e), i.appendChild(document.createTextNode("*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), document.head.appendChild(i), ()=>{
        window.getComputedStyle(document.body), setTimeout(()=>{
            document.head.removeChild(i);
        }, 1);
    };
}, E = (e)=>(e || (e = window.matchMedia(I)), e.matches ? "dark" : "light");
;
}),
"[project]/node_modules/sonner/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Toaster": ()=>Toaster,
    "toast": ()=>toast,
    "useSonner": ()=>useSonner
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)");
'use client';
function __insertCSS(code) {
    if (!code || typeof document == 'undefined') return;
    let head = document.head || document.getElementsByTagName('head')[0];
    let style = document.createElement('style');
    style.type = 'text/css';
    head.appendChild(style);
    style.styleSheet ? style.styleSheet.cssText = code : style.appendChild(document.createTextNode(code));
}
;
;
const getAsset = (type)=>{
    switch(type){
        case 'success':
            return SuccessIcon;
        case 'info':
            return InfoIcon;
        case 'warning':
            return WarningIcon;
        case 'error':
            return ErrorIcon;
        default:
            return null;
    }
};
const bars = Array(12).fill(0);
const Loader = (param)=>{
    let { visible, className } = param;
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        className: [
            'sonner-loading-wrapper',
            className
        ].filter(Boolean).join(' '),
        "data-visible": visible
    }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        className: "sonner-spinner"
    }, bars.map((_, i)=>/*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
            className: "sonner-loading-bar",
            key: "spinner-bar-".concat(i)
        }))));
};
const SuccessIcon = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    height: "20",
    width: "20"
}, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("path", {
    fillRule: "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
    clipRule: "evenodd"
}));
const WarningIcon = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    height: "20",
    width: "20"
}, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("path", {
    fillRule: "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    clipRule: "evenodd"
}));
const InfoIcon = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    height: "20",
    width: "20"
}, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("path", {
    fillRule: "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
    clipRule: "evenodd"
}));
const ErrorIcon = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    height: "20",
    width: "20"
}, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("path", {
    fillRule: "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
    clipRule: "evenodd"
}));
const CloseIcon = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "12",
    height: "12",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("line", {
    x1: "18",
    y1: "6",
    x2: "6",
    y2: "18"
}), /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("line", {
    x1: "6",
    y1: "6",
    x2: "18",
    y2: "18"
}));
const useIsDocumentHidden = ()=>{
    const [isDocumentHidden, setIsDocumentHidden] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(document.hidden);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "useIsDocumentHidden.useEffect": ()=>{
            const callback = {
                "useIsDocumentHidden.useEffect.callback": ()=>{
                    setIsDocumentHidden(document.hidden);
                }
            }["useIsDocumentHidden.useEffect.callback"];
            document.addEventListener('visibilitychange', callback);
            return ({
                "useIsDocumentHidden.useEffect": ()=>window.removeEventListener('visibilitychange', callback)
            })["useIsDocumentHidden.useEffect"];
        }
    }["useIsDocumentHidden.useEffect"], []);
    return isDocumentHidden;
};
let toastsCounter = 1;
class Observer {
    constructor(){
        // We use arrow functions to maintain the correct `this` reference
        this.subscribe = (subscriber)=>{
            this.subscribers.push(subscriber);
            return ()=>{
                const index = this.subscribers.indexOf(subscriber);
                this.subscribers.splice(index, 1);
            };
        };
        this.publish = (data)=>{
            this.subscribers.forEach((subscriber)=>subscriber(data));
        };
        this.addToast = (data)=>{
            this.publish(data);
            this.toasts = [
                ...this.toasts,
                data
            ];
        };
        this.create = (data)=>{
            var _data_id;
            const { message, ...rest } = data;
            const id = typeof (data == null ? void 0 : data.id) === 'number' || ((_data_id = data.id) == null ? void 0 : _data_id.length) > 0 ? data.id : toastsCounter++;
            const alreadyExists = this.toasts.find((toast)=>{
                return toast.id === id;
            });
            const dismissible = data.dismissible === undefined ? true : data.dismissible;
            if (this.dismissedToasts.has(id)) {
                this.dismissedToasts.delete(id);
            }
            if (alreadyExists) {
                this.toasts = this.toasts.map((toast)=>{
                    if (toast.id === id) {
                        this.publish({
                            ...toast,
                            ...data,
                            id,
                            title: message
                        });
                        return {
                            ...toast,
                            ...data,
                            id,
                            dismissible,
                            title: message
                        };
                    }
                    return toast;
                });
            } else {
                this.addToast({
                    title: message,
                    ...rest,
                    dismissible,
                    id
                });
            }
            return id;
        };
        this.dismiss = (id)=>{
            if (id) {
                this.dismissedToasts.add(id);
                requestAnimationFrame(()=>this.subscribers.forEach((subscriber)=>subscriber({
                            id,
                            dismiss: true
                        })));
            } else {
                this.toasts.forEach((toast)=>{
                    this.subscribers.forEach((subscriber)=>subscriber({
                            id: toast.id,
                            dismiss: true
                        }));
                });
            }
            return id;
        };
        this.message = (message, data)=>{
            return this.create({
                ...data,
                message
            });
        };
        this.error = (message, data)=>{
            return this.create({
                ...data,
                message,
                type: 'error'
            });
        };
        this.success = (message, data)=>{
            return this.create({
                ...data,
                type: 'success',
                message
            });
        };
        this.info = (message, data)=>{
            return this.create({
                ...data,
                type: 'info',
                message
            });
        };
        this.warning = (message, data)=>{
            return this.create({
                ...data,
                type: 'warning',
                message
            });
        };
        this.loading = (message, data)=>{
            return this.create({
                ...data,
                type: 'loading',
                message
            });
        };
        this.promise = (promise, data)=>{
            if (!data) {
                // Nothing to show
                return;
            }
            let id = undefined;
            if (data.loading !== undefined) {
                id = this.create({
                    ...data,
                    promise,
                    type: 'loading',
                    message: data.loading,
                    description: typeof data.description !== 'function' ? data.description : undefined
                });
            }
            const p = Promise.resolve(promise instanceof Function ? promise() : promise);
            let shouldDismiss = id !== undefined;
            let result;
            const originalPromise = p.then(async (response)=>{
                result = [
                    'resolve',
                    response
                ];
                const isReactElementResponse = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(response);
                if (isReactElementResponse) {
                    shouldDismiss = false;
                    this.create({
                        id,
                        type: 'default',
                        message: response
                    });
                } else if (isHttpResponse(response) && !response.ok) {
                    shouldDismiss = false;
                    const promiseData = typeof data.error === 'function' ? await data.error("HTTP error! status: ".concat(response.status)) : data.error;
                    const description = typeof data.description === 'function' ? await data.description("HTTP error! status: ".concat(response.status)) : data.description;
                    const isExtendedResult = typeof promiseData === 'object' && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(promiseData);
                    const toastSettings = isExtendedResult ? promiseData : {
                        message: promiseData
                    };
                    this.create({
                        id,
                        type: 'error',
                        description,
                        ...toastSettings
                    });
                } else if (response instanceof Error) {
                    shouldDismiss = false;
                    const promiseData = typeof data.error === 'function' ? await data.error(response) : data.error;
                    const description = typeof data.description === 'function' ? await data.description(response) : data.description;
                    const isExtendedResult = typeof promiseData === 'object' && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(promiseData);
                    const toastSettings = isExtendedResult ? promiseData : {
                        message: promiseData
                    };
                    this.create({
                        id,
                        type: 'error',
                        description,
                        ...toastSettings
                    });
                } else if (data.success !== undefined) {
                    shouldDismiss = false;
                    const promiseData = typeof data.success === 'function' ? await data.success(response) : data.success;
                    const description = typeof data.description === 'function' ? await data.description(response) : data.description;
                    const isExtendedResult = typeof promiseData === 'object' && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(promiseData);
                    const toastSettings = isExtendedResult ? promiseData : {
                        message: promiseData
                    };
                    this.create({
                        id,
                        type: 'success',
                        description,
                        ...toastSettings
                    });
                }
            }).catch(async (error)=>{
                result = [
                    'reject',
                    error
                ];
                if (data.error !== undefined) {
                    shouldDismiss = false;
                    const promiseData = typeof data.error === 'function' ? await data.error(error) : data.error;
                    const description = typeof data.description === 'function' ? await data.description(error) : data.description;
                    const isExtendedResult = typeof promiseData === 'object' && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(promiseData);
                    const toastSettings = isExtendedResult ? promiseData : {
                        message: promiseData
                    };
                    this.create({
                        id,
                        type: 'error',
                        description,
                        ...toastSettings
                    });
                }
            }).finally(()=>{
                if (shouldDismiss) {
                    // Toast is still in load state (and will be indefinitely  dismiss it)
                    this.dismiss(id);
                    id = undefined;
                }
                data.finally == null ? void 0 : data.finally.call(data);
            });
            const unwrap = ()=>new Promise((resolve, reject)=>originalPromise.then(()=>result[0] === 'reject' ? reject(result[1]) : resolve(result[1])).catch(reject));
            if (typeof id !== 'string' && typeof id !== 'number') {
                // cannot Object.assign on undefined
                return {
                    unwrap
                };
            } else {
                return Object.assign(id, {
                    unwrap
                });
            }
        };
        this.custom = (jsx, data)=>{
            const id = (data == null ? void 0 : data.id) || toastsCounter++;
            this.create({
                jsx: jsx(id),
                id,
                ...data
            });
            return id;
        };
        this.getActiveToasts = ()=>{
            return this.toasts.filter((toast)=>!this.dismissedToasts.has(toast.id));
        };
        this.subscribers = [];
        this.toasts = [];
        this.dismissedToasts = new Set();
    }
}
const ToastState = new Observer();
// bind this to the toast function
const toastFunction = (message, data)=>{
    const id = (data == null ? void 0 : data.id) || toastsCounter++;
    ToastState.addToast({
        title: message,
        ...data,
        id
    });
    return id;
};
const isHttpResponse = (data)=>{
    return data && typeof data === 'object' && 'ok' in data && typeof data.ok === 'boolean' && 'status' in data && typeof data.status === 'number';
};
const basicToast = toastFunction;
const getHistory = ()=>ToastState.toasts;
const getToasts = ()=>ToastState.getActiveToasts();
// We use `Object.assign` to maintain the correct types as we would lose them otherwise
const toast = Object.assign(basicToast, {
    success: ToastState.success,
    info: ToastState.info,
    warning: ToastState.warning,
    error: ToastState.error,
    custom: ToastState.custom,
    message: ToastState.message,
    promise: ToastState.promise,
    dismiss: ToastState.dismiss,
    loading: ToastState.loading
}, {
    getHistory,
    getToasts
});
__insertCSS("[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-rich-colors=true][data-sonner-toast][data-styled=true] [data-description]{color:inherit}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast][data-expanded=true]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}");
function isAction(action) {
    return action.label !== undefined;
}
// Visible toasts amount
const VISIBLE_TOASTS_AMOUNT = 3;
// Viewport padding
const VIEWPORT_OFFSET = '24px';
// Mobile viewport padding
const MOBILE_VIEWPORT_OFFSET = '16px';
// Default lifetime of a toasts (in ms)
const TOAST_LIFETIME = 4000;
// Default toast width
const TOAST_WIDTH = 356;
// Default gap between toasts
const GAP = 14;
// Threshold to dismiss a toast
const SWIPE_THRESHOLD = 45;
// Equal to exit animation duration
const TIME_BEFORE_UNMOUNT = 200;
function cn() {
    for(var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++){
        classes[_key] = arguments[_key];
    }
    return classes.filter(Boolean).join(' ');
}
function getDefaultSwipeDirections(position) {
    const [y, x] = position.split('-');
    const directions = [];
    if (y) {
        directions.push(y);
    }
    if (x) {
        directions.push(x);
    }
    return directions;
}
const Toast = (props)=>{
    var _toast_classNames, _toast_classNames1, _toast_classNames2, _toast_classNames3, _toast_classNames4, _toast_classNames5, _toast_classNames6, _toast_classNames7, _toast_classNames8;
    const { invert: ToasterInvert, toast, unstyled, interacting, setHeights, visibleToasts, heights, index, toasts, expanded, removeToast, defaultRichColors, closeButton: closeButtonFromToaster, style, cancelButtonStyle, actionButtonStyle, className = '', descriptionClassName = '', duration: durationFromToaster, position, gap, expandByDefault, classNames, icons, closeButtonAriaLabel = 'Close toast' } = props;
    const [swipeDirection, setSwipeDirection] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(null);
    const [swipeOutDirection, setSwipeOutDirection] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(null);
    const [mounted, setMounted] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(false);
    const [removed, setRemoved] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(false);
    const [swiping, setSwiping] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(false);
    const [swipeOut, setSwipeOut] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(false);
    const [isSwiped, setIsSwiped] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(false);
    const [offsetBeforeRemove, setOffsetBeforeRemove] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(0);
    const [initialHeight, setInitialHeight] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(0);
    const remainingTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(toast.duration || durationFromToaster || TOAST_LIFETIME);
    const dragStartTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(null);
    const toastRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(null);
    const isFront = index === 0;
    const isVisible = index + 1 <= visibleToasts;
    const toastType = toast.type;
    const dismissible = toast.dismissible !== false;
    const toastClassname = toast.className || '';
    const toastDescriptionClassname = toast.descriptionClassName || '';
    // Height index is used to calculate the offset as it gets updated before the toast array, which means we can calculate the new layout faster.
    const heightIndex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "Toast.useMemo[heightIndex]": ()=>heights.findIndex({
                "Toast.useMemo[heightIndex]": (height)=>height.toastId === toast.id
            }["Toast.useMemo[heightIndex]"]) || 0
    }["Toast.useMemo[heightIndex]"], [
        heights,
        toast.id
    ]);
    const closeButton = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "Toast.useMemo[closeButton]": ()=>{
            var _toast_closeButton;
            return (_toast_closeButton = toast.closeButton) != null ? _toast_closeButton : closeButtonFromToaster;
        }
    }["Toast.useMemo[closeButton]"], [
        toast.closeButton,
        closeButtonFromToaster
    ]);
    const duration = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "Toast.useMemo[duration]": ()=>toast.duration || durationFromToaster || TOAST_LIFETIME
    }["Toast.useMemo[duration]"], [
        toast.duration,
        durationFromToaster
    ]);
    const closeTimerStartTimeRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(0);
    const offset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(0);
    const lastCloseTimerStartTimeRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(0);
    const pointerStartRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(null);
    const [y, x] = position.split('-');
    const toastsHeightBefore = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "Toast.useMemo[toastsHeightBefore]": ()=>{
            return heights.reduce({
                "Toast.useMemo[toastsHeightBefore]": (prev, curr, reducerIndex)=>{
                    // Calculate offset up until current toast
                    if (reducerIndex >= heightIndex) {
                        return prev;
                    }
                    return prev + curr.height;
                }
            }["Toast.useMemo[toastsHeightBefore]"], 0);
        }
    }["Toast.useMemo[toastsHeightBefore]"], [
        heights,
        heightIndex
    ]);
    const isDocumentHidden = useIsDocumentHidden();
    const invert = toast.invert || ToasterInvert;
    const disabled = toastType === 'loading';
    offset.current = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "Toast.useMemo": ()=>heightIndex * gap + toastsHeightBefore
    }["Toast.useMemo"], [
        heightIndex,
        toastsHeightBefore
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toast.useEffect": ()=>{
            remainingTime.current = duration;
        }
    }["Toast.useEffect"], [
        duration
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toast.useEffect": ()=>{
            // Trigger enter animation without using CSS animation
            setMounted(true);
        }
    }["Toast.useEffect"], []);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toast.useEffect": ()=>{
            const toastNode = toastRef.current;
            if (toastNode) {
                const height = toastNode.getBoundingClientRect().height;
                // Add toast height to heights array after the toast is mounted
                setInitialHeight(height);
                setHeights({
                    "Toast.useEffect": (h)=>[
                            {
                                toastId: toast.id,
                                height,
                                position: toast.position
                            },
                            ...h
                        ]
                }["Toast.useEffect"]);
                return ({
                    "Toast.useEffect": ()=>setHeights({
                            "Toast.useEffect": (h)=>h.filter({
                                    "Toast.useEffect": (height)=>height.toastId !== toast.id
                                }["Toast.useEffect"])
                        }["Toast.useEffect"])
                })["Toast.useEffect"];
            }
        }
    }["Toast.useEffect"], [
        setHeights,
        toast.id
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useLayoutEffect({
        "Toast.useLayoutEffect": ()=>{
            // Keep height up to date with the content in case it updates
            if (!mounted) return;
            const toastNode = toastRef.current;
            const originalHeight = toastNode.style.height;
            toastNode.style.height = 'auto';
            const newHeight = toastNode.getBoundingClientRect().height;
            toastNode.style.height = originalHeight;
            setInitialHeight(newHeight);
            setHeights({
                "Toast.useLayoutEffect": (heights)=>{
                    const alreadyExists = heights.find({
                        "Toast.useLayoutEffect.alreadyExists": (height)=>height.toastId === toast.id
                    }["Toast.useLayoutEffect.alreadyExists"]);
                    if (!alreadyExists) {
                        return [
                            {
                                toastId: toast.id,
                                height: newHeight,
                                position: toast.position
                            },
                            ...heights
                        ];
                    } else {
                        return heights.map({
                            "Toast.useLayoutEffect": (height)=>height.toastId === toast.id ? {
                                    ...height,
                                    height: newHeight
                                } : height
                        }["Toast.useLayoutEffect"]);
                    }
                }
            }["Toast.useLayoutEffect"]);
        }
    }["Toast.useLayoutEffect"], [
        mounted,
        toast.title,
        toast.description,
        setHeights,
        toast.id,
        toast.jsx,
        toast.action,
        toast.cancel
    ]);
    const deleteToast = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useCallback({
        "Toast.useCallback[deleteToast]": ()=>{
            // Save the offset for the exit swipe animation
            setRemoved(true);
            setOffsetBeforeRemove(offset.current);
            setHeights({
                "Toast.useCallback[deleteToast]": (h)=>h.filter({
                        "Toast.useCallback[deleteToast]": (height)=>height.toastId !== toast.id
                    }["Toast.useCallback[deleteToast]"])
            }["Toast.useCallback[deleteToast]"]);
            setTimeout({
                "Toast.useCallback[deleteToast]": ()=>{
                    removeToast(toast);
                }
            }["Toast.useCallback[deleteToast]"], TIME_BEFORE_UNMOUNT);
        }
    }["Toast.useCallback[deleteToast]"], [
        toast,
        removeToast,
        setHeights,
        offset
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toast.useEffect": ()=>{
            if (toast.promise && toastType === 'loading' || toast.duration === Infinity || toast.type === 'loading') return;
            let timeoutId;
            // Pause the timer on each hover
            const pauseTimer = {
                "Toast.useEffect.pauseTimer": ()=>{
                    if (lastCloseTimerStartTimeRef.current < closeTimerStartTimeRef.current) {
                        // Get the elapsed time since the timer started
                        const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.current;
                        remainingTime.current = remainingTime.current - elapsedTime;
                    }
                    lastCloseTimerStartTimeRef.current = new Date().getTime();
                }
            }["Toast.useEffect.pauseTimer"];
            const startTimer = {
                "Toast.useEffect.startTimer": ()=>{
                    // setTimeout(, Infinity) behaves as if the delay is 0.
                    // As a result, the toast would be closed immediately, giving the appearance that it was never rendered.
                    // See: https://github.com/denysdovhan/wtfjs?tab=readme-ov-file#an-infinite-timeout
                    if (remainingTime.current === Infinity) return;
                    closeTimerStartTimeRef.current = new Date().getTime();
                    // Let the toast know it has started
                    timeoutId = setTimeout({
                        "Toast.useEffect.startTimer": ()=>{
                            toast.onAutoClose == null ? void 0 : toast.onAutoClose.call(toast, toast);
                            deleteToast();
                        }
                    }["Toast.useEffect.startTimer"], remainingTime.current);
                }
            }["Toast.useEffect.startTimer"];
            if (expanded || interacting || isDocumentHidden) {
                pauseTimer();
            } else {
                startTimer();
            }
            return ({
                "Toast.useEffect": ()=>clearTimeout(timeoutId)
            })["Toast.useEffect"];
        }
    }["Toast.useEffect"], [
        expanded,
        interacting,
        toast,
        toastType,
        isDocumentHidden,
        deleteToast
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toast.useEffect": ()=>{
            if (toast.delete) {
                deleteToast();
                toast.onDismiss == null ? void 0 : toast.onDismiss.call(toast, toast);
            }
        }
    }["Toast.useEffect"], [
        deleteToast,
        toast.delete
    ]);
    function getLoadingIcon() {
        var _toast_classNames;
        if (icons == null ? void 0 : icons.loading) {
            var _toast_classNames1;
            return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
                className: cn(classNames == null ? void 0 : classNames.loader, toast == null ? void 0 : (_toast_classNames1 = toast.classNames) == null ? void 0 : _toast_classNames1.loader, 'sonner-loader'),
                "data-visible": toastType === 'loading'
            }, icons.loading);
        }
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Loader, {
            className: cn(classNames == null ? void 0 : classNames.loader, toast == null ? void 0 : (_toast_classNames = toast.classNames) == null ? void 0 : _toast_classNames.loader),
            visible: toastType === 'loading'
        });
    }
    const icon = toast.icon || (icons == null ? void 0 : icons[toastType]) || getAsset(toastType);
    var _toast_richColors, _icons_close;
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("li", {
        tabIndex: 0,
        ref: toastRef,
        className: cn(className, toastClassname, classNames == null ? void 0 : classNames.toast, toast == null ? void 0 : (_toast_classNames = toast.classNames) == null ? void 0 : _toast_classNames.toast, classNames == null ? void 0 : classNames.default, classNames == null ? void 0 : classNames[toastType], toast == null ? void 0 : (_toast_classNames1 = toast.classNames) == null ? void 0 : _toast_classNames1[toastType]),
        "data-sonner-toast": "",
        "data-rich-colors": (_toast_richColors = toast.richColors) != null ? _toast_richColors : defaultRichColors,
        "data-styled": !Boolean(toast.jsx || toast.unstyled || unstyled),
        "data-mounted": mounted,
        "data-promise": Boolean(toast.promise),
        "data-swiped": isSwiped,
        "data-removed": removed,
        "data-visible": isVisible,
        "data-y-position": y,
        "data-x-position": x,
        "data-index": index,
        "data-front": isFront,
        "data-swiping": swiping,
        "data-dismissible": dismissible,
        "data-type": toastType,
        "data-invert": invert,
        "data-swipe-out": swipeOut,
        "data-swipe-direction": swipeOutDirection,
        "data-expanded": Boolean(expanded || expandByDefault && mounted),
        style: {
            '--index': index,
            '--toasts-before': index,
            '--z-index': toasts.length - index,
            '--offset': "".concat(removed ? offsetBeforeRemove : offset.current, "px"),
            '--initial-height': expandByDefault ? 'auto' : "".concat(initialHeight, "px"),
            ...style,
            ...toast.style
        },
        onDragEnd: ()=>{
            setSwiping(false);
            setSwipeDirection(null);
            pointerStartRef.current = null;
        },
        onPointerDown: (event)=>{
            if (event.button === 2) return; // Return early on right click
            if (disabled || !dismissible) return;
            dragStartTime.current = new Date();
            setOffsetBeforeRemove(offset.current);
            // Ensure we maintain correct pointer capture even when going outside of the toast (e.g. when swiping)
            event.target.setPointerCapture(event.pointerId);
            if (event.target.tagName === 'BUTTON') return;
            setSwiping(true);
            pointerStartRef.current = {
                x: event.clientX,
                y: event.clientY
            };
        },
        onPointerUp: ()=>{
            var _toastRef_current, _toastRef_current1, _dragStartTime_current;
            if (swipeOut || !dismissible) return;
            pointerStartRef.current = null;
            const swipeAmountX = Number(((_toastRef_current = toastRef.current) == null ? void 0 : _toastRef_current.style.getPropertyValue('--swipe-amount-x').replace('px', '')) || 0);
            const swipeAmountY = Number(((_toastRef_current1 = toastRef.current) == null ? void 0 : _toastRef_current1.style.getPropertyValue('--swipe-amount-y').replace('px', '')) || 0);
            const timeTaken = new Date().getTime() - ((_dragStartTime_current = dragStartTime.current) == null ? void 0 : _dragStartTime_current.getTime());
            const swipeAmount = swipeDirection === 'x' ? swipeAmountX : swipeAmountY;
            const velocity = Math.abs(swipeAmount) / timeTaken;
            if (Math.abs(swipeAmount) >= SWIPE_THRESHOLD || velocity > 0.11) {
                setOffsetBeforeRemove(offset.current);
                toast.onDismiss == null ? void 0 : toast.onDismiss.call(toast, toast);
                if (swipeDirection === 'x') {
                    setSwipeOutDirection(swipeAmountX > 0 ? 'right' : 'left');
                } else {
                    setSwipeOutDirection(swipeAmountY > 0 ? 'down' : 'up');
                }
                deleteToast();
                setSwipeOut(true);
                return;
            } else {
                var _toastRef_current2, _toastRef_current3;
                (_toastRef_current2 = toastRef.current) == null ? void 0 : _toastRef_current2.style.setProperty('--swipe-amount-x', "0px");
                (_toastRef_current3 = toastRef.current) == null ? void 0 : _toastRef_current3.style.setProperty('--swipe-amount-y', "0px");
            }
            setIsSwiped(false);
            setSwiping(false);
            setSwipeDirection(null);
        },
        onPointerMove: (event)=>{
            var _window_getSelection, _toastRef_current, _toastRef_current1;
            if (!pointerStartRef.current || !dismissible) return;
            const isHighlighted = ((_window_getSelection = window.getSelection()) == null ? void 0 : _window_getSelection.toString().length) > 0;
            if (isHighlighted) return;
            const yDelta = event.clientY - pointerStartRef.current.y;
            const xDelta = event.clientX - pointerStartRef.current.x;
            var _props_swipeDirections;
            const swipeDirections = (_props_swipeDirections = props.swipeDirections) != null ? _props_swipeDirections : getDefaultSwipeDirections(position);
            // Determine swipe direction if not already locked
            if (!swipeDirection && (Math.abs(xDelta) > 1 || Math.abs(yDelta) > 1)) {
                setSwipeDirection(Math.abs(xDelta) > Math.abs(yDelta) ? 'x' : 'y');
            }
            let swipeAmount = {
                x: 0,
                y: 0
            };
            const getDampening = (delta)=>{
                const factor = Math.abs(delta) / 20;
                return 1 / (1.5 + factor);
            };
            // Only apply swipe in the locked direction
            if (swipeDirection === 'y') {
                // Handle vertical swipes
                if (swipeDirections.includes('top') || swipeDirections.includes('bottom')) {
                    if (swipeDirections.includes('top') && yDelta < 0 || swipeDirections.includes('bottom') && yDelta > 0) {
                        swipeAmount.y = yDelta;
                    } else {
                        // Smoothly transition to dampened movement
                        const dampenedDelta = yDelta * getDampening(yDelta);
                        // Ensure we don't jump when transitioning to dampened movement
                        swipeAmount.y = Math.abs(dampenedDelta) < Math.abs(yDelta) ? dampenedDelta : yDelta;
                    }
                }
            } else if (swipeDirection === 'x') {
                // Handle horizontal swipes
                if (swipeDirections.includes('left') || swipeDirections.includes('right')) {
                    if (swipeDirections.includes('left') && xDelta < 0 || swipeDirections.includes('right') && xDelta > 0) {
                        swipeAmount.x = xDelta;
                    } else {
                        // Smoothly transition to dampened movement
                        const dampenedDelta = xDelta * getDampening(xDelta);
                        // Ensure we don't jump when transitioning to dampened movement
                        swipeAmount.x = Math.abs(dampenedDelta) < Math.abs(xDelta) ? dampenedDelta : xDelta;
                    }
                }
            }
            if (Math.abs(swipeAmount.x) > 0 || Math.abs(swipeAmount.y) > 0) {
                setIsSwiped(true);
            }
            (_toastRef_current = toastRef.current) == null ? void 0 : _toastRef_current.style.setProperty('--swipe-amount-x', "".concat(swipeAmount.x, "px"));
            (_toastRef_current1 = toastRef.current) == null ? void 0 : _toastRef_current1.style.setProperty('--swipe-amount-y', "".concat(swipeAmount.y, "px"));
        }
    }, closeButton && !toast.jsx && toastType !== 'loading' ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("button", {
        "aria-label": closeButtonAriaLabel,
        "data-disabled": disabled,
        "data-close-button": true,
        onClick: disabled || !dismissible ? ()=>{} : ()=>{
            deleteToast();
            toast.onDismiss == null ? void 0 : toast.onDismiss.call(toast, toast);
        },
        className: cn(classNames == null ? void 0 : classNames.closeButton, toast == null ? void 0 : (_toast_classNames2 = toast.classNames) == null ? void 0 : _toast_classNames2.closeButton)
    }, (_icons_close = icons == null ? void 0 : icons.close) != null ? _icons_close : CloseIcon) : null, (toastType || toast.icon || toast.promise) && toast.icon !== null && ((icons == null ? void 0 : icons[toastType]) !== null || toast.icon) ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        "data-icon": "",
        className: cn(classNames == null ? void 0 : classNames.icon, toast == null ? void 0 : (_toast_classNames3 = toast.classNames) == null ? void 0 : _toast_classNames3.icon)
    }, toast.promise || toast.type === 'loading' && !toast.icon ? toast.icon || getLoadingIcon() : null, toast.type !== 'loading' ? icon : null) : null, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        "data-content": "",
        className: cn(classNames == null ? void 0 : classNames.content, toast == null ? void 0 : (_toast_classNames4 = toast.classNames) == null ? void 0 : _toast_classNames4.content)
    }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        "data-title": "",
        className: cn(classNames == null ? void 0 : classNames.title, toast == null ? void 0 : (_toast_classNames5 = toast.classNames) == null ? void 0 : _toast_classNames5.title)
    }, toast.jsx ? toast.jsx : typeof toast.title === 'function' ? toast.title() : toast.title), toast.description ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
        "data-description": "",
        className: cn(descriptionClassName, toastDescriptionClassname, classNames == null ? void 0 : classNames.description, toast == null ? void 0 : (_toast_classNames6 = toast.classNames) == null ? void 0 : _toast_classNames6.description)
    }, typeof toast.description === 'function' ? toast.description() : toast.description) : null), /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(toast.cancel) ? toast.cancel : toast.cancel && isAction(toast.cancel) ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("button", {
        "data-button": true,
        "data-cancel": true,
        style: toast.cancelButtonStyle || cancelButtonStyle,
        onClick: (event)=>{
            // We need to check twice because typescript
            if (!isAction(toast.cancel)) return;
            if (!dismissible) return;
            toast.cancel.onClick == null ? void 0 : toast.cancel.onClick.call(toast.cancel, event);
            deleteToast();
        },
        className: cn(classNames == null ? void 0 : classNames.cancelButton, toast == null ? void 0 : (_toast_classNames7 = toast.classNames) == null ? void 0 : _toast_classNames7.cancelButton)
    }, toast.cancel.label) : null, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isValidElement(toast.action) ? toast.action : toast.action && isAction(toast.action) ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("button", {
        "data-button": true,
        "data-action": true,
        style: toast.actionButtonStyle || actionButtonStyle,
        onClick: (event)=>{
            // We need to check twice because typescript
            if (!isAction(toast.action)) return;
            toast.action.onClick == null ? void 0 : toast.action.onClick.call(toast.action, event);
            if (event.defaultPrevented) return;
            deleteToast();
        },
        className: cn(classNames == null ? void 0 : classNames.actionButton, toast == null ? void 0 : (_toast_classNames8 = toast.classNames) == null ? void 0 : _toast_classNames8.actionButton)
    }, toast.action.label) : null);
};
function getDocumentDirection() {
    if (typeof window === 'undefined') return 'ltr';
    if (typeof document === 'undefined') return 'ltr'; // For Fresh purpose
    const dirAttribute = document.documentElement.getAttribute('dir');
    if (dirAttribute === 'auto' || !dirAttribute) {
        return window.getComputedStyle(document.documentElement).direction;
    }
    return dirAttribute;
}
function assignOffset(defaultOffset, mobileOffset) {
    const styles = {};
    [
        defaultOffset,
        mobileOffset
    ].forEach((offset, index)=>{
        const isMobile = index === 1;
        const prefix = isMobile ? '--mobile-offset' : '--offset';
        const defaultValue = isMobile ? MOBILE_VIEWPORT_OFFSET : VIEWPORT_OFFSET;
        function assignAll(offset) {
            [
                'top',
                'right',
                'bottom',
                'left'
            ].forEach((key)=>{
                styles["".concat(prefix, "-").concat(key)] = typeof offset === 'number' ? "".concat(offset, "px") : offset;
            });
        }
        if (typeof offset === 'number' || typeof offset === 'string') {
            assignAll(offset);
        } else if (typeof offset === 'object') {
            [
                'top',
                'right',
                'bottom',
                'left'
            ].forEach((key)=>{
                if (offset[key] === undefined) {
                    styles["".concat(prefix, "-").concat(key)] = defaultValue;
                } else {
                    styles["".concat(prefix, "-").concat(key)] = typeof offset[key] === 'number' ? "".concat(offset[key], "px") : offset[key];
                }
            });
        } else {
            assignAll(defaultValue);
        }
    });
    return styles;
}
function useSonner() {
    const [activeToasts, setActiveToasts] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState([]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "useSonner.useEffect": ()=>{
            return ToastState.subscribe({
                "useSonner.useEffect": (toast)=>{
                    if (toast.dismiss) {
                        setTimeout({
                            "useSonner.useEffect": ()=>{
                                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].flushSync({
                                    "useSonner.useEffect": ()=>{
                                        setActiveToasts({
                                            "useSonner.useEffect": (toasts)=>toasts.filter({
                                                    "useSonner.useEffect": (t)=>t.id !== toast.id
                                                }["useSonner.useEffect"])
                                        }["useSonner.useEffect"]);
                                    }
                                }["useSonner.useEffect"]);
                            }
                        }["useSonner.useEffect"]);
                        return;
                    }
                    // Prevent batching, temp solution.
                    setTimeout({
                        "useSonner.useEffect": ()=>{
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].flushSync({
                                "useSonner.useEffect": ()=>{
                                    setActiveToasts({
                                        "useSonner.useEffect": (toasts)=>{
                                            const indexOfExistingToast = toasts.findIndex({
                                                "useSonner.useEffect.indexOfExistingToast": (t)=>t.id === toast.id
                                            }["useSonner.useEffect.indexOfExistingToast"]);
                                            // Update the toast if it already exists
                                            if (indexOfExistingToast !== -1) {
                                                return [
                                                    ...toasts.slice(0, indexOfExistingToast),
                                                    {
                                                        ...toasts[indexOfExistingToast],
                                                        ...toast
                                                    },
                                                    ...toasts.slice(indexOfExistingToast + 1)
                                                ];
                                            }
                                            return [
                                                toast,
                                                ...toasts
                                            ];
                                        }
                                    }["useSonner.useEffect"]);
                                }
                            }["useSonner.useEffect"]);
                        }
                    }["useSonner.useEffect"]);
                }
            }["useSonner.useEffect"]);
        }
    }["useSonner.useEffect"], []);
    return {
        toasts: activeToasts
    };
}
const Toaster = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forwardRef(function Toaster(props, ref) {
    const { invert, position = 'bottom-right', hotkey = [
        'altKey',
        'KeyT'
    ], expand, closeButton, className, offset, mobileOffset, theme = 'light', richColors, duration, style, visibleToasts = VISIBLE_TOASTS_AMOUNT, toastOptions, dir = getDocumentDirection(), gap = GAP, icons, containerAriaLabel = 'Notifications' } = props;
    const [toasts, setToasts] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState([]);
    const possiblePositions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "Toaster.Toaster.useMemo[possiblePositions]": ()=>{
            return Array.from(new Set([
                position
            ].concat(toasts.filter({
                "Toaster.Toaster.useMemo[possiblePositions]": (toast)=>toast.position
            }["Toaster.Toaster.useMemo[possiblePositions]"]).map({
                "Toaster.Toaster.useMemo[possiblePositions]": (toast)=>toast.position
            }["Toaster.Toaster.useMemo[possiblePositions]"]))));
        }
    }["Toaster.Toaster.useMemo[possiblePositions]"], [
        toasts,
        position
    ]);
    const [heights, setHeights] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState([]);
    const [expanded, setExpanded] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(false);
    const [interacting, setInteracting] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(false);
    const [actualTheme, setActualTheme] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(theme !== 'system' ? theme : typeof window !== 'undefined' ? window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light' : 'light');
    const listRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(null);
    const hotkeyLabel = hotkey.join('+').replace(/Key/g, '').replace(/Digit/g, '');
    const lastFocusedElementRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(null);
    const isFocusWithinRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(false);
    const removeToast = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useCallback({
        "Toaster.Toaster.useCallback[removeToast]": (toastToRemove)=>{
            setToasts({
                "Toaster.Toaster.useCallback[removeToast]": (toasts)=>{
                    var _toasts_find;
                    if (!((_toasts_find = toasts.find({
                        "Toaster.Toaster.useCallback[removeToast]": (toast)=>toast.id === toastToRemove.id
                    }["Toaster.Toaster.useCallback[removeToast]"])) == null ? void 0 : _toasts_find.delete)) {
                        ToastState.dismiss(toastToRemove.id);
                    }
                    return toasts.filter({
                        "Toaster.Toaster.useCallback[removeToast]": (param)=>{
                            let { id } = param;
                            return id !== toastToRemove.id;
                        }
                    }["Toaster.Toaster.useCallback[removeToast]"]);
                }
            }["Toaster.Toaster.useCallback[removeToast]"]);
        }
    }["Toaster.Toaster.useCallback[removeToast]"], []);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toaster.Toaster.useEffect": ()=>{
            return ToastState.subscribe({
                "Toaster.Toaster.useEffect": (toast)=>{
                    if (toast.dismiss) {
                        // Prevent batching of other state updates
                        requestAnimationFrame({
                            "Toaster.Toaster.useEffect": ()=>{
                                setToasts({
                                    "Toaster.Toaster.useEffect": (toasts)=>toasts.map({
                                            "Toaster.Toaster.useEffect": (t)=>t.id === toast.id ? {
                                                    ...t,
                                                    delete: true
                                                } : t
                                        }["Toaster.Toaster.useEffect"])
                                }["Toaster.Toaster.useEffect"]);
                            }
                        }["Toaster.Toaster.useEffect"]);
                        return;
                    }
                    // Prevent batching, temp solution.
                    setTimeout({
                        "Toaster.Toaster.useEffect": ()=>{
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].flushSync({
                                "Toaster.Toaster.useEffect": ()=>{
                                    setToasts({
                                        "Toaster.Toaster.useEffect": (toasts)=>{
                                            const indexOfExistingToast = toasts.findIndex({
                                                "Toaster.Toaster.useEffect.indexOfExistingToast": (t)=>t.id === toast.id
                                            }["Toaster.Toaster.useEffect.indexOfExistingToast"]);
                                            // Update the toast if it already exists
                                            if (indexOfExistingToast !== -1) {
                                                return [
                                                    ...toasts.slice(0, indexOfExistingToast),
                                                    {
                                                        ...toasts[indexOfExistingToast],
                                                        ...toast
                                                    },
                                                    ...toasts.slice(indexOfExistingToast + 1)
                                                ];
                                            }
                                            return [
                                                toast,
                                                ...toasts
                                            ];
                                        }
                                    }["Toaster.Toaster.useEffect"]);
                                }
                            }["Toaster.Toaster.useEffect"]);
                        }
                    }["Toaster.Toaster.useEffect"]);
                }
            }["Toaster.Toaster.useEffect"]);
        }
    }["Toaster.Toaster.useEffect"], [
        toasts
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toaster.Toaster.useEffect": ()=>{
            if (theme !== 'system') {
                setActualTheme(theme);
                return;
            }
            if (theme === 'system') {
                // check if current preference is dark
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    // it's currently dark
                    setActualTheme('dark');
                } else {
                    // it's not dark
                    setActualTheme('light');
                }
            }
            if (typeof window === 'undefined') return;
            const darkMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
            try {
                // Chrome & Firefox
                darkMediaQuery.addEventListener('change', {
                    "Toaster.Toaster.useEffect": (param)=>{
                        let { matches } = param;
                        if (matches) {
                            setActualTheme('dark');
                        } else {
                            setActualTheme('light');
                        }
                    }
                }["Toaster.Toaster.useEffect"]);
            } catch (error) {
                // Safari < 14
                darkMediaQuery.addListener({
                    "Toaster.Toaster.useEffect": (param)=>{
                        let { matches } = param;
                        try {
                            if (matches) {
                                setActualTheme('dark');
                            } else {
                                setActualTheme('light');
                            }
                        } catch (e) {
                            console.error(e);
                        }
                    }
                }["Toaster.Toaster.useEffect"]);
            }
        }
    }["Toaster.Toaster.useEffect"], [
        theme
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toaster.Toaster.useEffect": ()=>{
            // Ensure expanded is always false when no toasts are present / only one left
            if (toasts.length <= 1) {
                setExpanded(false);
            }
        }
    }["Toaster.Toaster.useEffect"], [
        toasts
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toaster.Toaster.useEffect": ()=>{
            const handleKeyDown = {
                "Toaster.Toaster.useEffect.handleKeyDown": (event)=>{
                    var _listRef_current;
                    const isHotkeyPressed = hotkey.every({
                        "Toaster.Toaster.useEffect.handleKeyDown.isHotkeyPressed": (key)=>event[key] || event.code === key
                    }["Toaster.Toaster.useEffect.handleKeyDown.isHotkeyPressed"]);
                    if (isHotkeyPressed) {
                        var _listRef_current1;
                        setExpanded(true);
                        (_listRef_current1 = listRef.current) == null ? void 0 : _listRef_current1.focus();
                    }
                    if (event.code === 'Escape' && (document.activeElement === listRef.current || ((_listRef_current = listRef.current) == null ? void 0 : _listRef_current.contains(document.activeElement)))) {
                        setExpanded(false);
                    }
                }
            }["Toaster.Toaster.useEffect.handleKeyDown"];
            document.addEventListener('keydown', handleKeyDown);
            return ({
                "Toaster.Toaster.useEffect": ()=>document.removeEventListener('keydown', handleKeyDown)
            })["Toaster.Toaster.useEffect"];
        }
    }["Toaster.Toaster.useEffect"], [
        hotkey
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "Toaster.Toaster.useEffect": ()=>{
            if (listRef.current) {
                return ({
                    "Toaster.Toaster.useEffect": ()=>{
                        if (lastFocusedElementRef.current) {
                            lastFocusedElementRef.current.focus({
                                preventScroll: true
                            });
                            lastFocusedElementRef.current = null;
                            isFocusWithinRef.current = false;
                        }
                    }
                })["Toaster.Toaster.useEffect"];
            }
        }
    }["Toaster.Toaster.useEffect"], [
        listRef.current
    ]);
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("section", {
        ref: ref,
        "aria-label": "".concat(containerAriaLabel, " ").concat(hotkeyLabel),
        tabIndex: -1,
        "aria-live": "polite",
        "aria-relevant": "additions text",
        "aria-atomic": "false",
        suppressHydrationWarning: true
    }, possiblePositions.map((position, index)=>{
        var _heights_;
        const [y, x] = position.split('-');
        if (!toasts.length) return null;
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("ol", {
            key: position,
            dir: dir === 'auto' ? getDocumentDirection() : dir,
            tabIndex: -1,
            ref: listRef,
            className: className,
            "data-sonner-toaster": true,
            "data-sonner-theme": actualTheme,
            "data-y-position": y,
            "data-x-position": x,
            style: {
                '--front-toast-height': "".concat(((_heights_ = heights[0]) == null ? void 0 : _heights_.height) || 0, "px"),
                '--width': "".concat(TOAST_WIDTH, "px"),
                '--gap': "".concat(gap, "px"),
                ...style,
                ...assignOffset(offset, mobileOffset)
            },
            onBlur: (event)=>{
                if (isFocusWithinRef.current && !event.currentTarget.contains(event.relatedTarget)) {
                    isFocusWithinRef.current = false;
                    if (lastFocusedElementRef.current) {
                        lastFocusedElementRef.current.focus({
                            preventScroll: true
                        });
                        lastFocusedElementRef.current = null;
                    }
                }
            },
            onFocus: (event)=>{
                const isNotDismissible = event.target instanceof HTMLElement && event.target.dataset.dismissible === 'false';
                if (isNotDismissible) return;
                if (!isFocusWithinRef.current) {
                    isFocusWithinRef.current = true;
                    lastFocusedElementRef.current = event.relatedTarget;
                }
            },
            onMouseEnter: ()=>setExpanded(true),
            onMouseMove: ()=>setExpanded(true),
            onMouseLeave: ()=>{
                // Avoid setting expanded to false when interacting with a toast, e.g. swiping
                if (!interacting) {
                    setExpanded(false);
                }
            },
            onDragEnd: ()=>setExpanded(false),
            onPointerDown: (event)=>{
                const isNotDismissible = event.target instanceof HTMLElement && event.target.dataset.dismissible === 'false';
                if (isNotDismissible) return;
                setInteracting(true);
            },
            onPointerUp: ()=>setInteracting(false)
        }, toasts.filter((toast)=>!toast.position && index === 0 || toast.position === position).map((toast, index)=>{
            var _toastOptions_duration, _toastOptions_closeButton;
            return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Toast, {
                key: toast.id,
                icons: icons,
                index: index,
                toast: toast,
                defaultRichColors: richColors,
                duration: (_toastOptions_duration = toastOptions == null ? void 0 : toastOptions.duration) != null ? _toastOptions_duration : duration,
                className: toastOptions == null ? void 0 : toastOptions.className,
                descriptionClassName: toastOptions == null ? void 0 : toastOptions.descriptionClassName,
                invert: invert,
                visibleToasts: visibleToasts,
                closeButton: (_toastOptions_closeButton = toastOptions == null ? void 0 : toastOptions.closeButton) != null ? _toastOptions_closeButton : closeButton,
                interacting: interacting,
                position: position,
                style: toastOptions == null ? void 0 : toastOptions.style,
                unstyled: toastOptions == null ? void 0 : toastOptions.unstyled,
                classNames: toastOptions == null ? void 0 : toastOptions.classNames,
                cancelButtonStyle: toastOptions == null ? void 0 : toastOptions.cancelButtonStyle,
                actionButtonStyle: toastOptions == null ? void 0 : toastOptions.actionButtonStyle,
                closeButtonAriaLabel: toastOptions == null ? void 0 : toastOptions.closeButtonAriaLabel,
                removeToast: removeToast,
                toasts: toasts.filter((t)=>t.position == toast.position),
                heights: heights.filter((h)=>h.position == toast.position),
                setHeights: setHeights,
                expandByDefault: expand,
                gap: gap,
                expanded: expanded,
                swipeDirections: props.swipeDirections
            });
        }));
    }));
});
;
}),
"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);
    }
    function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    React = {
        react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
}();
}}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * use-sync-external-store-with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = React.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
    exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef(null);
        if (null === instRef.current) {
            var inst = {
                hasValue: !1,
                value: null
            };
            instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo(function() {
            function memoizedSelector(nextSnapshot) {
                if (!hasMemo) {
                    hasMemo = !0;
                    memoizedSnapshot = nextSnapshot;
                    nextSnapshot = selector(nextSnapshot);
                    if (void 0 !== isEqual && inst.hasValue) {
                        var currentSelection = inst.value;
                        if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
                    }
                    return memoizedSelection = nextSnapshot;
                }
                currentSelection = memoizedSelection;
                if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
                var nextSelection = selector(nextSnapshot);
                if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
                memoizedSnapshot = nextSnapshot;
                return memoizedSelection = nextSelection;
            }
            var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
                function() {
                    return memoizedSelector(getSnapshot());
                },
                null === maybeGetServerSnapshot ? void 0 : function() {
                    return memoizedSelector(maybeGetServerSnapshot());
                }
            ];
        }, [
            getSnapshot,
            getServerSnapshot,
            selector,
            isEqual
        ]);
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect(function() {
            inst.hasValue = !0;
            inst.value = value;
        }, [
            value
        ]);
        useDebugValue(value);
        return value;
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}}),
"[project]/node_modules/use-sync-external-store/with-selector.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/react-redux/dist/react-redux.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/utils/react.ts
__turbopack_context__.s({
    "Provider": ()=>Provider_default,
    "ReactReduxContext": ()=>ReactReduxContext,
    "batch": ()=>batch,
    "connect": ()=>connect_default,
    "createDispatchHook": ()=>createDispatchHook,
    "createSelectorHook": ()=>createSelectorHook,
    "createStoreHook": ()=>createStoreHook,
    "shallowEqual": ()=>shallowEqual,
    "useDispatch": ()=>useDispatch,
    "useSelector": ()=>useSelector,
    "useStore": ()=>useStore
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
// src/hooks/useSelector.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$with$2d$selector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/use-sync-external-store/with-selector.js [app-client] (ecmascript)");
;
// src/utils/react-is.ts
var IS_REACT_19 = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"].startsWith("19");
var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for(IS_REACT_19 ? "react.transitional.element" : "react.element");
var REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal");
var REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment");
var REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode");
var REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler");
var REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer");
var REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context");
var REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref");
var REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense");
var REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for("react.suspense_list");
var REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo");
var REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy");
var REACT_OFFSCREEN_TYPE = /* @__PURE__ */ Symbol.for("react.offscreen");
var REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for("react.client.reference");
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Memo = REACT_MEMO_TYPE;
function isValidElementType(type) {
    return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) ? true : false;
}
function typeOf(object) {
    if (typeof object === "object" && object !== null) {
        const { $$typeof } = object;
        switch($$typeof){
            case REACT_ELEMENT_TYPE:
                switch(object = object.type, object){
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                    case REACT_SUSPENSE_LIST_TYPE:
                        return object;
                    default:
                        switch(object = object && object.$$typeof, object){
                            case REACT_CONTEXT_TYPE:
                            case REACT_FORWARD_REF_TYPE:
                            case REACT_LAZY_TYPE:
                            case REACT_MEMO_TYPE:
                                return object;
                            case REACT_CONSUMER_TYPE:
                                return object;
                            default:
                                return $$typeof;
                        }
                }
            case REACT_PORTAL_TYPE:
                return $$typeof;
        }
    }
}
function isContextConsumer(object) {
    return IS_REACT_19 ? typeOf(object) === REACT_CONSUMER_TYPE : typeOf(object) === REACT_CONTEXT_TYPE;
}
function isMemo(object) {
    return typeOf(object) === REACT_MEMO_TYPE;
}
// src/utils/warning.ts
function warning(message) {
    if (typeof console !== "undefined" && typeof console.error === "function") {
        console.error(message);
    }
    try {
        throw new Error(message);
    } catch (e) {}
}
// src/connect/verifySubselectors.ts
function verify(selector, methodName) {
    if (!selector) {
        throw new Error("Unexpected value for ".concat(methodName, " in connect."));
    } else if (methodName === "mapStateToProps" || methodName === "mapDispatchToProps") {
        if (!Object.prototype.hasOwnProperty.call(selector, "dependsOnOwnProps")) {
            warning("The selector for ".concat(methodName, " of connect did not specify a value for dependsOnOwnProps."));
        }
    }
}
function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {
    verify(mapStateToProps, "mapStateToProps");
    verify(mapDispatchToProps, "mapDispatchToProps");
    verify(mergeProps, "mergeProps");
}
// src/connect/selectorFactory.ts
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, param) {
    let { areStatesEqual, areOwnPropsEqual, areStatePropsEqual } = param;
    let hasRunAtLeastOnce = false;
    let state;
    let ownProps;
    let stateProps;
    let dispatchProps;
    let mergedProps;
    function handleFirstCall(firstState, firstOwnProps) {
        state = firstState;
        ownProps = firstOwnProps;
        stateProps = mapStateToProps(state, ownProps);
        dispatchProps = mapDispatchToProps(dispatch, ownProps);
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        hasRunAtLeastOnce = true;
        return mergedProps;
    }
    function handleNewPropsAndNewState() {
        stateProps = mapStateToProps(state, ownProps);
        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        return mergedProps;
    }
    function handleNewProps() {
        if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);
        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        return mergedProps;
    }
    function handleNewState() {
        const nextStateProps = mapStateToProps(state, ownProps);
        const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
        stateProps = nextStateProps;
        if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        return mergedProps;
    }
    function handleSubsequentCalls(nextState, nextOwnProps) {
        const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
        const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);
        state = nextState;
        ownProps = nextOwnProps;
        if (propsChanged && stateChanged) return handleNewPropsAndNewState();
        if (propsChanged) return handleNewProps();
        if (stateChanged) return handleNewState();
        return mergedProps;
    }
    return function pureFinalPropsSelector(nextState, nextOwnProps) {
        return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
    };
}
function finalPropsSelectorFactory(dispatch, param) {
    let { initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options } = param;
    const mapStateToProps = initMapStateToProps(dispatch, options);
    const mapDispatchToProps = initMapDispatchToProps(dispatch, options);
    const mergeProps = initMergeProps(dispatch, options);
    if ("TURBOPACK compile-time truthy", 1) {
        verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);
    }
    return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}
// src/utils/bindActionCreators.ts
function bindActionCreators(actionCreators, dispatch) {
    const boundActionCreators = {};
    for(const key in actionCreators){
        const actionCreator = actionCreators[key];
        if (typeof actionCreator === "function") {
            boundActionCreators[key] = function() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                return dispatch(actionCreator(...args));
            };
        }
    }
    return boundActionCreators;
}
// src/utils/isPlainObject.ts
function isPlainObject(obj) {
    if (typeof obj !== "object" || obj === null) return false;
    const proto = Object.getPrototypeOf(obj);
    if (proto === null) return true;
    let baseProto = proto;
    while(Object.getPrototypeOf(baseProto) !== null){
        baseProto = Object.getPrototypeOf(baseProto);
    }
    return proto === baseProto;
}
// src/utils/verifyPlainObject.ts
function verifyPlainObject(value, displayName, methodName) {
    if (!isPlainObject(value)) {
        warning("".concat(methodName, "() in ").concat(displayName, " must return a plain object. Instead received ").concat(value, "."));
    }
}
// src/connect/wrapMapToProps.ts
function wrapMapToPropsConstant(getConstant) {
    return function initConstantSelector(dispatch) {
        const constant = getConstant(dispatch);
        function constantSelector() {
            return constant;
        }
        constantSelector.dependsOnOwnProps = false;
        return constantSelector;
    };
}
function getDependsOnOwnProps(mapToProps) {
    return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}
function wrapMapToPropsFunc(mapToProps, methodName) {
    return function initProxySelector(dispatch, param) {
        let { displayName } = param;
        const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
            return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);
        };
        proxy.dependsOnOwnProps = true;
        proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
            proxy.mapToProps = mapToProps;
            proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
            let props = proxy(stateOrDispatch, ownProps);
            if (typeof props === "function") {
                proxy.mapToProps = props;
                proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
                props = proxy(stateOrDispatch, ownProps);
            }
            if ("TURBOPACK compile-time truthy", 1) verifyPlainObject(props, displayName, methodName);
            return props;
        };
        return proxy;
    };
}
// src/connect/invalidArgFactory.ts
function createInvalidArgFactory(arg, name) {
    return (dispatch, options)=>{
        throw new Error("Invalid value of type ".concat(typeof arg, " for ").concat(name, " argument when connecting component ").concat(options.wrappedComponentName, "."));
    };
}
// src/connect/mapDispatchToProps.ts
function mapDispatchToPropsFactory(mapDispatchToProps) {
    return mapDispatchToProps && typeof mapDispatchToProps === "object" ? wrapMapToPropsConstant((dispatch)=>// @ts-ignore
        bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch)=>({
            dispatch
        })) : typeof mapDispatchToProps === "function" ? // @ts-ignore
    wrapMapToPropsFunc(mapDispatchToProps, "mapDispatchToProps") : createInvalidArgFactory(mapDispatchToProps, "mapDispatchToProps");
}
// src/connect/mapStateToProps.ts
function mapStateToPropsFactory(mapStateToProps) {
    return !mapStateToProps ? wrapMapToPropsConstant(()=>({})) : typeof mapStateToProps === "function" ? // @ts-ignore
    wrapMapToPropsFunc(mapStateToProps, "mapStateToProps") : createInvalidArgFactory(mapStateToProps, "mapStateToProps");
}
// src/connect/mergeProps.ts
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
    return {
        ...ownProps,
        ...stateProps,
        ...dispatchProps
    };
}
function wrapMergePropsFunc(mergeProps) {
    return function initMergePropsProxy(dispatch, param) {
        let { displayName, areMergedPropsEqual } = param;
        let hasRunOnce = false;
        let mergedProps;
        return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
            const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
            if (hasRunOnce) {
                if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
            } else {
                hasRunOnce = true;
                mergedProps = nextMergedProps;
                if ("TURBOPACK compile-time truthy", 1) verifyPlainObject(mergedProps, displayName, "mergeProps");
            }
            return mergedProps;
        };
    };
}
function mergePropsFactory(mergeProps) {
    return !mergeProps ? ()=>defaultMergeProps : typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, "mergeProps");
}
// src/utils/batch.ts
function defaultNoopBatch(callback) {
    callback();
}
// src/utils/Subscription.ts
function createListenerCollection() {
    let first = null;
    let last = null;
    return {
        clear () {
            first = null;
            last = null;
        },
        notify () {
            defaultNoopBatch(()=>{
                let listener = first;
                while(listener){
                    listener.callback();
                    listener = listener.next;
                }
            });
        },
        get () {
            const listeners = [];
            let listener = first;
            while(listener){
                listeners.push(listener);
                listener = listener.next;
            }
            return listeners;
        },
        subscribe (callback) {
            let isSubscribed = true;
            const listener = last = {
                callback,
                next: null,
                prev: last
            };
            if (listener.prev) {
                listener.prev.next = listener;
            } else {
                first = listener;
            }
            return function unsubscribe() {
                if (!isSubscribed || first === null) return;
                isSubscribed = false;
                if (listener.next) {
                    listener.next.prev = listener.prev;
                } else {
                    last = listener.prev;
                }
                if (listener.prev) {
                    listener.prev.next = listener.next;
                } else {
                    first = listener.next;
                }
            };
        }
    };
}
var nullListeners = {
    notify () {},
    get: ()=>[]
};
function createSubscription(store, parentSub) {
    let unsubscribe;
    let listeners = nullListeners;
    let subscriptionsAmount = 0;
    let selfSubscribed = false;
    function addNestedSub(listener) {
        trySubscribe();
        const cleanupListener = listeners.subscribe(listener);
        let removed = false;
        return ()=>{
            if (!removed) {
                removed = true;
                cleanupListener();
                tryUnsubscribe();
            }
        };
    }
    function notifyNestedSubs() {
        listeners.notify();
    }
    function handleChangeWrapper() {
        if (subscription.onStateChange) {
            subscription.onStateChange();
        }
    }
    function isSubscribed() {
        return selfSubscribed;
    }
    function trySubscribe() {
        subscriptionsAmount++;
        if (!unsubscribe) {
            unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
            listeners = createListenerCollection();
        }
    }
    function tryUnsubscribe() {
        subscriptionsAmount--;
        if (unsubscribe && subscriptionsAmount === 0) {
            unsubscribe();
            unsubscribe = void 0;
            listeners.clear();
            listeners = nullListeners;
        }
    }
    function trySubscribeSelf() {
        if (!selfSubscribed) {
            selfSubscribed = true;
            trySubscribe();
        }
    }
    function tryUnsubscribeSelf() {
        if (selfSubscribed) {
            selfSubscribed = false;
            tryUnsubscribe();
        }
    }
    const subscription = {
        addNestedSub,
        notifyNestedSubs,
        handleChangeWrapper,
        isSubscribed,
        trySubscribe: trySubscribeSelf,
        tryUnsubscribe: tryUnsubscribeSelf,
        getListeners: ()=>listeners
    };
    return subscription;
}
// src/utils/useIsomorphicLayoutEffect.ts
var canUseDOM = ()=>!!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isDOM = /* @__PURE__ */ canUseDOM();
var isRunningInReactNative = ()=>typeof navigator !== "undefined" && navigator.product === "ReactNative";
var isReactNative = /* @__PURE__ */ isRunningInReactNative();
var getUseIsomorphicLayoutEffect = ()=>isDOM || isReactNative ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"];
var useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
// src/utils/shallowEqual.ts
function is(x, y) {
    if (x === y) {
        return x !== 0 || y !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}
function shallowEqual(objA, objB) {
    if (is(objA, objB)) return true;
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
        return false;
    }
    const keysA = Object.keys(objA);
    const keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;
    for(let i = 0; i < keysA.length; i++){
        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
            return false;
        }
    }
    return true;
}
// src/utils/hoistStatics.ts
var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};
var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};
var FORWARD_REF_STATICS = {
    $$typeof: true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
};
var MEMO_STATICS = {
    $$typeof: true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
};
var TYPE_STATICS = {
    [ForwardRef]: FORWARD_REF_STATICS,
    [Memo]: MEMO_STATICS
};
function getStatics(component) {
    if (isMemo(component)) {
        return MEMO_STATICS;
    }
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent) {
    if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
            const inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent);
            }
        }
        let keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        const targetStatics = getStatics(targetComponent);
        const sourceStatics = getStatics(sourceComponent);
        for(let i = 0; i < keys.length; ++i){
            const key = keys[i];
            if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                const descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }
    }
    return targetComponent;
}
// src/components/Context.ts
var ContextKey = /* @__PURE__ */ Symbol.for("react-redux-context");
var gT = typeof globalThis !== "undefined" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */ {};
function getContext() {
    var _gT, _ContextKey;
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"]) return {};
    var _;
    const contextMap = (_ = (_gT = gT)[_ContextKey = ContextKey]) !== null && _ !== void 0 ? _ : _gT[_ContextKey] = /* @__PURE__ */ new Map();
    let realContext = contextMap.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"]);
    if (!realContext) {
        realContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"](null);
        if ("TURBOPACK compile-time truthy", 1) {
            realContext.displayName = "ReactRedux";
        }
        contextMap.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"], realContext);
    }
    return realContext;
}
var ReactReduxContext = /* @__PURE__ */ getContext();
// src/components/connect.tsx
var NO_SUBSCRIPTION_ARRAY = [
    null,
    null
];
var stringifyComponent = (Comp)=>{
    try {
        return JSON.stringify(Comp);
    } catch (err) {
        return String(Comp);
    }
};
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
    useIsomorphicLayoutEffect({
        "useIsomorphicLayoutEffectWithArgs.useIsomorphicLayoutEffect": ()=>effectFunc(...effectArgs)
    }["useIsomorphicLayoutEffectWithArgs.useIsomorphicLayoutEffect"], dependencies);
}
function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {
    lastWrapperProps.current = wrapperProps;
    renderIsScheduled.current = false;
    if (childPropsFromStoreUpdate.current) {
        childPropsFromStoreUpdate.current = null;
        notifyNestedSubs();
    }
}
function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {
    if (!shouldHandleStateChanges) return ()=>{};
    let didUnsubscribe = false;
    let lastThrownError = null;
    const checkForUpdates = ()=>{
        if (didUnsubscribe || !isMounted.current) {
            return;
        }
        const latestStoreState = store.getState();
        let newChildProps, error;
        try {
            newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
        } catch (e) {
            error = e;
            lastThrownError = e;
        }
        if (!error) {
            lastThrownError = null;
        }
        if (newChildProps === lastChildProps.current) {
            if (!renderIsScheduled.current) {
                notifyNestedSubs();
            }
        } else {
            lastChildProps.current = newChildProps;
            childPropsFromStoreUpdate.current = newChildProps;
            renderIsScheduled.current = true;
            additionalSubscribeListener();
        }
    };
    subscription.onStateChange = checkForUpdates;
    subscription.trySubscribe();
    checkForUpdates();
    const unsubscribeWrapper = ()=>{
        didUnsubscribe = true;
        subscription.tryUnsubscribe();
        subscription.onStateChange = null;
        if (lastThrownError) {
            throw lastThrownError;
        }
    };
    return unsubscribeWrapper;
}
function strictEqual(a, b) {
    return a === b;
}
var hasWarnedAboutDeprecatedPureOption = false;
function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
    let { // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.
    // @ts-ignore
    pure, areStatesEqual = strictEqual, areOwnPropsEqual = shallowEqual, areStatePropsEqual = shallowEqual, areMergedPropsEqual = shallowEqual, // use React's forwardRef to expose a ref of the wrapped component
    forwardRef = false, // the context consumer to use
    context = ReactReduxContext } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if ("TURBOPACK compile-time truthy", 1) {
        if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {
            hasWarnedAboutDeprecatedPureOption = true;
            warning('The `pure` option has been removed. `connect` is now always a "pure/memoized" component');
        }
    }
    const Context = context;
    const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);
    const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);
    const initMergeProps = mergePropsFactory(mergeProps);
    const shouldHandleStateChanges = Boolean(mapStateToProps);
    const wrapWithConnect = (WrappedComponent)=>{
        if ("TURBOPACK compile-time truthy", 1) {
            const isValid = /* @__PURE__ */ isValidElementType(WrappedComponent);
            if (!isValid) throw new Error("You must pass a component to the function returned by connect. Instead received ".concat(stringifyComponent(WrappedComponent)));
        }
        const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
        const displayName = "Connect(".concat(wrappedComponentName, ")");
        const selectorFactoryOptions = {
            shouldHandleStateChanges,
            displayName,
            wrappedComponentName,
            WrappedComponent,
            // @ts-ignore
            initMapStateToProps,
            initMapDispatchToProps,
            initMergeProps,
            areStatesEqual,
            areStatePropsEqual,
            areOwnPropsEqual,
            areMergedPropsEqual
        };
        function ConnectFunction(props) {
            const [propsContext, reactReduxForwardedRef, wrapperProps] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo": ()=>{
                    const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;
                    return [
                        props.context,
                        reactReduxForwardedRef2,
                        wrapperProps2
                    ];
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo"], [
                props
            ]);
            const ContextToUse = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo[ContextToUse]": ()=>{
                    let ResultContext = Context;
                    if (propsContext === null || propsContext === void 0 ? void 0 : propsContext.Consumer) {
                        if ("TURBOPACK compile-time truthy", 1) {
                            const isValid = /* @__PURE__ */ isContextConsumer(// @ts-ignore
                            /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](propsContext.Consumer, null));
                            if (!isValid) {
                                throw new Error("You must pass a valid React context consumer as `props.context`");
                            }
                            ResultContext = propsContext;
                        }
                    }
                    return ResultContext;
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo[ContextToUse]"], [
                propsContext,
                Context
            ]);
            const contextValue = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](ContextToUse);
            const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
            const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
            if (("TURBOPACK compile-time value", "development") !== "production" && !didStoreComeFromProps && !didStoreComeFromContext) {
                throw new Error('Could not find "store" in the context of "'.concat(displayName, '". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ').concat(displayName, " in connect options."));
            }
            const store = didStoreComeFromProps ? props.store : contextValue.store;
            const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;
            const childPropsSelector = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo[childPropsSelector]": ()=>{
                    return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo[childPropsSelector]"], [
                store
            ]);
            const [subscription, notifyNestedSubs] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo": ()=>{
                    if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;
                    const subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);
                    const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
                    return [
                        subscription2,
                        notifyNestedSubs2
                    ];
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo"], [
                store,
                didStoreComeFromProps,
                contextValue
            ]);
            const overriddenContextValue = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo[overriddenContextValue]": ()=>{
                    if (didStoreComeFromProps) {
                        return contextValue;
                    }
                    return {
                        ...contextValue,
                        subscription
                    };
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo[overriddenContextValue]"], [
                didStoreComeFromProps,
                contextValue,
                subscription
            ]);
            const lastChildProps = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](void 0);
            const lastWrapperProps = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](wrapperProps);
            const childPropsFromStoreUpdate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](void 0);
            const renderIsScheduled = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](false);
            const isMounted = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](false);
            const latestSubscriptionCallbackError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](void 0);
            useIsomorphicLayoutEffect({
                "connect.wrapWithConnect.ConnectFunction.useIsomorphicLayoutEffect": ()=>{
                    isMounted.current = true;
                    return ({
                        "connect.wrapWithConnect.ConnectFunction.useIsomorphicLayoutEffect": ()=>{
                            isMounted.current = false;
                        }
                    })["connect.wrapWithConnect.ConnectFunction.useIsomorphicLayoutEffect"];
                }
            }["connect.wrapWithConnect.ConnectFunction.useIsomorphicLayoutEffect"], []);
            const actualChildPropsSelector = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo[actualChildPropsSelector]": ()=>{
                    const selector = {
                        "connect.wrapWithConnect.ConnectFunction.useMemo[actualChildPropsSelector].selector": ()=>{
                            if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
                                return childPropsFromStoreUpdate.current;
                            }
                            return childPropsSelector(store.getState(), wrapperProps);
                        }
                    }["connect.wrapWithConnect.ConnectFunction.useMemo[actualChildPropsSelector].selector"];
                    return selector;
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo[actualChildPropsSelector]"], [
                store,
                wrapperProps
            ]);
            const subscribeForReact = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo[subscribeForReact]": ()=>{
                    const subscribe = {
                        "connect.wrapWithConnect.ConnectFunction.useMemo[subscribeForReact].subscribe": (reactListener)=>{
                            if (!subscription) {
                                return ({
                                    "connect.wrapWithConnect.ConnectFunction.useMemo[subscribeForReact].subscribe": ()=>{}
                                })["connect.wrapWithConnect.ConnectFunction.useMemo[subscribeForReact].subscribe"];
                            }
                            return subscribeUpdates(shouldHandleStateChanges, store, subscription, // @ts-ignore
                            childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);
                        }
                    }["connect.wrapWithConnect.ConnectFunction.useMemo[subscribeForReact].subscribe"];
                    return subscribe;
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo[subscribeForReact]"], [
                subscription
            ]);
            useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [
                lastWrapperProps,
                lastChildProps,
                renderIsScheduled,
                wrapperProps,
                childPropsFromStoreUpdate,
                notifyNestedSubs
            ]);
            let actualChildProps;
            try {
                actualChildProps = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"](// TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing
                subscribeForReact, // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,
                // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.
                actualChildPropsSelector, getServerState ? ({
                    "connect.wrapWithConnect.ConnectFunction.useSyncExternalStore": ()=>childPropsSelector(getServerState(), wrapperProps)
                })["connect.wrapWithConnect.ConnectFunction.useSyncExternalStore"] : actualChildPropsSelector);
            } catch (err) {
                if (latestSubscriptionCallbackError.current) {
                    ;
                    err.message += "\nThe error may be correlated with this previous error:\n".concat(latestSubscriptionCallbackError.current.stack, "\n\n");
                }
                throw err;
            }
            useIsomorphicLayoutEffect({
                "connect.wrapWithConnect.ConnectFunction.useIsomorphicLayoutEffect": ()=>{
                    latestSubscriptionCallbackError.current = void 0;
                    childPropsFromStoreUpdate.current = void 0;
                    lastChildProps.current = actualChildProps;
                }
            }["connect.wrapWithConnect.ConnectFunction.useIsomorphicLayoutEffect"]);
            const renderedWrappedComponent = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo[renderedWrappedComponent]": ()=>{
                    return(// @ts-ignore
                    /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](WrappedComponent, {
                        ...actualChildProps,
                        ref: reactReduxForwardedRef
                    }));
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo[renderedWrappedComponent]"], [
                reactReduxForwardedRef,
                WrappedComponent,
                actualChildProps
            ]);
            const renderedChild = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
                "connect.wrapWithConnect.ConnectFunction.useMemo[renderedChild]": ()=>{
                    if (shouldHandleStateChanges) {
                        return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](ContextToUse.Provider, {
                            value: overriddenContextValue
                        }, renderedWrappedComponent);
                    }
                    return renderedWrappedComponent;
                }
            }["connect.wrapWithConnect.ConnectFunction.useMemo[renderedChild]"], [
                ContextToUse,
                renderedWrappedComponent,
                overriddenContextValue
            ]);
            return renderedChild;
        }
        const _Connect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"](ConnectFunction);
        const Connect = _Connect;
        Connect.WrappedComponent = WrappedComponent;
        Connect.displayName = ConnectFunction.displayName = displayName;
        if (forwardRef) {
            const _forwarded = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"](function forwardConnectRef(props, ref) {
                return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](Connect, {
                    ...props,
                    reactReduxForwardedRef: ref
                });
            });
            const forwarded = _forwarded;
            forwarded.displayName = displayName;
            forwarded.WrappedComponent = WrappedComponent;
            return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);
        }
        return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);
    };
    return wrapWithConnect;
}
var connect_default = connect;
// src/components/Provider.tsx
function Provider(providerProps) {
    const { children, context, serverState, store } = providerProps;
    const contextValue = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
        "Provider.useMemo[contextValue]": ()=>{
            const subscription = createSubscription(store);
            const baseContextValue = {
                store,
                subscription,
                getServerState: serverState ? ({
                    "Provider.useMemo[contextValue]": ()=>serverState
                })["Provider.useMemo[contextValue]"] : void 0
            };
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            else {
                const { identityFunctionCheck = "once", stabilityCheck = "once" } = providerProps;
                return /* @__PURE__ */ Object.assign(baseContextValue, {
                    stabilityCheck,
                    identityFunctionCheck
                });
            }
        }
    }["Provider.useMemo[contextValue]"], [
        store,
        serverState
    ]);
    const previousState = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
        "Provider.useMemo[previousState]": ()=>store.getState()
    }["Provider.useMemo[previousState]"], [
        store
    ]);
    useIsomorphicLayoutEffect({
        "Provider.useIsomorphicLayoutEffect": ()=>{
            const { subscription } = contextValue;
            subscription.onStateChange = subscription.notifyNestedSubs;
            subscription.trySubscribe();
            if (previousState !== store.getState()) {
                subscription.notifyNestedSubs();
            }
            return ({
                "Provider.useIsomorphicLayoutEffect": ()=>{
                    subscription.tryUnsubscribe();
                    subscription.onStateChange = void 0;
                }
            })["Provider.useIsomorphicLayoutEffect"];
        }
    }["Provider.useIsomorphicLayoutEffect"], [
        contextValue,
        previousState
    ]);
    const Context = context || ReactReduxContext;
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](Context.Provider, {
        value: contextValue
    }, children);
}
var Provider_default = Provider;
// src/hooks/useReduxContext.ts
function createReduxContextHook() {
    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ReactReduxContext;
    return function useReduxContext2() {
        const contextValue = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](context);
        if (("TURBOPACK compile-time value", "development") !== "production" && !contextValue) {
            throw new Error("could not find react-redux context value; please ensure the component is wrapped in a <Provider>");
        }
        return contextValue;
    };
}
var useReduxContext = /* @__PURE__ */ createReduxContextHook();
// src/hooks/useStore.ts
function createStoreHook() {
    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ReactReduxContext;
    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : // @ts-ignore
    createReduxContextHook(context);
    const useStore2 = ()=>{
        const { store } = useReduxContext2();
        return store;
    };
    Object.assign(useStore2, {
        withTypes: ()=>useStore2
    });
    return useStore2;
}
var useStore = /* @__PURE__ */ createStoreHook();
// src/hooks/useDispatch.ts
function createDispatchHook() {
    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ReactReduxContext;
    const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
    const useDispatch2 = ()=>{
        const store = useStore2();
        return store.dispatch;
    };
    Object.assign(useDispatch2, {
        withTypes: ()=>useDispatch2
    });
    return useDispatch2;
}
var useDispatch = /* @__PURE__ */ createDispatchHook();
;
var refEquality = (a, b)=>a === b;
function createSelectorHook() {
    let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ReactReduxContext;
    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
    const useSelector2 = function(selector) {
        let equalityFnOrOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const { equalityFn = refEquality } = typeof equalityFnOrOptions === "function" ? {
            equalityFn: equalityFnOrOptions
        } : equalityFnOrOptions;
        if ("TURBOPACK compile-time truthy", 1) {
            if (!selector) {
                throw new Error("You must pass a selector to useSelector");
            }
            if (typeof selector !== "function") {
                throw new Error("You must pass a function as a selector to useSelector");
            }
            if (typeof equalityFn !== "function") {
                throw new Error("You must pass a function as an equality function to useSelector");
            }
        }
        const reduxContext = useReduxContext2();
        const { store, subscription, getServerState } = reduxContext;
        const firstRun = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](true);
        const wrappedSelector = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
            [selector.name] (state) {
                const selected = selector(state);
                if ("TURBOPACK compile-time truthy", 1) {
                    const { devModeChecks = {} } = typeof equalityFnOrOptions === "function" ? {} : equalityFnOrOptions;
                    const { identityFunctionCheck, stabilityCheck } = reduxContext;
                    const { identityFunctionCheck: finalIdentityFunctionCheck, stabilityCheck: finalStabilityCheck } = {
                        stabilityCheck,
                        identityFunctionCheck,
                        ...devModeChecks
                    };
                    if (finalStabilityCheck === "always" || finalStabilityCheck === "once" && firstRun.current) {
                        const toCompare = selector(state);
                        if (!equalityFn(selected, toCompare)) {
                            let stack = void 0;
                            try {
                                throw new Error();
                            } catch (e) {
                                ;
                                ({ stack } = e);
                            }
                            console.warn("Selector " + (selector.name || "unknown") + " returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization", {
                                state,
                                selected,
                                selected2: toCompare,
                                stack
                            });
                        }
                    }
                    if (finalIdentityFunctionCheck === "always" || finalIdentityFunctionCheck === "once" && firstRun.current) {
                        if (selected === state) {
                            let stack = void 0;
                            try {
                                throw new Error();
                            } catch (e) {
                                ;
                                ({ stack } = e);
                            }
                            console.warn("Selector " + (selector.name || "unknown") + " returned the root state when called. This can lead to unnecessary rerenders.\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.", {
                                stack
                            });
                        }
                    }
                    if (firstRun.current) firstRun.current = false;
                }
                return selected;
            }
        }[selector.name], [
            selector
        ]);
        const selectedState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$with$2d$selector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStoreWithSelector"])(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useDebugValue"](selectedState);
        return selectedState;
    };
    Object.assign(useSelector2, {
        withTypes: ()=>useSelector2
    });
    return useSelector2;
}
var useSelector = /* @__PURE__ */ createSelectorHook();
// src/exports.ts
var batch = defaultNoopBatch;
;
 //# sourceMappingURL=react-redux.mjs.map
}),
"[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "_": ()=>_define_property
});
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else obj[key] = value;
    return obj;
}
;
}),
"[project]/node_modules/immer/dist/immer.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/utils/env.ts
__turbopack_context__.s({
    "Immer": ()=>Immer2,
    "applyPatches": ()=>applyPatches,
    "castDraft": ()=>castDraft,
    "castImmutable": ()=>castImmutable,
    "createDraft": ()=>createDraft,
    "current": ()=>current,
    "enableMapSet": ()=>enableMapSet,
    "enablePatches": ()=>enablePatches,
    "finishDraft": ()=>finishDraft,
    "freeze": ()=>freeze,
    "immerable": ()=>DRAFTABLE,
    "isDraft": ()=>isDraft,
    "isDraftable": ()=>isDraftable,
    "nothing": ()=>NOTHING,
    "original": ()=>original,
    "produce": ()=>produce,
    "produceWithPatches": ()=>produceWithPatches,
    "setAutoFreeze": ()=>setAutoFreeze,
    "setUseStrictShallowCopy": ()=>setUseStrictShallowCopy
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
// src/utils/errors.ts
var errors = ("TURBOPACK compile-time truthy", 1) ? [
    // All error codes, starting by 0:
    function(plugin) {
        return "The plugin for '".concat(plugin, "' has not been loaded into Immer. To enable the plugin, import and call `enable").concat(plugin, "()` when initializing your application.");
    },
    function(thing) {
        return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '".concat(thing, "'");
    },
    "This object has been frozen and should not be mutated",
    function(data) {
        return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
    },
    "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
    "Immer forbids circular references",
    "The first or second argument to `produce` must be a function",
    "The third argument to `produce` must be a function or undefined",
    "First argument to `createDraft` must be a plain object, an array, or an immerable object",
    "First argument to `finishDraft` must be a draft returned by `createDraft`",
    function(thing) {
        return "'current' expects a draft, got: ".concat(thing);
    },
    "Object.defineProperty() cannot be used on an Immer draft",
    "Object.setPrototypeOf() cannot be used on an Immer draft",
    "Immer only supports deleting array indices",
    "Immer only supports setting array indices and the 'length' property",
    function(thing) {
        return "'original' expects a draft, got: ".concat(thing);
    }
] : "TURBOPACK unreachable";
function die(error) {
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        args[_key - 1] = arguments[_key];
    }
    if ("TURBOPACK compile-time truthy", 1) {
        const e = errors[error];
        const msg = typeof e === "function" ? e.apply(null, args) : e;
        throw new Error("[Immer] ".concat(msg));
    }
    throw new Error("[Immer] minified error nr: ".concat(error, ". Full error at: https://bit.ly/3cXEKWf"));
}
// src/utils/common.ts
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
    return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
    var _value_constructor;
    if (!value) return false;
    return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value_constructor = value.constructor) === null || _value_constructor === void 0 ? void 0 : _value_constructor[DRAFTABLE]) || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject(value) {
    if (!value || typeof value !== "object") return false;
    const proto = getPrototypeOf(value);
    if (proto === null) {
        return true;
    }
    const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    if (Ctor === Object) return true;
    return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function original(value) {
    if (!isDraft(value)) die(15, value);
    return value[DRAFT_STATE].base_;
}
function each(obj, iter) {
    if (getArchtype(obj) === 0 /* Object */ ) {
        Reflect.ownKeys(obj).forEach((key)=>{
            iter(key, obj[key], obj);
        });
    } else {
        obj.forEach((entry, index)=>iter(index, entry, obj));
    }
}
function getArchtype(thing) {
    const state = thing[DRAFT_STATE];
    return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */  : isMap(thing) ? 2 /* Map */  : isSet(thing) ? 3 /* Set */  : 0 /* Object */ ;
}
function has(thing, prop) {
    return getArchtype(thing) === 2 /* Map */  ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function get(thing, prop) {
    return getArchtype(thing) === 2 /* Map */  ? thing.get(prop) : thing[prop];
}
function set(thing, propOrOldValue, value) {
    const t = getArchtype(thing);
    if (t === 2 /* Map */ ) thing.set(propOrOldValue, value);
    else if (t === 3 /* Set */ ) {
        thing.add(value);
    } else thing[propOrOldValue] = value;
}
function is(x, y) {
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}
function isMap(target) {
    return target instanceof Map;
}
function isSet(target) {
    return target instanceof Set;
}
function latest(state) {
    return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
    if (isMap(base)) {
        return new Map(base);
    }
    if (isSet(base)) {
        return new Set(base);
    }
    if (Array.isArray(base)) return Array.prototype.slice.call(base);
    const isPlain = isPlainObject(base);
    if (strict === true || strict === "class_only" && !isPlain) {
        const descriptors = Object.getOwnPropertyDescriptors(base);
        delete descriptors[DRAFT_STATE];
        let keys = Reflect.ownKeys(descriptors);
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            const desc = descriptors[key];
            if (desc.writable === false) {
                desc.writable = true;
                desc.configurable = true;
            }
            if (desc.get || desc.set) descriptors[key] = {
                configurable: true,
                writable: true,
                // could live with !!desc.set as well here...
                enumerable: desc.enumerable,
                value: base[key]
            };
        }
        return Object.create(getPrototypeOf(base), descriptors);
    } else {
        const proto = getPrototypeOf(base);
        if (proto !== null && isPlain) {
            return {
                ...base
            };
        }
        const obj = Object.create(proto);
        return Object.assign(obj, base);
    }
}
function freeze(obj) {
    let deep = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;
    if (getArchtype(obj) > 1) {
        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
    }
    Object.freeze(obj);
    if (deep) Object.entries(obj).forEach((param)=>{
        let [key, value] = param;
        return freeze(value, true);
    });
    return obj;
}
function dontMutateFrozenCollections() {
    die(2);
}
function isFrozen(obj) {
    return Object.isFrozen(obj);
}
// src/utils/plugins.ts
var plugins = {};
function getPlugin(pluginKey) {
    const plugin = plugins[pluginKey];
    if (!plugin) {
        die(0, pluginKey);
    }
    return plugin;
}
function loadPlugin(pluginKey, implementation) {
    if (!plugins[pluginKey]) plugins[pluginKey] = implementation;
}
// src/core/scope.ts
var currentScope;
function getCurrentScope() {
    return currentScope;
}
function createScope(parent_, immer_) {
    return {
        drafts_: [],
        parent_,
        immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
    };
}
function usePatchesInScope(scope, patchListener) {
    if (patchListener) {
        getPlugin("Patches");
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
    }
}
function revokeScope(scope) {
    leaveScope(scope);
    scope.drafts_.forEach(revokeDraft);
    scope.drafts_ = null;
}
function leaveScope(scope) {
    if (scope === currentScope) {
        currentScope = scope.parent_;
    }
}
function enterScope(immer2) {
    return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
    const state = draft[DRAFT_STATE];
    if (state.type_ === 0 /* Object */  || state.type_ === 1 /* Array */ ) state.revoke_();
    else state.revoked_ = true;
}
// src/core/finalize.ts
function processResult(result, scope) {
    scope.unfinalizedDrafts_ = scope.drafts_.length;
    const baseDraft = scope.drafts_[0];
    const isReplaced = result !== void 0 && result !== baseDraft;
    if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
            revokeScope(scope);
            die(4);
        }
        if (isDraftable(result)) {
            result = finalize(scope, result);
            if (!scope.parent_) maybeFreeze(scope, result);
        }
        if (scope.patches_) {
            getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
        }
    } else {
        result = finalize(scope, baseDraft, []);
    }
    revokeScope(scope);
    if (scope.patches_) {
        scope.patchListener_(scope.patches_, scope.inversePatches_);
    }
    return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
    if (isFrozen(value)) return value;
    const state = value[DRAFT_STATE];
    if (!state) {
        each(value, (key, childValue)=>finalizeProperty(rootScope, state, value, key, childValue, path));
        return value;
    }
    if (state.scope_ !== rootScope) return value;
    if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
    }
    if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        const result = state.copy_;
        let resultEach = result;
        let isSet2 = false;
        if (state.type_ === 3 /* Set */ ) {
            resultEach = new Set(result);
            result.clear();
            isSet2 = true;
        }
        each(resultEach, (key, childValue)=>finalizeProperty(rootScope, state, result, key, childValue, path, isSet2));
        maybeFreeze(rootScope, result, false);
        if (path && rootScope.patches_) {
            getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
        }
    }
    return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
    if (("TURBOPACK compile-time value", "development") !== "production" && childValue === targetObject) die(5);
    if (isDraft(childValue)) {
        const path = rootPath && parentState && parentState.type_ !== 3 /* Set */  && // Set objects are atomic since they have no keys.
        !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
        const res = finalize(rootScope, childValue, path);
        set(targetObject, prop, res);
        if (isDraft(res)) {
            rootScope.canAutoFreeze_ = false;
        } else return;
    } else if (targetIsSet) {
        targetObject.add(childValue);
    }
    if (isDraftable(childValue) && !isFrozen(childValue)) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
            return;
        }
        finalize(rootScope, childValue);
        if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop)) maybeFreeze(rootScope, childValue);
    }
}
function maybeFreeze(scope, value) {
    let deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
        freeze(value, deep);
    }
}
// src/core/proxy.ts
function createProxyProxy(base, parent) {
    const isArray = Array.isArray(base);
    const state = {
        type_: isArray ? 1 /* Array */  : 0 /* Object */ ,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned_: {},
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base,
        // The base proxy.
        draft_: null,
        // set below
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false
    };
    let target = state;
    let traps = objectTraps;
    if (isArray) {
        target = [
            state
        ];
        traps = arrayTraps;
    }
    const { revoke, proxy } = Proxy.revocable(target, traps);
    state.draft_ = proxy;
    state.revoke_ = revoke;
    return proxy;
}
var objectTraps = {
    get (state, prop) {
        if (prop === DRAFT_STATE) return state;
        const source = latest(state);
        if (!has(source, prop)) {
            return readPropFromProto(state, source, prop);
        }
        const value = source[prop];
        if (state.finalized_ || !isDraftable(value)) {
            return value;
        }
        if (value === peek(state.base_, prop)) {
            prepareCopy(state);
            return state.copy_[prop] = createProxy(value, state);
        }
        return value;
    },
    has (state, prop) {
        return prop in latest(state);
    },
    ownKeys (state) {
        return Reflect.ownKeys(latest(state));
    },
    set (state, prop, value) {
        const desc = getDescriptorFromProto(latest(state), prop);
        if (desc === null || desc === void 0 ? void 0 : desc.set) {
            desc.set.call(state.draft_, value);
            return true;
        }
        if (!state.modified_) {
            const current2 = peek(latest(state), prop);
            const currentState = current2 === null || current2 === void 0 ? void 0 : current2[DRAFT_STATE];
            if (currentState && currentState.base_ === value) {
                state.copy_[prop] = value;
                state.assigned_[prop] = false;
                return true;
            }
            if (is(value, current2) && (value !== void 0 || has(state.base_, prop))) return true;
            prepareCopy(state);
            markChanged(state);
        }
        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;
        state.copy_[prop] = value;
        state.assigned_[prop] = true;
        return true;
    },
    deleteProperty (state, prop) {
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
            state.assigned_[prop] = false;
            prepareCopy(state);
            markChanged(state);
        } else {
            delete state.assigned_[prop];
        }
        if (state.copy_) {
            delete state.copy_[prop];
        }
        return true;
    },
    // Note: We never coerce `desc.value` into an Immer draft, because we can't make
    // the same guarantee in ES5 mode.
    getOwnPropertyDescriptor (state, prop) {
        const owner = latest(state);
        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc) return desc;
        return {
            writable: true,
            configurable: state.type_ !== 1 /* Array */  || prop !== "length",
            enumerable: desc.enumerable,
            value: owner[prop]
        };
    },
    defineProperty () {
        die(11);
    },
    getPrototypeOf (state) {
        return getPrototypeOf(state.base_);
    },
    setPrototypeOf () {
        die(12);
    }
};
var arrayTraps = {};
each(objectTraps, (key, fn)=>{
    arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
    };
});
arrayTraps.deleteProperty = function(state, prop) {
    if (("TURBOPACK compile-time value", "development") !== "production" && isNaN(parseInt(prop))) die(13);
    return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
    if (("TURBOPACK compile-time value", "development") !== "production" && prop !== "length" && isNaN(parseInt(prop))) die(14);
    return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
    const state = draft[DRAFT_STATE];
    const source = state ? latest(state) : draft;
    return source[prop];
}
function readPropFromProto(state, source, prop) {
    var // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    _desc_get;
    const desc = getDescriptorFromProto(source, prop);
    return desc ? "value" in desc ? desc.value : (_desc_get = desc.get) === null || _desc_get === void 0 ? void 0 : _desc_get.call(state.draft_) : void 0;
}
function getDescriptorFromProto(source, prop) {
    if (!(prop in source)) return void 0;
    let proto = getPrototypeOf(source);
    while(proto){
        const desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc) return desc;
        proto = getPrototypeOf(proto);
    }
    return void 0;
}
function markChanged(state) {
    if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
            markChanged(state.parent_);
        }
    }
}
function prepareCopy(state) {
    if (!state.copy_) {
        state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);
    }
}
// src/core/immerClass.ts
var Immer2 = class {
    createDraft(base) {
        if (!isDraftable(base)) die(8);
        if (isDraft(base)) base = current(base);
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope);
        return proxy;
    }
    finishDraft(draft, patchListener) {
        const state = draft && draft[DRAFT_STATE];
        if (!state || !state.isManual_) die(9);
        const { scope_: scope } = state;
        usePatchesInScope(scope, patchListener);
        return processResult(void 0, scope);
    }
    /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */ setAutoFreeze(value) {
        this.autoFreeze_ = value;
    }
    /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */ setUseStrictShallowCopy(value) {
        this.useStrictShallowCopy_ = value;
    }
    applyPatches(base, patches) {
        let i;
        for(i = patches.length - 1; i >= 0; i--){
            const patch = patches[i];
            if (patch.path.length === 0 && patch.op === "replace") {
                base = patch.value;
                break;
            }
        }
        if (i > -1) {
            patches = patches.slice(i + 1);
        }
        const applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base)) {
            return applyPatchesImpl(base, patches);
        }
        return this.produce(base, (draft)=>applyPatchesImpl(draft, patches));
    }
    constructor(config){
        this.autoFreeze_ = true;
        this.useStrictShallowCopy_ = false;
        /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     *
     * @param {any} base - the initial state
     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */ this.produce = (base, recipe, patchListener)=>{
            if (typeof base === "function" && typeof recipe !== "function") {
                const defaultBase = recipe;
                recipe = base;
                const self = this;
                return function curriedProduce() {
                    let base2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultBase;
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    return self.produce(base2, (draft)=>recipe.call(this, draft, ...args));
                };
            }
            if (typeof recipe !== "function") die(6);
            if (patchListener !== void 0 && typeof patchListener !== "function") die(7);
            let result;
            if (isDraftable(base)) {
                const scope = enterScope(this);
                const proxy = createProxy(base, void 0);
                let hasError = true;
                try {
                    result = recipe(proxy);
                    hasError = false;
                } finally{
                    if (hasError) revokeScope(scope);
                    else leaveScope(scope);
                }
                usePatchesInScope(scope, patchListener);
                return processResult(result, scope);
            } else if (!base || typeof base !== "object") {
                result = recipe(base);
                if (result === void 0) result = base;
                if (result === NOTHING) result = void 0;
                if (this.autoFreeze_) freeze(result, true);
                if (patchListener) {
                    const p = [];
                    const ip = [];
                    getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
                    patchListener(p, ip);
                }
                return result;
            } else die(1, base);
        };
        this.produceWithPatches = (base, recipe)=>{
            if (typeof base === "function") {
                var _this = this;
                return function(state) {
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    return _this.produceWithPatches(state, (draft)=>base(draft, ...args));
                };
            }
            let patches, inversePatches;
            const result = this.produce(base, recipe, (p, ip)=>{
                patches = p;
                inversePatches = ip;
            });
            return [
                result,
                patches,
                inversePatches
            ];
        };
        if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === "boolean") this.setAutoFreeze(config.autoFreeze);
        if (typeof (config === null || config === void 0 ? void 0 : config.useStrictShallowCopy) === "boolean") this.setUseStrictShallowCopy(config.useStrictShallowCopy);
    }
};
function createProxy(value, parent) {
    const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
    const scope = parent ? parent.scope_ : getCurrentScope();
    scope.drafts_.push(draft);
    return draft;
}
// src/core/current.ts
function current(value) {
    if (!isDraft(value)) die(10, value);
    return currentImpl(value);
}
function currentImpl(value) {
    if (!isDraftable(value) || isFrozen(value)) return value;
    const state = value[DRAFT_STATE];
    let copy;
    if (state) {
        if (!state.modified_) return state.base_;
        state.finalized_ = true;
        copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
    } else {
        copy = shallowCopy(value, true);
    }
    each(copy, (key, childValue)=>{
        set(copy, key, currentImpl(childValue));
    });
    if (state) {
        state.finalized_ = false;
    }
    return copy;
}
// src/plugins/patches.ts
function enablePatches() {
    const errorOffset = 16;
    if ("TURBOPACK compile-time truthy", 1) {
        errors.push('Sets cannot have "replace" patches.', function(op) {
            return "Unsupported patch operation: " + op;
        }, function(path) {
            return "Cannot apply patch, path doesn't resolve: " + path;
        }, "Patching reserved attributes like __proto__, prototype and constructor is not allowed");
    }
    const REPLACE = "replace";
    const ADD = "add";
    const REMOVE = "remove";
    function generatePatches_(state, basePath, patches, inversePatches) {
        switch(state.type_){
            case 0 /* Object */ :
            case 2 /* Map */ :
                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
            case 1 /* Array */ :
                return generateArrayPatches(state, basePath, patches, inversePatches);
            case 3 /* Set */ :
                return generateSetPatches(state, basePath, patches, inversePatches);
        }
    }
    function generateArrayPatches(state, basePath, patches, inversePatches) {
        let { base_, assigned_ } = state;
        let copy_ = state.copy_;
        if (copy_.length < base_.length) {
            ;
            [base_, copy_] = [
                copy_,
                base_
            ];
            [patches, inversePatches] = [
                inversePatches,
                patches
            ];
        }
        for(let i = 0; i < base_.length; i++){
            if (assigned_[i] && copy_[i] !== base_[i]) {
                const path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: REPLACE,
                    path,
                    // Need to maybe clone it, as it can in fact be the original value
                    // due to the base/copy inversion at the start of this function
                    value: clonePatchValueIfNeeded(copy_[i])
                });
                inversePatches.push({
                    op: REPLACE,
                    path,
                    value: clonePatchValueIfNeeded(base_[i])
                });
            }
        }
        for(let i = base_.length; i < copy_.length; i++){
            const path = basePath.concat([
                i
            ]);
            patches.push({
                op: ADD,
                path,
                // Need to maybe clone it, as it can in fact be the original value
                // due to the base/copy inversion at the start of this function
                value: clonePatchValueIfNeeded(copy_[i])
            });
        }
        for(let i = copy_.length - 1; base_.length <= i; --i){
            const path = basePath.concat([
                i
            ]);
            inversePatches.push({
                op: REMOVE,
                path
            });
        }
    }
    function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
        const { base_, copy_ } = state;
        each(state.assigned_, (key, assignedValue)=>{
            const origValue = get(base_, key);
            const value = get(copy_, key);
            const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
            if (origValue === value && op === REPLACE) return;
            const path = basePath.concat(key);
            patches.push(op === REMOVE ? {
                op,
                path
            } : {
                op,
                path,
                value
            });
            inversePatches.push(op === ADD ? {
                op: REMOVE,
                path
            } : op === REMOVE ? {
                op: ADD,
                path,
                value: clonePatchValueIfNeeded(origValue)
            } : {
                op: REPLACE,
                path,
                value: clonePatchValueIfNeeded(origValue)
            });
        });
    }
    function generateSetPatches(state, basePath, patches, inversePatches) {
        let { base_, copy_ } = state;
        let i = 0;
        base_.forEach((value)=>{
            if (!copy_.has(value)) {
                const path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: REMOVE,
                    path,
                    value
                });
                inversePatches.unshift({
                    op: ADD,
                    path,
                    value
                });
            }
            i++;
        });
        i = 0;
        copy_.forEach((value)=>{
            if (!base_.has(value)) {
                const path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: ADD,
                    path,
                    value
                });
                inversePatches.unshift({
                    op: REMOVE,
                    path,
                    value
                });
            }
            i++;
        });
    }
    function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
        patches.push({
            op: REPLACE,
            path: [],
            value: replacement === NOTHING ? void 0 : replacement
        });
        inversePatches.push({
            op: REPLACE,
            path: [],
            value: baseValue
        });
    }
    function applyPatches_(draft, patches) {
        patches.forEach((patch)=>{
            const { path, op } = patch;
            let base = draft;
            for(let i = 0; i < path.length - 1; i++){
                const parentType = getArchtype(base);
                let p = path[i];
                if (typeof p !== "string" && typeof p !== "number") {
                    p = "" + p;
                }
                if ((parentType === 0 /* Object */  || parentType === 1 /* Array */ ) && (p === "__proto__" || p === "constructor")) die(errorOffset + 3);
                if (typeof base === "function" && p === "prototype") die(errorOffset + 3);
                base = get(base, p);
                if (typeof base !== "object") die(errorOffset + 2, path.join("/"));
            }
            const type = getArchtype(base);
            const value = deepClonePatchValue(patch.value);
            const key = path[path.length - 1];
            switch(op){
                case REPLACE:
                    switch(type){
                        case 2 /* Map */ :
                            return base.set(key, value);
                        case 3 /* Set */ :
                            die(errorOffset);
                        default:
                            return base[key] = value;
                    }
                case ADD:
                    switch(type){
                        case 1 /* Array */ :
                            return key === "-" ? base.push(value) : base.splice(key, 0, value);
                        case 2 /* Map */ :
                            return base.set(key, value);
                        case 3 /* Set */ :
                            return base.add(value);
                        default:
                            return base[key] = value;
                    }
                case REMOVE:
                    switch(type){
                        case 1 /* Array */ :
                            return base.splice(key, 1);
                        case 2 /* Map */ :
                            return base.delete(key);
                        case 3 /* Set */ :
                            return base.delete(patch.value);
                        default:
                            return delete base[key];
                    }
                default:
                    die(errorOffset + 1, op);
            }
        });
        return draft;
    }
    function deepClonePatchValue(obj) {
        if (!isDraftable(obj)) return obj;
        if (Array.isArray(obj)) return obj.map(deepClonePatchValue);
        if (isMap(obj)) return new Map(Array.from(obj.entries()).map((param)=>{
            let [k, v] = param;
            return [
                k,
                deepClonePatchValue(v)
            ];
        }));
        if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));
        const cloned = Object.create(getPrototypeOf(obj));
        for(const key in obj)cloned[key] = deepClonePatchValue(obj[key]);
        if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];
        return cloned;
    }
    function clonePatchValueIfNeeded(obj) {
        if (isDraft(obj)) {
            return deepClonePatchValue(obj);
        } else return obj;
    }
    loadPlugin("Patches", {
        applyPatches_,
        generatePatches_,
        generateReplacementPatches_
    });
}
// src/plugins/mapset.ts
function enableMapSet() {
    class DraftMap extends Map {
        get size() {
            return latest(this[DRAFT_STATE]).size;
        }
        has(key) {
            return latest(this[DRAFT_STATE]).has(key);
        }
        set(key, value) {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (!latest(state).has(key) || latest(state).get(key) !== value) {
                prepareMapCopy(state);
                markChanged(state);
                state.assigned_.set(key, true);
                state.copy_.set(key, value);
                state.assigned_.set(key, true);
            }
            return this;
        }
        delete(key) {
            if (!this.has(key)) {
                return false;
            }
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            prepareMapCopy(state);
            markChanged(state);
            if (state.base_.has(key)) {
                state.assigned_.set(key, false);
            } else {
                state.assigned_.delete(key);
            }
            state.copy_.delete(key);
            return true;
        }
        clear() {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (latest(state).size) {
                prepareMapCopy(state);
                markChanged(state);
                state.assigned_ = /* @__PURE__ */ new Map();
                each(state.base_, (key)=>{
                    state.assigned_.set(key, false);
                });
                state.copy_.clear();
            }
        }
        forEach(cb, thisArg) {
            const state = this[DRAFT_STATE];
            latest(state).forEach((_value, key, _map)=>{
                cb.call(thisArg, this.get(key), key, this);
            });
        }
        get(key) {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            const value = latest(state).get(key);
            if (state.finalized_ || !isDraftable(value)) {
                return value;
            }
            if (value !== state.base_.get(key)) {
                return value;
            }
            const draft = createProxy(value, state);
            prepareMapCopy(state);
            state.copy_.set(key, draft);
            return draft;
        }
        keys() {
            return latest(this[DRAFT_STATE]).keys();
        }
        values() {
            const iterator = this.keys();
            return {
                [Symbol.iterator]: ()=>this.values(),
                next: ()=>{
                    const r = iterator.next();
                    if (r.done) return r;
                    const value = this.get(r.value);
                    return {
                        done: false,
                        value
                    };
                }
            };
        }
        entries() {
            const iterator = this.keys();
            return {
                [Symbol.iterator]: ()=>this.entries(),
                next: ()=>{
                    const r = iterator.next();
                    if (r.done) return r;
                    const value = this.get(r.value);
                    return {
                        done: false,
                        value: [
                            r.value,
                            value
                        ]
                    };
                }
            };
        }
        [(DRAFT_STATE, Symbol.iterator)]() {
            return this.entries();
        }
        constructor(target, parent){
            super();
            this[DRAFT_STATE] = {
                type_: 2 /* Map */ ,
                parent_: parent,
                scope_: parent ? parent.scope_ : getCurrentScope(),
                modified_: false,
                finalized_: false,
                copy_: void 0,
                assigned_: void 0,
                base_: target,
                draft_: this,
                isManual_: false,
                revoked_: false
            };
        }
    }
    function proxyMap_(target, parent) {
        return new DraftMap(target, parent);
    }
    function prepareMapCopy(state) {
        if (!state.copy_) {
            state.assigned_ = /* @__PURE__ */ new Map();
            state.copy_ = new Map(state.base_);
        }
    }
    class DraftSet extends Set {
        get size() {
            return latest(this[DRAFT_STATE]).size;
        }
        has(value) {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (!state.copy_) {
                return state.base_.has(value);
            }
            if (state.copy_.has(value)) return true;
            if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;
            return false;
        }
        add(value) {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (!this.has(value)) {
                prepareSetCopy(state);
                markChanged(state);
                state.copy_.add(value);
            }
            return this;
        }
        delete(value) {
            if (!this.has(value)) {
                return false;
            }
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            prepareSetCopy(state);
            markChanged(state);
            return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : /* istanbul ignore next */ false);
        }
        clear() {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            if (latest(state).size) {
                prepareSetCopy(state);
                markChanged(state);
                state.copy_.clear();
            }
        }
        values() {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            prepareSetCopy(state);
            return state.copy_.values();
        }
        entries() {
            const state = this[DRAFT_STATE];
            assertUnrevoked(state);
            prepareSetCopy(state);
            return state.copy_.entries();
        }
        keys() {
            return this.values();
        }
        [(DRAFT_STATE, Symbol.iterator)]() {
            return this.values();
        }
        forEach(cb, thisArg) {
            const iterator = this.values();
            let result = iterator.next();
            while(!result.done){
                cb.call(thisArg, result.value, result.value, this);
                result = iterator.next();
            }
        }
        constructor(target, parent){
            super();
            this[DRAFT_STATE] = {
                type_: 3 /* Set */ ,
                parent_: parent,
                scope_: parent ? parent.scope_ : getCurrentScope(),
                modified_: false,
                finalized_: false,
                copy_: void 0,
                base_: target,
                draft_: this,
                drafts_: /* @__PURE__ */ new Map(),
                revoked_: false,
                isManual_: false
            };
        }
    }
    function proxySet_(target, parent) {
        return new DraftSet(target, parent);
    }
    function prepareSetCopy(state) {
        if (!state.copy_) {
            state.copy_ = /* @__PURE__ */ new Set();
            state.base_.forEach((value)=>{
                if (isDraftable(value)) {
                    const draft = createProxy(value, state);
                    state.drafts_.set(value, draft);
                    state.copy_.add(draft);
                } else {
                    state.copy_.add(value);
                }
            });
        }
    }
    function assertUnrevoked(state) {
        if (state.revoked_) die(3, JSON.stringify(latest(state)));
    }
    loadPlugin("MapSet", {
        proxyMap_,
        proxySet_
    });
}
// src/immer.ts
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = immer.produceWithPatches.bind(immer);
var setAutoFreeze = immer.setAutoFreeze.bind(immer);
var setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);
var applyPatches = immer.applyPatches.bind(immer);
var createDraft = immer.createDraft.bind(immer);
var finishDraft = immer.finishDraft.bind(immer);
function castDraft(value) {
    return value;
}
function castImmutable(value) {
    return value;
}
;
 //# sourceMappingURL=immer.mjs.map
}),
"[project]/node_modules/reselect/dist/reselect.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/devModeChecks/identityFunctionCheck.ts
__turbopack_context__.s({
    "createSelector": ()=>createSelector,
    "createSelectorCreator": ()=>createSelectorCreator,
    "createStructuredSelector": ()=>createStructuredSelector,
    "lruMemoize": ()=>lruMemoize,
    "referenceEqualityCheck": ()=>referenceEqualityCheck,
    "setGlobalDevModeChecks": ()=>setGlobalDevModeChecks,
    "unstable_autotrackMemoize": ()=>autotrackMemoize,
    "weakMapMemoize": ()=>weakMapMemoize
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
;
var runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult)=>{
    if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
        let isInputSameAsOutput = false;
        try {
            const emptyObject = {};
            if (resultFunc(emptyObject) === emptyObject) isInputSameAsOutput = true;
        } catch (e) {}
        if (isInputSameAsOutput) {
            let stack = void 0;
            try {
                throw new Error();
            } catch (e) {
                ;
                ({ stack } = e);
            }
            console.warn("The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.", {
                stack
            });
        }
    }
};
// src/devModeChecks/inputStabilityCheck.ts
var runInputStabilityCheck = (inputSelectorResultsObject, options, inputSelectorArgs)=>{
    const { memoize, memoizeOptions } = options;
    const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;
    const createAnEmptyObject = memoize(()=>({}), ...memoizeOptions);
    const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);
    if (!areInputSelectorResultsEqual) {
        let stack = void 0;
        try {
            throw new Error();
        } catch (e) {
            ;
            ({ stack } = e);
        }
        console.warn("An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`", {
            arguments: inputSelectorArgs,
            firstInputs: inputSelectorResults,
            secondInputs: inputSelectorResultsCopy,
            stack
        });
    }
};
// src/devModeChecks/setGlobalDevModeChecks.ts
var globalDevModeChecks = {
    inputStabilityCheck: "once",
    identityFunctionCheck: "once"
};
var setGlobalDevModeChecks = (devModeChecks)=>{
    Object.assign(globalDevModeChecks, devModeChecks);
};
// src/utils.ts
var NOT_FOUND = /* @__PURE__ */ Symbol("NOT_FOUND");
function assertIsFunction(func) {
    let errorMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "expected a function, instead received ".concat(typeof func);
    if (typeof func !== "function") {
        throw new TypeError(errorMessage);
    }
}
function assertIsObject(object) {
    let errorMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "expected an object, instead received ".concat(typeof object);
    if (typeof object !== "object") {
        throw new TypeError(errorMessage);
    }
}
function assertIsArrayOfFunctions(array) {
    let errorMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "expected all items to be functions, instead received the following types: ";
    if (!array.every((item)=>typeof item === "function")) {
        const itemTypes = array.map((item)=>typeof item === "function" ? "function ".concat(item.name || "unnamed", "()") : typeof item).join(", ");
        throw new TypeError("".concat(errorMessage, "[").concat(itemTypes, "]"));
    }
}
var ensureIsArray = (item)=>{
    return Array.isArray(item) ? item : [
        item
    ];
};
function getDependencies(createSelectorArgs) {
    const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
    assertIsArrayOfFunctions(dependencies, "createSelector expects all input-selectors to be functions, but received the following types: ");
    return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
    const inputSelectorResults = [];
    const { length } = dependencies;
    for(let i = 0; i < length; i++){
        inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
    }
    return inputSelectorResults;
}
var getDevModeChecksExecutionInfo = (firstRun, devModeChecks)=>{
    const { identityFunctionCheck, inputStabilityCheck } = {
        ...globalDevModeChecks,
        ...devModeChecks
    };
    return {
        identityFunctionCheck: {
            shouldRun: identityFunctionCheck === "always" || identityFunctionCheck === "once" && firstRun,
            run: runIdentityFunctionCheck
        },
        inputStabilityCheck: {
            shouldRun: inputStabilityCheck === "always" || inputStabilityCheck === "once" && firstRun,
            run: runInputStabilityCheck
        }
    };
};
// src/autotrackMemoize/autotracking.ts
var $REVISION = 0;
var CURRENT_TRACKER = null;
var Cell = class {
    // Whenever a storage value is read, it'll add itself to the current tracker if
    // one exists, entangling its state with that cache.
    get value() {
        CURRENT_TRACKER === null || CURRENT_TRACKER === void 0 ? void 0 : CURRENT_TRACKER.add(this);
        return this._value;
    }
    // Whenever a storage value is updated, we bump the global revision clock,
    // assign the revision for this storage to the new value, _and_ we schedule a
    // rerender. This is important, and it's what makes autotracking  _pull_
    // based. We don't actively tell the caches which depend on the storage that
    // anything has happened. Instead, we recompute the caches when needed.
    set value(newValue) {
        if (this.value === newValue) return;
        this._value = newValue;
        this.revision = ++$REVISION;
    }
    constructor(initialValue, isEqual = tripleEq){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "revision", $REVISION);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_value", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_lastValue", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_isEqual", tripleEq);
        this._value = this._lastValue = initialValue;
        this._isEqual = isEqual;
    }
};
function tripleEq(a, b) {
    return a === b;
}
var TrackingCache = class {
    clear() {
        this._cachedValue = void 0;
        this._cachedRevision = -1;
        this._deps = [];
        this.hits = 0;
    }
    get value() {
        if (this.revision > this._cachedRevision) {
            const { fn } = this;
            const currentTracker = /* @__PURE__ */ new Set();
            const prevTracker = CURRENT_TRACKER;
            CURRENT_TRACKER = currentTracker;
            this._cachedValue = fn();
            CURRENT_TRACKER = prevTracker;
            this.hits++;
            this._deps = Array.from(currentTracker);
            this._cachedRevision = this.revision;
        }
        CURRENT_TRACKER === null || CURRENT_TRACKER === void 0 ? void 0 : CURRENT_TRACKER.add(this);
        return this._cachedValue;
    }
    get revision() {
        return Math.max(...this._deps.map((d)=>d.revision), 0);
    }
    constructor(fn){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_cachedValue", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_cachedRevision", -1);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_deps", []);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "hits", 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "fn", void 0);
        this.fn = fn;
    }
};
function getValue(cell) {
    if (!(cell instanceof Cell)) {
        console.warn("Not a valid cell! ", cell);
    }
    return cell.value;
}
function setValue(storage, value) {
    if (!(storage instanceof Cell)) {
        throw new TypeError("setValue must be passed a tracked store created with `createStorage`.");
    }
    storage.value = storage._lastValue = value;
}
function createCell(initialValue) {
    let isEqual = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : tripleEq;
    return new Cell(initialValue, isEqual);
}
function createCache(fn) {
    assertIsFunction(fn, "the first parameter to `createCache` must be a function");
    return new TrackingCache(fn);
}
// src/autotrackMemoize/tracking.ts
var neverEq = (a, b)=>false;
function createTag() {
    return createCell(null, neverEq);
}
function dirtyTag(tag, value) {
    setValue(tag, value);
}
var consumeCollection = (node)=>{
    let tag = node.collectionTag;
    if (tag === null) {
        tag = node.collectionTag = createTag();
    }
    getValue(tag);
};
var dirtyCollection = (node)=>{
    const tag = node.collectionTag;
    if (tag !== null) {
        dirtyTag(tag, null);
    }
};
// src/autotrackMemoize/proxy.ts
var REDUX_PROXY_LABEL = Symbol();
var nextId = 0;
var proto = Object.getPrototypeOf({});
var ObjectTreeNode = class {
    constructor(value){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "proxy", new Proxy(this, objectProxyHandler));
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "tag", createTag());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "tags", {});
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "children", {});
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "collectionTag", null);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "id", nextId++);
        this.value = value;
        this.value = value;
        this.tag.value = value;
    }
};
var objectProxyHandler = {
    get (node, key) {
        function calculateResult() {
            const { value } = node;
            const childValue = Reflect.get(value, key);
            if (typeof key === "symbol") {
                return childValue;
            }
            if (key in proto) {
                return childValue;
            }
            if (typeof childValue === "object" && childValue !== null) {
                let childNode = node.children[key];
                if (childNode === void 0) {
                    childNode = node.children[key] = createNode(childValue);
                }
                if (childNode.tag) {
                    getValue(childNode.tag);
                }
                return childNode.proxy;
            } else {
                let tag = node.tags[key];
                if (tag === void 0) {
                    tag = node.tags[key] = createTag();
                    tag.value = childValue;
                }
                getValue(tag);
                return childValue;
            }
        }
        const res = calculateResult();
        return res;
    },
    ownKeys (node) {
        consumeCollection(node);
        return Reflect.ownKeys(node.value);
    },
    getOwnPropertyDescriptor (node, prop) {
        return Reflect.getOwnPropertyDescriptor(node.value, prop);
    },
    has (node, prop) {
        return Reflect.has(node.value, prop);
    }
};
var ArrayTreeNode = class {
    constructor(value){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "proxy", new Proxy([
            this
        ], arrayProxyHandler));
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "tag", createTag());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "tags", {});
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "children", {});
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "collectionTag", null);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "id", nextId++);
        this.value = value;
        this.value = value;
        this.tag.value = value;
    }
};
var arrayProxyHandler = {
    get (param, key) {
        let [node] = param;
        if (key === "length") {
            consumeCollection(node);
        }
        return objectProxyHandler.get(node, key);
    },
    ownKeys (param) {
        let [node] = param;
        return objectProxyHandler.ownKeys(node);
    },
    getOwnPropertyDescriptor (param, prop) {
        let [node] = param;
        return objectProxyHandler.getOwnPropertyDescriptor(node, prop);
    },
    has (param, prop) {
        let [node] = param;
        return objectProxyHandler.has(node, prop);
    }
};
function createNode(value) {
    if (Array.isArray(value)) {
        return new ArrayTreeNode(value);
    }
    return new ObjectTreeNode(value);
}
function updateNode(node, newValue) {
    const { value, tags, children } = node;
    node.value = newValue;
    if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) {
        dirtyCollection(node);
    } else {
        if (value !== newValue) {
            let oldKeysSize = 0;
            let newKeysSize = 0;
            let anyKeysAdded = false;
            for(const _key in value){
                oldKeysSize++;
            }
            for(const key in newValue){
                newKeysSize++;
                if (!(key in value)) {
                    anyKeysAdded = true;
                    break;
                }
            }
            const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;
            if (isDifferent) {
                dirtyCollection(node);
            }
        }
    }
    for(const key in tags){
        const childValue = value[key];
        const newChildValue = newValue[key];
        if (childValue !== newChildValue) {
            dirtyCollection(node);
            dirtyTag(tags[key], newChildValue);
        }
        if (typeof newChildValue === "object" && newChildValue !== null) {
            delete tags[key];
        }
    }
    for(const key in children){
        const childNode = children[key];
        const newChildValue = newValue[key];
        const childValue = childNode.value;
        if (childValue === newChildValue) {
            continue;
        } else if (typeof newChildValue === "object" && newChildValue !== null) {
            updateNode(childNode, newChildValue);
        } else {
            deleteNode(childNode);
            delete children[key];
        }
    }
}
function deleteNode(node) {
    if (node.tag) {
        dirtyTag(node.tag, null);
    }
    dirtyCollection(node);
    for(const key in node.tags){
        dirtyTag(node.tags[key], null);
    }
    for(const key in node.children){
        deleteNode(node.children[key]);
    }
}
// src/lruMemoize.ts
function createSingletonCache(equals) {
    let entry;
    return {
        get (key) {
            if (entry && equals(entry.key, key)) {
                return entry.value;
            }
            return NOT_FOUND;
        },
        put (key, value) {
            entry = {
                key,
                value
            };
        },
        getEntries () {
            return entry ? [
                entry
            ] : [];
        },
        clear () {
            entry = void 0;
        }
    };
}
function createLruCache(maxSize, equals) {
    let entries = [];
    function get(key) {
        const cacheIndex = entries.findIndex((entry)=>equals(key, entry.key));
        if (cacheIndex > -1) {
            const entry = entries[cacheIndex];
            if (cacheIndex > 0) {
                entries.splice(cacheIndex, 1);
                entries.unshift(entry);
            }
            return entry.value;
        }
        return NOT_FOUND;
    }
    function put(key, value) {
        if (get(key) === NOT_FOUND) {
            entries.unshift({
                key,
                value
            });
            if (entries.length > maxSize) {
                entries.pop();
            }
        }
    }
    function getEntries() {
        return entries;
    }
    function clear() {
        entries = [];
    }
    return {
        get,
        put,
        getEntries,
        clear
    };
}
var referenceEqualityCheck = (a, b)=>a === b;
function createCacheKeyComparator(equalityCheck) {
    return function areArgumentsShallowlyEqual(prev, next) {
        if (prev === null || next === null || prev.length !== next.length) {
            return false;
        }
        const { length } = prev;
        for(let i = 0; i < length; i++){
            if (!equalityCheck(prev[i], next[i])) {
                return false;
            }
        }
        return true;
    };
}
function lruMemoize(func, equalityCheckOrOptions) {
    const providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : {
        equalityCheck: equalityCheckOrOptions
    };
    const { equalityCheck = referenceEqualityCheck, maxSize = 1, resultEqualityCheck } = providedOptions;
    const comparator = createCacheKeyComparator(equalityCheck);
    let resultsCount = 0;
    const cache = maxSize <= 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
    function memoized() {
        let value = cache.get(arguments);
        if (value === NOT_FOUND) {
            value = func.apply(null, arguments);
            resultsCount++;
            if (resultEqualityCheck) {
                const entries = cache.getEntries();
                const matchingEntry = entries.find((entry)=>resultEqualityCheck(entry.value, value));
                if (matchingEntry) {
                    value = matchingEntry.value;
                    resultsCount !== 0 && resultsCount--;
                }
            }
            cache.put(arguments, value);
        }
        return value;
    }
    memoized.clearCache = ()=>{
        cache.clear();
        memoized.resetResultsCount();
    };
    memoized.resultsCount = ()=>resultsCount;
    memoized.resetResultsCount = ()=>{
        resultsCount = 0;
    };
    return memoized;
}
// src/autotrackMemoize/autotrackMemoize.ts
function autotrackMemoize(func) {
    const node = createNode([]);
    let lastArgs = null;
    const shallowEqual = createCacheKeyComparator(referenceEqualityCheck);
    const cache = createCache(()=>{
        const res = func.apply(null, node.proxy);
        return res;
    });
    function memoized() {
        if (!shallowEqual(lastArgs, arguments)) {
            updateNode(node, arguments);
            lastArgs = arguments;
        }
        return cache.value;
    }
    memoized.clearCache = ()=>{
        return cache.clear();
    };
    return memoized;
}
// src/weakMapMemoize.ts
var StrongRef = class {
    deref() {
        return this.value;
    }
    constructor(value){
        this.value = value;
    }
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
    return {
        s: UNTERMINATED,
        v: void 0,
        o: null,
        p: null
    };
}
function weakMapMemoize(func) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let fnNode = createCacheNode();
    const { resultEqualityCheck } = options;
    let lastResult;
    let resultsCount = 0;
    function memoized() {
        let cacheNode = fnNode;
        const { length } = arguments;
        for(let i = 0, l = length; i < l; i++){
            const arg = arguments[i];
            if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
                let objectCache = cacheNode.o;
                if (objectCache === null) {
                    cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
                }
                const objectNode = objectCache.get(arg);
                if (objectNode === void 0) {
                    cacheNode = createCacheNode();
                    objectCache.set(arg, cacheNode);
                } else {
                    cacheNode = objectNode;
                }
            } else {
                let primitiveCache = cacheNode.p;
                if (primitiveCache === null) {
                    cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
                }
                const primitiveNode = primitiveCache.get(arg);
                if (primitiveNode === void 0) {
                    cacheNode = createCacheNode();
                    primitiveCache.set(arg, cacheNode);
                } else {
                    cacheNode = primitiveNode;
                }
            }
        }
        const terminatedNode = cacheNode;
        let result;
        if (cacheNode.s === TERMINATED) {
            result = cacheNode.v;
        } else {
            result = func.apply(null, arguments);
            resultsCount++;
            if (resultEqualityCheck) {
                var _lastResult_deref;
                var _lastResult_deref1;
                const lastResultValue = (_lastResult_deref1 = lastResult === null || lastResult === void 0 ? void 0 : (_lastResult_deref = lastResult.deref) === null || _lastResult_deref === void 0 ? void 0 : _lastResult_deref.call(lastResult)) !== null && _lastResult_deref1 !== void 0 ? _lastResult_deref1 : lastResult;
                if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
                    result = lastResultValue;
                    resultsCount !== 0 && resultsCount--;
                }
                const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
                lastResult = needsWeakRef ? new Ref(result) : result;
            }
        }
        terminatedNode.s = TERMINATED;
        terminatedNode.v = result;
        return result;
    }
    memoized.clearCache = ()=>{
        fnNode = createCacheNode();
        memoized.resetResultsCount();
    };
    memoized.resultsCount = ()=>resultsCount;
    memoized.resetResultsCount = ()=>{
        resultsCount = 0;
    };
    return memoized;
}
// src/createSelectorCreator.ts
function createSelectorCreator(memoizeOrOptions) {
    for(var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        memoizeOptionsFromArgs[_key - 1] = arguments[_key];
    }
    const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
        memoize: memoizeOrOptions,
        memoizeOptions: memoizeOptionsFromArgs
    } : memoizeOrOptions;
    const createSelector2 = function() {
        for(var _len = arguments.length, createSelectorArgs = new Array(_len), _key = 0; _key < _len; _key++){
            createSelectorArgs[_key] = arguments[_key];
        }
        let recomputations = 0;
        let dependencyRecomputations = 0;
        let lastResult;
        let directlyPassedOptions = {};
        let resultFunc = createSelectorArgs.pop();
        if (typeof resultFunc === "object") {
            directlyPassedOptions = resultFunc;
            resultFunc = createSelectorArgs.pop();
        }
        assertIsFunction(resultFunc, "createSelector expects an output function after the inputs, but received: [".concat(typeof resultFunc, "]"));
        const combinedOptions = {
            ...createSelectorCreatorOptions,
            ...directlyPassedOptions
        };
        const { memoize, memoizeOptions = [], argsMemoize = weakMapMemoize, argsMemoizeOptions = [], devModeChecks = {} } = combinedOptions;
        const finalMemoizeOptions = ensureIsArray(memoizeOptions);
        const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
        const dependencies = getDependencies(createSelectorArgs);
        const memoizedResultFunc = memoize(function recomputationWrapper() {
            recomputations++;
            return resultFunc.apply(null, arguments);
        }, ...finalMemoizeOptions);
        let firstRun = true;
        const selector = argsMemoize(function dependenciesChecker() {
            dependencyRecomputations++;
            const inputSelectorResults = collectInputSelectorResults(dependencies, arguments);
            lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
            if ("TURBOPACK compile-time truthy", 1) {
                const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);
                if (identityFunctionCheck.shouldRun) {
                    identityFunctionCheck.run(resultFunc, inputSelectorResults, lastResult);
                }
                if (inputStabilityCheck.shouldRun) {
                    const inputSelectorResultsCopy = collectInputSelectorResults(dependencies, arguments);
                    inputStabilityCheck.run({
                        inputSelectorResults,
                        inputSelectorResultsCopy
                    }, {
                        memoize,
                        memoizeOptions: finalMemoizeOptions
                    }, arguments);
                }
                if (firstRun) firstRun = false;
            }
            return lastResult;
        }, ...finalArgsMemoizeOptions);
        return Object.assign(selector, {
            resultFunc,
            memoizedResultFunc,
            dependencies,
            dependencyRecomputations: ()=>dependencyRecomputations,
            resetDependencyRecomputations: ()=>{
                dependencyRecomputations = 0;
            },
            lastResult: ()=>lastResult,
            recomputations: ()=>recomputations,
            resetRecomputations: ()=>{
                recomputations = 0;
            },
            memoize,
            argsMemoize
        });
    };
    Object.assign(createSelector2, {
        withTypes: ()=>createSelector2
    });
    return createSelector2;
}
var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
// src/createStructuredSelector.ts
var createStructuredSelector = Object.assign(function(inputSelectorsObject) {
    let selectorCreator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : createSelector;
    assertIsObject(inputSelectorsObject, "createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ".concat(typeof inputSelectorsObject));
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map((key)=>inputSelectorsObject[key]);
    const structuredSelector = selectorCreator(dependencies, function() {
        for(var _len = arguments.length, inputSelectorResults = new Array(_len), _key = 0; _key < _len; _key++){
            inputSelectorResults[_key] = arguments[_key];
        }
        return inputSelectorResults.reduce((composition, value, index)=>{
            composition[inputSelectorKeys[index]] = value;
            return composition;
        }, {});
    });
    return structuredSelector;
}, {
    withTypes: ()=>createStructuredSelector
});
;
 //# sourceMappingURL=reselect.mjs.map
}),
"[project]/node_modules/redux/dist/redux.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/utils/formatProdErrorMessage.ts
__turbopack_context__.s({
    "__DO_NOT_USE__ActionTypes": ()=>actionTypes_default,
    "applyMiddleware": ()=>applyMiddleware,
    "bindActionCreators": ()=>bindActionCreators,
    "combineReducers": ()=>combineReducers,
    "compose": ()=>compose,
    "createStore": ()=>createStore,
    "isAction": ()=>isAction,
    "isPlainObject": ()=>isPlainObject,
    "legacy_createStore": ()=>legacy_createStore
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
function formatProdErrorMessage(code) {
    return "Minified Redux error #".concat(code, "; visit https://redux.js.org/Errors?code=").concat(code, " for the full message or use the non-minified dev environment for full errors. ");
}
// src/utils/symbol-observable.ts
var $$observable = /* @__PURE__ */ (()=>typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
// src/utils/actionTypes.ts
var randomString = ()=>Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
    INIT: "@@redux/INIT".concat(/* @__PURE__ */ randomString()),
    REPLACE: "@@redux/REPLACE".concat(/* @__PURE__ */ randomString()),
    PROBE_UNKNOWN_ACTION: ()=>"@@redux/PROBE_UNKNOWN_ACTION".concat(randomString())
};
var actionTypes_default = ActionTypes;
// src/utils/isPlainObject.ts
function isPlainObject(obj) {
    if (typeof obj !== "object" || obj === null) return false;
    let proto = obj;
    while(Object.getPrototypeOf(proto) !== null){
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
}
// src/utils/kindOf.ts
function miniKindOf(val) {
    if (val === void 0) return "undefined";
    if (val === null) return "null";
    const type = typeof val;
    switch(type){
        case "boolean":
        case "string":
        case "number":
        case "symbol":
        case "function":
            {
                return type;
            }
    }
    if (Array.isArray(val)) return "array";
    if (isDate(val)) return "date";
    if (isError(val)) return "error";
    const constructorName = ctorName(val);
    switch(constructorName){
        case "Symbol":
        case "Promise":
        case "WeakMap":
        case "WeakSet":
        case "Map":
        case "Set":
            return constructorName;
    }
    return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
    return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
    return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
    if (val instanceof Date) return true;
    return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
    let typeOfVal = typeof val;
    if ("TURBOPACK compile-time truthy", 1) {
        typeOfVal = miniKindOf(val);
    }
    return typeOfVal;
}
// src/createStore.ts
function createStore(reducer, preloadedState, enhancer) {
    if (typeof reducer !== "function") {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Expected the root reducer to be a function. Instead, received: '".concat(kindOf(reducer), "'"));
    }
    if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
    }
    if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
        enhancer = preloadedState;
        preloadedState = void 0;
    }
    if (typeof enhancer !== "undefined") {
        if (typeof enhancer !== "function") {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Expected the enhancer to be a function. Instead, received: '".concat(kindOf(enhancer), "'"));
        }
        return enhancer(createStore)(reducer, preloadedState);
    }
    let currentReducer = reducer;
    let currentState = preloadedState;
    let currentListeners = /* @__PURE__ */ new Map();
    let nextListeners = currentListeners;
    let listenerIdCounter = 0;
    let isDispatching = false;
    function ensureCanMutateNextListeners() {
        if (nextListeners === currentListeners) {
            nextListeners = /* @__PURE__ */ new Map();
            currentListeners.forEach((listener, key)=>{
                nextListeners.set(key, listener);
            });
        }
    }
    function getState() {
        if (isDispatching) {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
        }
        return currentState;
    }
    function subscribe(listener) {
        if (typeof listener !== "function") {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Expected the listener to be a function. Instead, received: '".concat(kindOf(listener), "'"));
        }
        if (isDispatching) {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
        }
        let isSubscribed = true;
        ensureCanMutateNextListeners();
        const listenerId = listenerIdCounter++;
        nextListeners.set(listenerId, listener);
        return function unsubscribe() {
            if (!isSubscribed) {
                return;
            }
            if (isDispatching) {
                throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
            }
            isSubscribed = false;
            ensureCanMutateNextListeners();
            nextListeners.delete(listenerId);
            currentListeners = null;
        };
    }
    function dispatch(action) {
        if (!isPlainObject(action)) {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Actions must be plain objects. Instead, the actual type was: '".concat(kindOf(action), "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples."));
        }
        if (typeof action.type === "undefined") {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
        }
        if (typeof action.type !== "string") {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 'Action "type" property must be a string. Instead, the actual type was: \''.concat(kindOf(action.type), "'. Value was: '").concat(action.type, "' (stringified)"));
        }
        if (isDispatching) {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Reducers may not dispatch actions.");
        }
        try {
            isDispatching = true;
            currentState = currentReducer(currentState, action);
        } finally{
            isDispatching = false;
        }
        const listeners = currentListeners = nextListeners;
        listeners.forEach((listener)=>{
            listener();
        });
        return action;
    }
    function replaceReducer(nextReducer) {
        if (typeof nextReducer !== "function") {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Expected the nextReducer to be a function. Instead, received: '".concat(kindOf(nextReducer)));
        }
        currentReducer = nextReducer;
        dispatch({
            type: actionTypes_default.REPLACE
        });
    }
    function observable() {
        const outerSubscribe = subscribe;
        return {
            /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */ subscribe (observer) {
                if (typeof observer !== "object" || observer === null) {
                    throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Expected the observer to be an object. Instead, received: '".concat(kindOf(observer), "'"));
                }
                function observeState() {
                    const observerAsObserver = observer;
                    if (observerAsObserver.next) {
                        observerAsObserver.next(getState());
                    }
                }
                observeState();
                const unsubscribe = outerSubscribe(observeState);
                return {
                    unsubscribe
                };
            },
            [symbol_observable_default] () {
                return this;
            }
        };
    }
    dispatch({
        type: actionTypes_default.INIT
    });
    const store = {
        dispatch,
        subscribe,
        getState,
        replaceReducer,
        [symbol_observable_default]: observable
    };
    return store;
}
function legacy_createStore(reducer, preloadedState, enhancer) {
    return createStore(reducer, preloadedState, enhancer);
}
// src/utils/warning.ts
function warning(message) {
    if (typeof console !== "undefined" && typeof console.error === "function") {
        console.error(message);
    }
    try {
        throw new Error(message);
    } catch (e) {}
}
// src/combineReducers.ts
function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
    const reducerKeys = Object.keys(reducers);
    const argumentName = action && action.type === actionTypes_default.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
    if (reducerKeys.length === 0) {
        return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
    }
    if (!isPlainObject(inputState)) {
        return "The ".concat(argumentName, ' has unexpected type of "').concat(kindOf(inputState), '". Expected argument to be an object with the following keys: "').concat(reducerKeys.join('", "'), '"');
    }
    const unexpectedKeys = Object.keys(inputState).filter((key)=>!reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);
    unexpectedKeys.forEach((key)=>{
        unexpectedKeyCache[key] = true;
    });
    if (action && action.type === actionTypes_default.REPLACE) return;
    if (unexpectedKeys.length > 0) {
        return "Unexpected ".concat(unexpectedKeys.length > 1 ? "keys" : "key", ' "').concat(unexpectedKeys.join('", "'), '" found in ').concat(argumentName, '. Expected to find one of the known reducer keys instead: "').concat(reducerKeys.join('", "'), '". Unexpected keys will be ignored.');
    }
}
function assertReducerShape(reducers) {
    Object.keys(reducers).forEach((key)=>{
        const reducer = reducers[key];
        const initialState = reducer(void 0, {
            type: actionTypes_default.INIT
        });
        if (typeof initialState === "undefined") {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 'The slice reducer for key "'.concat(key, "\" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined."));
        }
        if (typeof reducer(void 0, {
            type: actionTypes_default.PROBE_UNKNOWN_ACTION()
        }) === "undefined") {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 'The slice reducer for key "'.concat(key, "\" returned undefined when probed with a random type. Don't try to handle '").concat(actionTypes_default.INIT, '\' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.'));
        }
    });
}
function combineReducers(reducers) {
    const reducerKeys = Object.keys(reducers);
    const finalReducers = {};
    for(let i = 0; i < reducerKeys.length; i++){
        const key = reducerKeys[i];
        if ("TURBOPACK compile-time truthy", 1) {
            if (typeof reducers[key] === "undefined") {
                warning('No reducer provided for key "'.concat(key, '"'));
            }
        }
        if (typeof reducers[key] === "function") {
            finalReducers[key] = reducers[key];
        }
    }
    const finalReducerKeys = Object.keys(finalReducers);
    let unexpectedKeyCache;
    if (("TURBOPACK compile-time value", "development") !== "production") {
        unexpectedKeyCache = {};
    }
    let shapeAssertionError;
    try {
        assertReducerShape(finalReducers);
    } catch (e) {
        shapeAssertionError = e;
    }
    return function combination() {
        let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, action = arguments.length > 1 ? arguments[1] : void 0;
        if (shapeAssertionError) {
            throw shapeAssertionError;
        }
        if ("TURBOPACK compile-time truthy", 1) {
            const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
            if (warningMessage) {
                warning(warningMessage);
            }
        }
        let hasChanged = false;
        const nextState = {};
        for(let i = 0; i < finalReducerKeys.length; i++){
            const key = finalReducerKeys[i];
            const reducer = finalReducers[key];
            const previousStateForKey = state[key];
            const nextStateForKey = reducer(previousStateForKey, action);
            if (typeof nextStateForKey === "undefined") {
                const actionType = action && action.type;
                throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "When called with an action of type ".concat(actionType ? '"'.concat(String(actionType), '"') : "(unknown type)", ', the slice reducer for key "').concat(key, '" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.'));
            }
            nextState[key] = nextStateForKey;
            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
        }
        hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
        return hasChanged ? nextState : state;
    };
}
// src/bindActionCreators.ts
function bindActionCreator(actionCreator, dispatch) {
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return dispatch(actionCreator.apply(this, args));
    };
}
function bindActionCreators(actionCreators, dispatch) {
    if (typeof actionCreators === "function") {
        return bindActionCreator(actionCreators, dispatch);
    }
    if (typeof actionCreators !== "object" || actionCreators === null) {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "bindActionCreators expected an object or a function, but instead received: '".concat(kindOf(actionCreators), '\'. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?'));
    }
    const boundActionCreators = {};
    for(const key in actionCreators){
        const actionCreator = actionCreators[key];
        if (typeof actionCreator === "function") {
            boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
        }
    }
    return boundActionCreators;
}
// src/compose.ts
function compose() {
    for(var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++){
        funcs[_key] = arguments[_key];
    }
    if (funcs.length === 0) {
        return (arg)=>arg;
    }
    if (funcs.length === 1) {
        return funcs[0];
    }
    return funcs.reduce((a, b)=>function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            return a(b(...args));
        });
}
// src/applyMiddleware.ts
function applyMiddleware() {
    for(var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++){
        middlewares[_key] = arguments[_key];
    }
    return (createStore2)=>(reducer, preloadedState)=>{
            const store = createStore2(reducer, preloadedState);
            let dispatch = ()=>{
                throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
            };
            const middlewareAPI = {
                getState: store.getState,
                dispatch: function(action) {
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    return dispatch(action, ...args);
                }
            };
            const chain = middlewares.map((middleware)=>middleware(middlewareAPI));
            dispatch = compose(...chain)(store.dispatch);
            return {
                ...store,
                dispatch
            };
        };
}
// src/utils/isAction.ts
function isAction(action) {
    return isPlainObject(action) && "type" in action && typeof action.type === "string";
}
;
 //# sourceMappingURL=redux.mjs.map
}),
"[project]/node_modules/redux-thunk/dist/redux-thunk.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/index.ts
__turbopack_context__.s({
    "thunk": ()=>thunk,
    "withExtraArgument": ()=>withExtraArgument
});
function createThunkMiddleware(extraArgument) {
    const middleware = (param)=>{
        let { dispatch, getState } = param;
        return (next)=>(action)=>{
                if (typeof action === "function") {
                    return action(dispatch, getState, extraArgument);
                }
                return next(action);
            };
    };
    return middleware;
}
var thunk = createThunkMiddleware();
var withExtraArgument = createThunkMiddleware;
;
}),
"[project]/node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

// src/index.ts
__turbopack_context__.s({
    "ReducerType": ()=>ReducerType,
    "SHOULD_AUTOBATCH": ()=>SHOULD_AUTOBATCH,
    "TaskAbortError": ()=>TaskAbortError,
    "Tuple": ()=>Tuple,
    "addListener": ()=>addListener,
    "asyncThunkCreator": ()=>asyncThunkCreator,
    "autoBatchEnhancer": ()=>autoBatchEnhancer,
    "buildCreateSlice": ()=>buildCreateSlice,
    "clearAllListeners": ()=>clearAllListeners,
    "combineSlices": ()=>combineSlices,
    "configureStore": ()=>configureStore,
    "createAction": ()=>createAction,
    "createActionCreatorInvariantMiddleware": ()=>createActionCreatorInvariantMiddleware,
    "createAsyncThunk": ()=>createAsyncThunk,
    "createDraftSafeSelector": ()=>createDraftSafeSelector,
    "createDraftSafeSelectorCreator": ()=>createDraftSafeSelectorCreator,
    "createDynamicMiddleware": ()=>createDynamicMiddleware,
    "createEntityAdapter": ()=>createEntityAdapter,
    "createImmutableStateInvariantMiddleware": ()=>createImmutableStateInvariantMiddleware,
    "createListenerMiddleware": ()=>createListenerMiddleware,
    "createReducer": ()=>createReducer,
    "createSerializableStateInvariantMiddleware": ()=>createSerializableStateInvariantMiddleware,
    "createSlice": ()=>createSlice,
    "findNonSerializableValue": ()=>findNonSerializableValue,
    "formatProdErrorMessage": ()=>formatProdErrorMessage,
    "isActionCreator": ()=>isActionCreator,
    "isAllOf": ()=>isAllOf,
    "isAnyOf": ()=>isAnyOf,
    "isAsyncThunkAction": ()=>isAsyncThunkAction,
    "isFluxStandardAction": ()=>isFSA,
    "isFulfilled": ()=>isFulfilled,
    "isImmutableDefault": ()=>isImmutableDefault,
    "isPending": ()=>isPending,
    "isPlain": ()=>isPlain,
    "isRejected": ()=>isRejected,
    "isRejectedWithValue": ()=>isRejectedWithValue,
    "miniSerializeError": ()=>miniSerializeError,
    "nanoid": ()=>nanoid,
    "prepareAutoBatched": ()=>prepareAutoBatched,
    "removeListener": ()=>removeListener,
    "unwrapResult": ()=>unwrapResult
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
// src/createDraftSafeSelector.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/immer/dist/immer.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$reselect$2f$dist$2f$reselect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/reselect/dist/reselect.mjs [app-client] (ecmascript)");
// src/configureStore.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux/dist/redux.mjs [app-client] (ecmascript)");
// src/getDefaultMiddleware.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$thunk$2f$dist$2f$redux$2d$thunk$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-thunk/dist/redux-thunk.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
var createDraftSafeSelectorCreator = function() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    const createSelector2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$reselect$2f$dist$2f$reselect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSelectorCreator"])(...args);
    const createDraftSafeSelector2 = Object.assign(function() {
        for(var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++){
            args2[_key] = arguments[_key];
        }
        const selector = createSelector2(...args2);
        const wrappedSelector = function(value) {
            for(var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                rest[_key - 1] = arguments[_key];
            }
            return selector((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDraft"])(value) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["current"])(value) : value, ...rest);
        };
        Object.assign(wrappedSelector, selector);
        return wrappedSelector;
    }, {
        withTypes: ()=>createDraftSafeSelector2
    });
    return createDraftSafeSelector2;
};
var createDraftSafeSelector = /* @__PURE__ */ createDraftSafeSelectorCreator(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$reselect$2f$dist$2f$reselect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weakMapMemoize"]);
;
;
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
    if (arguments.length === 0) return void 0;
    if (typeof arguments[0] === "object") return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compose"];
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compose"].apply(null, arguments);
};
var devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
    return function(noop3) {
        return noop3;
    };
};
;
;
// src/tsHelpers.ts
var hasMatchFunction = (v)=>{
    return v && typeof v.match === "function";
};
// src/createAction.ts
function createAction(type, prepareAction) {
    function actionCreator() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (prepareAction) {
            let prepared = prepareAction(...args);
            if (!prepared) {
                throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "prepareAction did not return an object");
            }
            return {
                type,
                payload: prepared.payload,
                ..."meta" in prepared && {
                    meta: prepared.meta
                },
                ..."error" in prepared && {
                    error: prepared.error
                }
            };
        }
        return {
            type,
            payload: args[0]
        };
    }
    actionCreator.toString = ()=>"".concat(type);
    actionCreator.type = type;
    actionCreator.match = (action)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAction"])(action) && action.type === type;
    return actionCreator;
}
function isActionCreator(action) {
    return typeof action === "function" && "type" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it
    hasMatchFunction(action);
}
function isFSA(action) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAction"])(action) && Object.keys(action).every(isValidKey);
}
function isValidKey(key) {
    return [
        "type",
        "payload",
        "error",
        "meta"
    ].indexOf(key) > -1;
}
// src/actionCreatorInvariantMiddleware.ts
function getMessage(type) {
    const splitType = type ? "".concat(type).split("/") : [];
    const actionName = splitType[splitType.length - 1] || "actionCreator";
    return 'Detected an action creator with type "'.concat(type || "unknown", "\" being dispatched. \nMake sure you're calling the action creator before dispatching, i.e. `dispatch(").concat(actionName, "())` instead of `dispatch(").concat(actionName, ")`. This is necessary even if the action has no payload.");
}
function createActionCreatorInvariantMiddleware() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    const { isActionCreator: isActionCreator2 = isActionCreator } = options;
    return ()=>(next)=>(action)=>{
                if (isActionCreator2(action)) {
                    console.warn(getMessage(action.type));
                }
                return next(action);
            };
}
;
function getTimeMeasureUtils(maxDelay, fnName) {
    let elapsed = 0;
    return {
        measureTime (fn) {
            const started = Date.now();
            try {
                return fn();
            } finally{
                const finished = Date.now();
                elapsed += finished - started;
            }
        },
        warnIfExceeded () {
            if (elapsed > maxDelay) {
                console.warn("".concat(fnName, " took ").concat(elapsed, "ms, which is more than the warning threshold of ").concat(maxDelay, "ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that."));
            }
        }
    };
}
var Tuple = class _Tuple extends Array {
    static get [Symbol.species]() {
        return _Tuple;
    }
    concat() {
        for(var _len = arguments.length, arr = new Array(_len), _key = 0; _key < _len; _key++){
            arr[_key] = arguments[_key];
        }
        return super.concat.apply(this, arr);
    }
    prepend() {
        for(var _len = arguments.length, arr = new Array(_len), _key = 0; _key < _len; _key++){
            arr[_key] = arguments[_key];
        }
        if (arr.length === 1 && Array.isArray(arr[0])) {
            return new _Tuple(...arr[0].concat(this));
        }
        return new _Tuple(...arr.concat(this));
    }
    constructor(...items){
        super(...items);
        Object.setPrototypeOf(this, _Tuple.prototype);
    }
};
function freezeDraftable(val) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDraftable"])(val) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["produce"])(val, ()=>{}) : val;
}
function getOrInsertComputed(map, key, compute) {
    if (map.has(key)) return map.get(key);
    return map.set(key, compute(key)).get(key);
}
// src/immutableStateInvariantMiddleware.ts
function isImmutableDefault(value) {
    return typeof value !== "object" || value == null || Object.isFrozen(value);
}
function trackForMutations(isImmutable, ignorePaths, obj) {
    const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
    return {
        detectMutations () {
            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
        }
    };
}
function trackProperties(isImmutable) {
    let ignorePaths = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], obj = arguments.length > 2 ? arguments[2] : void 0, path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "", checkedObjects = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : /* @__PURE__ */ new Set();
    const tracked = {
        value: obj
    };
    if (!isImmutable(obj) && !checkedObjects.has(obj)) {
        checkedObjects.add(obj);
        tracked.children = {};
        for(const key in obj){
            const childPath = path ? path + "." + key : key;
            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
                continue;
            }
            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
        }
    }
    return tracked;
}
function detectMutations(isImmutable) {
    let ignoredPaths = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], trackedProperty = arguments.length > 2 ? arguments[2] : void 0, obj = arguments.length > 3 ? arguments[3] : void 0, sameParentRef = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, path = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "";
    const prevObj = trackedProperty ? trackedProperty.value : void 0;
    const sameRef = prevObj === obj;
    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
        return {
            wasMutated: true,
            path
        };
    }
    if (isImmutable(prevObj) || isImmutable(obj)) {
        return {
            wasMutated: false
        };
    }
    const keysToDetect = {};
    for(let key in trackedProperty.children){
        keysToDetect[key] = true;
    }
    for(let key in obj){
        keysToDetect[key] = true;
    }
    const hasIgnoredPaths = ignoredPaths.length > 0;
    for(let key in keysToDetect){
        const nestedPath = path ? path + "." + key : key;
        if (hasIgnoredPaths) {
            const hasMatches = ignoredPaths.some((ignored)=>{
                if (ignored instanceof RegExp) {
                    return ignored.test(nestedPath);
                }
                return nestedPath === ignored;
            });
            if (hasMatches) {
                continue;
            }
        }
        const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);
        if (result.wasMutated) {
            return result;
        }
    }
    return {
        wasMutated: false
    };
}
function createImmutableStateInvariantMiddleware() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        let stringify2 = function(obj, serializer, indent, decycler) {
            return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);
        }, getSerialize2 = function(serializer, decycler) {
            let stack = [], keys = [];
            if (!decycler) decycler = function(_, value) {
                if (stack[0] === value) return "[Circular ~]";
                return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
            };
            return function(key, value) {
                if (stack.length > 0) {
                    var thisPos = stack.indexOf(this);
                    ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
                    ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
                    if (~stack.indexOf(value)) value = decycler.call(this, key, value);
                } else stack.push(value);
                return serializer == null ? value : serializer.call(this, key, value);
            };
        };
        var stringify = stringify2, getSerialize = getSerialize2;
        let { isImmutable = isImmutableDefault, ignoredPaths, warnAfter = 32 } = options;
        const track = trackForMutations.bind(null, isImmutable, ignoredPaths);
        return (param)=>{
            let { getState } = param;
            let state = getState();
            let tracker = track(state);
            let result;
            return (next)=>(action)=>{
                    const measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
                    measureUtils.measureTime(()=>{
                        state = getState();
                        result = tracker.detectMutations();
                        tracker = track(state);
                        if (result.wasMutated) {
                            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "A state mutation was detected between dispatches, in the path '".concat(result.path || "", "'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)"));
                        }
                    });
                    const dispatchedAction = next(action);
                    measureUtils.measureTime(()=>{
                        state = getState();
                        result = tracker.detectMutations();
                        tracker = track(state);
                        if (result.wasMutated) {
                            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "A state mutation was detected inside a dispatch, in the path: ".concat(result.path || "", ". Take a look at the reducer(s) handling the action ").concat(stringify2(action), ". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)"));
                        }
                    });
                    measureUtils.warnIfExceeded();
                    return dispatchedAction;
                };
        };
    }
}
;
function isPlain(val) {
    const type = typeof val;
    return val == null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(val);
}
function findNonSerializableValue(value) {
    let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", isSerializable = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : isPlain, getEntries = arguments.length > 3 ? arguments[3] : void 0, ignoredPaths = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], cache = arguments.length > 5 ? arguments[5] : void 0;
    let foundNestedSerializable;
    if (!isSerializable(value)) {
        return {
            keyPath: path || "<root>",
            value
        };
    }
    if (typeof value !== "object" || value === null) {
        return false;
    }
    if (cache === null || cache === void 0 ? void 0 : cache.has(value)) return false;
    const entries = getEntries != null ? getEntries(value) : Object.entries(value);
    const hasIgnoredPaths = ignoredPaths.length > 0;
    for (const [key, nestedValue] of entries){
        const nestedPath = path ? path + "." + key : key;
        if (hasIgnoredPaths) {
            const hasMatches = ignoredPaths.some((ignored)=>{
                if (ignored instanceof RegExp) {
                    return ignored.test(nestedPath);
                }
                return nestedPath === ignored;
            });
            if (hasMatches) {
                continue;
            }
        }
        if (!isSerializable(nestedValue)) {
            return {
                keyPath: nestedPath,
                value: nestedValue
            };
        }
        if (typeof nestedValue === "object") {
            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);
            if (foundNestedSerializable) {
                return foundNestedSerializable;
            }
        }
    }
    if (cache && isNestedFrozen(value)) cache.add(value);
    return false;
}
function isNestedFrozen(value) {
    if (!Object.isFrozen(value)) return false;
    for (const nestedValue of Object.values(value)){
        if (typeof nestedValue !== "object" || nestedValue === null) continue;
        if (!isNestedFrozen(nestedValue)) return false;
    }
    return true;
}
function createSerializableStateInvariantMiddleware() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        const { isSerializable = isPlain, getEntries, ignoredActions = [], ignoredActionPaths = [
            "meta.arg",
            "meta.baseQueryMeta"
        ], ignoredPaths = [], warnAfter = 32, ignoreState = false, ignoreActions = false, disableCache = false } = options;
        const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
        return (storeAPI)=>(next)=>(action)=>{
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAction"])(action)) {
                        return next(action);
                    }
                    const result = next(action);
                    const measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
                    if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {
                        measureUtils.measureTime(()=>{
                            const foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths, cache);
                            if (foundActionNonSerializableValue) {
                                const { keyPath, value } = foundActionNonSerializableValue;
                                console.error("A non-serializable value was detected in an action, in the path: `".concat(keyPath, "`. Value:"), value, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
                            }
                        });
                    }
                    if (!ignoreState) {
                        measureUtils.measureTime(()=>{
                            const state = storeAPI.getState();
                            const foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths, cache);
                            if (foundStateNonSerializableValue) {
                                const { keyPath, value } = foundStateNonSerializableValue;
                                console.error("A non-serializable value was detected in the state, in the path: `".concat(keyPath, "`. Value:"), value, "\nTake a look at the reducer(s) handling this action type: ".concat(action.type, ".\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)"));
                            }
                        });
                        measureUtils.warnIfExceeded();
                    }
                    return result;
                };
    }
}
// src/getDefaultMiddleware.ts
function isBoolean(x) {
    return typeof x === "boolean";
}
var buildGetDefaultMiddleware = ()=>function getDefaultMiddleware(options) {
        const { thunk = true, immutableCheck = true, serializableCheck = true, actionCreatorCheck = true } = options !== null && options !== void 0 ? options : {};
        let middlewareArray = new Tuple();
        if (thunk) {
            if (isBoolean(thunk)) {
                middlewareArray.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$thunk$2f$dist$2f$redux$2d$thunk$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["thunk"]);
            } else {
                middlewareArray.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$thunk$2f$dist$2f$redux$2d$thunk$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withExtraArgument"])(thunk.extraArgument));
            }
        }
        if ("TURBOPACK compile-time truthy", 1) {
            if (immutableCheck) {
                let immutableOptions = {};
                if (!isBoolean(immutableCheck)) {
                    immutableOptions = immutableCheck;
                }
                middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
            }
            if (serializableCheck) {
                let serializableOptions = {};
                if (!isBoolean(serializableCheck)) {
                    serializableOptions = serializableCheck;
                }
                middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
            }
            if (actionCreatorCheck) {
                let actionCreatorOptions = {};
                if (!isBoolean(actionCreatorCheck)) {
                    actionCreatorOptions = actionCreatorCheck;
                }
                middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));
            }
        }
        return middlewareArray;
    };
// src/autoBatchEnhancer.ts
var SHOULD_AUTOBATCH = "RTK_autoBatch";
var prepareAutoBatched = ()=>(payload)=>({
            payload,
            meta: {
                [SHOULD_AUTOBATCH]: true
            }
        });
var createQueueWithTimer = (timeout)=>{
    return (notify)=>{
        setTimeout(notify, timeout);
    };
};
var autoBatchEnhancer = function() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        type: "raf"
    };
    return (next)=>function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            const store = next(...args);
            let notifying = true;
            let shouldNotifyAtEndOfTick = false;
            let notificationQueued = false;
            const listeners = /* @__PURE__ */ new Set();
            const queueCallback = options.type === "tick" ? queueMicrotask : options.type === "raf" ? // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
            typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10) : options.type === "callback" ? options.queueNotification : createQueueWithTimer(options.timeout);
            const notifyListeners = ()=>{
                notificationQueued = false;
                if (shouldNotifyAtEndOfTick) {
                    shouldNotifyAtEndOfTick = false;
                    listeners.forEach((l)=>l());
                }
            };
            return Object.assign({}, store, {
                // Override the base `store.subscribe` method to keep original listeners
                // from running if we're delaying notifications
                subscribe (listener2) {
                    const wrappedListener = ()=>notifying && listener2();
                    const unsubscribe = store.subscribe(wrappedListener);
                    listeners.add(listener2);
                    return ()=>{
                        unsubscribe();
                        listeners.delete(listener2);
                    };
                },
                // Override the base `store.dispatch` method so that we can check actions
                // for the `shouldAutoBatch` flag and determine if batching is active
                dispatch (action) {
                    try {
                        var _action_meta;
                        notifying = !(action === null || action === void 0 ? void 0 : (_action_meta = action.meta) === null || _action_meta === void 0 ? void 0 : _action_meta[SHOULD_AUTOBATCH]);
                        shouldNotifyAtEndOfTick = !notifying;
                        if (shouldNotifyAtEndOfTick) {
                            if (!notificationQueued) {
                                notificationQueued = true;
                                queueCallback(notifyListeners);
                            }
                        }
                        return store.dispatch(action);
                    } finally{
                        notifying = true;
                    }
                }
            });
        };
};
// src/getDefaultEnhancers.ts
var buildGetDefaultEnhancers = (middlewareEnhancer)=>function getDefaultEnhancers(options) {
        const { autoBatch = true } = options !== null && options !== void 0 ? options : {};
        let enhancerArray = new Tuple(middlewareEnhancer);
        if (autoBatch) {
            enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
        }
        return enhancerArray;
    };
// src/configureStore.ts
function configureStore(options) {
    const getDefaultMiddleware = buildGetDefaultMiddleware();
    const { reducer = void 0, middleware, devTools = true, duplicateMiddlewareCheck = true, preloadedState = void 0, enhancers = void 0 } = options || {};
    let rootReducer;
    if (typeof reducer === "function") {
        rootReducer = reducer;
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(reducer)) {
        rootReducer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["combineReducers"])(reducer);
    } else {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers");
    }
    if (("TURBOPACK compile-time value", "development") !== "production" && middleware && typeof middleware !== "function") {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "`middleware` field must be a callback");
    }
    let finalMiddleware;
    if (typeof middleware === "function") {
        finalMiddleware = middleware(getDefaultMiddleware);
        if (("TURBOPACK compile-time value", "development") !== "production" && !Array.isArray(finalMiddleware)) {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "when using a middleware builder function, an array of middleware must be returned");
        }
    } else {
        finalMiddleware = getDefaultMiddleware();
    }
    if (("TURBOPACK compile-time value", "development") !== "production" && finalMiddleware.some((item)=>typeof item !== "function")) {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "each middleware provided to configureStore must be a function");
    }
    if (("TURBOPACK compile-time value", "development") !== "production" && duplicateMiddlewareCheck) {
        let middlewareReferences = /* @__PURE__ */ new Set();
        finalMiddleware.forEach((middleware2)=>{
            if (middlewareReferences.has(middleware2)) {
                throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Duplicate middleware references found when creating the store. Ensure that each middleware is only included once.");
            }
            middlewareReferences.add(middleware2);
        });
    }
    let finalCompose = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compose"];
    if (devTools) {
        finalCompose = composeWithDevTools({
            // Enable capture of stack traces for dispatched Redux actions
            trace: ("TURBOPACK compile-time value", "development") !== "production",
            ...typeof devTools === "object" && devTools
        });
    }
    const middlewareEnhancer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyMiddleware"])(...finalMiddleware);
    const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
    if (("TURBOPACK compile-time value", "development") !== "production" && enhancers && typeof enhancers !== "function") {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "`enhancers` field must be a callback");
    }
    let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
    if (("TURBOPACK compile-time value", "development") !== "production" && !Array.isArray(storeEnhancers)) {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "`enhancers` callback must return an array");
    }
    if (("TURBOPACK compile-time value", "development") !== "production" && storeEnhancers.some((item)=>typeof item !== "function")) {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "each enhancer provided to configureStore must be a function");
    }
    if (("TURBOPACK compile-time value", "development") !== "production" && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {
        console.error("middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`");
    }
    const composedEnhancer = finalCompose(...storeEnhancers);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createStore"])(rootReducer, preloadedState, composedEnhancer);
}
;
// src/mapBuilders.ts
function executeReducerBuilderCallback(builderCallback) {
    const actionsMap = {};
    const actionMatchers = [];
    let defaultCaseReducer;
    const builder = {
        addCase (typeOrActionCreator, reducer) {
            if ("TURBOPACK compile-time truthy", 1) {
                if (actionMatchers.length > 0) {
                    throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "`builder.addCase` should only be called before calling `builder.addMatcher`");
                }
                if (defaultCaseReducer) {
                    throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "`builder.addCase` should only be called before calling `builder.addDefaultCase`");
                }
            }
            const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
            if (!type) {
                throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "`builder.addCase` cannot be called with an empty action type");
            }
            if (type in actionsMap) {
                throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "`builder.addCase` cannot be called with two reducers for the same action type '".concat(type, "'"));
            }
            actionsMap[type] = reducer;
            return builder;
        },
        addMatcher (matcher, reducer) {
            if ("TURBOPACK compile-time truthy", 1) {
                if (defaultCaseReducer) {
                    throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
                }
            }
            actionMatchers.push({
                matcher,
                reducer
            });
            return builder;
        },
        addDefaultCase (reducer) {
            if ("TURBOPACK compile-time truthy", 1) {
                if (defaultCaseReducer) {
                    throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "`builder.addDefaultCase` can only be called once");
                }
            }
            defaultCaseReducer = reducer;
            return builder;
        }
    };
    builderCallback(builder);
    return [
        actionsMap,
        actionMatchers,
        defaultCaseReducer
    ];
}
// src/createReducer.ts
function isStateFunction(x) {
    return typeof x === "function";
}
function createReducer(initialState, mapOrBuilderCallback) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (typeof mapOrBuilderCallback === "object") {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
        }
    }
    let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
    let getInitialState;
    if (isStateFunction(initialState)) {
        getInitialState = ()=>freezeDraftable(initialState());
    } else {
        const frozenInitialState = freezeDraftable(initialState);
        getInitialState = ()=>frozenInitialState;
    }
    function reducer() {
        let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getInitialState(), action = arguments.length > 1 ? arguments[1] : void 0;
        let caseReducers = [
            actionsMap[action.type],
            ...finalActionMatchers.filter((param)=>{
                let { matcher } = param;
                return matcher(action);
            }).map((param)=>{
                let { reducer: reducer2 } = param;
                return reducer2;
            })
        ];
        if (caseReducers.filter((cr)=>!!cr).length === 0) {
            caseReducers = [
                finalDefaultCaseReducer
            ];
        }
        return caseReducers.reduce((previousState, caseReducer)=>{
            if (caseReducer) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDraft"])(previousState)) {
                    const draft = previousState;
                    const result = caseReducer(draft, action);
                    if (result === void 0) {
                        return previousState;
                    }
                    return result;
                } else if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDraftable"])(previousState)) {
                    const result = caseReducer(previousState, action);
                    if (result === void 0) {
                        if (previousState === null) {
                            return previousState;
                        }
                        throw Error("A case reducer on a non-draftable value must not return undefined");
                    }
                    return result;
                } else {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["produce"])(previousState, (draft)=>{
                        return caseReducer(draft, action);
                    });
                }
            }
            return previousState;
        }, state);
    }
    reducer.getInitialState = getInitialState;
    return reducer;
}
// src/matchers.ts
var matches = (matcher, action)=>{
    if (hasMatchFunction(matcher)) {
        return matcher.match(action);
    } else {
        return matcher(action);
    }
};
function isAnyOf() {
    for(var _len = arguments.length, matchers = new Array(_len), _key = 0; _key < _len; _key++){
        matchers[_key] = arguments[_key];
    }
    return (action)=>{
        return matchers.some((matcher)=>matches(matcher, action));
    };
}
function isAllOf() {
    for(var _len = arguments.length, matchers = new Array(_len), _key = 0; _key < _len; _key++){
        matchers[_key] = arguments[_key];
    }
    return (action)=>{
        return matchers.every((matcher)=>matches(matcher, action));
    };
}
function hasExpectedRequestMetadata(action, validStatus) {
    if (!action || !action.meta) return false;
    const hasValidRequestId = typeof action.meta.requestId === "string";
    const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;
    return hasValidRequestId && hasValidRequestStatus;
}
function isAsyncThunkArray(a) {
    return typeof a[0] === "function" && "pending" in a[0] && "fulfilled" in a[0] && "rejected" in a[0];
}
function isPending() {
    for(var _len = arguments.length, asyncThunks = new Array(_len), _key = 0; _key < _len; _key++){
        asyncThunks[_key] = arguments[_key];
    }
    if (asyncThunks.length === 0) {
        return (action)=>hasExpectedRequestMetadata(action, [
                "pending"
            ]);
    }
    if (!isAsyncThunkArray(asyncThunks)) {
        return isPending()(asyncThunks[0]);
    }
    return isAnyOf(...asyncThunks.map((asyncThunk)=>asyncThunk.pending));
}
function isRejected() {
    for(var _len = arguments.length, asyncThunks = new Array(_len), _key = 0; _key < _len; _key++){
        asyncThunks[_key] = arguments[_key];
    }
    if (asyncThunks.length === 0) {
        return (action)=>hasExpectedRequestMetadata(action, [
                "rejected"
            ]);
    }
    if (!isAsyncThunkArray(asyncThunks)) {
        return isRejected()(asyncThunks[0]);
    }
    return isAnyOf(...asyncThunks.map((asyncThunk)=>asyncThunk.rejected));
}
function isRejectedWithValue() {
    for(var _len = arguments.length, asyncThunks = new Array(_len), _key = 0; _key < _len; _key++){
        asyncThunks[_key] = arguments[_key];
    }
    const hasFlag = (action)=>{
        return action && action.meta && action.meta.rejectedWithValue;
    };
    if (asyncThunks.length === 0) {
        return isAllOf(isRejected(...asyncThunks), hasFlag);
    }
    if (!isAsyncThunkArray(asyncThunks)) {
        return isRejectedWithValue()(asyncThunks[0]);
    }
    return isAllOf(isRejected(...asyncThunks), hasFlag);
}
function isFulfilled() {
    for(var _len = arguments.length, asyncThunks = new Array(_len), _key = 0; _key < _len; _key++){
        asyncThunks[_key] = arguments[_key];
    }
    if (asyncThunks.length === 0) {
        return (action)=>hasExpectedRequestMetadata(action, [
                "fulfilled"
            ]);
    }
    if (!isAsyncThunkArray(asyncThunks)) {
        return isFulfilled()(asyncThunks[0]);
    }
    return isAnyOf(...asyncThunks.map((asyncThunk)=>asyncThunk.fulfilled));
}
function isAsyncThunkAction() {
    for(var _len = arguments.length, asyncThunks = new Array(_len), _key = 0; _key < _len; _key++){
        asyncThunks[_key] = arguments[_key];
    }
    if (asyncThunks.length === 0) {
        return (action)=>hasExpectedRequestMetadata(action, [
                "pending",
                "fulfilled",
                "rejected"
            ]);
    }
    if (!isAsyncThunkArray(asyncThunks)) {
        return isAsyncThunkAction()(asyncThunks[0]);
    }
    return isAnyOf(...asyncThunks.flatMap((asyncThunk)=>[
            asyncThunk.pending,
            asyncThunk.rejected,
            asyncThunk.fulfilled
        ]));
}
// src/nanoid.ts
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid = function() {
    let size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 21;
    let id = "";
    let i = size;
    while(i--){
        id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
};
// src/createAsyncThunk.ts
var commonProperties = [
    "name",
    "message",
    "stack",
    "code"
];
var RejectWithValue = class {
    constructor(payload, meta){
        /*
  type-only property to distinguish between RejectWithValue and FulfillWithMeta
  does not exist at runtime
  */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_type", void 0);
        this.payload = payload;
        this.meta = meta;
    }
};
var FulfillWithMeta = class {
    constructor(payload, meta){
        /*
  type-only property to distinguish between RejectWithValue and FulfillWithMeta
  does not exist at runtime
  */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_type", void 0);
        this.payload = payload;
        this.meta = meta;
    }
};
var miniSerializeError = (value)=>{
    if (typeof value === "object" && value !== null) {
        const simpleError = {};
        for (const property of commonProperties){
            if (typeof value[property] === "string") {
                simpleError[property] = value[property];
            }
        }
        return simpleError;
    }
    return {
        message: String(value)
    };
};
var externalAbortMessage = "External signal was aborted";
var createAsyncThunk = /* @__PURE__ */ (()=>{
    function createAsyncThunk2(typePrefix, payloadCreator, options) {
        const fulfilled = createAction(typePrefix + "/fulfilled", (payload, requestId, arg, meta)=>({
                payload,
                meta: {
                    ...meta || {},
                    arg,
                    requestId,
                    requestStatus: "fulfilled"
                }
            }));
        const pending = createAction(typePrefix + "/pending", (requestId, arg, meta)=>({
                payload: void 0,
                meta: {
                    ...meta || {},
                    arg,
                    requestId,
                    requestStatus: "pending"
                }
            }));
        const rejected = createAction(typePrefix + "/rejected", (error, requestId, arg, payload, meta)=>({
                payload,
                error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
                meta: {
                    ...meta || {},
                    arg,
                    requestId,
                    rejectedWithValue: !!payload,
                    requestStatus: "rejected",
                    aborted: (error === null || error === void 0 ? void 0 : error.name) === "AbortError",
                    condition: (error === null || error === void 0 ? void 0 : error.name) === "ConditionError"
                }
            }));
        function actionCreator(arg) {
            let { signal } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return (dispatch, getState, extra)=>{
                const requestId = (options === null || options === void 0 ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();
                const abortController = new AbortController();
                let abortHandler;
                let abortReason;
                function abort(reason) {
                    abortReason = reason;
                    abortController.abort();
                }
                if (signal) {
                    if (signal.aborted) {
                        abort(externalAbortMessage);
                    } else {
                        signal.addEventListener("abort", ()=>abort(externalAbortMessage), {
                            once: true
                        });
                    }
                }
                const promise = async function() {
                    let finalAction;
                    try {
                        var _options_condition, _options_getPendingMeta;
                        let conditionResult = options === null || options === void 0 ? void 0 : (_options_condition = options.condition) === null || _options_condition === void 0 ? void 0 : _options_condition.call(options, arg, {
                            getState,
                            extra
                        });
                        if (isThenable(conditionResult)) {
                            conditionResult = await conditionResult;
                        }
                        if (conditionResult === false || abortController.signal.aborted) {
                            throw {
                                name: "ConditionError",
                                message: "Aborted due to condition callback returning false."
                            };
                        }
                        const abortedPromise = new Promise((_, reject)=>{
                            abortHandler = ()=>{
                                reject({
                                    name: "AbortError",
                                    message: abortReason || "Aborted"
                                });
                            };
                            abortController.signal.addEventListener("abort", abortHandler);
                        });
                        dispatch(pending(requestId, arg, options === null || options === void 0 ? void 0 : (_options_getPendingMeta = options.getPendingMeta) === null || _options_getPendingMeta === void 0 ? void 0 : _options_getPendingMeta.call(options, {
                            requestId,
                            arg
                        }, {
                            getState,
                            extra
                        })));
                        finalAction = await Promise.race([
                            abortedPromise,
                            Promise.resolve(payloadCreator(arg, {
                                dispatch,
                                getState,
                                extra,
                                requestId,
                                signal: abortController.signal,
                                abort,
                                rejectWithValue: (value, meta)=>{
                                    return new RejectWithValue(value, meta);
                                },
                                fulfillWithValue: (value, meta)=>{
                                    return new FulfillWithMeta(value, meta);
                                }
                            })).then((result)=>{
                                if (result instanceof RejectWithValue) {
                                    throw result;
                                }
                                if (result instanceof FulfillWithMeta) {
                                    return fulfilled(result.payload, requestId, arg, result.meta);
                                }
                                return fulfilled(result, requestId, arg);
                            })
                        ]);
                    } catch (err) {
                        finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);
                    } finally{
                        if (abortHandler) {
                            abortController.signal.removeEventListener("abort", abortHandler);
                        }
                    }
                    const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
                    if (!skipDispatch) {
                        dispatch(finalAction);
                    }
                    return finalAction;
                }();
                return Object.assign(promise, {
                    abort,
                    requestId,
                    arg,
                    unwrap () {
                        return promise.then(unwrapResult);
                    }
                });
            };
        }
        return Object.assign(actionCreator, {
            pending,
            rejected,
            fulfilled,
            settled: isAnyOf(rejected, fulfilled),
            typePrefix
        });
    }
    createAsyncThunk2.withTypes = ()=>createAsyncThunk2;
    return createAsyncThunk2;
})();
function unwrapResult(action) {
    if (action.meta && action.meta.rejectedWithValue) {
        throw action.payload;
    }
    if (action.error) {
        throw action.error;
    }
    return action.payload;
}
function isThenable(value) {
    return value !== null && typeof value === "object" && typeof value.then === "function";
}
// src/createSlice.ts
var asyncThunkSymbol = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
var asyncThunkCreator = {
    [asyncThunkSymbol]: createAsyncThunk
};
var ReducerType = /* @__PURE__ */ ((ReducerType2)=>{
    ReducerType2["reducer"] = "reducer";
    ReducerType2["reducerWithPrepare"] = "reducerWithPrepare";
    ReducerType2["asyncThunk"] = "asyncThunk";
    return ReducerType2;
})(ReducerType || {});
function getType(slice, actionKey) {
    return "".concat(slice, "/").concat(actionKey);
}
function buildCreateSlice() {
    let { creators } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var _creators_asyncThunk;
    const cAT = creators === null || creators === void 0 ? void 0 : (_creators_asyncThunk = creators.asyncThunk) === null || _creators_asyncThunk === void 0 ? void 0 : _creators_asyncThunk[asyncThunkSymbol];
    return function createSlice2(options) {
        const { name, reducerPath = name } = options;
        if (!name) {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "`name` is a required option for createSlice");
        }
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && ("TURBOPACK compile-time value", "development") === "development") {
            if (options.initialState === void 0) {
                console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
            }
        }
        const reducers = (typeof options.reducers === "function" ? options.reducers(buildReducerCreators()) : options.reducers) || {};
        const reducerNames = Object.keys(reducers);
        const context = {
            sliceCaseReducersByName: {},
            sliceCaseReducersByType: {},
            actionCreators: {},
            sliceMatchers: []
        };
        const contextMethods = {
            addCase (typeOrActionCreator, reducer2) {
                const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
                if (!type) {
                    throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "`context.addCase` cannot be called with an empty action type");
                }
                if (type in context.sliceCaseReducersByType) {
                    throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "`context.addCase` cannot be called with two reducers for the same action type: " + type);
                }
                context.sliceCaseReducersByType[type] = reducer2;
                return contextMethods;
            },
            addMatcher (matcher, reducer2) {
                context.sliceMatchers.push({
                    matcher,
                    reducer: reducer2
                });
                return contextMethods;
            },
            exposeAction (name2, actionCreator) {
                context.actionCreators[name2] = actionCreator;
                return contextMethods;
            },
            exposeCaseReducer (name2, reducer2) {
                context.sliceCaseReducersByName[name2] = reducer2;
                return contextMethods;
            }
        };
        reducerNames.forEach((reducerName)=>{
            const reducerDefinition = reducers[reducerName];
            const reducerDetails = {
                reducerName,
                type: getType(name, reducerName),
                createNotation: typeof options.reducers === "function"
            };
            if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
                handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
            } else {
                handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
            }
        });
        function buildReducer() {
            if ("TURBOPACK compile-time truthy", 1) {
                if (typeof options.extraReducers === "object") {
                    throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
                }
            }
            const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [
                options.extraReducers
            ];
            const finalCaseReducers = {
                ...extraReducers,
                ...context.sliceCaseReducersByType
            };
            return createReducer(options.initialState, (builder)=>{
                for(let key in finalCaseReducers){
                    builder.addCase(key, finalCaseReducers[key]);
                }
                for (let sM of context.sliceMatchers){
                    builder.addMatcher(sM.matcher, sM.reducer);
                }
                for (let m of actionMatchers){
                    builder.addMatcher(m.matcher, m.reducer);
                }
                if (defaultCaseReducer) {
                    builder.addDefaultCase(defaultCaseReducer);
                }
            });
        }
        const selectSelf = (state)=>state;
        const injectedSelectorCache = /* @__PURE__ */ new Map();
        const injectedStateCache = /* @__PURE__ */ new WeakMap();
        let _reducer;
        function reducer(state, action) {
            if (!_reducer) _reducer = buildReducer();
            return _reducer(state, action);
        }
        function getInitialState() {
            if (!_reducer) _reducer = buildReducer();
            return _reducer.getInitialState();
        }
        function makeSelectorProps(reducerPath2) {
            let injected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            function selectSlice(state) {
                let sliceState = state[reducerPath2];
                if (typeof sliceState === "undefined") {
                    if (injected) {
                        sliceState = getOrInsertComputed(injectedStateCache, selectSlice, getInitialState);
                    } else if ("TURBOPACK compile-time truthy", 1) {
                        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "selectSlice returned undefined for an uninjected slice reducer");
                    }
                }
                return sliceState;
            }
            function getSelectors() {
                let selectState = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : selectSelf;
                const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, ()=>/* @__PURE__ */ new WeakMap());
                return getOrInsertComputed(selectorCache, selectState, ()=>{
                    const map = {};
                    var _options_selectors;
                    for (const [name2, selector] of Object.entries((_options_selectors = options.selectors) !== null && _options_selectors !== void 0 ? _options_selectors : {})){
                        map[name2] = wrapSelector(selector, selectState, ()=>getOrInsertComputed(injectedStateCache, selectState, getInitialState), injected);
                    }
                    return map;
                });
            }
            return {
                reducerPath: reducerPath2,
                getSelectors,
                get selectors () {
                    return getSelectors(selectSlice);
                },
                selectSlice
            };
        }
        const slice = {
            name,
            reducer,
            actions: context.actionCreators,
            caseReducers: context.sliceCaseReducersByName,
            getInitialState,
            ...makeSelectorProps(reducerPath),
            injectInto (injectable) {
                let { reducerPath: pathOpt, ...config } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                const newReducerPath = pathOpt !== null && pathOpt !== void 0 ? pathOpt : reducerPath;
                injectable.inject({
                    reducerPath: newReducerPath,
                    reducer
                }, config);
                return {
                    ...slice,
                    ...makeSelectorProps(newReducerPath, true)
                };
            }
        };
        return slice;
    };
}
function wrapSelector(selector, selectState, getInitialState, injected) {
    function wrapper(rootState) {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            args[_key - 1] = arguments[_key];
        }
        let sliceState = selectState(rootState);
        if (typeof sliceState === "undefined") {
            if (injected) {
                sliceState = getInitialState();
            } else if ("TURBOPACK compile-time truthy", 1) {
                throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "selectState returned undefined for an uninjected slice reducer");
            }
        }
        return selector(sliceState, ...args);
    }
    wrapper.unwrapped = selector;
    return wrapper;
}
var createSlice = /* @__PURE__ */ buildCreateSlice();
function buildReducerCreators() {
    function asyncThunk(payloadCreator, config) {
        return {
            _reducerDefinitionType: "asyncThunk" /* asyncThunk */ ,
            payloadCreator,
            ...config
        };
    }
    asyncThunk.withTypes = ()=>asyncThunk;
    return {
        reducer (caseReducer) {
            return Object.assign({
                // hack so the wrapping function has the same name as the original
                // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
                [caseReducer.name] () {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    return caseReducer(...args);
                }
            }[caseReducer.name], {
                _reducerDefinitionType: "reducer" /* reducer */ 
            });
        },
        preparedReducer (prepare, reducer) {
            return {
                _reducerDefinitionType: "reducerWithPrepare" /* reducerWithPrepare */ ,
                prepare,
                reducer
            };
        },
        asyncThunk
    };
}
function handleNormalReducerDefinition(param, maybeReducerWithPrepare, context) {
    let { type, reducerName, createNotation } = param;
    let caseReducer;
    let prepareCallback;
    if ("reducer" in maybeReducerWithPrepare) {
        if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.");
        }
        caseReducer = maybeReducerWithPrepare.reducer;
        prepareCallback = maybeReducerWithPrepare.prepare;
    } else {
        caseReducer = maybeReducerWithPrepare;
    }
    context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
}
function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
    return reducerDefinition._reducerDefinitionType === "asyncThunk" /* asyncThunk */ ;
}
function isCaseReducerWithPrepareDefinition(reducerDefinition) {
    return reducerDefinition._reducerDefinitionType === "reducerWithPrepare" /* reducerWithPrepare */ ;
}
function handleThunkCaseReducerDefinition(param, reducerDefinition, context, cAT) {
    let { type, reducerName } = param;
    if (!cAT) {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.");
    }
    const { payloadCreator, fulfilled, pending, rejected, settled, options } = reducerDefinition;
    const thunk = cAT(type, payloadCreator, options);
    context.exposeAction(reducerName, thunk);
    if (fulfilled) {
        context.addCase(thunk.fulfilled, fulfilled);
    }
    if (pending) {
        context.addCase(thunk.pending, pending);
    }
    if (rejected) {
        context.addCase(thunk.rejected, rejected);
    }
    if (settled) {
        context.addMatcher(thunk.settled, settled);
    }
    context.exposeCaseReducer(reducerName, {
        fulfilled: fulfilled || noop,
        pending: pending || noop,
        rejected: rejected || noop,
        settled: settled || noop
    });
}
function noop() {}
// src/entities/entity_state.ts
function getInitialEntityState() {
    return {
        ids: [],
        entities: {}
    };
}
function createInitialStateFactory(stateAdapter) {
    function getInitialState() {
        let additionalState = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, entities = arguments.length > 1 ? arguments[1] : void 0;
        const state = Object.assign(getInitialEntityState(), additionalState);
        return entities ? stateAdapter.setAll(state, entities) : state;
    }
    return {
        getInitialState
    };
}
// src/entities/state_selectors.ts
function createSelectorsFactory() {
    function getSelectors(selectState) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const { createSelector: createSelector2 = createDraftSafeSelector } = options;
        const selectIds = (state)=>state.ids;
        const selectEntities = (state)=>state.entities;
        const selectAll = createSelector2(selectIds, selectEntities, (ids, entities)=>ids.map((id)=>entities[id]));
        const selectId = (_, id)=>id;
        const selectById = (entities, id)=>entities[id];
        const selectTotal = createSelector2(selectIds, (ids)=>ids.length);
        if (!selectState) {
            return {
                selectIds,
                selectEntities,
                selectAll,
                selectTotal,
                selectById: createSelector2(selectEntities, selectId, selectById)
            };
        }
        const selectGlobalizedEntities = createSelector2(selectState, selectEntities);
        return {
            selectIds: createSelector2(selectState, selectIds),
            selectEntities: selectGlobalizedEntities,
            selectAll: createSelector2(selectState, selectAll),
            selectTotal: createSelector2(selectState, selectTotal),
            selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)
        };
    }
    return {
        getSelectors
    };
}
;
var isDraftTyped = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDraft"];
function createSingleArgumentStateOperator(mutator) {
    const operator = createStateOperator((_, state)=>mutator(state));
    return function operation(state) {
        return operator(state, void 0);
    };
}
function createStateOperator(mutator) {
    return function operation(state, arg) {
        function isPayloadActionArgument(arg2) {
            return isFSA(arg2);
        }
        const runMutator = (draft)=>{
            if (isPayloadActionArgument(arg)) {
                mutator(arg.payload, draft);
            } else {
                mutator(arg, draft);
            }
        };
        if (isDraftTyped(state)) {
            runMutator(state);
            return state;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["produce"])(state, runMutator);
    };
}
;
function selectIdValue(entity, selectId) {
    const key = selectId(entity);
    if (("TURBOPACK compile-time value", "development") !== "production" && key === void 0) {
        console.warn("The entity passed to the `selectId` implementation returned undefined.", "You should probably provide your own `selectId` implementation.", "The entity that was passed:", entity, "The `selectId` implementation:", selectId.toString());
    }
    return key;
}
function ensureEntitiesArray(entities) {
    if (!Array.isArray(entities)) {
        entities = Object.values(entities);
    }
    return entities;
}
function getCurrent(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDraft"])(value) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["current"])(value) : value;
}
function splitAddedUpdatedEntities(newEntities, selectId, state) {
    newEntities = ensureEntitiesArray(newEntities);
    const existingIdsArray = getCurrent(state.ids);
    const existingIds = new Set(existingIdsArray);
    const added = [];
    const addedIds = /* @__PURE__ */ new Set([]);
    const updated = [];
    for (const entity of newEntities){
        const id = selectIdValue(entity, selectId);
        if (existingIds.has(id) || addedIds.has(id)) {
            updated.push({
                id,
                changes: entity
            });
        } else {
            addedIds.add(id);
            added.push(entity);
        }
    }
    return [
        added,
        updated,
        existingIdsArray
    ];
}
// src/entities/unsorted_state_adapter.ts
function createUnsortedStateAdapter(selectId) {
    function addOneMutably(entity, state) {
        const key = selectIdValue(entity, selectId);
        if (key in state.entities) {
            return;
        }
        state.ids.push(key);
        state.entities[key] = entity;
    }
    function addManyMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        for (const entity of newEntities){
            addOneMutably(entity, state);
        }
    }
    function setOneMutably(entity, state) {
        const key = selectIdValue(entity, selectId);
        if (!(key in state.entities)) {
            state.ids.push(key);
        }
        ;
        state.entities[key] = entity;
    }
    function setManyMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        for (const entity of newEntities){
            setOneMutably(entity, state);
        }
    }
    function setAllMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        state.ids = [];
        state.entities = {};
        addManyMutably(newEntities, state);
    }
    function removeOneMutably(key, state) {
        return removeManyMutably([
            key
        ], state);
    }
    function removeManyMutably(keys, state) {
        let didMutate = false;
        keys.forEach((key)=>{
            if (key in state.entities) {
                delete state.entities[key];
                didMutate = true;
            }
        });
        if (didMutate) {
            state.ids = state.ids.filter((id)=>id in state.entities);
        }
    }
    function removeAllMutably(state) {
        Object.assign(state, {
            ids: [],
            entities: {}
        });
    }
    function takeNewKey(keys, update, state) {
        const original3 = state.entities[update.id];
        if (original3 === void 0) {
            return false;
        }
        const updated = Object.assign({}, original3, update.changes);
        const newKey = selectIdValue(updated, selectId);
        const hasNewKey = newKey !== update.id;
        if (hasNewKey) {
            keys[update.id] = newKey;
            delete state.entities[update.id];
        }
        ;
        state.entities[newKey] = updated;
        return hasNewKey;
    }
    function updateOneMutably(update, state) {
        return updateManyMutably([
            update
        ], state);
    }
    function updateManyMutably(updates, state) {
        const newKeys = {};
        const updatesPerEntity = {};
        updates.forEach((update)=>{
            if (update.id in state.entities) {
                var _updatesPerEntity_update_id;
                updatesPerEntity[update.id] = {
                    id: update.id,
                    // Spreads ignore falsy values, so this works even if there isn't
                    // an existing update already at this key
                    changes: {
                        ...(_updatesPerEntity_update_id = updatesPerEntity[update.id]) === null || _updatesPerEntity_update_id === void 0 ? void 0 : _updatesPerEntity_update_id.changes,
                        ...update.changes
                    }
                };
            }
        });
        updates = Object.values(updatesPerEntity);
        const didMutateEntities = updates.length > 0;
        if (didMutateEntities) {
            const didMutateIds = updates.filter((update)=>takeNewKey(newKeys, update, state)).length > 0;
            if (didMutateIds) {
                state.ids = Object.values(state.entities).map((e)=>selectIdValue(e, selectId));
            }
        }
    }
    function upsertOneMutably(entity, state) {
        return upsertManyMutably([
            entity
        ], state);
    }
    function upsertManyMutably(newEntities, state) {
        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);
        addManyMutably(added, state);
        updateManyMutably(updated, state);
    }
    return {
        removeAll: createSingleArgumentStateOperator(removeAllMutably),
        addOne: createStateOperator(addOneMutably),
        addMany: createStateOperator(addManyMutably),
        setOne: createStateOperator(setOneMutably),
        setMany: createStateOperator(setManyMutably),
        setAll: createStateOperator(setAllMutably),
        updateOne: createStateOperator(updateOneMutably),
        updateMany: createStateOperator(updateManyMutably),
        upsertOne: createStateOperator(upsertOneMutably),
        upsertMany: createStateOperator(upsertManyMutably),
        removeOne: createStateOperator(removeOneMutably),
        removeMany: createStateOperator(removeManyMutably)
    };
}
// src/entities/sorted_state_adapter.ts
function findInsertIndex(sortedItems, item, comparisonFunction) {
    let lowIndex = 0;
    let highIndex = sortedItems.length;
    while(lowIndex < highIndex){
        let middleIndex = lowIndex + highIndex >>> 1;
        const currentItem = sortedItems[middleIndex];
        const res = comparisonFunction(item, currentItem);
        if (res >= 0) {
            lowIndex = middleIndex + 1;
        } else {
            highIndex = middleIndex;
        }
    }
    return lowIndex;
}
function insert(sortedItems, item, comparisonFunction) {
    const insertAtIndex = findInsertIndex(sortedItems, item, comparisonFunction);
    sortedItems.splice(insertAtIndex, 0, item);
    return sortedItems;
}
function createSortedStateAdapter(selectId, comparer) {
    const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(selectId);
    function addOneMutably(entity, state) {
        return addManyMutably([
            entity
        ], state);
    }
    function addManyMutably(newEntities, state, existingIds) {
        newEntities = ensureEntitiesArray(newEntities);
        const existingKeys = new Set(existingIds !== null && existingIds !== void 0 ? existingIds : getCurrent(state.ids));
        const models = newEntities.filter((model)=>!existingKeys.has(selectIdValue(model, selectId)));
        if (models.length !== 0) {
            mergeFunction(state, models);
        }
    }
    function setOneMutably(entity, state) {
        return setManyMutably([
            entity
        ], state);
    }
    function setManyMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        if (newEntities.length !== 0) {
            for (const item of newEntities){
                delete state.entities[selectId(item)];
            }
            mergeFunction(state, newEntities);
        }
    }
    function setAllMutably(newEntities, state) {
        newEntities = ensureEntitiesArray(newEntities);
        state.entities = {};
        state.ids = [];
        addManyMutably(newEntities, state, []);
    }
    function updateOneMutably(update, state) {
        return updateManyMutably([
            update
        ], state);
    }
    function updateManyMutably(updates, state) {
        let appliedUpdates = false;
        let replacedIds = false;
        for (let update of updates){
            const entity = state.entities[update.id];
            if (!entity) {
                continue;
            }
            appliedUpdates = true;
            Object.assign(entity, update.changes);
            const newId = selectId(entity);
            if (update.id !== newId) {
                replacedIds = true;
                delete state.entities[update.id];
                const oldIndex = state.ids.indexOf(update.id);
                state.ids[oldIndex] = newId;
                state.entities[newId] = entity;
            }
        }
        if (appliedUpdates) {
            mergeFunction(state, [], appliedUpdates, replacedIds);
        }
    }
    function upsertOneMutably(entity, state) {
        return upsertManyMutably([
            entity
        ], state);
    }
    function upsertManyMutably(newEntities, state) {
        const [added, updated, existingIdsArray] = splitAddedUpdatedEntities(newEntities, selectId, state);
        if (added.length) {
            addManyMutably(added, state, existingIdsArray);
        }
        if (updated.length) {
            updateManyMutably(updated, state);
        }
    }
    function areArraysEqual(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for(let i = 0; i < a.length; i++){
            if (a[i] === b[i]) {
                continue;
            }
            return false;
        }
        return true;
    }
    const mergeFunction = (state, addedItems, appliedUpdates, replacedIds)=>{
        const currentEntities = getCurrent(state.entities);
        const currentIds = getCurrent(state.ids);
        const stateEntities = state.entities;
        let ids = currentIds;
        if (replacedIds) {
            ids = new Set(currentIds);
        }
        let sortedEntities = [];
        for (const id of ids){
            const entity = currentEntities[id];
            if (entity) {
                sortedEntities.push(entity);
            }
        }
        const wasPreviouslyEmpty = sortedEntities.length === 0;
        for (const item of addedItems){
            stateEntities[selectId(item)] = item;
            if (!wasPreviouslyEmpty) {
                insert(sortedEntities, item, comparer);
            }
        }
        if (wasPreviouslyEmpty) {
            sortedEntities = addedItems.slice().sort(comparer);
        } else if (appliedUpdates) {
            sortedEntities.sort(comparer);
        }
        const newSortedIds = sortedEntities.map(selectId);
        if (!areArraysEqual(currentIds, newSortedIds)) {
            state.ids = newSortedIds;
        }
    };
    return {
        removeOne,
        removeMany,
        removeAll,
        addOne: createStateOperator(addOneMutably),
        updateOne: createStateOperator(updateOneMutably),
        upsertOne: createStateOperator(upsertOneMutably),
        setOne: createStateOperator(setOneMutably),
        setMany: createStateOperator(setManyMutably),
        setAll: createStateOperator(setAllMutably),
        addMany: createStateOperator(addManyMutably),
        updateMany: createStateOperator(updateManyMutably),
        upsertMany: createStateOperator(upsertManyMutably)
    };
}
// src/entities/create_adapter.ts
function createEntityAdapter() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { selectId, sortComparer } = {
        sortComparer: false,
        selectId: (instance)=>instance.id,
        ...options
    };
    const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);
    const stateFactory = createInitialStateFactory(stateAdapter);
    const selectorsFactory = createSelectorsFactory();
    return {
        selectId,
        sortComparer,
        ...stateFactory,
        ...selectorsFactory,
        ...stateAdapter
    };
}
;
// src/listenerMiddleware/exceptions.ts
var task = "task";
var listener = "listener";
var completed = "completed";
var cancelled = "cancelled";
var taskCancelled = "task-".concat(cancelled);
var taskCompleted = "task-".concat(completed);
var listenerCancelled = "".concat(listener, "-").concat(cancelled);
var listenerCompleted = "".concat(listener, "-").concat(completed);
var TaskAbortError = class {
    constructor(code){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "name", "TaskAbortError");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "message", void 0);
        this.code = code;
        this.message = "".concat(task, " ").concat(cancelled, " (reason: ").concat(code, ")");
    }
};
// src/listenerMiddleware/utils.ts
var assertFunction = (func, expected)=>{
    if (typeof func !== "function") {
        throw new TypeError(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "".concat(expected, " is not a function"));
    }
};
var noop2 = ()=>{};
var catchRejection = function(promise) {
    let onError = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
    promise.catch(onError);
    return promise;
};
var addAbortSignalListener = (abortSignal, callback)=>{
    abortSignal.addEventListener("abort", callback, {
        once: true
    });
    return ()=>abortSignal.removeEventListener("abort", callback);
};
var abortControllerWithReason = (abortController, reason)=>{
    const signal = abortController.signal;
    if (signal.aborted) {
        return;
    }
    if (!("reason" in signal)) {
        Object.defineProperty(signal, "reason", {
            enumerable: true,
            value: reason,
            configurable: true,
            writable: true
        });
    }
    ;
    abortController.abort(reason);
};
// src/listenerMiddleware/task.ts
var validateActive = (signal)=>{
    if (signal.aborted) {
        const { reason } = signal;
        throw new TaskAbortError(reason);
    }
};
function raceWithSignal(signal, promise) {
    let cleanup = noop2;
    return new Promise((resolve, reject)=>{
        const notifyRejection = ()=>reject(new TaskAbortError(signal.reason));
        if (signal.aborted) {
            notifyRejection();
            return;
        }
        cleanup = addAbortSignalListener(signal, notifyRejection);
        promise.finally(()=>cleanup()).then(resolve, reject);
    }).finally(()=>{
        cleanup = noop2;
    });
}
var runTask = async (task2, cleanUp)=>{
    try {
        await Promise.resolve();
        const value = await task2();
        return {
            status: "ok",
            value
        };
    } catch (error) {
        return {
            status: error instanceof TaskAbortError ? "cancelled" : "rejected",
            error
        };
    } finally{
        cleanUp === null || cleanUp === void 0 ? void 0 : cleanUp();
    }
};
var createPause = (signal)=>{
    return (promise)=>{
        return catchRejection(raceWithSignal(signal, promise).then((output)=>{
            validateActive(signal);
            return output;
        }));
    };
};
var createDelay = (signal)=>{
    const pause = createPause(signal);
    return (timeoutMs)=>{
        return pause(new Promise((resolve)=>setTimeout(resolve, timeoutMs)));
    };
};
// src/listenerMiddleware/index.ts
var { assign } = Object;
var INTERNAL_NIL_TOKEN = {};
var alm = "listenerMiddleware";
var createFork = (parentAbortSignal, parentBlockingPromises)=>{
    const linkControllers = (controller)=>addAbortSignalListener(parentAbortSignal, ()=>abortControllerWithReason(controller, parentAbortSignal.reason));
    return (taskExecutor, opts)=>{
        assertFunction(taskExecutor, "taskExecutor");
        const childAbortController = new AbortController();
        linkControllers(childAbortController);
        const result = runTask(async ()=>{
            validateActive(parentAbortSignal);
            validateActive(childAbortController.signal);
            const result2 = await taskExecutor({
                pause: createPause(childAbortController.signal),
                delay: createDelay(childAbortController.signal),
                signal: childAbortController.signal
            });
            validateActive(childAbortController.signal);
            return result2;
        }, ()=>abortControllerWithReason(childAbortController, taskCompleted));
        if (opts === null || opts === void 0 ? void 0 : opts.autoJoin) {
            parentBlockingPromises.push(result.catch(noop2));
        }
        return {
            result: createPause(parentAbortSignal)(result),
            cancel () {
                abortControllerWithReason(childAbortController, taskCancelled);
            }
        };
    };
};
var createTakePattern = (startListening, signal)=>{
    const take = async (predicate, timeout)=>{
        validateActive(signal);
        let unsubscribe = ()=>{};
        const tuplePromise = new Promise((resolve, reject)=>{
            let stopListening = startListening({
                predicate,
                effect: (action, listenerApi)=>{
                    listenerApi.unsubscribe();
                    resolve([
                        action,
                        listenerApi.getState(),
                        listenerApi.getOriginalState()
                    ]);
                }
            });
            unsubscribe = ()=>{
                stopListening();
                reject();
            };
        });
        const promises = [
            tuplePromise
        ];
        if (timeout != null) {
            promises.push(new Promise((resolve)=>setTimeout(resolve, timeout, null)));
        }
        try {
            const output = await raceWithSignal(signal, Promise.race(promises));
            validateActive(signal);
            return output;
        } finally{
            unsubscribe();
        }
    };
    return (predicate, timeout)=>catchRejection(take(predicate, timeout));
};
var getListenerEntryPropsFrom = (options)=>{
    let { type, actionCreator, matcher, predicate, effect } = options;
    if (type) {
        predicate = createAction(type).match;
    } else if (actionCreator) {
        type = actionCreator.type;
        predicate = actionCreator.match;
    } else if (matcher) {
        predicate = matcher;
    } else if (predicate) {} else {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Creating or removing a listener requires one of the known fields for matching an action");
    }
    assertFunction(effect, "options.listener");
    return {
        predicate,
        type,
        effect
    };
};
var createListenerEntry = /* @__PURE__ */ assign((options)=>{
    const { type, predicate, effect } = getListenerEntryPropsFrom(options);
    const entry = {
        id: nanoid(),
        effect,
        type,
        predicate,
        pending: /* @__PURE__ */ new Set(),
        unsubscribe: ()=>{
            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Unsubscribe not initialized");
        }
    };
    return entry;
}, {
    withTypes: ()=>createListenerEntry
});
var findListenerEntry = (listenerMap, options)=>{
    const { type, effect, predicate } = getListenerEntryPropsFrom(options);
    return Array.from(listenerMap.values()).find((entry)=>{
        const matchPredicateOrType = typeof type === "string" ? entry.type === type : entry.predicate === predicate;
        return matchPredicateOrType && entry.effect === effect;
    });
};
var cancelActiveListeners = (entry)=>{
    entry.pending.forEach((controller)=>{
        abortControllerWithReason(controller, listenerCancelled);
    });
};
var createClearListenerMiddleware = (listenerMap)=>{
    return ()=>{
        listenerMap.forEach(cancelActiveListeners);
        listenerMap.clear();
    };
};
var safelyNotifyError = (errorHandler, errorToNotify, errorInfo)=>{
    try {
        errorHandler(errorToNotify, errorInfo);
    } catch (errorHandlerError) {
        setTimeout(()=>{
            throw errorHandlerError;
        }, 0);
    }
};
var addListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction("".concat(alm, "/add")), {
    withTypes: ()=>addListener
});
var clearAllListeners = /* @__PURE__ */ createAction("".concat(alm, "/removeAll"));
var removeListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction("".concat(alm, "/remove")), {
    withTypes: ()=>removeListener
});
var defaultErrorHandler = function() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    console.error("".concat(alm, "/error"), ...args);
};
var createListenerMiddleware = function() {
    let middlewareOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const listenerMap = /* @__PURE__ */ new Map();
    const { extra, onError = defaultErrorHandler } = middlewareOptions;
    assertFunction(onError, "onError");
    const insertEntry = (entry)=>{
        entry.unsubscribe = ()=>listenerMap.delete(entry.id);
        listenerMap.set(entry.id, entry);
        return (cancelOptions)=>{
            entry.unsubscribe();
            if (cancelOptions === null || cancelOptions === void 0 ? void 0 : cancelOptions.cancelActive) {
                cancelActiveListeners(entry);
            }
        };
    };
    const startListening = (options)=>{
        var _findListenerEntry;
        const entry = (_findListenerEntry = findListenerEntry(listenerMap, options)) !== null && _findListenerEntry !== void 0 ? _findListenerEntry : createListenerEntry(options);
        return insertEntry(entry);
    };
    assign(startListening, {
        withTypes: ()=>startListening
    });
    const stopListening = (options)=>{
        const entry = findListenerEntry(listenerMap, options);
        if (entry) {
            entry.unsubscribe();
            if (options.cancelActive) {
                cancelActiveListeners(entry);
            }
        }
        return !!entry;
    };
    assign(stopListening, {
        withTypes: ()=>stopListening
    });
    const notifyListener = async (entry, action, api, getOriginalState)=>{
        const internalTaskController = new AbortController();
        const take = createTakePattern(startListening, internalTaskController.signal);
        const autoJoinPromises = [];
        try {
            entry.pending.add(internalTaskController);
            await Promise.resolve(entry.effect(action, // Use assign() rather than ... to avoid extra helper functions added to bundle
            assign({}, api, {
                getOriginalState,
                condition: (predicate, timeout)=>take(predicate, timeout).then(Boolean),
                take,
                delay: createDelay(internalTaskController.signal),
                pause: createPause(internalTaskController.signal),
                extra,
                signal: internalTaskController.signal,
                fork: createFork(internalTaskController.signal, autoJoinPromises),
                unsubscribe: entry.unsubscribe,
                subscribe: ()=>{
                    listenerMap.set(entry.id, entry);
                },
                cancelActiveListeners: ()=>{
                    entry.pending.forEach((controller, _, set)=>{
                        if (controller !== internalTaskController) {
                            abortControllerWithReason(controller, listenerCancelled);
                            set.delete(controller);
                        }
                    });
                },
                cancel: ()=>{
                    abortControllerWithReason(internalTaskController, listenerCancelled);
                    entry.pending.delete(internalTaskController);
                },
                throwIfCancelled: ()=>{
                    validateActive(internalTaskController.signal);
                }
            })));
        } catch (listenerError) {
            if (!(listenerError instanceof TaskAbortError)) {
                safelyNotifyError(onError, listenerError, {
                    raisedBy: "effect"
                });
            }
        } finally{
            await Promise.all(autoJoinPromises);
            abortControllerWithReason(internalTaskController, listenerCompleted);
            entry.pending.delete(internalTaskController);
        }
    };
    const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);
    const middleware = (api)=>(next)=>(action)=>{
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAction"])(action)) {
                    return next(action);
                }
                if (addListener.match(action)) {
                    return startListening(action.payload);
                }
                if (clearAllListeners.match(action)) {
                    clearListenerMiddleware();
                    return;
                }
                if (removeListener.match(action)) {
                    return stopListening(action.payload);
                }
                let originalState = api.getState();
                const getOriginalState = ()=>{
                    if (originalState === INTERNAL_NIL_TOKEN) {
                        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "".concat(alm, ": getOriginalState can only be called synchronously"));
                    }
                    return originalState;
                };
                let result;
                try {
                    result = next(action);
                    if (listenerMap.size > 0) {
                        const currentState = api.getState();
                        const listenerEntries = Array.from(listenerMap.values());
                        for (const entry of listenerEntries){
                            let runListener = false;
                            try {
                                runListener = entry.predicate(action, currentState, originalState);
                            } catch (predicateError) {
                                runListener = false;
                                safelyNotifyError(onError, predicateError, {
                                    raisedBy: "predicate"
                                });
                            }
                            if (!runListener) {
                                continue;
                            }
                            notifyListener(entry, action, api, getOriginalState);
                        }
                    }
                } finally{
                    originalState = INTERNAL_NIL_TOKEN;
                }
                return result;
            };
    return {
        middleware,
        startListening,
        stopListening,
        clearListeners: clearListenerMiddleware
    };
};
;
var createMiddlewareEntry = (middleware)=>({
        middleware,
        applied: /* @__PURE__ */ new Map()
    });
var matchInstance = (instanceId)=>(action)=>{
        var _action_meta;
        return (action === null || action === void 0 ? void 0 : (_action_meta = action.meta) === null || _action_meta === void 0 ? void 0 : _action_meta.instanceId) === instanceId;
    };
var createDynamicMiddleware = ()=>{
    const instanceId = nanoid();
    const middlewareMap = /* @__PURE__ */ new Map();
    const withMiddleware = Object.assign(createAction("dynamicMiddleware/add", function() {
        for(var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++){
            middlewares[_key] = arguments[_key];
        }
        return {
            payload: middlewares,
            meta: {
                instanceId
            }
        };
    }), {
        withTypes: ()=>withMiddleware
    });
    const addMiddleware = Object.assign(function addMiddleware2() {
        for(var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++){
            middlewares[_key] = arguments[_key];
        }
        middlewares.forEach((middleware2)=>{
            getOrInsertComputed(middlewareMap, middleware2, createMiddlewareEntry);
        });
    }, {
        withTypes: ()=>addMiddleware
    });
    const getFinalMiddleware = (api)=>{
        const appliedMiddleware = Array.from(middlewareMap.values()).map((entry)=>getOrInsertComputed(entry.applied, api, entry.middleware));
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compose"])(...appliedMiddleware);
    };
    const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));
    const middleware = (api)=>(next)=>(action)=>{
                if (isWithMiddleware(action)) {
                    addMiddleware(...action.payload);
                    return api.dispatch;
                }
                return getFinalMiddleware(api)(next)(action);
            };
    return {
        middleware,
        addMiddleware,
        withMiddleware,
        instanceId
    };
};
;
var isSliceLike = (maybeSliceLike)=>"reducerPath" in maybeSliceLike && typeof maybeSliceLike.reducerPath === "string";
var getReducers = (slices)=>slices.flatMap((sliceOrMap)=>isSliceLike(sliceOrMap) ? [
            [
                sliceOrMap.reducerPath,
                sliceOrMap.reducer
            ]
        ] : Object.entries(sliceOrMap));
var ORIGINAL_STATE = Symbol.for("rtk-state-proxy-original");
var isStateProxy = (value)=>!!value && !!value[ORIGINAL_STATE];
var stateProxyMap = /* @__PURE__ */ new WeakMap();
var createStateProxy = (state, reducerMap, initialStateCache)=>getOrInsertComputed(stateProxyMap, state, ()=>new Proxy(state, {
            get: (target, prop, receiver)=>{
                if (prop === ORIGINAL_STATE) return target;
                const result = Reflect.get(target, prop, receiver);
                if (typeof result === "undefined") {
                    const cached = initialStateCache[prop];
                    if (typeof cached !== "undefined") return cached;
                    const reducer = reducerMap[prop];
                    if (reducer) {
                        const reducerResult = reducer(void 0, {
                            type: nanoid()
                        });
                        if (typeof reducerResult === "undefined") {
                            throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 'The slice reducer for key "'.concat(prop.toString(), "\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined."));
                        }
                        initialStateCache[prop] = reducerResult;
                        return reducerResult;
                    }
                }
                return result;
            }
        }));
var original = (state)=>{
    if (!isStateProxy(state)) {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "original must be used on state Proxy");
    }
    return state[ORIGINAL_STATE];
};
var emptyObject = {};
var noopReducer = function() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : emptyObject;
    return state;
};
function combineSlices() {
    for(var _len = arguments.length, slices = new Array(_len), _key = 0; _key < _len; _key++){
        slices[_key] = arguments[_key];
    }
    const reducerMap = Object.fromEntries(getReducers(slices));
    const getReducer = ()=>Object.keys(reducerMap).length ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["combineReducers"])(reducerMap) : noopReducer;
    let reducer = getReducer();
    function combinedReducer(state, action) {
        return reducer(state, action);
    }
    combinedReducer.withLazyLoadedSlices = ()=>combinedReducer;
    const initialStateCache = {};
    const inject = function(slice) {
        let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const { reducerPath, reducer: reducerToInject } = slice;
        const currentReducer = reducerMap[reducerPath];
        if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {
            if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && ("TURBOPACK compile-time value", "development") === "development") {
                console.error("called `inject` to override already-existing reducer ".concat(reducerPath, " without specifying `overrideExisting: true`"));
            }
            return combinedReducer;
        }
        if (config.overrideExisting && currentReducer !== reducerToInject) {
            delete initialStateCache[reducerPath];
        }
        reducerMap[reducerPath] = reducerToInject;
        reducer = getReducer();
        return combinedReducer;
    };
    const selector = Object.assign(function makeSelector(selectorFn, selectState) {
        return function selector2(state) {
            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                args[_key - 1] = arguments[_key];
            }
            return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap, initialStateCache), ...args);
        };
    }, {
        original
    });
    return Object.assign(combinedReducer, {
        inject,
        selector
    });
}
// src/formatProdErrorMessage.ts
function formatProdErrorMessage(code) {
    return "Minified Redux Toolkit error #".concat(code, "; visit https://redux-toolkit.js.org/Errors?code=").concat(code, " for the full message or use the non-minified dev environment for full errors. ");
}
;
 //# sourceMappingURL=redux-toolkit.modern.mjs.map
}),
"[project]/node_modules/redux-persist/es/constants.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "DEFAULT_VERSION": ()=>DEFAULT_VERSION,
    "FLUSH": ()=>FLUSH,
    "KEY_PREFIX": ()=>KEY_PREFIX,
    "PAUSE": ()=>PAUSE,
    "PERSIST": ()=>PERSIST,
    "PURGE": ()=>PURGE,
    "REGISTER": ()=>REGISTER,
    "REHYDRATE": ()=>REHYDRATE
});
var KEY_PREFIX = 'persist:';
var FLUSH = 'persist/FLUSH';
var REHYDRATE = 'persist/REHYDRATE';
var PAUSE = 'persist/PAUSE';
var PERSIST = 'persist/PERSIST';
var PURGE = 'persist/PURGE';
var REGISTER = 'persist/REGISTER';
var DEFAULT_VERSION = -1;
}),
"[project]/node_modules/redux-persist/es/stateReconciler/autoMergeLevel1.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>autoMergeLevel1
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys(source, true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys(source).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function autoMergeLevel1(inboundState, originalState, reducedState, _ref) {
    var debug = _ref.debug;
    var newState = _objectSpread({}, reducedState); // only rehydrate if inboundState exists and is an object
    if (inboundState && _typeof(inboundState) === 'object') {
        Object.keys(inboundState).forEach(function(key) {
            // ignore _persist data
            if (key === '_persist') return; // if reducer modifies substate, skip auto rehydration
            if (originalState[key] !== reducedState[key]) {
                if (("TURBOPACK compile-time value", "development") !== 'production' && debug) console.log('redux-persist/stateReconciler: sub state for key `%s` modified, skipping.', key);
                return;
            } // otherwise hard set the new value
            newState[key] = inboundState[key];
        });
    }
    if (("TURBOPACK compile-time value", "development") !== 'production' && debug && inboundState && _typeof(inboundState) === 'object') console.log("redux-persist/stateReconciler: rehydrated keys '".concat(Object.keys(inboundState).join(', '), "'"));
    return newState;
}
}),
"[project]/node_modules/redux-persist/es/createPersistoid.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>createPersistoid
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/constants.js [app-client] (ecmascript)");
;
function createPersistoid(config) {
    // defaults
    var blacklist = config.blacklist || null;
    var whitelist = config.whitelist || null;
    var transforms = config.transforms || [];
    var throttle = config.throttle || 0;
    var storageKey = "".concat(config.keyPrefix !== undefined ? config.keyPrefix : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KEY_PREFIX"]).concat(config.key);
    var storage = config.storage;
    var serialize;
    if (config.serialize === false) {
        serialize = function serialize(x) {
            return x;
        };
    } else if (typeof config.serialize === 'function') {
        serialize = config.serialize;
    } else {
        serialize = defaultSerialize;
    }
    var writeFailHandler = config.writeFailHandler || null; // initialize stateful values
    var lastState = {};
    var stagedState = {};
    var keysToProcess = [];
    var timeIterator = null;
    var writePromise = null;
    var update = function update(state) {
        // add any changed keys to the queue
        Object.keys(state).forEach(function(key) {
            if (!passWhitelistBlacklist(key)) return; // is keyspace ignored? noop
            if (lastState[key] === state[key]) return; // value unchanged? noop
            if (keysToProcess.indexOf(key) !== -1) return; // is key already queued? noop
            keysToProcess.push(key); // add key to queue
        }); //if any key is missing in the new state which was present in the lastState,
        //add it for processing too
        Object.keys(lastState).forEach(function(key) {
            if (state[key] === undefined && passWhitelistBlacklist(key) && keysToProcess.indexOf(key) === -1 && lastState[key] !== undefined) {
                keysToProcess.push(key);
            }
        }); // start the time iterator if not running (read: throttle)
        if (timeIterator === null) {
            timeIterator = setInterval(processNextKey, throttle);
        }
        lastState = state;
    };
    function processNextKey() {
        if (keysToProcess.length === 0) {
            if (timeIterator) clearInterval(timeIterator);
            timeIterator = null;
            return;
        }
        var key = keysToProcess.shift();
        var endState = transforms.reduce(function(subState, transformer) {
            return transformer.in(subState, key, lastState);
        }, lastState[key]);
        if (endState !== undefined) {
            try {
                stagedState[key] = serialize(endState);
            } catch (err) {
                console.error('redux-persist/createPersistoid: error serializing state', err);
            }
        } else {
            //if the endState is undefined, no need to persist the existing serialized content
            delete stagedState[key];
        }
        if (keysToProcess.length === 0) {
            writeStagedState();
        }
    }
    function writeStagedState() {
        // cleanup any removed keys just before write.
        Object.keys(stagedState).forEach(function(key) {
            if (lastState[key] === undefined) {
                delete stagedState[key];
            }
        });
        writePromise = storage.setItem(storageKey, serialize(stagedState)).catch(onWriteFail);
    }
    function passWhitelistBlacklist(key) {
        if (whitelist && whitelist.indexOf(key) === -1 && key !== '_persist') return false;
        if (blacklist && blacklist.indexOf(key) !== -1) return false;
        return true;
    }
    function onWriteFail(err) {
        // @TODO add fail handlers (typically storage full)
        if (writeFailHandler) writeFailHandler(err);
        if (err && ("TURBOPACK compile-time value", "development") !== 'production') {
            console.error('Error storing data', err);
        }
    }
    var flush = function flush() {
        while(keysToProcess.length !== 0){
            processNextKey();
        }
        return writePromise || Promise.resolve();
    }; // return `persistoid`
    return {
        update: update,
        flush: flush
    };
} // @NOTE in the future this may be exposed via config
function defaultSerialize(data) {
    return JSON.stringify(data);
}
}),
"[project]/node_modules/redux-persist/es/getStoredState.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>getStoredState
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/constants.js [app-client] (ecmascript)");
;
function getStoredState(config) {
    var transforms = config.transforms || [];
    var storageKey = "".concat(config.keyPrefix !== undefined ? config.keyPrefix : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KEY_PREFIX"]).concat(config.key);
    var storage = config.storage;
    var debug = config.debug;
    var deserialize;
    if (config.deserialize === false) {
        deserialize = function deserialize(x) {
            return x;
        };
    } else if (typeof config.deserialize === 'function') {
        deserialize = config.deserialize;
    } else {
        deserialize = defaultDeserialize;
    }
    return storage.getItem(storageKey).then(function(serialized) {
        if (!serialized) return undefined;
        else {
            try {
                var state = {};
                var rawState = deserialize(serialized);
                Object.keys(rawState).forEach(function(key) {
                    state[key] = transforms.reduceRight(function(subState, transformer) {
                        return transformer.out(subState, key, rawState);
                    }, deserialize(rawState[key]));
                });
                return state;
            } catch (err) {
                if (("TURBOPACK compile-time value", "development") !== 'production' && debug) console.log("redux-persist/getStoredState: Error restoring data ".concat(serialized), err);
                throw err;
            }
        }
    });
}
function defaultDeserialize(serial) {
    return JSON.parse(serial);
}
}),
"[project]/node_modules/redux-persist/es/purgeStoredState.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>purgeStoredState
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/constants.js [app-client] (ecmascript)");
;
function purgeStoredState(config) {
    var storage = config.storage;
    var storageKey = "".concat(config.keyPrefix !== undefined ? config.keyPrefix : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KEY_PREFIX"]).concat(config.key);
    return storage.removeItem(storageKey, warnIfRemoveError);
}
function warnIfRemoveError(err) {
    if (err && ("TURBOPACK compile-time value", "development") !== 'production') {
        console.error('redux-persist/purgeStoredState: Error purging data stored state', err);
    }
}
}),
"[project]/node_modules/redux-persist/es/persistReducer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>persistReducer
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$stateReconciler$2f$autoMergeLevel1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/stateReconciler/autoMergeLevel1.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$createPersistoid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/createPersistoid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$getStoredState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/getStoredState.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$purgeStoredState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/purgeStoredState.js [app-client] (ecmascript)");
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys(source, true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys(source).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
;
;
;
;
;
var DEFAULT_TIMEOUT = 5000;
function persistReducer(config, baseReducer) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (!config) throw new Error('config is required for persistReducer');
        if (!config.key) throw new Error('key is required in persistor config');
        if (!config.storage) throw new Error("redux-persist: config.storage is required. Try using one of the provided storage engines `import storage from 'redux-persist/lib/storage'`");
    }
    var version = config.version !== undefined ? config.version : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_VERSION"];
    var debug = config.debug || false;
    var stateReconciler = config.stateReconciler === undefined ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$stateReconciler$2f$autoMergeLevel1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] : config.stateReconciler;
    var getStoredState = config.getStoredState || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$getStoredState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    var timeout = config.timeout !== undefined ? config.timeout : DEFAULT_TIMEOUT;
    var _persistoid = null;
    var _purge = false;
    var _paused = true;
    var conditionalUpdate = function conditionalUpdate(state) {
        // update the persistoid only if we are rehydrated and not paused
        state._persist.rehydrated && _persistoid && !_paused && _persistoid.update(state);
        return state;
    };
    return function(state, action) {
        var _ref = state || {}, _persist = _ref._persist, rest = _objectWithoutProperties(_ref, [
            "_persist"
        ]); // $FlowIgnore need to update State type
        var restState = rest;
        if (action.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PERSIST"]) {
            var _sealed = false;
            var _rehydrate = function _rehydrate(payload, err) {
                // dev warning if we are already sealed
                if (("TURBOPACK compile-time value", "development") !== 'production' && _sealed) console.error("redux-persist: rehydrate for \"".concat(config.key, "\" called after timeout."), payload, err); // only rehydrate if we are not already sealed
                if (!_sealed) {
                    action.rehydrate(config.key, payload, err);
                    _sealed = true;
                }
            };
            timeout && setTimeout(function() {
                !_sealed && _rehydrate(undefined, new Error("redux-persist: persist timed out for persist key \"".concat(config.key, "\"")));
            }, timeout); // @NOTE PERSIST resumes if paused.
            _paused = false; // @NOTE only ever create persistoid once, ensure we call it at least once, even if _persist has already been set
            if (!_persistoid) _persistoid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$createPersistoid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(config); // @NOTE PERSIST can be called multiple times, noop after the first
            if (_persist) {
                // We still need to call the base reducer because there might be nested
                // uses of persistReducer which need to be aware of the PERSIST action
                return _objectSpread({}, baseReducer(restState, action), {
                    _persist: _persist
                });
            }
            if (typeof action.rehydrate !== 'function' || typeof action.register !== 'function') throw new Error('redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution.');
            action.register(config.key);
            getStoredState(config).then(function(restoredState) {
                var migrate = config.migrate || function(s, v) {
                    return Promise.resolve(s);
                };
                migrate(restoredState, version).then(function(migratedState) {
                    _rehydrate(migratedState);
                }, function(migrateErr) {
                    if (("TURBOPACK compile-time value", "development") !== 'production' && migrateErr) console.error('redux-persist: migration error', migrateErr);
                    _rehydrate(undefined, migrateErr);
                });
            }, function(err) {
                _rehydrate(undefined, err);
            });
            return _objectSpread({}, baseReducer(restState, action), {
                _persist: {
                    version: version,
                    rehydrated: false
                }
            });
        } else if (action.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PURGE"]) {
            _purge = true;
            action.result((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$purgeStoredState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(config));
            return _objectSpread({}, baseReducer(restState, action), {
                _persist: _persist
            });
        } else if (action.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FLUSH"]) {
            action.result(_persistoid && _persistoid.flush());
            return _objectSpread({}, baseReducer(restState, action), {
                _persist: _persist
            });
        } else if (action.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PAUSE"]) {
            _paused = true;
        } else if (action.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["REHYDRATE"]) {
            // noop on restState if purging
            if (_purge) return _objectSpread({}, restState, {
                _persist: _objectSpread({}, _persist, {
                    rehydrated: true
                }) // @NOTE if key does not match, will continue to default else below
            });
            if (action.key === config.key) {
                var reducedState = baseReducer(restState, action);
                var inboundState = action.payload; // only reconcile state if stateReconciler and inboundState are both defined
                var reconciledRest = stateReconciler !== false && inboundState !== undefined ? stateReconciler(inboundState, state, reducedState, config) : reducedState;
                var _newState = _objectSpread({}, reconciledRest, {
                    _persist: _objectSpread({}, _persist, {
                        rehydrated: true
                    })
                });
                return conditionalUpdate(_newState);
            }
        } // if we have not already handled PERSIST, straight passthrough
        if (!_persist) return baseReducer(state, action); // run base reducer:
        // is state modified ? return original : return updated
        var newState = baseReducer(restState, action);
        if (newState === restState) return state;
        return conditionalUpdate(_objectSpread({}, newState, {
            _persist: _persist
        }));
    };
}
}),
"[project]/node_modules/redux-persist/es/stateReconciler/autoMergeLevel2.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>autoMergeLevel2
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys(source, true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys(source).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function autoMergeLevel2(inboundState, originalState, reducedState, _ref) {
    var debug = _ref.debug;
    var newState = _objectSpread({}, reducedState); // only rehydrate if inboundState exists and is an object
    if (inboundState && _typeof(inboundState) === 'object') {
        Object.keys(inboundState).forEach(function(key) {
            // ignore _persist data
            if (key === '_persist') return; // if reducer modifies substate, skip auto rehydration
            if (originalState[key] !== reducedState[key]) {
                if (("TURBOPACK compile-time value", "development") !== 'production' && debug) console.log('redux-persist/stateReconciler: sub state for key `%s` modified, skipping.', key);
                return;
            }
            if (isPlainEnoughObject(reducedState[key])) {
                // if object is plain enough shallow merge the new values (hence "Level2")
                newState[key] = _objectSpread({}, newState[key], {}, inboundState[key]);
                return;
            } // otherwise hard set
            newState[key] = inboundState[key];
        });
    }
    if (("TURBOPACK compile-time value", "development") !== 'production' && debug && inboundState && _typeof(inboundState) === 'object') console.log("redux-persist/stateReconciler: rehydrated keys '".concat(Object.keys(inboundState).join(', '), "'"));
    return newState;
}
function isPlainEnoughObject(o) {
    return o !== null && !Array.isArray(o) && _typeof(o) === 'object';
}
}),
"[project]/node_modules/redux-persist/es/persistCombineReducers.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>persistCombineReducers
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux/dist/redux.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$persistReducer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/persistReducer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$stateReconciler$2f$autoMergeLevel2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/stateReconciler/autoMergeLevel2.js [app-client] (ecmascript)");
;
;
;
function persistCombineReducers(config, reducers) {
    config.stateReconciler = config.stateReconciler === undefined ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$stateReconciler$2f$autoMergeLevel2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] : config.stateReconciler;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$persistReducer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(config, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["combineReducers"])(reducers));
}
}),
"[project]/node_modules/redux-persist/es/persistStore.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>persistStore
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux/dist/redux.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/constants.js [app-client] (ecmascript)");
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
        for(var i = 0, arr2 = new Array(arr.length); i < arr.length; i++){
            arr2[i] = arr[i];
        }
        return arr2;
    }
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys(source, true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys(source).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
;
;
var initialState = {
    registry: [],
    bootstrapped: false
};
var persistorReducer = function persistorReducer() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
    var action = arguments.length > 1 ? arguments[1] : undefined;
    switch(action.type){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["REGISTER"]:
            return _objectSpread({}, state, {
                registry: [].concat(_toConsumableArray(state.registry), [
                    action.key
                ])
            });
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["REHYDRATE"]:
            var firstIndex = state.registry.indexOf(action.key);
            var registry = _toConsumableArray(state.registry);
            registry.splice(firstIndex, 1);
            return _objectSpread({}, state, {
                registry: registry,
                bootstrapped: registry.length === 0
            });
        default:
            return state;
    }
};
function persistStore(store, options, cb) {
    // help catch incorrect usage of passing PersistConfig in as PersistorOptions
    if ("TURBOPACK compile-time truthy", 1) {
        var optionsToTest = options || {};
        var bannedKeys = [
            'blacklist',
            'whitelist',
            'transforms',
            'storage',
            'keyPrefix',
            'migrate'
        ];
        bannedKeys.forEach(function(k) {
            if (!!optionsToTest[k]) console.error("redux-persist: invalid option passed to persistStore: \"".concat(k, "\". You may be incorrectly passing persistConfig into persistStore, whereas it should be passed into persistReducer."));
        });
    }
    var boostrappedCb = cb || false;
    var _pStore = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createStore"])(persistorReducer, initialState, options && options.enhancer ? options.enhancer : undefined);
    var register = function register(key) {
        _pStore.dispatch({
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["REGISTER"],
            key: key
        });
    };
    var rehydrate = function rehydrate(key, payload, err) {
        var rehydrateAction = {
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["REHYDRATE"],
            payload: payload,
            err: err,
            key: key // dispatch to `store` to rehydrate and `persistor` to track result
        };
        store.dispatch(rehydrateAction);
        _pStore.dispatch(rehydrateAction);
        if (boostrappedCb && persistor.getState().bootstrapped) {
            boostrappedCb();
            boostrappedCb = false;
        }
    };
    var persistor = _objectSpread({}, _pStore, {
        purge: function purge() {
            var results = [];
            store.dispatch({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PURGE"],
                result: function result(purgeResult) {
                    results.push(purgeResult);
                }
            });
            return Promise.all(results);
        },
        flush: function flush() {
            var results = [];
            store.dispatch({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FLUSH"],
                result: function result(flushResult) {
                    results.push(flushResult);
                }
            });
            return Promise.all(results);
        },
        pause: function pause() {
            store.dispatch({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PAUSE"]
            });
        },
        persist: function persist() {
            store.dispatch({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PERSIST"],
                register: register,
                rehydrate: rehydrate
            });
        }
    });
    if (!(options && options.manualPersist)) {
        persistor.persist();
    }
    return persistor;
}
}),
"[project]/node_modules/redux-persist/es/createMigrate.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>createMigrate
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/constants.js [app-client] (ecmascript)");
;
function createMigrate(migrations, config) {
    var _ref = config || {}, debug = _ref.debug;
    return function(state, currentVersion) {
        if (!state) {
            if (("TURBOPACK compile-time value", "development") !== 'production' && debug) console.log('redux-persist: no inbound state, skipping migration');
            return Promise.resolve(undefined);
        }
        var inboundVersion = state._persist && state._persist.version !== undefined ? state._persist.version : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_VERSION"];
        if (inboundVersion === currentVersion) {
            if (("TURBOPACK compile-time value", "development") !== 'production' && debug) console.log('redux-persist: versions match, noop migration');
            return Promise.resolve(state);
        }
        if (inboundVersion > currentVersion) {
            if ("TURBOPACK compile-time truthy", 1) console.error('redux-persist: downgrading version is not supported');
            return Promise.resolve(state);
        }
        var migrationKeys = Object.keys(migrations).map(function(ver) {
            return parseInt(ver);
        }).filter(function(key) {
            return currentVersion >= key && key > inboundVersion;
        }).sort(function(a, b) {
            return a - b;
        });
        if (("TURBOPACK compile-time value", "development") !== 'production' && debug) console.log('redux-persist: migrationKeys', migrationKeys);
        try {
            var migratedState = migrationKeys.reduce(function(state, versionKey) {
                if (("TURBOPACK compile-time value", "development") !== 'production' && debug) console.log('redux-persist: running migration for versionKey', versionKey);
                return migrations[versionKey](state);
            }, state);
            return Promise.resolve(migratedState);
        } catch (err) {
            return Promise.reject(err);
        }
    };
}
}),
"[project]/node_modules/redux-persist/es/createTransform.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>createTransform
});
function createTransform(inbound, outbound) {
    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var whitelist = config.whitelist || null;
    var blacklist = config.blacklist || null;
    function whitelistBlacklistCheck(key) {
        if (whitelist && whitelist.indexOf(key) === -1) return true;
        if (blacklist && blacklist.indexOf(key) !== -1) return true;
        return false;
    }
    return {
        in: function _in(state, key, fullState) {
            return !whitelistBlacklistCheck(key) && inbound ? inbound(state, key, fullState) : state;
        },
        out: function out(state, key, fullState) {
            return !whitelistBlacklistCheck(key) && outbound ? outbound(state, key, fullState) : state;
        }
    };
}
}),
"[project]/node_modules/redux-persist/es/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$persistReducer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/persistReducer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$persistCombineReducers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/persistCombineReducers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$persistStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/persistStore.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$createMigrate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/createMigrate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$createTransform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/createTransform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$getStoredState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/getStoredState.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$createPersistoid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/createPersistoid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$purgeStoredState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/purgeStoredState.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/constants.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
}),
"[project]/node_modules/redux-persist/es/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$persistReducer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/persistReducer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$persistCombineReducers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/persistCombineReducers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$persistStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/persistStore.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$createMigrate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/createMigrate.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$createTransform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/createTransform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$getStoredState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/getStoredState.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$createPersistoid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/createPersistoid.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$purgeStoredState$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/purgeStoredState.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/index.js [app-client] (ecmascript) <locals>");
}),
"[project]/node_modules/redux-persist/es/persistStore.js [app-client] (ecmascript) <export default as persistStore>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "persistStore": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$persistStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$persistStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/persistStore.js [app-client] (ecmascript)");
}),
"[project]/node_modules/redux-persist/es/persistReducer.js [app-client] (ecmascript) <export default as persistReducer>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "persistReducer": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$persistReducer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2d$persist$2f$es$2f$persistReducer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux-persist/es/persistReducer.js [app-client] (ecmascript)");
}),
"[project]/node_modules/redux-persist/lib/storage/getStorage.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
exports.__esModule = true;
exports.default = getStorage;
function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}
function noop() {}
var noopStorage = {
    getItem: noop,
    setItem: noop,
    removeItem: noop
};
function hasStorage(storageType) {
    if ((typeof self === "undefined" ? "undefined" : _typeof(self)) !== 'object' || !(storageType in self)) {
        return false;
    }
    try {
        var storage = self[storageType];
        var testKey = "redux-persist ".concat(storageType, " test");
        storage.setItem(testKey, 'test');
        storage.getItem(testKey);
        storage.removeItem(testKey);
    } catch (e) {
        if ("TURBOPACK compile-time truthy", 1) console.warn("redux-persist ".concat(storageType, " test failed, persistence will be disabled."));
        return false;
    }
    return true;
}
function getStorage(type) {
    var storageType = "".concat(type, "Storage");
    if (hasStorage(storageType)) return self[storageType];
    else {
        if ("TURBOPACK compile-time truthy", 1) {
            console.error("redux-persist failed to create sync storage. falling back to noop storage.");
        }
        return noopStorage;
    }
}
}}),
"[project]/node_modules/redux-persist/lib/storage/createWebStorage.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
exports.__esModule = true;
exports.default = createWebStorage;
var _getStorage = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/redux-persist/lib/storage/getStorage.js [app-client] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function createWebStorage(type) {
    var storage = (0, _getStorage.default)(type);
    return {
        getItem: function getItem(key) {
            return new Promise(function(resolve, reject) {
                resolve(storage.getItem(key));
            });
        },
        setItem: function setItem(key, item) {
            return new Promise(function(resolve, reject) {
                resolve(storage.setItem(key, item));
            });
        },
        removeItem: function removeItem(key) {
            return new Promise(function(resolve, reject) {
                resolve(storage.removeItem(key));
            });
        }
    };
}
}}),
"[project]/node_modules/redux-persist/lib/storage/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
exports.__esModule = true;
exports.default = void 0;
var _createWebStorage = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/redux-persist/lib/storage/createWebStorage.js [app-client] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var _default = (0, _createWebStorage.default)('local');
exports.default = _default;
}}),
"[project]/node_modules/immer/dist/immer.mjs [app-client] (ecmascript) <export produce as createNextState>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createNextState": ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["produce"]
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/immer/dist/immer.mjs [app-client] (ecmascript)");
}),
"[project]/node_modules/@standard-schema/utils/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/getDotPath/getDotPath.ts
__turbopack_context__.s({
    "SchemaError": ()=>SchemaError,
    "getDotPath": ()=>getDotPath
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
;
function getDotPath(issue) {
    var _issue_path;
    if ((_issue_path = issue.path) === null || _issue_path === void 0 ? void 0 : _issue_path.length) {
        let dotPath = "";
        for (const item of issue.path){
            const key = typeof item === "object" ? item.key : item;
            if (typeof key === "string" || typeof key === "number") {
                if (dotPath) {
                    dotPath += ".".concat(key);
                } else {
                    dotPath += key;
                }
            } else {
                return null;
            }
        }
        return dotPath;
    }
    return null;
}
// src/SchemaError/SchemaError.ts
var SchemaError = class extends Error {
    /**
   * Creates a schema error with useful information.
   *
   * @param issues The schema issues.
   */ constructor(issues){
        super(issues[0].message), /**
   * The schema issues.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "issues", void 0);
        this.name = "SchemaError";
        this.issues = issues;
    }
};
;
}),
"[project]/node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/query/core/apiState.ts
__turbopack_context__.s({
    "NamedSchemaError": ()=>NamedSchemaError,
    "QueryStatus": ()=>QueryStatus,
    "_NEVER": ()=>_NEVER,
    "buildCreateApi": ()=>buildCreateApi,
    "copyWithStructuralSharing": ()=>copyWithStructuralSharing,
    "coreModule": ()=>coreModule,
    "coreModuleName": ()=>coreModuleName,
    "createApi": ()=>createApi,
    "defaultSerializeQueryArgs": ()=>defaultSerializeQueryArgs,
    "fakeBaseQuery": ()=>fakeBaseQuery,
    "fetchBaseQuery": ()=>fetchBaseQuery,
    "retry": ()=>retry,
    "setupListeners": ()=>setupListeners,
    "skipToken": ()=>skipToken
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
// src/query/core/rtkImports.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$reselect$2f$dist$2f$reselect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/reselect/dist/reselect.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redux/dist/redux.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__produce__as__createNextState$3e$__ = __turbopack_context__.i("[project]/node_modules/immer/dist/immer.mjs [app-client] (ecmascript) <export produce as createNextState>");
// src/query/core/buildThunks.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/immer/dist/immer.mjs [app-client] (ecmascript)");
// src/query/standardSchema.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$standard$2d$schema$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@standard-schema/utils/dist/index.js [app-client] (ecmascript)");
var QueryStatus = /* @__PURE__ */ ((QueryStatus2)=>{
    QueryStatus2["uninitialized"] = "uninitialized";
    QueryStatus2["pending"] = "pending";
    QueryStatus2["fulfilled"] = "fulfilled";
    QueryStatus2["rejected"] = "rejected";
    return QueryStatus2;
})(QueryStatus || {});
function getRequestStatusFlags(status) {
    return {
        status,
        isUninitialized: status === "uninitialized" /* uninitialized */ ,
        isLoading: status === "pending" /* pending */ ,
        isSuccess: status === "fulfilled" /* fulfilled */ ,
        isError: status === "rejected" /* rejected */ 
    };
}
;
// src/query/utils/copyWithStructuralSharing.ts
var isPlainObject2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"];
function copyWithStructuralSharing(oldObj, newObj) {
    if (oldObj === newObj || !(isPlainObject2(oldObj) && isPlainObject2(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {
        return newObj;
    }
    const newKeys = Object.keys(newObj);
    const oldKeys = Object.keys(oldObj);
    let isSameObject = newKeys.length === oldKeys.length;
    const mergeObj = Array.isArray(newObj) ? [] : {};
    for (const key of newKeys){
        mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);
        if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];
    }
    return isSameObject ? oldObj : mergeObj;
}
// src/query/utils/countObjectKeys.ts
function countObjectKeys(obj) {
    let count = 0;
    for(const _key in obj){
        count++;
    }
    return count;
}
// src/query/utils/flatten.ts
var flatten = (arr)=>[].concat(...arr);
// src/query/utils/isAbsoluteUrl.ts
function isAbsoluteUrl(url) {
    return new RegExp("(^|:)//").test(url);
}
// src/query/utils/isDocumentVisible.ts
function isDocumentVisible() {
    if (typeof document === "undefined") {
        return true;
    }
    return document.visibilityState !== "hidden";
}
// src/query/utils/isNotNullish.ts
function isNotNullish(v) {
    return v != null;
}
// src/query/utils/isOnline.ts
function isOnline() {
    return typeof navigator === "undefined" ? true : navigator.onLine === void 0 ? true : navigator.onLine;
}
// src/query/utils/joinUrls.ts
var withoutTrailingSlash = (url)=>url.replace(/\/$/, "");
var withoutLeadingSlash = (url)=>url.replace(/^\//, "");
function joinUrls(base, url) {
    if (!base) {
        return url;
    }
    if (!url) {
        return base;
    }
    if (isAbsoluteUrl(url)) {
        return url;
    }
    const delimiter = base.endsWith("/") || !url.startsWith("?") ? "/" : "";
    base = withoutTrailingSlash(base);
    url = withoutLeadingSlash(url);
    return "".concat(base).concat(delimiter).concat(url);
}
// src/query/utils/getOrInsert.ts
function getOrInsert(map, key, value) {
    if (map.has(key)) return map.get(key);
    return map.set(key, value).get(key);
}
// src/query/fetchBaseQuery.ts
var defaultFetchFn = function() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    return fetch(...args);
};
var defaultValidateStatus = (response)=>response.status >= 200 && response.status <= 299;
var defaultIsJsonContentType = (headers)=>/*applicat*/ /ion\/(vnd\.api\+)?json/.test(headers.get("content-type") || "");
function stripUndefined(obj) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(obj)) {
        return obj;
    }
    const copy = {
        ...obj
    };
    for (const [k, v] of Object.entries(copy)){
        if (v === void 0) delete copy[k];
    }
    return copy;
}
function fetchBaseQuery() {
    let { baseUrl, prepareHeaders = (x)=>x, fetchFn = defaultFetchFn, paramsSerializer, isJsonContentType = defaultIsJsonContentType, jsonContentType = "application/json", jsonReplacer, timeout: defaultTimeout, responseHandler: globalResponseHandler, validateStatus: globalValidateStatus, ...baseFetchOptions } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (typeof fetch === "undefined" && fetchFn === defaultFetchFn) {
        console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.");
    }
    return async (arg, api, extraOptions)=>{
        const { getState, extra, endpoint, forced, type } = api;
        let meta;
        let { url, headers = new Headers(baseFetchOptions.headers), params = void 0, responseHandler = globalResponseHandler !== null && globalResponseHandler !== void 0 ? globalResponseHandler : "json", validateStatus = globalValidateStatus !== null && globalValidateStatus !== void 0 ? globalValidateStatus : defaultValidateStatus, timeout = defaultTimeout, ...rest } = typeof arg == "string" ? {
            url: arg
        } : arg;
        let abortController, signal = api.signal;
        if (timeout) {
            abortController = new AbortController();
            api.signal.addEventListener("abort", abortController.abort);
            signal = abortController.signal;
        }
        let config = {
            ...baseFetchOptions,
            signal,
            ...rest
        };
        headers = new Headers(stripUndefined(headers));
        config.headers = await prepareHeaders(headers, {
            getState,
            arg,
            extra,
            endpoint,
            forced,
            type,
            extraOptions
        }) || headers;
        const isJsonifiable = (body)=>typeof body === "object" && ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(body) || Array.isArray(body) || typeof body.toJSON === "function");
        if (!config.headers.has("content-type") && isJsonifiable(config.body)) {
            config.headers.set("content-type", jsonContentType);
        }
        if (isJsonifiable(config.body) && isJsonContentType(config.headers)) {
            config.body = JSON.stringify(config.body, jsonReplacer);
        }
        if (params) {
            const divider = ~url.indexOf("?") ? "&" : "?";
            const query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));
            url += divider + query;
        }
        url = joinUrls(baseUrl, url);
        const request = new Request(url, config);
        const requestClone = new Request(url, config);
        meta = {
            request: requestClone
        };
        let response, timedOut = false, timeoutId = abortController && setTimeout(()=>{
            timedOut = true;
            abortController.abort();
        }, timeout);
        try {
            response = await fetchFn(request);
        } catch (e) {
            return {
                error: {
                    status: timedOut ? "TIMEOUT_ERROR" : "FETCH_ERROR",
                    error: String(e)
                },
                meta
            };
        } finally{
            if (timeoutId) clearTimeout(timeoutId);
            abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener("abort", abortController.abort);
        }
        const responseClone = response.clone();
        meta.response = responseClone;
        let resultData;
        let responseText = "";
        try {
            let handleResponseError;
            await Promise.all([
                handleResponse(response, responseHandler).then((r)=>resultData = r, (e)=>handleResponseError = e),
                // see https://github.com/node-fetch/node-fetch/issues/665#issuecomment-538995182
                // we *have* to "use up" both streams at the same time or they will stop running in node-fetch scenarios
                responseClone.text().then((r)=>responseText = r, ()=>{})
            ]);
            if (handleResponseError) throw handleResponseError;
        } catch (e) {
            return {
                error: {
                    status: "PARSING_ERROR",
                    originalStatus: response.status,
                    data: responseText,
                    error: String(e)
                },
                meta
            };
        }
        return validateStatus(response, resultData) ? {
            data: resultData,
            meta
        } : {
            error: {
                status: response.status,
                data: resultData
            },
            meta
        };
    };
    //TURBOPACK unreachable
    ;
    async function handleResponse(response, responseHandler) {
        if (typeof responseHandler === "function") {
            return responseHandler(response);
        }
        if (responseHandler === "content-type") {
            responseHandler = isJsonContentType(response.headers) ? "json" : "text";
        }
        if (responseHandler === "json") {
            const text = await response.text();
            return text.length ? JSON.parse(text) : null;
        }
        return response.text();
    }
}
// src/query/HandledError.ts
var HandledError = class {
    constructor(value, meta = void 0){
        this.value = value;
        this.meta = meta;
    }
};
// src/query/retry.ts
async function defaultBackoff() {
    let attempt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, maxRetries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
    const attempts = Math.min(attempt, maxRetries);
    const timeout = ~~((Math.random() + 0.4) * (300 << attempts));
    await new Promise((resolve)=>setTimeout((res)=>resolve(res), timeout));
}
function fail(error, meta) {
    throw Object.assign(new HandledError({
        error,
        meta
    }), {
        throwImmediately: true
    });
}
var EMPTY_OPTIONS = {};
var retryWithBackoff = (baseQuery, defaultOptions)=>async (args, api, extraOptions)=>{
        const possibleMaxRetries = [
            5,
            (defaultOptions || EMPTY_OPTIONS).maxRetries,
            (extraOptions || EMPTY_OPTIONS).maxRetries
        ].filter((x)=>x !== void 0);
        const [maxRetries] = possibleMaxRetries.slice(-1);
        const defaultRetryCondition = (_, __, param)=>{
            let { attempt } = param;
            return attempt <= maxRetries;
        };
        const options = {
            maxRetries,
            backoff: defaultBackoff,
            retryCondition: defaultRetryCondition,
            ...defaultOptions,
            ...extraOptions
        };
        let retry2 = 0;
        while(true){
            try {
                const result = await baseQuery(args, api, extraOptions);
                if (result.error) {
                    throw new HandledError(result);
                }
                return result;
            } catch (e) {
                retry2++;
                if (e.throwImmediately) {
                    if (e instanceof HandledError) {
                        return e.value;
                    }
                    throw e;
                }
                if (e instanceof HandledError && !options.retryCondition(e.value.error, args, {
                    attempt: retry2,
                    baseQueryApi: api,
                    extraOptions
                })) {
                    return e.value;
                }
                await options.backoff(retry2, options.maxRetries);
            }
        }
    };
var retry = /* @__PURE__ */ Object.assign(retryWithBackoff, {
    fail
});
// src/query/core/setupListeners.ts
var onFocus = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAction"])("__rtkq/focused");
var onFocusLost = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAction"])("__rtkq/unfocused");
var onOnline = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAction"])("__rtkq/online");
var onOffline = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAction"])("__rtkq/offline");
var initialized = false;
function setupListeners(dispatch, customHandler) {
    function defaultHandler() {
        const handleFocus = ()=>dispatch(onFocus());
        const handleFocusLost = ()=>dispatch(onFocusLost());
        const handleOnline = ()=>dispatch(onOnline());
        const handleOffline = ()=>dispatch(onOffline());
        const handleVisibilityChange = ()=>{
            if (window.document.visibilityState === "visible") {
                handleFocus();
            } else {
                handleFocusLost();
            }
        };
        if (!initialized) {
            if (typeof window !== "undefined" && window.addEventListener) {
                window.addEventListener("visibilitychange", handleVisibilityChange, false);
                window.addEventListener("focus", handleFocus, false);
                window.addEventListener("online", handleOnline, false);
                window.addEventListener("offline", handleOffline, false);
                initialized = true;
            }
        }
        const unsubscribe = ()=>{
            window.removeEventListener("focus", handleFocus);
            window.removeEventListener("visibilitychange", handleVisibilityChange);
            window.removeEventListener("online", handleOnline);
            window.removeEventListener("offline", handleOffline);
            initialized = false;
        };
        return unsubscribe;
    }
    return customHandler ? customHandler(dispatch, {
        onFocus,
        onFocusLost,
        onOffline,
        onOnline
    }) : defaultHandler();
}
// src/query/endpointDefinitions.ts
function isQueryDefinition(e) {
    return e.type === "query" /* query */ ;
}
function isMutationDefinition(e) {
    return e.type === "mutation" /* mutation */ ;
}
function isInfiniteQueryDefinition(e) {
    return e.type === "infinitequery" /* infinitequery */ ;
}
function isAnyQueryDefinition(e) {
    return isQueryDefinition(e) || isInfiniteQueryDefinition(e);
}
function calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {
    if (isFunction(description)) {
        return description(result, error, queryArg, meta).filter(isNotNullish).map(expandTagDescription).map(assertTagTypes);
    }
    if (Array.isArray(description)) {
        return description.map(expandTagDescription).map(assertTagTypes);
    }
    return [];
}
function isFunction(t) {
    return typeof t === "function";
}
function expandTagDescription(description) {
    return typeof description === "string" ? {
        type: description
    } : description;
}
;
;
// src/tsHelpers.ts
function asSafePromise(promise, fallback) {
    return promise.catch(fallback);
}
// src/query/core/buildInitiate.ts
var forceQueryFnSymbol = Symbol("forceQueryFn");
var isUpsertQuery = (arg)=>typeof arg[forceQueryFnSymbol] === "function";
function buildInitiate(param) {
    let { serializeQueryArgs, queryThunk, infiniteQueryThunk, mutationThunk, api, context } = param;
    const runningQueries = /* @__PURE__ */ new Map();
    const runningMutations = /* @__PURE__ */ new Map();
    const { unsubscribeQueryResult, removeMutationResult, updateSubscriptionOptions } = api.internalActions;
    return {
        buildInitiateQuery,
        buildInitiateInfiniteQuery,
        buildInitiateMutation,
        getRunningQueryThunk,
        getRunningMutationThunk,
        getRunningQueriesThunk,
        getRunningMutationsThunk
    };
    //TURBOPACK unreachable
    ;
    function getRunningQueryThunk(endpointName, queryArgs) {
        return (dispatch)=>{
            var _runningQueries_get;
            const endpointDefinition = context.endpointDefinitions[endpointName];
            const queryCacheKey = serializeQueryArgs({
                queryArgs,
                endpointDefinition,
                endpointName
            });
            return (_runningQueries_get = runningQueries.get(dispatch)) === null || _runningQueries_get === void 0 ? void 0 : _runningQueries_get[queryCacheKey];
        };
    }
    function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {
        return (dispatch)=>{
            var _runningMutations_get;
            return (_runningMutations_get = runningMutations.get(dispatch)) === null || _runningMutations_get === void 0 ? void 0 : _runningMutations_get[fixedCacheKeyOrRequestId];
        };
    }
    function getRunningQueriesThunk() {
        return (dispatch)=>Object.values(runningQueries.get(dispatch) || {}).filter(isNotNullish);
    }
    function getRunningMutationsThunk() {
        return (dispatch)=>Object.values(runningMutations.get(dispatch) || {}).filter(isNotNullish);
    }
    function middlewareWarning(dispatch) {
        if ("TURBOPACK compile-time truthy", 1) {
            if (middlewareWarning.triggered) return;
            const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());
            middlewareWarning.triggered = true;
            if (typeof returnedValue !== "object" || typeof (returnedValue === null || returnedValue === void 0 ? void 0 : returnedValue.type) === "string") {
                throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 'Warning: Middleware for RTK-Query API at reducerPath "'.concat(api.reducerPath, '" has not been added to the store.\nYou must add the middleware for RTK-Query to function correctly!'));
            }
        }
    }
    function buildInitiateAnyQuery(endpointName, endpointDefinition) {
        const queryAction = function(arg) {
            let { subscribe = true, forceRefetch, subscriptionOptions, [forceQueryFnSymbol]: forceQueryFn, ...rest } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return (dispatch, getState)=>{
                var _runningQueries_get;
                const queryCacheKey = serializeQueryArgs({
                    queryArgs: arg,
                    endpointDefinition,
                    endpointName
                });
                let thunk;
                const commonThunkArgs = {
                    ...rest,
                    type: "query",
                    subscribe,
                    forceRefetch,
                    subscriptionOptions,
                    endpointName,
                    originalArgs: arg,
                    queryCacheKey,
                    [forceQueryFnSymbol]: forceQueryFn
                };
                if (isQueryDefinition(endpointDefinition)) {
                    thunk = queryThunk(commonThunkArgs);
                } else {
                    const { direction, initialPageParam } = rest;
                    thunk = infiniteQueryThunk({
                        ...commonThunkArgs,
                        // Supply these even if undefined. This helps with a field existence
                        // check over in `buildSlice.ts`
                        direction,
                        initialPageParam
                    });
                }
                const selector = api.endpoints[endpointName].select(arg);
                const thunkResult = dispatch(thunk);
                const stateAfter = selector(getState());
                middlewareWarning(dispatch);
                const { requestId, abort } = thunkResult;
                const skippedSynchronously = stateAfter.requestId !== requestId;
                const runningQuery = (_runningQueries_get = runningQueries.get(dispatch)) === null || _runningQueries_get === void 0 ? void 0 : _runningQueries_get[queryCacheKey];
                const selectFromState = ()=>selector(getState());
                const statePromise = Object.assign(forceQueryFn ? // a query has been forced (upsertQueryData)
                // -> we want to resolve it once data has been written with the data that will be written
                thunkResult.then(selectFromState) : skippedSynchronously && !runningQuery ? // a query has been skipped due to a condition and we do not have any currently running query
                // -> we want to resolve it immediately with the current data
                Promise.resolve(stateAfter) : // query just started or one is already in flight
                // -> wait for the running query, then resolve with data from after that
                Promise.all([
                    runningQuery,
                    thunkResult
                ]).then(selectFromState), {
                    arg,
                    requestId,
                    subscriptionOptions,
                    queryCacheKey,
                    abort,
                    async unwrap () {
                        const result = await statePromise;
                        if (result.isError) {
                            throw result.error;
                        }
                        return result.data;
                    },
                    refetch: ()=>dispatch(queryAction(arg, {
                            subscribe: false,
                            forceRefetch: true
                        })),
                    unsubscribe () {
                        if (subscribe) dispatch(unsubscribeQueryResult({
                            queryCacheKey,
                            requestId
                        }));
                    },
                    updateSubscriptionOptions (options) {
                        statePromise.subscriptionOptions = options;
                        dispatch(updateSubscriptionOptions({
                            endpointName,
                            requestId,
                            queryCacheKey,
                            options
                        }));
                    }
                });
                if (!runningQuery && !skippedSynchronously && !forceQueryFn) {
                    const running = getOrInsert(runningQueries, dispatch, {});
                    running[queryCacheKey] = statePromise;
                    statePromise.then(()=>{
                        delete running[queryCacheKey];
                        if (!countObjectKeys(running)) {
                            runningQueries.delete(dispatch);
                        }
                    });
                }
                return statePromise;
            };
        };
        return queryAction;
    }
    function buildInitiateQuery(endpointName, endpointDefinition) {
        const queryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);
        return queryAction;
    }
    function buildInitiateInfiniteQuery(endpointName, endpointDefinition) {
        const infiniteQueryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);
        return infiniteQueryAction;
    }
    function buildInitiateMutation(endpointName) {
        return function(arg) {
            let { track = true, fixedCacheKey } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return (dispatch, getState)=>{
                const thunk = mutationThunk({
                    type: "mutation",
                    endpointName,
                    originalArgs: arg,
                    track,
                    fixedCacheKey
                });
                const thunkResult = dispatch(thunk);
                middlewareWarning(dispatch);
                const { requestId, abort, unwrap } = thunkResult;
                const returnValuePromise = asSafePromise(thunkResult.unwrap().then((data)=>({
                        data
                    })), (error)=>({
                        error
                    }));
                const reset = ()=>{
                    dispatch(removeMutationResult({
                        requestId,
                        fixedCacheKey
                    }));
                };
                const ret = Object.assign(returnValuePromise, {
                    arg: thunkResult.arg,
                    requestId,
                    abort,
                    unwrap,
                    reset
                });
                const running = runningMutations.get(dispatch) || {};
                runningMutations.set(dispatch, running);
                running[requestId] = ret;
                ret.then(()=>{
                    delete running[requestId];
                    if (!countObjectKeys(running)) {
                        runningMutations.delete(dispatch);
                    }
                });
                if (fixedCacheKey) {
                    running[fixedCacheKey] = ret;
                    ret.then(()=>{
                        if (running[fixedCacheKey] === ret) {
                            delete running[fixedCacheKey];
                            if (!countObjectKeys(running)) {
                                runningMutations.delete(dispatch);
                            }
                        }
                    });
                }
                return ret;
            };
        };
    }
}
;
var NamedSchemaError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$standard$2d$schema$2f$utils$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SchemaError"] {
    constructor(issues, value, schemaName, _bqMeta){
        super(issues);
        this.value = value;
        this.schemaName = schemaName;
        this._bqMeta = _bqMeta;
    }
};
async function parseWithSchema(schema, data, schemaName, bqMeta) {
    const result = await schema["~standard"].validate(data);
    if (result.issues) {
        throw new NamedSchemaError(result.issues, data, schemaName, bqMeta);
    }
    return result.value;
}
// src/query/core/buildThunks.ts
function defaultTransformResponse(baseQueryReturnValue) {
    return baseQueryReturnValue;
}
var addShouldAutoBatch = function() {
    let arg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return {
        ...arg,
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["SHOULD_AUTOBATCH"]]: true
    };
};
function buildThunks(param) {
    let { reducerPath, baseQuery, context: { endpointDefinitions }, serializeQueryArgs, api, assertTagType, selectors, onSchemaFailure, catchSchemaFailure: globalCatchSchemaFailure, skipSchemaValidation: globalSkipSchemaValidation } = param;
    const patchQueryData = (endpointName, arg, patches, updateProvided)=>(dispatch, getState)=>{
            const endpointDefinition = endpointDefinitions[endpointName];
            const queryCacheKey = serializeQueryArgs({
                queryArgs: arg,
                endpointDefinition,
                endpointName
            });
            dispatch(api.internalActions.queryResultPatched({
                queryCacheKey,
                patches
            }));
            if (!updateProvided) {
                return;
            }
            const newValue = api.endpoints[endpointName].select(arg)(// Work around TS 4.1 mismatch
            getState());
            const providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, arg, {}, assertTagType);
            dispatch(api.internalActions.updateProvidedBy([
                {
                    queryCacheKey,
                    providedTags
                }
            ]));
        };
    function addToStart(items, item) {
        let max = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        const newItems = [
            item,
            ...items
        ];
        return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
    }
    function addToEnd(items, item) {
        let max = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        const newItems = [
            ...items,
            item
        ];
        return max && newItems.length > max ? newItems.slice(1) : newItems;
    }
    const updateQueryData = function(endpointName, arg, updateRecipe) {
        let updateProvided = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
        return (dispatch, getState)=>{
            const endpointDefinition = api.endpoints[endpointName];
            const currentState = endpointDefinition.select(arg)(// Work around TS 4.1 mismatch
            getState());
            const ret = {
                patches: [],
                inversePatches: [],
                undo: ()=>dispatch(api.util.patchQueryData(endpointName, arg, ret.inversePatches, updateProvided))
            };
            if (currentState.status === "uninitialized" /* uninitialized */ ) {
                return ret;
            }
            let newValue;
            if ("data" in currentState) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDraftable"])(currentState.data)) {
                    const [value, patches, inversePatches] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["produceWithPatches"])(currentState.data, updateRecipe);
                    ret.patches.push(...patches);
                    ret.inversePatches.push(...inversePatches);
                    newValue = value;
                } else {
                    newValue = updateRecipe(currentState.data);
                    ret.patches.push({
                        op: "replace",
                        path: [],
                        value: newValue
                    });
                    ret.inversePatches.push({
                        op: "replace",
                        path: [],
                        value: currentState.data
                    });
                }
            }
            if (ret.patches.length === 0) {
                return ret;
            }
            dispatch(api.util.patchQueryData(endpointName, arg, ret.patches, updateProvided));
            return ret;
        };
    };
    const upsertQueryData = (endpointName, arg, value)=>(dispatch)=>{
            const res = dispatch(api.endpoints[endpointName].initiate(arg, {
                subscribe: false,
                forceRefetch: true,
                [forceQueryFnSymbol]: ()=>({
                        data: value
                    })
            }));
            return res;
        };
    const getTransformCallbackForEndpoint = (endpointDefinition, transformFieldName)=>{
        return endpointDefinition.query && endpointDefinition[transformFieldName] ? endpointDefinition[transformFieldName] : defaultTransformResponse;
    };
    const executeEndpoint = async (arg, param)=>{
        let { signal, abort, rejectWithValue, fulfillWithValue, dispatch, getState, extra } = param;
        const endpointDefinition = endpointDefinitions[arg.endpointName];
        const { metaSchema, skipSchemaValidation = globalSkipSchemaValidation } = endpointDefinition;
        try {
            let transformResponse = getTransformCallbackForEndpoint(endpointDefinition, "transformResponse");
            const baseQueryApi = {
                signal,
                abort,
                dispatch,
                getState,
                extra,
                endpoint: arg.endpointName,
                type: arg.type,
                forced: arg.type === "query" ? isForcedQuery(arg, getState()) : void 0,
                queryCacheKey: arg.type === "query" ? arg.queryCacheKey : void 0
            };
            const forceQueryFn = arg.type === "query" ? arg[forceQueryFnSymbol] : void 0;
            let finalQueryReturnValue;
            const fetchPage = async (data, param, maxPages, previous)=>{
                if (param == null && data.pages.length) {
                    return Promise.resolve({
                        data
                    });
                }
                const finalQueryArg = {
                    queryArg: arg.originalArgs,
                    pageParam: param
                };
                const pageResponse = await executeRequest(finalQueryArg);
                const addTo = previous ? addToStart : addToEnd;
                return {
                    data: {
                        pages: addTo(data.pages, pageResponse.data, maxPages),
                        pageParams: addTo(data.pageParams, param, maxPages)
                    },
                    meta: pageResponse.meta
                };
            };
            async function executeRequest(finalQueryArg) {
                let result;
                const { extraOptions, argSchema, rawResponseSchema, responseSchema } = endpointDefinition;
                if (argSchema && !skipSchemaValidation) {
                    finalQueryArg = await parseWithSchema(argSchema, finalQueryArg, "argSchema", {});
                }
                if (forceQueryFn) {
                    result = forceQueryFn();
                } else if (endpointDefinition.query) {
                    result = await baseQuery(endpointDefinition.query(finalQueryArg), baseQueryApi, extraOptions);
                } else {
                    result = await endpointDefinition.queryFn(finalQueryArg, baseQueryApi, extraOptions, (arg2)=>baseQuery(arg2, baseQueryApi, extraOptions));
                }
                if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && ("TURBOPACK compile-time value", "development") === "development") {
                    const what = endpointDefinition.query ? "`baseQuery`" : "`queryFn`";
                    let err;
                    if (!result) {
                        err = "".concat(what, " did not return anything.");
                    } else if (typeof result !== "object") {
                        err = "".concat(what, " did not return an object.");
                    } else if (result.error && result.data) {
                        err = "".concat(what, " returned an object containing both `error` and `result`.");
                    } else if (result.error === void 0 && result.data === void 0) {
                        err = "".concat(what, " returned an object containing neither a valid `error` and `result`. At least one of them should not be `undefined`");
                    } else {
                        for (const key of Object.keys(result)){
                            if (key !== "error" && key !== "data" && key !== "meta") {
                                err = "The object returned by ".concat(what, " has the unknown property ").concat(key, ".");
                                break;
                            }
                        }
                    }
                    if (err) {
                        console.error("Error encountered handling the endpoint ".concat(arg.endpointName, ".\n                  ").concat(err, "\n                  It needs to return an object with either the shape `{ data: <value> }` or `{ error: <value> }` that may contain an optional `meta` property.\n                  Object returned was:"), result);
                    }
                }
                if (result.error) throw new HandledError(result.error, result.meta);
                let { data } = result;
                if (rawResponseSchema && !skipSchemaValidation) {
                    data = await parseWithSchema(rawResponseSchema, result.data, "rawResponseSchema", result.meta);
                }
                let transformedResponse = await transformResponse(data, result.meta, finalQueryArg);
                if (responseSchema && !skipSchemaValidation) {
                    transformedResponse = await parseWithSchema(responseSchema, transformedResponse, "responseSchema", result.meta);
                }
                return {
                    ...result,
                    data: transformedResponse
                };
            }
            if (arg.type === "query" && "infiniteQueryOptions" in endpointDefinition) {
                var _selectors_selectQueryEntry;
                const { infiniteQueryOptions } = endpointDefinition;
                const { maxPages = Infinity } = infiniteQueryOptions;
                let result;
                const blankData = {
                    pages: [],
                    pageParams: []
                };
                const cachedData = (_selectors_selectQueryEntry = selectors.selectQueryEntry(getState(), arg.queryCacheKey)) === null || _selectors_selectQueryEntry === void 0 ? void 0 : _selectors_selectQueryEntry.data;
                const isForcedQueryNeedingRefetch = // arg.forceRefetch
                isForcedQuery(arg, getState()) && !arg.direction;
                const existingData = isForcedQueryNeedingRefetch || !cachedData ? blankData : cachedData;
                if ("direction" in arg && arg.direction && existingData.pages.length) {
                    const previous = arg.direction === "backward";
                    const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
                    const param = pageParamFn(infiniteQueryOptions, existingData, arg.originalArgs);
                    result = await fetchPage(existingData, param, maxPages, previous);
                } else {
                    const { initialPageParam = infiniteQueryOptions.initialPageParam } = arg;
                    var _cachedData_pageParams;
                    const cachedPageParams = (_cachedData_pageParams = cachedData === null || cachedData === void 0 ? void 0 : cachedData.pageParams) !== null && _cachedData_pageParams !== void 0 ? _cachedData_pageParams : [];
                    var _cachedPageParams_;
                    const firstPageParam = (_cachedPageParams_ = cachedPageParams[0]) !== null && _cachedPageParams_ !== void 0 ? _cachedPageParams_ : initialPageParam;
                    const totalPages = cachedPageParams.length;
                    result = await fetchPage(existingData, firstPageParam, maxPages);
                    if (forceQueryFn) {
                        result = {
                            data: result.data.pages[0]
                        };
                    }
                    for(let i = 1; i < totalPages; i++){
                        const param = getNextPageParam(infiniteQueryOptions, result.data, arg.originalArgs);
                        result = await fetchPage(result.data, param, maxPages);
                    }
                }
                finalQueryReturnValue = result;
            } else {
                finalQueryReturnValue = await executeRequest(arg.originalArgs);
            }
            if (metaSchema && !skipSchemaValidation && finalQueryReturnValue.meta) {
                finalQueryReturnValue.meta = await parseWithSchema(metaSchema, finalQueryReturnValue.meta, "metaSchema", finalQueryReturnValue.meta);
            }
            return fulfillWithValue(finalQueryReturnValue.data, addShouldAutoBatch({
                fulfilledTimeStamp: Date.now(),
                baseQueryMeta: finalQueryReturnValue.meta
            }));
        } catch (error) {
            let caughtError = error;
            if (caughtError instanceof HandledError) {
                let transformErrorResponse = getTransformCallbackForEndpoint(endpointDefinition, "transformErrorResponse");
                const { rawErrorResponseSchema, errorResponseSchema } = endpointDefinition;
                let { value, meta } = caughtError;
                try {
                    if (rawErrorResponseSchema && !skipSchemaValidation) {
                        value = await parseWithSchema(rawErrorResponseSchema, value, "rawErrorResponseSchema", meta);
                    }
                    if (metaSchema && !skipSchemaValidation) {
                        meta = await parseWithSchema(metaSchema, meta, "metaSchema", meta);
                    }
                    let transformedErrorResponse = await transformErrorResponse(value, meta, arg.originalArgs);
                    if (errorResponseSchema && !skipSchemaValidation) {
                        transformedErrorResponse = await parseWithSchema(errorResponseSchema, transformedErrorResponse, "errorResponseSchema", meta);
                    }
                    return rejectWithValue(transformedErrorResponse, addShouldAutoBatch({
                        baseQueryMeta: meta
                    }));
                } catch (e) {
                    caughtError = e;
                }
            }
            try {
                if (caughtError instanceof NamedSchemaError) {
                    var _endpointDefinition_onSchemaFailure;
                    const info = {
                        endpoint: arg.endpointName,
                        arg: arg.originalArgs,
                        type: arg.type,
                        queryCacheKey: arg.type === "query" ? arg.queryCacheKey : void 0
                    };
                    (_endpointDefinition_onSchemaFailure = endpointDefinition.onSchemaFailure) === null || _endpointDefinition_onSchemaFailure === void 0 ? void 0 : _endpointDefinition_onSchemaFailure.call(endpointDefinition, caughtError, info);
                    onSchemaFailure === null || onSchemaFailure === void 0 ? void 0 : onSchemaFailure(caughtError, info);
                    const { catchSchemaFailure = globalCatchSchemaFailure } = endpointDefinition;
                    if (catchSchemaFailure) {
                        return rejectWithValue(catchSchemaFailure(caughtError, info), addShouldAutoBatch({
                            baseQueryMeta: caughtError._bqMeta
                        }));
                    }
                }
            } catch (e) {
                caughtError = e;
            }
            if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && ("TURBOPACK compile-time value", "development") !== "production") {
                console.error('An unhandled error occurred processing a request for the endpoint "'.concat(arg.endpointName, '".\nIn the case of an unhandled error, no tags will be "provided" or "invalidated".'), caughtError);
            } else {
                console.error(caughtError);
            }
            throw caughtError;
        }
    };
    function isForcedQuery(arg, state) {
        const requestState = selectors.selectQueryEntry(state, arg.queryCacheKey);
        const baseFetchOnMountOrArgChange = selectors.selectConfig(state).refetchOnMountOrArgChange;
        const fulfilledVal = requestState === null || requestState === void 0 ? void 0 : requestState.fulfilledTimeStamp;
        var _arg_forceRefetch;
        const refetchVal = (_arg_forceRefetch = arg.forceRefetch) !== null && _arg_forceRefetch !== void 0 ? _arg_forceRefetch : arg.subscribe && baseFetchOnMountOrArgChange;
        if (refetchVal) {
            return refetchVal === true || (Number(/* @__PURE__ */ new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;
        }
        return false;
    }
    const createQueryThunk = ()=>{
        const generatedQueryThunk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAsyncThunk"])("".concat(reducerPath, "/executeQuery"), executeEndpoint, {
            getPendingMeta (param) {
                let { arg } = param;
                const endpointDefinition = endpointDefinitions[arg.endpointName];
                return addShouldAutoBatch({
                    startedTimeStamp: Date.now(),
                    ...isInfiniteQueryDefinition(endpointDefinition) ? {
                        direction: arg.direction
                    } : {}
                });
            },
            condition (queryThunkArg, param) {
                let { getState } = param;
                var _endpointDefinition_forceRefetch;
                const state = getState();
                const requestState = selectors.selectQueryEntry(state, queryThunkArg.queryCacheKey);
                const fulfilledVal = requestState === null || requestState === void 0 ? void 0 : requestState.fulfilledTimeStamp;
                const currentArg = queryThunkArg.originalArgs;
                const previousArg = requestState === null || requestState === void 0 ? void 0 : requestState.originalArgs;
                const endpointDefinition = endpointDefinitions[queryThunkArg.endpointName];
                const direction = queryThunkArg.direction;
                if (isUpsertQuery(queryThunkArg)) {
                    return true;
                }
                if ((requestState === null || requestState === void 0 ? void 0 : requestState.status) === "pending") {
                    return false;
                }
                if (isForcedQuery(queryThunkArg, state)) {
                    return true;
                }
                if (isQueryDefinition(endpointDefinition) && (endpointDefinition === null || endpointDefinition === void 0 ? void 0 : (_endpointDefinition_forceRefetch = endpointDefinition.forceRefetch) === null || _endpointDefinition_forceRefetch === void 0 ? void 0 : _endpointDefinition_forceRefetch.call(endpointDefinition, {
                    currentArg,
                    previousArg,
                    endpointState: requestState,
                    state
                }))) {
                    return true;
                }
                if (fulfilledVal && !direction) {
                    return false;
                }
                return true;
            },
            dispatchConditionRejection: true
        });
        return generatedQueryThunk;
    };
    const queryThunk = createQueryThunk();
    const infiniteQueryThunk = createQueryThunk();
    const mutationThunk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAsyncThunk"])("".concat(reducerPath, "/executeMutation"), executeEndpoint, {
        getPendingMeta () {
            return addShouldAutoBatch({
                startedTimeStamp: Date.now()
            });
        }
    });
    const hasTheForce = (options)=>"force" in options;
    const hasMaxAge = (options)=>"ifOlderThan" in options;
    const prefetch = (endpointName, arg, options)=>(dispatch, getState)=>{
            const force = hasTheForce(options) && options.force;
            const maxAge = hasMaxAge(options) && options.ifOlderThan;
            const queryAction = function() {
                let force2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                const options2 = {
                    forceRefetch: force2,
                    isPrefetch: true
                };
                return api.endpoints[endpointName].initiate(arg, options2);
            };
            const latestStateValue = api.endpoints[endpointName].select(arg)(getState());
            if (force) {
                dispatch(queryAction());
            } else if (maxAge) {
                const lastFulfilledTs = latestStateValue === null || latestStateValue === void 0 ? void 0 : latestStateValue.fulfilledTimeStamp;
                if (!lastFulfilledTs) {
                    dispatch(queryAction());
                    return;
                }
                const shouldRetrigger = (Number(/* @__PURE__ */ new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;
                if (shouldRetrigger) {
                    dispatch(queryAction());
                }
            } else {
                dispatch(queryAction(false));
            }
        };
    function matchesEndpoint(endpointName) {
        return (action)=>{
            var _action_meta_arg, _action_meta;
            return (action === null || action === void 0 ? void 0 : (_action_meta = action.meta) === null || _action_meta === void 0 ? void 0 : (_action_meta_arg = _action_meta.arg) === null || _action_meta_arg === void 0 ? void 0 : _action_meta_arg.endpointName) === endpointName;
        };
    }
    function buildMatchThunkActions(thunk, endpointName) {
        return {
            matchPending: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isAllOf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isPending"])(thunk), matchesEndpoint(endpointName)),
            matchFulfilled: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isAllOf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isFulfilled"])(thunk), matchesEndpoint(endpointName)),
            matchRejected: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isAllOf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isRejected"])(thunk), matchesEndpoint(endpointName))
        };
    }
    return {
        queryThunk,
        mutationThunk,
        infiniteQueryThunk,
        prefetch,
        updateQueryData,
        upsertQueryData,
        patchQueryData,
        buildMatchThunkActions
    };
}
function getNextPageParam(options, param, queryArg) {
    let { pages, pageParams } = param;
    const lastIndex = pages.length - 1;
    return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams, queryArg);
}
function getPreviousPageParam(options, param, queryArg) {
    let { pages, pageParams } = param;
    var _options_getPreviousPageParam;
    return (_options_getPreviousPageParam = options.getPreviousPageParam) === null || _options_getPreviousPageParam === void 0 ? void 0 : _options_getPreviousPageParam.call(options, pages[0], pages, pageParams[0], pageParams, queryArg);
}
function calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {
    return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isFulfilled"])(action) ? action.payload : void 0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isRejectedWithValue"])(action) ? action.payload : void 0, action.meta.arg.originalArgs, "baseQueryMeta" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);
}
;
;
function updateQuerySubstateIfExists(state, queryCacheKey, update) {
    const substate = state[queryCacheKey];
    if (substate) {
        update(substate);
    }
}
function getMutationCacheKey(id) {
    var _ref;
    return (_ref = "arg" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) !== null && _ref !== void 0 ? _ref : id.requestId;
}
function updateMutationSubstateIfExists(state, id, update) {
    const substate = state[getMutationCacheKey(id)];
    if (substate) {
        update(substate);
    }
}
var initialState = {};
function buildSlice(param) {
    let { reducerPath, queryThunk, mutationThunk, serializeQueryArgs, context: { endpointDefinitions: definitions, apiUid, extractRehydrationInfo, hasRehydrationInfo }, assertTagType, config } = param;
    const resetApiState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAction"])("".concat(reducerPath, "/resetApiState"));
    function writePendingCacheEntry(draft, arg, upserting, meta) {
        var _draft, _arg_queryCacheKey;
        var _;
        (_ = (_draft = draft)[_arg_queryCacheKey = arg.queryCacheKey]) !== null && _ !== void 0 ? _ : _draft[_arg_queryCacheKey] = {
            status: "uninitialized" /* uninitialized */ ,
            endpointName: arg.endpointName
        };
        updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate)=>{
            substate.status = "pending" /* pending */ ;
            substate.requestId = upserting && substate.requestId ? // for `upsertQuery` **updates**, keep the current `requestId`
            substate.requestId : // for normal queries or `upsertQuery` **inserts** always update the `requestId`
            meta.requestId;
            if (arg.originalArgs !== void 0) {
                substate.originalArgs = arg.originalArgs;
            }
            substate.startedTimeStamp = meta.startedTimeStamp;
            const endpointDefinition = definitions[meta.arg.endpointName];
            if (isInfiniteQueryDefinition(endpointDefinition) && "direction" in arg) {
                ;
                substate.direction = arg.direction;
            }
        });
    }
    function writeFulfilledCacheEntry(draft, meta, payload, upserting) {
        updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, (substate)=>{
            if (substate.requestId !== meta.requestId && !upserting) return;
            const { merge } = definitions[meta.arg.endpointName];
            substate.status = "fulfilled" /* fulfilled */ ;
            if (merge) {
                if (substate.data !== void 0) {
                    const { fulfilledTimeStamp, arg, baseQueryMeta, requestId } = meta;
                    let newData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__produce__as__createNextState$3e$__["createNextState"])(substate.data, (draftSubstateData)=>{
                        return merge(draftSubstateData, payload, {
                            arg: arg.originalArgs,
                            baseQueryMeta,
                            fulfilledTimeStamp,
                            requestId
                        });
                    });
                    substate.data = newData;
                } else {
                    substate.data = payload;
                }
            } else {
                var _definitions_meta_arg_endpointName_structuralSharing;
                substate.data = ((_definitions_meta_arg_endpointName_structuralSharing = definitions[meta.arg.endpointName].structuralSharing) !== null && _definitions_meta_arg_endpointName_structuralSharing !== void 0 ? _definitions_meta_arg_endpointName_structuralSharing : true) ? copyWithStructuralSharing((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDraft"])(substate.data) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["original"])(substate.data) : substate.data, payload) : payload;
            }
            delete substate.error;
            substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
        });
    }
    const querySlice = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createSlice"])({
        name: "".concat(reducerPath, "/queries"),
        initialState,
        reducers: {
            removeQueryResult: {
                reducer (draft, param) {
                    let { payload: { queryCacheKey } } = param;
                    delete draft[queryCacheKey];
                },
                prepare: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["prepareAutoBatched"])()
            },
            cacheEntriesUpserted: {
                reducer (draft, action) {
                    for (const entry of action.payload){
                        const { queryDescription: arg, value } = entry;
                        writePendingCacheEntry(draft, arg, true, {
                            arg,
                            requestId: action.meta.requestId,
                            startedTimeStamp: action.meta.timestamp
                        });
                        writeFulfilledCacheEntry(draft, {
                            arg,
                            requestId: action.meta.requestId,
                            fulfilledTimeStamp: action.meta.timestamp,
                            baseQueryMeta: {}
                        }, value, // We know we're upserting here
                        true);
                    }
                },
                prepare: (payload)=>{
                    const queryDescriptions = payload.map((entry)=>{
                        const { endpointName, arg, value } = entry;
                        const endpointDefinition = definitions[endpointName];
                        const queryDescription = {
                            type: "query",
                            endpointName,
                            originalArgs: entry.arg,
                            queryCacheKey: serializeQueryArgs({
                                queryArgs: arg,
                                endpointDefinition,
                                endpointName
                            })
                        };
                        return {
                            queryDescription,
                            value
                        };
                    });
                    const result = {
                        payload: queryDescriptions,
                        meta: {
                            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["SHOULD_AUTOBATCH"]]: true,
                            requestId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nanoid"])(),
                            timestamp: Date.now()
                        }
                    };
                    return result;
                }
            },
            queryResultPatched: {
                reducer (draft, param) {
                    let { payload: { queryCacheKey, patches } } = param;
                    updateQuerySubstateIfExists(draft, queryCacheKey, (substate)=>{
                        substate.data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyPatches"])(substate.data, patches.concat());
                    });
                },
                prepare: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["prepareAutoBatched"])()
            }
        },
        extraReducers (builder) {
            builder.addCase(queryThunk.pending, (draft, param)=>{
                let { meta, meta: { arg } } = param;
                const upserting = isUpsertQuery(arg);
                writePendingCacheEntry(draft, arg, upserting, meta);
            }).addCase(queryThunk.fulfilled, (draft, param)=>{
                let { meta, payload } = param;
                const upserting = isUpsertQuery(meta.arg);
                writeFulfilledCacheEntry(draft, meta, payload, upserting);
            }).addCase(queryThunk.rejected, (draft, param)=>{
                let { meta: { condition, arg, requestId }, error, payload } = param;
                updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate)=>{
                    if (condition) {} else {
                        if (substate.requestId !== requestId) return;
                        substate.status = "rejected" /* rejected */ ;
                        substate.error = payload !== null && payload !== void 0 ? payload : error;
                    }
                });
            }).addMatcher(hasRehydrationInfo, (draft, action)=>{
                const { queries } = extractRehydrationInfo(action);
                for (const [key, entry] of Object.entries(queries)){
                    if (// do not rehydrate entries that were currently in flight.
                    (entry === null || entry === void 0 ? void 0 : entry.status) === "fulfilled" /* fulfilled */  || (entry === null || entry === void 0 ? void 0 : entry.status) === "rejected" /* rejected */ ) {
                        draft[key] = entry;
                    }
                }
            });
        }
    });
    const mutationSlice = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createSlice"])({
        name: "".concat(reducerPath, "/mutations"),
        initialState,
        reducers: {
            removeMutationResult: {
                reducer (draft, param) {
                    let { payload } = param;
                    const cacheKey = getMutationCacheKey(payload);
                    if (cacheKey in draft) {
                        delete draft[cacheKey];
                    }
                },
                prepare: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["prepareAutoBatched"])()
            }
        },
        extraReducers (builder) {
            builder.addCase(mutationThunk.pending, (draft, param)=>{
                let { meta, meta: { requestId, arg, startedTimeStamp } } = param;
                if (!arg.track) return;
                draft[getMutationCacheKey(meta)] = {
                    requestId,
                    status: "pending" /* pending */ ,
                    endpointName: arg.endpointName,
                    startedTimeStamp
                };
            }).addCase(mutationThunk.fulfilled, (draft, param)=>{
                let { payload, meta } = param;
                if (!meta.arg.track) return;
                updateMutationSubstateIfExists(draft, meta, (substate)=>{
                    if (substate.requestId !== meta.requestId) return;
                    substate.status = "fulfilled" /* fulfilled */ ;
                    substate.data = payload;
                    substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
                });
            }).addCase(mutationThunk.rejected, (draft, param)=>{
                let { payload, error, meta } = param;
                if (!meta.arg.track) return;
                updateMutationSubstateIfExists(draft, meta, (substate)=>{
                    if (substate.requestId !== meta.requestId) return;
                    substate.status = "rejected" /* rejected */ ;
                    substate.error = payload !== null && payload !== void 0 ? payload : error;
                });
            }).addMatcher(hasRehydrationInfo, (draft, action)=>{
                const { mutations } = extractRehydrationInfo(action);
                for (const [key, entry] of Object.entries(mutations)){
                    if (// do not rehydrate entries that were currently in flight.
                    ((entry === null || entry === void 0 ? void 0 : entry.status) === "fulfilled" /* fulfilled */  || (entry === null || entry === void 0 ? void 0 : entry.status) === "rejected" /* rejected */ ) && // only rehydrate endpoints that were persisted using a `fixedCacheKey`
                    key !== (entry === null || entry === void 0 ? void 0 : entry.requestId)) {
                        draft[key] = entry;
                    }
                }
            });
        }
    });
    const initialInvalidationState = {
        tags: {},
        keys: {}
    };
    const invalidationSlice = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createSlice"])({
        name: "".concat(reducerPath, "/invalidation"),
        initialState: initialInvalidationState,
        reducers: {
            updateProvidedBy: {
                reducer (draft, action) {
                    for (const { queryCacheKey, providedTags } of action.payload){
                        removeCacheKeyFromTags(draft, queryCacheKey);
                        for (const { type, id } of providedTags){
                            var _draft_tags, _type, _ref, _ref1;
                            var _, _1;
                            const subscribedQueries = (_1 = (_ref = (_ = (_draft_tags = draft.tags)[_type = type]) !== null && _ !== void 0 ? _ : _draft_tags[_type] = {})[_ref1 = id || "__internal_without_id"]) !== null && _1 !== void 0 ? _1 : _ref[_ref1] = [];
                            const alreadySubscribed = subscribedQueries.includes(queryCacheKey);
                            if (!alreadySubscribed) {
                                subscribedQueries.push(queryCacheKey);
                            }
                        }
                        draft.keys[queryCacheKey] = providedTags;
                    }
                },
                prepare: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["prepareAutoBatched"])()
            }
        },
        extraReducers (builder) {
            builder.addCase(querySlice.actions.removeQueryResult, (draft, param)=>{
                let { payload: { queryCacheKey } } = param;
                removeCacheKeyFromTags(draft, queryCacheKey);
            }).addMatcher(hasRehydrationInfo, (draft, action)=>{
                const { provided } = extractRehydrationInfo(action);
                for (const [type, incomingTags] of Object.entries(provided)){
                    for (const [id, cacheKeys] of Object.entries(incomingTags)){
                        var _draft_tags, _type, _ref, _ref1;
                        var _, _1;
                        const subscribedQueries = (_1 = (_ref = (_ = (_draft_tags = draft.tags)[_type = type]) !== null && _ !== void 0 ? _ : _draft_tags[_type] = {})[_ref1 = id || "__internal_without_id"]) !== null && _1 !== void 0 ? _1 : _ref[_ref1] = [];
                        for (const queryCacheKey of cacheKeys){
                            const alreadySubscribed = subscribedQueries.includes(queryCacheKey);
                            if (!alreadySubscribed) {
                                subscribedQueries.push(queryCacheKey);
                            }
                        }
                    }
                }
            }).addMatcher((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isAnyOf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isFulfilled"])(queryThunk), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isRejectedWithValue"])(queryThunk)), (draft, action)=>{
                writeProvidedTagsForQueries(draft, [
                    action
                ]);
            }).addMatcher(querySlice.actions.cacheEntriesUpserted.match, (draft, action)=>{
                const mockActions = action.payload.map((param)=>{
                    let { queryDescription, value } = param;
                    return {
                        type: "UNKNOWN",
                        payload: value,
                        meta: {
                            requestStatus: "fulfilled",
                            requestId: "UNKNOWN",
                            arg: queryDescription
                        }
                    };
                });
                writeProvidedTagsForQueries(draft, mockActions);
            });
        }
    });
    function removeCacheKeyFromTags(draft, queryCacheKey) {
        var _draft_keys_queryCacheKey;
        const existingTags = (_draft_keys_queryCacheKey = draft.keys[queryCacheKey]) !== null && _draft_keys_queryCacheKey !== void 0 ? _draft_keys_queryCacheKey : [];
        for (const tag of existingTags){
            var _draft_tags_tagType;
            const tagType = tag.type;
            var _tag_id;
            const tagId = (_tag_id = tag.id) !== null && _tag_id !== void 0 ? _tag_id : "__internal_without_id";
            const tagSubscriptions = (_draft_tags_tagType = draft.tags[tagType]) === null || _draft_tags_tagType === void 0 ? void 0 : _draft_tags_tagType[tagId];
            if (tagSubscriptions) {
                draft.tags[tagType][tagId] = tagSubscriptions.filter((qc)=>qc !== queryCacheKey);
            }
        }
        delete draft.keys[queryCacheKey];
    }
    function writeProvidedTagsForQueries(draft, actions2) {
        const providedByEntries = actions2.map((action)=>{
            const providedTags = calculateProvidedByThunk(action, "providesTags", definitions, assertTagType);
            const { queryCacheKey } = action.meta.arg;
            return {
                queryCacheKey,
                providedTags
            };
        });
        invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy(providedByEntries));
    }
    const subscriptionSlice = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createSlice"])({
        name: "".concat(reducerPath, "/subscriptions"),
        initialState,
        reducers: {
            updateSubscriptionOptions (d, a) {},
            unsubscribeQueryResult (d, a) {},
            internal_getRTKQSubscriptions () {}
        }
    });
    const internalSubscriptionsSlice = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createSlice"])({
        name: "".concat(reducerPath, "/internalSubscriptions"),
        initialState,
        reducers: {
            subscriptionsUpdated: {
                reducer (state, action) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyPatches"])(state, action.payload);
                },
                prepare: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["prepareAutoBatched"])()
            }
        }
    });
    const configSlice = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createSlice"])({
        name: "".concat(reducerPath, "/config"),
        initialState: {
            online: isOnline(),
            focused: isDocumentVisible(),
            middlewareRegistered: false,
            ...config
        },
        reducers: {
            middlewareRegistered (state, param) {
                let { payload } = param;
                state.middlewareRegistered = state.middlewareRegistered === "conflict" || apiUid !== payload ? "conflict" : true;
            }
        },
        extraReducers: (builder)=>{
            builder.addCase(onOnline, (state)=>{
                state.online = true;
            }).addCase(onOffline, (state)=>{
                state.online = false;
            }).addCase(onFocus, (state)=>{
                state.focused = true;
            }).addCase(onFocusLost, (state)=>{
                state.focused = false;
            }).addMatcher(hasRehydrationInfo, (draft)=>({
                    ...draft
                }));
        }
    });
    const combinedReducer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["combineReducers"])({
        queries: querySlice.reducer,
        mutations: mutationSlice.reducer,
        provided: invalidationSlice.reducer,
        subscriptions: internalSubscriptionsSlice.reducer,
        config: configSlice.reducer
    });
    const reducer = (state, action)=>combinedReducer(resetApiState.match(action) ? void 0 : state, action);
    const actions = {
        ...configSlice.actions,
        ...querySlice.actions,
        ...subscriptionSlice.actions,
        ...internalSubscriptionsSlice.actions,
        ...mutationSlice.actions,
        ...invalidationSlice.actions,
        resetApiState
    };
    return {
        reducer,
        actions
    };
}
// src/query/core/buildSelectors.ts
var skipToken = /* @__PURE__ */ Symbol.for("RTKQ/skipToken");
var initialSubState = {
    status: "uninitialized" /* uninitialized */ 
};
var defaultQuerySubState = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__produce__as__createNextState$3e$__["createNextState"])(initialSubState, ()=>{});
var defaultMutationSubState = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__produce__as__createNextState$3e$__["createNextState"])(initialSubState, ()=>{});
function buildSelectors(param) {
    let { serializeQueryArgs, reducerPath, createSelector: createSelector2 } = param;
    const selectSkippedQuery = (state)=>defaultQuerySubState;
    const selectSkippedMutation = (state)=>defaultMutationSubState;
    return {
        buildQuerySelector,
        buildInfiniteQuerySelector,
        buildMutationSelector,
        selectInvalidatedBy,
        selectCachedArgsForQuery,
        selectApiState,
        selectQueries,
        selectMutations,
        selectQueryEntry,
        selectConfig
    };
    //TURBOPACK unreachable
    ;
    function withRequestFlags(substate) {
        return {
            ...substate,
            ...getRequestStatusFlags(substate.status)
        };
    }
    function selectApiState(rootState) {
        const state = rootState[reducerPath];
        if ("TURBOPACK compile-time truthy", 1) {
            if (!state) {
                if (selectApiState.triggered) return state;
                selectApiState.triggered = true;
                console.error("Error: No data found at `state.".concat(reducerPath, "`. Did you forget to add the reducer to the store?"));
            }
        }
        return state;
    }
    function selectQueries(rootState) {
        var _selectApiState;
        return (_selectApiState = selectApiState(rootState)) === null || _selectApiState === void 0 ? void 0 : _selectApiState.queries;
    }
    function selectQueryEntry(rootState, cacheKey) {
        var _selectQueries;
        return (_selectQueries = selectQueries(rootState)) === null || _selectQueries === void 0 ? void 0 : _selectQueries[cacheKey];
    }
    function selectMutations(rootState) {
        var _selectApiState;
        return (_selectApiState = selectApiState(rootState)) === null || _selectApiState === void 0 ? void 0 : _selectApiState.mutations;
    }
    function selectConfig(rootState) {
        var _selectApiState;
        return (_selectApiState = selectApiState(rootState)) === null || _selectApiState === void 0 ? void 0 : _selectApiState.config;
    }
    function buildAnyQuerySelector(endpointName, endpointDefinition, combiner) {
        return (queryArgs)=>{
            if (queryArgs === skipToken) {
                return createSelector2(selectSkippedQuery, combiner);
            }
            const serializedArgs = serializeQueryArgs({
                queryArgs,
                endpointDefinition,
                endpointName
            });
            const selectQuerySubstate = (state)=>{
                var _selectQueryEntry;
                return (_selectQueryEntry = selectQueryEntry(state, serializedArgs)) !== null && _selectQueryEntry !== void 0 ? _selectQueryEntry : defaultQuerySubState;
            };
            return createSelector2(selectQuerySubstate, combiner);
        };
    }
    function buildQuerySelector(endpointName, endpointDefinition) {
        return buildAnyQuerySelector(endpointName, endpointDefinition, withRequestFlags);
    }
    function buildInfiniteQuerySelector(endpointName, endpointDefinition) {
        const { infiniteQueryOptions } = endpointDefinition;
        function withInfiniteQueryResultFlags(substate) {
            const stateWithRequestFlags = {
                ...substate,
                ...getRequestStatusFlags(substate.status)
            };
            const { isLoading, isError, direction } = stateWithRequestFlags;
            const isForward = direction === "forward";
            const isBackward = direction === "backward";
            return {
                ...stateWithRequestFlags,
                hasNextPage: getHasNextPage(infiniteQueryOptions, stateWithRequestFlags.data, stateWithRequestFlags.originalArgs),
                hasPreviousPage: getHasPreviousPage(infiniteQueryOptions, stateWithRequestFlags.data, stateWithRequestFlags.originalArgs),
                isFetchingNextPage: isLoading && isForward,
                isFetchingPreviousPage: isLoading && isBackward,
                isFetchNextPageError: isError && isForward,
                isFetchPreviousPageError: isError && isBackward
            };
        }
        return buildAnyQuerySelector(endpointName, endpointDefinition, withInfiniteQueryResultFlags);
    }
    function buildMutationSelector() {
        return (id)=>{
            let mutationId;
            if (typeof id === "object") {
                var _getMutationCacheKey;
                mutationId = (_getMutationCacheKey = getMutationCacheKey(id)) !== null && _getMutationCacheKey !== void 0 ? _getMutationCacheKey : skipToken;
            } else {
                mutationId = id;
            }
            const selectMutationSubstate = (state)=>{
                var _selectApiState_mutations, _selectApiState;
                var _selectApiState_mutations_mutationId;
                return (_selectApiState_mutations_mutationId = (_selectApiState = selectApiState(state)) === null || _selectApiState === void 0 ? void 0 : (_selectApiState_mutations = _selectApiState.mutations) === null || _selectApiState_mutations === void 0 ? void 0 : _selectApiState_mutations[mutationId]) !== null && _selectApiState_mutations_mutationId !== void 0 ? _selectApiState_mutations_mutationId : defaultMutationSubState;
            };
            const finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;
            return createSelector2(finalSelectMutationSubstate, withRequestFlags);
        };
    }
    function selectInvalidatedBy(state, tags) {
        const apiState = state[reducerPath];
        const toInvalidate = /* @__PURE__ */ new Set();
        for (const tag of tags.filter(isNotNullish).map(expandTagDescription)){
            const provided = apiState.provided.tags[tag.type];
            if (!provided) {
                continue;
            }
            var _ref;
            let invalidateSubscriptions = (_ref = tag.id !== void 0 ? // id given: invalidate all queries that provide this type & id
            provided[tag.id] : // no id: invalidate all queries that provide this type
            flatten(Object.values(provided))) !== null && _ref !== void 0 ? _ref : [];
            for (const invalidate of invalidateSubscriptions){
                toInvalidate.add(invalidate);
            }
        }
        return flatten(Array.from(toInvalidate.values()).map((queryCacheKey)=>{
            const querySubState = apiState.queries[queryCacheKey];
            return querySubState ? [
                {
                    queryCacheKey,
                    endpointName: querySubState.endpointName,
                    originalArgs: querySubState.originalArgs
                }
            ] : [];
        }));
    }
    function selectCachedArgsForQuery(state, queryName) {
        return Object.values(selectQueries(state)).filter((entry)=>(entry === null || entry === void 0 ? void 0 : entry.endpointName) === queryName && entry.status !== "uninitialized" /* uninitialized */ ).map((entry)=>entry.originalArgs);
    }
    function getHasNextPage(options, data, queryArg) {
        if (!data) return false;
        return getNextPageParam(options, data, queryArg) != null;
    }
    function getHasPreviousPage(options, data, queryArg) {
        if (!data || !options.getPreviousPageParam) return false;
        return getPreviousPageParam(options, data, queryArg) != null;
    }
}
;
// src/query/defaultSerializeQueryArgs.ts
var cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;
var defaultSerializeQueryArgs = (param)=>{
    let { endpointName, queryArgs } = param;
    let serialized = "";
    const cached = cache === null || cache === void 0 ? void 0 : cache.get(queryArgs);
    if (typeof cached === "string") {
        serialized = cached;
    } else {
        const stringified = JSON.stringify(queryArgs, (key, value)=>{
            value = typeof value === "bigint" ? {
                $bigint: value.toString()
            } : value;
            value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value) ? Object.keys(value).sort().reduce((acc, key2)=>{
                acc[key2] = value[key2];
                return acc;
            }, {}) : value;
            return value;
        });
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(queryArgs)) {
            cache === null || cache === void 0 ? void 0 : cache.set(queryArgs, stringified);
        }
        serialized = stringified;
    }
    return "".concat(endpointName, "(").concat(serialized, ")");
};
;
function buildCreateApi() {
    for(var _len = arguments.length, modules = new Array(_len), _key = 0; _key < _len; _key++){
        modules[_key] = arguments[_key];
    }
    return function baseCreateApi(options) {
        const extractRehydrationInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$reselect$2f$dist$2f$reselect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weakMapMemoize"])((action)=>{
            var _options_extractRehydrationInfo;
            var _options_reducerPath;
            return (_options_extractRehydrationInfo = options.extractRehydrationInfo) === null || _options_extractRehydrationInfo === void 0 ? void 0 : _options_extractRehydrationInfo.call(options, action, {
                reducerPath: (_options_reducerPath = options.reducerPath) !== null && _options_reducerPath !== void 0 ? _options_reducerPath : "api"
            });
        });
        const optionsWithDefaults = {
            reducerPath: "api",
            keepUnusedDataFor: 60,
            refetchOnMountOrArgChange: false,
            refetchOnFocus: false,
            refetchOnReconnect: false,
            invalidationBehavior: "delayed",
            ...options,
            extractRehydrationInfo,
            serializeQueryArgs (queryArgsApi) {
                let finalSerializeQueryArgs = defaultSerializeQueryArgs;
                if ("serializeQueryArgs" in queryArgsApi.endpointDefinition) {
                    const endpointSQA = queryArgsApi.endpointDefinition.serializeQueryArgs;
                    finalSerializeQueryArgs = (queryArgsApi2)=>{
                        const initialResult = endpointSQA(queryArgsApi2);
                        if (typeof initialResult === "string") {
                            return initialResult;
                        } else {
                            return defaultSerializeQueryArgs({
                                ...queryArgsApi2,
                                queryArgs: initialResult
                            });
                        }
                    };
                } else if (options.serializeQueryArgs) {
                    finalSerializeQueryArgs = options.serializeQueryArgs;
                }
                return finalSerializeQueryArgs(queryArgsApi);
            },
            tagTypes: [
                ...options.tagTypes || []
            ]
        };
        const context = {
            endpointDefinitions: {},
            batch (fn) {
                fn();
            },
            apiUid: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["nanoid"])(),
            extractRehydrationInfo,
            hasRehydrationInfo: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$reselect$2f$dist$2f$reselect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weakMapMemoize"])((action)=>extractRehydrationInfo(action) != null)
        };
        const api = {
            injectEndpoints,
            enhanceEndpoints (param) {
                let { addTagTypes, endpoints } = param;
                if (addTagTypes) {
                    for (const eT of addTagTypes){
                        if (!optionsWithDefaults.tagTypes.includes(eT)) {
                            ;
                            optionsWithDefaults.tagTypes.push(eT);
                        }
                    }
                }
                if (endpoints) {
                    for (const [endpointName, partialDefinition] of Object.entries(endpoints)){
                        if (typeof partialDefinition === "function") {
                            partialDefinition(context.endpointDefinitions[endpointName]);
                        } else {
                            Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);
                        }
                    }
                }
                return api;
            }
        };
        const initializedModules = modules.map((m)=>m.init(api, optionsWithDefaults, context));
        function injectEndpoints(inject) {
            const evaluatedEndpoints = inject.endpoints({
                query: (x)=>({
                        ...x,
                        type: "query" /* query */ 
                    }),
                mutation: (x)=>({
                        ...x,
                        type: "mutation" /* mutation */ 
                    }),
                infiniteQuery: (x)=>({
                        ...x,
                        type: "infinitequery" /* infinitequery */ 
                    })
            });
            for (const [endpointName, definition] of Object.entries(evaluatedEndpoints)){
                if (inject.overrideExisting !== true && endpointName in context.endpointDefinitions) {
                    if (inject.overrideExisting === "throw") {
                        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "called `injectEndpoints` to override already-existing endpointName ".concat(endpointName, " without specifying `overrideExisting: true`"));
                    } else if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && ("TURBOPACK compile-time value", "development") === "development") {
                        console.error("called `injectEndpoints` to override already-existing endpointName ".concat(endpointName, " without specifying `overrideExisting: true`"));
                    }
                    continue;
                }
                if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && ("TURBOPACK compile-time value", "development") === "development") {
                    if (isInfiniteQueryDefinition(definition)) {
                        const { infiniteQueryOptions } = definition;
                        const { maxPages, getPreviousPageParam: getPreviousPageParam2 } = infiniteQueryOptions;
                        if (typeof maxPages === "number") {
                            if (maxPages < 1) {
                                throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "maxPages for endpoint '".concat(endpointName, "' must be a number greater than 0"));
                            }
                            if (typeof getPreviousPageParam2 !== "function") {
                                throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "getPreviousPageParam for endpoint '".concat(endpointName, "' must be a function if maxPages is used"));
                            }
                        }
                    }
                }
                context.endpointDefinitions[endpointName] = definition;
                for (const m of initializedModules){
                    m.injectEndpoint(endpointName, definition);
                }
            }
            return api;
        }
        return api.injectEndpoints({
            endpoints: options.endpoints
        });
    };
}
;
var _NEVER = /* @__PURE__ */ Symbol();
function fakeBaseQuery() {
    return function() {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "When using `fakeBaseQuery`, all queries & mutations must use the `queryFn` definition syntax.");
    };
}
;
// src/query/tsHelpers.ts
function assertCast(v) {}
function safeAssign(target) {
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        args[_key - 1] = arguments[_key];
    }
    return Object.assign(target, ...args);
}
;
var buildBatchedActionsHandler = (param)=>{
    let { api, queryThunk, internalState } = param;
    const subscriptionsPrefix = "".concat(api.reducerPath, "/subscriptions");
    let previousSubscriptions = null;
    let updateSyncTimer = null;
    const { updateSubscriptionOptions, unsubscribeQueryResult } = api.internalActions;
    const actuallyMutateSubscriptions = (mutableState, action)=>{
        if (updateSubscriptionOptions.match(action)) {
            var _mutableState_queryCacheKey;
            const { queryCacheKey, requestId, options } = action.payload;
            if (mutableState === null || mutableState === void 0 ? void 0 : (_mutableState_queryCacheKey = mutableState[queryCacheKey]) === null || _mutableState_queryCacheKey === void 0 ? void 0 : _mutableState_queryCacheKey[requestId]) {
                mutableState[queryCacheKey][requestId] = options;
            }
            return true;
        }
        if (unsubscribeQueryResult.match(action)) {
            const { queryCacheKey, requestId } = action.payload;
            if (mutableState[queryCacheKey]) {
                delete mutableState[queryCacheKey][requestId];
            }
            return true;
        }
        if (api.internalActions.removeQueryResult.match(action)) {
            delete mutableState[action.payload.queryCacheKey];
            return true;
        }
        if (queryThunk.pending.match(action)) {
            var _mutableState, _arg_queryCacheKey;
            const { meta: { arg, requestId } } = action;
            var _;
            const substate = (_ = (_mutableState = mutableState)[_arg_queryCacheKey = arg.queryCacheKey]) !== null && _ !== void 0 ? _ : _mutableState[_arg_queryCacheKey] = {};
            substate["".concat(requestId, "_running")] = {};
            if (arg.subscribe) {
                var _arg_subscriptionOptions, _ref;
                substate[requestId] = (_ref = (_arg_subscriptionOptions = arg.subscriptionOptions) !== null && _arg_subscriptionOptions !== void 0 ? _arg_subscriptionOptions : substate[requestId]) !== null && _ref !== void 0 ? _ref : {};
            }
            return true;
        }
        let mutated = false;
        if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action)) {
            const state = mutableState[action.meta.arg.queryCacheKey] || {};
            const key = "".concat(action.meta.requestId, "_running");
            mutated || (mutated = !!state[key]);
            delete state[key];
        }
        if (queryThunk.rejected.match(action)) {
            const { meta: { condition, arg, requestId } } = action;
            if (condition && arg.subscribe) {
                var _mutableState1, _arg_queryCacheKey1;
                var _1;
                const substate = (_1 = (_mutableState1 = mutableState)[_arg_queryCacheKey1 = arg.queryCacheKey]) !== null && _1 !== void 0 ? _1 : _mutableState1[_arg_queryCacheKey1] = {};
                var _arg_subscriptionOptions1, _ref1;
                substate[requestId] = (_ref1 = (_arg_subscriptionOptions1 = arg.subscriptionOptions) !== null && _arg_subscriptionOptions1 !== void 0 ? _arg_subscriptionOptions1 : substate[requestId]) !== null && _ref1 !== void 0 ? _ref1 : {};
                mutated = true;
            }
        }
        return mutated;
    };
    const getSubscriptions = ()=>internalState.currentSubscriptions;
    const getSubscriptionCount = (queryCacheKey)=>{
        const subscriptions = getSubscriptions();
        var _subscriptions_queryCacheKey;
        const subscriptionsForQueryArg = (_subscriptions_queryCacheKey = subscriptions[queryCacheKey]) !== null && _subscriptions_queryCacheKey !== void 0 ? _subscriptions_queryCacheKey : {};
        return countObjectKeys(subscriptionsForQueryArg);
    };
    const isRequestSubscribed = (queryCacheKey, requestId)=>{
        var _subscriptions_queryCacheKey;
        const subscriptions = getSubscriptions();
        return !!(subscriptions === null || subscriptions === void 0 ? void 0 : (_subscriptions_queryCacheKey = subscriptions[queryCacheKey]) === null || _subscriptions_queryCacheKey === void 0 ? void 0 : _subscriptions_queryCacheKey[requestId]);
    };
    const subscriptionSelectors = {
        getSubscriptions,
        getSubscriptionCount,
        isRequestSubscribed
    };
    return (action, mwApi)=>{
        if (!previousSubscriptions) {
            previousSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));
        }
        if (api.util.resetApiState.match(action)) {
            previousSubscriptions = internalState.currentSubscriptions = {};
            updateSyncTimer = null;
            return [
                true,
                false
            ];
        }
        if (api.internalActions.internal_getRTKQSubscriptions.match(action)) {
            return [
                false,
                subscriptionSelectors
            ];
        }
        const didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);
        let actionShouldContinue = true;
        if (didMutate) {
            if (!updateSyncTimer) {
                updateSyncTimer = setTimeout(()=>{
                    const newSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));
                    const [, patches] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["produceWithPatches"])(previousSubscriptions, ()=>newSubscriptions);
                    mwApi.next(api.internalActions.subscriptionsUpdated(patches));
                    previousSubscriptions = newSubscriptions;
                    updateSyncTimer = null;
                }, 500);
            }
            const isSubscriptionSliceAction = typeof action.type == "string" && !!action.type.startsWith(subscriptionsPrefix);
            const isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;
            actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;
        }
        return [
            actionShouldContinue,
            false
        ];
    };
};
// src/query/core/buildMiddleware/cacheCollection.ts
function isObjectEmpty(obj) {
    for(const k in obj){
        return false;
    }
    return true;
}
var THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;
var buildCacheCollectionHandler = (param)=>{
    let { reducerPath, api, queryThunk, context, internalState, selectors: { selectQueryEntry, selectConfig } } = param;
    const { removeQueryResult, unsubscribeQueryResult, cacheEntriesUpserted } = api.internalActions;
    const canTriggerUnsubscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isAnyOf"])(unsubscribeQueryResult.match, queryThunk.fulfilled, queryThunk.rejected, cacheEntriesUpserted.match);
    function anySubscriptionsRemainingForKey(queryCacheKey) {
        const subscriptions = internalState.currentSubscriptions[queryCacheKey];
        return !!subscriptions && !isObjectEmpty(subscriptions);
    }
    const currentRemovalTimeouts = {};
    const handler = (action, mwApi, internalState2)=>{
        const state = mwApi.getState();
        const config = selectConfig(state);
        if (canTriggerUnsubscribe(action)) {
            let queryCacheKeys;
            if (cacheEntriesUpserted.match(action)) {
                queryCacheKeys = action.payload.map((entry)=>entry.queryDescription.queryCacheKey);
            } else {
                const { queryCacheKey } = unsubscribeQueryResult.match(action) ? action.payload : action.meta.arg;
                queryCacheKeys = [
                    queryCacheKey
                ];
            }
            handleUnsubscribeMany(queryCacheKeys, mwApi, config);
        }
        if (api.util.resetApiState.match(action)) {
            for (const [key, timeout] of Object.entries(currentRemovalTimeouts)){
                if (timeout) clearTimeout(timeout);
                delete currentRemovalTimeouts[key];
            }
        }
        if (context.hasRehydrationInfo(action)) {
            const { queries } = context.extractRehydrationInfo(action);
            handleUnsubscribeMany(Object.keys(queries), mwApi, config);
        }
    };
    function handleUnsubscribeMany(cacheKeys, api2, config) {
        const state = api2.getState();
        for (const queryCacheKey of cacheKeys){
            const entry = selectQueryEntry(state, queryCacheKey);
            handleUnsubscribe(queryCacheKey, entry === null || entry === void 0 ? void 0 : entry.endpointName, api2, config);
        }
    }
    function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {
        const endpointDefinition = context.endpointDefinitions[endpointName];
        var _endpointDefinition_keepUnusedDataFor;
        const keepUnusedDataFor = (_endpointDefinition_keepUnusedDataFor = endpointDefinition === null || endpointDefinition === void 0 ? void 0 : endpointDefinition.keepUnusedDataFor) !== null && _endpointDefinition_keepUnusedDataFor !== void 0 ? _endpointDefinition_keepUnusedDataFor : config.keepUnusedDataFor;
        if (keepUnusedDataFor === Infinity) {
            return;
        }
        const finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));
        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
            const currentTimeout = currentRemovalTimeouts[queryCacheKey];
            if (currentTimeout) {
                clearTimeout(currentTimeout);
            }
            currentRemovalTimeouts[queryCacheKey] = setTimeout(()=>{
                if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
                    api2.dispatch(removeQueryResult({
                        queryCacheKey
                    }));
                }
                delete currentRemovalTimeouts[queryCacheKey];
            }, finalKeepUnusedDataFor * 1e3);
        }
    }
    return handler;
};
// src/query/core/buildMiddleware/cacheLifecycle.ts
var neverResolvedError = new Error("Promise never resolved before cacheEntryRemoved.");
var buildCacheLifecycleHandler = (param)=>{
    let { api, reducerPath, context, queryThunk, mutationThunk, internalState, selectors: { selectQueryEntry, selectApiState } } = param;
    const isQueryThunk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isAsyncThunkAction"])(queryThunk);
    const isMutationThunk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isAsyncThunkAction"])(mutationThunk);
    const isFulfilledThunk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isFulfilled"])(queryThunk, mutationThunk);
    const lifecycleMap = {};
    function resolveLifecycleEntry(cacheKey, data, meta) {
        const lifecycle = lifecycleMap[cacheKey];
        if (lifecycle === null || lifecycle === void 0 ? void 0 : lifecycle.valueResolved) {
            lifecycle.valueResolved({
                data,
                meta
            });
            delete lifecycle.valueResolved;
        }
    }
    function removeLifecycleEntry(cacheKey) {
        const lifecycle = lifecycleMap[cacheKey];
        if (lifecycle) {
            delete lifecycleMap[cacheKey];
            lifecycle.cacheEntryRemoved();
        }
    }
    const handler = (action, mwApi, stateBefore)=>{
        const cacheKey = getCacheKey(action);
        function checkForNewCacheKey(endpointName, cacheKey2, requestId, originalArgs) {
            const oldEntry = selectQueryEntry(stateBefore, cacheKey2);
            const newEntry = selectQueryEntry(mwApi.getState(), cacheKey2);
            if (!oldEntry && newEntry) {
                handleNewKey(endpointName, originalArgs, cacheKey2, mwApi, requestId);
            }
        }
        if (queryThunk.pending.match(action)) {
            checkForNewCacheKey(action.meta.arg.endpointName, cacheKey, action.meta.requestId, action.meta.arg.originalArgs);
        } else if (api.internalActions.cacheEntriesUpserted.match(action)) {
            for (const { queryDescription, value } of action.payload){
                const { endpointName, originalArgs, queryCacheKey } = queryDescription;
                checkForNewCacheKey(endpointName, queryCacheKey, action.meta.requestId, originalArgs);
                resolveLifecycleEntry(queryCacheKey, value, {});
            }
        } else if (mutationThunk.pending.match(action)) {
            const state = mwApi.getState()[reducerPath].mutations[cacheKey];
            if (state) {
                handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);
            }
        } else if (isFulfilledThunk(action)) {
            resolveLifecycleEntry(cacheKey, action.payload, action.meta.baseQueryMeta);
        } else if (api.internalActions.removeQueryResult.match(action) || api.internalActions.removeMutationResult.match(action)) {
            removeLifecycleEntry(cacheKey);
        } else if (api.util.resetApiState.match(action)) {
            for (const cacheKey2 of Object.keys(lifecycleMap)){
                removeLifecycleEntry(cacheKey2);
            }
        }
    };
    function getCacheKey(action) {
        if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;
        if (isMutationThunk(action)) {
            var _action_meta_arg_fixedCacheKey;
            return (_action_meta_arg_fixedCacheKey = action.meta.arg.fixedCacheKey) !== null && _action_meta_arg_fixedCacheKey !== void 0 ? _action_meta_arg_fixedCacheKey : action.meta.requestId;
        }
        if (api.internalActions.removeQueryResult.match(action)) return action.payload.queryCacheKey;
        if (api.internalActions.removeMutationResult.match(action)) return getMutationCacheKey(action.payload);
        return "";
    }
    function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {
        const endpointDefinition = context.endpointDefinitions[endpointName];
        const onCacheEntryAdded = endpointDefinition === null || endpointDefinition === void 0 ? void 0 : endpointDefinition.onCacheEntryAdded;
        if (!onCacheEntryAdded) return;
        const lifecycle = {};
        const cacheEntryRemoved = new Promise((resolve)=>{
            lifecycle.cacheEntryRemoved = resolve;
        });
        const cacheDataLoaded = Promise.race([
            new Promise((resolve)=>{
                lifecycle.valueResolved = resolve;
            }),
            cacheEntryRemoved.then(()=>{
                throw neverResolvedError;
            })
        ]);
        cacheDataLoaded.catch(()=>{});
        lifecycleMap[queryCacheKey] = lifecycle;
        const selector = api.endpoints[endpointName].select(isAnyQueryDefinition(endpointDefinition) ? originalArgs : queryCacheKey);
        const extra = mwApi.dispatch((_, __, extra2)=>extra2);
        const lifecycleApi = {
            ...mwApi,
            getCacheEntry: ()=>selector(mwApi.getState()),
            requestId,
            extra,
            updateCachedData: isAnyQueryDefinition(endpointDefinition) ? (updateRecipe)=>mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,
            cacheDataLoaded,
            cacheEntryRemoved
        };
        const runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);
        Promise.resolve(runningHandler).catch((e)=>{
            if (e === neverResolvedError) return;
            throw e;
        });
    }
    return handler;
};
// src/query/core/buildMiddleware/devMiddleware.ts
var buildDevCheckHandler = (param)=>{
    let { api, context: { apiUid }, reducerPath } = param;
    return (action, mwApi)=>{
        if (api.util.resetApiState.match(action)) {
            mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));
        }
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && ("TURBOPACK compile-time value", "development") === "development") {
            var _mwApi_getState_reducerPath_config, _mwApi_getState_reducerPath;
            if (api.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && ((_mwApi_getState_reducerPath = mwApi.getState()[reducerPath]) === null || _mwApi_getState_reducerPath === void 0 ? void 0 : (_mwApi_getState_reducerPath_config = _mwApi_getState_reducerPath.config) === null || _mwApi_getState_reducerPath_config === void 0 ? void 0 : _mwApi_getState_reducerPath_config.middlewareRegistered) === "conflict") {
                console.warn('There is a mismatch between slice and middleware for the reducerPath "'.concat(reducerPath, '".\nYou can only have one api per reducer path, this will lead to crashes in various situations!').concat(reducerPath === "api" ? "\nIf you have multiple apis, you *have* to specify the reducerPath option when using createApi!" : ""));
            }
        }
    };
};
// src/query/core/buildMiddleware/invalidationByTags.ts
var buildInvalidationByTagsHandler = (param)=>{
    let { reducerPath, context, context: { endpointDefinitions }, mutationThunk, queryThunk, api, assertTagType, refetchQuery, internalState } = param;
    const { removeQueryResult } = api.internalActions;
    const isThunkActionWithTags = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isAnyOf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isFulfilled"])(mutationThunk), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isRejectedWithValue"])(mutationThunk));
    const isQueryEnd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isAnyOf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isFulfilled"])(mutationThunk, queryThunk), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isRejected"])(mutationThunk, queryThunk));
    let pendingTagInvalidations = [];
    const handler = (action, mwApi)=>{
        if (isThunkActionWithTags(action)) {
            invalidateTags(calculateProvidedByThunk(action, "invalidatesTags", endpointDefinitions, assertTagType), mwApi);
        } else if (isQueryEnd(action)) {
            invalidateTags([], mwApi);
        } else if (api.util.invalidateTags.match(action)) {
            invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);
        }
    };
    function hasPendingRequests(state) {
        const { queries, mutations } = state;
        for (const cacheRecord of [
            queries,
            mutations
        ]){
            for(const key in cacheRecord){
                var _cacheRecord_key;
                if (((_cacheRecord_key = cacheRecord[key]) === null || _cacheRecord_key === void 0 ? void 0 : _cacheRecord_key.status) === "pending" /* pending */ ) return true;
            }
        }
        return false;
    }
    function invalidateTags(newTags, mwApi) {
        const rootState = mwApi.getState();
        const state = rootState[reducerPath];
        pendingTagInvalidations.push(...newTags);
        if (state.config.invalidationBehavior === "delayed" && hasPendingRequests(state)) {
            return;
        }
        const tags = pendingTagInvalidations;
        pendingTagInvalidations = [];
        if (tags.length === 0) return;
        const toInvalidate = api.util.selectInvalidatedBy(rootState, tags);
        context.batch(()=>{
            const valuesArray = Array.from(toInvalidate.values());
            for (const { queryCacheKey } of valuesArray){
                const querySubState = state.queries[queryCacheKey];
                var _internalState_currentSubscriptions_queryCacheKey;
                const subscriptionSubState = (_internalState_currentSubscriptions_queryCacheKey = internalState.currentSubscriptions[queryCacheKey]) !== null && _internalState_currentSubscriptions_queryCacheKey !== void 0 ? _internalState_currentSubscriptions_queryCacheKey : {};
                if (querySubState) {
                    if (countObjectKeys(subscriptionSubState) === 0) {
                        mwApi.dispatch(removeQueryResult({
                            queryCacheKey
                        }));
                    } else if (querySubState.status !== "uninitialized" /* uninitialized */ ) {
                        mwApi.dispatch(refetchQuery(querySubState));
                    }
                }
            }
        });
    }
    return handler;
};
// src/query/core/buildMiddleware/polling.ts
var buildPollingHandler = (param)=>{
    let { reducerPath, queryThunk, api, refetchQuery, internalState } = param;
    const currentPolls = {};
    const handler = (action, mwApi)=>{
        if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {
            updatePollingInterval(action.payload, mwApi);
        }
        if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {
            updatePollingInterval(action.meta.arg, mwApi);
        }
        if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {
            startNextPoll(action.meta.arg, mwApi);
        }
        if (api.util.resetApiState.match(action)) {
            clearPolls();
        }
    };
    function getCacheEntrySubscriptions(queryCacheKey, api2) {
        const state = api2.getState()[reducerPath];
        const querySubState = state.queries[queryCacheKey];
        const subscriptions = internalState.currentSubscriptions[queryCacheKey];
        if (!querySubState || querySubState.status === "uninitialized" /* uninitialized */ ) return;
        return subscriptions;
    }
    function startNextPoll(param, api2) {
        let { queryCacheKey } = param;
        const state = api2.getState()[reducerPath];
        const querySubState = state.queries[queryCacheKey];
        const subscriptions = internalState.currentSubscriptions[queryCacheKey];
        if (!querySubState || querySubState.status === "uninitialized" /* uninitialized */ ) return;
        const { lowestPollingInterval, skipPollingIfUnfocused } = findLowestPollingInterval(subscriptions);
        if (!Number.isFinite(lowestPollingInterval)) return;
        const currentPoll = currentPolls[queryCacheKey];
        if (currentPoll === null || currentPoll === void 0 ? void 0 : currentPoll.timeout) {
            clearTimeout(currentPoll.timeout);
            currentPoll.timeout = void 0;
        }
        const nextPollTimestamp = Date.now() + lowestPollingInterval;
        currentPolls[queryCacheKey] = {
            nextPollTimestamp,
            pollingInterval: lowestPollingInterval,
            timeout: setTimeout(()=>{
                if (state.config.focused || !skipPollingIfUnfocused) {
                    api2.dispatch(refetchQuery(querySubState));
                }
                startNextPoll({
                    queryCacheKey
                }, api2);
            }, lowestPollingInterval)
        };
    }
    function updatePollingInterval(param, api2) {
        let { queryCacheKey } = param;
        const state = api2.getState()[reducerPath];
        const querySubState = state.queries[queryCacheKey];
        const subscriptions = internalState.currentSubscriptions[queryCacheKey];
        if (!querySubState || querySubState.status === "uninitialized" /* uninitialized */ ) {
            return;
        }
        const { lowestPollingInterval } = findLowestPollingInterval(subscriptions);
        if (!Number.isFinite(lowestPollingInterval)) {
            cleanupPollForKey(queryCacheKey);
            return;
        }
        const currentPoll = currentPolls[queryCacheKey];
        const nextPollTimestamp = Date.now() + lowestPollingInterval;
        if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {
            startNextPoll({
                queryCacheKey
            }, api2);
        }
    }
    function cleanupPollForKey(key) {
        const existingPoll = currentPolls[key];
        if (existingPoll === null || existingPoll === void 0 ? void 0 : existingPoll.timeout) {
            clearTimeout(existingPoll.timeout);
        }
        delete currentPolls[key];
    }
    function clearPolls() {
        for (const key of Object.keys(currentPolls)){
            cleanupPollForKey(key);
        }
    }
    function findLowestPollingInterval() {
        let subscribers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let skipPollingIfUnfocused = false;
        let lowestPollingInterval = Number.POSITIVE_INFINITY;
        for(let key in subscribers){
            if (!!subscribers[key].pollingInterval) {
                lowestPollingInterval = Math.min(subscribers[key].pollingInterval, lowestPollingInterval);
                skipPollingIfUnfocused = subscribers[key].skipPollingIfUnfocused || skipPollingIfUnfocused;
            }
        }
        return {
            lowestPollingInterval,
            skipPollingIfUnfocused
        };
    }
    return handler;
};
// src/query/core/buildMiddleware/queryLifecycle.ts
var buildQueryLifecycleHandler = (param)=>{
    let { api, context, queryThunk, mutationThunk } = param;
    const isPendingThunk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isPending"])(queryThunk, mutationThunk);
    const isRejectedThunk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isRejected"])(queryThunk, mutationThunk);
    const isFullfilledThunk = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isFulfilled"])(queryThunk, mutationThunk);
    const lifecycleMap = {};
    const handler = (action, mwApi)=>{
        if (isPendingThunk(action)) {
            const { requestId, arg: { endpointName, originalArgs } } = action.meta;
            const endpointDefinition = context.endpointDefinitions[endpointName];
            const onQueryStarted = endpointDefinition === null || endpointDefinition === void 0 ? void 0 : endpointDefinition.onQueryStarted;
            if (onQueryStarted) {
                const lifecycle = {};
                const queryFulfilled = new Promise((resolve, reject)=>{
                    lifecycle.resolve = resolve;
                    lifecycle.reject = reject;
                });
                queryFulfilled.catch(()=>{});
                lifecycleMap[requestId] = lifecycle;
                const selector = api.endpoints[endpointName].select(isAnyQueryDefinition(endpointDefinition) ? originalArgs : requestId);
                const extra = mwApi.dispatch((_, __, extra2)=>extra2);
                const lifecycleApi = {
                    ...mwApi,
                    getCacheEntry: ()=>selector(mwApi.getState()),
                    requestId,
                    extra,
                    updateCachedData: isAnyQueryDefinition(endpointDefinition) ? (updateRecipe)=>mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,
                    queryFulfilled
                };
                onQueryStarted(originalArgs, lifecycleApi);
            }
        } else if (isFullfilledThunk(action)) {
            var _lifecycleMap_requestId;
            const { requestId, baseQueryMeta } = action.meta;
            (_lifecycleMap_requestId = lifecycleMap[requestId]) === null || _lifecycleMap_requestId === void 0 ? void 0 : _lifecycleMap_requestId.resolve({
                data: action.payload,
                meta: baseQueryMeta
            });
            delete lifecycleMap[requestId];
        } else if (isRejectedThunk(action)) {
            var _lifecycleMap_requestId1;
            const { requestId, rejectedWithValue, baseQueryMeta } = action.meta;
            var _action_payload;
            (_lifecycleMap_requestId1 = lifecycleMap[requestId]) === null || _lifecycleMap_requestId1 === void 0 ? void 0 : _lifecycleMap_requestId1.reject({
                error: (_action_payload = action.payload) !== null && _action_payload !== void 0 ? _action_payload : action.error,
                isUnhandledError: !rejectedWithValue,
                meta: baseQueryMeta
            });
            delete lifecycleMap[requestId];
        }
    };
    return handler;
};
// src/query/core/buildMiddleware/windowEventHandling.ts
var buildWindowEventHandler = (param)=>{
    let { reducerPath, context, api, refetchQuery, internalState } = param;
    const { removeQueryResult } = api.internalActions;
    const handler = (action, mwApi)=>{
        if (onFocus.match(action)) {
            refetchValidQueries(mwApi, "refetchOnFocus");
        }
        if (onOnline.match(action)) {
            refetchValidQueries(mwApi, "refetchOnReconnect");
        }
    };
    function refetchValidQueries(api2, type) {
        const state = api2.getState()[reducerPath];
        const queries = state.queries;
        const subscriptions = internalState.currentSubscriptions;
        context.batch(()=>{
            for (const queryCacheKey of Object.keys(subscriptions)){
                const querySubState = queries[queryCacheKey];
                const subscriptionSubState = subscriptions[queryCacheKey];
                if (!subscriptionSubState || !querySubState) continue;
                const shouldRefetch = Object.values(subscriptionSubState).some((sub)=>sub[type] === true) || Object.values(subscriptionSubState).every((sub)=>sub[type] === void 0) && state.config[type];
                if (shouldRefetch) {
                    if (countObjectKeys(subscriptionSubState) === 0) {
                        api2.dispatch(removeQueryResult({
                            queryCacheKey
                        }));
                    } else if (querySubState.status !== "uninitialized" /* uninitialized */ ) {
                        api2.dispatch(refetchQuery(querySubState));
                    }
                }
            }
        });
    }
    return handler;
};
// src/query/core/buildMiddleware/index.ts
function buildMiddleware(input) {
    const { reducerPath, queryThunk, api, context } = input;
    const { apiUid } = context;
    const actions = {
        invalidateTags: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAction"])("".concat(reducerPath, "/invalidateTags"))
    };
    const isThisApiSliceAction = (action)=>action.type.startsWith("".concat(reducerPath, "/"));
    const handlerBuilders = [
        buildDevCheckHandler,
        buildCacheCollectionHandler,
        buildInvalidationByTagsHandler,
        buildPollingHandler,
        buildCacheLifecycleHandler,
        buildQueryLifecycleHandler
    ];
    const middleware = (mwApi)=>{
        let initialized2 = false;
        const internalState = {
            currentSubscriptions: {}
        };
        const builderArgs = {
            ...input,
            internalState,
            refetchQuery,
            isThisApiSliceAction
        };
        const handlers = handlerBuilders.map((build)=>build(builderArgs));
        const batchedActionsHandler = buildBatchedActionsHandler(builderArgs);
        const windowEventsHandler = buildWindowEventHandler(builderArgs);
        return (next)=>{
            return (action)=>{
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redux$2f$dist$2f$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAction"])(action)) {
                    return next(action);
                }
                if (!initialized2) {
                    initialized2 = true;
                    mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));
                }
                const mwApiWithNext = {
                    ...mwApi,
                    next
                };
                const stateBefore = mwApi.getState();
                const [actionShouldContinue, internalProbeResult] = batchedActionsHandler(action, mwApiWithNext, stateBefore);
                let res;
                if (actionShouldContinue) {
                    res = next(action);
                } else {
                    res = internalProbeResult;
                }
                if (!!mwApi.getState()[reducerPath]) {
                    windowEventsHandler(action, mwApiWithNext, stateBefore);
                    if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {
                        for (const handler of handlers){
                            handler(action, mwApiWithNext, stateBefore);
                        }
                    }
                }
                return res;
            };
        };
    };
    return {
        middleware,
        actions
    };
    //TURBOPACK unreachable
    ;
    function refetchQuery(querySubState) {
        return input.api.endpoints[querySubState.endpointName].initiate(querySubState.originalArgs, {
            subscribe: false,
            forceRefetch: true
        });
    }
}
// src/query/core/module.ts
var coreModuleName = /* @__PURE__ */ Symbol();
var coreModule = function() {
    let { createSelector: createSelector2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$reselect$2f$dist$2f$reselect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSelector"] } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return {
        name: coreModuleName,
        init (api, param, context) {
            let { baseQuery, tagTypes, reducerPath, serializeQueryArgs, keepUnusedDataFor, refetchOnMountOrArgChange, refetchOnFocus, refetchOnReconnect, invalidationBehavior, onSchemaFailure, catchSchemaFailure, skipSchemaValidation } = param;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enablePatches"])();
            assertCast(serializeQueryArgs);
            const assertTagType = (tag)=>{
                if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && ("TURBOPACK compile-time value", "development") === "development") {
                    if (!tagTypes.includes(tag.type)) {
                        console.error("Tag type '".concat(tag.type, "' was used, but not specified in `tagTypes`!"));
                    }
                }
                return tag;
            };
            Object.assign(api, {
                reducerPath,
                endpoints: {},
                internalActions: {
                    onOnline,
                    onOffline,
                    onFocus,
                    onFocusLost
                },
                util: {}
            });
            const selectors = buildSelectors({
                serializeQueryArgs,
                reducerPath,
                createSelector: createSelector2
            });
            const { selectInvalidatedBy, selectCachedArgsForQuery, buildQuerySelector, buildInfiniteQuerySelector, buildMutationSelector } = selectors;
            safeAssign(api.util, {
                selectInvalidatedBy,
                selectCachedArgsForQuery
            });
            const { queryThunk, infiniteQueryThunk, mutationThunk, patchQueryData, updateQueryData, upsertQueryData, prefetch, buildMatchThunkActions } = buildThunks({
                baseQuery,
                reducerPath,
                context,
                api,
                serializeQueryArgs,
                assertTagType,
                selectors,
                onSchemaFailure,
                catchSchemaFailure,
                skipSchemaValidation
            });
            const { reducer, actions: sliceActions } = buildSlice({
                context,
                queryThunk,
                infiniteQueryThunk,
                mutationThunk,
                serializeQueryArgs,
                reducerPath,
                assertTagType,
                config: {
                    refetchOnFocus,
                    refetchOnReconnect,
                    refetchOnMountOrArgChange,
                    keepUnusedDataFor,
                    reducerPath,
                    invalidationBehavior
                }
            });
            safeAssign(api.util, {
                patchQueryData,
                updateQueryData,
                upsertQueryData,
                prefetch,
                resetApiState: sliceActions.resetApiState,
                upsertQueryEntries: sliceActions.cacheEntriesUpserted
            });
            safeAssign(api.internalActions, sliceActions);
            const { middleware, actions: middlewareActions } = buildMiddleware({
                reducerPath,
                context,
                queryThunk,
                mutationThunk,
                infiniteQueryThunk,
                api,
                assertTagType,
                selectors
            });
            safeAssign(api.util, middlewareActions);
            safeAssign(api, {
                reducer,
                middleware
            });
            const { buildInitiateQuery, buildInitiateInfiniteQuery, buildInitiateMutation, getRunningMutationThunk, getRunningMutationsThunk, getRunningQueriesThunk, getRunningQueryThunk } = buildInitiate({
                queryThunk,
                mutationThunk,
                infiniteQueryThunk,
                api,
                serializeQueryArgs,
                context
            });
            safeAssign(api.util, {
                getRunningMutationThunk,
                getRunningMutationsThunk,
                getRunningQueryThunk,
                getRunningQueriesThunk
            });
            return {
                name: coreModuleName,
                injectEndpoint (endpointName, definition) {
                    var _anyApi_endpoints, _endpointName;
                    const anyApi = api;
                    var _;
                    const endpoint = (_ = (_anyApi_endpoints = anyApi.endpoints)[_endpointName = endpointName]) !== null && _ !== void 0 ? _ : _anyApi_endpoints[_endpointName] = {};
                    if (isQueryDefinition(definition)) {
                        safeAssign(endpoint, {
                            name: endpointName,
                            select: buildQuerySelector(endpointName, definition),
                            initiate: buildInitiateQuery(endpointName, definition)
                        }, buildMatchThunkActions(queryThunk, endpointName));
                    }
                    if (isMutationDefinition(definition)) {
                        safeAssign(endpoint, {
                            name: endpointName,
                            select: buildMutationSelector(),
                            initiate: buildInitiateMutation(endpointName)
                        }, buildMatchThunkActions(mutationThunk, endpointName));
                    }
                    if (isInfiniteQueryDefinition(definition)) {
                        safeAssign(endpoint, {
                            name: endpointName,
                            select: buildInfiniteQuerySelector(endpointName, definition),
                            initiate: buildInitiateInfiniteQuery(endpointName, definition)
                        }, buildMatchThunkActions(queryThunk, endpointName));
                    }
                }
            };
        }
    };
};
// src/query/core/index.ts
var createApi = /* @__PURE__ */ buildCreateApi(coreModule());
;
 //# sourceMappingURL=rtk-query.modern.mjs.map
}),
"[project]/node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

// src/query/react/index.ts
__turbopack_context__.s({
    "ApiProvider": ()=>ApiProvider,
    "UNINITIALIZED_VALUE": ()=>UNINITIALIZED_VALUE,
    "createApi": ()=>createApi,
    "reactHooksModule": ()=>reactHooksModule,
    "reactHooksModuleName": ()=>reactHooksModuleName
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$query$2f$rtk$2d$query$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$redux$2f$dist$2f$react$2d$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-redux/dist/react-redux.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$reselect$2f$dist$2f$reselect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/reselect/dist/reselect.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
// src/query/react/ApiProvider.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs [app-client] (ecmascript) <locals>");
;
;
;
;
// src/query/utils/capitalize.ts
function capitalize(str) {
    return str.replace(str[0], str[0].toUpperCase());
}
// src/query/utils/countObjectKeys.ts
function countObjectKeys(obj) {
    let count = 0;
    for(const _key in obj){
        count++;
    }
    return count;
}
// src/query/endpointDefinitions.ts
function isQueryDefinition(e) {
    return e.type === "query" /* query */ ;
}
function isMutationDefinition(e) {
    return e.type === "mutation" /* mutation */ ;
}
function isInfiniteQueryDefinition(e) {
    return e.type === "infinitequery" /* infinitequery */ ;
}
// src/query/tsHelpers.ts
function safeAssign(target) {
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        args[_key - 1] = arguments[_key];
    }
    return Object.assign(target, ...args);
}
;
;
;
;
// src/query/react/constants.ts
var UNINITIALIZED_VALUE = Symbol();
;
function useStableQueryArgs(queryArgs, serialize, endpointDefinition, endpointName) {
    const incoming = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useStableQueryArgs.useMemo[incoming]": ()=>({
                queryArgs,
                serialized: typeof queryArgs == "object" ? serialize({
                    queryArgs,
                    endpointDefinition,
                    endpointName
                }) : queryArgs
            })
    }["useStableQueryArgs.useMemo[incoming]"], [
        queryArgs,
        serialize,
        endpointDefinition,
        endpointName
    ]);
    const cache = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(incoming);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useStableQueryArgs.useEffect": ()=>{
            if (cache.current.serialized !== incoming.serialized) {
                cache.current = incoming;
            }
        }
    }["useStableQueryArgs.useEffect"], [
        incoming
    ]);
    return cache.current.serialized === incoming.serialized ? cache.current.queryArgs : queryArgs;
}
;
;
function useShallowStableValue(value) {
    const cache = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(value);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useShallowStableValue.useEffect2": ()=>{
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$redux$2f$dist$2f$react$2d$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallowEqual"])(cache.current, value)) {
                cache.current = value;
            }
        }
    }["useShallowStableValue.useEffect2"], [
        value
    ]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$redux$2f$dist$2f$react$2d$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallowEqual"])(cache.current, value) ? cache.current : value;
}
// src/query/react/buildHooks.ts
var canUseDOM = ()=>!!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isDOM = /* @__PURE__ */ canUseDOM();
var isRunningInReactNative = ()=>typeof navigator !== "undefined" && navigator.product === "ReactNative";
var isReactNative = /* @__PURE__ */ isRunningInReactNative();
var getUseIsomorphicLayoutEffect = ()=>isDOM || isReactNative ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"];
var useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
var noPendingQueryStateSelector = (selected)=>{
    if (selected.isUninitialized) {
        return {
            ...selected,
            isUninitialized: false,
            isFetching: true,
            isLoading: selected.data !== void 0 ? false : true,
            status: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$query$2f$rtk$2d$query$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QueryStatus"].pending
        };
    }
    return selected;
};
function pick(obj) {
    for(var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        keys[_key - 1] = arguments[_key];
    }
    const ret = {};
    keys.forEach((key)=>{
        ret[key] = obj[key];
    });
    return ret;
}
var COMMON_HOOK_DEBUG_FIELDS = [
    "data",
    "status",
    "isLoading",
    "isSuccess",
    "isError",
    "error"
];
function buildHooks(param) {
    let { api, moduleOptions: { batch, hooks: { useDispatch, useSelector, useStore }, unstable__sideEffectsInRender, createSelector }, serializeQueryArgs, context } = param;
    const usePossiblyImmediateEffect = unstable__sideEffectsInRender ? (cb)=>cb() : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"];
    return {
        buildQueryHooks,
        buildInfiniteQueryHooks,
        buildMutationHook,
        usePrefetch
    };
    //TURBOPACK unreachable
    ;
    function queryStatePreSelector(currentState, lastResult, queryArgs) {
        if ((lastResult === null || lastResult === void 0 ? void 0 : lastResult.endpointName) && currentState.isUninitialized) {
            const { endpointName } = lastResult;
            const endpointDefinition = context.endpointDefinitions[endpointName];
            if (queryArgs !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$query$2f$rtk$2d$query$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["skipToken"] && serializeQueryArgs({
                queryArgs: lastResult.originalArgs,
                endpointDefinition,
                endpointName
            }) === serializeQueryArgs({
                queryArgs,
                endpointDefinition,
                endpointName
            })) lastResult = void 0;
        }
        let data = currentState.isSuccess ? currentState.data : lastResult === null || lastResult === void 0 ? void 0 : lastResult.data;
        if (data === void 0) data = currentState.data;
        const hasData = data !== void 0;
        const isFetching = currentState.isLoading;
        const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;
        const isSuccess = currentState.isSuccess || hasData && (isFetching && !(lastResult === null || lastResult === void 0 ? void 0 : lastResult.isError) || currentState.isUninitialized);
        return {
            ...currentState,
            data,
            currentData: currentState.data,
            isFetching,
            isLoading,
            isSuccess
        };
    }
    function infiniteQueryStatePreSelector(currentState, lastResult, queryArgs) {
        if ((lastResult === null || lastResult === void 0 ? void 0 : lastResult.endpointName) && currentState.isUninitialized) {
            const { endpointName } = lastResult;
            const endpointDefinition = context.endpointDefinitions[endpointName];
            if (queryArgs !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$query$2f$rtk$2d$query$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["skipToken"] && serializeQueryArgs({
                queryArgs: lastResult.originalArgs,
                endpointDefinition,
                endpointName
            }) === serializeQueryArgs({
                queryArgs,
                endpointDefinition,
                endpointName
            })) lastResult = void 0;
        }
        let data = currentState.isSuccess ? currentState.data : lastResult === null || lastResult === void 0 ? void 0 : lastResult.data;
        if (data === void 0) data = currentState.data;
        const hasData = data !== void 0;
        const isFetching = currentState.isLoading;
        const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;
        const isSuccess = currentState.isSuccess || isFetching && hasData;
        return {
            ...currentState,
            data,
            currentData: currentState.data,
            isFetching,
            isLoading,
            isSuccess
        };
    }
    function usePrefetch(endpointName, defaultOptions) {
        const dispatch = useDispatch();
        const stableDefaultOptions = useShallowStableValue(defaultOptions);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "buildHooks.usePrefetch.useCallback": (arg, options)=>dispatch(api.util.prefetch(endpointName, arg, {
                    ...stableDefaultOptions,
                    ...options
                }))
        }["buildHooks.usePrefetch.useCallback"], [
            endpointName,
            dispatch,
            stableDefaultOptions
        ]);
    }
    function useQuerySubscriptionCommonImpl(endpointName, arg) {
        let { refetchOnReconnect, refetchOnFocus, refetchOnMountOrArgChange, skip = false, pollingInterval = 0, skipPollingIfUnfocused = false, ...rest } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const { initiate } = api.endpoints[endpointName];
        const dispatch = useDispatch();
        const subscriptionSelectorsRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(void 0);
        if (!subscriptionSelectorsRef.current) {
            const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());
            if ("TURBOPACK compile-time truthy", 1) {
                if (typeof returnedValue !== "object" || typeof (returnedValue === null || returnedValue === void 0 ? void 0 : returnedValue.type) === "string") {
                    throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 'Warning: Middleware for RTK-Query API at reducerPath "'.concat(api.reducerPath, '" has not been added to the store.\n    You must add the middleware for RTK-Query to function correctly!'));
                }
            }
            subscriptionSelectorsRef.current = returnedValue;
        }
        const stableArg = useStableQueryArgs(skip ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$query$2f$rtk$2d$query$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["skipToken"] : arg, // Even if the user provided a per-endpoint `serializeQueryArgs` with
        // a consistent return value, _here_ we want to use the default behavior
        // so we can tell if _anything_ actually changed. Otherwise, we can end up
        // with a case where the query args did change but the serialization doesn't,
        // and then we never try to initiate a refetch.
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$query$2f$rtk$2d$query$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultSerializeQueryArgs"], context.endpointDefinitions[endpointName], endpointName);
        const stableSubscriptionOptions = useShallowStableValue({
            refetchOnReconnect,
            refetchOnFocus,
            pollingInterval,
            skipPollingIfUnfocused
        });
        const initialPageParam = rest.initialPageParam;
        const stableInitialPageParam = useShallowStableValue(initialPageParam);
        const promiseRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(void 0);
        let { queryCacheKey, requestId } = promiseRef.current || {};
        let currentRenderHasSubscription = false;
        if (queryCacheKey && requestId) {
            currentRenderHasSubscription = subscriptionSelectorsRef.current.isRequestSubscribed(queryCacheKey, requestId);
        }
        const subscriptionRemoved = !currentRenderHasSubscription && promiseRef.current !== void 0;
        usePossiblyImmediateEffect({
            "buildHooks.useQuerySubscriptionCommonImpl.usePossiblyImmediateEffect": ()=>{
                if (subscriptionRemoved) {
                    promiseRef.current = void 0;
                }
            }
        }["buildHooks.useQuerySubscriptionCommonImpl.usePossiblyImmediateEffect"], [
            subscriptionRemoved
        ]);
        usePossiblyImmediateEffect({
            "buildHooks.useQuerySubscriptionCommonImpl.usePossiblyImmediateEffect": ()=>{
                var _promiseRef_current;
                const lastPromise = promiseRef.current;
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                if (stableArg === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$query$2f$rtk$2d$query$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["skipToken"]) {
                    lastPromise === null || lastPromise === void 0 ? void 0 : lastPromise.unsubscribe();
                    promiseRef.current = void 0;
                    return;
                }
                const lastSubscriptionOptions = (_promiseRef_current = promiseRef.current) === null || _promiseRef_current === void 0 ? void 0 : _promiseRef_current.subscriptionOptions;
                if (!lastPromise || lastPromise.arg !== stableArg) {
                    lastPromise === null || lastPromise === void 0 ? void 0 : lastPromise.unsubscribe();
                    const promise = dispatch(initiate(stableArg, {
                        subscriptionOptions: stableSubscriptionOptions,
                        forceRefetch: refetchOnMountOrArgChange,
                        ...isInfiniteQueryDefinition(context.endpointDefinitions[endpointName]) ? {
                            initialPageParam: stableInitialPageParam
                        } : {}
                    }));
                    promiseRef.current = promise;
                } else if (stableSubscriptionOptions !== lastSubscriptionOptions) {
                    lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);
                }
            }
        }["buildHooks.useQuerySubscriptionCommonImpl.usePossiblyImmediateEffect"], [
            dispatch,
            initiate,
            refetchOnMountOrArgChange,
            stableArg,
            stableSubscriptionOptions,
            subscriptionRemoved,
            stableInitialPageParam,
            endpointName
        ]);
        return [
            promiseRef,
            dispatch,
            initiate,
            stableSubscriptionOptions
        ];
    }
    function buildUseQueryState(endpointName, preSelector) {
        const useQueryState = function(arg) {
            let { skip = false, selectFromResult } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            const { select } = api.endpoints[endpointName];
            const stableArg = useStableQueryArgs(skip ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$query$2f$rtk$2d$query$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["skipToken"] : arg, serializeQueryArgs, context.endpointDefinitions[endpointName], endpointName);
            const lastValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(void 0);
            const selectDefaultResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
                "buildHooks.buildUseQueryState.useQueryState.useMemo2[selectDefaultResult]": ()=>// Normally ts-ignores are bad and should be avoided, but we're
                    // already casting this selector to be `Selector<any>` anyway,
                    // so the inconsistencies don't matter here
                    // @ts-ignore
                    createSelector([
                        // @ts-ignore
                        select(stableArg),
                        {
                            "buildHooks.buildUseQueryState.useQueryState.useMemo2[selectDefaultResult]": (_, lastResult)=>lastResult
                        }["buildHooks.buildUseQueryState.useQueryState.useMemo2[selectDefaultResult]"],
                        {
                            "buildHooks.buildUseQueryState.useQueryState.useMemo2[selectDefaultResult]": (_)=>stableArg
                        }["buildHooks.buildUseQueryState.useQueryState.useMemo2[selectDefaultResult]"]
                    ], preSelector, {
                        memoizeOptions: {
                            resultEqualityCheck: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$redux$2f$dist$2f$react$2d$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallowEqual"]
                        }
                    })
            }["buildHooks.buildUseQueryState.useQueryState.useMemo2[selectDefaultResult]"], [
                select,
                stableArg
            ]);
            const querySelector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
                "buildHooks.buildUseQueryState.useQueryState.useMemo2[querySelector]": ()=>selectFromResult ? createSelector([
                        selectDefaultResult
                    ], selectFromResult, {
                        devModeChecks: {
                            identityFunctionCheck: "never"
                        }
                    }) : selectDefaultResult
            }["buildHooks.buildUseQueryState.useQueryState.useMemo2[querySelector]"], [
                selectDefaultResult,
                selectFromResult
            ]);
            const currentState = useSelector({
                "buildHooks.buildUseQueryState.useQueryState.useSelector[currentState]": (state)=>querySelector(state, lastValue.current)
            }["buildHooks.buildUseQueryState.useQueryState.useSelector[currentState]"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$redux$2f$dist$2f$react$2d$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallowEqual"]);
            const store = useStore();
            const newLastValue = selectDefaultResult(store.getState(), lastValue.current);
            useIsomorphicLayoutEffect({
                "buildHooks.buildUseQueryState.useQueryState.useIsomorphicLayoutEffect": ()=>{
                    lastValue.current = newLastValue;
                }
            }["buildHooks.buildUseQueryState.useQueryState.useIsomorphicLayoutEffect"], [
                newLastValue
            ]);
            return currentState;
        };
        return useQueryState;
    }
    function usePromiseRefUnsubscribeOnUnmount(promiseRef) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
            "buildHooks.usePromiseRefUnsubscribeOnUnmount.useEffect3": ()=>{
                return ({
                    "buildHooks.usePromiseRefUnsubscribeOnUnmount.useEffect3": ()=>{
                        var _promiseRef_current_unsubscribe, _promiseRef_current;
                        (_promiseRef_current = promiseRef.current) === null || _promiseRef_current === void 0 ? void 0 : (_promiseRef_current_unsubscribe = _promiseRef_current.unsubscribe) === null || _promiseRef_current_unsubscribe === void 0 ? void 0 : _promiseRef_current_unsubscribe.call(_promiseRef_current);
                        promiseRef.current = void 0;
                    }
                })["buildHooks.usePromiseRefUnsubscribeOnUnmount.useEffect3"];
            }
        }["buildHooks.usePromiseRefUnsubscribeOnUnmount.useEffect3"], [
            promiseRef
        ]);
    }
    function refetchOrErrorIfUnmounted(promiseRef) {
        if (!promiseRef.current) throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Cannot refetch a query that has not been started yet.");
        return promiseRef.current.refetch();
    }
    function buildQueryHooks(endpointName) {
        const useQuerySubscription = function(arg) {
            let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            const [promiseRef] = useQuerySubscriptionCommonImpl(endpointName, arg, options);
            usePromiseRefUnsubscribeOnUnmount(promiseRef);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
                "buildHooks.buildQueryHooks.useQuerySubscription.useMemo2": ()=>({
                        /**
         * A method to manually refetch data for the query
         */ refetch: ({
                            "buildHooks.buildQueryHooks.useQuerySubscription.useMemo2": ()=>refetchOrErrorIfUnmounted(promiseRef)
                        })["buildHooks.buildQueryHooks.useQuerySubscription.useMemo2"]
                    })
            }["buildHooks.buildQueryHooks.useQuerySubscription.useMemo2"], [
                promiseRef
            ]);
        };
        const useLazyQuerySubscription = function() {
            let { refetchOnReconnect, refetchOnFocus, pollingInterval = 0, skipPollingIfUnfocused = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            const { initiate } = api.endpoints[endpointName];
            const dispatch = useDispatch();
            const [arg, setArg] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(UNINITIALIZED_VALUE);
            const promiseRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(void 0);
            const stableSubscriptionOptions = useShallowStableValue({
                refetchOnReconnect,
                refetchOnFocus,
                pollingInterval,
                skipPollingIfUnfocused
            });
            usePossiblyImmediateEffect({
                "buildHooks.buildQueryHooks.useLazyQuerySubscription.usePossiblyImmediateEffect": ()=>{
                    var _promiseRef_current;
                    const lastSubscriptionOptions = (_promiseRef_current = promiseRef.current) === null || _promiseRef_current === void 0 ? void 0 : _promiseRef_current.subscriptionOptions;
                    if (stableSubscriptionOptions !== lastSubscriptionOptions) {
                        var _promiseRef_current1;
                        (_promiseRef_current1 = promiseRef.current) === null || _promiseRef_current1 === void 0 ? void 0 : _promiseRef_current1.updateSubscriptionOptions(stableSubscriptionOptions);
                    }
                }
            }["buildHooks.buildQueryHooks.useLazyQuerySubscription.usePossiblyImmediateEffect"], [
                stableSubscriptionOptions
            ]);
            const subscriptionOptionsRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(stableSubscriptionOptions);
            usePossiblyImmediateEffect({
                "buildHooks.buildQueryHooks.useLazyQuerySubscription.usePossiblyImmediateEffect": ()=>{
                    subscriptionOptionsRef.current = stableSubscriptionOptions;
                }
            }["buildHooks.buildQueryHooks.useLazyQuerySubscription.usePossiblyImmediateEffect"], [
                stableSubscriptionOptions
            ]);
            const trigger = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
                "buildHooks.buildQueryHooks.useLazyQuerySubscription.useCallback[trigger]": function(arg2) {
                    let preferCacheValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                    let promise;
                    batch({
                        "buildHooks.buildQueryHooks.useLazyQuerySubscription.useCallback[trigger]": ()=>{
                            var _promiseRef_current;
                            (_promiseRef_current = promiseRef.current) === null || _promiseRef_current === void 0 ? void 0 : _promiseRef_current.unsubscribe();
                            promiseRef.current = promise = dispatch(initiate(arg2, {
                                subscriptionOptions: subscriptionOptionsRef.current,
                                forceRefetch: !preferCacheValue
                            }));
                            setArg(arg2);
                        }
                    }["buildHooks.buildQueryHooks.useLazyQuerySubscription.useCallback[trigger]"]);
                    return promise;
                }
            }["buildHooks.buildQueryHooks.useLazyQuerySubscription.useCallback[trigger]"], [
                dispatch,
                initiate
            ]);
            const reset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
                "buildHooks.buildQueryHooks.useLazyQuerySubscription.useCallback[reset]": ()=>{
                    var _promiseRef_current;
                    if ((_promiseRef_current = promiseRef.current) === null || _promiseRef_current === void 0 ? void 0 : _promiseRef_current.queryCacheKey) {
                        var _promiseRef_current1;
                        dispatch(api.internalActions.removeQueryResult({
                            queryCacheKey: (_promiseRef_current1 = promiseRef.current) === null || _promiseRef_current1 === void 0 ? void 0 : _promiseRef_current1.queryCacheKey
                        }));
                    }
                }
            }["buildHooks.buildQueryHooks.useLazyQuerySubscription.useCallback[reset]"], [
                dispatch
            ]);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
                "buildHooks.buildQueryHooks.useLazyQuerySubscription.useEffect3": ()=>{
                    return ({
                        "buildHooks.buildQueryHooks.useLazyQuerySubscription.useEffect3": ()=>{
                            var _promiseRef_current;
                            promiseRef === null || promiseRef === void 0 ? void 0 : (_promiseRef_current = promiseRef.current) === null || _promiseRef_current === void 0 ? void 0 : _promiseRef_current.unsubscribe();
                        }
                    })["buildHooks.buildQueryHooks.useLazyQuerySubscription.useEffect3"];
                }
            }["buildHooks.buildQueryHooks.useLazyQuerySubscription.useEffect3"], []);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
                "buildHooks.buildQueryHooks.useLazyQuerySubscription.useEffect3": ()=>{
                    if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) {
                        trigger(arg, true);
                    }
                }
            }["buildHooks.buildQueryHooks.useLazyQuerySubscription.useEffect3"], [
                arg,
                trigger
            ]);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
                "buildHooks.buildQueryHooks.useLazyQuerySubscription.useMemo2": ()=>[
                        trigger,
                        arg,
                        {
                            reset
                        }
                    ]
            }["buildHooks.buildQueryHooks.useLazyQuerySubscription.useMemo2"], [
                trigger,
                arg,
                reset
            ]);
        };
        const useQueryState = buildUseQueryState(endpointName, queryStatePreSelector);
        return {
            useQueryState,
            useQuerySubscription,
            useLazyQuerySubscription,
            useLazyQuery (options) {
                const [trigger, arg, { reset }] = useLazyQuerySubscription(options);
                const queryStateResults = useQueryState(arg, {
                    ...options,
                    skip: arg === UNINITIALIZED_VALUE
                });
                const info = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
                    "buildHooks.buildQueryHooks.useMemo2[info]": ()=>({
                            lastArg: arg
                        })
                }["buildHooks.buildQueryHooks.useMemo2[info]"], [
                    arg
                ]);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
                    "buildHooks.buildQueryHooks.useMemo2": ()=>[
                            trigger,
                            {
                                ...queryStateResults,
                                reset
                            },
                            info
                        ]
                }["buildHooks.buildQueryHooks.useMemo2"], [
                    trigger,
                    queryStateResults,
                    reset,
                    info
                ]);
            },
            useQuery (arg, options) {
                const querySubscriptionResults = useQuerySubscription(arg, options);
                const queryStateResults = useQueryState(arg, {
                    selectFromResult: arg === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$query$2f$rtk$2d$query$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["skipToken"] || (options === null || options === void 0 ? void 0 : options.skip) ? void 0 : noPendingQueryStateSelector,
                    ...options
                });
                const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useDebugValue"])(debugValue);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
                    "buildHooks.buildQueryHooks.useMemo2": ()=>({
                            ...queryStateResults,
                            ...querySubscriptionResults
                        })
                }["buildHooks.buildQueryHooks.useMemo2"], [
                    queryStateResults,
                    querySubscriptionResults
                ]);
            }
        };
    }
    function buildInfiniteQueryHooks(endpointName) {
        const useInfiniteQuerySubscription = function(arg) {
            let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            const [promiseRef, dispatch, initiate, stableSubscriptionOptions] = useQuerySubscriptionCommonImpl(endpointName, arg, options);
            const subscriptionOptionsRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(stableSubscriptionOptions);
            usePossiblyImmediateEffect({
                "buildHooks.buildInfiniteQueryHooks.useInfiniteQuerySubscription.usePossiblyImmediateEffect": ()=>{
                    subscriptionOptionsRef.current = stableSubscriptionOptions;
                }
            }["buildHooks.buildInfiniteQueryHooks.useInfiniteQuerySubscription.usePossiblyImmediateEffect"], [
                stableSubscriptionOptions
            ]);
            const trigger = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
                "buildHooks.buildInfiniteQueryHooks.useInfiniteQuerySubscription.useCallback[trigger]": function(arg2, direction) {
                    let promise;
                    batch({
                        "buildHooks.buildInfiniteQueryHooks.useInfiniteQuerySubscription.useCallback[trigger]": ()=>{
                            var _promiseRef_current;
                            (_promiseRef_current = promiseRef.current) === null || _promiseRef_current === void 0 ? void 0 : _promiseRef_current.unsubscribe();
                            promiseRef.current = promise = dispatch(initiate(arg2, {
                                subscriptionOptions: subscriptionOptionsRef.current,
                                direction
                            }));
                        }
                    }["buildHooks.buildInfiniteQueryHooks.useInfiniteQuerySubscription.useCallback[trigger]"]);
                    return promise;
                }
            }["buildHooks.buildInfiniteQueryHooks.useInfiniteQuerySubscription.useCallback[trigger]"], [
                promiseRef,
                dispatch,
                initiate
            ]);
            usePromiseRefUnsubscribeOnUnmount(promiseRef);
            const stableArg = useStableQueryArgs(options.skip ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$query$2f$rtk$2d$query$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["skipToken"] : arg, // Even if the user provided a per-endpoint `serializeQueryArgs` with
            // a consistent return value, _here_ we want to use the default behavior
            // so we can tell if _anything_ actually changed. Otherwise, we can end up
            // with a case where the query args did change but the serialization doesn't,
            // and then we never try to initiate a refetch.
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$query$2f$rtk$2d$query$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultSerializeQueryArgs"], context.endpointDefinitions[endpointName], endpointName);
            const refetch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
                "buildHooks.buildInfiniteQueryHooks.useInfiniteQuerySubscription.useCallback[refetch]": ()=>refetchOrErrorIfUnmounted(promiseRef)
            }["buildHooks.buildInfiniteQueryHooks.useInfiniteQuerySubscription.useCallback[refetch]"], [
                promiseRef
            ]);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
                "buildHooks.buildInfiniteQueryHooks.useInfiniteQuerySubscription.useMemo2": ()=>{
                    const fetchNextPage = {
                        "buildHooks.buildInfiniteQueryHooks.useInfiniteQuerySubscription.useMemo2.fetchNextPage": ()=>{
                            return trigger(stableArg, "forward");
                        }
                    }["buildHooks.buildInfiniteQueryHooks.useInfiniteQuerySubscription.useMemo2.fetchNextPage"];
                    const fetchPreviousPage = {
                        "buildHooks.buildInfiniteQueryHooks.useInfiniteQuerySubscription.useMemo2.fetchPreviousPage": ()=>{
                            return trigger(stableArg, "backward");
                        }
                    }["buildHooks.buildInfiniteQueryHooks.useInfiniteQuerySubscription.useMemo2.fetchPreviousPage"];
                    return {
                        trigger,
                        /**
           * A method to manually refetch data for the query
           */ refetch,
                        fetchNextPage,
                        fetchPreviousPage
                    };
                }
            }["buildHooks.buildInfiniteQueryHooks.useInfiniteQuerySubscription.useMemo2"], [
                refetch,
                trigger,
                stableArg
            ]);
        };
        const useInfiniteQueryState = buildUseQueryState(endpointName, infiniteQueryStatePreSelector);
        return {
            useInfiniteQueryState,
            useInfiniteQuerySubscription,
            useInfiniteQuery (arg, options) {
                const { refetch, fetchNextPage, fetchPreviousPage } = useInfiniteQuerySubscription(arg, options);
                const queryStateResults = useInfiniteQueryState(arg, {
                    selectFromResult: arg === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$query$2f$rtk$2d$query$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["skipToken"] || (options === null || options === void 0 ? void 0 : options.skip) ? void 0 : noPendingQueryStateSelector,
                    ...options
                });
                const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS, "hasNextPage", "hasPreviousPage");
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useDebugValue"])(debugValue);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
                    "buildHooks.buildInfiniteQueryHooks.useMemo2": ()=>({
                            ...queryStateResults,
                            fetchNextPage,
                            fetchPreviousPage,
                            refetch
                        })
                }["buildHooks.buildInfiniteQueryHooks.useMemo2"], [
                    queryStateResults,
                    fetchNextPage,
                    fetchPreviousPage,
                    refetch
                ]);
            }
        };
    }
    function buildMutationHook(name) {
        return function() {
            let { selectFromResult, fixedCacheKey } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            const { select, initiate } = api.endpoints[name];
            const dispatch = useDispatch();
            const [promise, setPromise] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])();
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
                "buildHooks.buildMutationHook.useEffect3": ()=>({
                        "buildHooks.buildMutationHook.useEffect3": ()=>{
                            if (!(promise === null || promise === void 0 ? void 0 : promise.arg.fixedCacheKey)) {
                                promise === null || promise === void 0 ? void 0 : promise.reset();
                            }
                        }
                    })["buildHooks.buildMutationHook.useEffect3"]
            }["buildHooks.buildMutationHook.useEffect3"], [
                promise
            ]);
            const triggerMutation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
                "buildHooks.buildMutationHook.useCallback[triggerMutation]": function(arg) {
                    const promise2 = dispatch(initiate(arg, {
                        fixedCacheKey
                    }));
                    setPromise(promise2);
                    return promise2;
                }
            }["buildHooks.buildMutationHook.useCallback[triggerMutation]"], [
                dispatch,
                initiate,
                fixedCacheKey
            ]);
            const { requestId } = promise || {};
            const selectDefaultResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
                "buildHooks.buildMutationHook.useMemo2[selectDefaultResult]": ()=>select({
                        fixedCacheKey,
                        requestId: promise === null || promise === void 0 ? void 0 : promise.requestId
                    })
            }["buildHooks.buildMutationHook.useMemo2[selectDefaultResult]"], [
                fixedCacheKey,
                promise,
                select
            ]);
            const mutationSelector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
                "buildHooks.buildMutationHook.useMemo2[mutationSelector]": ()=>selectFromResult ? createSelector([
                        selectDefaultResult
                    ], selectFromResult) : selectDefaultResult
            }["buildHooks.buildMutationHook.useMemo2[mutationSelector]"], [
                selectFromResult,
                selectDefaultResult
            ]);
            const currentState = useSelector(mutationSelector, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$redux$2f$dist$2f$react$2d$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallowEqual"]);
            const originalArgs = fixedCacheKey == null ? promise === null || promise === void 0 ? void 0 : promise.arg.originalArgs : void 0;
            const reset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
                "buildHooks.buildMutationHook.useCallback[reset]": ()=>{
                    batch({
                        "buildHooks.buildMutationHook.useCallback[reset]": ()=>{
                            if (promise) {
                                setPromise(void 0);
                            }
                            if (fixedCacheKey) {
                                dispatch(api.internalActions.removeMutationResult({
                                    requestId,
                                    fixedCacheKey
                                }));
                            }
                        }
                    }["buildHooks.buildMutationHook.useCallback[reset]"]);
                }
            }["buildHooks.buildMutationHook.useCallback[reset]"], [
                dispatch,
                fixedCacheKey,
                promise,
                requestId
            ]);
            const debugValue = pick(currentState, ...COMMON_HOOK_DEBUG_FIELDS, "endpointName");
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useDebugValue"])(debugValue);
            const finalState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
                "buildHooks.buildMutationHook.useMemo2[finalState]": ()=>({
                        ...currentState,
                        originalArgs,
                        reset
                    })
            }["buildHooks.buildMutationHook.useMemo2[finalState]"], [
                currentState,
                originalArgs,
                reset
            ]);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
                "buildHooks.buildMutationHook.useMemo2": ()=>[
                        triggerMutation,
                        finalState
                    ]
            }["buildHooks.buildMutationHook.useMemo2"], [
                triggerMutation,
                finalState
            ]);
        };
    }
}
// src/query/react/module.ts
var reactHooksModuleName = /* @__PURE__ */ Symbol();
var reactHooksModule = function() {
    let { batch = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$redux$2f$dist$2f$react$2d$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["batch"], hooks = {
        useDispatch: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$redux$2f$dist$2f$react$2d$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useDispatch"],
        useSelector: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$redux$2f$dist$2f$react$2d$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSelector"],
        useStore: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$redux$2f$dist$2f$react$2d$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useStore"]
    }, createSelector = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$reselect$2f$dist$2f$reselect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSelector"], unstable__sideEffectsInRender = false, ...rest } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if ("TURBOPACK compile-time truthy", 1) {
        const hookNames = [
            "useDispatch",
            "useSelector",
            "useStore"
        ];
        let warned = false;
        for (const hookName of hookNames){
            if (countObjectKeys(rest) > 0) {
                if (rest[hookName]) {
                    if (!warned) {
                        console.warn("As of RTK 2.0, the hooks now need to be specified as one object, provided under a `hooks` key:\n`reactHooksModule({ hooks: { useDispatch, useSelector, useStore } })`");
                        warned = true;
                    }
                }
                hooks[hookName] = rest[hookName];
            }
            if (typeof hooks[hookName] !== "function") {
                throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "When using custom hooks for context, all ".concat(hookNames.length, " hooks need to be provided: ").concat(hookNames.join(", "), ".\nHook ").concat(hookName, " was either not provided or not a function."));
            }
        }
    }
    return {
        name: reactHooksModuleName,
        init (api, param, context) {
            let { serializeQueryArgs } = param;
            const anyApi = api;
            const { buildQueryHooks, buildInfiniteQueryHooks, buildMutationHook, usePrefetch } = buildHooks({
                api,
                moduleOptions: {
                    batch,
                    hooks,
                    unstable__sideEffectsInRender,
                    createSelector
                },
                serializeQueryArgs,
                context
            });
            safeAssign(anyApi, {
                usePrefetch
            });
            safeAssign(context, {
                batch
            });
            return {
                injectEndpoint (endpointName, definition) {
                    if (isQueryDefinition(definition)) {
                        const { useQuery, useLazyQuery, useLazyQuerySubscription, useQueryState, useQuerySubscription } = buildQueryHooks(endpointName);
                        safeAssign(anyApi.endpoints[endpointName], {
                            useQuery,
                            useLazyQuery,
                            useLazyQuerySubscription,
                            useQueryState,
                            useQuerySubscription
                        });
                        api["use".concat(capitalize(endpointName), "Query")] = useQuery;
                        api["useLazy".concat(capitalize(endpointName), "Query")] = useLazyQuery;
                    }
                    if (isMutationDefinition(definition)) {
                        const useMutation = buildMutationHook(endpointName);
                        safeAssign(anyApi.endpoints[endpointName], {
                            useMutation
                        });
                        api["use".concat(capitalize(endpointName), "Mutation")] = useMutation;
                    } else if (isInfiniteQueryDefinition(definition)) {
                        const { useInfiniteQuery, useInfiniteQuerySubscription, useInfiniteQueryState } = buildInfiniteQueryHooks(endpointName);
                        safeAssign(anyApi.endpoints[endpointName], {
                            useInfiniteQuery,
                            useInfiniteQuerySubscription,
                            useInfiniteQueryState
                        });
                        api["use".concat(capitalize(endpointName), "InfiniteQuery")] = useInfiniteQuery;
                    }
                }
            };
        }
    };
};
;
;
;
;
;
;
;
function ApiProvider(props) {
    const context = props.context || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$redux$2f$dist$2f$react$2d$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ReactReduxContext"];
    const existingContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(context);
    if (existingContext) {
        throw new Error(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "Existing Redux context detected. If you already have a store set up, please use the traditional Redux setup.");
    }
    const [store] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"]({
        "ApiProvider.useState": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$redux$2d$toolkit$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["configureStore"])({
                reducer: {
                    [props.api.reducerPath]: props.api.reducer
                },
                middleware: {
                    "ApiProvider.useState": (gDM)=>gDM().concat(props.api.middleware)
                }["ApiProvider.useState"]
            })
    }["ApiProvider.useState"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "ApiProvider.useEffect4": ()=>props.setupListeners === false ? void 0 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$query$2f$rtk$2d$query$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setupListeners"])(store.dispatch, props.setupListeners)
    }["ApiProvider.useEffect4"], [
        props.setupListeners,
        store.dispatch
    ]);
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$redux$2f$dist$2f$react$2d$redux$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Provider"], {
        store,
        context
    }, props.children);
}
// src/query/react/index.ts
var createApi = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$query$2f$rtk$2d$query$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["buildCreateApi"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$reduxjs$2f$toolkit$2f$dist$2f$query$2f$rtk$2d$query$2e$modern$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coreModule"])(), reactHooksModule());
;
 //# sourceMappingURL=rtk-query-react.modern.mjs.map
}),
"[project]/node_modules/@capacitor/core/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/*! Capacitor: https://capacitorjs.com/ - MIT License */ __turbopack_context__.s({
    "Capacitor": ()=>Capacitor,
    "CapacitorCookies": ()=>CapacitorCookies,
    "CapacitorException": ()=>CapacitorException,
    "CapacitorHttp": ()=>CapacitorHttp,
    "ExceptionCode": ()=>ExceptionCode,
    "WebPlugin": ()=>WebPlugin,
    "WebView": ()=>WebView,
    "buildRequestInit": ()=>buildRequestInit,
    "registerPlugin": ()=>registerPlugin
});
var ExceptionCode;
(function(ExceptionCode) {
    /**
     * API is not implemented.
     *
     * This usually means the API can't be used because it is not implemented for
     * the current platform.
     */ ExceptionCode["Unimplemented"] = "UNIMPLEMENTED";
    /**
     * API is not available.
     *
     * This means the API can't be used right now because:
     *   - it is currently missing a prerequisite, such as network connectivity
     *   - it requires a particular platform or browser version
     */ ExceptionCode["Unavailable"] = "UNAVAILABLE";
})(ExceptionCode || (ExceptionCode = {}));
class CapacitorException extends Error {
    constructor(message, code, data){
        super(message);
        this.message = message;
        this.code = code;
        this.data = data;
    }
}
const getPlatformId = (win)=>{
    var _a, _b;
    if (win === null || win === void 0 ? void 0 : win.androidBridge) {
        return 'android';
    } else if ((_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {
        return 'ios';
    } else {
        return 'web';
    }
};
const createCapacitor = (win)=>{
    const capCustomPlatform = win.CapacitorCustomPlatform || null;
    const cap = win.Capacitor || {};
    const Plugins = cap.Plugins = cap.Plugins || {};
    const getPlatform = ()=>{
        return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win);
    };
    const isNativePlatform = ()=>getPlatform() !== 'web';
    const isPluginAvailable = (pluginName)=>{
        const plugin = registeredPlugins.get(pluginName);
        if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {
            // JS implementation available for the current platform.
            return true;
        }
        if (getPluginHeader(pluginName)) {
            // Native implementation available.
            return true;
        }
        return false;
    };
    const getPluginHeader = (pluginName)=>{
        var _a;
        return (_a = cap.PluginHeaders) === null || _a === void 0 ? void 0 : _a.find((h)=>h.name === pluginName);
    };
    const handleError = (err)=>win.console.error(err);
    const registeredPlugins = new Map();
    const registerPlugin = function(pluginName) {
        let jsImplementations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const registeredPlugin = registeredPlugins.get(pluginName);
        if (registeredPlugin) {
            console.warn('Capacitor plugin "'.concat(pluginName, '" already registered. Cannot register plugins twice.'));
            return registeredPlugin.proxy;
        }
        const platform = getPlatform();
        const pluginHeader = getPluginHeader(pluginName);
        let jsImplementation;
        const loadPluginImplementation = async ()=>{
            if (!jsImplementation && platform in jsImplementations) {
                jsImplementation = typeof jsImplementations[platform] === 'function' ? jsImplementation = await jsImplementations[platform]() : jsImplementation = jsImplementations[platform];
            } else if (capCustomPlatform !== null && !jsImplementation && 'web' in jsImplementations) {
                jsImplementation = typeof jsImplementations['web'] === 'function' ? jsImplementation = await jsImplementations['web']() : jsImplementation = jsImplementations['web'];
            }
            return jsImplementation;
        };
        const createPluginMethod = (impl, prop)=>{
            var _a, _b;
            if (pluginHeader) {
                const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m)=>prop === m.name);
                if (methodHeader) {
                    if (methodHeader.rtype === 'promise') {
                        return (options)=>cap.nativePromise(pluginName, prop.toString(), options);
                    } else {
                        return (options, callback)=>cap.nativeCallback(pluginName, prop.toString(), options, callback);
                    }
                } else if (impl) {
                    return (_a = impl[prop]) === null || _a === void 0 ? void 0 : _a.bind(impl);
                }
            } else if (impl) {
                return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);
            } else {
                throw new CapacitorException('"'.concat(pluginName, '" plugin is not implemented on ').concat(platform), ExceptionCode.Unimplemented);
            }
        };
        const createPluginMethodWrapper = (prop)=>{
            let remove;
            const wrapper = function() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                const p = loadPluginImplementation().then((impl)=>{
                    const fn = createPluginMethod(impl, prop);
                    if (fn) {
                        const p = fn(...args);
                        remove = p === null || p === void 0 ? void 0 : p.remove;
                        return p;
                    } else {
                        throw new CapacitorException('"'.concat(pluginName, ".").concat(prop, '()" is not implemented on ').concat(platform), ExceptionCode.Unimplemented);
                    }
                });
                if (prop === 'addListener') {
                    p.remove = async ()=>remove();
                }
                return p;
            };
            // Some flair 
            wrapper.toString = ()=>"".concat(prop.toString(), "() { [capacitor code] }");
            Object.defineProperty(wrapper, 'name', {
                value: prop,
                writable: false,
                configurable: false
            });
            return wrapper;
        };
        const addListener = createPluginMethodWrapper('addListener');
        const removeListener = createPluginMethodWrapper('removeListener');
        const addListenerNative = (eventName, callback)=>{
            const call = addListener({
                eventName
            }, callback);
            const remove = async ()=>{
                const callbackId = await call;
                removeListener({
                    eventName,
                    callbackId
                }, callback);
            };
            const p = new Promise((resolve)=>call.then(()=>resolve({
                        remove
                    })));
            p.remove = async ()=>{
                console.warn("Using addListener() without 'await' is deprecated.");
                await remove();
            };
            return p;
        };
        const proxy = new Proxy({}, {
            get (_, prop) {
                switch(prop){
                    // https://github.com/facebook/react/issues/20030
                    case '$$typeof':
                        return undefined;
                    case 'toJSON':
                        return ()=>({});
                    case 'addListener':
                        return pluginHeader ? addListenerNative : addListener;
                    case 'removeListener':
                        return removeListener;
                    default:
                        return createPluginMethodWrapper(prop);
                }
            }
        });
        Plugins[pluginName] = proxy;
        registeredPlugins.set(pluginName, {
            name: pluginName,
            proxy,
            platforms: new Set([
                ...Object.keys(jsImplementations),
                ...pluginHeader ? [
                    platform
                ] : []
            ])
        });
        return proxy;
    };
    // Add in convertFileSrc for web, it will already be available in native context
    if (!cap.convertFileSrc) {
        cap.convertFileSrc = (filePath)=>filePath;
    }
    cap.getPlatform = getPlatform;
    cap.handleError = handleError;
    cap.isNativePlatform = isNativePlatform;
    cap.isPluginAvailable = isPluginAvailable;
    cap.registerPlugin = registerPlugin;
    cap.Exception = CapacitorException;
    cap.DEBUG = !!cap.DEBUG;
    cap.isLoggingEnabled = !!cap.isLoggingEnabled;
    return cap;
};
const initCapacitorGlobal = (win)=>win.Capacitor = createCapacitor(win);
const Capacitor = /*#__PURE__*/ initCapacitorGlobal(typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK ident replacement", globalThis) : "TURBOPACK unreachable");
const registerPlugin = Capacitor.registerPlugin;
/**
 * Base class web plugins should extend.
 */ class WebPlugin {
    addListener(eventName, listenerFunc) {
        let firstListener = false;
        const listeners = this.listeners[eventName];
        if (!listeners) {
            this.listeners[eventName] = [];
            firstListener = true;
        }
        this.listeners[eventName].push(listenerFunc);
        // If we haven't added a window listener for this event and it requires one,
        // go ahead and add it
        const windowListener = this.windowListeners[eventName];
        if (windowListener && !windowListener.registered) {
            this.addWindowListener(windowListener);
        }
        if (firstListener) {
            this.sendRetainedArgumentsForEvent(eventName);
        }
        const remove = async ()=>this.removeListener(eventName, listenerFunc);
        const p = Promise.resolve({
            remove
        });
        return p;
    }
    async removeAllListeners() {
        this.listeners = {};
        for(const listener in this.windowListeners){
            this.removeWindowListener(this.windowListeners[listener]);
        }
        this.windowListeners = {};
    }
    notifyListeners(eventName, data, retainUntilConsumed) {
        const listeners = this.listeners[eventName];
        if (!listeners) {
            if (retainUntilConsumed) {
                let args = this.retainedEventArguments[eventName];
                if (!args) {
                    args = [];
                }
                args.push(data);
                this.retainedEventArguments[eventName] = args;
            }
            return;
        }
        listeners.forEach((listener)=>listener(data));
    }
    hasListeners(eventName) {
        var _a;
        return !!((_a = this.listeners[eventName]) === null || _a === void 0 ? void 0 : _a.length);
    }
    registerWindowListener(windowEventName, pluginEventName) {
        this.windowListeners[pluginEventName] = {
            registered: false,
            windowEventName,
            pluginEventName,
            handler: (event)=>{
                this.notifyListeners(pluginEventName, event);
            }
        };
    }
    unimplemented() {
        let msg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'not implemented';
        return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);
    }
    unavailable() {
        let msg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'not available';
        return new Capacitor.Exception(msg, ExceptionCode.Unavailable);
    }
    async removeListener(eventName, listenerFunc) {
        const listeners = this.listeners[eventName];
        if (!listeners) {
            return;
        }
        const index = listeners.indexOf(listenerFunc);
        this.listeners[eventName].splice(index, 1);
        // If there are no more listeners for this type of event,
        // remove the window listener
        if (!this.listeners[eventName].length) {
            this.removeWindowListener(this.windowListeners[eventName]);
        }
    }
    addWindowListener(handle) {
        window.addEventListener(handle.windowEventName, handle.handler);
        handle.registered = true;
    }
    removeWindowListener(handle) {
        if (!handle) {
            return;
        }
        window.removeEventListener(handle.windowEventName, handle.handler);
        handle.registered = false;
    }
    sendRetainedArgumentsForEvent(eventName) {
        const args = this.retainedEventArguments[eventName];
        if (!args) {
            return;
        }
        delete this.retainedEventArguments[eventName];
        args.forEach((arg)=>{
            this.notifyListeners(eventName, arg);
        });
    }
    constructor(){
        this.listeners = {};
        this.retainedEventArguments = {};
        this.windowListeners = {};
    }
}
const WebView = /*#__PURE__*/ registerPlugin('WebView');
/******** END WEB VIEW PLUGIN ********/ /******** COOKIES PLUGIN ********/ /**
 * Safely web encode a string value (inspired by js-cookie)
 * @param str The string value to encode
 */ const encode = (str)=>encodeURIComponent(str).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
/**
 * Safely web decode a string value (inspired by js-cookie)
 * @param str The string value to decode
 */ const decode = (str)=>str.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
class CapacitorCookiesPluginWeb extends WebPlugin {
    async getCookies() {
        const cookies = document.cookie;
        const cookieMap = {};
        cookies.split(';').forEach((cookie)=>{
            if (cookie.length <= 0) return;
            // Replace first "=" with CAP_COOKIE to prevent splitting on additional "="
            let [key, value] = cookie.replace(/=/, 'CAP_COOKIE').split('CAP_COOKIE');
            key = decode(key).trim();
            value = decode(value).trim();
            cookieMap[key] = value;
        });
        return cookieMap;
    }
    async setCookie(options) {
        try {
            // Safely Encoded Key/Value
            const encodedKey = encode(options.key);
            const encodedValue = encode(options.value);
            // Clean & sanitize options
            const expires = "; expires=".concat((options.expires || '').replace('expires=', '')); // Default is "; expires="
            const path = (options.path || '/').replace('path=', ''); // Default is "path=/"
            const domain = options.url != null && options.url.length > 0 ? "domain=".concat(options.url) : '';
            document.cookie = "".concat(encodedKey, "=").concat(encodedValue || '').concat(expires, "; path=").concat(path, "; ").concat(domain, ";");
        } catch (error) {
            return Promise.reject(error);
        }
    }
    async deleteCookie(options) {
        try {
            document.cookie = "".concat(options.key, "=; Max-Age=0");
        } catch (error) {
            return Promise.reject(error);
        }
    }
    async clearCookies() {
        try {
            const cookies = document.cookie.split(';') || [];
            for (const cookie of cookies){
                document.cookie = cookie.replace(/^ +/, '').replace(/=.*/, "=;expires=".concat(new Date().toUTCString(), ";path=/"));
            }
        } catch (error) {
            return Promise.reject(error);
        }
    }
    async clearAllCookies() {
        try {
            await this.clearCookies();
        } catch (error) {
            return Promise.reject(error);
        }
    }
}
const CapacitorCookies = registerPlugin('CapacitorCookies', {
    web: ()=>new CapacitorCookiesPluginWeb()
});
// UTILITY FUNCTIONS
/**
 * Read in a Blob value and return it as a base64 string
 * @param blob The blob value to convert to a base64 string
 */ const readBlobAsBase64 = async (blob)=>new Promise((resolve, reject)=>{
        const reader = new FileReader();
        reader.onload = ()=>{
            const base64String = reader.result;
            // remove prefix "data:application/pdf;base64,"
            resolve(base64String.indexOf(',') >= 0 ? base64String.split(',')[1] : base64String);
        };
        reader.onerror = (error)=>reject(error);
        reader.readAsDataURL(blob);
    });
/**
 * Normalize an HttpHeaders map by lowercasing all of the values
 * @param headers The HttpHeaders object to normalize
 */ const normalizeHttpHeaders = function() {
    let headers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const originalKeys = Object.keys(headers);
    const loweredKeys = Object.keys(headers).map((k)=>k.toLocaleLowerCase());
    const normalized = loweredKeys.reduce((acc, key, index)=>{
        acc[key] = headers[originalKeys[index]];
        return acc;
    }, {});
    return normalized;
};
/**
 * Builds a string of url parameters that
 * @param params A map of url parameters
 * @param shouldEncode true if you should encodeURIComponent() the values (true by default)
 */ const buildUrlParams = function(params) {
    let shouldEncode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (!params) return null;
    const output = Object.entries(params).reduce((accumulator, entry)=>{
        const [key, value] = entry;
        let encodedValue;
        let item;
        if (Array.isArray(value)) {
            item = '';
            value.forEach((str)=>{
                encodedValue = shouldEncode ? encodeURIComponent(str) : str;
                item += "".concat(key, "=").concat(encodedValue, "&");
            });
            // last character will always be "&" so slice it off
            item.slice(0, -1);
        } else {
            encodedValue = shouldEncode ? encodeURIComponent(value) : value;
            item = "".concat(key, "=").concat(encodedValue);
        }
        return "".concat(accumulator, "&").concat(item);
    }, '');
    // Remove initial "&" from the reduce
    return output.substr(1);
};
/**
 * Build the RequestInit object based on the options passed into the initial request
 * @param options The Http plugin options
 * @param extra Any extra RequestInit values
 */ const buildRequestInit = function(options) {
    let extra = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const output = Object.assign({
        method: options.method || 'GET',
        headers: options.headers
    }, extra);
    // Get the content-type
    const headers = normalizeHttpHeaders(options.headers);
    const type = headers['content-type'] || '';
    // If body is already a string, then pass it through as-is.
    if (typeof options.data === 'string') {
        output.body = options.data;
    } else if (type.includes('application/x-www-form-urlencoded')) {
        const params = new URLSearchParams();
        for (const [key, value] of Object.entries(options.data || {})){
            params.set(key, value);
        }
        output.body = params.toString();
    } else if (type.includes('multipart/form-data') || options.data instanceof FormData) {
        const form = new FormData();
        if (options.data instanceof FormData) {
            options.data.forEach((value, key)=>{
                form.append(key, value);
            });
        } else {
            for (const key of Object.keys(options.data)){
                form.append(key, options.data[key]);
            }
        }
        output.body = form;
        const headers = new Headers(output.headers);
        headers.delete('content-type'); // content-type will be set by `window.fetch` to includy boundary
        output.headers = headers;
    } else if (type.includes('application/json') || typeof options.data === 'object') {
        output.body = JSON.stringify(options.data);
    }
    return output;
};
// WEB IMPLEMENTATION
class CapacitorHttpPluginWeb extends WebPlugin {
    /**
     * Perform an Http request given a set of options
     * @param options Options to build the HTTP request
     */ async request(options) {
        const requestInit = buildRequestInit(options, options.webFetchExtra);
        const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);
        const url = urlParams ? "".concat(options.url, "?").concat(urlParams) : options.url;
        const response = await fetch(url, requestInit);
        const contentType = response.headers.get('content-type') || '';
        // Default to 'text' responseType so no parsing happens
        let { responseType = 'text' } = response.ok ? options : {};
        // If the response content-type is json, force the response to be json
        if (contentType.includes('application/json')) {
            responseType = 'json';
        }
        let data;
        let blob;
        switch(responseType){
            case 'arraybuffer':
            case 'blob':
                blob = await response.blob();
                data = await readBlobAsBase64(blob);
                break;
            case 'json':
                data = await response.json();
                break;
            case 'document':
            case 'text':
            default:
                data = await response.text();
        }
        // Convert fetch headers to Capacitor HttpHeaders
        const headers = {};
        response.headers.forEach((value, key)=>{
            headers[key] = value;
        });
        return {
            data,
            headers,
            status: response.status,
            url: response.url
        };
    }
    /**
     * Perform an Http GET request given a set of options
     * @param options Options to build the HTTP request
     */ async get(options) {
        return this.request(Object.assign(Object.assign({}, options), {
            method: 'GET'
        }));
    }
    /**
     * Perform an Http POST request given a set of options
     * @param options Options to build the HTTP request
     */ async post(options) {
        return this.request(Object.assign(Object.assign({}, options), {
            method: 'POST'
        }));
    }
    /**
     * Perform an Http PUT request given a set of options
     * @param options Options to build the HTTP request
     */ async put(options) {
        return this.request(Object.assign(Object.assign({}, options), {
            method: 'PUT'
        }));
    }
    /**
     * Perform an Http PATCH request given a set of options
     * @param options Options to build the HTTP request
     */ async patch(options) {
        return this.request(Object.assign(Object.assign({}, options), {
            method: 'PATCH'
        }));
    }
    /**
     * Perform an Http DELETE request given a set of options
     * @param options Options to build the HTTP request
     */ async delete(options) {
        return this.request(Object.assign(Object.assign({}, options), {
            method: 'DELETE'
        }));
    }
}
const CapacitorHttp = registerPlugin('CapacitorHttp', {
    web: ()=>new CapacitorHttpPluginWeb()
});
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/redux-persist/es/integration/react.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "PersistGate": ()=>PersistGate
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"); // eslint-disable-line import/no-unresolved
function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized(self);
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
;
var PersistGate = /*#__PURE__*/ function(_PureComponent) {
    _inherits(PersistGate, _PureComponent);
    function PersistGate() {
        var _getPrototypeOf2;
        var _this;
        _classCallCheck(this, PersistGate);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PersistGate)).call.apply(_getPrototypeOf2, [
            this
        ].concat(args)));
        _defineProperty(_assertThisInitialized(_this), "state", {
            bootstrapped: false
        });
        _defineProperty(_assertThisInitialized(_this), "_unsubscribe", void 0);
        _defineProperty(_assertThisInitialized(_this), "handlePersistorState", function() {
            var persistor = _this.props.persistor;
            var _persistor$getState = persistor.getState(), bootstrapped = _persistor$getState.bootstrapped;
            if (bootstrapped) {
                if (_this.props.onBeforeLift) {
                    Promise.resolve(_this.props.onBeforeLift()).finally(function() {
                        return _this.setState({
                            bootstrapped: true
                        });
                    });
                } else {
                    _this.setState({
                        bootstrapped: true
                    });
                }
                _this._unsubscribe && _this._unsubscribe();
            }
        });
        return _this;
    }
    _createClass(PersistGate, [
        {
            key: "componentDidMount",
            value: function componentDidMount() {
                this._unsubscribe = this.props.persistor.subscribe(this.handlePersistorState);
                this.handlePersistorState();
            }
        },
        {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this._unsubscribe && this._unsubscribe();
            }
        },
        {
            key: "render",
            value: function render() {
                if ("TURBOPACK compile-time truthy", 1) {
                    if (typeof this.props.children === 'function' && this.props.loading) console.error('redux-persist: PersistGate expects either a function child or loading prop, but not both. The loading prop will be ignored.');
                }
                if (typeof this.props.children === 'function') {
                    return this.props.children(this.state.bootstrapped);
                }
                return this.state.bootstrapped ? this.props.children : this.props.loading;
            }
        }
    ]);
    return PersistGate;
}(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PureComponent"]);
_defineProperty(PersistGate, "defaultProps", {
    children: null,
    loading: null
});
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "disableSmoothScrollDuringRouteTransition", {
    enumerable: true,
    get: function() {
        return disableSmoothScrollDuringRouteTransition;
    }
});
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
function disableSmoothScrollDuringRouteTransition(fn, options) {
    if (options === void 0) options = {};
    // if only the hash is changed, we don't need to disable smooth scrolling
    // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX
    if (options.onlyHashChange) {
        fn();
        return;
    }
    const htmlElement = document.documentElement;
    const hasDataAttribute = htmlElement.dataset.scrollBehavior === 'smooth';
    // Since this is a breaking change, this is temporarily flagged
    // and will be false by default.
    // In the next major (v16), this will be automatically enabled
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        // Old behavior: always manipulate styles, but warn about upcoming change
        // Warn if smooth scrolling is detected but no data attribute is present
        if (("TURBOPACK compile-time value", "development") === 'development' && !hasDataAttribute && getComputedStyle(htmlElement).scrollBehavior === 'smooth') {
            (0, _warnonce.warnOnce)('Detected `scroll-behavior: smooth` on the `<html>` element. In a future version, ' + 'Next.js will no longer automatically disable smooth scrolling during route transitions. ' + 'To prepare for this change, add `data-scroll-behavior="smooth"` to your <html> element. ' + 'Learn more: https://nextjs.org/docs/messages/missing-data-scroll-behavior');
        }
    }
    // Proceed with temporarily disabling smooth scrolling
    const existing = htmlElement.style.scrollBehavior;
    htmlElement.style.scrollBehavior = 'auto';
    if (!options.dontForceLayout) {
        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.
        // Otherwise it will not pickup the change in scrollBehavior
        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042
        htmlElement.getClientRects();
    }
    fn();
    htmlElement.style.scrollBehavior = existing;
} //# sourceMappingURL=disable-smooth-scroll.js.map
}}),
"[project]/node_modules/next/dist/client/components/bfcache.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useRouterBFCache", {
    enumerable: true,
    get: function() {
        return useRouterBFCache;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
// When the flag is disabled, only track the currently active tree
const MAX_BF_CACHE_ENTRIES = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 1;
function useRouterBFCache(activeTree, activeStateKey) {
    // The currently active entry. The entries form a linked list, sorted in
    // order of most recently active. This allows us to reuse parts of the list
    // without cloning, unless there's a reordering or removal.
    // TODO: Once we start tracking back/forward history at each route level,
    // we should use the history order instead. In other words, when traversing
    // to an existing entry as a result of a popstate event, we should maintain
    // the existing order instead of moving it to the front of the list. I think
    // an initial implementation of this could be to pass an incrementing id
    // to history.pushState/replaceState, then use that here for ordering.
    const [prevActiveEntry, setPrevActiveEntry] = (0, _react.useState)(()=>{
        const initialEntry = {
            tree: activeTree,
            stateKey: activeStateKey,
            next: null
        };
        return initialEntry;
    });
    if (prevActiveEntry.tree === activeTree) {
        // Fast path. The active tree hasn't changed, so we can reuse the
        // existing state.
        return prevActiveEntry;
    }
    // The route tree changed. Note that this doesn't mean that the tree changed
    // *at this level*  the change may be due to a child route. Either way, we
    // need to either add or update the router tree in the bfcache.
    //
    // The rest of the code looks more complicated than it actually is because we
    // can't mutate the state in place; we have to copy-on-write.
    // Create a new entry for the active cache key. This is the head of the new
    // linked list.
    const newActiveEntry = {
        tree: activeTree,
        stateKey: activeStateKey,
        next: null
    };
    // We need to append the old list onto the new list. If the head of the new
    // list was already present in the cache, then we'll need to clone everything
    // that came before it. Then we can reuse the rest.
    let n = 1;
    let oldEntry = prevActiveEntry;
    let clonedEntry = newActiveEntry;
    while(oldEntry !== null && n < MAX_BF_CACHE_ENTRIES){
        if (oldEntry.stateKey === activeStateKey) {
            // Fast path. This entry in the old list that corresponds to the key that
            // is now active. We've already placed a clone of this entry at the front
            // of the new list. We can reuse the rest of the old list without cloning.
            // NOTE: We don't need to worry about eviction in this case because we
            // haven't increased the size of the cache, and we assume the max size
            // is constant across renders. If we were to change it to a dynamic limit,
            // then the implementation would need to account for that.
            clonedEntry.next = oldEntry.next;
            break;
        } else {
            // Clone the entry and append it to the list.
            n++;
            const entry = {
                tree: oldEntry.tree,
                stateKey: oldEntry.stateKey,
                next: null
            };
            clonedEntry.next = entry;
            clonedEntry = entry;
        }
        oldEntry = oldEntry.next;
    }
    setPrevActiveEntry(newActiveEntry);
    return newActiveEntry;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=bfcache.js.map
}}),
"[project]/node_modules/next/dist/client/components/layout-router.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, /**
 * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.
 * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.
 */ "default", {
    enumerable: true,
    get: function() {
        return OuterLayoutRouter;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _routerreducertypes = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _reactdom = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)"));
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)");
const _fetchserverresponse = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-client] (ecmascript)");
const _unresolvedthenable = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/unresolved-thenable.js [app-client] (ecmascript)");
const _errorboundary = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/error-boundary.js [app-client] (ecmascript)");
const _matchsegments = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/match-segments.js [app-client] (ecmascript)");
const _disablesmoothscroll = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js [app-client] (ecmascript)");
const _redirectboundary = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/redirect-boundary.js [app-client] (ecmascript)");
const _errorboundary1 = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/http-access-fallback/error-boundary.js [app-client] (ecmascript)");
const _createroutercachekey = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-client] (ecmascript)");
const _hasinterceptionrouteincurrenttree = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-client] (ecmascript)");
const _useactionqueue = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/use-action-queue.js [app-client] (ecmascript)");
const _bfcache = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/bfcache.js [app-client] (ecmascript)");
const _apppaths = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js [app-client] (ecmascript)");
const Activity = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : null;
/**
 * Add refetch marker to router state at the point of the current layout segment.
 * This ensures the response returned is not further down than the current layout segment.
 */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {
    if (segmentPathToWalk) {
        const [segment, parallelRouteKey] = segmentPathToWalk;
        const isLast = segmentPathToWalk.length === 2;
        if ((0, _matchsegments.matchSegment)(treeToRecreate[0], segment)) {
            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {
                if (isLast) {
                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);
                    return [
                        treeToRecreate[0],
                        {
                            ...treeToRecreate[1],
                            [parallelRouteKey]: [
                                subTree[0],
                                subTree[1],
                                subTree[2],
                                'refetch'
                            ]
                        }
                    ];
                }
                return [
                    treeToRecreate[0],
                    {
                        ...treeToRecreate[1],
                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])
                    }
                ];
            }
        }
    }
    return treeToRecreate;
}
const __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = _reactdom.default.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available
/**
 * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning
 */ function findDOMNode(instance) {
    // Tree-shake for server bundle
    if (typeof window === 'undefined') return null;
    // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.
    // We need to lazily reference it.
    const internal_reactDOMfindDOMNode = __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode;
    return internal_reactDOMfindDOMNode(instance);
}
const rectProperties = [
    'bottom',
    'height',
    'left',
    'right',
    'top',
    'width',
    'x',
    'y'
];
/**
 * Check if a HTMLElement is hidden or fixed/sticky position
 */ function shouldSkipElement(element) {
    // we ignore fixed or sticky positioned elements since they'll likely pass the "in-viewport" check
    // and will result in a situation we bail on scroll because of something like a fixed nav,
    // even though the actual page content is offscreen
    if ([
        'sticky',
        'fixed'
    ].includes(getComputedStyle(element).position)) {
        if ("TURBOPACK compile-time truthy", 1) {
            console.warn('Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:', element);
        }
        return true;
    }
    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`
    // because `offsetParent` doesn't consider document/body
    const rect = element.getBoundingClientRect();
    return rectProperties.every((item)=>rect[item] === 0);
}
/**
 * Check if the top corner of the HTMLElement is in the viewport.
 */ function topOfElementInViewport(element, viewportHeight) {
    const rect = element.getBoundingClientRect();
    return rect.top >= 0 && rect.top <= viewportHeight;
}
/**
 * Find the DOM node for a hash fragment.
 * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.
 * If the hash fragment is an id, the page has to scroll to the element with that id.
 * If the hash fragment is a name, the page has to scroll to the first element with that name.
 */ function getHashFragmentDomNode(hashFragment) {
    // If the hash fragment is `top` the page has to scroll to the top of the page.
    if (hashFragment === 'top') {
        return document.body;
    }
    var _document_getElementById;
    // If the hash fragment is an id, the page has to scroll to the element with that id.
    return (_document_getElementById = document.getElementById(hashFragment)) != null ? _document_getElementById : document.getElementsByName(hashFragment)[0];
}
class InnerScrollAndFocusHandler extends _react.default.Component {
    componentDidMount() {
        this.handlePotentialScroll();
    }
    componentDidUpdate() {
        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.
        if (this.props.focusAndScrollRef.apply) {
            this.handlePotentialScroll();
        }
    }
    render() {
        return this.props.children;
    }
    constructor(...args){
        super(...args), this.handlePotentialScroll = ()=>{
            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.
            const { focusAndScrollRef, segmentPath } = this.props;
            if (focusAndScrollRef.apply) {
                // segmentPaths is an array of segment paths that should be scrolled to
                // if the current segment path is not in the array, the scroll is not applied
                // unless the array is empty, in which case the scroll is always applied
                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>(0, _matchsegments.matchSegment)(segment, scrollRefSegmentPath[index])))) {
                    return;
                }
                let domNode = null;
                const hashFragment = focusAndScrollRef.hashFragment;
                if (hashFragment) {
                    domNode = getHashFragmentDomNode(hashFragment);
                }
                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.
                // This already caused a bug where the first child was a <link/> in head.
                if (!domNode) {
                    domNode = findDOMNode(this);
                }
                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.
                if (!(domNode instanceof Element)) {
                    return;
                }
                // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.
                // If the element is skipped, try to select the next sibling and try again.
                while(!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)){
                    if ("TURBOPACK compile-time truthy", 1) {
                        var _domNode_parentElement;
                        if (((_domNode_parentElement = domNode.parentElement) == null ? void 0 : _domNode_parentElement.localName) === 'head') {
                        // TODO: We enter this state when metadata was rendered as part of the page or via Next.js.
                        // This is always a bug in Next.js and caused by React hoisting metadata.
                        // We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.
                        }
                    }
                    // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.
                    if (domNode.nextElementSibling === null) {
                        return;
                    }
                    domNode = domNode.nextElementSibling;
                }
                // State is mutated to ensure that the focus and scroll is applied only once.
                focusAndScrollRef.apply = false;
                focusAndScrollRef.hashFragment = null;
                focusAndScrollRef.segmentPaths = [];
                (0, _disablesmoothscroll.disableSmoothScrollDuringRouteTransition)(()=>{
                    // In case of hash scroll, we only need to scroll the element into view
                    if (hashFragment) {
                        ;
                        domNode.scrollIntoView();
                        return;
                    }
                    // Store the current viewport height because reading `clientHeight` causes a reflow,
                    // and it won't change during this function.
                    const htmlElement = document.documentElement;
                    const viewportHeight = htmlElement.clientHeight;
                    // If the element's top edge is already in the viewport, exit early.
                    if (topOfElementInViewport(domNode, viewportHeight)) {
                        return;
                    }
                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages
                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)
                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left
                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically
                    htmlElement.scrollTop = 0;
                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document
                    if (!topOfElementInViewport(domNode, viewportHeight)) {
                        // Scroll into view doesn't scroll horizontally by default when not needed
                        ;
                        domNode.scrollIntoView();
                    }
                }, {
                    // We will force layout by querying domNode position
                    dontForceLayout: true,
                    onlyHashChange: focusAndScrollRef.onlyHashChange
                });
                // Mutate after scrolling so that it can be read by `disableSmoothScrollDuringRouteTransition`
                focusAndScrollRef.onlyHashChange = false;
                // Set focus on the element
                domNode.focus();
            }
        };
    }
}
function ScrollAndFocusHandler(param) {
    let { segmentPath, children } = param;
    const context = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);
    if (!context) {
        throw Object.defineProperty(new Error('invariant global layout router not mounted'), "__NEXT_ERROR_CODE", {
            value: "E473",
            enumerable: false,
            configurable: true
        });
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerScrollAndFocusHandler, {
        segmentPath: segmentPath,
        focusAndScrollRef: context.focusAndScrollRef,
        children: children
    });
}
/**
 * InnerLayoutRouter handles rendering the provided segment based on the cache.
 */ function InnerLayoutRouter(param) {
    let { tree, segmentPath, cacheNode, url } = param;
    const context = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);
    if (!context) {
        throw Object.defineProperty(new Error('invariant global layout router not mounted'), "__NEXT_ERROR_CODE", {
            value: "E473",
            enumerable: false,
            configurable: true
        });
    }
    const { tree: fullTree } = context;
    // `rsc` represents the renderable node for this segment.
    // If this segment has a `prefetchRsc`, it's the statically prefetched data.
    // We should use that on initial render instead of `rsc`. Then we'll switch
    // to `rsc` when the dynamic response streams in.
    //
    // If no prefetch data is available, then we go straight to rendering `rsc`.
    const resolvedPrefetchRsc = cacheNode.prefetchRsc !== null ? cacheNode.prefetchRsc : cacheNode.rsc;
    // We use `useDeferredValue` to handle switching between the prefetched and
    // final values. The second argument is returned on initial render, then it
    // re-renders with the first argument.
    const rsc = (0, _react.useDeferredValue)(cacheNode.rsc, resolvedPrefetchRsc);
    // `rsc` is either a React node or a promise for a React node, except we
    // special case `null` to represent that this segment's data is missing. If
    // it's a promise, we need to unwrap it so we can determine whether or not the
    // data is missing.
    const resolvedRsc = typeof rsc === 'object' && rsc !== null && typeof rsc.then === 'function' ? (0, _react.use)(rsc) : rsc;
    if (!resolvedRsc) {
        // The data for this segment is not available, and there's no pending
        // navigation that will be able to fulfill it. We need to fetch more from
        // the server and patch the cache.
        // Check if there's already a pending request.
        let lazyData = cacheNode.lazyData;
        if (lazyData === null) {
            /**
       * Router state with refetch marker added
       */ // TODO-APP: remove ''
            const refetchTree = walkAddRefetch([
                '',
                ...segmentPath
            ], fullTree);
            const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(fullTree);
            const navigatedAt = Date.now();
            cacheNode.lazyData = lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(url, location.origin), {
                flightRouterState: refetchTree,
                nextUrl: includeNextUrl ? context.nextUrl : null
            }).then((serverResponse)=>{
                (0, _react.startTransition)(()=>{
                    (0, _useactionqueue.dispatchAppRouterAction)({
                        type: _routerreducertypes.ACTION_SERVER_PATCH,
                        previousTree: fullTree,
                        serverResponse,
                        navigatedAt
                    });
                });
                return serverResponse;
            });
            // Suspend while waiting for lazyData to resolve
            (0, _react.use)(lazyData);
        }
        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.
        // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.
        (0, _react.use)(_unresolvedthenable.unresolvedThenable);
    }
    // If we get to this point, then we know we have something we can render.
    const subtree = /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {
        value: {
            parentTree: tree,
            parentCacheNode: cacheNode,
            parentSegmentPath: segmentPath,
            // TODO-APP: overriding of url for parallel routes
            url: url
        },
        children: resolvedRsc
    });
    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`
    return subtree;
}
/**
 * Renders suspense boundary with the provided "loading" property as the fallback.
 * If no loading property is provided it renders the children without a suspense boundary.
 */ function LoadingBoundary(param) {
    let { loading, children } = param;
    // If loading is a promise, unwrap it. This happens in cases where we haven't
    // yet received the loading data from the server  which includes whether or
    // not this layout has a loading component at all.
    //
    // It's OK to suspend here instead of inside the fallback because this
    // promise will resolve simultaneously with the data for the segment itself.
    // So it will never suspend for longer than it would have if we didn't use
    // a Suspense fallback at all.
    let loadingModuleData;
    if (typeof loading === 'object' && loading !== null && typeof loading.then === 'function') {
        const promiseForLoading = loading;
        loadingModuleData = (0, _react.use)(promiseForLoading);
    } else {
        loadingModuleData = loading;
    }
    if (loadingModuleData) {
        const loadingRsc = loadingModuleData[0];
        const loadingStyles = loadingModuleData[1];
        const loadingScripts = loadingModuleData[2];
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {
            fallback: /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                children: [
                    loadingStyles,
                    loadingScripts,
                    loadingRsc
                ]
            }),
            children: children
        });
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
        children: children
    });
}
function RenderChildren(param) {
    let { children } = param;
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
        children: children
    });
}
function OuterLayoutRouter(param) {
    let { parallelRouterKey, error, errorStyles, errorScripts, templateStyles, templateScripts, template, notFound, forbidden, unauthorized, gracefullyDegrade, segmentViewBoundaries } = param;
    const context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);
    if (!context) {
        throw Object.defineProperty(new Error('invariant expected layout router to be mounted'), "__NEXT_ERROR_CODE", {
            value: "E56",
            enumerable: false,
            configurable: true
        });
    }
    const { parentTree, parentCacheNode, parentSegmentPath, url } = context;
    // Get the CacheNode for this segment by reading it from the parent segment's
    // child map.
    const parentParallelRoutes = parentCacheNode.parallelRoutes;
    let segmentMap = parentParallelRoutes.get(parallelRouterKey);
    // If the parallel router cache node does not exist yet, create it.
    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.
    if (!segmentMap) {
        segmentMap = new Map();
        parentParallelRoutes.set(parallelRouterKey, segmentMap);
    }
    const parentTreeSegment = parentTree[0];
    const segmentPath = parentSegmentPath === null ? // the code. We should clean this up.
    [
        parallelRouterKey
    ] : parentSegmentPath.concat([
        parentTreeSegment,
        parallelRouterKey
    ]);
    // The "state" key of a segment is the one passed to React  it represents the
    // identity of the UI tree. Whenever the state key changes, the tree is
    // recreated and the state is reset. In the App Router model, search params do
    // not cause state to be lost, so two segments with the same segment path but
    // different search params should have the same state key.
    //
    // The "cache" key of a segment, however, *does* include the search params, if
    // it's possible that the segment accessed the search params on the server.
    // (This only applies to page segments; layout segments cannot access search
    // params on the server.)
    const activeTree = parentTree[1][parallelRouterKey];
    const activeSegment = activeTree[0];
    const activeStateKey = (0, _createroutercachekey.createRouterCacheKey)(activeSegment, true) // no search params
    ;
    // At each level of the route tree, not only do we render the currently
    // active segment  we also render the last N segments that were active at
    // this level inside a hidden <Activity> boundary, to preserve their state
    // if or when the user navigates to them again.
    //
    // bfcacheEntry is a linked list of FlightRouterStates.
    let bfcacheEntry = (0, _bfcache.useRouterBFCache)(activeTree, activeStateKey);
    let children = [];
    do {
        const tree = bfcacheEntry.tree;
        const stateKey = bfcacheEntry.stateKey;
        const segment = tree[0];
        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);
        // Read segment path from the parallel router cache node.
        let cacheNode = segmentMap.get(cacheKey);
        if (cacheNode === undefined) {
            // When data is not available during rendering client-side we need to fetch
            // it from the server.
            const newLazyCacheNode = {
                lazyData: null,
                rsc: null,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                loading: null,
                navigatedAt: -1
            };
            // Flight data fetch kicked off during render and put into the cache.
            cacheNode = newLazyCacheNode;
            segmentMap.set(cacheKey, newLazyCacheNode);
        }
        /*
    - Error boundary
      - Only renders error boundary if error component is provided.
      - Rendered for each segment to ensure they have their own error state.
      - When gracefully degrade for bots, skip rendering error boundary.
    - Loading boundary
      - Only renders suspense boundary if loading components is provided.
      - Rendered for each segment to ensure they have their own loading state.
      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.
  */ const ErrorBoundaryComponent = gracefullyDegrade ? RenderChildren : _errorboundary.ErrorBoundary;
        let segmentBoundaryTriggerNode = null;
        let segmentViewStateNode = null;
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        // TODO: The loading module data for a segment is stored on the parent, then
        // applied to each of that parent segment's parallel route slots. In the
        // simple case where there's only one parallel route (the `children` slot),
        // this is no different from if the loading module data where stored on the
        // child directly. But I'm not sure this actually makes sense when there are
        // multiple parallel routes. It's not a huge issue because you always have
        // the option to define a narrower loading boundary for a particular slot. But
        // this sort of smells like an implementation accident to me.
        const loadingModuleData = parentCacheNode.loading;
        let child = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_approutercontextsharedruntime.TemplateContext.Provider, {
            value: /*#__PURE__*/ (0, _jsxruntime.jsxs)(ScrollAndFocusHandler, {
                segmentPath: segmentPath,
                children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsx)(ErrorBoundaryComponent, {
                        errorComponent: error,
                        errorStyles: errorStyles,
                        errorScripts: errorScripts,
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(LoadingBoundary, {
                            loading: loadingModuleData,
                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary1.HTTPAccessFallbackBoundary, {
                                notFound: notFound,
                                forbidden: forbidden,
                                unauthorized: unauthorized,
                                children: /*#__PURE__*/ (0, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {
                                    children: [
                                        /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerLayoutRouter, {
                                            url: url,
                                            tree: tree,
                                            cacheNode: cacheNode,
                                            segmentPath: segmentPath
                                        }),
                                        segmentBoundaryTriggerNode
                                    ]
                                })
                            })
                        })
                    }),
                    segmentViewStateNode
                ]
            }),
            children: [
                templateStyles,
                templateScripts,
                template
            ]
        }, stateKey);
        if ("TURBOPACK compile-time truthy", 1) {
            const { SegmentStateProvider } = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js [app-client] (ecmascript)");
            child = /*#__PURE__*/ (0, _jsxruntime.jsxs)(SegmentStateProvider, {
                children: [
                    child,
                    segmentViewBoundaries
                ]
            }, stateKey);
        }
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        children.push(child);
        bfcacheEntry = bfcacheEntry.next;
    }while (bfcacheEntry !== null)
    return children;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=layout-router.js.map
}}),
"[project]/node_modules/next/dist/client/components/render-from-template-context.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return RenderFromTemplateContext;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)");
function RenderFromTemplateContext() {
    const children = (0, _react.useContext)(_approutercontextsharedruntime.TemplateContext);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
        children: children
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=render-from-template-context.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "InvariantError", {
    enumerable: true,
    get: function() {
        return InvariantError;
    }
});
class InvariantError extends Error {
    constructor(message, options){
        super("Invariant: " + (message.endsWith('.') ? message : message + '.') + " This is a bug in Next.js.", options);
        this.name = 'InvariantError';
    }
} //# sourceMappingURL=invariant-error.js.map
}}),
"[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ReflectAdapter", {
    enumerable: true,
    get: function() {
        return ReflectAdapter;
    }
});
class ReflectAdapter {
    static get(target, prop, receiver) {
        const value = Reflect.get(target, prop, receiver);
        if (typeof value === 'function') {
            return value.bind(target);
        }
        return value;
    }
    static set(target, prop, value, receiver) {
        return Reflect.set(target, prop, value, receiver);
    }
    static has(target, prop) {
        return Reflect.has(target, prop);
    }
    static deleteProperty(target, prop) {
        return Reflect.deleteProperty(target, prop);
    }
} //# sourceMappingURL=reflect.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/utils/reflect-utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// This regex will have fast negatives meaning valid identifiers may not pass
// this test. However this is only used during static generation to provide hints
// about why a page bailed out of some or all prerendering and we can use bracket notation
// for example while `_` is a valid identifier it's ok to print `searchParams['_']`
// even if this would have been fine too `searchParams._`
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    describeHasCheckingStringProperty: null,
    describeStringPropertyAccess: null,
    wellKnownProperties: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    describeHasCheckingStringProperty: function() {
        return describeHasCheckingStringProperty;
    },
    describeStringPropertyAccess: function() {
        return describeStringPropertyAccess;
    },
    wellKnownProperties: function() {
        return wellKnownProperties;
    }
});
const isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/;
function describeStringPropertyAccess(target, prop) {
    if (isDefinitelyAValidIdentifier.test(prop)) {
        return "`" + target + "." + prop + "`";
    }
    return "`" + target + "[" + JSON.stringify(prop) + "]`";
}
function describeHasCheckingStringProperty(target, prop) {
    const stringifiedProp = JSON.stringify(prop);
    return "`Reflect.has(" + target + ", " + stringifiedProp + ")`, `" + stringifiedProp + " in " + target + "`, or similar";
}
const wellKnownProperties = new Set([
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toString',
    'valueOf',
    'toLocaleString',
    // Promise prototype
    // fallthrough
    'then',
    'catch',
    'finally',
    // React Promise extension
    // fallthrough
    'status',
    // React introspection
    'displayName',
    '_debugInfo',
    // Common tested properties
    // fallthrough
    'toJSON',
    '$$typeof',
    '__esModule'
]); //# sourceMappingURL=reflect-utils.js.map
}}),
"[project]/node_modules/next/dist/client/request/search-params.browser.dev.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createRenderSearchParamsFromClient", {
    enumerable: true,
    get: function() {
        return createRenderSearchParamsFromClient;
    }
});
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)");
const _reflectutils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/reflect-utils.js [app-client] (ecmascript)");
const CachedSearchParams = new WeakMap();
function makeUntrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams) {
    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    const promise = Promise.resolve(underlyingSearchParams);
    Object.keys(underlyingSearchParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
            // These properties cannot be shadowed because they need to be the
            // true underlying value for Promises to work correctly at runtime
            unproxiedProperties.push(prop);
        } else {
            proxiedProperties.add(prop);
            promise[prop] = underlyingSearchParams[prop];
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('searchParams', prop);
                    warnForSyncAccess(expression);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return Reflect.set(target, prop, value, receiver);
        },
        has (target, prop) {
            if (typeof prop === 'string') {
                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, _reflectutils.describeHasCheckingStringProperty)('searchParams', prop);
                    warnForSyncAccess(expression);
                }
            }
            return Reflect.has(target, prop);
        },
        ownKeys (target) {
            warnForSyncSpread();
            return Reflect.ownKeys(target);
        }
    });
    CachedSearchParams.set(underlyingSearchParams, proxiedPromise);
    return proxiedPromise;
}
// Similar to `makeUntrackedExoticSearchParamsWithDevWarnings`, but just logging
// the sync access without actually defining the search params on the promise.
function makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams) {
    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    const promise = Promise.resolve(underlyingSearchParams);
    Object.keys(underlyingSearchParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
            // These properties cannot be shadowed because they need to be the
            // true underlying value for Promises to work correctly at runtime
            unproxiedProperties.push(prop);
        } else {
            proxiedProperties.add(prop);
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('searchParams', prop);
                    warnForSyncAccess(expression);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return Reflect.set(target, prop, value, receiver);
        },
        has (target, prop) {
            if (typeof prop === 'string') {
                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, _reflectutils.describeHasCheckingStringProperty)('searchParams', prop);
                    warnForSyncAccess(expression);
                }
            }
            return Reflect.has(target, prop);
        },
        ownKeys (target) {
            warnForSyncSpread();
            return Reflect.ownKeys(target);
        }
    });
    CachedSearchParams.set(underlyingSearchParams, proxiedPromise);
    return proxiedPromise;
}
function warnForSyncAccess(expression) {
    console.error("A searchParam property was accessed directly with " + expression + ". " + "`searchParams` should be unwrapped with `React.use()` before accessing its properties. " + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis");
}
function warnForSyncSpread() {
    console.error("The keys of `searchParams` were accessed directly. " + "`searchParams` should be unwrapped with `React.use()` before accessing its properties. " + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis");
}
function createRenderSearchParamsFromClient(underlyingSearchParams) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return makeUntrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=search-params.browser.dev.js.map
}}),
"[project]/node_modules/next/dist/client/request/search-params.browser.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createRenderSearchParamsFromClient", {
    enumerable: true,
    get: function() {
        return createRenderSearchParamsFromClient;
    }
});
const createRenderSearchParamsFromClient = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[project]/node_modules/next/dist/client/request/search-params.browser.dev.js [app-client] (ecmascript)").createRenderSearchParamsFromClient : "TURBOPACK unreachable";
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=search-params.browser.js.map
}}),
"[project]/node_modules/next/dist/client/request/params.browser.dev.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createRenderParamsFromClient", {
    enumerable: true,
    get: function() {
        return createRenderParamsFromClient;
    }
});
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)");
const _reflectutils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/reflect-utils.js [app-client] (ecmascript)");
const CachedParams = new WeakMap();
function makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    // We don't use makeResolvedReactPromise here because params
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = Promise.resolve(underlyingParams);
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    Object.keys(underlyingParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
        // These properties cannot be shadowed because they need to be the
        // true underlying value for Promises to work correctly at runtime
        } else {
            proxiedProperties.add(prop);
            promise[prop] = underlyingParams[prop];
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (proxiedProperties.has(prop)) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('params', prop);
                    warnForSyncAccess(expression);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return _reflect.ReflectAdapter.set(target, prop, value, receiver);
        },
        ownKeys (target) {
            warnForEnumeration(unproxiedProperties);
            return Reflect.ownKeys(target);
        }
    });
    CachedParams.set(underlyingParams, proxiedPromise);
    return proxiedPromise;
}
// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just
// logging the sync access without actually defining the params on the promise.
function makeDynamicallyTrackedParamsWithDevWarnings(underlyingParams) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    // We don't use makeResolvedReactPromise here because params
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = Promise.resolve(underlyingParams);
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    Object.keys(underlyingParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
        // These properties cannot be shadowed because they need to be the
        // true underlying value for Promises to work correctly at runtime
        } else {
            proxiedProperties.add(prop);
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (proxiedProperties.has(prop)) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('params', prop);
                    warnForSyncAccess(expression);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return _reflect.ReflectAdapter.set(target, prop, value, receiver);
        },
        ownKeys (target) {
            warnForEnumeration(unproxiedProperties);
            return Reflect.ownKeys(target);
        }
    });
    CachedParams.set(underlyingParams, proxiedPromise);
    return proxiedPromise;
}
function warnForSyncAccess(expression) {
    console.error("A param property was accessed directly with " + expression + ". `params` is now a Promise and should be unwrapped with `React.use()` before accessing properties of the underlying params object. In this version of Next.js direct access to param properties is still supported to facilitate migration but in a future version you will be required to unwrap `params` with `React.use()`.");
}
function warnForEnumeration(missingProperties) {
    if (missingProperties.length) {
        const describedMissingProperties = describeListOfPropertyNames(missingProperties);
        console.error("params are being enumerated incompletely missing these properties: " + describedMissingProperties + ". " + "`params` should be unwrapped with `React.use()` before using its value. " + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis");
    } else {
        console.error("params are being enumerated. " + "`params` should be unwrapped with `React.use()` before using its value. " + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis");
    }
}
function describeListOfPropertyNames(properties) {
    switch(properties.length){
        case 0:
            throw Object.defineProperty(new _invarianterror.InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.'), "__NEXT_ERROR_CODE", {
                value: "E531",
                enumerable: false,
                configurable: true
            });
        case 1:
            return "`" + properties[0] + "`";
        case 2:
            return "`" + properties[0] + "` and `" + properties[1] + "`";
        default:
            {
                let description = '';
                for(let i = 0; i < properties.length - 1; i++){
                    description += "`" + properties[i] + "`, ";
                }
                description += ", and `" + properties[properties.length - 1] + "`";
                return description;
            }
    }
}
function createRenderParamsFromClient(clientParams) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return makeDynamicallyTrackedExoticParamsWithDevWarnings(clientParams);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=params.browser.dev.js.map
}}),
"[project]/node_modules/next/dist/client/request/params.browser.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createRenderParamsFromClient", {
    enumerable: true,
    get: function() {
        return createRenderParamsFromClient;
    }
});
const createRenderParamsFromClient = ("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[project]/node_modules/next/dist/client/request/params.browser.dev.js [app-client] (ecmascript)").createRenderParamsFromClient : "TURBOPACK unreachable";
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=params.browser.js.map
}}),
"[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createDedupedByCallsiteServerErrorLoggerDev", {
    enumerable: true,
    get: function() {
        return createDedupedByCallsiteServerErrorLoggerDev;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const errorRef = {
    current: null
};
// React.cache is currently only available in canary/experimental React channels.
const cache = typeof _react.cache === 'function' ? _react.cache : (fn)=>fn;
// When Dynamic IO is enabled, we record these as errors so that they
// are captured by the dev overlay as it's more critical to fix these
// when enabled.
const logErrorOrWarn = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : console.warn;
// We don't want to dedupe across requests.
// The developer might've just attempted to fix the warning so we should warn again if it still happens.
const flushCurrentErrorIfNew = cache((key)=>{
    try {
        logErrorOrWarn(errorRef.current);
    } finally{
        errorRef.current = null;
    }
});
function createDedupedByCallsiteServerErrorLoggerDev(getMessage) {
    return function logDedupedError() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        const message = getMessage(...args);
        if ("TURBOPACK compile-time truthy", 1) {
            var _stack;
            const callStackFrames = (_stack = new Error().stack) == null ? void 0 : _stack.split('\n');
            if (callStackFrames === undefined || callStackFrames.length < 4) {
                logErrorOrWarn(message);
            } else {
                // Error:
                //   logDedupedError
                //   asyncApiBeingAccessedSynchronously
                //   <userland callsite>
                // TODO: This breaks if sourcemaps with ignore lists are enabled.
                const key = callStackFrames[4];
                errorRef.current = message;
                flushCurrentErrorIfNew(key);
            }
        } else //TURBOPACK unreachable
        ;
    };
} //# sourceMappingURL=create-deduped-by-callsite-server-error-logger.js.map
}}),
"[project]/node_modules/next/dist/server/app-render/after-task-async-storage-instance.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "afterTaskAsyncStorageInstance", {
    enumerable: true,
    get: function() {
        return afterTaskAsyncStorageInstance;
    }
});
const _asynclocalstorage = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/async-local-storage.js [app-client] (ecmascript)");
const afterTaskAsyncStorageInstance = (0, _asynclocalstorage.createAsyncLocalStorage)(); //# sourceMappingURL=after-task-async-storage-instance.js.map
}}),
"[project]/node_modules/next/dist/server/app-render/after-task-async-storage.external.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "afterTaskAsyncStorage", {
    enumerable: true,
    get: function() {
        return _aftertaskasyncstorageinstance.afterTaskAsyncStorageInstance;
    }
});
const _aftertaskasyncstorageinstance = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/after-task-async-storage-instance.js [app-client] (ecmascript)"); //# sourceMappingURL=after-task-async-storage.external.js.map
}}),
"[project]/node_modules/next/dist/server/request/utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    isRequestAPICallableInsideAfter: null,
    throwForSearchParamsAccessInUseCache: null,
    throwWithStaticGenerationBailoutError: null,
    throwWithStaticGenerationBailoutErrorWithDynamicError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    isRequestAPICallableInsideAfter: function() {
        return isRequestAPICallableInsideAfter;
    },
    throwForSearchParamsAccessInUseCache: function() {
        return throwForSearchParamsAccessInUseCache;
    },
    throwWithStaticGenerationBailoutError: function() {
        return throwWithStaticGenerationBailoutError;
    },
    throwWithStaticGenerationBailoutErrorWithDynamicError: function() {
        return throwWithStaticGenerationBailoutErrorWithDynamicError;
    }
});
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-client] (ecmascript)");
const _aftertaskasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/after-task-async-storage.external.js [app-client] (ecmascript)");
function throwWithStaticGenerationBailoutError(route, expression) {
    throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError("Route ".concat(route, " couldn't be rendered statically because it used ").concat(expression, ". See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering")), "__NEXT_ERROR_CODE", {
        value: "E576",
        enumerable: false,
        configurable: true
    });
}
function throwWithStaticGenerationBailoutErrorWithDynamicError(route, expression) {
    throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError("Route ".concat(route, ' with `dynamic = "error"` couldn\'t be rendered statically because it used ').concat(expression, ". See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering")), "__NEXT_ERROR_CODE", {
        value: "E543",
        enumerable: false,
        configurable: true
    });
}
function throwForSearchParamsAccessInUseCache(workStore, constructorOpt) {
    var _workStore;
    const error = Object.defineProperty(new Error("Route ".concat(workStore.route, ' used "searchParams" inside "use cache". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "searchParams" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache')), "__NEXT_ERROR_CODE", {
        value: "E634",
        enumerable: false,
        configurable: true
    });
    Error.captureStackTrace(error, constructorOpt);
    var _invalidDynamicUsageError;
    (_invalidDynamicUsageError = (_workStore = workStore).invalidDynamicUsageError) !== null && _invalidDynamicUsageError !== void 0 ? _invalidDynamicUsageError : _workStore.invalidDynamicUsageError = error;
    throw error;
}
function isRequestAPICallableInsideAfter() {
    const afterTaskStore = _aftertaskasyncstorageexternal.afterTaskAsyncStorage.getStore();
    return (afterTaskStore == null ? void 0 : afterTaskStore.rootTaskSpawnPhase) === 'action';
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/next/dist/server/request/search-params.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createPrerenderSearchParamsForClientPage: null,
    createSearchParamsFromClient: null,
    createServerSearchParamsForMetadata: null,
    createServerSearchParamsForServerPage: null,
    makeErroringExoticSearchParamsForUseCache: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createPrerenderSearchParamsForClientPage: function() {
        return createPrerenderSearchParamsForClientPage;
    },
    createSearchParamsFromClient: function() {
        return createSearchParamsFromClient;
    },
    createServerSearchParamsForMetadata: function() {
        return createServerSearchParamsForMetadata;
    },
    createServerSearchParamsForServerPage: function() {
        return createServerSearchParamsForServerPage;
    },
    makeErroringExoticSearchParamsForUseCache: function() {
        return makeErroringExoticSearchParamsForUseCache;
    }
});
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-client] (ecmascript)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js [app-client] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)");
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-client] (ecmascript)");
const _creatededupedbycallsiteservererrorlogger = __turbopack_context__.r("[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-client] (ecmascript)");
const _reflectutils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/reflect-utils.js [app-client] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/utils.js [app-client] (ecmascript)");
const _scheduler = __turbopack_context__.r("[project]/node_modules/next/dist/lib/scheduler.js [app-client] (ecmascript)");
function createSearchParamsFromClient(underlyingSearchParams, workStore) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                return createPrerenderSearchParams(workStore, workUnitStore);
            default:
        }
    }
    return createRenderSearchParams(underlyingSearchParams, workStore);
}
const createServerSearchParamsForMetadata = createServerSearchParamsForServerPage;
function createServerSearchParamsForServerPage(underlyingSearchParams, workStore) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                return createPrerenderSearchParams(workStore, workUnitStore);
            default:
        }
    }
    return createRenderSearchParams(underlyingSearchParams, workStore);
}
function createPrerenderSearchParamsForClientPage(workStore) {
    if (workStore.forceStatic) {
        // When using forceStatic we override all other logic and always just return an empty
        // dictionary object.
        return Promise.resolve({});
    }
    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (prerenderStore && (prerenderStore.type === 'prerender' || prerenderStore.type === 'prerender-client')) {
        // dynamicIO Prerender
        // We're prerendering in a mode that aborts (dynamicIO) and should stall
        // the promise to ensure the RSC side is considered dynamic
        return (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`searchParams`');
    }
    // We're prerendering in a mode that does not aborts. We resolve the promise without
    // any tracking because we're just transporting a value from server to client where the tracking
    // will be applied.
    return Promise.resolve({});
}
function createPrerenderSearchParams(workStore, prerenderStore) {
    if (workStore.forceStatic) {
        // When using forceStatic we override all other logic and always just return an empty
        // dictionary object.
        return Promise.resolve({});
    }
    switch(prerenderStore.type){
        case 'prerender':
        case 'prerender-client':
            // We are in a dynamicIO (PPR or otherwise) prerender
            return makeHangingSearchParams(prerenderStore);
        default:
            // The remaining cases are prerender-ppr and prerender-legacy
            // We are in a legacy static generation and need to interrupt the prerender
            // when search params are accessed.
            return makeErroringExoticSearchParams(workStore, prerenderStore);
    }
}
function createRenderSearchParams(underlyingSearchParams, workStore) {
    if (workStore.forceStatic) {
        // When using forceStatic we override all other logic and always just return an empty
        // dictionary object.
        return Promise.resolve({});
    } else {
        if (("TURBOPACK compile-time value", "development") === 'development' && !workStore.isPrefetchRequest) {
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            return makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, workStore);
        } else {
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            return makeUntrackedExoticSearchParams(underlyingSearchParams, workStore);
        }
    }
}
const CachedSearchParams = new WeakMap();
const CachedSearchParamsForUseCache = new WeakMap();
function makeHangingSearchParams(prerenderStore) {
    const cachedSearchParams = CachedSearchParams.get(prerenderStore);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const promise = (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`searchParams`');
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (Object.hasOwn(promise, prop)) {
                // The promise has this property directly. we must return it.
                // We know it isn't a dynamic access because it can only be something
                // that was previously written to the promise and thus not an underlying searchParam value
                return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
            switch(prop){
                case 'then':
                    {
                        const expression = '`await searchParams`, `searchParams.then`, or similar';
                        (0, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                    }
                case 'status':
                    {
                        const expression = '`use(searchParams)`, `searchParams.status`, or similar';
                        (0, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                    }
                default:
                    {
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                    }
            }
        }
    });
    CachedSearchParams.set(prerenderStore, proxiedPromise);
    return proxiedPromise;
}
function makeErroringExoticSearchParams(workStore, prerenderStore) {
    const cachedSearchParams = CachedSearchParams.get(workStore);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const underlyingSearchParams = {};
    // For search params we don't construct a ReactPromise because we want to interrupt
    // rendering on any property access that was not set from outside and so we only want
    // to have properties like value and status if React sets them.
    const promise = Promise.resolve(underlyingSearchParams);
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (Object.hasOwn(promise, prop)) {
                // The promise has this property directly. we must return it.
                // We know it isn't a dynamic access because it can only be something
                // that was previously written to the promise and thus not an underlying searchParam value
                return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
            switch(prop){
                case 'then':
                    {
                        const expression = '`await searchParams`, `searchParams.then`, or similar';
                        if (workStore.dynamicShouldError) {
                            (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);
                        } else if (prerenderStore.type === 'prerender-ppr') {
                            // PPR Prerender (no dynamicIO)
                            (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);
                        } else {
                            // Legacy Prerender
                            (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);
                        }
                        return;
                    }
                case 'status':
                    {
                        const expression = '`use(searchParams)`, `searchParams.status`, or similar';
                        if (workStore.dynamicShouldError) {
                            (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);
                        } else if (prerenderStore.type === 'prerender-ppr') {
                            // PPR Prerender (no dynamicIO)
                            (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);
                        } else {
                            // Legacy Prerender
                            (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);
                        }
                        return;
                    }
                default:
                    {
                        if (typeof prop === 'string' && !_reflectutils.wellKnownProperties.has(prop)) {
                            const expression = (0, _reflectutils.describeStringPropertyAccess)('searchParams', prop);
                            if (workStore.dynamicShouldError) {
                                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);
                            } else if (prerenderStore.type === 'prerender-ppr') {
                                // PPR Prerender (no dynamicIO)
                                (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);
                            } else {
                                // Legacy Prerender
                                (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);
                            }
                        }
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                    }
            }
        },
        has (target, prop) {
            // We don't expect key checking to be used except for testing the existence of
            // searchParams so we make all has tests trigger dynamic. this means that `promise.then`
            // can resolve to the then function on the Promise prototype but 'then' in promise will assume
            // you are testing whether the searchParams has a 'then' property.
            if (typeof prop === 'string') {
                const expression = (0, _reflectutils.describeHasCheckingStringProperty)('searchParams', prop);
                if (workStore.dynamicShouldError) {
                    (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);
                } else if (prerenderStore.type === 'prerender-ppr') {
                    // PPR Prerender (no dynamicIO)
                    (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);
                } else {
                    // Legacy Prerender
                    (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);
                }
                return false;
            }
            return _reflect.ReflectAdapter.has(target, prop);
        },
        ownKeys () {
            const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';
            if (workStore.dynamicShouldError) {
                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);
            } else if (prerenderStore.type === 'prerender-ppr') {
                // PPR Prerender (no dynamicIO)
                (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);
            } else {
                // Legacy Prerender
                (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);
            }
        }
    });
    CachedSearchParams.set(workStore, proxiedPromise);
    return proxiedPromise;
}
function makeErroringExoticSearchParamsForUseCache(workStore) {
    const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const promise = Promise.resolve({});
    const proxiedPromise = new Proxy(promise, {
        get: function get(target, prop, receiver) {
            if (Object.hasOwn(promise, prop)) {
                // The promise has this property directly. we must return it. We know it
                // isn't a dynamic access because it can only be something that was
                // previously written to the promise and thus not an underlying
                // searchParam value
                return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
            if (typeof prop === 'string' && (prop === 'then' || !_reflectutils.wellKnownProperties.has(prop))) {
                (0, _utils.throwForSearchParamsAccessInUseCache)(workStore, get);
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        has: function has(target, prop) {
            // We don't expect key checking to be used except for testing the existence of
            // searchParams so we make all has tests throw an error. this means that `promise.then`
            // can resolve to the then function on the Promise prototype but 'then' in promise will assume
            // you are testing whether the searchParams has a 'then' property.
            if (typeof prop === 'string' && (prop === 'then' || !_reflectutils.wellKnownProperties.has(prop))) {
                (0, _utils.throwForSearchParamsAccessInUseCache)(workStore, has);
            }
            return _reflect.ReflectAdapter.has(target, prop);
        },
        ownKeys: function ownKeys() {
            (0, _utils.throwForSearchParamsAccessInUseCache)(workStore, ownKeys);
        }
    });
    CachedSearchParamsForUseCache.set(workStore, proxiedPromise);
    return proxiedPromise;
}
function makeUntrackedExoticSearchParams(underlyingSearchParams, store) {
    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    // We don't use makeResolvedReactPromise here because searchParams
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = Promise.resolve(underlyingSearchParams);
    CachedSearchParams.set(underlyingSearchParams, promise);
    Object.keys(underlyingSearchParams).forEach((prop)=>{
        if (!_reflectutils.wellKnownProperties.has(prop)) {
            Object.defineProperty(promise, prop, {
                get () {
                    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
                    (0, _dynamicrendering.trackDynamicDataInDynamicRender)(store, workUnitStore);
                    return underlyingSearchParams[prop];
                },
                set (value) {
                    Object.defineProperty(promise, prop, {
                        value,
                        writable: true,
                        enumerable: true
                    });
                },
                enumerable: true,
                configurable: true
            });
        }
    });
    return promise;
}
function makeUntrackedSearchParams(underlyingSearchParams) {
    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const promise = Promise.resolve(underlyingSearchParams);
    CachedSearchParams.set(underlyingSearchParams, promise);
    return promise;
}
function makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, store) {
    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying
    // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender
    // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking
    // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger
    // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce
    // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.
    let promiseInitialized = false;
    const proxiedUnderlying = new Proxy(underlyingSearchParams, {
        get (target, prop, receiver) {
            if (typeof prop === 'string' && promiseInitialized) {
                if (store.dynamicShouldError) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('searchParams', prop);
                    (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);
                }
                const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
                (0, _dynamicrendering.trackDynamicDataInDynamicRender)(store, workUnitStore);
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        has (target, prop) {
            if (typeof prop === 'string') {
                if (store.dynamicShouldError) {
                    const expression = (0, _reflectutils.describeHasCheckingStringProperty)('searchParams', prop);
                    (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);
                }
            }
            return Reflect.has(target, prop);
        },
        ownKeys (target) {
            if (store.dynamicShouldError) {
                const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';
                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);
            }
            return Reflect.ownKeys(target);
        }
    });
    // We don't use makeResolvedReactPromise here because searchParams
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = new Promise((resolve)=>(0, _scheduler.scheduleImmediate)(()=>resolve(underlyingSearchParams)));
    promise.then(()=>{
        promiseInitialized = true;
    });
    Object.keys(underlyingSearchParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
            // These properties cannot be shadowed because they need to be the
            // true underlying value for Promises to work correctly at runtime
            unproxiedProperties.push(prop);
        } else {
            proxiedProperties.add(prop);
            Object.defineProperty(promise, prop, {
                get () {
                    return proxiedUnderlying[prop];
                },
                set (newValue) {
                    Object.defineProperty(promise, prop, {
                        value: newValue,
                        writable: true,
                        enumerable: true
                    });
                },
                enumerable: true,
                configurable: true
            });
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (prop === 'then' && store.dynamicShouldError) {
                const expression = '`searchParams.then`';
                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);
            }
            if (typeof prop === 'string') {
                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('searchParams', prop);
                    syncIODev(store.route, expression);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return Reflect.set(target, prop, value, receiver);
        },
        has (target, prop) {
            if (typeof prop === 'string') {
                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, _reflectutils.describeHasCheckingStringProperty)('searchParams', prop);
                    syncIODev(store.route, expression);
                }
            }
            return Reflect.has(target, prop);
        },
        ownKeys (target) {
            const expression = '`Object.keys(searchParams)` or similar';
            syncIODev(store.route, expression, unproxiedProperties);
            return Reflect.ownKeys(target);
        }
    });
    CachedSearchParams.set(underlyingSearchParams, proxiedPromise);
    return proxiedPromise;
}
// Similar to `makeDynamicallyTrackedExoticSearchParamsWithDevWarnings`, but
// just logging the sync access without actually defining the search params on
// the promise.
function makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams, store) {
    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);
    if (cachedSearchParams) {
        return cachedSearchParams;
    }
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    const promise = Promise.resolve(underlyingSearchParams);
    Object.keys(underlyingSearchParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
            // These properties cannot be shadowed because they need to be the
            // true underlying value for Promises to work correctly at runtime
            unproxiedProperties.push(prop);
        } else {
            proxiedProperties.add(prop);
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('searchParams', prop);
                    warnForSyncAccess(store.route, expression);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return Reflect.set(target, prop, value, receiver);
        },
        has (target, prop) {
            if (typeof prop === 'string') {
                if (!_reflectutils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor
                // the underlying searchParams.
                Reflect.has(target, prop) === false)) {
                    const expression = (0, _reflectutils.describeHasCheckingStringProperty)('searchParams', prop);
                    warnForSyncAccess(store.route, expression);
                }
            }
            return Reflect.has(target, prop);
        },
        ownKeys (target) {
            const expression = '`Object.keys(searchParams)` or similar';
            warnForIncompleteEnumeration(store.route, expression, unproxiedProperties);
            return Reflect.ownKeys(target);
        }
    });
    CachedSearchParams.set(underlyingSearchParams, proxiedPromise);
    return proxiedPromise;
}
function syncIODev(route, expression, missingProperties) {
    // In all cases we warn normally
    if (missingProperties && missingProperties.length > 0) {
        warnForIncompleteEnumeration(route, expression, missingProperties);
    } else {
        warnForSyncAccess(route, expression);
    }
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {
        // When we're rendering dynamically in dev we need to advance out of the
        // Prerender environment when we read Request data synchronously
        const requestStore = workUnitStore;
        (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);
    }
}
const warnForSyncAccess = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createSearchAccessError);
const warnForIncompleteEnumeration = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createIncompleteEnumerationError);
function createSearchAccessError(route, expression) {
    const prefix = route ? 'Route "'.concat(route, '" ') : 'This route ';
    return Object.defineProperty(new Error("".concat(prefix, "used ").concat(expression, ". ") + "`searchParams` should be awaited before using its properties. " + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis"), "__NEXT_ERROR_CODE", {
        value: "E249",
        enumerable: false,
        configurable: true
    });
}
function createIncompleteEnumerationError(route, expression, missingProperties) {
    const prefix = route ? 'Route "'.concat(route, '" ') : 'This route ';
    return Object.defineProperty(new Error("".concat(prefix, "used ").concat(expression, ". ") + "`searchParams` should be awaited before using its properties. " + "The following properties were not available through enumeration " + "because they conflict with builtin or well-known property names: " + "".concat(describeListOfPropertyNames(missingProperties), ". ") + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis"), "__NEXT_ERROR_CODE", {
        value: "E2",
        enumerable: false,
        configurable: true
    });
}
function describeListOfPropertyNames(properties) {
    switch(properties.length){
        case 0:
            throw Object.defineProperty(new _invarianterror.InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.'), "__NEXT_ERROR_CODE", {
                value: "E531",
                enumerable: false,
                configurable: true
            });
        case 1:
            return "`".concat(properties[0], "`");
        case 2:
            return "`".concat(properties[0], "` and `").concat(properties[1], "`");
        default:
            {
                let description = '';
                for(let i = 0; i < properties.length - 1; i++){
                    description += "`".concat(properties[i], "`, ");
                }
                description += ", and `".concat(properties[properties.length - 1], "`");
                return description;
            }
    }
} //# sourceMappingURL=search-params.js.map
}}),
"[project]/node_modules/next/dist/server/app-render/dynamic-access-async-storage-instance.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "dynamicAccessAsyncStorageInstance", {
    enumerable: true,
    get: function() {
        return dynamicAccessAsyncStorageInstance;
    }
});
const _asynclocalstorage = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/async-local-storage.js [app-client] (ecmascript)");
const dynamicAccessAsyncStorageInstance = (0, _asynclocalstorage.createAsyncLocalStorage)(); //# sourceMappingURL=dynamic-access-async-storage-instance.js.map
}}),
"[project]/node_modules/next/dist/server/app-render/dynamic-access-async-storage.external.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "dynamicAccessAsyncStorage", {
    enumerable: true,
    get: function() {
        return _dynamicaccessasyncstorageinstance.dynamicAccessAsyncStorageInstance;
    }
});
const _dynamicaccessasyncstorageinstance = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-access-async-storage-instance.js [app-client] (ecmascript)"); //# sourceMappingURL=dynamic-access-async-storage.external.js.map
}}),
"[project]/node_modules/next/dist/server/request/params.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createParamsFromClient: null,
    createPrerenderParamsForClientSegment: null,
    createServerParamsForMetadata: null,
    createServerParamsForRoute: null,
    createServerParamsForServerSegment: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createParamsFromClient: function() {
        return createParamsFromClient;
    },
    createPrerenderParamsForClientSegment: function() {
        return createPrerenderParamsForClientSegment;
    },
    createServerParamsForMetadata: function() {
        return createServerParamsForMetadata;
    },
    createServerParamsForRoute: function() {
        return createServerParamsForRoute;
    },
    createServerParamsForServerSegment: function() {
        return createServerParamsForServerSegment;
    }
});
const _reflect = __turbopack_context__.r("[project]/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js [app-client] (ecmascript)");
const _dynamicrendering = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-client] (ecmascript)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js [app-client] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)");
const _reflectutils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/reflect-utils.js [app-client] (ecmascript)");
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-client] (ecmascript)");
const _creatededupedbycallsiteservererrorlogger = __turbopack_context__.r("[project]/node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js [app-client] (ecmascript)");
const _scheduler = __turbopack_context__.r("[project]/node_modules/next/dist/lib/scheduler.js [app-client] (ecmascript)");
const _dynamicaccessasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/dynamic-access-async-storage.external.js [app-client] (ecmascript)");
function createParamsFromClient(underlyingParams, workStore) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                return createPrerenderParams(underlyingParams, workStore, workUnitStore);
            default:
        }
    }
    return createRenderParams(underlyingParams, workStore);
}
const createServerParamsForMetadata = createServerParamsForServerSegment;
function createServerParamsForRoute(underlyingParams, workStore) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                return createPrerenderParams(underlyingParams, workStore, workUnitStore);
            default:
        }
    }
    return createRenderParams(underlyingParams, workStore);
}
function createServerParamsForServerSegment(underlyingParams, workStore) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore) {
        switch(workUnitStore.type){
            case 'prerender':
            case 'prerender-client':
            case 'prerender-ppr':
            case 'prerender-legacy':
                return createPrerenderParams(underlyingParams, workStore, workUnitStore);
            default:
        }
    }
    return createRenderParams(underlyingParams, workStore);
}
function createPrerenderParamsForClientSegment(underlyingParams, workStore) {
    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (prerenderStore && (prerenderStore.type === 'prerender' || prerenderStore.type === 'prerender-client')) {
        const fallbackParams = workStore.fallbackRouteParams;
        if (fallbackParams) {
            for(let key in underlyingParams){
                if (fallbackParams.has(key)) {
                    // This params object has one of more fallback params so we need to consider
                    // the awaiting of this params object "dynamic". Since we are in dynamicIO mode
                    // we encode this as a promise that never resolves
                    return (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`params`');
                }
            }
        }
    }
    // We're prerendering in a mode that does not abort. We resolve the promise without
    // any tracking because we're just transporting a value from server to client where the tracking
    // will be applied.
    return Promise.resolve(underlyingParams);
}
function createPrerenderParams(underlyingParams, workStore, prerenderStore) {
    const fallbackParams = workStore.fallbackRouteParams;
    if (fallbackParams) {
        let hasSomeFallbackParams = false;
        for(const key in underlyingParams){
            if (fallbackParams.has(key)) {
                hasSomeFallbackParams = true;
                break;
            }
        }
        if (hasSomeFallbackParams) {
            // params need to be treated as dynamic because we have at least one fallback param
            switch(prerenderStore.type){
                case 'prerender':
                case 'prerender-client':
                    // We are in a dynamicIO prerender
                    return makeHangingParams(underlyingParams, prerenderStore);
                default:
                    return makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore);
            }
        }
    }
    // We don't have any fallback params so we have an entirely static safe params object
    return makeUntrackedExoticParams(underlyingParams);
}
function createRenderParams(underlyingParams, workStore) {
    if (("TURBOPACK compile-time value", "development") === 'development' && !workStore.isPrefetchRequest) {
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, workStore);
    } else {
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return makeUntrackedExoticParams(underlyingParams);
    }
}
const CachedParams = new WeakMap();
const fallbackParamsProxyHandler = {
    get: function get(target, prop, receiver) {
        if (prop === 'then' || prop === 'catch' || prop === 'finally') {
            const originalMethod = _reflect.ReflectAdapter.get(target, prop, receiver);
            return ({
                [prop]: function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    const store = _dynamicaccessasyncstorageexternal.dynamicAccessAsyncStorage.getStore();
                    if (store) {
                        store.abortController.abort(Object.defineProperty(new Error("Accessed fallback `params` during prerendering."), "__NEXT_ERROR_CODE", {
                            value: "E691",
                            enumerable: false,
                            configurable: true
                        }));
                    }
                    return new Proxy(originalMethod.apply(target, args), fallbackParamsProxyHandler);
                }
            })[prop];
        }
        return _reflect.ReflectAdapter.get(target, prop, receiver);
    }
};
function makeHangingParams(underlyingParams, prerenderStore) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    const promise = new Proxy((0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`params`'), fallbackParamsProxyHandler);
    CachedParams.set(underlyingParams, promise);
    return promise;
}
function makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    const augmentedUnderlying = {
        ...underlyingParams
    };
    // We don't use makeResolvedReactPromise here because params
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = Promise.resolve(augmentedUnderlying);
    CachedParams.set(underlyingParams, promise);
    Object.keys(underlyingParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
        // These properties cannot be shadowed because they need to be the
        // true underlying value for Promises to work correctly at runtime
        } else {
            if (fallbackParams.has(prop)) {
                Object.defineProperty(augmentedUnderlying, prop, {
                    get () {
                        const expression = (0, _reflectutils.describeStringPropertyAccess)('params', prop);
                        // In most dynamic APIs we also throw if `dynamic = "error"` however
                        // for params is only dynamic when we're generating a fallback shell
                        // and even when `dynamic = "error"` we still support generating dynamic
                        // fallback shells
                        // TODO remove this comment when dynamicIO is the default since there
                        // will be no `dynamic = "error"`
                        if (prerenderStore.type === 'prerender-ppr') {
                            // PPR Prerender (no dynamicIO)
                            (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);
                        } else {
                            // Legacy Prerender
                            (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);
                        }
                    },
                    enumerable: true
                });
                Object.defineProperty(promise, prop, {
                    get () {
                        const expression = (0, _reflectutils.describeStringPropertyAccess)('params', prop);
                        // In most dynamic APIs we also throw if `dynamic = "error"` however
                        // for params is only dynamic when we're generating a fallback shell
                        // and even when `dynamic = "error"` we still support generating dynamic
                        // fallback shells
                        // TODO remove this comment when dynamicIO is the default since there
                        // will be no `dynamic = "error"`
                        if (prerenderStore.type === 'prerender-ppr') {
                            // PPR Prerender (no dynamicIO)
                            (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);
                        } else {
                            // Legacy Prerender
                            (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);
                        }
                    },
                    set (newValue) {
                        Object.defineProperty(promise, prop, {
                            value: newValue,
                            writable: true,
                            enumerable: true
                        });
                    },
                    enumerable: true,
                    configurable: true
                });
            } else {
                ;
                promise[prop] = underlyingParams[prop];
            }
        }
    });
    return promise;
}
function makeUntrackedExoticParams(underlyingParams) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    // We don't use makeResolvedReactPromise here because params
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = Promise.resolve(underlyingParams);
    CachedParams.set(underlyingParams, promise);
    Object.keys(underlyingParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
        // These properties cannot be shadowed because they need to be the
        // true underlying value for Promises to work correctly at runtime
        } else {
            ;
            promise[prop] = underlyingParams[prop];
        }
    });
    return promise;
}
function makeUntrackedParams(underlyingParams) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    const promise = Promise.resolve(underlyingParams);
    CachedParams.set(underlyingParams, promise);
    return promise;
}
function makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, store) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    // We don't use makeResolvedReactPromise here because params
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = new Promise((resolve)=>(0, _scheduler.scheduleImmediate)(()=>resolve(underlyingParams)));
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    Object.keys(underlyingParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
            // These properties cannot be shadowed because they need to be the
            // true underlying value for Promises to work correctly at runtime
            unproxiedProperties.push(prop);
        } else {
            proxiedProperties.add(prop);
            promise[prop] = underlyingParams[prop];
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (proxiedProperties.has(prop)) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('params', prop);
                    syncIODev(store.route, expression);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return _reflect.ReflectAdapter.set(target, prop, value, receiver);
        },
        ownKeys (target) {
            const expression = '`...params` or similar expression';
            syncIODev(store.route, expression, unproxiedProperties);
            return Reflect.ownKeys(target);
        }
    });
    CachedParams.set(underlyingParams, proxiedPromise);
    return proxiedPromise;
}
// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just
// logging the sync access without actually defining the params on the promise.
function makeDynamicallyTrackedParamsWithDevWarnings(underlyingParams, store) {
    const cachedParams = CachedParams.get(underlyingParams);
    if (cachedParams) {
        return cachedParams;
    }
    // We don't use makeResolvedReactPromise here because params
    // supports copying with spread and we don't want to unnecessarily
    // instrument the promise with spreadable properties of ReactPromise.
    const promise = new Promise((resolve)=>(0, _scheduler.scheduleImmediate)(()=>resolve(underlyingParams)));
    const proxiedProperties = new Set();
    const unproxiedProperties = [];
    Object.keys(underlyingParams).forEach((prop)=>{
        if (_reflectutils.wellKnownProperties.has(prop)) {
            // These properties cannot be shadowed because they need to be the
            // true underlying value for Promises to work correctly at runtime
            unproxiedProperties.push(prop);
        } else {
            proxiedProperties.add(prop);
        }
    });
    const proxiedPromise = new Proxy(promise, {
        get (target, prop, receiver) {
            if (typeof prop === 'string') {
                if (proxiedProperties.has(prop)) {
                    const expression = (0, _reflectutils.describeStringPropertyAccess)('params', prop);
                    warnForSyncAccess(store.route, expression);
                }
            }
            return _reflect.ReflectAdapter.get(target, prop, receiver);
        },
        set (target, prop, value, receiver) {
            if (typeof prop === 'string') {
                proxiedProperties.delete(prop);
            }
            return _reflect.ReflectAdapter.set(target, prop, value, receiver);
        },
        ownKeys (target) {
            const expression = '`...params` or similar expression';
            warnForIncompleteEnumeration(store.route, expression, unproxiedProperties);
            return Reflect.ownKeys(target);
        }
    });
    CachedParams.set(underlyingParams, proxiedPromise);
    return proxiedPromise;
}
function syncIODev(route, expression, missingProperties) {
    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {
        // When we're rendering dynamically in dev we need to advance out of the
        // Prerender environment when we read Request data synchronously
        const requestStore = workUnitStore;
        (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);
    }
    // In all cases we warn normally
    if (missingProperties && missingProperties.length > 0) {
        warnForIncompleteEnumeration(route, expression, missingProperties);
    } else {
        warnForSyncAccess(route, expression);
    }
}
const warnForSyncAccess = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createParamsAccessError);
const warnForIncompleteEnumeration = (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createIncompleteEnumerationError);
function createParamsAccessError(route, expression) {
    const prefix = route ? 'Route "'.concat(route, '" ') : 'This route ';
    return Object.defineProperty(new Error("".concat(prefix, "used ").concat(expression, ". ") + "`params` should be awaited before using its properties. " + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis"), "__NEXT_ERROR_CODE", {
        value: "E307",
        enumerable: false,
        configurable: true
    });
}
function createIncompleteEnumerationError(route, expression, missingProperties) {
    const prefix = route ? 'Route "'.concat(route, '" ') : 'This route ';
    return Object.defineProperty(new Error("".concat(prefix, "used ").concat(expression, ". ") + "`params` should be awaited before using its properties. " + "The following properties were not available through enumeration " + "because they conflict with builtin property names: " + "".concat(describeListOfPropertyNames(missingProperties), ". ") + "Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis"), "__NEXT_ERROR_CODE", {
        value: "E482",
        enumerable: false,
        configurable: true
    });
}
function describeListOfPropertyNames(properties) {
    switch(properties.length){
        case 0:
            throw Object.defineProperty(new _invarianterror.InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.'), "__NEXT_ERROR_CODE", {
                value: "E531",
                enumerable: false,
                configurable: true
            });
        case 1:
            return "`".concat(properties[0], "`");
        case 2:
            return "`".concat(properties[0], "` and `").concat(properties[1], "`");
        default:
            {
                let description = '';
                for(let i = 0; i < properties.length - 1; i++){
                    description += "`".concat(properties[i], "`, ");
                }
                description += ", and `".concat(properties[properties.length - 1], "`");
                return description;
            }
    }
} //# sourceMappingURL=params.js.map
}}),
"[project]/node_modules/next/dist/client/components/client-page.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ClientPageRoot", {
    enumerable: true,
    get: function() {
        return ClientPageRoot;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)");
function ClientPageRoot(param) {
    let { Component, searchParams, params, promises } = param;
    if (typeof window === 'undefined') {
        const { workAsyncStorage } = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)");
        let clientSearchParams;
        let clientParams;
        // We are going to instrument the searchParams prop with tracking for the
        // appropriate context. We wrap differently in prerendering vs rendering
        const store = workAsyncStorage.getStore();
        if (!store) {
            throw Object.defineProperty(new _invarianterror.InvariantError('Expected workStore to exist when handling searchParams in a client Page.'), "__NEXT_ERROR_CODE", {
                value: "E564",
                enumerable: false,
                configurable: true
            });
        }
        const { createSearchParamsFromClient } = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/search-params.js [app-client] (ecmascript)");
        clientSearchParams = createSearchParamsFromClient(searchParams, store);
        const { createParamsFromClient } = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/params.js [app-client] (ecmascript)");
        clientParams = createParamsFromClient(params, store);
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {
            params: clientParams,
            searchParams: clientSearchParams
        });
    } else {
        const { createRenderSearchParamsFromClient } = __turbopack_context__.r("[project]/node_modules/next/dist/client/request/search-params.browser.js [app-client] (ecmascript)");
        const clientSearchParams = createRenderSearchParamsFromClient(searchParams);
        const { createRenderParamsFromClient } = __turbopack_context__.r("[project]/node_modules/next/dist/client/request/params.browser.js [app-client] (ecmascript)");
        const clientParams = createRenderParamsFromClient(params);
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {
            params: clientParams,
            searchParams: clientSearchParams
        });
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=client-page.js.map
}}),
"[project]/node_modules/next/dist/client/components/client-segment.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ClientSegmentRoot", {
    enumerable: true,
    get: function() {
        return ClientSegmentRoot;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _invarianterror = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)");
function ClientSegmentRoot(param) {
    let { Component, slots, params, promise } = param;
    if (typeof window === 'undefined') {
        const { workAsyncStorage } = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)");
        let clientParams;
        // We are going to instrument the searchParams prop with tracking for the
        // appropriate context. We wrap differently in prerendering vs rendering
        const store = workAsyncStorage.getStore();
        if (!store) {
            throw Object.defineProperty(new _invarianterror.InvariantError('Expected workStore to exist when handling params in a client segment such as a Layout or Template.'), "__NEXT_ERROR_CODE", {
                value: "E600",
                enumerable: false,
                configurable: true
            });
        }
        const { createParamsFromClient } = __turbopack_context__.r("[project]/node_modules/next/dist/server/request/params.js [app-client] (ecmascript)");
        clientParams = createParamsFromClient(params, store);
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {
            ...slots,
            params: clientParams
        });
    } else {
        const { createRenderParamsFromClient } = __turbopack_context__.r("[project]/node_modules/next/dist/client/request/params.browser.js [app-client] (ecmascript)");
        const clientParams = createRenderParamsFromClient(params);
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {
            ...slots,
            params: clientParams
        });
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=client-segment.js.map
}}),
"[project]/node_modules/next/dist/lib/metadata/generate/icon-mark.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "IconMark", {
    enumerable: true,
    get: function() {
        return IconMark;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const IconMark = ()=>{
    if (typeof window !== 'undefined') {
        return null;
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
        name: "\xabnxt-icon\xbb"
    });
}; //# sourceMappingURL=icon-mark.js.map
}}),
"[project]/node_modules/next/dist/client/components/metadata/async-metadata.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AsyncMetadataOutlet", {
    enumerable: true,
    get: function() {
        return AsyncMetadataOutlet;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
function MetadataOutlet(param) {
    let { promise } = param;
    const { error, digest } = (0, _react.use)(promise);
    if (error) {
        if (digest) {
            // The error will lose its original digest after passing from server layer to client layer
            // We recover the digest property here to override the React created one if original digest exists.
            ;
            error.digest = digest;
        }
        throw error;
    }
    return null;
}
function AsyncMetadataOutlet(param) {
    let { promise } = param;
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {
        fallback: null,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(MetadataOutlet, {
            promise: promise
        })
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=async-metadata.js.map
}}),
"[project]/node_modules/next/dist/client/components/metadata/metadata-boundary.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    MetadataBoundary: null,
    OutletBoundary: null,
    ViewportBoundary: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    MetadataBoundary: function() {
        return MetadataBoundary;
    },
    OutletBoundary: function() {
        return OutletBoundary;
    },
    ViewportBoundary: function() {
        return ViewportBoundary;
    }
});
const _metadataconstants = __turbopack_context__.r("[project]/node_modules/next/dist/lib/metadata/metadata-constants.js [app-client] (ecmascript)");
// We use a namespace object to allow us to recover the name of the function
// at runtime even when production bundling/minification is used.
const NameSpace = {
    [_metadataconstants.METADATA_BOUNDARY_NAME]: function(param) {
        let { children } = param;
        return children;
    },
    [_metadataconstants.VIEWPORT_BOUNDARY_NAME]: function(param) {
        let { children } = param;
        return children;
    },
    [_metadataconstants.OUTLET_BOUNDARY_NAME]: function(param) {
        let { children } = param;
        return children;
    }
};
const MetadataBoundary = // so it retains the name inferred from the namespace object
NameSpace[_metadataconstants.METADATA_BOUNDARY_NAME.slice(0)];
const ViewportBoundary = // so it retains the name inferred from the namespace object
NameSpace[_metadataconstants.VIEWPORT_BOUNDARY_NAME.slice(0)];
const OutletBoundary = // so it retains the name inferred from the namespace object
NameSpace[_metadataconstants.OUTLET_BOUNDARY_NAME.slice(0)];
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=metadata-boundary.js.map
}}),
}]);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFtdLAogICJzZWN0aW9ucyI6IFsKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cblxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5cbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0O1xuICB9XG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICB9XG4gIHJldHVybiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2VzRGVjb3JhdGUoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcbiAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xuICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xuICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xuICAgICAgfVxuICB9XG4gIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcbiAgZG9uZSA9IHRydWU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19ydW5Jbml0aWFsaXplcnModGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xuICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcbiAgfVxuICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Byb3BLZXkoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCIgPyB4IDogXCJcIi5jb25jYXQoeCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19zZXRGdW5jdGlvbk5hbWUoZiwgbmFtZSwgcHJlZml4KSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikgbmFtZSA9IG5hbWUuZGVzY3JpcHRpb24gPyBcIltcIi5jb25jYXQobmFtZS5kZXNjcmlwdGlvbiwgXCJdXCIpIDogXCJcIjtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcIm5hbWVcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFwiLCBuYW1lKSA6IG5hbWUgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEl0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKTtcbiAgcmV0dXJuIGcubmV4dCA9IHZlcmIoMCksIGdbXCJ0aHJvd1wiXSA9IHZlcmIoMSksIGdbXCJyZXR1cm5cIl0gPSB2ZXJiKDIpLCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gIH1cbn1cblxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcbiAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgfVxuICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSkgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gIGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgIH1cbiAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICB9XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XG4gIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICByZXR1cm4gYXI7XG59XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgcltrXSA9IGFbal07XG4gIHJldHVybiByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XG4gIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XG4gIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcbiAgdmFyIGksIHA7XG4gIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IGZhbHNlIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcbiAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gIHJldHVybiBjb29rZWQ7XG59O1xuXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59O1xuXG52YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgdmFyIGFyID0gW107XG4gICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICByZXR1cm4gYXI7XG4gIH07XG4gIHJldHVybiBvd25LZXlzKG8pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xuICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XG4gIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xuICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52LCB2YWx1ZSwgYXN5bmMpIHtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkLlwiKTtcbiAgICB2YXIgZGlzcG9zZSwgaW5uZXI7XG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICB9XG4gICAgaWYgKGRpc3Bvc2UgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKCFTeW1ib2wuZGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5kaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuZGlzcG9zZV07XG4gICAgICBpZiAoYXN5bmMpIGlubmVyID0gZGlzcG9zZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkaXNwb3NlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qgbm90IGRpc3Bvc2FibGUuXCIpO1xuICAgIGlmIChpbm5lcikgZGlzcG9zZSA9IGZ1bmN0aW9uKCkgeyB0cnkgeyBpbm5lci5jYWxsKHRoaXMpOyB9IGNhdGNoIChlKSB7IHJldHVybiBQcm9taXNlLnJlamVjdChlKTsgfSB9O1xuICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XG4gIH1cbiAgZWxzZSBpZiAoYXN5bmMpIHtcbiAgICBlbnYuc3RhY2sucHVzaCh7IGFzeW5jOiB0cnVlIH0pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIF9TdXBwcmVzc2VkRXJyb3IgPSB0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19kaXNwb3NlUmVzb3VyY2VzKGVudikge1xuICBmdW5jdGlvbiBmYWlsKGUpIHtcbiAgICBlbnYuZXJyb3IgPSBlbnYuaGFzRXJyb3IgPyBuZXcgX1N1cHByZXNzZWRFcnJvcihlLCBlbnYuZXJyb3IsIFwiQW4gZXJyb3Igd2FzIHN1cHByZXNzZWQgZHVyaW5nIGRpc3Bvc2FsLlwiKSA6IGU7XG4gICAgZW52Lmhhc0Vycm9yID0gdHJ1ZTtcbiAgfVxuICB2YXIgciwgcyA9IDA7XG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgd2hpbGUgKHIgPSBlbnYuc3RhY2sucG9wKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghci5hc3luYyAmJiBzID09PSAxKSByZXR1cm4gcyA9IDAsIGVudi5zdGFjay5wdXNoKHIpLCBQcm9taXNlLnJlc29sdmUoKS50aGVuKG5leHQpO1xuICAgICAgICBpZiAoci5kaXNwb3NlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHIuZGlzcG9zZS5jYWxsKHIudmFsdWUpO1xuICAgICAgICAgIGlmIChyLmFzeW5jKSByZXR1cm4gcyB8PSAyLCBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKG5leHQsIGZ1bmN0aW9uKGUpIHsgZmFpbChlKTsgcmV0dXJuIG5leHQoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBzIHw9IDE7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBmYWlsKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocyA9PT0gMSkgcmV0dXJuIGVudi5oYXNFcnJvciA/IFByb21pc2UucmVqZWN0KGVudi5lcnJvcikgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBpZiAoZW52Lmhhc0Vycm9yKSB0aHJvdyBlbnYuZXJyb3I7XG4gIH1cbiAgcmV0dXJuIG5leHQoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmV3cml0ZVJlbGF0aXZlSW1wb3J0RXh0ZW5zaW9uKHBhdGgsIHByZXNlcnZlSnN4KSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiAmJiAvXlxcLlxcLj9cXC8vLnRlc3QocGF0aCkpIHtcbiAgICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcLih0c3gpJHwoKD86XFwuZCk/KSgoPzpcXC5bXi4vXSs/KT8pXFwuKFtjbV0/KXRzJC9pLCBmdW5jdGlvbiAobSwgdHN4LCBkLCBleHQsIGNtKSB7XG4gICAgICAgICAgcmV0dXJuIHRzeCA/IHByZXNlcnZlSnN4ID8gXCIuanN4XCIgOiBcIi5qc1wiIDogZCAmJiAoIWV4dCB8fCAhY20pID8gbSA6IChkICsgZXh0ICsgXCIuXCIgKyBjbS50b0xvd2VyQ2FzZSgpICsgXCJqc1wiKTtcbiAgICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZXh0ZW5kcyxcbiAgX19hc3NpZ24sXG4gIF9fcmVzdCxcbiAgX19kZWNvcmF0ZSxcbiAgX19wYXJhbSxcbiAgX19lc0RlY29yYXRlLFxuICBfX3J1bkluaXRpYWxpemVycyxcbiAgX19wcm9wS2V5LFxuICBfX3NldEZ1bmN0aW9uTmFtZSxcbiAgX19tZXRhZGF0YSxcbiAgX19hd2FpdGVyLFxuICBfX2dlbmVyYXRvcixcbiAgX19jcmVhdGVCaW5kaW5nLFxuICBfX2V4cG9ydFN0YXIsXG4gIF9fdmFsdWVzLFxuICBfX3JlYWQsXG4gIF9fc3ByZWFkLFxuICBfX3NwcmVhZEFycmF5cyxcbiAgX19zcHJlYWRBcnJheSxcbiAgX19hd2FpdCxcbiAgX19hc3luY0dlbmVyYXRvcixcbiAgX19hc3luY0RlbGVnYXRvcixcbiAgX19hc3luY1ZhbHVlcyxcbiAgX19tYWtlVGVtcGxhdGVPYmplY3QsXG4gIF9faW1wb3J0U3RhcixcbiAgX19pbXBvcnREZWZhdWx0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4sXG4gIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlLFxuICBfX2Rpc3Bvc2VSZXNvdXJjZXMsXG4gIF9fcmV3cml0ZVJlbGF0aXZlSW1wb3J0RXh0ZW5zaW9uLFxufTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FDOUUsOERBQThEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUU5RCxJQUFJLGdCQUFnQixTQUFTLENBQUMsRUFBRSxDQUFDO0lBQy9CLGdCQUFnQixPQUFPLGNBQWMsSUFDaEMsQ0FBQTtRQUFFLFdBQVcsRUFBRTtJQUFDLENBQUEsYUFBYSxTQUFTLFNBQVUsQ0FBQyxFQUFFLENBQUM7UUFBSSxFQUFFLFNBQVMsR0FBRztJQUFHLEtBQzFFLFNBQVUsQ0FBQyxFQUFFLENBQUM7UUFBSSxJQUFLLElBQUksS0FBSyxFQUFHLElBQUksT0FBTyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRTtJQUFFO0lBQ3BHLE9BQU8sY0FBYyxHQUFHO0FBQzFCO0FBRU8sU0FBUyxVQUFVLENBQUMsRUFBRSxDQUFDO0lBQzVCLElBQUksT0FBTyxNQUFNLGNBQWMsTUFBTSxNQUNqQyxNQUFNLElBQUksVUFBVSx5QkFBeUIsT0FBTyxLQUFLO0lBQzdELGNBQWMsR0FBRztJQUNqQixTQUFTO1FBQU8sSUFBSSxDQUFDLFdBQVcsR0FBRztJQUFHO0lBQ3RDLEVBQUUsU0FBUyxHQUFHLE1BQU0sT0FBTyxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxTQUFTLEdBQUcsRUFBRSxTQUFTLEVBQUUsSUFBSSxJQUFJO0FBQ3JGO0FBRU8sSUFBSSxXQUFXO0lBQ3BCLFdBQVcsT0FBTyxNQUFNLElBQUksU0FBUyxTQUFTLENBQUM7UUFDM0MsSUFBSyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksVUFBVSxNQUFNLEVBQUUsSUFBSSxHQUFHLElBQUs7WUFDakQsSUFBSSxTQUFTLENBQUMsRUFBRTtZQUNoQixJQUFLLElBQUksS0FBSyxFQUFHLElBQUksT0FBTyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUNoRjtRQUNBLE9BQU87SUFDWDtJQUNBLE9BQU8sU0FBUyxLQUFLLENBQUMsSUFBSSxFQUFFO0FBQzlCO0FBRU8sU0FBUyxPQUFPLENBQUMsRUFBRSxDQUFDO0lBQ3pCLElBQUksSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJLEtBQUssRUFBRyxJQUFJLE9BQU8sU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLEVBQUUsT0FBTyxDQUFDLEtBQUssR0FDOUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRTtJQUNmLElBQUksS0FBSyxRQUFRLE9BQU8sT0FBTyxxQkFBcUIsS0FBSyxZQUNyRCxJQUFLLElBQUksSUFBSSxHQUFHLElBQUksT0FBTyxxQkFBcUIsQ0FBQyxJQUFJLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSztRQUNwRSxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksS0FBSyxPQUFPLFNBQVMsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxHQUN6RSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQ3pCO0lBQ0osT0FBTztBQUNUO0FBRU8sU0FBUyxXQUFXLFVBQVUsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLElBQUk7SUFDdEQsSUFBSSxJQUFJLFVBQVUsTUFBTSxFQUFFLElBQUksSUFBSSxJQUFJLFNBQVMsU0FBUyxPQUFPLE9BQU8sT0FBTyx3QkFBd0IsQ0FBQyxRQUFRLE9BQU8sTUFBTTtJQUMzSCxJQUFJLE9BQU8sWUFBWSxZQUFZLE9BQU8sUUFBUSxRQUFRLEtBQUssWUFBWSxJQUFJLFFBQVEsUUFBUSxDQUFDLFlBQVksUUFBUSxLQUFLO1NBQ3BILElBQUssSUFBSSxJQUFJLFdBQVcsTUFBTSxHQUFHLEdBQUcsS0FBSyxHQUFHLElBQUssSUFBSSxJQUFJLFVBQVUsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFLEtBQUssSUFBSSxJQUFJLEVBQUUsUUFBUSxLQUFLLEtBQUssRUFBRSxRQUFRLElBQUksS0FBSztJQUNoSixPQUFPLElBQUksS0FBSyxLQUFLLE9BQU8sY0FBYyxDQUFDLFFBQVEsS0FBSyxJQUFJO0FBQzlEO0FBRU8sU0FBUyxRQUFRLFVBQVUsRUFBRSxTQUFTO0lBQzNDLE9BQU8sU0FBVSxNQUFNLEVBQUUsR0FBRztRQUFJLFVBQVUsUUFBUSxLQUFLO0lBQWE7QUFDdEU7QUFFTyxTQUFTLGFBQWEsSUFBSSxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxpQkFBaUI7SUFDckcsU0FBUyxPQUFPLENBQUM7UUFBSSxJQUFJLE1BQU0sS0FBSyxLQUFLLE9BQU8sTUFBTSxZQUFZLE1BQU0sSUFBSSxVQUFVO1FBQXNCLE9BQU87SUFBRztJQUN0SCxJQUFJLE9BQU8sVUFBVSxJQUFJLEVBQUUsTUFBTSxTQUFTLFdBQVcsUUFBUSxTQUFTLFdBQVcsUUFBUTtJQUN6RixJQUFJLFNBQVMsQ0FBQyxnQkFBZ0IsT0FBTyxTQUFTLENBQUMsU0FBUyxHQUFHLE9BQU8sS0FBSyxTQUFTLEdBQUc7SUFDbkYsSUFBSSxhQUFhLGdCQUFnQixDQUFDLFNBQVMsT0FBTyx3QkFBd0IsQ0FBQyxRQUFRLFVBQVUsSUFBSSxJQUFJLENBQUMsQ0FBQztJQUN2RyxJQUFJLEdBQUcsT0FBTztJQUNkLElBQUssSUFBSSxJQUFJLFdBQVcsTUFBTSxHQUFHLEdBQUcsS0FBSyxHQUFHLElBQUs7UUFDN0MsSUFBSSxVQUFVLENBQUM7UUFDZixJQUFLLElBQUksS0FBSyxVQUFXLE9BQU8sQ0FBQyxFQUFFLEdBQUcsTUFBTSxXQUFXLENBQUMsSUFBSSxTQUFTLENBQUMsRUFBRTtRQUN4RSxJQUFLLElBQUksS0FBSyxVQUFVLE1BQU0sQ0FBRSxRQUFRLE1BQU0sQ0FBQyxFQUFFLEdBQUcsVUFBVSxNQUFNLENBQUMsRUFBRTtRQUN2RSxRQUFRLGNBQWMsR0FBRyxTQUFVLENBQUM7WUFBSSxJQUFJLE1BQU0sTUFBTSxJQUFJLFVBQVU7WUFBMkQsa0JBQWtCLElBQUksQ0FBQyxPQUFPLEtBQUs7UUFBUTtRQUM1SyxJQUFJLFNBQVMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxFQUFFLEVBQUUsU0FBUyxhQUFhO1lBQUUsS0FBSyxXQUFXLEdBQUc7WUFBRSxLQUFLLFdBQVcsR0FBRztRQUFDLElBQUksVUFBVSxDQUFDLElBQUksRUFBRTtRQUN0SCxJQUFJLFNBQVMsWUFBWTtZQUNyQixJQUFJLFdBQVcsS0FBSyxHQUFHO1lBQ3ZCLElBQUksV0FBVyxRQUFRLE9BQU8sV0FBVyxVQUFVLE1BQU0sSUFBSSxVQUFVO1lBQ3ZFLElBQUksSUFBSSxPQUFPLE9BQU8sR0FBRyxHQUFHLFdBQVcsR0FBRyxHQUFHO1lBQzdDLElBQUksSUFBSSxPQUFPLE9BQU8sR0FBRyxHQUFHLFdBQVcsR0FBRyxHQUFHO1lBQzdDLElBQUksSUFBSSxPQUFPLE9BQU8sSUFBSSxHQUFHLGFBQWEsT0FBTyxDQUFDO1FBQ3RELE9BQ0ssSUFBSSxJQUFJLE9BQU8sU0FBUztZQUN6QixJQUFJLFNBQVMsU0FBUyxhQUFhLE9BQU8sQ0FBQztpQkFDdEMsVUFBVSxDQUFDLElBQUksR0FBRztRQUMzQjtJQUNKO0lBQ0EsSUFBSSxRQUFRLE9BQU8sY0FBYyxDQUFDLFFBQVEsVUFBVSxJQUFJLEVBQUU7SUFDMUQsT0FBTztBQUNUOztBQUVPLFNBQVMsa0JBQWtCLE9BQU8sRUFBRSxZQUFZLEVBQUUsS0FBSztJQUM1RCxJQUFJLFdBQVcsVUFBVSxNQUFNLEdBQUc7SUFDbEMsSUFBSyxJQUFJLElBQUksR0FBRyxJQUFJLGFBQWEsTUFBTSxFQUFFLElBQUs7UUFDMUMsUUFBUSxXQUFXLFlBQVksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsU0FBUyxZQUFZLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQztJQUNuRjtJQUNBLE9BQU8sV0FBVyxRQUFRLEtBQUs7QUFDakM7O0FBRU8sU0FBUyxVQUFVLENBQUM7SUFDekIsT0FBTyxPQUFPLE1BQU0sV0FBVyxJQUFJLEdBQUcsTUFBTSxDQUFDO0FBQy9DOztBQUVPLFNBQVMsa0JBQWtCLENBQUMsRUFBRSxJQUFJLEVBQUUsTUFBTTtJQUMvQyxJQUFJLE9BQU8sU0FBUyxVQUFVLE9BQU8sS0FBSyxXQUFXLEdBQUcsSUFBSSxNQUFNLENBQUMsS0FBSyxXQUFXLEVBQUUsT0FBTztJQUM1RixPQUFPLE9BQU8sY0FBYyxDQUFDLEdBQUcsUUFBUTtRQUFFLGNBQWM7UUFBTSxPQUFPLFNBQVMsR0FBRyxNQUFNLENBQUMsUUFBUSxLQUFLLFFBQVE7SUFBSztBQUNwSDs7QUFFTyxTQUFTLFdBQVcsV0FBVyxFQUFFLGFBQWE7SUFDbkQsSUFBSSxPQUFPLFlBQVksWUFBWSxPQUFPLFFBQVEsUUFBUSxLQUFLLFlBQVksT0FBTyxRQUFRLFFBQVEsQ0FBQyxhQUFhO0FBQ2xIO0FBRU8sU0FBUyxVQUFVLE9BQU8sRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLFNBQVM7SUFDekQsU0FBUyxNQUFNLEtBQUs7UUFBSSxPQUFPLGlCQUFpQixJQUFJLFFBQVEsSUFBSSxFQUFFLFNBQVUsT0FBTztZQUFJLFFBQVE7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLE9BQU8sQ0FBQyxFQUFFLFNBQVUsT0FBTyxFQUFFLE1BQU07UUFDckQsU0FBUyxVQUFVLEtBQUs7WUFBSSxJQUFJO2dCQUFFLEtBQUssVUFBVSxJQUFJLENBQUM7WUFBUyxFQUFFLE9BQU8sR0FBRztnQkFBRSxPQUFPO1lBQUk7UUFBRTtRQUMxRixTQUFTLFNBQVMsS0FBSztZQUFJLElBQUk7Z0JBQUUsS0FBSyxTQUFTLENBQUMsUUFBUSxDQUFDO1lBQVMsRUFBRSxPQUFPLEdBQUc7Z0JBQUUsT0FBTztZQUFJO1FBQUU7UUFDN0YsU0FBUyxLQUFLLE1BQU07WUFBSSxPQUFPLElBQUksR0FBRyxRQUFRLE9BQU8sS0FBSyxJQUFJLE1BQU0sT0FBTyxLQUFLLEVBQUUsSUFBSSxDQUFDLFdBQVc7UUFBVztRQUM3RyxLQUFLLENBQUMsWUFBWSxVQUFVLEtBQUssQ0FBQyxTQUFTLGNBQWMsRUFBRSxDQUFDLEVBQUUsSUFBSTtJQUN0RTtBQUNGO0FBRU8sU0FBUyxZQUFZLE9BQU8sRUFBRSxJQUFJO0lBQ3ZDLElBQUksSUFBSTtRQUFFLE9BQU87UUFBRyxNQUFNO1lBQWEsSUFBSSxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsRUFBRTtZQUFFLE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFBRTtRQUFHLE1BQU0sRUFBRTtRQUFFLEtBQUssRUFBRTtJQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxPQUFPLE1BQU0sQ0FBQyxDQUFDLE9BQU8sYUFBYSxhQUFhLFdBQVcsTUFBTSxFQUFFLFNBQVM7SUFDL0wsT0FBTyxFQUFFLElBQUksR0FBRyxLQUFLLElBQUksQ0FBQyxDQUFDLFFBQVEsR0FBRyxLQUFLLElBQUksQ0FBQyxDQUFDLFNBQVMsR0FBRyxLQUFLLElBQUksT0FBTyxXQUFXLGNBQWMsQ0FBQyxDQUFDLENBQUMsT0FBTyxRQUFRLENBQUMsR0FBRztRQUFhLE9BQU8sSUFBSTtJQUFFLENBQUMsR0FBRzs7O0lBQzFKLFNBQVMsS0FBSyxDQUFDO1FBQUksT0FBTyxTQUFVLENBQUM7WUFBSSxPQUFPLEtBQUs7Z0JBQUM7Z0JBQUc7YUFBRTtRQUFHO0lBQUc7SUFDakUsU0FBUyxLQUFLLEVBQUU7UUFDWixJQUFJLEdBQUcsTUFBTSxJQUFJLFVBQVU7UUFDM0IsTUFBTyxLQUFLLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUcsSUFBSTtZQUMxQyxJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsS0FBSyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksS0FBSyxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsT0FBTztZQUMzSixJQUFJLElBQUksR0FBRyxHQUFHLEtBQUs7Z0JBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRztnQkFBRyxFQUFFLEtBQUs7YUFBQztZQUN2QyxPQUFRLEVBQUUsQ0FBQyxFQUFFO2dCQUNULEtBQUs7Z0JBQUcsS0FBSztvQkFBRyxJQUFJO29CQUFJO2dCQUN4QixLQUFLO29CQUFHLEVBQUUsS0FBSztvQkFBSSxPQUFPO3dCQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUU7d0JBQUUsTUFBTTtvQkFBTTtnQkFDdEQsS0FBSztvQkFBRyxFQUFFLEtBQUs7b0JBQUksSUFBSSxFQUFFLENBQUMsRUFBRTtvQkFBRSxLQUFLO3dCQUFDO3FCQUFFO29CQUFFO2dCQUN4QyxLQUFLO29CQUFHLEtBQUssRUFBRSxHQUFHLENBQUMsR0FBRztvQkFBSSxFQUFFLElBQUksQ0FBQyxHQUFHO29CQUFJO2dCQUN4QztvQkFDSSxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxNQUFNLEdBQUcsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHO3dCQUFFLElBQUk7d0JBQUc7b0JBQVU7b0JBQzNHLElBQUksRUFBRSxDQUFDLEVBQUUsS0FBSyxLQUFLLENBQUMsQ0FBQyxLQUFNLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEFBQUMsR0FBRzt3QkFBRSxFQUFFLEtBQUssR0FBRyxFQUFFLENBQUMsRUFBRTt3QkFBRTtvQkFBTztvQkFDckYsSUFBSSxFQUFFLENBQUMsRUFBRSxLQUFLLEtBQUssRUFBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRTt3QkFBRSxFQUFFLEtBQUssR0FBRyxDQUFDLENBQUMsRUFBRTt3QkFBRSxJQUFJO3dCQUFJO29CQUFPO29CQUNwRSxJQUFJLEtBQUssRUFBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRTt3QkFBRSxFQUFFLEtBQUssR0FBRyxDQUFDLENBQUMsRUFBRTt3QkFBRSxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUM7d0JBQUs7b0JBQU87b0JBQ2xFLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEdBQUcsQ0FBQyxHQUFHO29CQUNuQixFQUFFLElBQUksQ0FBQyxHQUFHO29CQUFJO1lBQ3RCO1lBQ0EsS0FBSyxLQUFLLElBQUksQ0FBQyxTQUFTO1FBQzVCLEVBQUUsT0FBTyxHQUFHO1lBQUUsS0FBSztnQkFBQztnQkFBRzthQUFFO1lBQUUsSUFBSTtRQUFHLFNBQVU7WUFBRSxJQUFJLElBQUk7UUFBRztRQUN6RCxJQUFJLEVBQUUsQ0FBQyxFQUFFLEdBQUcsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFO1FBQUUsT0FBTztZQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEtBQUs7WUFBRyxNQUFNO1FBQUs7SUFDbkY7QUFDRjtBQUVPLElBQUksa0JBQWtCLE9BQU8sTUFBTSxHQUFJLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtJQUNoRSxJQUFJLE9BQU8sV0FBVyxLQUFLO0lBQzNCLElBQUksT0FBTyxPQUFPLHdCQUF3QixDQUFDLEdBQUc7SUFDOUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLE9BQU8sQ0FBQyxFQUFFLFVBQVUsR0FBRyxLQUFLLFFBQVEsSUFBSSxLQUFLLFlBQVksR0FBRztRQUMvRSxPQUFPO1lBQUUsWUFBWTtZQUFNLEtBQUs7Z0JBQWEsT0FBTyxDQUFDLENBQUMsRUFBRTtZQUFFO1FBQUU7SUFDaEU7SUFDQSxPQUFPLGNBQWMsQ0FBQyxHQUFHLElBQUk7QUFDL0IsSUFBTSxTQUFTLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7SUFDeEIsSUFBSSxPQUFPLFdBQVcsS0FBSztJQUMzQixDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFO0FBQ2Q7QUFFTyxTQUFTLGFBQWEsQ0FBQyxFQUFFLENBQUM7SUFDL0IsSUFBSyxJQUFJLEtBQUssRUFBRyxJQUFJLE1BQU0sYUFBYSxDQUFDLE9BQU8sU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLGdCQUFnQixHQUFHLEdBQUc7QUFDN0c7QUFFTyxTQUFTLFNBQVMsQ0FBQztJQUN4QixJQUFJLElBQUksT0FBTyxXQUFXLGNBQWMsT0FBTyxRQUFRLEVBQUUsSUFBSSxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsSUFBSTtJQUM1RSxJQUFJLEdBQUcsT0FBTyxFQUFFLElBQUksQ0FBQztJQUNyQixJQUFJLEtBQUssT0FBTyxFQUFFLE1BQU0sS0FBSyxVQUFVLE9BQU87UUFDMUMsTUFBTTtZQUNGLElBQUksS0FBSyxLQUFLLEVBQUUsTUFBTSxFQUFFLElBQUksS0FBSztZQUNqQyxPQUFPO2dCQUFFLE9BQU8sS0FBSyxDQUFDLENBQUMsSUFBSTtnQkFBRSxNQUFNLENBQUM7WUFBRTtRQUMxQztJQUNKO0lBQ0EsTUFBTSxJQUFJLFVBQVUsSUFBSSw0QkFBNEI7QUFDdEQ7QUFFTyxTQUFTLE9BQU8sQ0FBQyxFQUFFLENBQUM7SUFDekIsSUFBSSxJQUFJLE9BQU8sV0FBVyxjQUFjLENBQUMsQ0FBQyxPQUFPLFFBQVEsQ0FBQztJQUMxRCxJQUFJLENBQUMsR0FBRyxPQUFPO0lBQ2YsSUFBSSxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLEVBQUUsRUFBRTtJQUMvQixJQUFJO1FBQ0EsTUFBTyxDQUFDLE1BQU0sS0FBSyxLQUFLLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEVBQUUsSUFBSSxDQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsS0FBSztJQUM3RSxFQUNBLE9BQU8sT0FBTztRQUFFLElBQUk7WUFBRSxPQUFPO1FBQU07SUFBRyxTQUM5QjtRQUNKLElBQUk7WUFDQSxJQUFJLEtBQUssQ0FBQyxFQUFFLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsR0FBRyxFQUFFLElBQUksQ0FBQztRQUNsRCxTQUNRO1lBQUUsSUFBSSxHQUFHLE1BQU0sRUFBRSxLQUFLO1FBQUU7SUFDcEM7SUFDQSxPQUFPO0FBQ1Q7QUFHTyxTQUFTO0lBQ2QsSUFBSyxJQUFJLEtBQUssRUFBRSxFQUFFLElBQUksR0FBRyxJQUFJLFVBQVUsTUFBTSxFQUFFLElBQzNDLEtBQUssR0FBRyxNQUFNLENBQUMsT0FBTyxTQUFTLENBQUMsRUFBRTtJQUN0QyxPQUFPO0FBQ1Q7QUFHTyxTQUFTO0lBQ2QsSUFBSyxJQUFJLElBQUksR0FBRyxJQUFJLEdBQUcsS0FBSyxVQUFVLE1BQU0sRUFBRSxJQUFJLElBQUksSUFBSyxLQUFLLFNBQVMsQ0FBQyxFQUFFLENBQUMsTUFBTTtJQUNuRixJQUFLLElBQUksSUFBSSxNQUFNLElBQUksSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLElBQUksSUFDekMsSUFBSyxJQUFJLElBQUksU0FBUyxDQUFDLEVBQUUsRUFBRSxJQUFJLEdBQUcsS0FBSyxFQUFFLE1BQU0sRUFBRSxJQUFJLElBQUksS0FBSyxJQUMxRCxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFO0lBQ25CLE9BQU87QUFDVDtBQUVPLFNBQVMsY0FBYyxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUk7SUFDMUMsSUFBSSxRQUFRLFVBQVUsTUFBTSxLQUFLLEdBQUcsSUFBSyxJQUFJLElBQUksR0FBRyxJQUFJLEtBQUssTUFBTSxFQUFFLElBQUksSUFBSSxHQUFHLElBQUs7UUFDakYsSUFBSSxNQUFNLENBQUMsQ0FBQyxLQUFLLElBQUksR0FBRztZQUNwQixJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHO1lBQ2xELEVBQUUsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUU7UUFDbkI7SUFDSjtJQUNBLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxNQUFNLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO0FBQ3BEO0FBRU8sU0FBUyxRQUFRLENBQUM7SUFDdkIsT0FBTyxJQUFJLFlBQVksVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxJQUFJLElBQUksSUFBSSxRQUFRO0FBQ3BFO0FBRU8sU0FBUyxpQkFBaUIsT0FBTyxFQUFFLFVBQVUsRUFBRSxTQUFTO0lBQzdELElBQUksQ0FBQyxPQUFPLGFBQWEsRUFBRSxNQUFNLElBQUksVUFBVTtJQUMvQyxJQUFJLElBQUksVUFBVSxLQUFLLENBQUMsU0FBUyxjQUFjLEVBQUUsR0FBRyxHQUFHLElBQUksRUFBRTtJQUM3RCxPQUFPLElBQUksT0FBTyxNQUFNLENBQUMsQ0FBQyxPQUFPLGtCQUFrQixhQUFhLGdCQUFnQixNQUFNLEVBQUUsU0FBUyxHQUFHLEtBQUssU0FBUyxLQUFLLFVBQVUsS0FBSyxVQUFVLGNBQWMsQ0FBQyxDQUFDLE9BQU8sYUFBYSxDQUFDLEdBQUc7UUFBYyxPQUFPLElBQUk7SUFBRSxHQUFHOzs7SUFDdE4sU0FBUyxZQUFZLENBQUM7UUFBSSxPQUFPLFNBQVUsQ0FBQztZQUFJLE9BQU8sUUFBUSxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRztRQUFTO0lBQUc7SUFDOUYsU0FBUyxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQUksSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxTQUFVLENBQUM7Z0JBQUksT0FBTyxJQUFJLFFBQVEsU0FBVSxDQUFDLEVBQUUsQ0FBQztvQkFBSSxFQUFFLElBQUksQ0FBQzt3QkFBQzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRSxJQUFJLEtBQUssT0FBTyxHQUFHO2dCQUFJO1lBQUk7WUFBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFO1FBQUc7SUFBRTtJQUN2SyxTQUFTLE9BQU8sQ0FBQyxFQUFFLENBQUM7UUFBSSxJQUFJO1lBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQUssRUFBRSxPQUFPLEdBQUc7WUFBRSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQUk7SUFBRTtJQUNqRixTQUFTLEtBQUssQ0FBQztRQUFJLEVBQUUsS0FBSyxZQUFZLFVBQVUsUUFBUSxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLFVBQVUsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtJQUFJO0lBQ3ZILFNBQVMsUUFBUSxLQUFLO1FBQUksT0FBTyxRQUFRO0lBQVE7SUFDakQsU0FBUyxPQUFPLEtBQUs7UUFBSSxPQUFPLFNBQVM7SUFBUTtJQUNqRCxTQUFTLE9BQU8sQ0FBQyxFQUFFLENBQUM7UUFBSSxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssSUFBSSxFQUFFLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUFHO0FBQ25GO0FBRU8sU0FBUyxpQkFBaUIsQ0FBQztJQUNoQyxJQUFJLEdBQUc7SUFDUCxPQUFPLElBQUksQ0FBQyxHQUFHLEtBQUssU0FBUyxLQUFLLFNBQVMsU0FBVSxDQUFDO1FBQUksTUFBTTtJQUFHLElBQUksS0FBSyxXQUFXLENBQUMsQ0FBQyxPQUFPLFFBQVEsQ0FBQyxHQUFHO1FBQWMsT0FBTyxJQUFJO0lBQUUsR0FBRzs7O0lBQzFJLFNBQVMsS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUFJLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxTQUFVLENBQUM7WUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSTtnQkFBRSxPQUFPLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQztnQkFBSyxNQUFNO1lBQU0sSUFBSSxJQUFJLEVBQUUsS0FBSztRQUFHLElBQUk7SUFBRztBQUN2STtBQUVPLFNBQVMsY0FBYyxDQUFDO0lBQzdCLElBQUksQ0FBQyxPQUFPLGFBQWEsRUFBRSxNQUFNLElBQUksVUFBVTtJQUMvQyxJQUFJLElBQUksQ0FBQyxDQUFDLE9BQU8sYUFBYSxDQUFDLEVBQUU7SUFDakMsT0FBTyxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLE9BQU8sYUFBYSxhQUFhLFNBQVMsS0FBSyxDQUFDLENBQUMsT0FBTyxRQUFRLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxLQUFLLFNBQVMsS0FBSyxVQUFVLEtBQUssV0FBVyxDQUFDLENBQUMsT0FBTyxhQUFhLENBQUMsR0FBRztRQUFjLE9BQU8sSUFBSTtJQUFFLEdBQUcsQ0FBQzs7O0lBQy9NLFNBQVMsS0FBSyxDQUFDO1FBQUksQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLFNBQVUsQ0FBQztZQUFJLE9BQU8sSUFBSSxRQUFRLFNBQVUsT0FBTyxFQUFFLE1BQU07Z0JBQUksSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksT0FBTyxTQUFTLFFBQVEsRUFBRSxJQUFJLEVBQUUsRUFBRSxLQUFLO1lBQUc7UUFBSTtJQUFHO0lBQy9KLFNBQVMsT0FBTyxPQUFPLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQUksUUFBUSxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1lBQUksUUFBUTtnQkFBRSxPQUFPO2dCQUFHLE1BQU07WUFBRTtRQUFJLEdBQUc7SUFBUztBQUM3SDtBQUVPLFNBQVMscUJBQXFCLE1BQU0sRUFBRSxHQUFHO0lBQzlDLElBQUksT0FBTyxjQUFjLEVBQUU7UUFBRSxPQUFPLGNBQWMsQ0FBQyxRQUFRLE9BQU87WUFBRSxPQUFPO1FBQUk7SUFBSSxPQUFPO1FBQUUsT0FBTyxHQUFHLEdBQUc7SUFBSztJQUM5RyxPQUFPO0FBQ1Q7O0FBRUEsSUFBSSxxQkFBcUIsT0FBTyxNQUFNLEdBQUksU0FBUyxDQUFDLEVBQUUsQ0FBQztJQUNyRCxPQUFPLGNBQWMsQ0FBQyxHQUFHLFdBQVc7UUFBRSxZQUFZO1FBQU0sT0FBTztJQUFFO0FBQ25FLElBQUssU0FBUyxDQUFDLEVBQUUsQ0FBQztJQUNoQixDQUFDLENBQUMsVUFBVSxHQUFHO0FBQ2pCO0FBRUEsSUFBSSxVQUFVLFNBQVMsQ0FBQztJQUN0QixVQUFVLE9BQU8sbUJBQW1CLElBQUksU0FBVSxDQUFDO1FBQ2pELElBQUksS0FBSyxFQUFFO1FBQ1gsSUFBSyxJQUFJLEtBQUssRUFBRyxJQUFJLE9BQU8sU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHO1FBQ2pGLE9BQU87SUFDVDtJQUNBLE9BQU8sUUFBUTtBQUNqQjtBQUVPLFNBQVMsYUFBYSxHQUFHO0lBQzlCLElBQUksT0FBTyxJQUFJLFVBQVUsRUFBRSxPQUFPO0lBQ2xDLElBQUksU0FBUyxDQUFDO0lBQ2QsSUFBSSxPQUFPLE1BQU07UUFBQSxJQUFLLElBQUksSUFBSSxRQUFRLE1BQU0sSUFBSSxHQUFHLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSyxJQUFJLENBQUMsQ0FBQyxFQUFFLEtBQUssV0FBVyxnQkFBZ0IsUUFBUSxLQUFLLENBQUMsQ0FBQyxFQUFFO0lBQUM7SUFDaEksbUJBQW1CLFFBQVE7SUFDM0IsT0FBTztBQUNUO0FBRU8sU0FBUyxnQkFBZ0IsR0FBRztJQUNqQyxPQUFPLEFBQUMsT0FBTyxJQUFJLFVBQVUsR0FBSSxNQUFNO1FBQUUsU0FBUztJQUFJO0FBQ3hEO0FBRU8sU0FBUyx1QkFBdUIsUUFBUSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUM3RCxJQUFJLFNBQVMsT0FBTyxDQUFDLEdBQUcsTUFBTSxJQUFJLFVBQVU7SUFDNUMsSUFBSSxPQUFPLFVBQVUsYUFBYSxhQUFhLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsV0FBVyxNQUFNLElBQUksVUFBVTtJQUN2RyxPQUFPLFNBQVMsTUFBTSxJQUFJLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQyxZQUFZLElBQUksRUFBRSxLQUFLLEdBQUcsTUFBTSxHQUFHLENBQUM7QUFDdEY7QUFFTyxTQUFTLHVCQUF1QixRQUFRLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUNwRSxJQUFJLFNBQVMsS0FBSyxNQUFNLElBQUksVUFBVTtJQUN0QyxJQUFJLFNBQVMsT0FBTyxDQUFDLEdBQUcsTUFBTSxJQUFJLFVBQVU7SUFDNUMsSUFBSSxPQUFPLFVBQVUsYUFBYSxhQUFhLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsV0FBVyxNQUFNLElBQUksVUFBVTtJQUN2RyxPQUFPLEFBQUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDLFVBQVUsU0FBUyxJQUFJLEVBQUUsS0FBSyxHQUFHLFFBQVEsTUFBTSxHQUFHLENBQUMsVUFBVSxRQUFTO0FBQ3RHO0FBRU8sU0FBUyxzQkFBc0IsS0FBSyxFQUFFLFFBQVE7SUFDbkQsSUFBSSxhQUFhLFFBQVMsT0FBTyxhQUFhLFlBQVksT0FBTyxhQUFhLFlBQWEsTUFBTSxJQUFJLFVBQVU7SUFDL0csT0FBTyxPQUFPLFVBQVUsYUFBYSxhQUFhLFFBQVEsTUFBTSxHQUFHLENBQUM7QUFDdEU7QUFFTyxTQUFTLHdCQUF3QixHQUFHLEVBQUUsS0FBSyxFQUFFLEtBQUs7SUFDdkQsSUFBSSxVQUFVLFFBQVEsVUFBVSxLQUFLLEdBQUc7UUFDdEMsSUFBSSxPQUFPLFVBQVUsWUFBWSxPQUFPLFVBQVUsWUFBWSxNQUFNLElBQUksVUFBVTtRQUNsRixJQUFJLFNBQVM7UUFDYixJQUFJLE9BQU87WUFDVCxJQUFJLENBQUMsT0FBTyxZQUFZLEVBQUUsTUFBTSxJQUFJLFVBQVU7WUFDOUMsVUFBVSxLQUFLLENBQUMsT0FBTyxZQUFZLENBQUM7UUFDdEM7UUFDQSxJQUFJLFlBQVksS0FBSyxHQUFHO1lBQ3RCLElBQUksQ0FBQyxPQUFPLE9BQU8sRUFBRSxNQUFNLElBQUksVUFBVTtZQUN6QyxVQUFVLEtBQUssQ0FBQyxPQUFPLE9BQU8sQ0FBQztZQUMvQixJQUFJLE9BQU8sUUFBUTtRQUNyQjtRQUNBLElBQUksT0FBTyxZQUFZLFlBQVksTUFBTSxJQUFJLFVBQVU7UUFDdkQsSUFBSSxPQUFPLFVBQVU7WUFBYSxJQUFJO2dCQUFFLE1BQU0sSUFBSSxDQUFDLElBQUk7WUFBRyxFQUFFLE9BQU8sR0FBRztnQkFBRSxPQUFPLFFBQVEsTUFBTSxDQUFDO1lBQUk7UUFBRTtRQUNwRyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUM7WUFBRSxPQUFPO1lBQU8sU0FBUztZQUFTLE9BQU87UUFBTTtJQUNoRSxPQUNLLElBQUksT0FBTztRQUNkLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQztZQUFFLE9BQU87UUFBSztJQUMvQjtJQUNBLE9BQU87QUFDVDtBQUVBLElBQUksbUJBQW1CLE9BQU8sb0JBQW9CLGFBQWEsa0JBQWtCLFNBQVUsS0FBSyxFQUFFLFVBQVUsRUFBRSxPQUFPO0lBQ25ILElBQUksSUFBSSxJQUFJLE1BQU07SUFDbEIsT0FBTyxFQUFFLElBQUksR0FBRyxtQkFBbUIsRUFBRSxLQUFLLEdBQUcsT0FBTyxFQUFFLFVBQVUsR0FBRyxZQUFZO0FBQ2pGO0FBRU8sU0FBUyxtQkFBbUIsR0FBRztJQUNwQyxTQUFTLEtBQUssQ0FBQztRQUNiLElBQUksS0FBSyxHQUFHLElBQUksUUFBUSxHQUFHLElBQUksaUJBQWlCLEdBQUcsSUFBSSxLQUFLLEVBQUUsOENBQThDO1FBQzVHLElBQUksUUFBUSxHQUFHO0lBQ2pCO0lBQ0EsSUFBSSxHQUFHLElBQUk7SUFDWCxTQUFTO1FBQ1AsTUFBTyxJQUFJLElBQUksS0FBSyxDQUFDLEdBQUcsR0FBSTtZQUMxQixJQUFJO2dCQUNGLElBQUksQ0FBQyxFQUFFLEtBQUssSUFBSSxNQUFNLEdBQUcsT0FBTyxJQUFJLEdBQUcsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksUUFBUSxPQUFPLEdBQUcsSUFBSSxDQUFDO2dCQUNqRixJQUFJLEVBQUUsT0FBTyxFQUFFO29CQUNiLElBQUksU0FBUyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLO29CQUNuQyxJQUFJLEVBQUUsS0FBSyxFQUFFLE9BQU8sS0FBSyxHQUFHLFFBQVEsT0FBTyxDQUFDLFFBQVEsSUFBSSxDQUFDLE1BQU0sU0FBUyxDQUFDO3dCQUFJLEtBQUs7d0JBQUksT0FBTztvQkFBUTtnQkFDdkcsT0FDSyxLQUFLO1lBQ1osRUFDQSxPQUFPLEdBQUc7Z0JBQ1IsS0FBSztZQUNQO1FBQ0Y7UUFDQSxJQUFJLE1BQU0sR0FBRyxPQUFPLElBQUksUUFBUSxHQUFHLFFBQVEsTUFBTSxDQUFDLElBQUksS0FBSyxJQUFJLFFBQVEsT0FBTztRQUM5RSxJQUFJLElBQUksUUFBUSxFQUFFLE1BQU0sSUFBSSxLQUFLO0lBQ25DO0lBQ0EsT0FBTztBQUNUO0FBRU8sU0FBUyxpQ0FBaUMsSUFBSSxFQUFFLFdBQVc7SUFDaEUsSUFBSSxPQUFPLFNBQVMsWUFBWSxXQUFXLElBQUksQ0FBQyxPQUFPO1FBQ25ELE9BQU8sS0FBSyxPQUFPLENBQUMsb0RBQW9ELFNBQVUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUU7WUFDaEcsT0FBTyxNQUFNLGNBQWMsU0FBUyxRQUFRLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLElBQUksSUFBSyxJQUFJLE1BQU0sTUFBTSxHQUFHLFdBQVcsS0FBSztRQUM3RztJQUNKO0lBQ0EsT0FBTztBQUNUO3VDQUVlO0lBQ2I7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDYwNywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDBmb3JtYXRqcy9mYXN0LW1lbW9pemUvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vXG4vLyBNYWluXG4vL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW9pemUoZm4sIG9wdGlvbnMpIHtcbiAgICB2YXIgY2FjaGUgPSBvcHRpb25zICYmIG9wdGlvbnMuY2FjaGUgPyBvcHRpb25zLmNhY2hlIDogY2FjaGVEZWZhdWx0O1xuICAgIHZhciBzZXJpYWxpemVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnNlcmlhbGl6ZXIgPyBvcHRpb25zLnNlcmlhbGl6ZXIgOiBzZXJpYWxpemVyRGVmYXVsdDtcbiAgICB2YXIgc3RyYXRlZ3kgPSBvcHRpb25zICYmIG9wdGlvbnMuc3RyYXRlZ3kgPyBvcHRpb25zLnN0cmF0ZWd5IDogc3RyYXRlZ3lEZWZhdWx0O1xuICAgIHJldHVybiBzdHJhdGVneShmbiwge1xuICAgICAgICBjYWNoZTogY2FjaGUsXG4gICAgICAgIHNlcmlhbGl6ZXI6IHNlcmlhbGl6ZXIsXG4gICAgfSk7XG59XG4vL1xuLy8gU3RyYXRlZ3lcbi8vXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKTsgLy8gfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICd1bnNhZmUnIHByaW1pdGl2ZSBmb3Igb3VyIG5lZWRzXG59XG5mdW5jdGlvbiBtb25hZGljKGZuLCBjYWNoZSwgc2VyaWFsaXplciwgYXJnKSB7XG4gICAgdmFyIGNhY2hlS2V5ID0gaXNQcmltaXRpdmUoYXJnKSA/IGFyZyA6IHNlcmlhbGl6ZXIoYXJnKTtcbiAgICB2YXIgY29tcHV0ZWRWYWx1ZSA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKHR5cGVvZiBjb21wdXRlZFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb21wdXRlZFZhbHVlID0gZm4uY2FsbCh0aGlzLCBhcmcpO1xuICAgICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGNvbXB1dGVkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcHV0ZWRWYWx1ZTtcbn1cbmZ1bmN0aW9uIHZhcmlhZGljKGZuLCBjYWNoZSwgc2VyaWFsaXplcikge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgICB2YXIgY2FjaGVLZXkgPSBzZXJpYWxpemVyKGFyZ3MpO1xuICAgIHZhciBjb21wdXRlZFZhbHVlID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAodHlwZW9mIGNvbXB1dGVkVmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbXB1dGVkVmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBjb21wdXRlZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXB1dGVkVmFsdWU7XG59XG5mdW5jdGlvbiBhc3NlbWJsZShmbiwgY29udGV4dCwgc3RyYXRlZ3ksIGNhY2hlLCBzZXJpYWxpemUpIHtcbiAgICByZXR1cm4gc3RyYXRlZ3kuYmluZChjb250ZXh0LCBmbiwgY2FjaGUsIHNlcmlhbGl6ZSk7XG59XG5mdW5jdGlvbiBzdHJhdGVneURlZmF1bHQoZm4sIG9wdGlvbnMpIHtcbiAgICB2YXIgc3RyYXRlZ3kgPSBmbi5sZW5ndGggPT09IDEgPyBtb25hZGljIDogdmFyaWFkaWM7XG4gICAgcmV0dXJuIGFzc2VtYmxlKGZuLCB0aGlzLCBzdHJhdGVneSwgb3B0aW9ucy5jYWNoZS5jcmVhdGUoKSwgb3B0aW9ucy5zZXJpYWxpemVyKTtcbn1cbmZ1bmN0aW9uIHN0cmF0ZWd5VmFyaWFkaWMoZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXNzZW1ibGUoZm4sIHRoaXMsIHZhcmlhZGljLCBvcHRpb25zLmNhY2hlLmNyZWF0ZSgpLCBvcHRpb25zLnNlcmlhbGl6ZXIpO1xufVxuZnVuY3Rpb24gc3RyYXRlZ3lNb25hZGljKGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFzc2VtYmxlKGZuLCB0aGlzLCBtb25hZGljLCBvcHRpb25zLmNhY2hlLmNyZWF0ZSgpLCBvcHRpb25zLnNlcmlhbGl6ZXIpO1xufVxuLy9cbi8vIFNlcmlhbGl6ZXJcbi8vXG52YXIgc2VyaWFsaXplckRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3VtZW50cyk7XG59O1xuLy9cbi8vIENhY2hlXG4vL1xudmFyIE9iamVjdFdpdGhvdXRQcm90b3R5cGVDYWNoZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYmplY3RXaXRob3V0UHJvdG90eXBlQ2FjaGUoKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBPYmplY3RXaXRob3V0UHJvdG90eXBlQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVba2V5XTtcbiAgICB9O1xuICAgIE9iamVjdFdpdGhvdXRQcm90b3R5cGVDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgICByZXR1cm4gT2JqZWN0V2l0aG91dFByb3RvdHlwZUNhY2hlO1xufSgpKTtcbnZhciBjYWNoZURlZmF1bHQgPSB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0V2l0aG91dFByb3RvdHlwZUNhY2hlKCk7XG4gICAgfSxcbn07XG5leHBvcnQgdmFyIHN0cmF0ZWdpZXMgPSB7XG4gICAgdmFyaWFkaWM6IHN0cmF0ZWd5VmFyaWFkaWMsXG4gICAgbW9uYWRpYzogc3RyYXRlZ3lNb25hZGljLFxufTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxFQUFFO0FBQ0YsT0FBTztBQUNQLEVBQUU7Ozs7O0FBQ0ssU0FBUyxRQUFRLEVBQUUsRUFBRSxPQUFPO0lBQy9CLElBQUksUUFBUSxXQUFXLFFBQVEsS0FBSyxHQUFHLFFBQVEsS0FBSyxHQUFHO0lBQ3ZELElBQUksYUFBYSxXQUFXLFFBQVEsVUFBVSxHQUFHLFFBQVEsVUFBVSxHQUFHO0lBQ3RFLElBQUksV0FBVyxXQUFXLFFBQVEsUUFBUSxHQUFHLFFBQVEsUUFBUSxHQUFHO0lBQ2hFLE9BQU8sU0FBUyxJQUFJO1FBQ2hCLE9BQU87UUFDUCxZQUFZO0lBQ2hCO0FBQ0o7QUFDQSxFQUFFO0FBQ0YsV0FBVztBQUNYLEVBQUU7QUFDRixTQUFTLFlBQVksS0FBSztJQUN0QixPQUFRLFNBQVMsUUFBUSxPQUFPLFVBQVUsWUFBWSxPQUFPLFVBQVUsV0FBWSxnRUFBZ0U7QUFDdko7QUFDQSxTQUFTLFFBQVEsRUFBRSxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsR0FBRztJQUN2QyxJQUFJLFdBQVcsWUFBWSxPQUFPLE1BQU0sV0FBVztJQUNuRCxJQUFJLGdCQUFnQixNQUFNLEdBQUcsQ0FBQztJQUM5QixJQUFJLE9BQU8sa0JBQWtCLGFBQWE7UUFDdEMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRTtRQUM5QixNQUFNLEdBQUcsQ0FBQyxVQUFVO0lBQ3hCO0lBQ0EsT0FBTztBQUNYO0FBQ0EsU0FBUyxTQUFTLEVBQUUsRUFBRSxLQUFLLEVBQUUsVUFBVTtJQUNuQyxJQUFJLE9BQU8sTUFBTSxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxXQUFXO0lBQ2pELElBQUksV0FBVyxXQUFXO0lBQzFCLElBQUksZ0JBQWdCLE1BQU0sR0FBRyxDQUFDO0lBQzlCLElBQUksT0FBTyxrQkFBa0IsYUFBYTtRQUN0QyxnQkFBZ0IsR0FBRyxLQUFLLENBQUMsSUFBSSxFQUFFO1FBQy9CLE1BQU0sR0FBRyxDQUFDLFVBQVU7SUFDeEI7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTLFNBQVMsRUFBRSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLFNBQVM7SUFDckQsT0FBTyxTQUFTLElBQUksQ0FBQyxTQUFTLElBQUksT0FBTztBQUM3QztBQUNBLFNBQVMsZ0JBQWdCLEVBQUUsRUFBRSxPQUFPO0lBQ2hDLElBQUksV0FBVyxHQUFHLE1BQU0sS0FBSyxJQUFJLFVBQVU7SUFDM0MsT0FBTyxTQUFTLElBQUksSUFBSSxFQUFFLFVBQVUsUUFBUSxLQUFLLENBQUMsTUFBTSxJQUFJLFFBQVEsVUFBVTtBQUNsRjtBQUNBLFNBQVMsaUJBQWlCLEVBQUUsRUFBRSxPQUFPO0lBQ2pDLE9BQU8sU0FBUyxJQUFJLElBQUksRUFBRSxVQUFVLFFBQVEsS0FBSyxDQUFDLE1BQU0sSUFBSSxRQUFRLFVBQVU7QUFDbEY7QUFDQSxTQUFTLGdCQUFnQixFQUFFLEVBQUUsT0FBTztJQUNoQyxPQUFPLFNBQVMsSUFBSSxJQUFJLEVBQUUsU0FBUyxRQUFRLEtBQUssQ0FBQyxNQUFNLElBQUksUUFBUSxVQUFVO0FBQ2pGO0FBQ0EsRUFBRTtBQUNGLGFBQWE7QUFDYixFQUFFO0FBQ0YsSUFBSSxvQkFBb0I7SUFDcEIsT0FBTyxLQUFLLFNBQVMsQ0FBQztBQUMxQjtBQUNBLEVBQUU7QUFDRixRQUFRO0FBQ1IsRUFBRTtBQUNGLElBQUksOEJBQTZDO0lBQzdDLFNBQVM7UUFDTCxJQUFJLENBQUMsS0FBSyxHQUFHLE9BQU8sTUFBTSxDQUFDO0lBQy9CO0lBQ0EsNEJBQTRCLFNBQVMsQ0FBQyxHQUFHLEdBQUcsU0FBVSxHQUFHO1FBQ3JELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJO0lBQzFCO0lBQ0EsNEJBQTRCLFNBQVMsQ0FBQyxHQUFHLEdBQUcsU0FBVSxHQUFHLEVBQUUsS0FBSztRQUM1RCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRztJQUN0QjtJQUNBLE9BQU87QUFDWDtBQUNBLElBQUksZUFBZTtJQUNmLFFBQVEsU0FBUztRQUNiLE9BQU8sSUFBSTtJQUNmO0FBQ0o7QUFDTyxJQUFJLGFBQWE7SUFDcEIsVUFBVTtJQUNWLFNBQVM7QUFDYiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2OTUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwZm9ybWF0anMvaWN1LW1lc3NhZ2Vmb3JtYXQtcGFyc2VyL2xpYi9lcnJvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIEVycm9yS2luZDtcbihmdW5jdGlvbiAoRXJyb3JLaW5kKSB7XG4gICAgLyoqIEFyZ3VtZW50IGlzIHVuY2xvc2VkIChlLmcuIGB7MGApICovXG4gICAgRXJyb3JLaW5kW0Vycm9yS2luZFtcIkVYUEVDVF9BUkdVTUVOVF9DTE9TSU5HX0JSQUNFXCJdID0gMV0gPSBcIkVYUEVDVF9BUkdVTUVOVF9DTE9TSU5HX0JSQUNFXCI7XG4gICAgLyoqIEFyZ3VtZW50IGlzIGVtcHR5IChlLmcuIGB7fWApLiAqL1xuICAgIEVycm9yS2luZFtFcnJvcktpbmRbXCJFTVBUWV9BUkdVTUVOVFwiXSA9IDJdID0gXCJFTVBUWV9BUkdVTUVOVFwiO1xuICAgIC8qKiBBcmd1bWVudCBpcyBtYWxmb3JtZWQgKGUuZy4gYHtmb28hfWBgKSAqL1xuICAgIEVycm9yS2luZFtFcnJvcktpbmRbXCJNQUxGT1JNRURfQVJHVU1FTlRcIl0gPSAzXSA9IFwiTUFMRk9STUVEX0FSR1VNRU5UXCI7XG4gICAgLyoqIEV4cGVjdCBhbiBhcmd1bWVudCB0eXBlIChlLmcuIGB7Zm9vLH1gKSAqL1xuICAgIEVycm9yS2luZFtFcnJvcktpbmRbXCJFWFBFQ1RfQVJHVU1FTlRfVFlQRVwiXSA9IDRdID0gXCJFWFBFQ1RfQVJHVU1FTlRfVFlQRVwiO1xuICAgIC8qKiBVbnN1cHBvcnRlZCBhcmd1bWVudCB0eXBlIChlLmcuIGB7Zm9vLGZvb31gKSAqL1xuICAgIEVycm9yS2luZFtFcnJvcktpbmRbXCJJTlZBTElEX0FSR1VNRU5UX1RZUEVcIl0gPSA1XSA9IFwiSU5WQUxJRF9BUkdVTUVOVF9UWVBFXCI7XG4gICAgLyoqIEV4cGVjdCBhbiBhcmd1bWVudCBzdHlsZSAoZS5nLiBge2ZvbywgbnVtYmVyLCB9YCkgKi9cbiAgICBFcnJvcktpbmRbRXJyb3JLaW5kW1wiRVhQRUNUX0FSR1VNRU5UX1NUWUxFXCJdID0gNl0gPSBcIkVYUEVDVF9BUkdVTUVOVF9TVFlMRVwiO1xuICAgIC8qKiBUaGUgbnVtYmVyIHNrZWxldG9uIGlzIGludmFsaWQuICovXG4gICAgRXJyb3JLaW5kW0Vycm9yS2luZFtcIklOVkFMSURfTlVNQkVSX1NLRUxFVE9OXCJdID0gN10gPSBcIklOVkFMSURfTlVNQkVSX1NLRUxFVE9OXCI7XG4gICAgLyoqIFRoZSBkYXRlIHRpbWUgc2tlbGV0b24gaXMgaW52YWxpZC4gKi9cbiAgICBFcnJvcktpbmRbRXJyb3JLaW5kW1wiSU5WQUxJRF9EQVRFX1RJTUVfU0tFTEVUT05cIl0gPSA4XSA9IFwiSU5WQUxJRF9EQVRFX1RJTUVfU0tFTEVUT05cIjtcbiAgICAvKiogRXhlcGN0IGEgbnVtYmVyIHNrZWxldG9uIGZvbGxvd2luZyB0aGUgYDo6YCAoZS5nLiBge2ZvbywgbnVtYmVyLCA6On1gKSAqL1xuICAgIEVycm9yS2luZFtFcnJvcktpbmRbXCJFWFBFQ1RfTlVNQkVSX1NLRUxFVE9OXCJdID0gOV0gPSBcIkVYUEVDVF9OVU1CRVJfU0tFTEVUT05cIjtcbiAgICAvKiogRXhlcGN0IGEgZGF0ZSB0aW1lIHNrZWxldG9uIGZvbGxvd2luZyB0aGUgYDo6YCAoZS5nLiBge2ZvbywgZGF0ZSwgOjp9YCkgKi9cbiAgICBFcnJvcktpbmRbRXJyb3JLaW5kW1wiRVhQRUNUX0RBVEVfVElNRV9TS0VMRVRPTlwiXSA9IDEwXSA9IFwiRVhQRUNUX0RBVEVfVElNRV9TS0VMRVRPTlwiO1xuICAgIC8qKiBVbm1hdGNoZWQgYXBvc3Ryb3BoZXMgaW4gdGhlIGFyZ3VtZW50IHN0eWxlIChlLmcuIGB7Zm9vLCBudW1iZXIsICd0ZXN0YCkgKi9cbiAgICBFcnJvcktpbmRbRXJyb3JLaW5kW1wiVU5DTE9TRURfUVVPVEVfSU5fQVJHVU1FTlRfU1RZTEVcIl0gPSAxMV0gPSBcIlVOQ0xPU0VEX1FVT1RFX0lOX0FSR1VNRU5UX1NUWUxFXCI7XG4gICAgLyoqIE1pc3Npbmcgc2VsZWN0IGFyZ3VtZW50IG9wdGlvbnMgKGUuZy4gYHtmb28sIHNlbGVjdH1gKSAqL1xuICAgIEVycm9yS2luZFtFcnJvcktpbmRbXCJFWFBFQ1RfU0VMRUNUX0FSR1VNRU5UX09QVElPTlNcIl0gPSAxMl0gPSBcIkVYUEVDVF9TRUxFQ1RfQVJHVU1FTlRfT1BUSU9OU1wiO1xuICAgIC8qKiBFeHBlY3RpbmcgYW4gb2Zmc2V0IHZhbHVlIGluIGBwbHVyYWxgIG9yIGBzZWxlY3RvcmRpbmFsYCBhcmd1bWVudCAoZS5nIGB7Zm9vLCBwbHVyYWwsIG9mZnNldH1gKSAqL1xuICAgIEVycm9yS2luZFtFcnJvcktpbmRbXCJFWFBFQ1RfUExVUkFMX0FSR1VNRU5UX09GRlNFVF9WQUxVRVwiXSA9IDEzXSA9IFwiRVhQRUNUX1BMVVJBTF9BUkdVTUVOVF9PRkZTRVRfVkFMVUVcIjtcbiAgICAvKiogT2Zmc2V0IHZhbHVlIGluIGBwbHVyYWxgIG9yIGBzZWxlY3RvcmRpbmFsYCBpcyBpbnZhbGlkIChlLmcuIGB7Zm9vLCBwbHVyYWwsIG9mZnNldDogeH1gKSAqL1xuICAgIEVycm9yS2luZFtFcnJvcktpbmRbXCJJTlZBTElEX1BMVVJBTF9BUkdVTUVOVF9PRkZTRVRfVkFMVUVcIl0gPSAxNF0gPSBcIklOVkFMSURfUExVUkFMX0FSR1VNRU5UX09GRlNFVF9WQUxVRVwiO1xuICAgIC8qKiBFeHBlY3RpbmcgYSBzZWxlY3RvciBpbiBgc2VsZWN0YCBhcmd1bWVudCAoZS5nIGB7Zm9vLCBzZWxlY3R9YCkgKi9cbiAgICBFcnJvcktpbmRbRXJyb3JLaW5kW1wiRVhQRUNUX1NFTEVDVF9BUkdVTUVOVF9TRUxFQ1RPUlwiXSA9IDE1XSA9IFwiRVhQRUNUX1NFTEVDVF9BUkdVTUVOVF9TRUxFQ1RPUlwiO1xuICAgIC8qKiBFeHBlY3RpbmcgYSBzZWxlY3RvciBpbiBgcGx1cmFsYCBvciBgc2VsZWN0b3JkaW5hbGAgYXJndW1lbnQgKGUuZyBge2ZvbywgcGx1cmFsfWApICovXG4gICAgRXJyb3JLaW5kW0Vycm9yS2luZFtcIkVYUEVDVF9QTFVSQUxfQVJHVU1FTlRfU0VMRUNUT1JcIl0gPSAxNl0gPSBcIkVYUEVDVF9QTFVSQUxfQVJHVU1FTlRfU0VMRUNUT1JcIjtcbiAgICAvKiogRXhwZWN0aW5nIGEgbWVzc2FnZSBmcmFnbWVudCBhZnRlciB0aGUgYHNlbGVjdGAgc2VsZWN0b3IgKGUuZy4gYHtmb28sIHNlbGVjdCwgYXBwbGV9YCkgKi9cbiAgICBFcnJvcktpbmRbRXJyb3JLaW5kW1wiRVhQRUNUX1NFTEVDVF9BUkdVTUVOVF9TRUxFQ1RPUl9GUkFHTUVOVFwiXSA9IDE3XSA9IFwiRVhQRUNUX1NFTEVDVF9BUkdVTUVOVF9TRUxFQ1RPUl9GUkFHTUVOVFwiO1xuICAgIC8qKlxuICAgICAqIEV4cGVjdGluZyBhIG1lc3NhZ2UgZnJhZ21lbnQgYWZ0ZXIgdGhlIGBwbHVyYWxgIG9yIGBzZWxlY3RvcmRpbmFsYCBzZWxlY3RvclxuICAgICAqIChlLmcuIGB7Zm9vLCBwbHVyYWwsIG9uZX1gKVxuICAgICAqL1xuICAgIEVycm9yS2luZFtFcnJvcktpbmRbXCJFWFBFQ1RfUExVUkFMX0FSR1VNRU5UX1NFTEVDVE9SX0ZSQUdNRU5UXCJdID0gMThdID0gXCJFWFBFQ1RfUExVUkFMX0FSR1VNRU5UX1NFTEVDVE9SX0ZSQUdNRU5UXCI7XG4gICAgLyoqIFNlbGVjdG9yIGluIGBwbHVyYWxgIG9yIGBzZWxlY3RvcmRpbmFsYCBpcyBtYWxmb3JtZWQgKGUuZy4gYHtmb28sIHBsdXJhbCwgPXggeyN9fWApICovXG4gICAgRXJyb3JLaW5kW0Vycm9yS2luZFtcIklOVkFMSURfUExVUkFMX0FSR1VNRU5UX1NFTEVDVE9SXCJdID0gMTldID0gXCJJTlZBTElEX1BMVVJBTF9BUkdVTUVOVF9TRUxFQ1RPUlwiO1xuICAgIC8qKlxuICAgICAqIER1cGxpY2F0ZSBzZWxlY3RvcnMgaW4gYHBsdXJhbGAgb3IgYHNlbGVjdG9yZGluYWxgIGFyZ3VtZW50LlxuICAgICAqIChlLmcuIHtmb28sIHBsdXJhbCwgb25lIHsjfSBvbmUgeyN9fSlcbiAgICAgKi9cbiAgICBFcnJvcktpbmRbRXJyb3JLaW5kW1wiRFVQTElDQVRFX1BMVVJBTF9BUkdVTUVOVF9TRUxFQ1RPUlwiXSA9IDIwXSA9IFwiRFVQTElDQVRFX1BMVVJBTF9BUkdVTUVOVF9TRUxFQ1RPUlwiO1xuICAgIC8qKiBEdXBsaWNhdGUgc2VsZWN0b3JzIGluIGBzZWxlY3RgIGFyZ3VtZW50LlxuICAgICAqIChlLmcuIHtmb28sIHNlbGVjdCwgYXBwbGUge2FwcGxlfSBhcHBsZSB7YXBwbGV9fSlcbiAgICAgKi9cbiAgICBFcnJvcktpbmRbRXJyb3JLaW5kW1wiRFVQTElDQVRFX1NFTEVDVF9BUkdVTUVOVF9TRUxFQ1RPUlwiXSA9IDIxXSA9IFwiRFVQTElDQVRFX1NFTEVDVF9BUkdVTUVOVF9TRUxFQ1RPUlwiO1xuICAgIC8qKiBQbHVyYWwgb3Igc2VsZWN0IGFyZ3VtZW50IG9wdGlvbiBtdXN0IGhhdmUgYG90aGVyYCBjbGF1c2UuICovXG4gICAgRXJyb3JLaW5kW0Vycm9yS2luZFtcIk1JU1NJTkdfT1RIRVJfQ0xBVVNFXCJdID0gMjJdID0gXCJNSVNTSU5HX09USEVSX0NMQVVTRVwiO1xuICAgIC8qKiBUaGUgdGFnIGlzIG1hbGZvcm1lZC4gKGUuZy4gYDxib2xkIT5mb288L2JvbGQhPikgKi9cbiAgICBFcnJvcktpbmRbRXJyb3JLaW5kW1wiSU5WQUxJRF9UQUdcIl0gPSAyM10gPSBcIklOVkFMSURfVEFHXCI7XG4gICAgLyoqIFRoZSB0YWcgbmFtZSBpcyBpbnZhbGlkLiAoZS5nLiBgPDEyMz5mb288LzEyMz5gKSAqL1xuICAgIEVycm9yS2luZFtFcnJvcktpbmRbXCJJTlZBTElEX1RBR19OQU1FXCJdID0gMjVdID0gXCJJTlZBTElEX1RBR19OQU1FXCI7XG4gICAgLyoqIFRoZSBjbG9zaW5nIHRhZyBkb2VzIG5vdCBtYXRjaCB0aGUgb3BlbmluZyB0YWcuIChlLmcuIGA8Ym9sZD5mb288L2l0YWxpYz5gKSAqL1xuICAgIEVycm9yS2luZFtFcnJvcktpbmRbXCJVTk1BVENIRURfQ0xPU0lOR19UQUdcIl0gPSAyNl0gPSBcIlVOTUFUQ0hFRF9DTE9TSU5HX1RBR1wiO1xuICAgIC8qKiBUaGUgb3BlbmluZyB0YWcgaGFzIHVubWF0Y2hlZCBjbG9zaW5nIHRhZy4gKGUuZy4gYDxib2xkPmZvb2ApICovXG4gICAgRXJyb3JLaW5kW0Vycm9yS2luZFtcIlVOQ0xPU0VEX1RBR1wiXSA9IDI3XSA9IFwiVU5DTE9TRURfVEFHXCI7XG59KShFcnJvcktpbmQgfHwgKEVycm9yS2luZCA9IHt9KSk7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQU8sSUFBSTtBQUNYLENBQUMsU0FBVSxTQUFTO0lBQ2hCLHFDQUFxQyxHQUNyQyxTQUFTLENBQUMsU0FBUyxDQUFDLGdDQUFnQyxHQUFHLEVBQUUsR0FBRztJQUM1RCxtQ0FBbUMsR0FDbkMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLEdBQUc7SUFDN0MsMkNBQTJDLEdBQzNDLFNBQVMsQ0FBQyxTQUFTLENBQUMscUJBQXFCLEdBQUcsRUFBRSxHQUFHO0lBQ2pELDRDQUE0QyxHQUM1QyxTQUFTLENBQUMsU0FBUyxDQUFDLHVCQUF1QixHQUFHLEVBQUUsR0FBRztJQUNuRCxpREFBaUQsR0FDakQsU0FBUyxDQUFDLFNBQVMsQ0FBQyx3QkFBd0IsR0FBRyxFQUFFLEdBQUc7SUFDcEQsc0RBQXNELEdBQ3RELFNBQVMsQ0FBQyxTQUFTLENBQUMsd0JBQXdCLEdBQUcsRUFBRSxHQUFHO0lBQ3BELG9DQUFvQyxHQUNwQyxTQUFTLENBQUMsU0FBUyxDQUFDLDBCQUEwQixHQUFHLEVBQUUsR0FBRztJQUN0RCx1Q0FBdUMsR0FDdkMsU0FBUyxDQUFDLFNBQVMsQ0FBQyw2QkFBNkIsR0FBRyxFQUFFLEdBQUc7SUFDekQsMkVBQTJFLEdBQzNFLFNBQVMsQ0FBQyxTQUFTLENBQUMseUJBQXlCLEdBQUcsRUFBRSxHQUFHO0lBQ3JELDRFQUE0RSxHQUM1RSxTQUFTLENBQUMsU0FBUyxDQUFDLDRCQUE0QixHQUFHLEdBQUcsR0FBRztJQUN6RCw2RUFBNkUsR0FDN0UsU0FBUyxDQUFDLFNBQVMsQ0FBQyxtQ0FBbUMsR0FBRyxHQUFHLEdBQUc7SUFDaEUsMkRBQTJELEdBQzNELFNBQVMsQ0FBQyxTQUFTLENBQUMsaUNBQWlDLEdBQUcsR0FBRyxHQUFHO0lBQzlELG9HQUFvRyxHQUNwRyxTQUFTLENBQUMsU0FBUyxDQUFDLHNDQUFzQyxHQUFHLEdBQUcsR0FBRztJQUNuRSw2RkFBNkYsR0FDN0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyx1Q0FBdUMsR0FBRyxHQUFHLEdBQUc7SUFDcEUsb0VBQW9FLEdBQ3BFLFNBQVMsQ0FBQyxTQUFTLENBQUMsa0NBQWtDLEdBQUcsR0FBRyxHQUFHO0lBQy9ELHVGQUF1RixHQUN2RixTQUFTLENBQUMsU0FBUyxDQUFDLGtDQUFrQyxHQUFHLEdBQUcsR0FBRztJQUMvRCwyRkFBMkYsR0FDM0YsU0FBUyxDQUFDLFNBQVMsQ0FBQywyQ0FBMkMsR0FBRyxHQUFHLEdBQUc7SUFDeEU7OztLQUdDLEdBQ0QsU0FBUyxDQUFDLFNBQVMsQ0FBQywyQ0FBMkMsR0FBRyxHQUFHLEdBQUc7SUFDeEUsd0ZBQXdGLEdBQ3hGLFNBQVMsQ0FBQyxTQUFTLENBQUMsbUNBQW1DLEdBQUcsR0FBRyxHQUFHO0lBQ2hFOzs7S0FHQyxHQUNELFNBQVMsQ0FBQyxTQUFTLENBQUMscUNBQXFDLEdBQUcsR0FBRyxHQUFHO0lBQ2xFOztLQUVDLEdBQ0QsU0FBUyxDQUFDLFNBQVMsQ0FBQyxxQ0FBcUMsR0FBRyxHQUFHLEdBQUc7SUFDbEUsK0RBQStELEdBQy9ELFNBQVMsQ0FBQyxTQUFTLENBQUMsdUJBQXVCLEdBQUcsR0FBRyxHQUFHO0lBQ3BELHFEQUFxRCxHQUNyRCxTQUFTLENBQUMsU0FBUyxDQUFDLGNBQWMsR0FBRyxHQUFHLEdBQUc7SUFDM0MscURBQXFELEdBQ3JELFNBQVMsQ0FBQyxTQUFTLENBQUMsbUJBQW1CLEdBQUcsR0FBRyxHQUFHO0lBQ2hELGdGQUFnRixHQUNoRixTQUFTLENBQUMsU0FBUyxDQUFDLHdCQUF3QixHQUFHLEdBQUcsR0FBRztJQUNyRCxrRUFBa0UsR0FDbEUsU0FBUyxDQUFDLFNBQVMsQ0FBQyxlQUFlLEdBQUcsR0FBRyxHQUFHO0FBQ2hELENBQUMsRUFBRSxhQUFhLENBQUMsWUFBWSxDQUFDLENBQUMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzM5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MGZvcm1hdGpzL2ljdS1tZXNzYWdlZm9ybWF0LXBhcnNlci9saWIvdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBUWVBFO1xuKGZ1bmN0aW9uIChUWVBFKSB7XG4gICAgLyoqXG4gICAgICogUmF3IHRleHRcbiAgICAgKi9cbiAgICBUWVBFW1RZUEVbXCJsaXRlcmFsXCJdID0gMF0gPSBcImxpdGVyYWxcIjtcbiAgICAvKipcbiAgICAgKiBWYXJpYWJsZSB3L28gYW55IGZvcm1hdCwgZS5nIGB2YXJgIGluIGB0aGlzIGlzIGEge3Zhcn1gXG4gICAgICovXG4gICAgVFlQRVtUWVBFW1wiYXJndW1lbnRcIl0gPSAxXSA9IFwiYXJndW1lbnRcIjtcbiAgICAvKipcbiAgICAgKiBWYXJpYWJsZSB3LyBudW1iZXIgZm9ybWF0XG4gICAgICovXG4gICAgVFlQRVtUWVBFW1wibnVtYmVyXCJdID0gMl0gPSBcIm51bWJlclwiO1xuICAgIC8qKlxuICAgICAqIFZhcmlhYmxlIHcvIGRhdGUgZm9ybWF0XG4gICAgICovXG4gICAgVFlQRVtUWVBFW1wiZGF0ZVwiXSA9IDNdID0gXCJkYXRlXCI7XG4gICAgLyoqXG4gICAgICogVmFyaWFibGUgdy8gdGltZSBmb3JtYXRcbiAgICAgKi9cbiAgICBUWVBFW1RZUEVbXCJ0aW1lXCJdID0gNF0gPSBcInRpbWVcIjtcbiAgICAvKipcbiAgICAgKiBWYXJpYWJsZSB3LyBzZWxlY3QgZm9ybWF0XG4gICAgICovXG4gICAgVFlQRVtUWVBFW1wic2VsZWN0XCJdID0gNV0gPSBcInNlbGVjdFwiO1xuICAgIC8qKlxuICAgICAqIFZhcmlhYmxlIHcvIHBsdXJhbCBmb3JtYXRcbiAgICAgKi9cbiAgICBUWVBFW1RZUEVbXCJwbHVyYWxcIl0gPSA2XSA9IFwicGx1cmFsXCI7XG4gICAgLyoqXG4gICAgICogT25seSBwb3NzaWJsZSB3aXRoaW4gcGx1cmFsIGFyZ3VtZW50LlxuICAgICAqIFRoaXMgaXMgdGhlIGAjYCBzeW1ib2wgdGhhdCB3aWxsIGJlIHN1YnN0aXR1dGVkIHdpdGggdGhlIGNvdW50LlxuICAgICAqL1xuICAgIFRZUEVbVFlQRVtcInBvdW5kXCJdID0gN10gPSBcInBvdW5kXCI7XG4gICAgLyoqXG4gICAgICogWE1MLWxpa2UgdGFnXG4gICAgICovXG4gICAgVFlQRVtUWVBFW1widGFnXCJdID0gOF0gPSBcInRhZ1wiO1xufSkoVFlQRSB8fCAoVFlQRSA9IHt9KSk7XG5leHBvcnQgdmFyIFNLRUxFVE9OX1RZUEU7XG4oZnVuY3Rpb24gKFNLRUxFVE9OX1RZUEUpIHtcbiAgICBTS0VMRVRPTl9UWVBFW1NLRUxFVE9OX1RZUEVbXCJudW1iZXJcIl0gPSAwXSA9IFwibnVtYmVyXCI7XG4gICAgU0tFTEVUT05fVFlQRVtTS0VMRVRPTl9UWVBFW1wiZGF0ZVRpbWVcIl0gPSAxXSA9IFwiZGF0ZVRpbWVcIjtcbn0pKFNLRUxFVE9OX1RZUEUgfHwgKFNLRUxFVE9OX1RZUEUgPSB7fSkpO1xuLyoqXG4gKiBUeXBlIEd1YXJkc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMaXRlcmFsRWxlbWVudChlbCkge1xuICAgIHJldHVybiBlbC50eXBlID09PSBUWVBFLmxpdGVyYWw7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBcmd1bWVudEVsZW1lbnQoZWwpIHtcbiAgICByZXR1cm4gZWwudHlwZSA9PT0gVFlQRS5hcmd1bWVudDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlckVsZW1lbnQoZWwpIHtcbiAgICByZXR1cm4gZWwudHlwZSA9PT0gVFlQRS5udW1iZXI7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlRWxlbWVudChlbCkge1xuICAgIHJldHVybiBlbC50eXBlID09PSBUWVBFLmRhdGU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNUaW1lRWxlbWVudChlbCkge1xuICAgIHJldHVybiBlbC50eXBlID09PSBUWVBFLnRpbWU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTZWxlY3RFbGVtZW50KGVsKSB7XG4gICAgcmV0dXJuIGVsLnR5cGUgPT09IFRZUEUuc2VsZWN0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUGx1cmFsRWxlbWVudChlbCkge1xuICAgIHJldHVybiBlbC50eXBlID09PSBUWVBFLnBsdXJhbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1BvdW5kRWxlbWVudChlbCkge1xuICAgIHJldHVybiBlbC50eXBlID09PSBUWVBFLnBvdW5kO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVGFnRWxlbWVudChlbCkge1xuICAgIHJldHVybiBlbC50eXBlID09PSBUWVBFLnRhZztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlclNrZWxldG9uKGVsKSB7XG4gICAgcmV0dXJuICEhKGVsICYmIHR5cGVvZiBlbCA9PT0gJ29iamVjdCcgJiYgZWwudHlwZSA9PT0gU0tFTEVUT05fVFlQRS5udW1iZXIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZVRpbWVTa2VsZXRvbihlbCkge1xuICAgIHJldHVybiAhIShlbCAmJiB0eXBlb2YgZWwgPT09ICdvYmplY3QnICYmIGVsLnR5cGUgPT09IFNLRUxFVE9OX1RZUEUuZGF0ZVRpbWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxpdGVyYWxFbGVtZW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogVFlQRS5saXRlcmFsLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOdW1iZXJFbGVtZW50KHZhbHVlLCBzdHlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFRZUEUubnVtYmVyLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU8sSUFBSTtBQUNYLENBQUMsU0FBVSxJQUFJO0lBQ1g7O0tBRUMsR0FDRCxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDNUI7O0tBRUMsR0FDRCxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxFQUFFLEdBQUc7SUFDN0I7O0tBRUMsR0FDRCxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDM0I7O0tBRUMsR0FDRCxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDekI7O0tBRUMsR0FDRCxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDekI7O0tBRUMsR0FDRCxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDM0I7O0tBRUMsR0FDRCxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDM0I7OztLQUdDLEdBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQzFCOztLQUVDLEdBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxHQUFHO0FBQzVCLENBQUMsRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDZCxJQUFJO0FBQ1gsQ0FBQyxTQUFVLGFBQWE7SUFDcEIsYUFBYSxDQUFDLGFBQWEsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQzdDLGFBQWEsQ0FBQyxhQUFhLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztBQUNuRCxDQUFDLEVBQUUsaUJBQWlCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUloQyxTQUFTLGlCQUFpQixFQUFFO0lBQy9CLE9BQU8sR0FBRyxJQUFJLEtBQUssS0FBSyxPQUFPO0FBQ25DO0FBQ08sU0FBUyxrQkFBa0IsRUFBRTtJQUNoQyxPQUFPLEdBQUcsSUFBSSxLQUFLLEtBQUssUUFBUTtBQUNwQztBQUNPLFNBQVMsZ0JBQWdCLEVBQUU7SUFDOUIsT0FBTyxHQUFHLElBQUksS0FBSyxLQUFLLE1BQU07QUFDbEM7QUFDTyxTQUFTLGNBQWMsRUFBRTtJQUM1QixPQUFPLEdBQUcsSUFBSSxLQUFLLEtBQUssSUFBSTtBQUNoQztBQUNPLFNBQVMsY0FBYyxFQUFFO0lBQzVCLE9BQU8sR0FBRyxJQUFJLEtBQUssS0FBSyxJQUFJO0FBQ2hDO0FBQ08sU0FBUyxnQkFBZ0IsRUFBRTtJQUM5QixPQUFPLEdBQUcsSUFBSSxLQUFLLEtBQUssTUFBTTtBQUNsQztBQUNPLFNBQVMsZ0JBQWdCLEVBQUU7SUFDOUIsT0FBTyxHQUFHLElBQUksS0FBSyxLQUFLLE1BQU07QUFDbEM7QUFDTyxTQUFTLGVBQWUsRUFBRTtJQUM3QixPQUFPLEdBQUcsSUFBSSxLQUFLLEtBQUssS0FBSztBQUNqQztBQUNPLFNBQVMsYUFBYSxFQUFFO0lBQzNCLE9BQU8sR0FBRyxJQUFJLEtBQUssS0FBSyxHQUFHO0FBQy9CO0FBQ08sU0FBUyxpQkFBaUIsRUFBRTtJQUMvQixPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sT0FBTyxPQUFPLFlBQVksR0FBRyxJQUFJLEtBQUssY0FBYyxNQUFNO0FBQzlFO0FBQ08sU0FBUyxtQkFBbUIsRUFBRTtJQUNqQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sT0FBTyxPQUFPLFlBQVksR0FBRyxJQUFJLEtBQUssY0FBYyxRQUFRO0FBQ2hGO0FBQ08sU0FBUyxxQkFBcUIsS0FBSztJQUN0QyxPQUFPO1FBQ0gsTUFBTSxLQUFLLE9BQU87UUFDbEIsT0FBTztJQUNYO0FBQ0o7QUFDTyxTQUFTLG9CQUFvQixLQUFLLEVBQUUsS0FBSztJQUM1QyxPQUFPO1FBQ0gsTUFBTSxLQUFLLE1BQU07UUFDakIsT0FBTztRQUNQLE9BQU87SUFDWDtBQUNKIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDg0MiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDBmb3JtYXRqcy9pY3UtbWVzc2FnZWZvcm1hdC1wYXJzZXIvbGliL3JlZ2V4LmdlbmVyYXRlZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZ2VuZXJhdGVkIGZyb20gcmVnZXgtZ2VuLnRzXG5leHBvcnQgdmFyIFNQQUNFX1NFUEFSQVRPUl9SRUdFWCA9IC9bIFxceEEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vO1xuZXhwb3J0IHZhciBXSElURV9TUEFDRV9SRUdFWCA9IC9bXFx0LVxcciBcXHg4NVxcdTIwMEVcXHUyMDBGXFx1MjAyOFxcdTIwMjldLztcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwrQkFBK0I7Ozs7O0FBQ3hCLElBQUksd0JBQXdCO0FBQzVCLElBQUksb0JBQW9CIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDg1MywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDBmb3JtYXRqcy9pY3Utc2tlbGV0b24tcGFyc2VyL2xpYi9kYXRlLXRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9GaWVsZF9TeW1ib2xfVGFibGVcbiAqIENyZWRpdDogaHR0cHM6Ly9naXRodWIuY29tL2NhcmlkeS9pbnRsLWRhdGV0aW1lZm9ybWF0LXBhdHRlcm4vYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAqIHdpdGggc29tZSB0d2Vha3NcbiAqL1xudmFyIERBVEVfVElNRV9SRUdFWCA9IC8oPzpbRWVjXXsxLDZ9fEd7MSw1fXxbUXFdezEsNX18KD86W3lZdXJdK3xVezEsNX0pfFtNTF17MSw1fXxkezEsMn18RHsxLDN9fEZ7MX18W2FiQl17MSw1fXxbaGtIS117MSwyfXx3ezEsMn18V3sxfXxtezEsMn18c3sxLDJ9fFt6Wk92VnhYXXsxLDR9KSg/PShbXiddKidbXiddKicpKlteJ10qJCkvZztcbi8qKlxuICogUGFyc2UgRGF0ZSB0aW1lIHNrZWxldG9uIGludG8gSW50bC5EYXRlVGltZUZvcm1hdE9wdGlvbnNcbiAqIFJlZjogaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRmllbGRfU3ltYm9sX1RhYmxlXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gc2tlbGV0b24gc2tlbGV0b24gc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURhdGVUaW1lU2tlbGV0b24oc2tlbGV0b24pIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgc2tlbGV0b24ucmVwbGFjZShEQVRFX1RJTUVfUkVHRVgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICB2YXIgbGVuID0gbWF0Y2gubGVuZ3RoO1xuICAgICAgICBzd2l0Y2ggKG1hdGNoWzBdKSB7XG4gICAgICAgICAgICAvLyBFcmFcbiAgICAgICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5lcmEgPSBsZW4gPT09IDQgPyAnbG9uZycgOiBsZW4gPT09IDUgPyAnbmFycm93JyA6ICdzaG9ydCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBZZWFyXG4gICAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgICAgICByZXN1bHQueWVhciA9IGxlbiA9PT0gMiA/ICcyLWRpZ2l0JyA6ICdudW1lcmljJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1knOlxuICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdgWS91L1UvcmAgKHllYXIpIHBhdHRlcm5zIGFyZSBub3Qgc3VwcG9ydGVkLCB1c2UgYHlgIGluc3RlYWQnKTtcbiAgICAgICAgICAgIC8vIFF1YXJ0ZXJcbiAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2BxL1FgIChxdWFydGVyKSBwYXR0ZXJucyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgLy8gTW9udGhcbiAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm1vbnRoID0gWydudW1lcmljJywgJzItZGlnaXQnLCAnc2hvcnQnLCAnbG9uZycsICduYXJyb3cnXVtsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFdlZWtcbiAgICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgY2FzZSAnVyc6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2B3L1dgICh3ZWVrKSBwYXR0ZXJucyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRheSA9IFsnbnVtZXJpYycsICcyLWRpZ2l0J11bbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICAgIGNhc2UgJ0YnOlxuICAgICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2BEL0YvZ2AgKGRheSkgcGF0dGVybnMgYXJlIG5vdCBzdXBwb3J0ZWQsIHVzZSBgZGAgaW5zdGVhZCcpO1xuICAgICAgICAgICAgLy8gV2Vla2RheVxuICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0LndlZWtkYXkgPSBsZW4gPT09IDQgPyAnbG9uZycgOiBsZW4gPT09IDUgPyAnbmFycm93JyA6ICdzaG9ydCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICBpZiAobGVuIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYGUuLmVlZWAgKHdlZWtkYXkpIHBhdHRlcm5zIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC53ZWVrZGF5ID0gWydzaG9ydCcsICdsb25nJywgJ25hcnJvdycsICdzaG9ydCddW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2BjLi5jY2NgICh3ZWVrZGF5KSBwYXR0ZXJucyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQud2Vla2RheSA9IFsnc2hvcnQnLCAnbG9uZycsICduYXJyb3cnLCAnc2hvcnQnXVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFBlcmlvZFxuICAgICAgICAgICAgY2FzZSAnYSc6IC8vIEFNLCBQTVxuICAgICAgICAgICAgICAgIHJlc3VsdC5ob3VyMTIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYic6IC8vIGFtLCBwbSwgbm9vbiwgbWlkbmlnaHRcbiAgICAgICAgICAgIGNhc2UgJ0InOiAvLyBmbGV4aWJsZSBkYXkgcGVyaW9kc1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdgYi9CYCAocGVyaW9kKSBwYXR0ZXJucyBhcmUgbm90IHN1cHBvcnRlZCwgdXNlIGBhYCBpbnN0ZWFkJyk7XG4gICAgICAgICAgICAvLyBIb3VyXG4gICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICByZXN1bHQuaG91ckN5Y2xlID0gJ2gxMic7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmhvdXIgPSBbJ251bWVyaWMnLCAnMi1kaWdpdCddW2xlbiAtIDFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0LmhvdXJDeWNsZSA9ICdoMjMnO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5ob3VyID0gWydudW1lcmljJywgJzItZGlnaXQnXVtsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0snOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5ob3VyQ3ljbGUgPSAnaDExJztcbiAgICAgICAgICAgICAgICByZXN1bHQuaG91ciA9IFsnbnVtZXJpYycsICcyLWRpZ2l0J11bbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdrJzpcbiAgICAgICAgICAgICAgICByZXN1bHQuaG91ckN5Y2xlID0gJ2gyNCc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmhvdXIgPSBbJ251bWVyaWMnLCAnMi1kaWdpdCddW2xlbiAtIDFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaic6XG4gICAgICAgICAgICBjYXNlICdKJzpcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdgai9KL0NgIChob3VyKSBwYXR0ZXJucyBhcmUgbm90IHN1cHBvcnRlZCwgdXNlIGBoL0gvSy9rYCBpbnN0ZWFkJyk7XG4gICAgICAgICAgICAvLyBNaW51dGVcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5taW51dGUgPSBbJ251bWVyaWMnLCAnMi1kaWdpdCddW2xlbiAtIDFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gU2Vjb25kXG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICByZXN1bHQuc2Vjb25kID0gWydudW1lcmljJywgJzItZGlnaXQnXVtsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2BTL0FgIChzZWNvbmQpIHBhdHRlcm5zIGFyZSBub3Qgc3VwcG9ydGVkLCB1c2UgYHNgIGluc3RlYWQnKTtcbiAgICAgICAgICAgIC8vIFpvbmVcbiAgICAgICAgICAgIGNhc2UgJ3onOiAvLyAxLi4zLCA0OiBzcGVjaWZpYyBub24tbG9jYXRpb24gZm9ybWF0XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRpbWVab25lTmFtZSA9IGxlbiA8IDQgPyAnc2hvcnQnIDogJ2xvbmcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnWic6IC8vIDEuLjMsIDQsIDU6IFRoZSBJU084NjAxIHZhcmlvcyBmb3JtYXRzXG4gICAgICAgICAgICBjYXNlICdPJzogLy8gMSwgNDogbWlsbGlzZWNvbmRzIGluIGRheSBzaG9ydCwgbG9uZ1xuICAgICAgICAgICAgY2FzZSAndic6IC8vIDEsIDQ6IGdlbmVyaWMgbm9uLWxvY2F0aW9uIGZvcm1hdFxuICAgICAgICAgICAgY2FzZSAnVic6IC8vIDEsIDIsIDMsIDQ6IHRpbWUgem9uZSBJRCBvciBjaXR5XG4gICAgICAgICAgICBjYXNlICdYJzogLy8gMSwgMiwgMywgNDogVGhlIElTTzg2MDEgdmFyaW9zIGZvcm1hdHNcbiAgICAgICAgICAgIGNhc2UgJ3gnOiAvLyAxLCAyLCAzLCA0OiBUaGUgSVNPODYwMSB2YXJpb3MgZm9ybWF0c1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdgWi9PL3YvVi9YL3hgICh0aW1lWm9uZSkgcGF0dGVybnMgYXJlIG5vdCBzdXBwb3J0ZWQsIHVzZSBgemAgaW5zdGVhZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUM7OztBQUNELElBQUksa0JBQWtCO0FBT2YsU0FBUyxzQkFBc0IsUUFBUTtJQUMxQyxJQUFJLFNBQVMsQ0FBQztJQUNkLFNBQVMsT0FBTyxDQUFDLGlCQUFpQixTQUFVLEtBQUs7UUFDN0MsSUFBSSxNQUFNLE1BQU0sTUFBTTtRQUN0QixPQUFRLEtBQUssQ0FBQyxFQUFFO1lBQ1osTUFBTTtZQUNOLEtBQUs7Z0JBQ0QsT0FBTyxHQUFHLEdBQUcsUUFBUSxJQUFJLFNBQVMsUUFBUSxJQUFJLFdBQVc7Z0JBQ3pEO1lBQ0osT0FBTztZQUNQLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJLEdBQUcsUUFBUSxJQUFJLFlBQVk7Z0JBQ3RDO1lBQ0osS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDRCxNQUFNLElBQUksV0FBVztZQUN6QixVQUFVO1lBQ1YsS0FBSztZQUNMLEtBQUs7Z0JBQ0QsTUFBTSxJQUFJLFdBQVc7WUFDekIsUUFBUTtZQUNSLEtBQUs7WUFDTCxLQUFLO2dCQUNELE9BQU8sS0FBSyxHQUFHO29CQUFDO29CQUFXO29CQUFXO29CQUFTO29CQUFRO2lCQUFTLENBQUMsTUFBTSxFQUFFO2dCQUN6RTtZQUNKLE9BQU87WUFDUCxLQUFLO1lBQ0wsS0FBSztnQkFDRCxNQUFNLElBQUksV0FBVztZQUN6QixLQUFLO2dCQUNELE9BQU8sR0FBRyxHQUFHO29CQUFDO29CQUFXO2lCQUFVLENBQUMsTUFBTSxFQUFFO2dCQUM1QztZQUNKLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDRCxNQUFNLElBQUksV0FBVztZQUN6QixVQUFVO1lBQ1YsS0FBSztnQkFDRCxPQUFPLE9BQU8sR0FBRyxRQUFRLElBQUksU0FBUyxRQUFRLElBQUksV0FBVztnQkFDN0Q7WUFDSixLQUFLO2dCQUNELElBQUksTUFBTSxHQUFHO29CQUNULE1BQU0sSUFBSSxXQUFXO2dCQUN6QjtnQkFDQSxPQUFPLE9BQU8sR0FBRztvQkFBQztvQkFBUztvQkFBUTtvQkFBVTtpQkFBUSxDQUFDLE1BQU0sRUFBRTtnQkFDOUQ7WUFDSixLQUFLO2dCQUNELElBQUksTUFBTSxHQUFHO29CQUNULE1BQU0sSUFBSSxXQUFXO2dCQUN6QjtnQkFDQSxPQUFPLE9BQU8sR0FBRztvQkFBQztvQkFBUztvQkFBUTtvQkFBVTtpQkFBUSxDQUFDLE1BQU0sRUFBRTtnQkFDOUQ7WUFDSixTQUFTO1lBQ1QsS0FBSztnQkFDRCxPQUFPLE1BQU0sR0FBRztnQkFDaEI7WUFDSixLQUFLO1lBQ0wsS0FBSztnQkFDRCxNQUFNLElBQUksV0FBVztZQUN6QixPQUFPO1lBQ1AsS0FBSztnQkFDRCxPQUFPLFNBQVMsR0FBRztnQkFDbkIsT0FBTyxJQUFJLEdBQUc7b0JBQUM7b0JBQVc7aUJBQVUsQ0FBQyxNQUFNLEVBQUU7Z0JBQzdDO1lBQ0osS0FBSztnQkFDRCxPQUFPLFNBQVMsR0FBRztnQkFDbkIsT0FBTyxJQUFJLEdBQUc7b0JBQUM7b0JBQVc7aUJBQVUsQ0FBQyxNQUFNLEVBQUU7Z0JBQzdDO1lBQ0osS0FBSztnQkFDRCxPQUFPLFNBQVMsR0FBRztnQkFDbkIsT0FBTyxJQUFJLEdBQUc7b0JBQUM7b0JBQVc7aUJBQVUsQ0FBQyxNQUFNLEVBQUU7Z0JBQzdDO1lBQ0osS0FBSztnQkFDRCxPQUFPLFNBQVMsR0FBRztnQkFDbkIsT0FBTyxJQUFJLEdBQUc7b0JBQUM7b0JBQVc7aUJBQVUsQ0FBQyxNQUFNLEVBQUU7Z0JBQzdDO1lBQ0osS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNELE1BQU0sSUFBSSxXQUFXO1lBQ3pCLFNBQVM7WUFDVCxLQUFLO2dCQUNELE9BQU8sTUFBTSxHQUFHO29CQUFDO29CQUFXO2lCQUFVLENBQUMsTUFBTSxFQUFFO2dCQUMvQztZQUNKLFNBQVM7WUFDVCxLQUFLO2dCQUNELE9BQU8sTUFBTSxHQUFHO29CQUFDO29CQUFXO2lCQUFVLENBQUMsTUFBTSxFQUFFO2dCQUMvQztZQUNKLEtBQUs7WUFDTCxLQUFLO2dCQUNELE1BQU0sSUFBSSxXQUFXO1lBQ3pCLE9BQU87WUFDUCxLQUFLO2dCQUNELE9BQU8sWUFBWSxHQUFHLE1BQU0sSUFBSSxVQUFVO2dCQUMxQztZQUNKLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDRCxNQUFNLElBQUksV0FBVztRQUM3QjtRQUNBLE9BQU87SUFDWDtJQUNBLE9BQU87QUFDWCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMDExLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MGZvcm1hdGpzL2ljdS1za2VsZXRvbi1wYXJzZXIvbGliL3JlZ2V4LmdlbmVyYXRlZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZ2VuZXJhdGVkIGZyb20gcmVnZXgtZ2VuLnRzXG5leHBvcnQgdmFyIFdISVRFX1NQQUNFX1JFR0VYID0gL1tcXHQtXFxyIFxceDg1XFx1MjAwRVxcdTIwMEZcXHUyMDI4XFx1MjAyOV0vaTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwrQkFBK0I7Ozs7QUFDeEIsSUFBSSxvQkFBb0IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTAyMCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDBmb3JtYXRqcy9pY3Utc2tlbGV0b24tcGFyc2VyL2xpYi9udW1iZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IFdISVRFX1NQQUNFX1JFR0VYIH0gZnJvbSAnLi9yZWdleC5nZW5lcmF0ZWQnO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTnVtYmVyU2tlbGV0b25Gcm9tU3RyaW5nKHNrZWxldG9uKSB7XG4gICAgaWYgKHNrZWxldG9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciBza2VsZXRvbiBjYW5ub3QgYmUgZW1wdHknKTtcbiAgICB9XG4gICAgLy8gUGFyc2UgdGhlIHNrZWxldG9uXG4gICAgdmFyIHN0cmluZ1Rva2VucyA9IHNrZWxldG9uXG4gICAgICAgIC5zcGxpdChXSElURV9TUEFDRV9SRUdFWClcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5sZW5ndGggPiAwOyB9KTtcbiAgICB2YXIgdG9rZW5zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBzdHJpbmdUb2tlbnNfMSA9IHN0cmluZ1Rva2VuczsgX2kgPCBzdHJpbmdUb2tlbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHN0cmluZ1Rva2VuID0gc3RyaW5nVG9rZW5zXzFbX2ldO1xuICAgICAgICB2YXIgc3RlbUFuZE9wdGlvbnMgPSBzdHJpbmdUb2tlbi5zcGxpdCgnLycpO1xuICAgICAgICBpZiAoc3RlbUFuZE9wdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIHNrZWxldG9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ZW0gPSBzdGVtQW5kT3B0aW9uc1swXSwgb3B0aW9ucyA9IHN0ZW1BbmRPcHRpb25zLnNsaWNlKDEpO1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIG9wdGlvbnNfMSA9IG9wdGlvbnM7IF9hIDwgb3B0aW9uc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IG9wdGlvbnNfMVtfYV07XG4gICAgICAgICAgICBpZiAob3B0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgc2tlbGV0b24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMucHVzaCh7IHN0ZW06IHN0ZW0sIG9wdGlvbnM6IG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnM7XG59XG5mdW5jdGlvbiBpY3VVbml0VG9FY21hKHVuaXQpIHtcbiAgICByZXR1cm4gdW5pdC5yZXBsYWNlKC9eKC4qPyktLywgJycpO1xufVxudmFyIEZSQUNUSU9OX1BSRUNJU0lPTl9SRUdFWCA9IC9eXFwuKD86KDArKShcXCopP3woIyspfCgwKykoIyspKSQvZztcbnZhciBTSUdOSUZJQ0FOVF9QUkVDSVNJT05fUkVHRVggPSAvXihAKyk/KFxcK3wjKyk/W3JzXT8kL2c7XG52YXIgSU5URUdFUl9XSURUSF9SRUdFWCA9IC8oXFwqKSgwKyl8KCMrKSgwKyl8KDArKS9nO1xudmFyIENPTkNJU0VfSU5URUdFUl9XSURUSF9SRUdFWCA9IC9eKDArKSQvO1xuZnVuY3Rpb24gcGFyc2VTaWduaWZpY2FudFByZWNpc2lvbihzdHIpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICdyJykge1xuICAgICAgICByZXN1bHQucm91bmRpbmdQcmlvcml0eSA9ICdtb3JlUHJlY2lzaW9uJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJ3MnKSB7XG4gICAgICAgIHJlc3VsdC5yb3VuZGluZ1ByaW9yaXR5ID0gJ2xlc3NQcmVjaXNpb24nO1xuICAgIH1cbiAgICBzdHIucmVwbGFjZShTSUdOSUZJQ0FOVF9QUkVDSVNJT05fUkVHRVgsIGZ1bmN0aW9uIChfLCBnMSwgZzIpIHtcbiAgICAgICAgLy8gQEBAIGNhc2VcbiAgICAgICAgaWYgKHR5cGVvZiBnMiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc3VsdC5taW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgPSBnMS5sZW5ndGg7XG4gICAgICAgICAgICByZXN1bHQubWF4aW11bVNpZ25pZmljYW50RGlnaXRzID0gZzEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBAQCsgY2FzZVxuICAgICAgICBlbHNlIGlmIChnMiA9PT0gJysnKSB7XG4gICAgICAgICAgICByZXN1bHQubWluaW11bVNpZ25pZmljYW50RGlnaXRzID0gZzEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIC4jIyMgY2FzZVxuICAgICAgICBlbHNlIGlmIChnMVswXSA9PT0gJyMnKSB7XG4gICAgICAgICAgICByZXN1bHQubWF4aW11bVNpZ25pZmljYW50RGlnaXRzID0gZzEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIC5AQCMjIG9yIC5AQEAgY2FzZVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5taW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgPSBnMS5sZW5ndGg7XG4gICAgICAgICAgICByZXN1bHQubWF4aW11bVNpZ25pZmljYW50RGlnaXRzID1cbiAgICAgICAgICAgICAgICBnMS5sZW5ndGggKyAodHlwZW9mIGcyID09PSAnc3RyaW5nJyA/IGcyLmxlbmd0aCA6IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VTaWduKHN0cikge1xuICAgIHN3aXRjaCAoc3RyKSB7XG4gICAgICAgIGNhc2UgJ3NpZ24tYXV0byc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNpZ25EaXNwbGF5OiAnYXV0bycsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdzaWduLWFjY291bnRpbmcnOlxuICAgICAgICBjYXNlICcoKSc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbmN5U2lnbjogJ2FjY291bnRpbmcnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnc2lnbi1hbHdheXMnOlxuICAgICAgICBjYXNlICcrISc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNpZ25EaXNwbGF5OiAnYWx3YXlzJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ3NpZ24tYWNjb3VudGluZy1hbHdheXMnOlxuICAgICAgICBjYXNlICcoKSEnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzaWduRGlzcGxheTogJ2Fsd2F5cycsXG4gICAgICAgICAgICAgICAgY3VycmVuY3lTaWduOiAnYWNjb3VudGluZycsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdzaWduLWV4Y2VwdC16ZXJvJzpcbiAgICAgICAgY2FzZSAnKz8nOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzaWduRGlzcGxheTogJ2V4Y2VwdFplcm8nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnc2lnbi1hY2NvdW50aW5nLWV4Y2VwdC16ZXJvJzpcbiAgICAgICAgY2FzZSAnKCk/JzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2lnbkRpc3BsYXk6ICdleGNlcHRaZXJvJyxcbiAgICAgICAgICAgICAgICBjdXJyZW5jeVNpZ246ICdhY2NvdW50aW5nJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ3NpZ24tbmV2ZXInOlxuICAgICAgICBjYXNlICcrXyc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNpZ25EaXNwbGF5OiAnbmV2ZXInLFxuICAgICAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUNvbmNpc2VTY2llbnRpZmljQW5kRW5naW5lZXJpbmdTdGVtKHN0ZW0pIHtcbiAgICAvLyBFbmdpbmVlcmluZ1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKHN0ZW1bMF0gPT09ICdFJyAmJiBzdGVtWzFdID09PSAnRScpIHtcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbm90YXRpb246ICdlbmdpbmVlcmluZycsXG4gICAgICAgIH07XG4gICAgICAgIHN0ZW0gPSBzdGVtLnNsaWNlKDIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGVtWzBdID09PSAnRScpIHtcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbm90YXRpb246ICdzY2llbnRpZmljJyxcbiAgICAgICAgfTtcbiAgICAgICAgc3RlbSA9IHN0ZW0uc2xpY2UoMSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgdmFyIHNpZ25EaXNwbGF5ID0gc3RlbS5zbGljZSgwLCAyKTtcbiAgICAgICAgaWYgKHNpZ25EaXNwbGF5ID09PSAnKyEnKSB7XG4gICAgICAgICAgICByZXN1bHQuc2lnbkRpc3BsYXkgPSAnYWx3YXlzJztcbiAgICAgICAgICAgIHN0ZW0gPSBzdGVtLnNsaWNlKDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpZ25EaXNwbGF5ID09PSAnKz8nKSB7XG4gICAgICAgICAgICByZXN1bHQuc2lnbkRpc3BsYXkgPSAnZXhjZXB0WmVybyc7XG4gICAgICAgICAgICBzdGVtID0gc3RlbS5zbGljZSgyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUNPTkNJU0VfSU5URUdFUl9XSURUSF9SRUdFWC50ZXN0KHN0ZW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBjb25jaXNlIGVuZy9zY2llbnRpZmljIG5vdGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lm1pbmltdW1JbnRlZ2VyRGlnaXRzID0gc3RlbS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZU5vdGF0aW9uT3B0aW9ucyhvcHQpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIHNpZ25PcHRzID0gcGFyc2VTaWduKG9wdCk7XG4gICAgaWYgKHNpZ25PcHRzKSB7XG4gICAgICAgIHJldHVybiBzaWduT3B0cztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3VuaWNvZGUtb3JnL2ljdS9ibG9iL21hc3Rlci9kb2NzL3VzZXJndWlkZS9mb3JtYXRfcGFyc2UvbnVtYmVycy9za2VsZXRvbnMubWQjc2tlbGV0b24tc3RlbXMtYW5kLW9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTnVtYmVyU2tlbGV0b24odG9rZW5zKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIF9pID0gMCwgdG9rZW5zXzEgPSB0b2tlbnM7IF9pIDwgdG9rZW5zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc18xW19pXTtcbiAgICAgICAgc3dpdGNoICh0b2tlbi5zdGVtKSB7XG4gICAgICAgICAgICBjYXNlICdwZXJjZW50JzpcbiAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zdHlsZSA9ICdwZXJjZW50JztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgJyV4MTAwJzpcbiAgICAgICAgICAgICAgICByZXN1bHQuc3R5bGUgPSAncGVyY2VudCc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNjYWxlID0gMTAwO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSAnY3VycmVuY3knOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zdHlsZSA9ICdjdXJyZW5jeSc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmN1cnJlbmN5ID0gdG9rZW4ub3B0aW9uc1swXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgJ2dyb3VwLW9mZic6XG4gICAgICAgICAgICBjYXNlICcsXyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnVzZUdyb3VwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlICdwcmVjaXNpb24taW50ZWdlcic6XG4gICAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgICAgICByZXN1bHQubWF4aW11bUZyYWN0aW9uRGlnaXRzID0gMDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgJ21lYXN1cmUtdW5pdCc6XG4gICAgICAgICAgICBjYXNlICd1bml0JzpcbiAgICAgICAgICAgICAgICByZXN1bHQuc3R5bGUgPSAndW5pdCc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnVuaXQgPSBpY3VVbml0VG9FY21hKHRva2VuLm9wdGlvbnNbMF0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSAnY29tcGFjdC1zaG9ydCc6XG4gICAgICAgICAgICBjYXNlICdLJzpcbiAgICAgICAgICAgICAgICByZXN1bHQubm90YXRpb24gPSAnY29tcGFjdCc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvbXBhY3REaXNwbGF5ID0gJ3Nob3J0JztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgJ2NvbXBhY3QtbG9uZyc6XG4gICAgICAgICAgICBjYXNlICdLSyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm5vdGF0aW9uID0gJ2NvbXBhY3QnO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jb21wYWN0RGlzcGxheSA9ICdsb25nJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgJ3NjaWVudGlmaWMnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCB7IG5vdGF0aW9uOiAnc2NpZW50aWZpYycgfSksIHRva2VuLm9wdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChhbGwsIG9wdCkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBhbGwpLCBwYXJzZU5vdGF0aW9uT3B0aW9ucyhvcHQpKSk7IH0sIHt9KSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlICdlbmdpbmVlcmluZyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIHJlc3VsdCksIHsgbm90YXRpb246ICdlbmdpbmVlcmluZycgfSksIHRva2VuLm9wdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChhbGwsIG9wdCkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBhbGwpLCBwYXJzZU5vdGF0aW9uT3B0aW9ucyhvcHQpKSk7IH0sIHt9KSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlICdub3RhdGlvbi1zaW1wbGUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5ub3RhdGlvbiA9ICdzdGFuZGFyZCc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdW5pY29kZS1vcmcvaWN1L2Jsb2IvbWFzdGVyL2ljdTRjL3NvdXJjZS9pMThuL3VuaWNvZGUvdW51bWJlcmZvcm1hdHRlci5oXG4gICAgICAgICAgICBjYXNlICd1bml0LXdpZHRoLW5hcnJvdyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0LmN1cnJlbmN5RGlzcGxheSA9ICduYXJyb3dTeW1ib2wnO1xuICAgICAgICAgICAgICAgIHJlc3VsdC51bml0RGlzcGxheSA9ICduYXJyb3cnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSAndW5pdC13aWR0aC1zaG9ydCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0LmN1cnJlbmN5RGlzcGxheSA9ICdjb2RlJztcbiAgICAgICAgICAgICAgICByZXN1bHQudW5pdERpc3BsYXkgPSAnc2hvcnQnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSAndW5pdC13aWR0aC1mdWxsLW5hbWUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5jdXJyZW5jeURpc3BsYXkgPSAnbmFtZSc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnVuaXREaXNwbGF5ID0gJ2xvbmcnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSAndW5pdC13aWR0aC1pc28tY29kZSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0LmN1cnJlbmN5RGlzcGxheSA9ICdzeW1ib2wnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSAnc2NhbGUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zY2FsZSA9IHBhcnNlRmxvYXQodG9rZW4ub3B0aW9uc1swXSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlICdyb3VuZGluZy1tb2RlLWZsb29yJzpcbiAgICAgICAgICAgICAgICByZXN1bHQucm91bmRpbmdNb2RlID0gJ2Zsb29yJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgJ3JvdW5kaW5nLW1vZGUtY2VpbGluZyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJvdW5kaW5nTW9kZSA9ICdjZWlsJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgJ3JvdW5kaW5nLW1vZGUtZG93bic6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJvdW5kaW5nTW9kZSA9ICd0cnVuYyc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlICdyb3VuZGluZy1tb2RlLXVwJzpcbiAgICAgICAgICAgICAgICByZXN1bHQucm91bmRpbmdNb2RlID0gJ2V4cGFuZCc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlICdyb3VuZGluZy1tb2RlLWhhbGYtZXZlbic6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJvdW5kaW5nTW9kZSA9ICdoYWxmRXZlbic7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlICdyb3VuZGluZy1tb2RlLWhhbGYtZG93bic6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJvdW5kaW5nTW9kZSA9ICdoYWxmVHJ1bmMnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSAncm91bmRpbmctbW9kZS1oYWxmLXVwJzpcbiAgICAgICAgICAgICAgICByZXN1bHQucm91bmRpbmdNb2RlID0gJ2hhbGZFeHBhbmQnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly91bmljb2RlLW9yZy5naXRodWIuaW8vaWN1L3VzZXJndWlkZS9mb3JtYXRfcGFyc2UvbnVtYmVycy9za2VsZXRvbnMuaHRtbCNpbnRlZ2VyLXdpZHRoXG4gICAgICAgICAgICBjYXNlICdpbnRlZ2VyLXdpZHRoJzpcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4ub3B0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbnRlZ2VyLXdpZHRoIHN0ZW1zIG9ubHkgYWNjZXB0IGEgc2luZ2xlIG9wdGlvbmFsIG9wdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbi5vcHRpb25zWzBdLnJlcGxhY2UoSU5URUdFUl9XSURUSF9SRUdFWCwgZnVuY3Rpb24gKF8sIGcxLCBnMiwgZzMsIGc0LCBnNSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5taW5pbXVtSW50ZWdlckRpZ2l0cyA9IGcyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChnMyAmJiBnNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZSBjdXJyZW50bHkgZG8gbm90IHN1cHBvcnQgbWF4aW11bSBpbnRlZ2VyIGRpZ2l0cycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGc1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIGN1cnJlbnRseSBkbyBub3Qgc3VwcG9ydCBleGFjdCBpbnRlZ2VyIGRpZ2l0cycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBodHRwczovL3VuaWNvZGUtb3JnLmdpdGh1Yi5pby9pY3UvdXNlcmd1aWRlL2Zvcm1hdF9wYXJzZS9udW1iZXJzL3NrZWxldG9ucy5odG1sI2ludGVnZXItd2lkdGhcbiAgICAgICAgaWYgKENPTkNJU0VfSU5URUdFUl9XSURUSF9SRUdFWC50ZXN0KHRva2VuLnN0ZW0pKSB7XG4gICAgICAgICAgICByZXN1bHQubWluaW11bUludGVnZXJEaWdpdHMgPSB0b2tlbi5zdGVtLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUkFDVElPTl9QUkVDSVNJT05fUkVHRVgudGVzdCh0b2tlbi5zdGVtKSkge1xuICAgICAgICAgICAgLy8gUHJlY2lzaW9uXG4gICAgICAgICAgICAvLyBodHRwczovL3VuaWNvZGUtb3JnLmdpdGh1Yi5pby9pY3UvdXNlcmd1aWRlL2Zvcm1hdF9wYXJzZS9udW1iZXJzL3NrZWxldG9ucy5odG1sI2ZyYWN0aW9uLXByZWNpc2lvblxuICAgICAgICAgICAgLy8gcHJlY2lzaW9uLWludGVnZXIgY2FzZVxuICAgICAgICAgICAgaWYgKHRva2VuLm9wdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdGcmFjdGlvbi1wcmVjaXNpb24gc3RlbXMgb25seSBhY2NlcHQgYSBzaW5nbGUgb3B0aW9uYWwgb3B0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbi5zdGVtLnJlcGxhY2UoRlJBQ1RJT05fUFJFQ0lTSU9OX1JFR0VYLCBmdW5jdGlvbiAoXywgZzEsIGcyLCBnMywgZzQsIGc1KSB7XG4gICAgICAgICAgICAgICAgLy8gLjAwMCogY2FzZSAoYmVmb3JlIElDVTY3IGl0IHdhcyAuMDAwKylcbiAgICAgICAgICAgICAgICBpZiAoZzIgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubWluaW11bUZyYWN0aW9uRGlnaXRzID0gZzEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAuIyMjIGNhc2VcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChnMyAmJiBnM1swXSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tYXhpbXVtRnJhY3Rpb25EaWdpdHMgPSBnMy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIC4wMCMjIGNhc2VcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChnNCAmJiBnNSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubWluaW11bUZyYWN0aW9uRGlnaXRzID0gZzQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubWF4aW11bUZyYWN0aW9uRGlnaXRzID0gZzQubGVuZ3RoICsgZzUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1pbmltdW1GcmFjdGlvbkRpZ2l0cyA9IGcxLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IGcxLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgb3B0ID0gdG9rZW4ub3B0aW9uc1swXTtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdW5pY29kZS1vcmcuZ2l0aHViLmlvL2ljdS91c2VyZ3VpZGUvZm9ybWF0X3BhcnNlL251bWJlcnMvc2tlbGV0b25zLmh0bWwjdHJhaWxpbmctemVyby1kaXNwbGF5XG4gICAgICAgICAgICBpZiAob3B0ID09PSAndycpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVzdWx0KSwgeyB0cmFpbGluZ1plcm9EaXNwbGF5OiAnc3RyaXBJZkludGVnZXInIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlc3VsdCksIHBhcnNlU2lnbmlmaWNhbnRQcmVjaXNpb24ob3B0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBodHRwczovL3VuaWNvZGUtb3JnLmdpdGh1Yi5pby9pY3UvdXNlcmd1aWRlL2Zvcm1hdF9wYXJzZS9udW1iZXJzL3NrZWxldG9ucy5odG1sI3NpZ25pZmljYW50LWRpZ2l0cy1wcmVjaXNpb25cbiAgICAgICAgaWYgKFNJR05JRklDQU5UX1BSRUNJU0lPTl9SRUdFWC50ZXN0KHRva2VuLnN0ZW0pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVzdWx0KSwgcGFyc2VTaWduaWZpY2FudFByZWNpc2lvbih0b2tlbi5zdGVtKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2lnbk9wdHMgPSBwYXJzZVNpZ24odG9rZW4uc3RlbSk7XG4gICAgICAgIGlmIChzaWduT3B0cykge1xuICAgICAgICAgICAgcmVzdWx0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlc3VsdCksIHNpZ25PcHRzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29uY2lzZVNjaWVudGlmaWNBbmRFbmdpbmVlcmluZ09wdHMgPSBwYXJzZUNvbmNpc2VTY2llbnRpZmljQW5kRW5naW5lZXJpbmdTdGVtKHRva2VuLnN0ZW0pO1xuICAgICAgICBpZiAoY29uY2lzZVNjaWVudGlmaWNBbmRFbmdpbmVlcmluZ09wdHMpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCBjb25jaXNlU2NpZW50aWZpY0FuZEVuZ2luZWVyaW5nT3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7O0FBQ08sU0FBUyw4QkFBOEIsUUFBUTtJQUNsRCxJQUFJLFNBQVMsTUFBTSxLQUFLLEdBQUc7UUFDdkIsTUFBTSxJQUFJLE1BQU07SUFDcEI7SUFDQSxxQkFBcUI7SUFDckIsSUFBSSxlQUFlLFNBQ2QsS0FBSyxDQUFDLHVMQUFBLENBQUEsb0JBQWlCLEVBQ3ZCLE1BQU0sQ0FBQyxTQUFVLENBQUM7UUFBSSxPQUFPLEVBQUUsTUFBTSxHQUFHO0lBQUc7SUFDaEQsSUFBSSxTQUFTLEVBQUU7SUFDZixJQUFLLElBQUksS0FBSyxHQUFHLGlCQUFpQixjQUFjLEtBQUssZUFBZSxNQUFNLEVBQUUsS0FBTTtRQUM5RSxJQUFJLGNBQWMsY0FBYyxDQUFDLEdBQUc7UUFDcEMsSUFBSSxpQkFBaUIsWUFBWSxLQUFLLENBQUM7UUFDdkMsSUFBSSxlQUFlLE1BQU0sS0FBSyxHQUFHO1lBQzdCLE1BQU0sSUFBSSxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxPQUFPLGNBQWMsQ0FBQyxFQUFFLEVBQUUsVUFBVSxlQUFlLEtBQUssQ0FBQztRQUM3RCxJQUFLLElBQUksS0FBSyxHQUFHLFlBQVksU0FBUyxLQUFLLFVBQVUsTUFBTSxFQUFFLEtBQU07WUFDL0QsSUFBSSxTQUFTLFNBQVMsQ0FBQyxHQUFHO1lBQzFCLElBQUksT0FBTyxNQUFNLEtBQUssR0FBRztnQkFDckIsTUFBTSxJQUFJLE1BQU07WUFDcEI7UUFDSjtRQUNBLE9BQU8sSUFBSSxDQUFDO1lBQUUsTUFBTTtZQUFNLFNBQVM7UUFBUTtJQUMvQztJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVMsY0FBYyxJQUFJO0lBQ3ZCLE9BQU8sS0FBSyxPQUFPLENBQUMsV0FBVztBQUNuQztBQUNBLElBQUksMkJBQTJCO0FBQy9CLElBQUksOEJBQThCO0FBQ2xDLElBQUks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QUFRLEFBQUQsRUFBRSxDQUFDLEdBQUcsU0FBUztRQUM1QztRQUNBLElBQUksc0NBQXNDLHlDQUF5QyxNQUFNLElBQUk7UUFDN0YsSUFBSSxxQ0FBcUM7WUFDckMsU0FBUyxDQUFBLEdBQUEseUlBQUEsQ0FBQSxXQUFRLEFBQUQsRUFBRSxDQUFBLEdBQUEseUlBQUEsQ0FBQSxXQUFRLEFBQUQsRUFBRSxDQUFDLEdBQUcsU0FBUztRQUM1QztJQUNKO0lBQ0EsT0FBTztBQUNYIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEzMzgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwZm9ybWF0anMvaWN1LXNrZWxldG9uLXBhcnNlci9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9kYXRlLXRpbWUnO1xuZXhwb3J0ICogZnJvbSAnLi9udW1iZXInO1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEzNTUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwZm9ybWF0anMvaWN1LW1lc3NhZ2Vmb3JtYXQtcGFyc2VyL2xpYi90aW1lLWRhdGEuZ2VuZXJhdGVkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEBnZW5lcmF0ZWQgZnJvbSB0aW1lLWRhdGEtZ2VuLnRzXG4vLyBwcmV0dGllci1pZ25vcmUgIFxuZXhwb3J0IHZhciB0aW1lRGF0YSA9IHtcbiAgICBcIjAwMVwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIlxuICAgIF0sXG4gICAgXCI0MTlcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiXG4gICAgXSxcbiAgICBcIkFDXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJBRFwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiQUVcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIkFGXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhcIlxuICAgIF0sXG4gICAgXCJBR1wiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiQUlcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkFMXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiQU1cIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkFPXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJBUlwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCJcbiAgICBdLFxuICAgIFwiQVNcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiQVRcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkFVXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJBV1wiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiQVhcIjogW1xuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJBWlwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaFwiXG4gICAgXSxcbiAgICBcIkJBXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoXCJcbiAgICBdLFxuICAgIFwiQkJcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkJEXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiQkVcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkJGXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJCR1wiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaFwiXG4gICAgXSxcbiAgICBcIkJIXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJCSVwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIlxuICAgIF0sXG4gICAgXCJCSlwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiQkxcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkJNXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJCTlwiOiBbXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiQk9cIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiXG4gICAgXSxcbiAgICBcIkJRXCI6IFtcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiQlJcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkJTXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJCVFwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJCV1wiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiQllcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCJcbiAgICBdLFxuICAgIFwiQlpcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkNBXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJDQ1wiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiQ0RcIjogW1xuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIkNGXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiQ0dcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkNIXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoXCJcbiAgICBdLFxuICAgIFwiQ0lcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkNLXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJDTFwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCJcbiAgICBdLFxuICAgIFwiQ01cIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJDTlwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJoXCJcbiAgICBdLFxuICAgIFwiQ09cIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiXG4gICAgXSxcbiAgICBcIkNQXCI6IFtcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiQ1JcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiXG4gICAgXSxcbiAgICBcIkNVXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIlxuICAgIF0sXG4gICAgXCJDVlwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiQ1dcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkNYXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJDWVwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiQ1pcIjogW1xuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJERVwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiREdcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkRKXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIkRLXCI6IFtcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiRE1cIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkRPXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIlxuICAgIF0sXG4gICAgXCJEWlwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiRUFcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiXG4gICAgXSxcbiAgICBcIkVDXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIlxuICAgIF0sXG4gICAgXCJFRVwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiRUdcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIkVIXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJFUlwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJFU1wiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCJcbiAgICBdLFxuICAgIFwiRVRcIjogW1xuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIkZJXCI6IFtcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiRkpcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkZLXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJGTVwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiRk9cIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCJcbiAgICBdLFxuICAgIFwiRlJcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkdBXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJHQlwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiR0RcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkdFXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoXCJcbiAgICBdLFxuICAgIFwiR0ZcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkdHXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJHSFwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJHSVwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiR0xcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCJcbiAgICBdLFxuICAgIFwiR01cIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkdOXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJHUFwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiR1FcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiXG4gICAgXSxcbiAgICBcIkdSXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJHVFwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCJcbiAgICBdLFxuICAgIFwiR1VcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkdXXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJHWVwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiSEtcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIkhOXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIlxuICAgIF0sXG4gICAgXCJIUlwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiSFVcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCJcbiAgICBdLFxuICAgIFwiSUNcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiXG4gICAgXSxcbiAgICBcIklEXCI6IFtcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiSUVcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIklMXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJJTVwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiSU5cIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiSU9cIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIklRXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJJUlwiOiBbXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiSVNcIjogW1xuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJJVFwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiSkVcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkpNXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJKT1wiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiSlBcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJLXCIsXG4gICAgICAgIFwiaFwiXG4gICAgXSxcbiAgICBcIktFXCI6IFtcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIlxuICAgIF0sXG4gICAgXCJLR1wiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCJcbiAgICBdLFxuICAgIFwiS0hcIjogW1xuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoYlwiXG4gICAgXSxcbiAgICBcIktJXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJLTVwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCJcbiAgICBdLFxuICAgIFwiS05cIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIktQXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIlxuICAgIF0sXG4gICAgXCJLUlwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCJcbiAgICBdLFxuICAgIFwiS1dcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIktZXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJLWlwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiTEFcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaFwiXG4gICAgXSxcbiAgICBcIkxCXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJMQ1wiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiTElcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhcIlxuICAgIF0sXG4gICAgXCJMS1wiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCJcbiAgICBdLFxuICAgIFwiTFJcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkxTXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIkxUXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJMVVwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIkxWXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhcIlxuICAgIF0sXG4gICAgXCJMWVwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiTUFcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiXG4gICAgXSxcbiAgICBcIk1DXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJNRFwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiTUVcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhcIlxuICAgIF0sXG4gICAgXCJNRlwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiTUdcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCJcbiAgICBdLFxuICAgIFwiTUhcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIk1LXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJNTFwiOiBbXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIk1NXCI6IFtcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIlxuICAgIF0sXG4gICAgXCJNTlwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiTU9cIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIk1QXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJNUVwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiTVJcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIk1TXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJNVFwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIlxuICAgIF0sXG4gICAgXCJNVVwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIlxuICAgIF0sXG4gICAgXCJNVlwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIlxuICAgIF0sXG4gICAgXCJNV1wiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiTVhcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiXG4gICAgXSxcbiAgICBcIk1ZXCI6IFtcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJNWlwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiTkFcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiXG4gICAgXSxcbiAgICBcIk5DXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJORVwiOiBbXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIk5GXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJOR1wiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiTklcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiXG4gICAgXSxcbiAgICBcIk5MXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJOT1wiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIlxuICAgIF0sXG4gICAgXCJOUFwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIk5SXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJOVVwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiTlpcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIk9NXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJQQVwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCJcbiAgICBdLFxuICAgIFwiUEVcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiXG4gICAgXSxcbiAgICBcIlBGXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiUEdcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiUEhcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIlBLXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiUExcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCJcbiAgICBdLFxuICAgIFwiUE1cIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIlBOXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJQUlwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCJcbiAgICBdLFxuICAgIFwiUFNcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIlBUXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJQV1wiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJQWVwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCJcbiAgICBdLFxuICAgIFwiUUFcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIlJFXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJST1wiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiUlNcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhcIlxuICAgIF0sXG4gICAgXCJSVVwiOiBbXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIlJXXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiXG4gICAgXSxcbiAgICBcIlNBXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJTQlwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiU0NcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJTRFwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiU0VcIjogW1xuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJTR1wiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiU0hcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIlNJXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJTSlwiOiBbXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIlNLXCI6IFtcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiU0xcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIlNNXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiU05cIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJTT1wiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJTUlwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiU1NcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIlNUXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJTVlwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCJcbiAgICBdLFxuICAgIFwiU1hcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIlNZXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJTWlwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiVEFcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIlRDXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJURFwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIlRGXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiVEdcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIlRIXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiXG4gICAgXSxcbiAgICBcIlRKXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiXG4gICAgXSxcbiAgICBcIlRMXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhcIlxuICAgIF0sXG4gICAgXCJUTVwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIlxuICAgIF0sXG4gICAgXCJUTlwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiVE9cIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiVFJcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIlRUXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJUV1wiOiBbXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiVFpcIjogW1xuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiXG4gICAgXSxcbiAgICBcIlVBXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoXCJcbiAgICBdLFxuICAgIFwiVUdcIjogW1xuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiXG4gICAgXSxcbiAgICBcIlVNXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJVU1wiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiVVlcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiXG4gICAgXSxcbiAgICBcIlVaXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoXCJcbiAgICBdLFxuICAgIFwiVkFcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJWQ1wiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiVkVcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiXG4gICAgXSxcbiAgICBcIlZHXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJWSVwiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiVk5cIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCJcbiAgICBdLFxuICAgIFwiVlVcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiV0ZcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIldTXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIlhLXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoXCJcbiAgICBdLFxuICAgIFwiWUVcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcIllUXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJaQVwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiWk1cIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcIlpXXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiXG4gICAgXSxcbiAgICBcImFmLVpBXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIlxuICAgIF0sXG4gICAgXCJhci0wMDFcIjogW1xuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcImNhLUVTXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiZW4tMDAxXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJlbi1IS1wiOiBbXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhiXCIsXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiZW4tSUxcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcImVuLU1ZXCI6IFtcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJlcy1CUlwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhiXCJcbiAgICBdLFxuICAgIFwiZXMtRVNcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiXG4gICAgXSxcbiAgICBcImVzLUdRXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIlxuICAgIF0sXG4gICAgXCJmci1DQVwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcImdsLUVTXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcImhCXCJcbiAgICBdLFxuICAgIFwiZ3UtSU5cIjogW1xuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcImhpLUlOXCI6IFtcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwiaXQtQ0hcIjogW1xuICAgICAgICBcIkhcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiaEJcIlxuICAgIF0sXG4gICAgXCJpdC1JVFwiOiBbXG4gICAgICAgIFwiSFwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoQlwiXG4gICAgXSxcbiAgICBcImtuLUlOXCI6IFtcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwibWwtSU5cIjogW1xuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaFwiLFxuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJtci1JTlwiOiBbXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJIXCJcbiAgICBdLFxuICAgIFwicGEtSU5cIjogW1xuICAgICAgICBcImhCXCIsXG4gICAgICAgIFwiaGJcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcInRhLUlOXCI6IFtcbiAgICAgICAgXCJoQlwiLFxuICAgICAgICBcImhcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcIkhcIlxuICAgIF0sXG4gICAgXCJ0ZS1JTlwiOiBbXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoXCIsXG4gICAgICAgIFwiSFwiXG4gICAgXSxcbiAgICBcInp1LVpBXCI6IFtcbiAgICAgICAgXCJIXCIsXG4gICAgICAgIFwiaEJcIixcbiAgICAgICAgXCJoYlwiLFxuICAgICAgICBcImhcIlxuICAgIF1cbn07XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsbUNBQW1DO0FBQ25DLG9CQUFvQjs7OztBQUNiLElBQUksV0FBVztJQUNsQixPQUFPO1FBQ0g7UUFDQTtLQUNIO0lBQ0QsT0FBTztRQUNIO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7S0FDSDtJQUNELE1BQU07UUFDRjtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7S0FDSDtJQUNELE1BQU07UUFDRjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsTUFBTTtRQUNGO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNO1FBQ0Y7UUFDQTtLQUNIO0lBQ0QsU0FBUztRQUNMO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxVQUFVO1FBQ047UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELFNBQVM7UUFDTDtRQUNBO1FBQ0E7S0FDSDtJQUNELFVBQVU7UUFDTjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsU0FBUztRQUNMO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxTQUFTO1FBQ0w7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELFNBQVM7UUFDTDtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsU0FBUztRQUNMO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxTQUFTO1FBQ0w7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELFNBQVM7UUFDTDtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsU0FBUztRQUNMO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsU0FBUztRQUNMO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsU0FBUztRQUNMO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxTQUFTO1FBQ0w7UUFDQTtRQUNBO0tBQ0g7SUFDRCxTQUFTO1FBQ0w7UUFDQTtRQUNBO0tBQ0g7SUFDRCxTQUFTO1FBQ0w7UUFDQTtRQUNBO0tBQ0g7SUFDRCxTQUFTO1FBQ0w7UUFDQTtRQUNBO0tBQ0g7SUFDRCxTQUFTO1FBQ0w7UUFDQTtRQUNBO0tBQ0g7SUFDRCxTQUFTO1FBQ0w7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELFNBQVM7UUFDTDtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsU0FBUztRQUNMO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxTQUFTO1FBQ0w7UUFDQTtRQUNBO0tBQ0g7SUFDRCxTQUFTO1FBQ0w7UUFDQTtRQUNBO1FBQ0E7S0FDSDtBQUNMIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI3NzksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwZm9ybWF0anMvaWN1LW1lc3NhZ2Vmb3JtYXQtcGFyc2VyL2xpYi9kYXRlLXRpbWUtcGF0dGVybi1nZW5lcmF0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdGltZURhdGEgfSBmcm9tICcuL3RpbWUtZGF0YS5nZW5lcmF0ZWQnO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBiZXN0IG1hdGNoaW5nIGRhdGUgdGltZSBwYXR0ZXJuIGlmIGEgZGF0ZSB0aW1lIHNrZWxldG9uXG4gKiBwYXR0ZXJuIGlzIHByb3ZpZGVkIHdpdGggYSBsb2NhbGUuIEZvbGxvd3MgdGhlIFVuaWNvZGUgc3BlY2lmaWNhdGlvbjpcbiAqIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjdGFibGUtbWFwcGluZy1yZXF1ZXN0ZWQtdGltZS1za2VsZXRvbnMtdG8tcGF0dGVybnNcbiAqIEBwYXJhbSBza2VsZXRvbiBkYXRlIHRpbWUgc2tlbGV0b24gcGF0dGVybiB0aGF0IHBvc3NpYmx5IGluY2x1ZGVzIGosIEogb3IgQ1xuICogQHBhcmFtIGxvY2FsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmVzdFBhdHRlcm4oc2tlbGV0b24sIGxvY2FsZSkge1xuICAgIHZhciBza2VsZXRvbkNvcHkgPSAnJztcbiAgICBmb3IgKHZhciBwYXR0ZXJuUG9zID0gMDsgcGF0dGVyblBvcyA8IHNrZWxldG9uLmxlbmd0aDsgcGF0dGVyblBvcysrKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuQ2hhciA9IHNrZWxldG9uLmNoYXJBdChwYXR0ZXJuUG9zKTtcbiAgICAgICAgaWYgKHBhdHRlcm5DaGFyID09PSAnaicpIHtcbiAgICAgICAgICAgIHZhciBleHRyYUxlbmd0aCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAocGF0dGVyblBvcyArIDEgPCBza2VsZXRvbi5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBza2VsZXRvbi5jaGFyQXQocGF0dGVyblBvcyArIDEpID09PSBwYXR0ZXJuQ2hhcikge1xuICAgICAgICAgICAgICAgIGV4dHJhTGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgcGF0dGVyblBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhvdXJMZW4gPSAxICsgKGV4dHJhTGVuZ3RoICYgMSk7XG4gICAgICAgICAgICB2YXIgZGF5UGVyaW9kTGVuID0gZXh0cmFMZW5ndGggPCAyID8gMSA6IDMgKyAoZXh0cmFMZW5ndGggPj4gMSk7XG4gICAgICAgICAgICB2YXIgZGF5UGVyaW9kQ2hhciA9ICdhJztcbiAgICAgICAgICAgIHZhciBob3VyQ2hhciA9IGdldERlZmF1bHRIb3VyU3ltYm9sRnJvbUxvY2FsZShsb2NhbGUpO1xuICAgICAgICAgICAgaWYgKGhvdXJDaGFyID09ICdIJyB8fCBob3VyQ2hhciA9PSAnaycpIHtcbiAgICAgICAgICAgICAgICBkYXlQZXJpb2RMZW4gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGRheVBlcmlvZExlbi0tID4gMCkge1xuICAgICAgICAgICAgICAgIHNrZWxldG9uQ29weSArPSBkYXlQZXJpb2RDaGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGhvdXJMZW4tLSA+IDApIHtcbiAgICAgICAgICAgICAgICBza2VsZXRvbkNvcHkgPSBob3VyQ2hhciArIHNrZWxldG9uQ29weTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXR0ZXJuQ2hhciA9PT0gJ0onKSB7XG4gICAgICAgICAgICBza2VsZXRvbkNvcHkgKz0gJ0gnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2tlbGV0b25Db3B5ICs9IHBhdHRlcm5DaGFyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBza2VsZXRvbkNvcHk7XG59XG4vKipcbiAqIE1hcHMgdGhlIFtob3VyIGN5Y2xlIHR5cGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludGwvTG9jYWxlL2hvdXJDeWNsZSlcbiAqIG9mIHRoZSBnaXZlbiBgbG9jYWxlYCB0byB0aGUgY29ycmVzcG9uZGluZyB0aW1lIHBhdHRlcm4uXG4gKiBAcGFyYW0gbG9jYWxlXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRIb3VyU3ltYm9sRnJvbUxvY2FsZShsb2NhbGUpIHtcbiAgICB2YXIgaG91ckN5Y2xlID0gbG9jYWxlLmhvdXJDeWNsZTtcbiAgICBpZiAoaG91ckN5Y2xlID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBob3VyQ3ljbGUocykgaXMgbm90IGlkZW50aWZpZWQgeWV0XG4gICAgICAgIGxvY2FsZS5ob3VyQ3ljbGVzICYmXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbG9jYWxlLmhvdXJDeWNsZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaG91ckN5Y2xlID0gbG9jYWxlLmhvdXJDeWNsZXNbMF07XG4gICAgfVxuICAgIGlmIChob3VyQ3ljbGUpIHtcbiAgICAgICAgc3dpdGNoIChob3VyQ3ljbGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2gyNCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdrJztcbiAgICAgICAgICAgIGNhc2UgJ2gyMyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdIJztcbiAgICAgICAgICAgIGNhc2UgJ2gxMic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdoJztcbiAgICAgICAgICAgIGNhc2UgJ2gxMSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdLJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhvdXJDeWNsZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRPRE86IE9uY2UgaG91ckN5Y2xlIGlzIGZ1bGx5IHN1cHBvcnRlZCByZW1vdmUgdGhlIGZvbGxvd2luZyB3aXRoIGRhdGEgZ2VuZXJhdGlvblxuICAgIHZhciBsYW5ndWFnZVRhZyA9IGxvY2FsZS5sYW5ndWFnZTtcbiAgICB2YXIgcmVnaW9uVGFnO1xuICAgIGlmIChsYW5ndWFnZVRhZyAhPT0gJ3Jvb3QnKSB7XG4gICAgICAgIHJlZ2lvblRhZyA9IGxvY2FsZS5tYXhpbWl6ZSgpLnJlZ2lvbjtcbiAgICB9XG4gICAgdmFyIGhvdXJDeWNsZXMgPSB0aW1lRGF0YVtyZWdpb25UYWcgfHwgJyddIHx8XG4gICAgICAgIHRpbWVEYXRhW2xhbmd1YWdlVGFnIHx8ICcnXSB8fFxuICAgICAgICB0aW1lRGF0YVtcIlwiLmNvbmNhdChsYW5ndWFnZVRhZywgXCItMDAxXCIpXSB8fFxuICAgICAgICB0aW1lRGF0YVsnMDAxJ107XG4gICAgcmV0dXJuIGhvdXJDeWNsZXNbMF07XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7O0FBUU8sU0FBUyxlQUFlLFFBQVEsRUFBRSxNQUFNO0lBQzNDLElBQUksZUFBZTtJQUNuQixJQUFLLElBQUksYUFBYSxHQUFHLGFBQWEsU0FBUyxNQUFNLEVBQUUsYUFBYztRQUNqRSxJQUFJLGNBQWMsU0FBUyxNQUFNLENBQUM7UUFDbEMsSUFBSSxnQkFBZ0IsS0FBSztZQUNyQixJQUFJLGNBQWM7WUFDbEIsTUFBTyxhQUFhLElBQUksU0FBUyxNQUFNLElBQ25DLFNBQVMsTUFBTSxDQUFDLGFBQWEsT0FBTyxZQUFhO2dCQUNqRDtnQkFDQTtZQUNKO1lBQ0EsSUFBSSxVQUFVLElBQUksQ0FBQyxjQUFjLENBQUM7WUFDbEMsSUFBSSxlQUFlLGNBQWMsSUFBSSxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUM7WUFDOUQsSUFBSSxnQkFBZ0I7WUFDcEIsSUFBSSxXQUFXLCtCQUErQjtZQUM5QyxJQUFJLFlBQVksT0FBTyxZQUFZLEtBQUs7Z0JBQ3BDLGVBQWU7WUFDbkI7WUFDQSxNQUFPLGlCQUFpQixFQUFHO2dCQUN2QixnQkFBZ0I7WUFDcEI7WUFDQSxNQUFPLFlBQVksRUFBRztnQkFDbEIsZUFBZSxXQUFXO1lBQzlCO1FBQ0osT0FDSyxJQUFJLGdCQUFnQixLQUFLO1lBQzFCLGdCQUFnQjtRQUNwQixPQUNLO1lBQ0QsZ0JBQWdCO1FBQ3BCO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7OztDQUlDLEdBQ0QsU0FBUywrQkFBK0IsTUFBTTtJQUMxQyxJQUFJLFlBQVksT0FBTyxTQUFTO0lBQ2hDLElBQUksY0FBYyxhQUNkLGdEQUFnRDtJQUNoRCxPQUFPLFVBQVUsSUFDakIsYUFBYTtJQUNiLE9BQU8sVUFBVSxDQUFDLE1BQU0sRUFBRTtRQUMxQixhQUFhO1FBQ2IsWUFBWSxPQUFPLFVBQVUsQ0FBQyxFQUFFO0lBQ3BDO0lBQ0EsSUFBSSxXQUFXO1FBQ1gsT0FBUTtZQUNKLEtBQUs7Z0JBQ0QsT0FBTztZQUNYLEtBQUs7Z0JBQ0QsT0FBTztZQUNYLEtBQUs7Z0JBQ0QsT0FBTztZQUNYLEtBQUs7Z0JBQ0QsT0FBTztZQUNYO2dCQUNJLE1BQU0sSUFBSSxNQUFNO1FBQ3hCO0lBQ0o7SUFDQSxvRkFBb0Y7SUFDcEYsSUFBSSxjQUFjLE9BQU8sUUFBUTtJQUNqQyxJQUFJO0lBQ0osSUFBSSxnQkFBZ0IsUUFBUTtRQUN4QixZQUFZLE9BQU8sUUFBUSxHQUFHLE1BQU07SUFDeEM7SUFDQSxJQUFJLGFBQWEsbU1BQUEsQ0FBQSxXQUFRLENBQUMsYUFBYSxHQUFHLElBQ3RDLG1NQUFBLENBQUEsV0FBUSxDQUFDLGVBQWUsR0FBRyxJQUMzQixtTUFBQSxDQUFBLFdBQVEsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxhQUFhLFFBQVEsSUFDeEMsbU1BQUEsQ0FBQSxXQUFRLENBQUMsTUFBTTtJQUNuQixPQUFPLFVBQVUsQ0FBQyxFQUFFO0FBQ3hCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI4NTQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwZm9ybWF0anMvaWN1LW1lc3NhZ2Vmb3JtYXQtcGFyc2VyL2xpYi9wYXJzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9hO1xuaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEVycm9yS2luZCB9IGZyb20gJy4vZXJyb3InO1xuaW1wb3J0IHsgU0tFTEVUT05fVFlQRSwgVFlQRSwgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFNQQUNFX1NFUEFSQVRPUl9SRUdFWCB9IGZyb20gJy4vcmVnZXguZ2VuZXJhdGVkJztcbmltcG9ydCB7IHBhcnNlTnVtYmVyU2tlbGV0b24sIHBhcnNlTnVtYmVyU2tlbGV0b25Gcm9tU3RyaW5nLCBwYXJzZURhdGVUaW1lU2tlbGV0b24sIH0gZnJvbSAnQGZvcm1hdGpzL2ljdS1za2VsZXRvbi1wYXJzZXInO1xuaW1wb3J0IHsgZ2V0QmVzdFBhdHRlcm4gfSBmcm9tICcuL2RhdGUtdGltZS1wYXR0ZXJuLWdlbmVyYXRvcic7XG52YXIgU1BBQ0VfU0VQQVJBVE9SX1NUQVJUX1JFR0VYID0gbmV3IFJlZ0V4cChcIl5cIi5jb25jYXQoU1BBQ0VfU0VQQVJBVE9SX1JFR0VYLnNvdXJjZSwgXCIqXCIpKTtcbnZhciBTUEFDRV9TRVBBUkFUT1JfRU5EX1JFR0VYID0gbmV3IFJlZ0V4cChcIlwiLmNvbmNhdChTUEFDRV9TRVBBUkFUT1JfUkVHRVguc291cmNlLCBcIiokXCIpKTtcbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG59XG4vLyAjcmVnaW9uIFBvbnlmaWxsc1xuLy8gQ29uc29saWRhdGUgdGhlc2UgdmFyaWFibGVzIHVwIHRvcCBmb3IgZWFzaWVyIHRvZ2dsaW5nIGR1cmluZyBkZWJ1Z2dpbmdcbnZhciBoYXNOYXRpdmVTdGFydHNXaXRoID0gISFTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggJiYgJ19hJy5zdGFydHNXaXRoKCdhJywgMSk7XG52YXIgaGFzTmF0aXZlRnJvbUNvZGVQb2ludCA9ICEhU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG52YXIgaGFzTmF0aXZlRnJvbUVudHJpZXMgPSAhIU9iamVjdC5mcm9tRW50cmllcztcbnZhciBoYXNOYXRpdmVDb2RlUG9pbnRBdCA9ICEhU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdDtcbnZhciBoYXNUcmltU3RhcnQgPSAhIVN0cmluZy5wcm90b3R5cGUudHJpbVN0YXJ0O1xudmFyIGhhc1RyaW1FbmQgPSAhIVN0cmluZy5wcm90b3R5cGUudHJpbUVuZDtcbnZhciBoYXNOYXRpdmVJc1NhZmVJbnRlZ2VyID0gISFOdW1iZXIuaXNTYWZlSW50ZWdlcjtcbnZhciBpc1NhZmVJbnRlZ2VyID0gaGFzTmF0aXZlSXNTYWZlSW50ZWdlclxuICAgID8gTnVtYmVyLmlzU2FmZUludGVnZXJcbiAgICA6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIG4gPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICBpc0Zpbml0ZShuKSAmJlxuICAgICAgICAgICAgTWF0aC5mbG9vcihuKSA9PT0gbiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMobikgPD0gMHgxZmZmZmZmZmZmZmZmZik7XG4gICAgfTtcbi8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCB5IGFuZCB1LlxudmFyIFJFR0VYX1NVUFBPUlRTX1VfQU5EX1kgPSB0cnVlO1xudHJ5IHtcbiAgICB2YXIgcmUgPSBSRSgnKFteXFxcXHB7V2hpdGVfU3BhY2V9XFxcXHB7UGF0dGVybl9TeW50YXh9XSopJywgJ3l1Jyk7XG4gICAgLyoqXG4gICAgICogbGVnYWN5IEVkZ2Ugb3IgWGJveCBPbmUgYnJvd3NlclxuICAgICAqIFVuaWNvZGUgZmxhZyBzdXBwb3J0OiBzdXBwb3J0ZWRcbiAgICAgKiBQYXR0ZXJuX1N5bnRheCBzdXBwb3J0OiBub3Qgc3VwcG9ydGVkXG4gICAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtYXRqcy9mb3JtYXRqcy9pc3N1ZXMvMjgyMlxuICAgICAqL1xuICAgIFJFR0VYX1NVUFBPUlRTX1VfQU5EX1kgPSAoKF9hID0gcmUuZXhlYygnYScpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSAnYSc7XG59XG5jYXRjaCAoXykge1xuICAgIFJFR0VYX1NVUFBPUlRTX1VfQU5EX1kgPSBmYWxzZTtcbn1cbnZhciBzdGFydHNXaXRoID0gaGFzTmF0aXZlU3RhcnRzV2l0aFxuICAgID8gLy8gTmF0aXZlXG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgocywgc2VhcmNoLCBwb3NpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHMuc3RhcnRzV2l0aChzZWFyY2gsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIDogLy8gRm9yIElFMTFcbiAgICAgICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzLCBzZWFyY2gsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xuICAgICAgICB9O1xudmFyIGZyb21Db2RlUG9pbnQgPSBoYXNOYXRpdmVGcm9tQ29kZVBvaW50XG4gICAgPyBTdHJpbmcuZnJvbUNvZGVQb2ludFxuICAgIDogLy8gSUUxMVxuICAgICAgICBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KCkge1xuICAgICAgICAgICAgdmFyIGNvZGVQb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gJyc7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgICAgIHdoaWxlIChsZW5ndGggPiBpKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGVQb2ludHNbaSsrXTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA+IDB4MTBmZmZmKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50cyArPVxuICAgICAgICAgICAgICAgICAgICBjb2RlIDwgMHgxMDAwMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4ZDgwMCwgKGNvZGUgJSAweDQwMCkgKyAweGRjMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgICB9O1xudmFyIGZyb21FbnRyaWVzID0gXG4vLyBuYXRpdmVcbmhhc05hdGl2ZUZyb21FbnRyaWVzXG4gICAgPyBPYmplY3QuZnJvbUVudHJpZXNcbiAgICA6IC8vIFBvbnlmaWxsXG4gICAgICAgIGZ1bmN0aW9uIGZyb21FbnRyaWVzKGVudHJpZXMpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgZW50cmllc18xID0gZW50cmllczsgX2kgPCBlbnRyaWVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gZW50cmllc18xW19pXSwgayA9IF9hWzBdLCB2ID0gX2FbMV07XG4gICAgICAgICAgICAgICAgb2JqW2tdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG52YXIgY29kZVBvaW50QXQgPSBoYXNOYXRpdmVDb2RlUG9pbnRBdFxuICAgID8gLy8gTmF0aXZlXG4gICAgICAgIGZ1bmN0aW9uIGNvZGVQb2ludEF0KHMsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gcy5jb2RlUG9pbnRBdChpbmRleCk7XG4gICAgICAgIH1cbiAgICA6IC8vIElFIDExXG4gICAgICAgIGZ1bmN0aW9uIGNvZGVQb2ludEF0KHMsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmaXJzdCA9IHMuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICB2YXIgc2Vjb25kO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0IDwgMHhkODAwIHx8XG4gICAgICAgICAgICAgICAgZmlyc3QgPiAweGRiZmYgfHxcbiAgICAgICAgICAgICAgICBpbmRleCArIDEgPT09IHNpemUgfHxcbiAgICAgICAgICAgICAgICAoc2Vjb25kID0gcy5jaGFyQ29kZUF0KGluZGV4ICsgMSkpIDwgMHhkYzAwIHx8XG4gICAgICAgICAgICAgICAgc2Vjb25kID4gMHhkZmZmXG4gICAgICAgICAgICAgICAgPyBmaXJzdFxuICAgICAgICAgICAgICAgIDogKChmaXJzdCAtIDB4ZDgwMCkgPDwgMTApICsgKHNlY29uZCAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICAgICAgICB9O1xudmFyIHRyaW1TdGFydCA9IGhhc1RyaW1TdGFydFxuICAgID8gLy8gTmF0aXZlXG4gICAgICAgIGZ1bmN0aW9uIHRyaW1TdGFydChzKSB7XG4gICAgICAgICAgICByZXR1cm4gcy50cmltU3RhcnQoKTtcbiAgICAgICAgfVxuICAgIDogLy8gUG9ueWZpbGxcbiAgICAgICAgZnVuY3Rpb24gdHJpbVN0YXJ0KHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzLnJlcGxhY2UoU1BBQ0VfU0VQQVJBVE9SX1NUQVJUX1JFR0VYLCAnJyk7XG4gICAgICAgIH07XG52YXIgdHJpbUVuZCA9IGhhc1RyaW1FbmRcbiAgICA/IC8vIE5hdGl2ZVxuICAgICAgICBmdW5jdGlvbiB0cmltRW5kKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzLnRyaW1FbmQoKTtcbiAgICAgICAgfVxuICAgIDogLy8gUG9ueWZpbGxcbiAgICAgICAgZnVuY3Rpb24gdHJpbUVuZChzKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKFNQQUNFX1NFUEFSQVRPUl9FTkRfUkVHRVgsICcnKTtcbiAgICAgICAgfTtcbi8vIFByZXZlbnQgbWluaWZpZXIgdG8gdHJhbnNsYXRlIG5ldyBSZWdFeHAgdG8gbGl0ZXJhbCBmb3JtIHRoYXQgbWlnaHQgY2F1c2Ugc3ludGF4IGVycm9yIG9uIElFMTEuXG5mdW5jdGlvbiBSRShzLCBmbGFnKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocywgZmxhZyk7XG59XG4vLyAjZW5kcmVnaW9uXG52YXIgbWF0Y2hJZGVudGlmaWVyQXRJbmRleDtcbmlmIChSRUdFWF9TVVBQT1JUU19VX0FORF9ZKSB7XG4gICAgLy8gTmF0aXZlXG4gICAgdmFyIElERU5USUZJRVJfUFJFRklYX1JFXzEgPSBSRSgnKFteXFxcXHB7V2hpdGVfU3BhY2V9XFxcXHB7UGF0dGVybl9TeW50YXh9XSopJywgJ3l1Jyk7XG4gICAgbWF0Y2hJZGVudGlmaWVyQXRJbmRleCA9IGZ1bmN0aW9uIG1hdGNoSWRlbnRpZmllckF0SW5kZXgocywgaW5kZXgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBJREVOVElGSUVSX1BSRUZJWF9SRV8xLmxhc3RJbmRleCA9IGluZGV4O1xuICAgICAgICB2YXIgbWF0Y2ggPSBJREVOVElGSUVSX1BSRUZJWF9SRV8xLmV4ZWMocyk7XG4gICAgICAgIHJldHVybiAoX2EgPSBtYXRjaFsxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgfTtcbn1cbmVsc2Uge1xuICAgIC8vIElFMTFcbiAgICBtYXRjaElkZW50aWZpZXJBdEluZGV4ID0gZnVuY3Rpb24gbWF0Y2hJZGVudGlmaWVyQXRJbmRleChzLCBpbmRleCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBbXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBjID0gY29kZVBvaW50QXQocywgaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGMgPT09IHVuZGVmaW5lZCB8fCBfaXNXaGl0ZVNwYWNlKGMpIHx8IF9pc1BhdHRlcm5TeW50YXgoYykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoLnB1c2goYyk7XG4gICAgICAgICAgICBpbmRleCArPSBjID49IDB4MTAwMDAgPyAyIDogMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbUNvZGVQb2ludC5hcHBseSh2b2lkIDAsIG1hdGNoKTtcbiAgICB9O1xufVxudmFyIFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0geyBvZmZzZXQ6IDAsIGxpbmU6IDEsIGNvbHVtbjogMSB9O1xuICAgICAgICB0aGlzLmlnbm9yZVRhZyA9ICEhb3B0aW9ucy5pZ25vcmVUYWc7XG4gICAgICAgIHRoaXMubG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XG4gICAgICAgIHRoaXMucmVxdWlyZXNPdGhlckNsYXVzZSA9ICEhb3B0aW9ucy5yZXF1aXJlc090aGVyQ2xhdXNlO1xuICAgICAgICB0aGlzLnNob3VsZFBhcnNlU2tlbGV0b25zID0gISFvcHRpb25zLnNob3VsZFBhcnNlU2tlbGV0b25zO1xuICAgIH1cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vZmZzZXQoKSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ3BhcnNlciBjYW4gb25seSBiZSB1c2VkIG9uY2UnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU1lc3NhZ2UoMCwgJycsIGZhbHNlKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VNZXNzYWdlID0gZnVuY3Rpb24gKG5lc3RpbmdMZXZlbCwgcGFyZW50QXJnVHlwZSwgZXhwZWN0aW5nQ2xvc2VUYWcpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICAgIHdoaWxlICghdGhpcy5pc0VPRigpKSB7XG4gICAgICAgICAgICB2YXIgY2hhciA9IHRoaXMuY2hhcigpO1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09IDEyMyAvKiBge2AgKi8pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZUFyZ3VtZW50KG5lc3RpbmdMZXZlbCwgZXhwZWN0aW5nQ2xvc2VUYWcpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gocmVzdWx0LnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAxMjUgLyogYH1gICovICYmIG5lc3RpbmdMZXZlbCA+IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IDM1IC8qIGAjYCAqLyAmJlxuICAgICAgICAgICAgICAgIChwYXJlbnRBcmdUeXBlID09PSAncGx1cmFsJyB8fCBwYXJlbnRBcmdUeXBlID09PSAnc2VsZWN0b3JkaW5hbCcpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5jbG9uZVBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5idW1wKCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFRZUEUucG91bmQsXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvbihwb3NpdGlvbiwgdGhpcy5jbG9uZVBvc2l0aW9uKCkpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gNjAgLyogYDxgICovICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaWdub3JlVGFnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5wZWVrKCkgPT09IDQ3IC8vIGNoYXIgY29kZSBmb3IgJy8nXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwZWN0aW5nQ2xvc2VUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihFcnJvcktpbmQuVU5NQVRDSEVEX0NMT1NJTkdfVEFHLCBjcmVhdGVMb2NhdGlvbih0aGlzLmNsb25lUG9zaXRpb24oKSwgdGhpcy5jbG9uZVBvc2l0aW9uKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSA2MCAvKiBgPGAgKi8gJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5pZ25vcmVUYWcgJiZcbiAgICAgICAgICAgICAgICBfaXNBbHBoYSh0aGlzLnBlZWsoKSB8fCAwKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlVGFnKG5lc3RpbmdMZXZlbCwgcGFyZW50QXJnVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChyZXN1bHQudmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlTGl0ZXJhbChuZXN0aW5nTGV2ZWwsIHBhcmVudEFyZ1R5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gocmVzdWx0LnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsOiBlbGVtZW50cywgZXJyOiBudWxsIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHRhZyBuYW1lIG11c3Qgc3RhcnQgd2l0aCBhbiBBU0NJSSBsb3dlci91cHBlciBjYXNlIGxldHRlci4gVGhlIGdyYW1tYXIgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW2N1c3RvbSBlbGVtZW50IG5hbWVdW10gZXhjZXB0IHRoYXQgYSBkYXNoIGlzIE5PVCBhbHdheXMgbWFuZGF0b3J5IGFuZCB1cHBlcmNhc2UgbGV0dGVyc1xuICAgICAqIGFyZSBhY2NlcHRlZDpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHRhZyA6Oj0gXCI8XCIgdGFnTmFtZSAod2hpdGVzcGFjZSkqIFwiLz5cIiB8IFwiPFwiIHRhZ05hbWUgKHdoaXRlc3BhY2UpKiBcIj5cIiBtZXNzYWdlIFwiPC9cIiB0YWdOYW1lICh3aGl0ZXNwYWNlKSogXCI+XCJcbiAgICAgKiB0YWdOYW1lIDo6PSBbYS16XSAoUEVOQ2hhcikqXG4gICAgICogUEVOQ2hhciA6Oj1cbiAgICAgKiAgICAgXCItXCIgfCBcIi5cIiB8IFswLTldIHwgXCJfXCIgfCBbYS16XSB8IFtBLVpdIHwgI3hCNyB8IFsjeEMwLSN4RDZdIHwgWyN4RDgtI3hGNl0gfCBbI3hGOC0jeDM3RF0gfFxuICAgICAqICAgICBbI3gzN0YtI3gxRkZGXSB8IFsjeDIwMEMtI3gyMDBEXSB8IFsjeDIwM0YtI3gyMDQwXSB8IFsjeDIwNzAtI3gyMThGXSB8IFsjeDJDMDAtI3gyRkVGXSB8XG4gICAgICogICAgIFsjeDMwMDEtI3hEN0ZGXSB8IFsjeEY5MDAtI3hGRENGXSB8IFsjeEZERjAtI3hGRkZEXSB8IFsjeDEwMDAwLSN4RUZGRkZdXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBbY3VzdG9tIGVsZW1lbnQgbmFtZV06IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2N1c3RvbS1lbGVtZW50cy5odG1sI3ZhbGlkLWN1c3RvbS1lbGVtZW50LW5hbWVcbiAgICAgKiBOT1RFOiBXZSdyZSBhIGJpdCBtb3JlIGxheCBoZXJlIHNpbmNlIEhUTUwgdGVjaG5pY2FsbHkgZG9lcyBub3QgYWxsb3cgdXBwZXJjYXNlIEhUTUwgZWxlbWVudCBidXQgd2UgZG9cbiAgICAgKiBzaW5jZSBvdGhlciB0YWctYmFzZWQgZW5naW5lcyBsaWtlIFJlYWN0IGFsbG93IGl0XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRhZyA9IGZ1bmN0aW9uIChuZXN0aW5nTGV2ZWwsIHBhcmVudEFyZ1R5cGUpIHtcbiAgICAgICAgdmFyIHN0YXJ0UG9zaXRpb24gPSB0aGlzLmNsb25lUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5idW1wKCk7IC8vIGA8YFxuICAgICAgICB2YXIgdGFnTmFtZSA9IHRoaXMucGFyc2VUYWdOYW1lKCk7XG4gICAgICAgIHRoaXMuYnVtcFNwYWNlKCk7XG4gICAgICAgIGlmICh0aGlzLmJ1bXBJZignLz4nKSkge1xuICAgICAgICAgICAgLy8gU2VsZiBjbG9zaW5nIHRhZ1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWw6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVFlQRS5saXRlcmFsLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCI8XCIuY29uY2F0KHRhZ05hbWUsIFwiLz5cIiksXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvbihzdGFydFBvc2l0aW9uLCB0aGlzLmNsb25lUG9zaXRpb24oKSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnI6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYnVtcElmKCc+JykpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlblJlc3VsdCA9IHRoaXMucGFyc2VNZXNzYWdlKG5lc3RpbmdMZXZlbCArIDEsIHBhcmVudEFyZ1R5cGUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuUmVzdWx0LmVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlblJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGNoaWxkcmVuUmVzdWx0LnZhbDtcbiAgICAgICAgICAgIC8vIEV4cGVjdGluZyBhIGNsb3NlIHRhZ1xuICAgICAgICAgICAgdmFyIGVuZFRhZ1N0YXJ0UG9zaXRpb24gPSB0aGlzLmNsb25lUG9zaXRpb24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1bXBJZignPC8nKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRU9GKCkgfHwgIV9pc0FscGhhKHRoaXMuY2hhcigpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihFcnJvcktpbmQuSU5WQUxJRF9UQUcsIGNyZWF0ZUxvY2F0aW9uKGVuZFRhZ1N0YXJ0UG9zaXRpb24sIHRoaXMuY2xvbmVQb3NpdGlvbigpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjbG9zaW5nVGFnTmFtZVN0YXJ0UG9zaXRpb24gPSB0aGlzLmNsb25lUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgY2xvc2luZ1RhZ05hbWUgPSB0aGlzLnBhcnNlVGFnTmFtZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lICE9PSBjbG9zaW5nVGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihFcnJvcktpbmQuVU5NQVRDSEVEX0NMT1NJTkdfVEFHLCBjcmVhdGVMb2NhdGlvbihjbG9zaW5nVGFnTmFtZVN0YXJ0UG9zaXRpb24sIHRoaXMuY2xvbmVQb3NpdGlvbigpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYnVtcFNwYWNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJ1bXBJZignPicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKEVycm9yS2luZC5JTlZBTElEX1RBRywgY3JlYXRlTG9jYXRpb24oZW5kVGFnU3RhcnRQb3NpdGlvbiwgdGhpcy5jbG9uZVBvc2l0aW9uKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFLnRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0YWdOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uKHN0YXJ0UG9zaXRpb24sIHRoaXMuY2xvbmVQb3NpdGlvbigpKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihFcnJvcktpbmQuVU5DTE9TRURfVEFHLCBjcmVhdGVMb2NhdGlvbihzdGFydFBvc2l0aW9uLCB0aGlzLmNsb25lUG9zaXRpb24oKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoRXJyb3JLaW5kLklOVkFMSURfVEFHLCBjcmVhdGVMb2NhdGlvbihzdGFydFBvc2l0aW9uLCB0aGlzLmNsb25lUG9zaXRpb24oKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3N1bWVzIHRoYXQgdGhlIGNhbGxlciBoYXMgcGVla2VkIGFoZWFkIGZvciB0aGUgZmlyc3QgdGFnIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGFnTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcbiAgICAgICAgdGhpcy5idW1wKCk7IC8vIHRoZSBmaXJzdCB0YWcgbmFtZSBjaGFyYWN0ZXJcbiAgICAgICAgd2hpbGUgKCF0aGlzLmlzRU9GKCkgJiYgX2lzUG90ZW50aWFsRWxlbWVudE5hbWVDaGFyKHRoaXMuY2hhcigpKSkge1xuICAgICAgICAgICAgdGhpcy5idW1wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZS5zbGljZShzdGFydE9mZnNldCwgdGhpcy5vZmZzZXQoKSk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGl0ZXJhbCA9IGZ1bmN0aW9uIChuZXN0aW5nTGV2ZWwsIHBhcmVudEFyZ1R5cGUpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5jbG9uZVBvc2l0aW9uKCk7XG4gICAgICAgIHZhciB2YWx1ZSA9ICcnO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHBhcnNlUXVvdGVSZXN1bHQgPSB0aGlzLnRyeVBhcnNlUXVvdGUocGFyZW50QXJnVHlwZSk7XG4gICAgICAgICAgICBpZiAocGFyc2VRdW90ZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IHBhcnNlUXVvdGVSZXN1bHQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFyc2VVbnF1b3RlZFJlc3VsdCA9IHRoaXMudHJ5UGFyc2VVbnF1b3RlZChuZXN0aW5nTGV2ZWwsIHBhcmVudEFyZ1R5cGUpO1xuICAgICAgICAgICAgaWYgKHBhcnNlVW5xdW90ZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBwYXJzZVVucXVvdGVkUmVzdWx0O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcnNlTGVmdEFuZ2xlUmVzdWx0ID0gdGhpcy50cnlQYXJzZUxlZnRBbmdsZUJyYWNrZXQoKTtcbiAgICAgICAgICAgIGlmIChwYXJzZUxlZnRBbmdsZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IHBhcnNlTGVmdEFuZ2xlUmVzdWx0O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhcnQsIHRoaXMuY2xvbmVQb3NpdGlvbigpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbDogeyB0eXBlOiBUWVBFLmxpdGVyYWwsIHZhbHVlOiB2YWx1ZSwgbG9jYXRpb246IGxvY2F0aW9uIH0sXG4gICAgICAgICAgICBlcnI6IG51bGwsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnRyeVBhcnNlTGVmdEFuZ2xlQnJhY2tldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRU9GKCkgJiZcbiAgICAgICAgICAgIHRoaXMuY2hhcigpID09PSA2MCAvKiBgPGAgKi8gJiZcbiAgICAgICAgICAgICh0aGlzLmlnbm9yZVRhZyB8fFxuICAgICAgICAgICAgICAgIC8vIElmIGF0IHRoZSBvcGVuaW5nIHRhZyBvciBjbG9zaW5nIHRhZyBwb3NpdGlvbiwgYmFpbC5cbiAgICAgICAgICAgICAgICAhX2lzQWxwaGFPclNsYXNoKHRoaXMucGVlaygpIHx8IDApKSkge1xuICAgICAgICAgICAgdGhpcy5idW1wKCk7IC8vIGA8YFxuICAgICAgICAgICAgcmV0dXJuICc8JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0aW5nIHdpdGggSUNVIDQuOCwgYW4gQVNDSUkgYXBvc3Ryb3BoZSBvbmx5IHN0YXJ0cyBxdW90ZWQgdGV4dCBpZiBpdCBpbW1lZGlhdGVseSBwcmVjZWRlc1xuICAgICAqIGEgY2hhcmFjdGVyIHRoYXQgcmVxdWlyZXMgcXVvdGluZyAodGhhdCBpcywgXCJvbmx5IHdoZXJlIG5lZWRlZFwiKSwgYW5kIHdvcmtzIHRoZSBzYW1lIGluXG4gICAgICogbmVzdGVkIG1lc3NhZ2VzIGFzIG9uIHRoZSB0b3AgbGV2ZWwgb2YgdGhlIHBhdHRlcm4uIFRoZSBuZXcgYmVoYXZpb3IgaXMgb3RoZXJ3aXNlIGNvbXBhdGlibGUuXG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS50cnlQYXJzZVF1b3RlID0gZnVuY3Rpb24gKHBhcmVudEFyZ1R5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFT0YoKSB8fCB0aGlzLmNoYXIoKSAhPT0gMzkgLyogYCdgICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJzZSBlc2NhcGVkIGNoYXIgZm9sbG93aW5nIHRoZSBhcG9zdHJvcGhlLCBvciBlYXJseSByZXR1cm4gaWYgdGhlcmUgaXMgbm8gZXNjYXBlZCBjaGFyLlxuICAgICAgICAvLyBDaGVjayBpZiBpcyB2YWxpZCBlc2NhcGVkIGNoYXJhY3RlclxuICAgICAgICBzd2l0Y2ggKHRoaXMucGVlaygpKSB7XG4gICAgICAgICAgICBjYXNlIDM5IC8qIGAnYCAqLzpcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUgcXVvdGUsIHNob3VsZCByZXR1cm4gYXMgYSBzaW5nbGUgcXVvdGUuXG4gICAgICAgICAgICAgICAgdGhpcy5idW1wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5idW1wKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiJ1wiO1xuICAgICAgICAgICAgLy8gJ3snLCAnPCcsICc+JywgJ30nXG4gICAgICAgICAgICBjYXNlIDEyMzpcbiAgICAgICAgICAgIGNhc2UgNjA6XG4gICAgICAgICAgICBjYXNlIDYyOlxuICAgICAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM1OiAvLyAnIydcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50QXJnVHlwZSA9PT0gJ3BsdXJhbCcgfHwgcGFyZW50QXJnVHlwZSA9PT0gJ3NlbGVjdG9yZGluYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idW1wKCk7IC8vIGFwb3N0cm9waGVcbiAgICAgICAgdmFyIGNvZGVQb2ludHMgPSBbdGhpcy5jaGFyKCldOyAvLyBlc2NhcGVkIGNoYXJcbiAgICAgICAgdGhpcy5idW1wKCk7XG4gICAgICAgIC8vIHJlYWQgY2hhcnMgdW50aWwgdGhlIG9wdGlvbmFsIGNsb3NpbmcgYXBvc3Ryb3BoZSBpcyBmb3VuZFxuICAgICAgICB3aGlsZSAoIXRoaXMuaXNFT0YoKSkge1xuICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5jaGFyKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDM5IC8qIGAnYCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gMzkgLyogYCdgICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludHMucHVzaCgzOSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1bXAgb25lIG1vcmUgdGltZSBiZWNhdXNlIHdlIG5lZWQgdG8gc2tpcCAyIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVtcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW9uYWwgY2xvc2luZyBhcG9zdHJvcGhlLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1bXAoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50cy5wdXNoKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVtcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50LmFwcGx5KHZvaWQgMCwgY29kZVBvaW50cyk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnRyeVBhcnNlVW5xdW90ZWQgPSBmdW5jdGlvbiAobmVzdGluZ0xldmVsLCBwYXJlbnRBcmdUeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRU9GKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaCA9IHRoaXMuY2hhcigpO1xuICAgICAgICBpZiAoY2ggPT09IDYwIC8qIGA8YCAqLyB8fFxuICAgICAgICAgICAgY2ggPT09IDEyMyAvKiBge2AgKi8gfHxcbiAgICAgICAgICAgIChjaCA9PT0gMzUgLyogYCNgICovICYmXG4gICAgICAgICAgICAgICAgKHBhcmVudEFyZ1R5cGUgPT09ICdwbHVyYWwnIHx8IHBhcmVudEFyZ1R5cGUgPT09ICdzZWxlY3RvcmRpbmFsJykpIHx8XG4gICAgICAgICAgICAoY2ggPT09IDEyNSAvKiBgfWAgKi8gJiYgbmVzdGluZ0xldmVsID4gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idW1wKCk7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjaCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBcmd1bWVudCA9IGZ1bmN0aW9uIChuZXN0aW5nTGV2ZWwsIGV4cGVjdGluZ0Nsb3NlVGFnKSB7XG4gICAgICAgIHZhciBvcGVuaW5nQnJhY2VQb3NpdGlvbiA9IHRoaXMuY2xvbmVQb3NpdGlvbigpO1xuICAgICAgICB0aGlzLmJ1bXAoKTsgLy8gYHtgXG4gICAgICAgIHRoaXMuYnVtcFNwYWNlKCk7XG4gICAgICAgIGlmICh0aGlzLmlzRU9GKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKEVycm9yS2luZC5FWFBFQ1RfQVJHVU1FTlRfQ0xPU0lOR19CUkFDRSwgY3JlYXRlTG9jYXRpb24ob3BlbmluZ0JyYWNlUG9zaXRpb24sIHRoaXMuY2xvbmVQb3NpdGlvbigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hhcigpID09PSAxMjUgLyogYH1gICovKSB7XG4gICAgICAgICAgICB0aGlzLmJ1bXAoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKEVycm9yS2luZC5FTVBUWV9BUkdVTUVOVCwgY3JlYXRlTG9jYXRpb24ob3BlbmluZ0JyYWNlUG9zaXRpb24sIHRoaXMuY2xvbmVQb3NpdGlvbigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXJndW1lbnQgbmFtZVxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnBhcnNlSWRlbnRpZmllcklmUG9zc2libGUoKS52YWx1ZTtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoRXJyb3JLaW5kLk1BTEZPUk1FRF9BUkdVTUVOVCwgY3JlYXRlTG9jYXRpb24ob3BlbmluZ0JyYWNlUG9zaXRpb24sIHRoaXMuY2xvbmVQb3NpdGlvbigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idW1wU3BhY2UoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNFT0YoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoRXJyb3JLaW5kLkVYUEVDVF9BUkdVTUVOVF9DTE9TSU5HX0JSQUNFLCBjcmVhdGVMb2NhdGlvbihvcGVuaW5nQnJhY2VQb3NpdGlvbiwgdGhpcy5jbG9uZVBvc2l0aW9uKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMuY2hhcigpKSB7XG4gICAgICAgICAgICAvLyBTaW1wbGUgYXJndW1lbnQ6IGB7bmFtZX1gXG4gICAgICAgICAgICBjYXNlIDEyNSAvKiBgfWAgKi86IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1bXAoKTsgLy8gYH1gXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFLmFyZ3VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgZG9lcyBub3QgaW5jbHVkZSB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyBicmFjZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogY3JlYXRlTG9jYXRpb24ob3BlbmluZ0JyYWNlUG9zaXRpb24sIHRoaXMuY2xvbmVQb3NpdGlvbigpKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcmd1bWVudCB3aXRoIG9wdGlvbnM6IGB7bmFtZSwgZm9ybWF0LCAuLi59YFxuICAgICAgICAgICAgY2FzZSA0NCAvKiBgLGAgKi86IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1bXAoKTsgLy8gYCxgXG4gICAgICAgICAgICAgICAgdGhpcy5idW1wU3BhY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0VPRigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKEVycm9yS2luZC5FWFBFQ1RfQVJHVU1FTlRfQ0xPU0lOR19CUkFDRSwgY3JlYXRlTG9jYXRpb24ob3BlbmluZ0JyYWNlUG9zaXRpb24sIHRoaXMuY2xvbmVQb3NpdGlvbigpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJndW1lbnRPcHRpb25zKG5lc3RpbmdMZXZlbCwgZXhwZWN0aW5nQ2xvc2VUYWcsIHZhbHVlLCBvcGVuaW5nQnJhY2VQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKEVycm9yS2luZC5NQUxGT1JNRURfQVJHVU1FTlQsIGNyZWF0ZUxvY2F0aW9uKG9wZW5pbmdCcmFjZVBvc2l0aW9uLCB0aGlzLmNsb25lUG9zaXRpb24oKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZHZhbmNlIHRoZSBwYXJzZXIgdW50aWwgdGhlIGVuZCBvZiB0aGUgaWRlbnRpZmllciwgaWYgaXQgaXMgY3VycmVudGx5IG9uXG4gICAgICogYW4gaWRlbnRpZmllciBjaGFyYWN0ZXIuIFJldHVybiBhbiBlbXB0eSBzdHJpbmcgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJZGVudGlmaWVySWZQb3NzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXJ0aW5nUG9zaXRpb24gPSB0aGlzLmNsb25lUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcbiAgICAgICAgdmFyIHZhbHVlID0gbWF0Y2hJZGVudGlmaWVyQXRJbmRleCh0aGlzLm1lc3NhZ2UsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgdmFyIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICB0aGlzLmJ1bXBUbyhlbmRPZmZzZXQpO1xuICAgICAgICB2YXIgZW5kUG9zaXRpb24gPSB0aGlzLmNsb25lUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhcnRpbmdQb3NpdGlvbiwgZW5kUG9zaXRpb24pO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGxvY2F0aW9uOiBsb2NhdGlvbiB9O1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFyZ3VtZW50T3B0aW9ucyA9IGZ1bmN0aW9uIChuZXN0aW5nTGV2ZWwsIGV4cGVjdGluZ0Nsb3NlVGFnLCB2YWx1ZSwgb3BlbmluZ0JyYWNlUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBQYXJzZSB0aGlzIHJhbmdlOlxuICAgICAgICAvLyB7bmFtZSwgdHlwZSwgc3R5bGV9XG4gICAgICAgIC8vICAgICAgICBeLS0tXlxuICAgICAgICB2YXIgdHlwZVN0YXJ0UG9zaXRpb24gPSB0aGlzLmNsb25lUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGFyZ1R5cGUgPSB0aGlzLnBhcnNlSWRlbnRpZmllcklmUG9zc2libGUoKS52YWx1ZTtcbiAgICAgICAgdmFyIHR5cGVFbmRQb3NpdGlvbiA9IHRoaXMuY2xvbmVQb3NpdGlvbigpO1xuICAgICAgICBzd2l0Y2ggKGFyZ1R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICAgICAgLy8gRXhwZWN0aW5nIGEgc3R5bGUgc3RyaW5nIG51bWJlciwgZGF0ZSwgdGltZSwgcGx1cmFsLCBzZWxlY3RvcmRpbmFsLCBvciBzZWxlY3QuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoRXJyb3JLaW5kLkVYUEVDVF9BUkdVTUVOVF9UWVBFLCBjcmVhdGVMb2NhdGlvbih0eXBlU3RhcnRQb3NpdGlvbiwgdHlwZUVuZFBvc2l0aW9uKSk7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICBjYXNlICd0aW1lJzoge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoaXMgcmFuZ2U6XG4gICAgICAgICAgICAgICAgLy8ge25hbWUsIG51bWJlciwgc3R5bGV9XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgIF4tLS0tLS0tXlxuICAgICAgICAgICAgICAgIHRoaXMuYnVtcFNwYWNlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlQW5kTG9jYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJ1bXBJZignLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVtcFNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZVN0YXJ0UG9zaXRpb24gPSB0aGlzLmNsb25lUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VTaW1wbGVBcmdTdHlsZUlmUG9zc2libGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gdHJpbUVuZChyZXN1bHQudmFsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoRXJyb3JLaW5kLkVYUEVDVF9BUkdVTUVOVF9TVFlMRSwgY3JlYXRlTG9jYXRpb24odGhpcy5jbG9uZVBvc2l0aW9uKCksIHRoaXMuY2xvbmVQb3NpdGlvbigpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlTG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihzdHlsZVN0YXJ0UG9zaXRpb24sIHRoaXMuY2xvbmVQb3NpdGlvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVBbmRMb2NhdGlvbiA9IHsgc3R5bGU6IHN0eWxlLCBzdHlsZUxvY2F0aW9uOiBzdHlsZUxvY2F0aW9uIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhcmdDbG9zZVJlc3VsdCA9IHRoaXMudHJ5UGFyc2VBcmd1bWVudENsb3NlKG9wZW5pbmdCcmFjZVBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnQ2xvc2VSZXN1bHQuZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdDbG9zZVJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uXzEgPSBjcmVhdGVMb2NhdGlvbihvcGVuaW5nQnJhY2VQb3NpdGlvbiwgdGhpcy5jbG9uZVBvc2l0aW9uKCkpO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3Qgc3R5bGUgb3Igc2tlbGV0b25cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVBbmRMb2NhdGlvbiAmJiBzdGFydHNXaXRoKHN0eWxlQW5kTG9jYXRpb24gPT09IG51bGwgfHwgc3R5bGVBbmRMb2NhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGVBbmRMb2NhdGlvbi5zdHlsZSwgJzo6JywgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tlbGV0b24gc3RhcnRzIHdpdGggYDo6YC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNrZWxldG9uID0gdHJpbVN0YXJ0KHN0eWxlQW5kTG9jYXRpb24uc3R5bGUuc2xpY2UoMikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlTnVtYmVyU2tlbGV0b25Gcm9tU3RyaW5nKHNrZWxldG9uLCBzdHlsZUFuZExvY2F0aW9uLnN0eWxlTG9jYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw6IHsgdHlwZTogVFlQRS5udW1iZXIsIHZhbHVlOiB2YWx1ZSwgbG9jYXRpb246IGxvY2F0aW9uXzEsIHN0eWxlOiByZXN1bHQudmFsIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChza2VsZXRvbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihFcnJvcktpbmQuRVhQRUNUX0RBVEVfVElNRV9TS0VMRVRPTiwgbG9jYXRpb25fMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0ZVRpbWVQYXR0ZXJuID0gc2tlbGV0b247XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgXCJiZXN0IG1hdGNoXCIgcGF0dGVybiBvbmx5IGlmIGxvY2FsZSBpcyBwYXNzZWQsIGlmIG5vdCwgbGV0IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXNzIGFzLWlzIHdoZXJlIGBwYXJzZURhdGVUaW1lU2tlbGV0b24oKWAgd2lsbCB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHVuc3VwcG9ydGVkIHBhdHRlcm5zLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZVRpbWVQYXR0ZXJuID0gZ2V0QmVzdFBhdHRlcm4oc2tlbGV0b24sIHRoaXMubG9jYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTS0VMRVRPTl9UWVBFLmRhdGVUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGRhdGVUaW1lUGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogc3R5bGVBbmRMb2NhdGlvbi5zdHlsZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZE9wdGlvbnM6IHRoaXMuc2hvdWxkUGFyc2VTa2VsZXRvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXJzZURhdGVUaW1lU2tlbGV0b24oZGF0ZVRpbWVQYXR0ZXJuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gYXJnVHlwZSA9PT0gJ2RhdGUnID8gVFlQRS5kYXRlIDogVFlQRS50aW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw6IHsgdHlwZTogdHlwZSwgdmFsdWU6IHZhbHVlLCBsb2NhdGlvbjogbG9jYXRpb25fMSwgc3R5bGU6IHN0eWxlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWd1bGFyIHN0eWxlIG9yIG5vIHN0eWxlLlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYXJnVHlwZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFRZUEUubnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhcmdUeXBlID09PSAnZGF0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBUWVBFLmRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBUWVBFLnRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25fMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAoX2EgPSBzdHlsZUFuZExvY2F0aW9uID09PSBudWxsIHx8IHN0eWxlQW5kTG9jYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0eWxlQW5kTG9jYXRpb24uc3R5bGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycjogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAncGx1cmFsJzpcbiAgICAgICAgICAgIGNhc2UgJ3NlbGVjdG9yZGluYWwnOlxuICAgICAgICAgICAgY2FzZSAnc2VsZWN0Jzoge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoaXMgcmFuZ2U6XG4gICAgICAgICAgICAgICAgLy8ge25hbWUsIHBsdXJhbCwgb3B0aW9uc31cbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgXi0tLS0tLS0tLV5cbiAgICAgICAgICAgICAgICB2YXIgdHlwZUVuZFBvc2l0aW9uXzEgPSB0aGlzLmNsb25lUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1bXBTcGFjZSgpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5idW1wSWYoJywnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihFcnJvcktpbmQuRVhQRUNUX1NFTEVDVF9BUkdVTUVOVF9PUFRJT05TLCBjcmVhdGVMb2NhdGlvbih0eXBlRW5kUG9zaXRpb25fMSwgX19hc3NpZ24oe30sIHR5cGVFbmRQb3NpdGlvbl8xKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJ1bXBTcGFjZSgpO1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG9mZnNldDpcbiAgICAgICAgICAgICAgICAvLyB7bmFtZSwgcGx1cmFsLCBvZmZzZXQ6MSwgb3B0aW9uc31cbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBeLS0tLS1eXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBvciB0aGUgZmlyc3Qgb3B0aW9uOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8ge25hbWUsIHBsdXJhbCwgb25lIHsuLi59IG90aGVyIHsuLi59fVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIF4tLV5cbiAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllckFuZExvY2F0aW9uID0gdGhpcy5wYXJzZUlkZW50aWZpZXJJZlBvc3NpYmxlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBsdXJhbE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ1R5cGUgIT09ICdzZWxlY3QnICYmIGlkZW50aWZpZXJBbmRMb2NhdGlvbi52YWx1ZSA9PT0gJ29mZnNldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJ1bXBJZignOicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihFcnJvcktpbmQuRVhQRUNUX1BMVVJBTF9BUkdVTUVOVF9PRkZTRVRfVkFMVUUsIGNyZWF0ZUxvY2F0aW9uKHRoaXMuY2xvbmVQb3NpdGlvbigpLCB0aGlzLmNsb25lUG9zaXRpb24oKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVtcFNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnRyeVBhcnNlRGVjaW1hbEludGVnZXIoRXJyb3JLaW5kLkVYUEVDVF9QTFVSQUxfQVJHVU1FTlRfT0ZGU0VUX1ZBTFVFLCBFcnJvcktpbmQuSU5WQUxJRF9QTFVSQUxfQVJHVU1FTlRfT0ZGU0VUX1ZBTFVFKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgYW5vdGhlciBpZGVudGlmaWVyIGZvciBvcHRpb24gcGFyc2luZ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1bXBTcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyQW5kTG9jYXRpb24gPSB0aGlzLnBhcnNlSWRlbnRpZmllcklmUG9zc2libGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcGx1cmFsT2Zmc2V0ID0gcmVzdWx0LnZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnNSZXN1bHQgPSB0aGlzLnRyeVBhcnNlUGx1cmFsT3JTZWxlY3RPcHRpb25zKG5lc3RpbmdMZXZlbCwgYXJnVHlwZSwgZXhwZWN0aW5nQ2xvc2VUYWcsIGlkZW50aWZpZXJBbmRMb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNSZXN1bHQuZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zUmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYXJnQ2xvc2VSZXN1bHQgPSB0aGlzLnRyeVBhcnNlQXJndW1lbnRDbG9zZShvcGVuaW5nQnJhY2VQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ0Nsb3NlUmVzdWx0LmVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnQ2xvc2VSZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbl8yID0gY3JlYXRlTG9jYXRpb24ob3BlbmluZ0JyYWNlUG9zaXRpb24sIHRoaXMuY2xvbmVQb3NpdGlvbigpKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnVHlwZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRZUEUuc2VsZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBmcm9tRW50cmllcyhvcHRpb25zUmVzdWx0LnZhbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXzIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRZUEUucGx1cmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBmcm9tRW50cmllcyhvcHRpb25zUmVzdWx0LnZhbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwbHVyYWxPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1cmFsVHlwZTogYXJnVHlwZSA9PT0gJ3BsdXJhbCcgPyAnY2FyZGluYWwnIDogJ29yZGluYWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbl8yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKEVycm9yS2luZC5JTlZBTElEX0FSR1VNRU5UX1RZUEUsIGNyZWF0ZUxvY2F0aW9uKHR5cGVTdGFydFBvc2l0aW9uLCB0eXBlRW5kUG9zaXRpb24pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS50cnlQYXJzZUFyZ3VtZW50Q2xvc2UgPSBmdW5jdGlvbiAob3BlbmluZ0JyYWNlUG9zaXRpb24pIHtcbiAgICAgICAgLy8gUGFyc2U6IHt2YWx1ZSwgbnVtYmVyLCA6OmN1cnJlbmN5L0dCUCB9XG4gICAgICAgIC8vXG4gICAgICAgIGlmICh0aGlzLmlzRU9GKCkgfHwgdGhpcy5jaGFyKCkgIT09IDEyNSAvKiBgfWAgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKEVycm9yS2luZC5FWFBFQ1RfQVJHVU1FTlRfQ0xPU0lOR19CUkFDRSwgY3JlYXRlTG9jYXRpb24ob3BlbmluZ0JyYWNlUG9zaXRpb24sIHRoaXMuY2xvbmVQb3NpdGlvbigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idW1wKCk7IC8vIGB9YFxuICAgICAgICByZXR1cm4geyB2YWw6IHRydWUsIGVycjogbnVsbCB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdW5pY29kZS1vcmcvaWN1L2Jsb2IvYWY3ZWQxZjZkMjI5ODAxM2RjMzAzNjI4NDM4ZWM0YWJlMWYxNjQ3OS9pY3U0Yy9zb3VyY2UvY29tbW9uL21lc3NhZ2VwYXR0ZXJuLmNwcCNMNjU5XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNpbXBsZUFyZ1N0eWxlSWZQb3NzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5lc3RlZEJyYWNlcyA9IDA7XG4gICAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gdGhpcy5jbG9uZVBvc2l0aW9uKCk7XG4gICAgICAgIHdoaWxlICghdGhpcy5pc0VPRigpKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSB0aGlzLmNoYXIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDM5IC8qIGAnYCAqLzoge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcmVhdCBhcG9zdHJvcGhlIGFzIHF1b3RpbmcgYnV0IGluY2x1ZGUgaXQgaW4gdGhlIHN0eWxlIHBhcnQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGVuZCBvZiB0aGUgcXVvdGVkIGxpdGVyYWwgdGV4dC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idW1wKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcG9zdHJvcGhlUG9zaXRpb24gPSB0aGlzLmNsb25lUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJ1bXBVbnRpbChcIidcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKEVycm9yS2luZC5VTkNMT1NFRF9RVU9URV9JTl9BUkdVTUVOVF9TVFlMRSwgY3JlYXRlTG9jYXRpb24oYXBvc3Ryb3BoZVBvc2l0aW9uLCB0aGlzLmNsb25lUG9zaXRpb24oKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVtcCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAxMjMgLyogYHtgICovOiB7XG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZEJyYWNlcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1bXAoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTI1IC8qIGB9YCAqLzoge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVzdGVkQnJhY2VzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkQnJhY2VzIC09IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbDogdGhpcy5tZXNzYWdlLnNsaWNlKHN0YXJ0UG9zaXRpb24ub2Zmc2V0LCB0aGlzLm9mZnNldCgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1bXAoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbDogdGhpcy5tZXNzYWdlLnNsaWNlKHN0YXJ0UG9zaXRpb24ub2Zmc2V0LCB0aGlzLm9mZnNldCgpKSxcbiAgICAgICAgICAgIGVycjogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VOdW1iZXJTa2VsZXRvbkZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc2tlbGV0b24sIGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRva2VucyA9IHBhcnNlTnVtYmVyU2tlbGV0b25Gcm9tU3RyaW5nKHNrZWxldG9uKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoRXJyb3JLaW5kLklOVkFMSURfTlVNQkVSX1NLRUxFVE9OLCBsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFNLRUxFVE9OX1RZUEUubnVtYmVyLFxuICAgICAgICAgICAgICAgIHRva2VuczogdG9rZW5zLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICBwYXJzZWRPcHRpb25zOiB0aGlzLnNob3VsZFBhcnNlU2tlbGV0b25zXG4gICAgICAgICAgICAgICAgICAgID8gcGFyc2VOdW1iZXJTa2VsZXRvbih0b2tlbnMpXG4gICAgICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyOiBudWxsLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG5lc3RpbmdfbGV2ZWwgVGhlIGN1cnJlbnQgbmVzdGluZyBsZXZlbCBvZiBtZXNzYWdlcy5cbiAgICAgKiAgICAgVGhpcyBjYW4gYmUgcG9zaXRpdmUgd2hlbiBwYXJzaW5nIG1lc3NhZ2UgZnJhZ21lbnQgaW4gc2VsZWN0IG9yIHBsdXJhbCBhcmd1bWVudCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBwYXJlbnRfYXJnX3R5cGUgVGhlIHBhcmVudCBhcmd1bWVudCdzIHR5cGUuXG4gICAgICogQHBhcmFtIHBhcnNlZF9maXJzdF9pZGVudGlmaWVyIElmIHByb3ZpZGVkLCB0aGlzIGlzIHRoZSBmaXJzdCBpZGVudGlmaWVyLWxpa2Ugc2VsZWN0b3Igb2ZcbiAgICAgKiAgICAgdGhlIGFyZ3VtZW50LiBJdCBpcyBhIGJ5LXByb2R1Y3Qgb2YgYSBwcmV2aW91cyBwYXJzaW5nIGF0dGVtcHQuXG4gICAgICogQHBhcmFtIGV4cGVjdGluZ19jbG9zZV90YWcgSWYgdHJ1ZSwgdGhpcyBtZXNzYWdlIGlzIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgbmVzdGVkIGluc2lkZVxuICAgICAqICAgICBiZXR3ZWVuIGEgcGFpciBvZiBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3MuIFRoZSBuZXN0ZWQgbWVzc2FnZSB3aWxsIG5vdCBwYXJzZSBiZXlvbmRcbiAgICAgKiAgICAgdGhlIGNsb3NpbmcgdGFnIGJvdW5kYXJ5LlxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUudHJ5UGFyc2VQbHVyYWxPclNlbGVjdE9wdGlvbnMgPSBmdW5jdGlvbiAobmVzdGluZ0xldmVsLCBwYXJlbnRBcmdUeXBlLCBleHBlY3RDbG9zZVRhZywgcGFyc2VkRmlyc3RJZGVudGlmaWVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGhhc090aGVyQ2xhdXNlID0gZmFsc2U7XG4gICAgICAgIHZhciBvcHRpb25zID0gW107XG4gICAgICAgIHZhciBwYXJzZWRTZWxlY3RvcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHBhcnNlZEZpcnN0SWRlbnRpZmllci52YWx1ZSwgc2VsZWN0b3JMb2NhdGlvbiA9IHBhcnNlZEZpcnN0SWRlbnRpZmllci5sb2NhdGlvbjtcbiAgICAgICAgLy8gUGFyc2U6XG4gICAgICAgIC8vIG9uZSB7b25lIGFwcGxlfVxuICAgICAgICAvLyBeLS1eXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0b3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0UG9zaXRpb24gPSB0aGlzLmNsb25lUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50QXJnVHlwZSAhPT0gJ3NlbGVjdCcgJiYgdGhpcy5idW1wSWYoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgcGFyc2UgYD17bnVtYmVyfWAgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMudHJ5UGFyc2VEZWNpbWFsSW50ZWdlcihFcnJvcktpbmQuRVhQRUNUX1BMVVJBTF9BUkdVTUVOVF9TRUxFQ1RPUiwgRXJyb3JLaW5kLklOVkFMSURfUExVUkFMX0FSR1VNRU5UX1NFTEVDVE9SKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXJ0UG9zaXRpb24sIHRoaXMuY2xvbmVQb3NpdGlvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB0aGlzLm1lc3NhZ2Uuc2xpY2Uoc3RhcnRQb3NpdGlvbi5vZmZzZXQsIHRoaXMub2Zmc2V0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRHVwbGljYXRlIHNlbGVjdG9yIGNsYXVzZXNcbiAgICAgICAgICAgIGlmIChwYXJzZWRTZWxlY3RvcnMuaGFzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKHBhcmVudEFyZ1R5cGUgPT09ICdzZWxlY3QnXG4gICAgICAgICAgICAgICAgICAgID8gRXJyb3JLaW5kLkRVUExJQ0FURV9TRUxFQ1RfQVJHVU1FTlRfU0VMRUNUT1JcbiAgICAgICAgICAgICAgICAgICAgOiBFcnJvcktpbmQuRFVQTElDQVRFX1BMVVJBTF9BUkdVTUVOVF9TRUxFQ1RPUiwgc2VsZWN0b3JMb2NhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09ICdvdGhlcicpIHtcbiAgICAgICAgICAgICAgICBoYXNPdGhlckNsYXVzZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZTpcbiAgICAgICAgICAgIC8vIG9uZSB7b25lIGFwcGxlfVxuICAgICAgICAgICAgLy8gICAgIF4tLS0tLS0tLS0tXlxuICAgICAgICAgICAgdGhpcy5idW1wU3BhY2UoKTtcbiAgICAgICAgICAgIHZhciBvcGVuaW5nQnJhY2VQb3NpdGlvbiA9IHRoaXMuY2xvbmVQb3NpdGlvbigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmJ1bXBJZigneycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IocGFyZW50QXJnVHlwZSA9PT0gJ3NlbGVjdCdcbiAgICAgICAgICAgICAgICAgICAgPyBFcnJvcktpbmQuRVhQRUNUX1NFTEVDVF9BUkdVTUVOVF9TRUxFQ1RPUl9GUkFHTUVOVFxuICAgICAgICAgICAgICAgICAgICA6IEVycm9yS2luZC5FWFBFQ1RfUExVUkFMX0FSR1VNRU5UX1NFTEVDVE9SX0ZSQUdNRU5ULCBjcmVhdGVMb2NhdGlvbih0aGlzLmNsb25lUG9zaXRpb24oKSwgdGhpcy5jbG9uZVBvc2l0aW9uKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmcmFnbWVudFJlc3VsdCA9IHRoaXMucGFyc2VNZXNzYWdlKG5lc3RpbmdMZXZlbCArIDEsIHBhcmVudEFyZ1R5cGUsIGV4cGVjdENsb3NlVGFnKTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudFJlc3VsdC5lcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJnQ2xvc2VSZXN1bHQgPSB0aGlzLnRyeVBhcnNlQXJndW1lbnRDbG9zZShvcGVuaW5nQnJhY2VQb3NpdGlvbik7XG4gICAgICAgICAgICBpZiAoYXJnQ2xvc2VSZXN1bHQuZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ0Nsb3NlUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKFtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmcmFnbWVudFJlc3VsdC52YWwsXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvbihvcGVuaW5nQnJhY2VQb3NpdGlvbiwgdGhpcy5jbG9uZVBvc2l0aW9uKCkpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGV4aXN0aW5nIHNlbGVjdG9yc1xuICAgICAgICAgICAgcGFyc2VkU2VsZWN0b3JzLmFkZChzZWxlY3Rvcik7XG4gICAgICAgICAgICAvLyBQcmVwIG5leHQgc2VsZWN0b3IgY2xhdXNlLlxuICAgICAgICAgICAgdGhpcy5idW1wU3BhY2UoKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMucGFyc2VJZGVudGlmaWVySWZQb3NzaWJsZSgpLCBzZWxlY3RvciA9IF9hLnZhbHVlLCBzZWxlY3RvckxvY2F0aW9uID0gX2EubG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IocGFyZW50QXJnVHlwZSA9PT0gJ3NlbGVjdCdcbiAgICAgICAgICAgICAgICA/IEVycm9yS2luZC5FWFBFQ1RfU0VMRUNUX0FSR1VNRU5UX1NFTEVDVE9SXG4gICAgICAgICAgICAgICAgOiBFcnJvcktpbmQuRVhQRUNUX1BMVVJBTF9BUkdVTUVOVF9TRUxFQ1RPUiwgY3JlYXRlTG9jYXRpb24odGhpcy5jbG9uZVBvc2l0aW9uKCksIHRoaXMuY2xvbmVQb3NpdGlvbigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVxdWlyZXNPdGhlckNsYXVzZSAmJiAhaGFzT3RoZXJDbGF1c2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKEVycm9yS2luZC5NSVNTSU5HX09USEVSX0NMQVVTRSwgY3JlYXRlTG9jYXRpb24odGhpcy5jbG9uZVBvc2l0aW9uKCksIHRoaXMuY2xvbmVQb3NpdGlvbigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsOiBvcHRpb25zLCBlcnI6IG51bGwgfTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUudHJ5UGFyc2VEZWNpbWFsSW50ZWdlciA9IGZ1bmN0aW9uIChleHBlY3ROdW1iZXJFcnJvciwgaW52YWxpZE51bWJlckVycm9yKSB7XG4gICAgICAgIHZhciBzaWduID0gMTtcbiAgICAgICAgdmFyIHN0YXJ0aW5nUG9zaXRpb24gPSB0aGlzLmNsb25lUG9zaXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuYnVtcElmKCcrJykpIHtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmJ1bXBJZignLScpKSB7XG4gICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc0RpZ2l0cyA9IGZhbHNlO1xuICAgICAgICB2YXIgZGVjaW1hbCA9IDA7XG4gICAgICAgIHdoaWxlICghdGhpcy5pc0VPRigpKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSB0aGlzLmNoYXIoKTtcbiAgICAgICAgICAgIGlmIChjaCA+PSA0OCAvKiBgMGAgKi8gJiYgY2ggPD0gNTcgLyogYDlgICovKSB7XG4gICAgICAgICAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkZWNpbWFsID0gZGVjaW1hbCAqIDEwICsgKGNoIC0gNDgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVtcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhcnRpbmdQb3NpdGlvbiwgdGhpcy5jbG9uZVBvc2l0aW9uKCkpO1xuICAgICAgICBpZiAoIWhhc0RpZ2l0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoZXhwZWN0TnVtYmVyRXJyb3IsIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNpbWFsICo9IHNpZ247XG4gICAgICAgIGlmICghaXNTYWZlSW50ZWdlcihkZWNpbWFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoaW52YWxpZE51bWJlckVycm9yLCBsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsOiBkZWNpbWFsLCBlcnI6IG51bGwgfTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi5vZmZzZXQ7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLmlzRU9GID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQoKSA9PT0gdGhpcy5tZXNzYWdlLmxlbmd0aDtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuY2xvbmVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBtdWNoIGZhc3RlciB0aGFuIGBPYmplY3QuYXNzaWduYCBvciBzcHJlYWQuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMucG9zaXRpb24ub2Zmc2V0LFxuICAgICAgICAgICAgbGluZTogdGhpcy5wb3NpdGlvbi5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiB0aGlzLnBvc2l0aW9uLmNvbHVtbixcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY29kZSBwb2ludCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcGFyc2VyLlxuICAgICAqIFRocm93cyBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kLlxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuY2hhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMucG9zaXRpb24ub2Zmc2V0O1xuICAgICAgICBpZiAob2Zmc2V0ID49IHRoaXMubWVzc2FnZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdvdXQgb2YgYm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29kZSA9IGNvZGVQb2ludEF0KHRoaXMubWVzc2FnZSwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJPZmZzZXQgXCIuY29uY2F0KG9mZnNldCwgXCIgaXMgYXQgaW52YWxpZCBVVEYtMTYgY29kZSB1bml0IGJvdW5kYXJ5XCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoa2luZCwgbG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbDogbnVsbCxcbiAgICAgICAgICAgIGVycjoge1xuICAgICAgICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKiogQnVtcCB0aGUgcGFyc2VyIHRvIHRoZSBuZXh0IFVURi0xNiBjb2RlIHVuaXQuICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5idW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VPRigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvZGUgPSB0aGlzLmNoYXIoKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDEwIC8qICdcXG4nICovKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLmxpbmUgKz0gMTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24uY29sdW1uID0gMTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ub2Zmc2V0ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLmNvbHVtbiArPSAxO1xuICAgICAgICAgICAgLy8gMCB+IDB4MTAwMDAgLT4gdW5pY29kZSBCTVAsIG90aGVyd2lzZSBza2lwIHRoZSBzdXJyb2dhdGUgcGFpci5cbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ub2Zmc2V0ICs9IGNvZGUgPCAweDEwMDAwID8gMSA6IDI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBzdWJzdHJpbmcgc3RhcnRpbmcgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBhcnNlciBoYXNcbiAgICAgKiB0aGUgZ2l2ZW4gcHJlZml4LCB0aGVuIGJ1bXAgdGhlIHBhcnNlciB0byB0aGUgY2hhcmFjdGVyIGltbWVkaWF0ZWx5XG4gICAgICogZm9sbG93aW5nIHRoZSBwcmVmaXggYW5kIHJldHVybiB0cnVlLiBPdGhlcndpc2UsIGRvbid0IGJ1bXAgdGhlIHBhcnNlclxuICAgICAqIGFuZCByZXR1cm4gZmFsc2UuXG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5idW1wSWYgPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICAgIGlmIChzdGFydHNXaXRoKHRoaXMubWVzc2FnZSwgcHJlZml4LCB0aGlzLm9mZnNldCgpKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1bXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJ1bXAgdGhlIHBhcnNlciB1bnRpbCB0aGUgcGF0dGVybiBjaGFyYWN0ZXIgaXMgZm91bmQgYW5kIHJldHVybiBgdHJ1ZWAuXG4gICAgICogT3RoZXJ3aXNlIGJ1bXAgdG8gdGhlIGVuZCBvZiB0aGUgZmlsZSBhbmQgcmV0dXJuIGBmYWxzZWAuXG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5idW1wVW50aWwgPSBmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgICB2YXIgY3VycmVudE9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMubWVzc2FnZS5pbmRleE9mKHBhdHRlcm4sIGN1cnJlbnRPZmZzZXQpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5idW1wVG8oaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1bXBUbyh0aGlzLm1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQnVtcCB0aGUgcGFyc2VyIHRvIHRoZSB0YXJnZXQgb2Zmc2V0LlxuICAgICAqIElmIHRhcmdldCBvZmZzZXQgaXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LCBidW1wIHRoZSBwYXJzZXIgdG8gdGhlIGVuZCBvZiB0aGUgaW5wdXQuXG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5idW1wVG8gPSBmdW5jdGlvbiAodGFyZ2V0T2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLm9mZnNldCgpID4gdGFyZ2V0T2Zmc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcInRhcmdldE9mZnNldCBcIi5jb25jYXQodGFyZ2V0T2Zmc2V0LCBcIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgY3VycmVudCBvZmZzZXQgXCIpLmNvbmNhdCh0aGlzLm9mZnNldCgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0T2Zmc2V0ID0gTWF0aC5taW4odGFyZ2V0T2Zmc2V0LCB0aGlzLm1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gdGFyZ2V0T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gdGFyZ2V0T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJ0YXJnZXRPZmZzZXQgXCIuY29uY2F0KHRhcmdldE9mZnNldCwgXCIgaXMgYXQgaW52YWxpZCBVVEYtMTYgY29kZSB1bml0IGJvdW5kYXJ5XCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVtcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNFT0YoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogYWR2YW5jZSB0aGUgcGFyc2VyIHRocm91Z2ggYWxsIHdoaXRlc3BhY2UgdG8gdGhlIG5leHQgbm9uLXdoaXRlc3BhY2UgY29kZSB1bml0LiAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuYnVtcFNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAoIXRoaXMuaXNFT0YoKSAmJiBfaXNXaGl0ZVNwYWNlKHRoaXMuY2hhcigpKSkge1xuICAgICAgICAgICAgdGhpcy5idW1wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlZWsgYXQgdGhlICpuZXh0KiBVbmljb2RlIGNvZGVwb2ludCBpbiB0aGUgaW5wdXQgd2l0aG91dCBhZHZhbmNpbmcgdGhlIHBhcnNlci5cbiAgICAgKiBJZiB0aGUgaW5wdXQgaGFzIGJlZW4gZXhoYXVzdGVkLCB0aGVuIHRoaXMgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFT0YoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvZGUgPSB0aGlzLmNoYXIoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG4gICAgICAgIHZhciBuZXh0Q29kZSA9IHRoaXMubWVzc2FnZS5jaGFyQ29kZUF0KG9mZnNldCArIChjb2RlID49IDB4MTAwMDAgPyAyIDogMSkpO1xuICAgICAgICByZXR1cm4gbmV4dENvZGUgIT09IG51bGwgJiYgbmV4dENvZGUgIT09IHZvaWQgMCA/IG5leHRDb2RlIDogbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZXI7XG59KCkpO1xuZXhwb3J0IHsgUGFyc2VyIH07XG4vKipcbiAqIFRoaXMgY2hlY2sgaWYgY29kZXBvaW50IGlzIGFscGhhYmV0IChsb3dlciAmIHVwcGVyY2FzZSlcbiAqIEBwYXJhbSBjb2RlcG9pbnRcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIF9pc0FscGhhKGNvZGVwb2ludCkge1xuICAgIHJldHVybiAoKGNvZGVwb2ludCA+PSA5NyAmJiBjb2RlcG9pbnQgPD0gMTIyKSB8fFxuICAgICAgICAoY29kZXBvaW50ID49IDY1ICYmIGNvZGVwb2ludCA8PSA5MCkpO1xufVxuZnVuY3Rpb24gX2lzQWxwaGFPclNsYXNoKGNvZGVwb2ludCkge1xuICAgIHJldHVybiBfaXNBbHBoYShjb2RlcG9pbnQpIHx8IGNvZGVwb2ludCA9PT0gNDc7IC8qICcvJyAqL1xufVxuLyoqIFNlZSBgcGFyc2VUYWdgIGZ1bmN0aW9uIGRvY3MuICovXG5mdW5jdGlvbiBfaXNQb3RlbnRpYWxFbGVtZW50TmFtZUNoYXIoYykge1xuICAgIHJldHVybiAoYyA9PT0gNDUgLyogJy0nICovIHx8XG4gICAgICAgIGMgPT09IDQ2IC8qICcuJyAqLyB8fFxuICAgICAgICAoYyA+PSA0OCAmJiBjIDw9IDU3KSAvKiAwLi45ICovIHx8XG4gICAgICAgIGMgPT09IDk1IC8qICdfJyAqLyB8fFxuICAgICAgICAoYyA+PSA5NyAmJiBjIDw9IDEyMikgLyoqIGEuLnogKi8gfHxcbiAgICAgICAgKGMgPj0gNjUgJiYgYyA8PSA5MCkgLyogQS4uWiAqLyB8fFxuICAgICAgICBjID09IDB4YjcgfHxcbiAgICAgICAgKGMgPj0gMHhjMCAmJiBjIDw9IDB4ZDYpIHx8XG4gICAgICAgIChjID49IDB4ZDggJiYgYyA8PSAweGY2KSB8fFxuICAgICAgICAoYyA+PSAweGY4ICYmIGMgPD0gMHgzN2QpIHx8XG4gICAgICAgIChjID49IDB4MzdmICYmIGMgPD0gMHgxZmZmKSB8fFxuICAgICAgICAoYyA+PSAweDIwMGMgJiYgYyA8PSAweDIwMGQpIHx8XG4gICAgICAgIChjID49IDB4MjAzZiAmJiBjIDw9IDB4MjA0MCkgfHxcbiAgICAgICAgKGMgPj0gMHgyMDcwICYmIGMgPD0gMHgyMThmKSB8fFxuICAgICAgICAoYyA+PSAweDJjMDAgJiYgYyA8PSAweDJmZWYpIHx8XG4gICAgICAgIChjID49IDB4MzAwMSAmJiBjIDw9IDB4ZDdmZikgfHxcbiAgICAgICAgKGMgPj0gMHhmOTAwICYmIGMgPD0gMHhmZGNmKSB8fFxuICAgICAgICAoYyA+PSAweGZkZjAgJiYgYyA8PSAweGZmZmQpIHx8XG4gICAgICAgIChjID49IDB4MTAwMDAgJiYgYyA8PSAweGVmZmZmKSk7XG59XG4vKipcbiAqIENvZGUgcG9pbnQgZXF1aXZhbGVudCBvZiByZWdleCBgXFxwe1doaXRlX1NwYWNlfWAuXG4gKiBGcm9tOiBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvUHJvcExpc3QudHh0XG4gKi9cbmZ1bmN0aW9uIF9pc1doaXRlU3BhY2UoYykge1xuICAgIHJldHVybiAoKGMgPj0gMHgwMDA5ICYmIGMgPD0gMHgwMDBkKSB8fFxuICAgICAgICBjID09PSAweDAwMjAgfHxcbiAgICAgICAgYyA9PT0gMHgwMDg1IHx8XG4gICAgICAgIChjID49IDB4MjAwZSAmJiBjIDw9IDB4MjAwZikgfHxcbiAgICAgICAgYyA9PT0gMHgyMDI4IHx8XG4gICAgICAgIGMgPT09IDB4MjAyOSk7XG59XG4vKipcbiAqIENvZGUgcG9pbnQgZXF1aXZhbGVudCBvZiByZWdleCBgXFxwe1BhdHRlcm5fU3ludGF4fWAuXG4gKiBTZWUgaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL1Byb3BMaXN0LnR4dFxuICovXG5mdW5jdGlvbiBfaXNQYXR0ZXJuU3ludGF4KGMpIHtcbiAgICByZXR1cm4gKChjID49IDB4MDAyMSAmJiBjIDw9IDB4MDAyMykgfHxcbiAgICAgICAgYyA9PT0gMHgwMDI0IHx8XG4gICAgICAgIChjID49IDB4MDAyNSAmJiBjIDw9IDB4MDAyNykgfHxcbiAgICAgICAgYyA9PT0gMHgwMDI4IHx8XG4gICAgICAgIGMgPT09IDB4MDAyOSB8fFxuICAgICAgICBjID09PSAweDAwMmEgfHxcbiAgICAgICAgYyA9PT0gMHgwMDJiIHx8XG4gICAgICAgIGMgPT09IDB4MDAyYyB8fFxuICAgICAgICBjID09PSAweDAwMmQgfHxcbiAgICAgICAgKGMgPj0gMHgwMDJlICYmIGMgPD0gMHgwMDJmKSB8fFxuICAgICAgICAoYyA+PSAweDAwM2EgJiYgYyA8PSAweDAwM2IpIHx8XG4gICAgICAgIChjID49IDB4MDAzYyAmJiBjIDw9IDB4MDAzZSkgfHxcbiAgICAgICAgKGMgPj0gMHgwMDNmICYmIGMgPD0gMHgwMDQwKSB8fFxuICAgICAgICBjID09PSAweDAwNWIgfHxcbiAgICAgICAgYyA9PT0gMHgwMDVjIHx8XG4gICAgICAgIGMgPT09IDB4MDA1ZCB8fFxuICAgICAgICBjID09PSAweDAwNWUgfHxcbiAgICAgICAgYyA9PT0gMHgwMDYwIHx8XG4gICAgICAgIGMgPT09IDB4MDA3YiB8fFxuICAgICAgICBjID09PSAweDAwN2MgfHxcbiAgICAgICAgYyA9PT0gMHgwMDdkIHx8XG4gICAgICAgIGMgPT09IDB4MDA3ZSB8fFxuICAgICAgICBjID09PSAweDAwYTEgfHxcbiAgICAgICAgKGMgPj0gMHgwMGEyICYmIGMgPD0gMHgwMGE1KSB8fFxuICAgICAgICBjID09PSAweDAwYTYgfHxcbiAgICAgICAgYyA9PT0gMHgwMGE3IHx8XG4gICAgICAgIGMgPT09IDB4MDBhOSB8fFxuICAgICAgICBjID09PSAweDAwYWIgfHxcbiAgICAgICAgYyA9PT0gMHgwMGFjIHx8XG4gICAgICAgIGMgPT09IDB4MDBhZSB8fFxuICAgICAgICBjID09PSAweDAwYjAgfHxcbiAgICAgICAgYyA9PT0gMHgwMGIxIHx8XG4gICAgICAgIGMgPT09IDB4MDBiNiB8fFxuICAgICAgICBjID09PSAweDAwYmIgfHxcbiAgICAgICAgYyA9PT0gMHgwMGJmIHx8XG4gICAgICAgIGMgPT09IDB4MDBkNyB8fFxuICAgICAgICBjID09PSAweDAwZjcgfHxcbiAgICAgICAgKGMgPj0gMHgyMDEwICYmIGMgPD0gMHgyMDE1KSB8fFxuICAgICAgICAoYyA+PSAweDIwMTYgJiYgYyA8PSAweDIwMTcpIHx8XG4gICAgICAgIGMgPT09IDB4MjAxOCB8fFxuICAgICAgICBjID09PSAweDIwMTkgfHxcbiAgICAgICAgYyA9PT0gMHgyMDFhIHx8XG4gICAgICAgIChjID49IDB4MjAxYiAmJiBjIDw9IDB4MjAxYykgfHxcbiAgICAgICAgYyA9PT0gMHgyMDFkIHx8XG4gICAgICAgIGMgPT09IDB4MjAxZSB8fFxuICAgICAgICBjID09PSAweDIwMWYgfHxcbiAgICAgICAgKGMgPj0gMHgyMDIwICYmIGMgPD0gMHgyMDI3KSB8fFxuICAgICAgICAoYyA+PSAweDIwMzAgJiYgYyA8PSAweDIwMzgpIHx8XG4gICAgICAgIGMgPT09IDB4MjAzOSB8fFxuICAgICAgICBjID09PSAweDIwM2EgfHxcbiAgICAgICAgKGMgPj0gMHgyMDNiICYmIGMgPD0gMHgyMDNlKSB8fFxuICAgICAgICAoYyA+PSAweDIwNDEgJiYgYyA8PSAweDIwNDMpIHx8XG4gICAgICAgIGMgPT09IDB4MjA0NCB8fFxuICAgICAgICBjID09PSAweDIwNDUgfHxcbiAgICAgICAgYyA9PT0gMHgyMDQ2IHx8XG4gICAgICAgIChjID49IDB4MjA0NyAmJiBjIDw9IDB4MjA1MSkgfHxcbiAgICAgICAgYyA9PT0gMHgyMDUyIHx8XG4gICAgICAgIGMgPT09IDB4MjA1MyB8fFxuICAgICAgICAoYyA+PSAweDIwNTUgJiYgYyA8PSAweDIwNWUpIHx8XG4gICAgICAgIChjID49IDB4MjE5MCAmJiBjIDw9IDB4MjE5NCkgfHxcbiAgICAgICAgKGMgPj0gMHgyMTk1ICYmIGMgPD0gMHgyMTk5KSB8fFxuICAgICAgICAoYyA+PSAweDIxOWEgJiYgYyA8PSAweDIxOWIpIHx8XG4gICAgICAgIChjID49IDB4MjE5YyAmJiBjIDw9IDB4MjE5ZikgfHxcbiAgICAgICAgYyA9PT0gMHgyMWEwIHx8XG4gICAgICAgIChjID49IDB4MjFhMSAmJiBjIDw9IDB4MjFhMikgfHxcbiAgICAgICAgYyA9PT0gMHgyMWEzIHx8XG4gICAgICAgIChjID49IDB4MjFhNCAmJiBjIDw9IDB4MjFhNSkgfHxcbiAgICAgICAgYyA9PT0gMHgyMWE2IHx8XG4gICAgICAgIChjID49IDB4MjFhNyAmJiBjIDw9IDB4MjFhZCkgfHxcbiAgICAgICAgYyA9PT0gMHgyMWFlIHx8XG4gICAgICAgIChjID49IDB4MjFhZiAmJiBjIDw9IDB4MjFjZCkgfHxcbiAgICAgICAgKGMgPj0gMHgyMWNlICYmIGMgPD0gMHgyMWNmKSB8fFxuICAgICAgICAoYyA+PSAweDIxZDAgJiYgYyA8PSAweDIxZDEpIHx8XG4gICAgICAgIGMgPT09IDB4MjFkMiB8fFxuICAgICAgICBjID09PSAweDIxZDMgfHxcbiAgICAgICAgYyA9PT0gMHgyMWQ0IHx8XG4gICAgICAgIChjID49IDB4MjFkNSAmJiBjIDw9IDB4MjFmMykgfHxcbiAgICAgICAgKGMgPj0gMHgyMWY0ICYmIGMgPD0gMHgyMmZmKSB8fFxuICAgICAgICAoYyA+PSAweDIzMDAgJiYgYyA8PSAweDIzMDcpIHx8XG4gICAgICAgIGMgPT09IDB4MjMwOCB8fFxuICAgICAgICBjID09PSAweDIzMDkgfHxcbiAgICAgICAgYyA9PT0gMHgyMzBhIHx8XG4gICAgICAgIGMgPT09IDB4MjMwYiB8fFxuICAgICAgICAoYyA+PSAweDIzMGMgJiYgYyA8PSAweDIzMWYpIHx8XG4gICAgICAgIChjID49IDB4MjMyMCAmJiBjIDw9IDB4MjMyMSkgfHxcbiAgICAgICAgKGMgPj0gMHgyMzIyICYmIGMgPD0gMHgyMzI4KSB8fFxuICAgICAgICBjID09PSAweDIzMjkgfHxcbiAgICAgICAgYyA9PT0gMHgyMzJhIHx8XG4gICAgICAgIChjID49IDB4MjMyYiAmJiBjIDw9IDB4MjM3YikgfHxcbiAgICAgICAgYyA9PT0gMHgyMzdjIHx8XG4gICAgICAgIChjID49IDB4MjM3ZCAmJiBjIDw9IDB4MjM5YSkgfHxcbiAgICAgICAgKGMgPj0gMHgyMzliICYmIGMgPD0gMHgyM2IzKSB8fFxuICAgICAgICAoYyA+PSAweDIzYjQgJiYgYyA8PSAweDIzZGIpIHx8XG4gICAgICAgIChjID49IDB4MjNkYyAmJiBjIDw9IDB4MjNlMSkgfHxcbiAgICAgICAgKGMgPj0gMHgyM2UyICYmIGMgPD0gMHgyNDI2KSB8fFxuICAgICAgICAoYyA+PSAweDI0MjcgJiYgYyA8PSAweDI0M2YpIHx8XG4gICAgICAgIChjID49IDB4MjQ0MCAmJiBjIDw9IDB4MjQ0YSkgfHxcbiAgICAgICAgKGMgPj0gMHgyNDRiICYmIGMgPD0gMHgyNDVmKSB8fFxuICAgICAgICAoYyA+PSAweDI1MDAgJiYgYyA8PSAweDI1YjYpIHx8XG4gICAgICAgIGMgPT09IDB4MjViNyB8fFxuICAgICAgICAoYyA+PSAweDI1YjggJiYgYyA8PSAweDI1YzApIHx8XG4gICAgICAgIGMgPT09IDB4MjVjMSB8fFxuICAgICAgICAoYyA+PSAweDI1YzIgJiYgYyA8PSAweDI1ZjcpIHx8XG4gICAgICAgIChjID49IDB4MjVmOCAmJiBjIDw9IDB4MjVmZikgfHxcbiAgICAgICAgKGMgPj0gMHgyNjAwICYmIGMgPD0gMHgyNjZlKSB8fFxuICAgICAgICBjID09PSAweDI2NmYgfHxcbiAgICAgICAgKGMgPj0gMHgyNjcwICYmIGMgPD0gMHgyNzY3KSB8fFxuICAgICAgICBjID09PSAweDI3NjggfHxcbiAgICAgICAgYyA9PT0gMHgyNzY5IHx8XG4gICAgICAgIGMgPT09IDB4Mjc2YSB8fFxuICAgICAgICBjID09PSAweDI3NmIgfHxcbiAgICAgICAgYyA9PT0gMHgyNzZjIHx8XG4gICAgICAgIGMgPT09IDB4Mjc2ZCB8fFxuICAgICAgICBjID09PSAweDI3NmUgfHxcbiAgICAgICAgYyA9PT0gMHgyNzZmIHx8XG4gICAgICAgIGMgPT09IDB4Mjc3MCB8fFxuICAgICAgICBjID09PSAweDI3NzEgfHxcbiAgICAgICAgYyA9PT0gMHgyNzcyIHx8XG4gICAgICAgIGMgPT09IDB4Mjc3MyB8fFxuICAgICAgICBjID09PSAweDI3NzQgfHxcbiAgICAgICAgYyA9PT0gMHgyNzc1IHx8XG4gICAgICAgIChjID49IDB4Mjc5NCAmJiBjIDw9IDB4MjdiZikgfHxcbiAgICAgICAgKGMgPj0gMHgyN2MwICYmIGMgPD0gMHgyN2M0KSB8fFxuICAgICAgICBjID09PSAweDI3YzUgfHxcbiAgICAgICAgYyA9PT0gMHgyN2M2IHx8XG4gICAgICAgIChjID49IDB4MjdjNyAmJiBjIDw9IDB4MjdlNSkgfHxcbiAgICAgICAgYyA9PT0gMHgyN2U2IHx8XG4gICAgICAgIGMgPT09IDB4MjdlNyB8fFxuICAgICAgICBjID09PSAweDI3ZTggfHxcbiAgICAgICAgYyA9PT0gMHgyN2U5IHx8XG4gICAgICAgIGMgPT09IDB4MjdlYSB8fFxuICAgICAgICBjID09PSAweDI3ZWIgfHxcbiAgICAgICAgYyA9PT0gMHgyN2VjIHx8XG4gICAgICAgIGMgPT09IDB4MjdlZCB8fFxuICAgICAgICBjID09PSAweDI3ZWUgfHxcbiAgICAgICAgYyA9PT0gMHgyN2VmIHx8XG4gICAgICAgIChjID49IDB4MjdmMCAmJiBjIDw9IDB4MjdmZikgfHxcbiAgICAgICAgKGMgPj0gMHgyODAwICYmIGMgPD0gMHgyOGZmKSB8fFxuICAgICAgICAoYyA+PSAweDI5MDAgJiYgYyA8PSAweDI5ODIpIHx8XG4gICAgICAgIGMgPT09IDB4Mjk4MyB8fFxuICAgICAgICBjID09PSAweDI5ODQgfHxcbiAgICAgICAgYyA9PT0gMHgyOTg1IHx8XG4gICAgICAgIGMgPT09IDB4Mjk4NiB8fFxuICAgICAgICBjID09PSAweDI5ODcgfHxcbiAgICAgICAgYyA9PT0gMHgyOTg4IHx8XG4gICAgICAgIGMgPT09IDB4Mjk4OSB8fFxuICAgICAgICBjID09PSAweDI5OGEgfHxcbiAgICAgICAgYyA9PT0gMHgyOThiIHx8XG4gICAgICAgIGMgPT09IDB4Mjk4YyB8fFxuICAgICAgICBjID09PSAweDI5OGQgfHxcbiAgICAgICAgYyA9PT0gMHgyOThlIHx8XG4gICAgICAgIGMgPT09IDB4Mjk4ZiB8fFxuICAgICAgICBjID09PSAweDI5OTAgfHxcbiAgICAgICAgYyA9PT0gMHgyOTkxIHx8XG4gICAgICAgIGMgPT09IDB4Mjk5MiB8fFxuICAgICAgICBjID09PSAweDI5OTMgfHxcbiAgICAgICAgYyA9PT0gMHgyOTk0IHx8XG4gICAgICAgIGMgPT09IDB4Mjk5NSB8fFxuICAgICAgICBjID09PSAweDI5OTYgfHxcbiAgICAgICAgYyA9PT0gMHgyOTk3IHx8XG4gICAgICAgIGMgPT09IDB4Mjk5OCB8fFxuICAgICAgICAoYyA+PSAweDI5OTkgJiYgYyA8PSAweDI5ZDcpIHx8XG4gICAgICAgIGMgPT09IDB4MjlkOCB8fFxuICAgICAgICBjID09PSAweDI5ZDkgfHxcbiAgICAgICAgYyA9PT0gMHgyOWRhIHx8XG4gICAgICAgIGMgPT09IDB4MjlkYiB8fFxuICAgICAgICAoYyA+PSAweDI5ZGMgJiYgYyA8PSAweDI5ZmIpIHx8XG4gICAgICAgIGMgPT09IDB4MjlmYyB8fFxuICAgICAgICBjID09PSAweDI5ZmQgfHxcbiAgICAgICAgKGMgPj0gMHgyOWZlICYmIGMgPD0gMHgyYWZmKSB8fFxuICAgICAgICAoYyA+PSAweDJiMDAgJiYgYyA8PSAweDJiMmYpIHx8XG4gICAgICAgIChjID49IDB4MmIzMCAmJiBjIDw9IDB4MmI0NCkgfHxcbiAgICAgICAgKGMgPj0gMHgyYjQ1ICYmIGMgPD0gMHgyYjQ2KSB8fFxuICAgICAgICAoYyA+PSAweDJiNDcgJiYgYyA8PSAweDJiNGMpIHx8XG4gICAgICAgIChjID49IDB4MmI0ZCAmJiBjIDw9IDB4MmI3MykgfHxcbiAgICAgICAgKGMgPj0gMHgyYjc0ICYmIGMgPD0gMHgyYjc1KSB8fFxuICAgICAgICAoYyA+PSAweDJiNzYgJiYgYyA8PSAweDJiOTUpIHx8XG4gICAgICAgIGMgPT09IDB4MmI5NiB8fFxuICAgICAgICAoYyA+PSAweDJiOTcgJiYgYyA8PSAweDJiZmYpIHx8XG4gICAgICAgIChjID49IDB4MmUwMCAmJiBjIDw9IDB4MmUwMSkgfHxcbiAgICAgICAgYyA9PT0gMHgyZTAyIHx8XG4gICAgICAgIGMgPT09IDB4MmUwMyB8fFxuICAgICAgICBjID09PSAweDJlMDQgfHxcbiAgICAgICAgYyA9PT0gMHgyZTA1IHx8XG4gICAgICAgIChjID49IDB4MmUwNiAmJiBjIDw9IDB4MmUwOCkgfHxcbiAgICAgICAgYyA9PT0gMHgyZTA5IHx8XG4gICAgICAgIGMgPT09IDB4MmUwYSB8fFxuICAgICAgICBjID09PSAweDJlMGIgfHxcbiAgICAgICAgYyA9PT0gMHgyZTBjIHx8XG4gICAgICAgIGMgPT09IDB4MmUwZCB8fFxuICAgICAgICAoYyA+PSAweDJlMGUgJiYgYyA8PSAweDJlMTYpIHx8XG4gICAgICAgIGMgPT09IDB4MmUxNyB8fFxuICAgICAgICAoYyA+PSAweDJlMTggJiYgYyA8PSAweDJlMTkpIHx8XG4gICAgICAgIGMgPT09IDB4MmUxYSB8fFxuICAgICAgICBjID09PSAweDJlMWIgfHxcbiAgICAgICAgYyA9PT0gMHgyZTFjIHx8XG4gICAgICAgIGMgPT09IDB4MmUxZCB8fFxuICAgICAgICAoYyA+PSAweDJlMWUgJiYgYyA8PSAweDJlMWYpIHx8XG4gICAgICAgIGMgPT09IDB4MmUyMCB8fFxuICAgICAgICBjID09PSAweDJlMjEgfHxcbiAgICAgICAgYyA9PT0gMHgyZTIyIHx8XG4gICAgICAgIGMgPT09IDB4MmUyMyB8fFxuICAgICAgICBjID09PSAweDJlMjQgfHxcbiAgICAgICAgYyA9PT0gMHgyZTI1IHx8XG4gICAgICAgIGMgPT09IDB4MmUyNiB8fFxuICAgICAgICBjID09PSAweDJlMjcgfHxcbiAgICAgICAgYyA9PT0gMHgyZTI4IHx8XG4gICAgICAgIGMgPT09IDB4MmUyOSB8fFxuICAgICAgICAoYyA+PSAweDJlMmEgJiYgYyA8PSAweDJlMmUpIHx8XG4gICAgICAgIGMgPT09IDB4MmUyZiB8fFxuICAgICAgICAoYyA+PSAweDJlMzAgJiYgYyA8PSAweDJlMzkpIHx8XG4gICAgICAgIChjID49IDB4MmUzYSAmJiBjIDw9IDB4MmUzYikgfHxcbiAgICAgICAgKGMgPj0gMHgyZTNjICYmIGMgPD0gMHgyZTNmKSB8fFxuICAgICAgICBjID09PSAweDJlNDAgfHxcbiAgICAgICAgYyA9PT0gMHgyZTQxIHx8XG4gICAgICAgIGMgPT09IDB4MmU0MiB8fFxuICAgICAgICAoYyA+PSAweDJlNDMgJiYgYyA8PSAweDJlNGYpIHx8XG4gICAgICAgIChjID49IDB4MmU1MCAmJiBjIDw9IDB4MmU1MSkgfHxcbiAgICAgICAgYyA9PT0gMHgyZTUyIHx8XG4gICAgICAgIChjID49IDB4MmU1MyAmJiBjIDw9IDB4MmU3ZikgfHxcbiAgICAgICAgKGMgPj0gMHgzMDAxICYmIGMgPD0gMHgzMDAzKSB8fFxuICAgICAgICBjID09PSAweDMwMDggfHxcbiAgICAgICAgYyA9PT0gMHgzMDA5IHx8XG4gICAgICAgIGMgPT09IDB4MzAwYSB8fFxuICAgICAgICBjID09PSAweDMwMGIgfHxcbiAgICAgICAgYyA9PT0gMHgzMDBjIHx8XG4gICAgICAgIGMgPT09IDB4MzAwZCB8fFxuICAgICAgICBjID09PSAweDMwMGUgfHxcbiAgICAgICAgYyA9PT0gMHgzMDBmIHx8XG4gICAgICAgIGMgPT09IDB4MzAxMCB8fFxuICAgICAgICBjID09PSAweDMwMTEgfHxcbiAgICAgICAgKGMgPj0gMHgzMDEyICYmIGMgPD0gMHgzMDEzKSB8fFxuICAgICAgICBjID09PSAweDMwMTQgfHxcbiAgICAgICAgYyA9PT0gMHgzMDE1IHx8XG4gICAgICAgIGMgPT09IDB4MzAxNiB8fFxuICAgICAgICBjID09PSAweDMwMTcgfHxcbiAgICAgICAgYyA9PT0gMHgzMDE4IHx8XG4gICAgICAgIGMgPT09IDB4MzAxOSB8fFxuICAgICAgICBjID09PSAweDMwMWEgfHxcbiAgICAgICAgYyA9PT0gMHgzMDFiIHx8XG4gICAgICAgIGMgPT09IDB4MzAxYyB8fFxuICAgICAgICBjID09PSAweDMwMWQgfHxcbiAgICAgICAgKGMgPj0gMHgzMDFlICYmIGMgPD0gMHgzMDFmKSB8fFxuICAgICAgICBjID09PSAweDMwMjAgfHxcbiAgICAgICAgYyA9PT0gMHgzMDMwIHx8XG4gICAgICAgIGMgPT09IDB4ZmQzZSB8fFxuICAgICAgICBjID09PSAweGZkM2YgfHxcbiAgICAgICAgKGMgPj0gMHhmZTQ1ICYmIGMgPD0gMHhmZTQ2KSk7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQU5BLElBQUk7Ozs7Ozs7QUFPSixJQUFJLDhCQUE4QixJQUFJLE9BQU8sSUFBSSxNQUFNLENBQUMsNExBQUEsQ0FBQSx3QkFBcUIsQ0FBQyxNQUFNLEVBQUU7QUFDdEYsSUFBSSw0QkFBNEIsSUFBSSxPQUFPLEdBQUcsTUFBTSxDQUFDLDRMQUFBLENBQUEsd0JBQXFCLENBQUMsTUFBTSxFQUFFO0FBQ25GLFNBQVMsZUFBZSxLQUFLLEVBQUUsR0FBRztJQUM5QixPQUFPO1FBQUUsT0FBTztRQUFPLEtBQUs7SUFBSTtBQUNwQztBQUNBLG9CQUFvQjtBQUNwQiwwRUFBMEU7QUFDMUUsSUFBSSxzQkFBc0IsQ0FBQyxDQUFDLE9BQU8sU0FBUyxDQUFDLFVBQVUsSUFBSSxLQUFLLFVBQVUsQ0FBQyxLQUFLO0FBQ2hGLElBQUkseUJBQXlCLENBQUMsQ0FBQyxPQUFPLGFBQWE7QUFDbkQsSUFBSSx1QkFBdUIsQ0FBQyxDQUFDLE9BQU8sV0FBVztBQUMvQyxJQUFJLHVCQUF1QixDQUFDLENBQUMsT0FBTyxTQUFTLENBQUMsV0FBVztBQUN6RCxJQUFJLGVBQWUsQ0FBQyxDQUFDLE9BQU8sU0FBUyxDQUFDLFNBQVM7QUFDL0MsSUFBSSxhQUFhLENBQUMsQ0FBQyxPQUFPLFNBQVMsQ0FBQyxPQUFPO0FBQzNDLElBQUkseUJBQXlCLENBQUMsQ0FBQyxPQUFPLGFBQWE7QUFDbkQsSUFBSSxnQkFBZ0IseUJBQ2QsT0FBTyxhQUFhLEdBQ3BCLFNBQVUsQ0FBQztJQUNULE9BQVEsT0FBTyxNQUFNLFlBQ2pCLFNBQVMsTUFDVCxLQUFLLEtBQUssQ0FBQyxPQUFPLEtBQ2xCLEtBQUssR0FBRyxDQUFDLE1BQU07QUFDdkI7QUFDSixpQ0FBaUM7QUFDakMsSUFBSSx5QkFBeUI7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QUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssV0FBVyxLQUFLO0FBQzlCO0FBQ0E7OztDQUdDLEdBQ0QsU0FBUyxjQUFjLENBQUM7SUFDcEIsT0FBUSxBQUFDLEtBQUssVUFBVSxLQUFLLFVBQ3pCLE1BQU0sVUFDTixNQUFNLFVBQ0wsS0FBSyxVQUFVLEtBQUssVUFDckIsTUFBTSxVQUNOLE1BQU07QUFDZDtBQUNBOzs7Q0FHQyxHQUNELFNBQVMsaUJBQWlCLENBQUM7SUFDdkIsT0FBUSxBQUFDLEtBQUssVUFBVSxLQUFLLFVBQ3pCLE1BQU0sVUFDTCxLQUFLLFVBQVUsS0FBSyxVQUNyQixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTCxLQUFLLFVBQVUsS0FBSyxVQUNwQixLQUFLLFVBQVUsS0FBSyxVQUNwQixLQUFLLFVBQVUsS0FBSyxVQUNwQixLQUFLLFVBQVUsS0FBSyxVQUNyQixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ0wsS0FBSyxVQUFVLEtBQUssVUFDckIsTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNMLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3JCLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNMLEtBQUssVUFBVSxLQUFLLFVBQ3JCLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNMLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3JCLE1BQU0sVUFDTixNQUFNLFVBQ0wsS0FBSyxVQUFVLEtBQUssVUFDcEIsS0FBSyxVQUFVLEtBQUssVUFDckIsTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ0wsS0FBSyxVQUFVLEtBQUssVUFDckIsTUFBTSxVQUNOLE1BQU0sVUFDTCxLQUFLLFVBQVUsS0FBSyxVQUNwQixLQUFLLFVBQVUsS0FBSyxVQUNwQixLQUFLLFVBQVUsS0FBSyxVQUNwQixLQUFLLFVBQVUsS0FBSyxVQUNwQixLQUFLLFVBQVUsS0FBSyxVQUNyQixNQUFNLFVBQ0wsS0FBSyxVQUFVLEtBQUssVUFDckIsTUFBTSxVQUNMLEtBQUssVUFBVSxLQUFLLFVBQ3JCLE1BQU0sVUFDTCxLQUFLLFVBQVUsS0FBSyxVQUNyQixNQUFNLFVBQ0wsS0FBSyxVQUFVLEtBQUssVUFDcEIsS0FBSyxVQUFVLEtBQUssVUFDcEIsS0FBSyxVQUFVLEtBQUssVUFDckIsTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ0wsS0FBSyxVQUFVLEtBQUssVUFDcEIsS0FBSyxVQUFVLEtBQUssVUFDcEIsS0FBSyxVQUFVLEtBQUssVUFDckIsTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNMLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3JCLE1BQU0sVUFDTixNQUFNLFVBQ0wsS0FBSyxVQUFVLEtBQUssVUFDckIsTUFBTSxVQUNMLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3JCLE1BQU0sVUFDTCxLQUFLLFVBQVUsS0FBSyxVQUNyQixNQUFNLFVBQ0wsS0FBSyxVQUFVLEtBQUssVUFDcEIsS0FBSyxVQUFVLEtBQUssVUFDcEIsS0FBSyxVQUFVLEtBQUssVUFDckIsTUFBTSxVQUNMLEtBQUssVUFBVSxLQUFLLFVBQ3JCLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ0wsS0FBSyxVQUFVLEtBQUssVUFDcEIsS0FBSyxVQUFVLEtBQUssVUFDckIsTUFBTSxVQUNOLE1BQU0sVUFDTCxLQUFLLFVBQVUsS0FBSyxVQUNyQixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ0wsS0FBSyxVQUFVLEtBQUssVUFDcEIsS0FBSyxVQUFVLEtBQUssVUFDcEIsS0FBSyxVQUFVLEtBQUssVUFDckIsTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNMLEtBQUssVUFBVSxLQUFLLFVBQ3JCLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTCxLQUFLLFVBQVUsS0FBSyxVQUNyQixNQUFNLFVBQ04sTUFBTSxVQUNMLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3JCLE1BQU0sVUFDTCxLQUFLLFVBQVUsS0FBSyxVQUNwQixLQUFLLFVBQVUsS0FBSyxVQUNyQixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ0wsS0FBSyxVQUFVLEtBQUssVUFDckIsTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTCxLQUFLLFVBQVUsS0FBSyxVQUNyQixNQUFNLFVBQ0wsS0FBSyxVQUFVLEtBQUssVUFDckIsTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNMLEtBQUssVUFBVSxLQUFLLFVBQ3JCLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTCxLQUFLLFVBQVUsS0FBSyxVQUNyQixNQUFNLFVBQ0wsS0FBSyxVQUFVLEtBQUssVUFDcEIsS0FBSyxVQUFVLEtBQUssVUFDcEIsS0FBSyxVQUFVLEtBQUssVUFDckIsTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ0wsS0FBSyxVQUFVLEtBQUssVUFDcEIsS0FBSyxVQUFVLEtBQUssVUFDckIsTUFBTSxVQUNMLEtBQUssVUFBVSxLQUFLLFVBQ3BCLEtBQUssVUFBVSxLQUFLLFVBQ3JCLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTCxLQUFLLFVBQVUsS0FBSyxVQUNyQixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ0wsS0FBSyxVQUFVLEtBQUssVUFDckIsTUFBTSxVQUNOLE1BQU0sVUFDTixNQUFNLFVBQ04sTUFBTSxVQUNMLEtBQUssVUFBVSxLQUFLO0FBQzdCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDM4MTgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwZm9ybWF0anMvaWN1LW1lc3NhZ2Vmb3JtYXQtcGFyc2VyL2xpYi9tYW5pcHVsYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3NwcmVhZEFycmF5IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBpc0FyZ3VtZW50RWxlbWVudCwgaXNEYXRlRWxlbWVudCwgaXNOdW1iZXJFbGVtZW50LCBpc1BsdXJhbEVsZW1lbnQsIGlzU2VsZWN0RWxlbWVudCwgaXNUYWdFbGVtZW50LCBpc1RpbWVFbGVtZW50LCBUWVBFLCB9IGZyb20gJy4vdHlwZXMnO1xuZnVuY3Rpb24gY2xvbmVEZWVwKG9iaikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBtZWhcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoW10sIG9iai5tYXAoY2xvbmVEZWVwKSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBtZWhcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKGZ1bmN0aW9uIChjbG9uZWQsIGspIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbWVoXG4gICAgICAgICAgICBjbG9uZWRba10gPSBjbG9uZURlZXAob2JqW2tdKTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIGhvaXN0UGx1cmFsT3JTZWxlY3RFbGVtZW50KGFzdCwgZWwsIHBvc2l0aW9uVG9JbmplY3QpIHtcbiAgICAvLyBwdWxsIHRoaXMgb3V0IG9mIHRoZSBhc3QgYW5kIG1vdmUgaXQgdG8gdGhlIHRvcFxuICAgIHZhciBjbG9uZWQgPSBjbG9uZURlZXAoZWwpO1xuICAgIHZhciBvcHRpb25zID0gY2xvbmVkLm9wdGlvbnM7XG4gICAgY2xvbmVkLm9wdGlvbnMgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5yZWR1Y2UoZnVuY3Rpb24gKGFsbCwgaykge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBob2lzdFNlbGVjdG9ycyhfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgYXN0LnNsaWNlKDAsIHBvc2l0aW9uVG9JbmplY3QpLCB0cnVlKSwgb3B0aW9uc1trXS52YWx1ZSwgdHJ1ZSksIGFzdC5zbGljZShwb3NpdGlvblRvSW5qZWN0ICsgMSksIHRydWUpKTtcbiAgICAgICAgYWxsW2tdID0ge1xuICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYWxsO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gY2xvbmVkO1xufVxuZnVuY3Rpb24gaXNQbHVyYWxPclNlbGVjdEVsZW1lbnQoZWwpIHtcbiAgICByZXR1cm4gaXNQbHVyYWxFbGVtZW50KGVsKSB8fCBpc1NlbGVjdEVsZW1lbnQoZWwpO1xufVxuZnVuY3Rpb24gZmluZFBsdXJhbE9yU2VsZWN0RWxlbWVudChhc3QpIHtcbiAgICByZXR1cm4gISFhc3QuZmluZChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGlzUGx1cmFsT3JTZWxlY3RFbGVtZW50KGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGFnRWxlbWVudChlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kUGx1cmFsT3JTZWxlY3RFbGVtZW50KGVsLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG59XG4vKipcbiAqIEhvaXN0IGFsbCBzZWxlY3RvcnMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgQVNUICYgZmxhdHRlbiB0aGVcbiAqIHJlc3VsdGluZyBvcHRpb25zLiBFLmc6XG4gKiBcIkkgaGF2ZSB7Y291bnQsIHBsdXJhbCwgb25le2EgZG9nfSBvdGhlcnttYW55IGRvZ3N9fVwiXG4gKiBiZWNvbWVzIFwie2NvdW50LCBwbHVyYWwsIG9uZXtJIGhhdmUgYSBkb2d9IG90aGVye0kgaGF2ZSBtYW55IGRvZ3N9fVwiLlxuICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIHNlbGVjdG9ycywgdGhlIG9yZGVyIG9mIHdoaWNoIG9uZSBpcyBob2lzdGVkIDFzdFxuICogaXMgbm9uLWRldGVybWluaXN0aWMuXG4gKiBUaGUgZ29hbCBpcyB0byBwcm92aWRlIGFzIG1hbnkgZnVsbCBzZW50ZW5jZXMgYXMgcG9zc2libGUgc2luY2UgZnJhZ21lbnRlZFxuICogc2VudGVuY2VzIGFyZSBub3QgdHJhbnNsYXRvci1mcmllbmRseVxuICogQHBhcmFtIGFzdCBBU1RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhvaXN0U2VsZWN0b3JzKGFzdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbCA9IGFzdFtpXTtcbiAgICAgICAgaWYgKGlzUGx1cmFsT3JTZWxlY3RFbGVtZW50KGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtob2lzdFBsdXJhbE9yU2VsZWN0RWxlbWVudChhc3QsIGVsLCBpKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGFnRWxlbWVudChlbCkgJiYgZmluZFBsdXJhbE9yU2VsZWN0RWxlbWVudChbZWxdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaG9pc3QgcGx1cmFsL3NlbGVjdCB3aXRoaW4gYSB0YWcgZWxlbWVudC4gUGxlYXNlIHB1dCB0aGUgdGFnIGVsZW1lbnQgaW5zaWRlIGVhY2ggcGx1cmFsL3NlbGVjdCBvcHRpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXN0O1xufVxuLyoqXG4gKiBDb2xsZWN0IGFsbCB2YXJpYWJsZXMgaW4gYW4gQVNUIHRvIFJlY29yZDxzdHJpbmcsIFRZUEU+XG4gKiBAcGFyYW0gYXN0IEFTVCB0byBjb2xsZWN0IHZhcmlhYmxlcyBmcm9tXG4gKiBAcGFyYW0gdmFycyBSZWNvcmQgb2YgdmFyaWFibGUgbmFtZSB0byB2YXJpYWJsZSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RWYXJpYWJsZXMoYXN0LCB2YXJzKSB7XG4gICAgaWYgKHZhcnMgPT09IHZvaWQgMCkgeyB2YXJzID0gbmV3IE1hcCgpOyB9XG4gICAgYXN0LmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmIChpc0FyZ3VtZW50RWxlbWVudChlbCkgfHxcbiAgICAgICAgICAgIGlzRGF0ZUVsZW1lbnQoZWwpIHx8XG4gICAgICAgICAgICBpc1RpbWVFbGVtZW50KGVsKSB8fFxuICAgICAgICAgICAgaXNOdW1iZXJFbGVtZW50KGVsKSkge1xuICAgICAgICAgICAgaWYgKGVsLnZhbHVlIGluIHZhcnMgJiYgdmFycy5nZXQoZWwudmFsdWUpICE9PSBlbC50eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgXCIuY29uY2F0KGVsLnZhbHVlLCBcIiBoYXMgY29uZmxpY3RpbmcgdHlwZXNcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFycy5zZXQoZWwudmFsdWUsIGVsLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BsdXJhbEVsZW1lbnQoZWwpIHx8IGlzU2VsZWN0RWxlbWVudChlbCkpIHtcbiAgICAgICAgICAgIHZhcnMuc2V0KGVsLnZhbHVlLCBlbC50eXBlKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGVsLm9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0VmFyaWFibGVzKGVsLm9wdGlvbnNba10udmFsdWUsIHZhcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGFnRWxlbWVudChlbCkpIHtcbiAgICAgICAgICAgIHZhcnMuc2V0KGVsLnZhbHVlLCBlbC50eXBlKTtcbiAgICAgICAgICAgIGNvbGxlY3RWYXJpYWJsZXMoZWwuY2hpbGRyZW4sIHZhcnMpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIENoZWNrIGlmIDIgQVNUcyBhcmUgc3RydWN0dXJhbGx5IHRoZSBzYW1lLiBUaGlzIHByaW1hcmlseSBtZWFucyB0aGF0XG4gKiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFyaWFibGVzIHdpdGggdGhlIHNhbWUgdHlwZVxuICogQHBhcmFtIGFcbiAqIEBwYXJhbSBiXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJ1Y3R1cmFsbHlTYW1lKGEsIGIpIHtcbiAgICB2YXIgYVZhcnMgPSBuZXcgTWFwKCk7XG4gICAgdmFyIGJWYXJzID0gbmV3IE1hcCgpO1xuICAgIGNvbGxlY3RWYXJpYWJsZXMoYSwgYVZhcnMpO1xuICAgIGNvbGxlY3RWYXJpYWJsZXMoYiwgYlZhcnMpO1xuICAgIGlmIChhVmFycy5zaXplICE9PSBiVmFycy5zaXplKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoXCJEaWZmZXJlbnQgbnVtYmVyIG9mIHZhcmlhYmxlczogW1wiLmNvbmNhdChBcnJheS5mcm9tKGFWYXJzLmtleXMoKSkuam9pbignLCAnKSwgXCJdIHZzIFtcIikuY29uY2F0KEFycmF5LmZyb20oYlZhcnMua2V5cygpKS5qb2luKCcsICcpLCBcIl1cIikpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShhVmFycy5lbnRyaWVzKCkpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBfYSkge1xuICAgICAgICB2YXIga2V5ID0gX2FbMF0sIHR5cGUgPSBfYVsxXTtcbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYlR5cGUgPSBiVmFycy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGJUeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFyaWFibGUgXCIuY29uY2F0KGtleSwgXCIgaW4gbWVzc2FnZVwiKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChiVHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFwiVmFyaWFibGUgXCIuY29uY2F0KGtleSwgXCIgaGFzIGNvbmZsaWN0aW5nIHR5cGVzOiBcIikuY29uY2F0KFRZUEVbdHlwZV0sIFwiIHZzIFwiKS5jb25jYXQoVFlQRVtiVHlwZV0pKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7IHN1Y2Nlc3M6IHRydWUgfSk7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7OztBQUNBLFNBQVMsVUFBVSxHQUFHO0lBQ2xCLElBQUksTUFBTSxPQUFPLENBQUMsTUFBTTtRQUNwQix1QkFBdUI7UUFDdkIsT0FBTyxDQUFBLEdBQUEseUlBQUEsQ0FBQSxnQkFBYSxBQUFELEVBQUUsRUFBRSxFQUFFLElB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LE9BQU8sT0FBTyxFQUFFO1lBQ2pCLE9BQU87UUFDWDtRQUNBLElBQUksUUFBUSxNQUFNLEdBQUcsQ0FBQztRQUN0QixJQUFJLFNBQVMsTUFBTTtZQUNmLE9BQU87Z0JBQ0gsU0FBUztnQkFDVCxPQUFPLElBQUksTUFBTSxvQkFBb0IsTUFBTSxDQUFDLEtBQUs7WUFDckQ7UUFDSjtRQUNBLElBQUksVUFBVSxNQUFNO1lBQ2hCLE9BQU87Z0JBQ0gsU0FBUztnQkFDVCxPQUFPLElBQUksTUFBTSxZQUFZLE1BQU0sQ0FBQyxLQUFLLDRCQUE0QixNQUFNLENBQUMsK0tBQUEsQ0FBQSxPQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsTUFBTSxDQUFDLCtLQUFBLENBQUEsT0FBSSxDQUFDLE1BQU07WUFDdEg7UUFDSjtRQUNBLE9BQU87SUFDWCxHQUFHO1FBQUUsU0FBUztJQUFLO0FBQ3ZCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDM5NDksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwZm9ybWF0anMvaWN1LW1lc3NhZ2Vmb3JtYXQtcGFyc2VyL2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgRXJyb3JLaW5kIH0gZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQgeyBQYXJzZXIgfSBmcm9tICcuL3BhcnNlcic7XG5pbXBvcnQgeyBpc0RhdGVFbGVtZW50LCBpc0RhdGVUaW1lU2tlbGV0b24sIGlzTnVtYmVyRWxlbWVudCwgaXNOdW1iZXJTa2VsZXRvbiwgaXNQbHVyYWxFbGVtZW50LCBpc1NlbGVjdEVsZW1lbnQsIGlzVGFnRWxlbWVudCwgaXNUaW1lRWxlbWVudCwgfSBmcm9tICcuL3R5cGVzJztcbmZ1bmN0aW9uIHBydW5lTG9jYXRpb24oZWxzKSB7XG4gICAgZWxzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGRlbGV0ZSBlbC5sb2NhdGlvbjtcbiAgICAgICAgaWYgKGlzU2VsZWN0RWxlbWVudChlbCkgfHwgaXNQbHVyYWxFbGVtZW50KGVsKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBlbC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsLm9wdGlvbnNba10ubG9jYXRpb247XG4gICAgICAgICAgICAgICAgcHJ1bmVMb2NhdGlvbihlbC5vcHRpb25zW2tdLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc051bWJlckVsZW1lbnQoZWwpICYmIGlzTnVtYmVyU2tlbGV0b24oZWwuc3R5bGUpKSB7XG4gICAgICAgICAgICBkZWxldGUgZWwuc3R5bGUubG9jYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGlzRGF0ZUVsZW1lbnQoZWwpIHx8IGlzVGltZUVsZW1lbnQoZWwpKSAmJlxuICAgICAgICAgICAgaXNEYXRlVGltZVNrZWxldG9uKGVsLnN0eWxlKSkge1xuICAgICAgICAgICAgZGVsZXRlIGVsLnN0eWxlLmxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVGFnRWxlbWVudChlbCkpIHtcbiAgICAgICAgICAgIHBydW5lTG9jYXRpb24oZWwuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2UobWVzc2FnZSwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XG4gICAgb3B0cyA9IF9fYXNzaWduKHsgc2hvdWxkUGFyc2VTa2VsZXRvbnM6IHRydWUsIHJlcXVpcmVzT3RoZXJDbGF1c2U6IHRydWUgfSwgb3B0cyk7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBQYXJzZXIobWVzc2FnZSwgb3B0cykucGFyc2UoKTtcbiAgICBpZiAocmVzdWx0LmVycikge1xuICAgICAgICB2YXIgZXJyb3IgPSBTeW50YXhFcnJvcihFcnJvcktpbmRbcmVzdWx0LmVyci5raW5kXSk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQXNzaWduIHRvIGVycm9yIG9iamVjdFxuICAgICAgICBlcnJvci5sb2NhdGlvbiA9IHJlc3VsdC5lcnIubG9jYXRpb247XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQXNzaWduIHRvIGVycm9yIG9iamVjdFxuICAgICAgICBlcnJvci5vcmlnaW5hbE1lc3NhZ2UgPSByZXN1bHQuZXJyLm1lc3NhZ2U7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAoIShvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuY2FwdHVyZUxvY2F0aW9uKSkge1xuICAgICAgICBwcnVuZUxvY2F0aW9uKHJlc3VsdC52YWwpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnZhbDtcbn1cbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuLy8gb25seSBmb3IgdGVzdGluZ1xuZXhwb3J0IHZhciBfUGFyc2VyID0gUGFyc2VyO1xuZXhwb3J0IHsgaXNTdHJ1Y3R1cmFsbHlTYW1lIH0gZnJvbSAnLi9tYW5pcHVsYXRvcic7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBMENBOzs7OztBQXpDQSxTQUFTLGNBQWMsR0FBRztJQUN0QixJQUFJLE9BQU8sQ0FBQyxTQUFVLEVBQUU7UUFDcEIsT0FBTyxHQUFHLFFBQVE7UUFDbEIsSUFBSSxDQUFBLEdBQUEsK0tBQUEsQ0FBQSxrQkFBZSxBQUFELEVBQUUsT0FBTyxDQUFBLEdBQUEsK0tBQUEsQ0FBQSxrQkFBZSxBQUFELEVBQUUsS0FBSztZQUM1QyxJQUFLLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBRTtnQkFDdEIsT0FBTyxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUMsUUFBUTtnQkFDN0IsY0FBYyxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUMsS0FBSztZQUNyQztRQUNKLE9BQ0ssSUFBSSxDQUFBLEdBQUEsK0tBQUEsQ0FBQSxrQkFBZSxBQUFELEVBQUUsT0FBTyxDQUFBLEdBQUEsK0tBQUEsQ0FBQSxtQkFBZ0IsQUFBRCxFQUFFLEdBQUcsS0FBSyxHQUFHO1lBQ3hELE9BQU8sR0FBRyxLQUFLLENBQUMsUUFBUTtRQUM1QixPQUNLLElBQUksQ0FBQyxDQUFBLEdBQUEsK0tBQUEsQ0FBQSxnQkFBYSxBQUFELEVBQUUsT0FBTyxDQUFBLEdBQUEsK0tBQUEsQ0FBQSxnQkFBYSxBQUFELEVBQUUsR0FBRyxLQUM1QyxDQUFBLEdBQUEsK0tBQUEsQ0FBQSxxQkFBa0IsQUFBRCxFQUFFLEdBQUcsS0FBSyxHQUFHO1lBQzlCLE9BQU8sR0FBRyxLQUFLLENBQUMsUUFBUTtRQUM1QixPQUNLLElBQUksQ0FBQSxHQUFBLCtLQUFBLENBQUEsZUFBWSxBQUFELEVBQUUsS0FBSztZQUN2QixjQUFjLEdBQUcsUUFBUTtRQUM3QjtJQUNKO0FBQ0o7QUFDTyxTQUFTLE1BQU0sT0FBTyxFQUFFLElBQUk7SUFDL0IsSUFBSSxTQUFTLEtBQUssR0FBRztRQUFFLE9BQU8sQ0FBQztJQUFHO0lBQ2xDLE9BQU8sQ0FBQSxHQUFBLHlJQUFBLENBQUEsV0FBUSxBQUFELEVBQUU7UUFBRSxzQkFBc0I7UUFBTSxxQkFBcUI7SUFBSyxHQUFHO0lBQzNFLElBQUksU0FBUyxJQUFJLGdMQUFBLENBQUEsU0FBTSxDQUFDLFNBQVMsTUFBTSxLQUFLO0lBQzVDLElBQUksT0FBTyxHQUFHLEVBQUU7UUFDWixJQUFJLFFBQVEsWUFBWSwrS0FBQSxDQUFBLFlBQVMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUM7UUFDbEQsMENBQTBDO1FBQzFDLE1BQU0sUUFBUSxHQUFHLE9BQU8sR0FBRyxDQUFDLFFBQVE7UUFDcEMsMENBQTBDO1FBQzFDLE1BQU0sZUFBZSxHQUFHLE9BQU8sR0FBRyxDQUFDLE9BQU87UUFDMUMsTUFBTTtJQUNWO0lBQ0EsSUFBSSxDQUFDLENBQUMsU0FBUyxRQUFRLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSSxLQUFLLGVBQWUsR0FBRztRQUNyRSxjQUFjLE9BQU8sR0FBRztJQUM1QjtJQUNBLE9BQU8sT0FBTyxHQUFHO0FBQ3JCOztBQUdPLElBQUksVUFBVSxnTEFBQSxDQUFBLFNBQU0iLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDAxOCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9pbnRsLW1lc3NhZ2Vmb3JtYXQvbGliL3NyYy9lcnJvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmV4cG9ydCB2YXIgRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChFcnJvckNvZGUpIHtcbiAgICAvLyBXaGVuIHdlIGhhdmUgYSBwbGFjZWhvbGRlciBidXQgbm8gdmFsdWUgdG8gZm9ybWF0XG4gICAgRXJyb3JDb2RlW1wiTUlTU0lOR19WQUxVRVwiXSA9IFwiTUlTU0lOR19WQUxVRVwiO1xuICAgIC8vIFdoZW4gdmFsdWUgc3VwcGxpZWQgaXMgaW52YWxpZFxuICAgIEVycm9yQ29kZVtcIklOVkFMSURfVkFMVUVcIl0gPSBcIklOVkFMSURfVkFMVUVcIjtcbiAgICAvLyBXaGVuIHdlIG5lZWQgc3BlY2lmaWMgSW50bCBBUEkgYnV0IGl0J3Mgbm90IGF2YWlsYWJsZVxuICAgIEVycm9yQ29kZVtcIk1JU1NJTkdfSU5UTF9BUElcIl0gPSBcIk1JU1NJTkdfSU5UTF9BUElcIjtcbn0pKEVycm9yQ29kZSB8fCAoRXJyb3JDb2RlID0ge30pKTtcbnZhciBGb3JtYXRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRm9ybWF0RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9ybWF0RXJyb3IobXNnLCBjb2RlLCBvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbXNnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgX3RoaXMub3JpZ2luYWxNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZvcm1hdEVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW2Zvcm1hdGpzIEVycm9yOiBcIi5jb25jYXQodGhpcy5jb2RlLCBcIl0gXCIpLmNvbmNhdCh0aGlzLm1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIEZvcm1hdEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0IHsgRm9ybWF0RXJyb3IgfTtcbnZhciBJbnZhbGlkVmFsdWVFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW52YWxpZFZhbHVlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW52YWxpZFZhbHVlRXJyb3IodmFyaWFibGVJZCwgdmFsdWUsIG9wdGlvbnMsIG9yaWdpbmFsTWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJJbnZhbGlkIHZhbHVlcyBmb3IgXFxcIlwiLmNvbmNhdCh2YXJpYWJsZUlkLCBcIlxcXCI6IFxcXCJcIikuY29uY2F0KHZhbHVlLCBcIlxcXCIuIE9wdGlvbnMgYXJlIFxcXCJcIikuY29uY2F0KE9iamVjdC5rZXlzKG9wdGlvbnMpLmpvaW4oJ1wiLCBcIicpLCBcIlxcXCJcIiksIEVycm9yQ29kZS5JTlZBTElEX1ZBTFVFLCBvcmlnaW5hbE1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBJbnZhbGlkVmFsdWVFcnJvcjtcbn0oRm9ybWF0RXJyb3IpKTtcbmV4cG9ydCB7IEludmFsaWRWYWx1ZUVycm9yIH07XG52YXIgSW52YWxpZFZhbHVlVHlwZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnZhbGlkVmFsdWVUeXBlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW52YWxpZFZhbHVlVHlwZUVycm9yKHZhbHVlLCB0eXBlLCBvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiVmFsdWUgZm9yIFxcXCJcIi5jb25jYXQodmFsdWUsIFwiXFxcIiBtdXN0IGJlIG9mIHR5cGUgXCIpLmNvbmNhdCh0eXBlKSwgRXJyb3JDb2RlLklOVkFMSURfVkFMVUUsIG9yaWdpbmFsTWVzc2FnZSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEludmFsaWRWYWx1ZVR5cGVFcnJvcjtcbn0oRm9ybWF0RXJyb3IpKTtcbmV4cG9ydCB7IEludmFsaWRWYWx1ZVR5cGVFcnJvciB9O1xudmFyIE1pc3NpbmdWYWx1ZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNaXNzaW5nVmFsdWVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNaXNzaW5nVmFsdWVFcnJvcih2YXJpYWJsZUlkLCBvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiVGhlIGludGwgc3RyaW5nIGNvbnRleHQgdmFyaWFibGUgXFxcIlwiLmNvbmNhdCh2YXJpYWJsZUlkLCBcIlxcXCIgd2FzIG5vdCBwcm92aWRlZCB0byB0aGUgc3RyaW5nIFxcXCJcIikuY29uY2F0KG9yaWdpbmFsTWVzc2FnZSwgXCJcXFwiXCIpLCBFcnJvckNvZGUuTUlTU0lOR19WQUxVRSwgb3JpZ2luYWxNZXNzYWdlKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWlzc2luZ1ZhbHVlRXJyb3I7XG59KEZvcm1hdEVycm9yKSk7XG5leHBvcnQgeyBNaXNzaW5nVmFsdWVFcnJvciB9O1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDTyxJQUFJO0FBQ1gsQ0FBQyxTQUFVLFNBQVM7SUFDaEIsb0RBQW9EO0lBQ3BELFNBQVMsQ0FBQyxnQkFBZ0IsR0FBRztJQUM3QixpQ0FBaUM7SUFDakMsU0FBUyxDQUFDLGdCQUFnQixHQUFHO0lBQzdCLHdEQUF3RDtJQUN4RCxTQUFTLENBQUMsbUJBQW1CLEdBQUc7QUFDcEMsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUMvQixJQUFJLGNBQTZCLFNBQVUsTUFBTTtJQUM3QyxDQUFBLEdBQUEseUlBQUEsQ0FBQSxZQUFTLEFBQUQsRUFBRSxhQUFhO0lBQ3ZCLFNBQVMsWUFBWSxHQUFHLEVBQUUsSUFBSSxFQUFFLGVBQWU7UUFDM0MsSUFBSSxRQUFRLE9BQU8sSUFBSSxDQUFDLElBQUksRUFBRSxRQUFRLElBQUk7UUFDMUMsTUFBTSxJQUFJLEdBQUc7UUFDYixNQUFNLGVBQWUsR0FBRztRQUN4QixPQUFPO0lBQ1g7SUFDQSxZQUFZLFNBQVMsQ0FBQyxRQUFRLEdBQUc7UUFDN0IsT0FBTyxvQkFBb0IsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU87SUFDMUU7SUFDQSxPQUFPO0FBQ1gsRUFBRTs7QUFFRixJQUFJLG9CQUFtQyxTQUFVLE1BQU07SUFDbkQsQ0FBQSxHQUFBLHlJQUFBLENBQUEsWUFBUyxBQUFELEVBQUUsbUJBQW1CO0lBQzdCLFNBQVMsa0JBQWtCLFVBQVUsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLGVBQWU7UUFDbEUsT0FBTyxPQUFPLElBQUksQ0FBQyxJQUFJLEVBQUUsd0JBQXdCLE1BQU0sQ0FBQyxZQUFZLFVBQVUsTUFBTSxDQUFDLE9BQU8sc0JBQXNCLE1BQU0sQ0FBQyxPQUFPLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxTQUFTLE9BQU8sVUFBVSxhQUFhLEVBQUUsb0JBQW9CLElBQUk7SUFDeE47SUFDQSxPQUFPO0FBQ1gsRUFBRTs7QUFFRixJQUFJLHdCQUF1QyxTQUFVLE1BQU07SUFDdkQsQ0FBQSxHQUFBLHlJQUFBLENBQUEsWUFBUyxBQUFELEVBQUUsdUJBQXVCO0lBQ2pDLFNBQVMsc0JBQXNCLEtBQUssRUFBRSxJQUFJLEVBQUUsZUFBZTtRQUN2RCxPQUFPLE9BQU8sSUFBSSxDQUFDLElBQUksRUFBRSxlQUFlLE1BQU0sQ0FBQyxPQUFPLHVCQUF1QixNQUFNLENBQUMsT0FBTyxVQUFVLGFBQWEsRUFBRSxvQkFBb0IsSUFBSTtJQUNoSjtJQUNBLE9BQU87QUFDWCxFQUFFOztBQUVGLElBQUksb0JBQW1DLFNBQVUsTUFBTTtJQUNuRCxDQUFBLEdBQUEseUlBQUEsQ0FBQSxZQUFTLEFBQUQsRUFBRSxtQkFBbUI7SUFDN0IsU0FBUyxrQkFBa0IsVUFBVSxFQUFFLGVBQWU7UUFDbEQsT0FBTyxPQUFPLElBQUksQ0FBQyxJQUFJLEVBQUUsc0NBQXNDLE1BQU0sQ0FBQyxZQUFZLHdDQUF3QyxNQUFNLENBQUMsaUJBQWlCLE9BQU8sVUFBVSxhQUFhLEVBQUUsb0JBQW9CLElBQUk7SUFDOU07SUFDQSxPQUFPO0FBQ1gsRUFBRSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0MDc4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL2ludGwtbWVzc2FnZWZvcm1hdC9saWIvc3JjL2Zvcm1hdHRlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNBcmd1bWVudEVsZW1lbnQsIGlzRGF0ZUVsZW1lbnQsIGlzRGF0ZVRpbWVTa2VsZXRvbiwgaXNMaXRlcmFsRWxlbWVudCwgaXNOdW1iZXJFbGVtZW50LCBpc051bWJlclNrZWxldG9uLCBpc1BsdXJhbEVsZW1lbnQsIGlzUG91bmRFbGVtZW50LCBpc1NlbGVjdEVsZW1lbnQsIGlzVGFnRWxlbWVudCwgaXNUaW1lRWxlbWVudCwgfSBmcm9tICdAZm9ybWF0anMvaWN1LW1lc3NhZ2Vmb3JtYXQtcGFyc2VyJztcbmltcG9ydCB7IEVycm9yQ29kZSwgRm9ybWF0RXJyb3IsIEludmFsaWRWYWx1ZUVycm9yLCBJbnZhbGlkVmFsdWVUeXBlRXJyb3IsIE1pc3NpbmdWYWx1ZUVycm9yLCB9IGZyb20gJy4vZXJyb3InO1xuZXhwb3J0IHZhciBQQVJUX1RZUEU7XG4oZnVuY3Rpb24gKFBBUlRfVFlQRSkge1xuICAgIFBBUlRfVFlQRVtQQVJUX1RZUEVbXCJsaXRlcmFsXCJdID0gMF0gPSBcImxpdGVyYWxcIjtcbiAgICBQQVJUX1RZUEVbUEFSVF9UWVBFW1wib2JqZWN0XCJdID0gMV0gPSBcIm9iamVjdFwiO1xufSkoUEFSVF9UWVBFIHx8IChQQVJUX1RZUEUgPSB7fSkpO1xuZnVuY3Rpb24gbWVyZ2VMaXRlcmFsKHBhcnRzKSB7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMucmVkdWNlKGZ1bmN0aW9uIChhbGwsIHBhcnQpIHtcbiAgICAgICAgdmFyIGxhc3RQYXJ0ID0gYWxsW2FsbC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKCFsYXN0UGFydCB8fFxuICAgICAgICAgICAgbGFzdFBhcnQudHlwZSAhPT0gUEFSVF9UWVBFLmxpdGVyYWwgfHxcbiAgICAgICAgICAgIHBhcnQudHlwZSAhPT0gUEFSVF9UWVBFLmxpdGVyYWwpIHtcbiAgICAgICAgICAgIGFsbC5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFzdFBhcnQudmFsdWUgKz0gcGFydC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsO1xuICAgIH0sIFtdKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Zvcm1hdFhNTEVsZW1lbnRGbihlbCkge1xuICAgIHJldHVybiB0eXBlb2YgZWwgPT09ICdmdW5jdGlvbic7XG59XG4vLyBUT0RPKHNrZWxldG9uKTogYWRkIHNrZWxldG9uIHN1cHBvcnRcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUb1BhcnRzKGVscywgbG9jYWxlcywgZm9ybWF0dGVycywgZm9ybWF0cywgdmFsdWVzLCBjdXJyZW50UGx1cmFsVmFsdWUsIFxuLy8gRm9yIGRlYnVnZ2luZ1xub3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgLy8gSG90IHBhdGggZm9yIHN0cmFpZ2h0IHNpbXBsZSBtc2cgdHJhbnNsYXRpb25zXG4gICAgaWYgKGVscy5sZW5ndGggPT09IDEgJiYgaXNMaXRlcmFsRWxlbWVudChlbHNbMF0pKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogUEFSVF9UWVBFLmxpdGVyYWwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGVsc1swXS52YWx1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGVsc18xID0gZWxzOyBfaSA8IGVsc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZWwgPSBlbHNfMVtfaV07XG4gICAgICAgIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZyBwYXJ0cy5cbiAgICAgICAgaWYgKGlzTGl0ZXJhbEVsZW1lbnQoZWwpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogUEFSVF9UWVBFLmxpdGVyYWwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGVsLnZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyBwYXJ0IGJlIGxpdGVyYWwgdHlwZT9cbiAgICAgICAgLy8gUmVwbGFjZSBgI2AgaW4gcGx1cmFsIHJ1bGVzIHdpdGggdGhlIGFjdHVhbCBudW1lcmljIHZhbHVlLlxuICAgICAgICBpZiAoaXNQb3VuZEVsZW1lbnQoZWwpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRQbHVyYWxWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFBBUlRfVFlQRS5saXRlcmFsLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZm9ybWF0dGVycy5nZXROdW1iZXJGb3JtYXQobG9jYWxlcykuZm9ybWF0KGN1cnJlbnRQbHVyYWxWYWx1ZSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFyTmFtZSA9IGVsLnZhbHVlO1xuICAgICAgICAvLyBFbmZvcmNlIHRoYXQgYWxsIHJlcXVpcmVkIHZhbHVlcyBhcmUgcHJvdmlkZWQgYnkgdGhlIGNhbGxlci5cbiAgICAgICAgaWYgKCEodmFsdWVzICYmIHZhck5hbWUgaW4gdmFsdWVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdWYWx1ZUVycm9yKHZhck5hbWUsIG9yaWdpbmFsTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW3Zhck5hbWVdO1xuICAgICAgICBpZiAoaXNBcmd1bWVudEVsZW1lbnQoZWwpKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFN0cmluZyh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IFBBUlRfVFlQRS5saXRlcmFsIDogUEFSVF9UWVBFLm9iamVjdCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZvcm1hdCBwbHVyYWwgYW5kIHNlbGVjdCBwYXJ0cycgb3B0aW9uIOKAlCB3aGljaCBjYW4gYmUgYVxuICAgICAgICAvLyBuZXN0ZWQgcGF0dGVybiBzdHJ1Y3R1cmUuIFRoZSBjaG9vc2luZyBvZiB0aGUgb3B0aW9uIHRvIHVzZSBpc1xuICAgICAgICAvLyBhYnN0cmFjdGVkLWJ5IGFuZCBkZWxlZ2F0ZWQtdG8gdGhlIHBhcnQgaGVscGVyIG9iamVjdC5cbiAgICAgICAgaWYgKGlzRGF0ZUVsZW1lbnQoZWwpKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0eXBlb2YgZWwuc3R5bGUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBmb3JtYXRzLmRhdGVbZWwuc3R5bGVdXG4gICAgICAgICAgICAgICAgOiBpc0RhdGVUaW1lU2tlbGV0b24oZWwuc3R5bGUpXG4gICAgICAgICAgICAgICAgICAgID8gZWwuc3R5bGUucGFyc2VkT3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBQQVJUX1RZUEUubGl0ZXJhbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZm9ybWF0dGVyc1xuICAgICAgICAgICAgICAgICAgICAuZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlcywgc3R5bGUpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JtYXQodmFsdWUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUaW1lRWxlbWVudChlbCkpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHR5cGVvZiBlbC5zdHlsZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IGZvcm1hdHMudGltZVtlbC5zdHlsZV1cbiAgICAgICAgICAgICAgICA6IGlzRGF0ZVRpbWVTa2VsZXRvbihlbC5zdHlsZSlcbiAgICAgICAgICAgICAgICAgICAgPyBlbC5zdHlsZS5wYXJzZWRPcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIDogZm9ybWF0cy50aW1lLm1lZGl1bTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBQQVJUX1RZUEUubGl0ZXJhbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZm9ybWF0dGVyc1xuICAgICAgICAgICAgICAgICAgICAuZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlcywgc3R5bGUpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JtYXQodmFsdWUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1iZXJFbGVtZW50KGVsKSkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdHlwZW9mIGVsLnN0eWxlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gZm9ybWF0cy5udW1iZXJbZWwuc3R5bGVdXG4gICAgICAgICAgICAgICAgOiBpc051bWJlclNrZWxldG9uKGVsLnN0eWxlKVxuICAgICAgICAgICAgICAgICAgICA/IGVsLnN0eWxlLnBhcnNlZE9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc3R5bGUgJiYgc3R5bGUuc2NhbGUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICpcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdHlsZS5zY2FsZSB8fCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBQQVJUX1RZUEUubGl0ZXJhbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZm9ybWF0dGVyc1xuICAgICAgICAgICAgICAgICAgICAuZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZXMsIHN0eWxlKVxuICAgICAgICAgICAgICAgICAgICAuZm9ybWF0KHZhbHVlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGFnRWxlbWVudChlbCkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuLCB2YWx1ZV8xID0gZWwudmFsdWU7XG4gICAgICAgICAgICB2YXIgZm9ybWF0Rm4gPSB2YWx1ZXNbdmFsdWVfMV07XG4gICAgICAgICAgICBpZiAoIWlzRm9ybWF0WE1MRWxlbWVudEZuKGZvcm1hdEZuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVmFsdWVUeXBlRXJyb3IodmFsdWVfMSwgJ2Z1bmN0aW9uJywgb3JpZ2luYWxNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGZvcm1hdFRvUGFydHMoY2hpbGRyZW4sIGxvY2FsZXMsIGZvcm1hdHRlcnMsIGZvcm1hdHMsIHZhbHVlcywgY3VycmVudFBsdXJhbFZhbHVlKTtcbiAgICAgICAgICAgIHZhciBjaHVua3MgPSBmb3JtYXRGbihwYXJ0cy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudmFsdWU7IH0pKTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjaHVua3MpKSB7XG4gICAgICAgICAgICAgICAgY2h1bmtzID0gW2NodW5rc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIGNodW5rcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyBQQVJUX1RZUEUubGl0ZXJhbCA6IFBBUlRfVFlQRS5vYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2VsZWN0RWxlbWVudChlbCkpIHtcbiAgICAgICAgICAgIHZhciBvcHQgPSBlbC5vcHRpb25zW3ZhbHVlXSB8fCBlbC5vcHRpb25zLm90aGVyO1xuICAgICAgICAgICAgaWYgKCFvcHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFZhbHVlRXJyb3IoZWwudmFsdWUsIHZhbHVlLCBPYmplY3Qua2V5cyhlbC5vcHRpb25zKSwgb3JpZ2luYWxNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgZm9ybWF0VG9QYXJ0cyhvcHQudmFsdWUsIGxvY2FsZXMsIGZvcm1hdHRlcnMsIGZvcm1hdHMsIHZhbHVlcykpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUGx1cmFsRWxlbWVudChlbCkpIHtcbiAgICAgICAgICAgIHZhciBvcHQgPSBlbC5vcHRpb25zW1wiPVwiLmNvbmNhdCh2YWx1ZSldO1xuICAgICAgICAgICAgaWYgKCFvcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUludGwuUGx1cmFsUnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEVycm9yKFwiSW50bC5QbHVyYWxSdWxlcyBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQuXFxuVHJ5IHBvbHlmaWxsaW5nIGl0IHVzaW5nIFxcXCJAZm9ybWF0anMvaW50bC1wbHVyYWxydWxlc1xcXCJcXG5cIiwgRXJyb3JDb2RlLk1JU1NJTkdfSU5UTF9BUEksIG9yaWdpbmFsTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBydWxlID0gZm9ybWF0dGVyc1xuICAgICAgICAgICAgICAgICAgICAuZ2V0UGx1cmFsUnVsZXMobG9jYWxlcywgeyB0eXBlOiBlbC5wbHVyYWxUeXBlIH0pXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3QodmFsdWUgLSAoZWwub2Zmc2V0IHx8IDApKTtcbiAgICAgICAgICAgICAgICBvcHQgPSBlbC5vcHRpb25zW3J1bGVdIHx8IGVsLm9wdGlvbnMub3RoZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVmFsdWVFcnJvcihlbC52YWx1ZSwgdmFsdWUsIE9iamVjdC5rZXlzKGVsLm9wdGlvbnMpLCBvcmlnaW5hbE1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBmb3JtYXRUb1BhcnRzKG9wdC52YWx1ZSwgbG9jYWxlcywgZm9ybWF0dGVycywgZm9ybWF0cywgdmFsdWVzLCB2YWx1ZSAtIChlbC5vZmZzZXQgfHwgMCkpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZUxpdGVyYWwocmVzdWx0KTtcbn1cbiJdLCJuYW1lcyI6W10sIm1h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R0FBRyxPQUFPLEdBQUc7WUFDMUU7WUFDQSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxjQUFjLElBQUksS0FBSyxFQUFFLFNBQVMsWUFBWSxTQUFTO1lBQ2pGO1FBQ0o7UUFDQSxJQUFJLENBQUEsR0FBQSwrS0FBQSxDQUFBLGtCQUFlLEFBQUQsRUFBRSxLQUFLO1lBQ3JCLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPO1lBQ3ZDLElBQUksQ0FBQyxLQUFLO2dCQUNOLElBQUksQ0FBQyxLQUFLLFdBQVcsRUFBRTtvQkFDbkIsTUFBTSxJQUFJLCtKQUFBLENBQUEsY0FBVyxDQUFDLHFIQUFxSCwrSkFBQSxDQUFBLFlBQVMsQ0FBQyxnQkFBZ0IsRUFBRTtnQkFDM0s7Z0JBQ0EsSUFBSSxPQUFPLFdBQ04sY0FBYyxDQUFDLFNBQVM7b0JBQUUsTUFBTSxHQUFHLFVBQVU7Z0JBQUMsR0FDOUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDO2dCQUNuQyxNQUFNLEdBQUcsT0FBTyxDQUFDLEtBQUssSUFBSSxHQUFHLE9BQU8sQ0FBQyxLQUFLO1lBQzlDO1lBQ0EsSUFBSSxDQUFDLEtBQUs7Z0JBQ04sTUFBTSxJQUFJLCtKQUFBLENBQUEsb0JBQWlCLENBQUMsR0FBRyxLQUFLLEVBQUUsT0FBTyxPQUFPLElBQUksQ0FBQyxHQUFHLE9BQU8sR0FBRztZQUMxRTtZQUNBLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLGNBQWMsSUFBSSxLQUFLLEVBQUUsU0FBUyxZQUFZLFNBQVMsUUFBUSxRQUFRLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQztZQUNoSDtRQUNKO0lBQ0o7SUFDQSxPQUFPLGFBQWE7QUFDeEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDI0MywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9pbnRsLW1lc3NhZ2Vmb3JtYXQvbGliL3NyYy9jb3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTQsIFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5Db3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuXG5TZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuKi9cbmltcG9ydCB7IF9fYXNzaWduLCBfX3Jlc3QsIF9fc3ByZWFkQXJyYXkgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IG1lbW9pemUsIHN0cmF0ZWdpZXMgfSBmcm9tICdAZm9ybWF0anMvZmFzdC1tZW1vaXplJztcbmltcG9ydCB7IHBhcnNlLCB9IGZyb20gJ0Bmb3JtYXRqcy9pY3UtbWVzc2FnZWZvcm1hdC1wYXJzZXInO1xuaW1wb3J0IHsgZm9ybWF0VG9QYXJ0cywgUEFSVF9UWVBFLCB9IGZyb20gJy4vZm9ybWF0dGVycyc7XG4vLyAtLSBNZXNzYWdlRm9ybWF0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBtZXJnZUNvbmZpZyhjMSwgYzIpIHtcbiAgICBpZiAoIWMyKSB7XG4gICAgICAgIHJldHVybiBjMTtcbiAgICB9XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCAoYzEgfHwge30pKSwgKGMyIHx8IHt9KSksIE9iamVjdC5rZXlzKGMxKS5yZWR1Y2UoZnVuY3Rpb24gKGFsbCwgaykge1xuICAgICAgICBhbGxba10gPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYzFba10pLCAoYzJba10gfHwge30pKTtcbiAgICAgICAgcmV0dXJuIGFsbDtcbiAgICB9LCB7fSkpO1xufVxuZnVuY3Rpb24gbWVyZ2VDb25maWdzKGRlZmF1bHRDb25maWcsIGNvbmZpZ3MpIHtcbiAgICBpZiAoIWNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRDb25maWc7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhkZWZhdWx0Q29uZmlnKS5yZWR1Y2UoZnVuY3Rpb24gKGFsbCwgaykge1xuICAgICAgICBhbGxba10gPSBtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnW2tdLCBjb25maWdzW2tdKTtcbiAgICAgICAgcmV0dXJuIGFsbDtcbiAgICB9LCBfX2Fzc2lnbih7fSwgZGVmYXVsdENvbmZpZykpO1xufVxuZnVuY3Rpb24gY3JlYXRlRmFzdE1lbW9pemVDYWNoZShzdG9yZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlW2tleV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdEZvcm1hdHRlcnMoY2FjaGUpIHtcbiAgICBpZiAoY2FjaGUgPT09IHZvaWQgMCkgeyBjYWNoZSA9IHtcbiAgICAgICAgbnVtYmVyOiB7fSxcbiAgICAgICAgZGF0ZVRpbWU6IHt9LFxuICAgICAgICBwbHVyYWxSdWxlczoge30sXG4gICAgfTsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGdldE51bWJlckZvcm1hdDogbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3ICgoX2EgPSBJbnRsLk51bWJlckZvcm1hdCkuYmluZC5hcHBseShfYSwgX19zcHJlYWRBcnJheShbdm9pZCAwXSwgYXJncywgZmFsc2UpKSkoKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY2FjaGU6IGNyZWF0ZUZhc3RNZW1vaXplQ2FjaGUoY2FjaGUubnVtYmVyKSxcbiAgICAgICAgICAgIHN0cmF0ZWd5OiBzdHJhdGVnaWVzLnZhcmlhZGljLFxuICAgICAgICB9KSxcbiAgICAgICAgZ2V0RGF0ZVRpbWVGb3JtYXQ6IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoKF9hID0gSW50bC5EYXRlVGltZUZvcm1hdCkuYmluZC5hcHBseShfYSwgX19zcHJlYWRBcnJheShbdm9pZCAwXSwgYXJncywgZmFsc2UpKSkoKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY2FjaGU6IGNyZWF0ZUZhc3RNZW1vaXplQ2FjaGUoY2FjaGUuZGF0ZVRpbWUpLFxuICAgICAgICAgICAgc3RyYXRlZ3k6IHN0cmF0ZWdpZXMudmFyaWFkaWMsXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRQbHVyYWxSdWxlczogbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3ICgoX2EgPSBJbnRsLlBsdXJhbFJ1bGVzKS5iaW5kLmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5KFt2b2lkIDBdLCBhcmdzLCBmYWxzZSkpKSgpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBjYWNoZTogY3JlYXRlRmFzdE1lbW9pemVDYWNoZShjYWNoZS5wbHVyYWxSdWxlcyksXG4gICAgICAgICAgICBzdHJhdGVneTogc3RyYXRlZ2llcy52YXJpYWRpYyxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cbnZhciBJbnRsTWVzc2FnZUZvcm1hdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnRsTWVzc2FnZUZvcm1hdChtZXNzYWdlLCBsb2NhbGVzLCBvdmVycmlkZUZvcm1hdHMsIG9wdHMpIHtcbiAgICAgICAgaWYgKGxvY2FsZXMgPT09IHZvaWQgMCkgeyBsb2NhbGVzID0gSW50bE1lc3NhZ2VGb3JtYXQuZGVmYXVsdExvY2FsZTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmZvcm1hdHRlckNhY2hlID0ge1xuICAgICAgICAgICAgbnVtYmVyOiB7fSxcbiAgICAgICAgICAgIGRhdGVUaW1lOiB7fSxcbiAgICAgICAgICAgIHBsdXJhbFJ1bGVzOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBfdGhpcy5mb3JtYXRUb1BhcnRzKHZhbHVlcyk7XG4gICAgICAgICAgICAvLyBIb3QgcGF0aCBmb3Igc3RyYWlnaHQgc2ltcGxlIG1zZyB0cmFuc2xhdGlvbnNcbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydHNbMF0udmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFydHMucmVkdWNlKGZ1bmN0aW9uIChhbGwsIHBhcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbC5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgcGFydC50eXBlICE9PSBQQVJUX1RZUEUubGl0ZXJhbCB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgYWxsW2FsbC5sZW5ndGggLSAxXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsLnB1c2gocGFydC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbGxbYWxsLmxlbmd0aCAtIDFdICs9IHBhcnQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhbGw7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFswXSB8fCAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZm9ybWF0VG9QYXJ0cyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRUb1BhcnRzKF90aGlzLmFzdCwgX3RoaXMubG9jYWxlcywgX3RoaXMuZm9ybWF0dGVycywgX3RoaXMuZm9ybWF0cywgdmFsdWVzLCB1bmRlZmluZWQsIF90aGlzLm1lc3NhZ2UpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlc29sdmVkT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgIGxvY2FsZTogKChfYSA9IF90aGlzLnJlc29sdmVkTG9jYWxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgSW50bC5OdW1iZXJGb3JtYXQuc3VwcG9ydGVkTG9jYWxlc09mKF90aGlzLmxvY2FsZXMpWzBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0QXN0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYXN0OyB9O1xuICAgICAgICAvLyBEZWZpbmVkIGZpcnN0IGJlY2F1c2UgaXQncyB1c2VkIHRvIGJ1aWxkIHRoZSBmb3JtYXQgcGF0dGVybi5cbiAgICAgICAgdGhpcy5sb2NhbGVzID0gbG9jYWxlcztcbiAgICAgICAgdGhpcy5yZXNvbHZlZExvY2FsZSA9IEludGxNZXNzYWdlRm9ybWF0LnJlc29sdmVMb2NhbGUobG9jYWxlcyk7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoIUludGxNZXNzYWdlRm9ybWF0Ll9fcGFyc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnRsTWVzc2FnZUZvcm1hdC5fX3BhcnNlIG11c3QgYmUgc2V0IHRvIHByb2Nlc3MgYG1lc3NhZ2VgIG9mIHR5cGUgYHN0cmluZ2AnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYSA9IG9wdHMgfHwge30sIGZvcm1hdHRlcnMgPSBfYS5mb3JtYXR0ZXJzLCBwYXJzZU9wdHMgPSBfX3Jlc3QoX2EsIFtcImZvcm1hdHRlcnNcIl0pO1xuICAgICAgICAgICAgLy8gUGFyc2Ugc3RyaW5nIG1lc3NhZ2VzIGludG8gYW4gQVNULlxuICAgICAgICAgICAgdGhpcy5hc3QgPSBJbnRsTWVzc2FnZUZvcm1hdC5fX3BhcnNlKG1lc3NhZ2UsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJzZU9wdHMpLCB7IGxvY2FsZTogdGhpcy5yZXNvbHZlZExvY2FsZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFzdCA9IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuYXN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBtZXNzYWdlIG11c3QgYmUgcHJvdmlkZWQgYXMgYSBTdHJpbmcgb3IgQVNULicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBgZm9ybWF0c2AgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHRcbiAgICAgICAgLy8gZm9ybWF0cy5cbiAgICAgICAgdGhpcy5mb3JtYXRzID0gbWVyZ2VDb25maWdzKEludGxNZXNzYWdlRm9ybWF0LmZvcm1hdHMsIG92ZXJyaWRlRm9ybWF0cyk7XG4gICAgICAgIHRoaXMuZm9ybWF0dGVycyA9XG4gICAgICAgICAgICAob3B0cyAmJiBvcHRzLmZvcm1hdHRlcnMpIHx8IGNyZWF0ZURlZmF1bHRGb3JtYXR0ZXJzKHRoaXMuZm9ybWF0dGVyQ2FjaGUpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW50bE1lc3NhZ2VGb3JtYXQsIFwiZGVmYXVsdExvY2FsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFJbnRsTWVzc2FnZUZvcm1hdC5tZW1vaXplZERlZmF1bHRMb2NhbGUpIHtcbiAgICAgICAgICAgICAgICBJbnRsTWVzc2FnZUZvcm1hdC5tZW1vaXplZERlZmF1bHRMb2NhbGUgPVxuICAgICAgICAgICAgICAgICAgICBuZXcgSW50bC5OdW1iZXJGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSW50bE1lc3NhZ2VGb3JtYXQubWVtb2l6ZWREZWZhdWx0TG9jYWxlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgSW50bE1lc3NhZ2VGb3JtYXQubWVtb2l6ZWREZWZhdWx0TG9jYWxlID0gbnVsbDtcbiAgICBJbnRsTWVzc2FnZUZvcm1hdC5yZXNvbHZlTG9jYWxlID0gZnVuY3Rpb24gKGxvY2FsZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBJbnRsLkxvY2FsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3VwcG9ydGVkTG9jYWxlcyA9IEludGwuTnVtYmVyRm9ybWF0LnN1cHBvcnRlZExvY2FsZXNPZihsb2NhbGVzKTtcbiAgICAgICAgaWYgKHN1cHBvcnRlZExvY2FsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLkxvY2FsZShzdXBwb3J0ZWRMb2NhbGVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEludGwuTG9jYWxlKHR5cGVvZiBsb2NhbGVzID09PSAnc3RyaW5nJyA/IGxvY2FsZXMgOiBsb2NhbGVzWzBdKTtcbiAgICB9O1xuICAgIEludGxNZXNzYWdlRm9ybWF0Ll9fcGFyc2UgPSBwYXJzZTtcbiAgICAvLyBEZWZhdWx0IGZvcm1hdCBvcHRpb25zIHVzZWQgYXMgdGhlIHByb3RvdHlwZSBvZiB0aGUgYGZvcm1hdHNgIHByb3ZpZGVkIHRvIHRoZVxuICAgIC8vIGNvbnN0cnVjdG9yLiBUaGVzZSBhcmUgdXNlZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgaW50ZXJuYWwgSW50bC5OdW1iZXJGb3JtYXRcbiAgICAvLyBhbmQgSW50bC5EYXRlVGltZUZvcm1hdCBpbnN0YW5jZXMuXG4gICAgSW50bE1lc3NhZ2VGb3JtYXQuZm9ybWF0cyA9IHtcbiAgICAgICAgbnVtYmVyOiB7XG4gICAgICAgICAgICBpbnRlZ2VyOiB7XG4gICAgICAgICAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN1cnJlbmN5OiB7XG4gICAgICAgICAgICAgICAgc3R5bGU6ICdjdXJyZW5jeScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGVyY2VudDoge1xuICAgICAgICAgICAgICAgIHN0eWxlOiAncGVyY2VudCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBkYXRlOiB7XG4gICAgICAgICAgICBzaG9ydDoge1xuICAgICAgICAgICAgICAgIG1vbnRoOiAnbnVtZXJpYycsXG4gICAgICAgICAgICAgICAgZGF5OiAnbnVtZXJpYycsXG4gICAgICAgICAgICAgICAgeWVhcjogJzItZGlnaXQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lZGl1bToge1xuICAgICAgICAgICAgICAgIG1vbnRoOiAnc2hvcnQnLFxuICAgICAgICAgICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdudW1lcmljJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb25nOiB7XG4gICAgICAgICAgICAgICAgbW9udGg6ICdsb25nJyxcbiAgICAgICAgICAgICAgICBkYXk6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVsbDoge1xuICAgICAgICAgICAgICAgIHdlZWtkYXk6ICdsb25nJyxcbiAgICAgICAgICAgICAgICBtb250aDogJ2xvbmcnLFxuICAgICAgICAgICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdudW1lcmljJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWU6IHtcbiAgICAgICAgICAgIHNob3J0OiB7XG4gICAgICAgICAgICAgICAgaG91cjogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIG1pbnV0ZTogJ251bWVyaWMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lZGl1bToge1xuICAgICAgICAgICAgICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICBtaW51dGU6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICBzZWNvbmQ6ICdudW1lcmljJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb25nOiB7XG4gICAgICAgICAgICAgICAgaG91cjogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIG1pbnV0ZTogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIHNlY29uZDogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIHRpbWVab25lTmFtZTogJ3Nob3J0JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdWxsOiB7XG4gICAgICAgICAgICAgICAgaG91cjogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIG1pbnV0ZTogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIHNlY29uZDogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIHRpbWVab25lTmFtZTogJ3Nob3J0JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gSW50bE1lc3NhZ2VGb3JtYXQ7XG59KCkpO1xuZXhwb3J0IHsgSW50bE1lc3NhZ2VGb3JtYXQgfTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7OztBQUlBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUNBLDRFQUE0RTtBQUM1RSxTQUFTLFlBQVksRUFBRSxFQUFFLEVBQUU7SUFDdkIsSUFBSSxDQUFDLElBQUk7UUFDTCxP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TyxJQUFJLEtBQUssTUFBTSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7UUFDOUM7UUFDQSxPQUFPLElBQUksS0FBSyxNQUFNLENBQUMsT0FBTyxZQUFZLFdBQVcsVUFBVSxPQUFPLENBQUMsRUFBRTtJQUM3RTtJQUNBLGtCQUFrQixPQUFPLEdBQUcsK0xBQUEsQ0FBQSxRQUFLO0lBQ2pDLGdGQUFnRjtJQUNoRiwrRUFBK0U7SUFDL0UscUNBQXFDO0lBQ3JDLGtCQUFrQixPQUFPLEdBQUc7UUFDeEIsUUFBUTtZQUNKLFNBQVM7Z0JBQ0wsdUJBQXVCO1lBQzNCO1lBQ0EsVUFBVTtnQkFDTixPQUFPO1lBQ1g7WUFDQSxTQUFTO2dCQUNMLE9BQU87WUFDWDtRQUNKO1FBQ0EsTUFBTTtZQUNGLE9BQU87Z0JBQ0gsT0FBTztnQkFDUCxLQUFLO2dCQUNMLE1BQU07WUFDVjtZQUNBLFFBQVE7Z0JBQ0osT0FBTztnQkFDUCxLQUFLO2dCQUNMLE1BQU07WUFDVjtZQUNBLE1BQU07Z0JBQ0YsT0FBTztnQkFDUCxLQUFLO2dCQUNMLE1BQU07WUFDVjtZQUNBLE1BQU07Z0JBQ0YsU0FBUztnQkFDVCxPQUFPO2dCQUNQLEtBQUs7Z0JBQ0wsTUFBTTtZQUNWO1FBQ0o7UUFDQSxNQUFNO1lBQ0YsT0FBTztnQkFDSCxNQUFNO2dCQUNOLFFBQVE7WUFDWjtZQUNBLFFBQVE7Z0JBQ0osTUFBTTtnQkFDTixRQUFRO2dCQUNSLFFBQVE7WUFDWjtZQUNBLE1BQU07Z0JBQ0YsTUFBTTtnQkFDTixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsY0FBYztZQUNsQjtZQUNBLE1BQU07Z0JBQ0YsTUFBTTtnQkFDTixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsY0FBYztZQUNsQjtRQUNKO0lBQ0o7SUFDQSxPQUFPO0FBQ1giLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNDUwMSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2VzbS9kZXZlbG9wbWVudC9pbml0aWFsaXplQ29uZmlnLUNSRDZldXVLLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEludGxNZXNzYWdlRm9ybWF0IH0gZnJvbSAnaW50bC1tZXNzYWdlZm9ybWF0JztcbmltcG9ydCB7IGlzVmFsaWRFbGVtZW50LCBjbG9uZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBtZW1vaXplLCBzdHJhdGVnaWVzIH0gZnJvbSAnQGZvcm1hdGpzL2Zhc3QtbWVtb2l6ZSc7XG5cbmNsYXNzIEludGxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY29kZSwgb3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBjb2RlO1xuICAgIGlmIChvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICAgIG1lc3NhZ2UgKz0gJzogJyArIG9yaWdpbmFsTWVzc2FnZTtcbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICBpZiAob3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG9yaWdpbmFsTWVzc2FnZTtcbiAgICB9XG4gIH1cbn1cblxudmFyIEludGxFcnJvckNvZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEludGxFcnJvckNvZGUpIHtcbiAgSW50bEVycm9yQ29kZVtcIk1JU1NJTkdfTUVTU0FHRVwiXSA9IFwiTUlTU0lOR19NRVNTQUdFXCI7XG4gIEludGxFcnJvckNvZGVbXCJNSVNTSU5HX0ZPUk1BVFwiXSA9IFwiTUlTU0lOR19GT1JNQVRcIjtcbiAgSW50bEVycm9yQ29kZVtcIkVOVklST05NRU5UX0ZBTExCQUNLXCJdID0gXCJFTlZJUk9OTUVOVF9GQUxMQkFDS1wiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5TVUZGSUNJRU5UX1BBVEhcIl0gPSBcIklOU1VGRklDSUVOVF9QQVRIXCI7XG4gIEludGxFcnJvckNvZGVbXCJJTlZBTElEX01FU1NBR0VcIl0gPSBcIklOVkFMSURfTUVTU0FHRVwiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5WQUxJRF9LRVlcIl0gPSBcIklOVkFMSURfS0VZXCI7XG4gIEludGxFcnJvckNvZGVbXCJGT1JNQVRUSU5HX0VSUk9SXCJdID0gXCJGT1JNQVRUSU5HX0VSUk9SXCI7XG4gIHJldHVybiBJbnRsRXJyb3JDb2RlO1xufShJbnRsRXJyb3JDb2RlIHx8IHt9KTtcblxuLyoqXG4gKiBgaW50bC1tZXNzYWdlZm9ybWF0YCB1c2VzIHNlcGFyYXRlIGtleXMgZm9yIGBkYXRlYCBhbmQgYHRpbWVgLCBidXQgdGhlcmUnc1xuICogb25seSBvbmUgbmF0aXZlIEFQSTogYEludGwuRGF0ZVRpbWVGb3JtYXRgLiBBZGRpdGlvbmFsbHkgeW91IG1pZ2h0IHdhbnQgdG9cbiAqIGluY2x1ZGUgYm90aCBhIHRpbWUgYW5kIGEgZGF0ZSBpbiBhIHZhbHVlLCB0aGVyZWZvcmUgdGhlIHNlcGFyYXRpb24gZG9lc24ndFxuICogc2VlbSBzbyB1c2VmdWwuIFdlIG9mZmVyIGEgc2luZ2xlIGBkYXRlVGltZWAgbmFtZXNwYWNlIGluc3RlYWQsIGJ1dCB3ZSBoYXZlXG4gKiB0byBjb252ZXJ0IHRoZSBmb3JtYXQgYmVmb3JlIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIGNhbiBiZSB1c2VkLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0Rm9ybWF0c1RvSW50bE1lc3NhZ2VGb3JtYXQoZ2xvYmFsRm9ybWF0cywgaW5saW5lRm9ybWF0cywgdGltZVpvbmUpIHtcbiAgY29uc3QgbWZEYXRlRGVmYXVsdHMgPSBJbnRsTWVzc2FnZUZvcm1hdC5mb3JtYXRzLmRhdGU7XG4gIGNvbnN0IG1mVGltZURlZmF1bHRzID0gSW50bE1lc3NhZ2VGb3JtYXQuZm9ybWF0cy50aW1lO1xuICBjb25zdCBkYXRlVGltZUZvcm1hdHMgPSB7XG4gICAgLi4uZ2xvYmFsRm9ybWF0cz8uZGF0ZVRpbWUsXG4gICAgLi4uaW5saW5lRm9ybWF0cz8uZGF0ZVRpbWVcbiAgfTtcbiAgY29uc3QgYWxsRm9ybWF0cyA9IHtcbiAgICBkYXRlOiB7XG4gICAgICAuLi5tZkRhdGVEZWZhdWx0cyxcbiAgICAgIC4uLmRhdGVUaW1lRm9ybWF0c1xuICAgIH0sXG4gICAgdGltZToge1xuICAgICAgLi4ubWZUaW1lRGVmYXVsdHMsXG4gICAgICAuLi5kYXRlVGltZUZvcm1hdHNcbiAgICB9LFxuICAgIG51bWJlcjoge1xuICAgICAgLi4uZ2xvYmFsRm9ybWF0cz8ubnVtYmVyLFxuICAgICAgLi4uaW5saW5lRm9ybWF0cz8ubnVtYmVyXG4gICAgfVxuICAgIC8vIChsaXN0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUNVIG1lc3NhZ2VzKVxuICB9O1xuICBpZiAodGltZVpvbmUpIHtcbiAgICAvLyBUaGUgb25seSB3YXkgdG8gc2V0IGEgdGltZSB6b25lIHdpdGggYGludGwtbWVzc2FnZWZvcm1hdGAgaXMgdG8gbWVyZ2UgaXQgaW50byB0aGUgZm9ybWF0c1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtYXRqcy9mb3JtYXRqcy9ibG9iLzgyNTZjNTI3MTUwNWNmMjYwNmU0OGUzYzk3ZWNkZDE2ZWRlNGYxYjUvcGFja2FnZXMvaW50bC9zcmMvbWVzc2FnZS50cyNMMTVcbiAgICBbJ2RhdGUnLCAndGltZSddLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0cyA9IGFsbEZvcm1hdHNbcHJvcGVydHldO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZm9ybWF0cykpIHtcbiAgICAgICAgZm9ybWF0c1trZXldID0ge1xuICAgICAgICAgIHRpbWVab25lLFxuICAgICAgICAgIC4uLnZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGFsbEZvcm1hdHM7XG59XG5cbmZ1bmN0aW9uIGpvaW5QYXRoKC4uLnBhcnRzKSB7XG4gIHJldHVybiBwYXJ0cy5maWx0ZXIoQm9vbGVhbikuam9pbignLicpO1xufVxuXG4vKipcbiAqIENvbnRhaW5zIGRlZmF1bHRzIHRoYXQgYXJlIHVzZWQgZm9yIGFsbCBlbnRyeSBwb2ludHMgaW50byB0aGUgY29yZS5cbiAqIFNlZSBhbHNvIGBJbml0aWFsaXplZEludGxDb25maWd1cmF0aW9uYC5cbiAqL1xuXG5mdW5jdGlvbiBkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrKHByb3BzKSB7XG4gIHJldHVybiBqb2luUGF0aChwcm9wcy5uYW1lc3BhY2UsIHByb3BzLmtleSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihlcnJvcikge1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG4gIHJldHVybiB7XG4gICAgZGF0ZVRpbWU6IHt9LFxuICAgIG51bWJlcjoge30sXG4gICAgbWVzc2FnZToge30sXG4gICAgcmVsYXRpdmVUaW1lOiB7fSxcbiAgICBwbHVyYWxSdWxlczoge30sXG4gICAgbGlzdDoge30sXG4gICAgZGlzcGxheU5hbWVzOiB7fVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTWVtb0NhY2hlKHN0b3JlKSB7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KGtleSkge1xuICAgICAgICAgIHJldHVybiBzdG9yZVtrZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHN0b3JlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtZW1vRm4oZm4sIGNhY2hlKSB7XG4gIHJldHVybiBtZW1vaXplKGZuLCB7XG4gICAgY2FjaGU6IGNyZWF0ZU1lbW9DYWNoZShjYWNoZSksXG4gICAgc3RyYXRlZ3k6IHN0cmF0ZWdpZXMudmFyaWFkaWNcbiAgfSk7XG59XG5mdW5jdGlvbiBtZW1vQ29uc3RydWN0b3IoQ29uc3RydWN0b3JGbiwgY2FjaGUpIHtcbiAgcmV0dXJuIG1lbW9GbigoLi4uYXJncykgPT4gbmV3IENvbnN0cnVjdG9yRm4oLi4uYXJncyksIGNhY2hlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludGxGb3JtYXR0ZXJzKGNhY2hlKSB7XG4gIGNvbnN0IGdldERhdGVUaW1lRm9ybWF0ID0gbWVtb0NvbnN0cnVjdG9yKEludGwuRGF0ZVRpbWVGb3JtYXQsIGNhY2hlLmRhdGVUaW1lKTtcbiAgY29uc3QgZ2V0TnVtYmVyRm9ybWF0ID0gbWVtb0NvbnN0cnVjdG9yKEludGwuTnVtYmVyRm9ybWF0LCBjYWNoZS5udW1iZXIpO1xuICBjb25zdCBnZXRQbHVyYWxSdWxlcyA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLlBsdXJhbFJ1bGVzLCBjYWNoZS5wbHVyYWxSdWxlcyk7XG4gIGNvbnN0IGdldFJlbGF0aXZlVGltZUZvcm1hdCA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLlJlbGF0aXZlVGltZUZvcm1hdCwgY2FjaGUucmVsYXRpdmVUaW1lKTtcbiAgY29uc3QgZ2V0TGlzdEZvcm1hdCA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLkxpc3RGb3JtYXQsIGNhY2hlLmxpc3QpO1xuICBjb25zdCBnZXREaXNwbGF5TmFtZXMgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5EaXNwbGF5TmFtZXMsIGNhY2hlLmRpc3BsYXlOYW1lcyk7XG4gIHJldHVybiB7XG4gICAgZ2V0RGF0ZVRpbWVGb3JtYXQsXG4gICAgZ2V0TnVtYmVyRm9ybWF0LFxuICAgIGdldFBsdXJhbFJ1bGVzLFxuICAgIGdldFJlbGF0aXZlVGltZUZvcm1hdCxcbiAgICBnZXRMaXN0Rm9ybWF0LFxuICAgIGdldERpc3BsYXlOYW1lc1xuICB9O1xufVxuXG4vLyBQbGFjZWQgaGVyZSBmb3IgaW1wcm92ZWQgdHJlZSBzaGFraW5nLiBTb21laG93IHdoZW4gdGhpcyBpcyBwbGFjZWQgaW5cbi8vIGBmb3JtYXR0ZXJzLnRzeGAsIHRoZW4gaXQgY2FuJ3QgYmUgc2hha2VuIG9mZiBmcm9tIGBuZXh0LWludGxgLlxuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZUZvcm1hdHRlcihjYWNoZSwgaW50bEZvcm1hdHRlcnMpIHtcbiAgY29uc3QgZ2V0TWVzc2FnZUZvcm1hdCA9IG1lbW9GbigoLi4uYXJncykgPT4gbmV3IEludGxNZXNzYWdlRm9ybWF0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIHtcbiAgICBmb3JtYXR0ZXJzOiBpbnRsRm9ybWF0dGVycyxcbiAgICAuLi5hcmdzWzNdXG4gIH0pLCBjYWNoZS5tZXNzYWdlKTtcbiAgcmV0dXJuIGdldE1lc3NhZ2VGb3JtYXQ7XG59XG5mdW5jdGlvbiByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBrZXksIG5hbWVzcGFjZSkge1xuICBjb25zdCBmdWxsS2V5ID0gam9pblBhdGgobmFtZXNwYWNlLCBrZXkpO1xuICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBtZXNzYWdlcyBhdmFpbGFibGUgYXQgXFxgJHtuYW1lc3BhY2V9XFxgLmAgKTtcbiAgfVxuICBsZXQgbWVzc2FnZSA9IG1lc3NhZ2VzO1xuICBrZXkuc3BsaXQoJy4nKS5mb3JFYWNoKHBhcnQgPT4ge1xuICAgIGNvbnN0IG5leHQgPSBtZXNzYWdlW3BhcnRdO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAocGFydCA9PSBudWxsIHx8IG5leHQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcmVzb2x2ZSBcXGAke2Z1bGxLZXl9XFxgIGluIG1lc3NhZ2VzIGZvciBsb2NhbGUgXFxgJHtsb2NhbGV9XFxgLmAgKTtcbiAgICB9XG4gICAgbWVzc2FnZSA9IG5leHQ7XG4gIH0pO1xuICByZXR1cm4gbWVzc2FnZTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVUcmFuc2xhdGlvblZhbHVlcyh2YWx1ZXMpIHtcbiAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2lzc3Vlcy8xNDY3XG4gIGNvbnN0IHRyYW5zZm9ybWVkVmFsdWVzID0ge307XG4gIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICBsZXQgdHJhbnNmb3JtZWQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJhbnNmb3JtZWQgPSBjaHVua3MgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZShjaHVua3MpO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL2lzVmFsaWRFbGVtZW50KHJlc3VsdCkgPyAvKiNfX1BVUkVfXyovY2xvbmVFbGVtZW50KHJlc3VsdCwge1xuICAgICAgICAgIGtleToga2V5ICsgaW5kZXgrK1xuICAgICAgICB9KSA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zZm9ybWVkID0gdmFsdWU7XG4gICAgfVxuICAgIHRyYW5zZm9ybWVkVmFsdWVzW2tleV0gPSB0cmFuc2Zvcm1lZDtcbiAgfSk7XG4gIHJldHVybiB0cmFuc2Zvcm1lZFZhbHVlcztcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VzT3JFcnJvcihsb2NhbGUsIG1lc3NhZ2VzLCBuYW1lc3BhY2UsIG9uRXJyb3IgPSBkZWZhdWx0T25FcnJvcikge1xuICB0cnkge1xuICAgIGlmICghbWVzc2FnZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbWVzc2FnZXMgd2VyZSBjb25maWd1cmVkLmAgKTtcbiAgICB9XG4gICAgY29uc3QgcmV0cmlldmVkTWVzc2FnZXMgPSBuYW1lc3BhY2UgPyByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBuYW1lc3BhY2UpIDogbWVzc2FnZXM7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIGlmICghcmV0cmlldmVkTWVzc2FnZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbWVzc2FnZXMgZm9yIG5hbWVzcGFjZSBcXGAke25hbWVzcGFjZX1cXGAgZm91bmQuYCApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0cmlldmVkTWVzc2FnZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgaW50bEVycm9yID0gbmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLk1JU1NJTkdfTUVTU0FHRSwgZXJyb3IubWVzc2FnZSk7XG4gICAgb25FcnJvcihpbnRsRXJyb3IpO1xuICAgIHJldHVybiBpbnRsRXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBsYWluTWVzc2FnZShjYW5kaWRhdGUsIHZhbHVlcykge1xuICB7XG4gICAgLy8gS2VlcCBmYXN0IHBhdGggaW4gZGV2ZWxvcG1lbnRcbiAgICBpZiAodmFsdWVzKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgLy8gRGVzcGl0ZSBwb3RlbnRpYWxseSBubyB2YWx1ZXMgYmVpbmcgYXZhaWxhYmxlLCB0aGVyZSBjYW4gc3RpbGwgYmVcbiAgICAvLyBwbGFjZWhvbGRlcnMgaW4gdGhlIG1lc3NhZ2UgaWYgdGhlIHVzZXIgaGFzIGZvcmdvdHRlbiB0byBwcm92aWRlXG4gICAgLy8gdmFsdWVzLiBJbiB0aGlzIGNhc2Ugd2UgY29tcGlsZSB0aGUgbWVzc2FnZSB0byByZWNlaXZlIGFuIGVycm9yLlxuICAgIGNvbnN0IHVuZXNjYXBlZE1lc3NhZ2UgPSBjYW5kaWRhdGUucmVwbGFjZSgvJyhbe31dKS9naSwgJyQxJyk7XG4gICAgY29uc3QgaGFzUGxhY2Vob2xkZXJzID0gLzx8ey8udGVzdCh1bmVzY2FwZWRNZXNzYWdlKTtcbiAgICBpZiAoIWhhc1BsYWNlaG9sZGVycykge1xuICAgICAgcmV0dXJuIHVuZXNjYXBlZE1lc3NhZ2U7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVCYXNlVHJhbnNsYXRvcihjb25maWcpIHtcbiAgY29uc3QgbWVzc2FnZXNPckVycm9yID0gZ2V0TWVzc2FnZXNPckVycm9yKGNvbmZpZy5sb2NhbGUsIGNvbmZpZy5tZXNzYWdlcywgY29uZmlnLm5hbWVzcGFjZSwgY29uZmlnLm9uRXJyb3IpO1xuICByZXR1cm4gY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsKHtcbiAgICAuLi5jb25maWcsXG4gICAgbWVzc2FnZXNPckVycm9yXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsKHtcbiAgY2FjaGUsXG4gIGZvcm1hdHM6IGdsb2JhbEZvcm1hdHMsXG4gIGZvcm1hdHRlcnMsXG4gIGdldE1lc3NhZ2VGYWxsYmFjayA9IGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2ssXG4gIGxvY2FsZSxcbiAgbWVzc2FnZXNPckVycm9yLFxuICBuYW1lc3BhY2UsXG4gIG9uRXJyb3IsXG4gIHRpbWVab25lXG59KSB7XG4gIGNvbnN0IGhhc01lc3NhZ2VzRXJyb3IgPSBtZXNzYWdlc09yRXJyb3IgaW5zdGFuY2VvZiBJbnRsRXJyb3I7XG4gIGZ1bmN0aW9uIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgY29kZSwgbWVzc2FnZSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEludGxFcnJvcihjb2RlLCBtZXNzYWdlKTtcbiAgICBvbkVycm9yKGVycm9yKTtcbiAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgIGVycm9yLFxuICAgICAga2V5LFxuICAgICAgbmFtZXNwYWNlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNsYXRlQmFzZUZuKC8qKiBVc2UgYSBkb3QgdG8gaW5kaWNhdGUgYSBsZXZlbCBvZiBuZXN0aW5nIChlLmcuIGBuYW1lc3BhY2UubmVzdGVkTGFiZWxgKS4gKi9cbiAga2V5LCAvKiogS2V5IHZhbHVlIHBhaXJzIGZvciB2YWx1ZXMgdG8gaW50ZXJwb2xhdGUgaW50byB0aGUgbWVzc2FnZS4gKi9cbiAgdmFsdWVzLCAvKiogUHJvdmlkZSBjdXN0b20gZm9ybWF0cyBmb3IgbnVtYmVycywgZGF0ZXMgYW5kIHRpbWVzLiAqL1xuICBmb3JtYXRzKSB7XG4gICAgaWYgKGhhc01lc3NhZ2VzRXJyb3IpIHtcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQgdGhpcyBkdXJpbmcgcmVuZGVyXG4gICAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgICAgZXJyb3I6IG1lc3NhZ2VzT3JFcnJvcixcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IG1lc3NhZ2VzT3JFcnJvcjtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICB0cnkge1xuICAgICAgbWVzc2FnZSA9IHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIGtleSwgbmFtZXNwYWNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnKSB7XG4gICAgICBsZXQgY29kZSwgZXJyb3JNZXNzYWdlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcbiAgICAgICAgY29kZSA9IEludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFO1xuICAgICAgICB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gYE1lc3NhZ2UgYXQgXFxgJHtqb2luUGF0aChuYW1lc3BhY2UsIGtleSl9XFxgIHJlc29sdmVkIHRvIGFuIGFycmF5LCBidXQgb25seSBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuIFNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy91c2FnZS9tZXNzYWdlcyNhcnJheXMtb2YtbWVzc2FnZXNgO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlID0gSW50bEVycm9yQ29kZS5JTlNVRkZJQ0lFTlRfUEFUSDtcbiAgICAgICAge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGBNZXNzYWdlIGF0IFxcYCR7am9pblBhdGgobmFtZXNwYWNlLCBrZXkpfVxcYCByZXNvbHZlZCB0byBhbiBvYmplY3QsIGJ1dCBvbmx5IHN0cmluZ3MgYXJlIHN1cHBvcnRlZC4gVXNlIGEgXFxgLlxcYCB0byByZXRyaWV2ZSBuZXN0ZWQgbWVzc2FnZXMuIFNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy91c2FnZS9tZXNzYWdlcyNzdHJ1Y3R1cmluZy1tZXNzYWdlc2A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGNvZGUsIGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIGxldCBtZXNzYWdlRm9ybWF0O1xuXG4gICAgLy8gSG90IHBhdGggdGhhdCBhdm9pZHMgY3JlYXRpbmcgYW4gYEludGxNZXNzYWdlRm9ybWF0YCBpbnN0YW5jZVxuICAgIGNvbnN0IHBsYWluTWVzc2FnZSA9IGdldFBsYWluTWVzc2FnZShtZXNzYWdlLCB2YWx1ZXMpO1xuICAgIGlmIChwbGFpbk1lc3NhZ2UpIHJldHVybiBwbGFpbk1lc3NhZ2U7XG5cbiAgICAvLyBMYXp5IGluaXQgdGhlIG1lc3NhZ2UgZm9ybWF0dGVyIGZvciBiZXR0ZXIgdHJlZVxuICAgIC8vIHNoYWtpbmcgaW4gY2FzZSBtZXNzYWdlIGZvcm1hdHRpbmcgaXMgbm90IHVzZWQuXG4gICAgaWYgKCFmb3JtYXR0ZXJzLmdldE1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgIGZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdCA9IGNyZWF0ZU1lc3NhZ2VGb3JtYXR0ZXIoY2FjaGUsIGZvcm1hdHRlcnMpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbWVzc2FnZUZvcm1hdCA9IGZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdChtZXNzYWdlLCBsb2NhbGUsIGNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdChnbG9iYWxGb3JtYXRzLCBmb3JtYXRzLCB0aW1lWm9uZSksIHtcbiAgICAgICAgZm9ybWF0dGVyczoge1xuICAgICAgICAgIC4uLmZvcm1hdHRlcnMsXG4gICAgICAgICAgZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlcywgb3B0aW9ucykge1xuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2lzc3Vlcy80Mjc5XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXREYXRlVGltZUZvcm1hdChsb2NhbGVzLCB7XG4gICAgICAgICAgICAgIHRpbWVab25lLFxuICAgICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCB0aHJvd25FcnJvciA9IGVycm9yO1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0UsIHRocm93bkVycm9yLm1lc3NhZ2UgKyAoJ29yaWdpbmFsTWVzc2FnZScgaW4gdGhyb3duRXJyb3IgPyBgICgke3Rocm93bkVycm9yLm9yaWdpbmFsTWVzc2FnZX0pYCA6ICcnKSApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IG1lc3NhZ2VGb3JtYXQuZm9ybWF0KFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgaW50bC1tZXNzYWdlZm9ybWF0YCBleHBlY3RzIGEgZGlmZmVyZW50IGZvcm1hdFxuICAgICAgLy8gZm9yIHJpY2ggdGV4dCBlbGVtZW50cyBzaW5jZSBhIHJlY2VudCBtaW5vciB1cGRhdGUuIFRoaXNcbiAgICAgIC8vIG5lZWRzIHRvIGJlIGV2YWx1YXRlZCBpbiBkZXRhaWwsIHBvc3NpYmx5IGFsc28gaW4gcmVnYXJkc1xuICAgICAgLy8gdG8gYmUgYWJsZSB0byBmb3JtYXQgdG8gcGFydHMuXG4gICAgICB2YWx1ZXMgPyBwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXModmFsdWVzKSA6IHZhbHVlcyk7XG4gICAgICBpZiAoZm9ybWF0dGVkTWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZvcm1hdCBcXGAke2tleX1cXGAgaW4gJHtuYW1lc3BhY2UgPyBgbmFtZXNwYWNlIFxcYCR7bmFtZXNwYWNlfVxcYGAgOiAnbWVzc2FnZXMnfWAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gTGltaXQgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSB0byByZXR1cm4gc3RyaW5ncyBvciBSZWFjdCBlbGVtZW50c1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9pc1ZhbGlkRWxlbWVudChmb3JtYXR0ZWRNZXNzYWdlKSB8fFxuICAgICAgLy8gQXJyYXlzIG9mIFJlYWN0IGVsZW1lbnRzXG4gICAgICBBcnJheS5pc0FycmF5KGZvcm1hdHRlZE1lc3NhZ2UpIHx8IHR5cGVvZiBmb3JtYXR0ZWRNZXNzYWdlID09PSAnc3RyaW5nJyA/IGZvcm1hdHRlZE1lc3NhZ2UgOiBTdHJpbmcoZm9ybWF0dGVkTWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIEludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUZuKC8qKiBVc2UgYSBkb3QgdG8gaW5kaWNhdGUgYSBsZXZlbCBvZiBuZXN0aW5nIChlLmcuIGBuYW1lc3BhY2UubmVzdGVkTGFiZWxgKS4gKi9cbiAga2V5LCAvKiogS2V5IHZhbHVlIHBhaXJzIGZvciB2YWx1ZXMgdG8gaW50ZXJwb2xhdGUgaW50byB0aGUgbWVzc2FnZS4gKi9cbiAgdmFsdWVzLCAvKiogUHJvdmlkZSBjdXN0b20gZm9ybWF0cyBmb3IgbnVtYmVycywgZGF0ZXMgYW5kIHRpbWVzLiAqL1xuICBmb3JtYXRzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHJhbnNsYXRlQmFzZUZuKGtleSwgdmFsdWVzLCBmb3JtYXRzKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIEludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFLCBgVGhlIG1lc3NhZ2UgXFxgJHtrZXl9XFxgIGluICR7bmFtZXNwYWNlID8gYG5hbWVzcGFjZSBcXGAke25hbWVzcGFjZX1cXGBgIDogJ21lc3NhZ2VzJ30gZGlkbid0IHJlc29sdmUgdG8gYSBzdHJpbmcuIElmIHlvdSB3YW50IHRvIGZvcm1hdCByaWNoIHRleHQsIHVzZSBcXGB0LnJpY2hcXGAgaW5zdGVhZC5gICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHJhbnNsYXRlRm4ucmljaCA9IHRyYW5zbGF0ZUJhc2VGbjtcblxuICAvLyBBdWdtZW50IGB0cmFuc2xhdGVCYXNlRm5gIHRvIHJldHVybiBwbGFpbiBzdHJpbmdzXG4gIHRyYW5zbGF0ZUZuLm1hcmt1cCA9IChrZXksIHZhbHVlcywgZm9ybWF0cykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRyYW5zbGF0ZUJhc2VGbihrZXksXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBgTWFya3VwVHJhbnNsYXRpb25WYWx1ZXNgIGlzIHByYWN0aWNhbGx5IGEgc3ViIHR5cGVcbiAgICAvLyBvZiBgUmljaFRyYW5zbGF0aW9uVmFsdWVzYCBidXQgVHlwZVNjcmlwdCBpc24ndCBzbWFydCBlbm91Z2ggaGVyZS5cbiAgICB2YWx1ZXMsIGZvcm1hdHMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgXCJgdC5tYXJrdXBgIG9ubHkgYWNjZXB0cyBmdW5jdGlvbnMgZm9yIGZvcm1hdHRpbmcgdGhhdCByZWNlaXZlIGFuZCByZXR1cm4gc3RyaW5ncy5cXG5cXG5FLmcuIHQubWFya3VwKCdtYXJrdXAnLCB7YjogKGNodW5rcykgPT4gYDxiPiR7Y2h1bmtzfTwvYj5gfSlcIik7XG4gICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICBlcnJvcixcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICB0cmFuc2xhdGVGbi5yYXcgPSBrZXkgPT4ge1xuICAgIGlmIChoYXNNZXNzYWdlc0Vycm9yKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0IHRoaXMgZHVyaW5nIHJlbmRlclxuICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgIGVycm9yOiBtZXNzYWdlc09yRXJyb3IsXG4gICAgICAgIGtleSxcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBtZXNzYWdlc09yRXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIEludGxFcnJvckNvZGUuTUlTU0lOR19NRVNTQUdFLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH07XG4gIHRyYW5zbGF0ZUZuLmhhcyA9IGtleSA9PiB7XG4gICAgaWYgKGhhc01lc3NhZ2VzRXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXNPckVycm9yLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFuc2xhdGVGbjtcbn1cblxuLyoqXG4gKiBGb3IgdGhlIHN0cmljdGx5IHR5cGVkIG1lc3NhZ2VzIHRvIHdvcmsgd2UgaGF2ZSB0byB3cmFwIHRoZSBuYW1lc3BhY2UgaW50b1xuICogYSBtYW5kYXRvcnkgcHJlZml4LiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNTI5NTc1LzM0MzA0NVxuICovXG5mdW5jdGlvbiByZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZSwgbmFtZXNwYWNlUHJlZml4KSB7XG4gIHJldHVybiBuYW1lc3BhY2UgPT09IG5hbWVzcGFjZVByZWZpeCA/IHVuZGVmaW5lZCA6IG5hbWVzcGFjZS5zbGljZSgobmFtZXNwYWNlUHJlZml4ICsgJy4nKS5sZW5ndGgpO1xufVxuXG5jb25zdCBTRUNPTkQgPSAxO1xuY29uc3QgTUlOVVRFID0gU0VDT05EICogNjA7XG5jb25zdCBIT1VSID0gTUlOVVRFICogNjA7XG5jb25zdCBEQVkgPSBIT1VSICogMjQ7XG5jb25zdCBXRUVLID0gREFZICogNztcbmNvbnN0IE1PTlRIID0gREFZICogKDM2NSAvIDEyKTsgLy8gQXBwcm94aW1hdGlvblxuY29uc3QgUVVBUlRFUiA9IE1PTlRIICogMztcbmNvbnN0IFlFQVIgPSBEQVkgKiAzNjU7XG5jb25zdCBVTklUX1NFQ09ORFMgPSB7XG4gIHNlY29uZDogU0VDT05ELFxuICBzZWNvbmRzOiBTRUNPTkQsXG4gIG1pbnV0ZTogTUlOVVRFLFxuICBtaW51dGVzOiBNSU5VVEUsXG4gIGhvdXI6IEhPVVIsXG4gIGhvdXJzOiBIT1VSLFxuICBkYXk6IERBWSxcbiAgZGF5czogREFZLFxuICB3ZWVrOiBXRUVLLFxuICB3ZWVrczogV0VFSyxcbiAgbW9udGg6IE1PTlRILFxuICBtb250aHM6IE1PTlRILFxuICBxdWFydGVyOiBRVUFSVEVSLFxuICBxdWFydGVyczogUVVBUlRFUixcbiAgeWVhcjogWUVBUixcbiAgeWVhcnM6IFlFQVJcbn07XG5mdW5jdGlvbiByZXNvbHZlUmVsYXRpdmVUaW1lVW5pdChzZWNvbmRzKSB7XG4gIGNvbnN0IGFic1ZhbHVlID0gTWF0aC5hYnMoc2Vjb25kcyk7XG4gIGlmIChhYnNWYWx1ZSA8IE1JTlVURSkge1xuICAgIHJldHVybiAnc2Vjb25kJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IEhPVVIpIHtcbiAgICByZXR1cm4gJ21pbnV0ZSc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBEQVkpIHtcbiAgICByZXR1cm4gJ2hvdXInO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgV0VFSykge1xuICAgIHJldHVybiAnZGF5JztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IE1PTlRIKSB7XG4gICAgcmV0dXJuICd3ZWVrJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IFlFQVIpIHtcbiAgICByZXR1cm4gJ21vbnRoJztcbiAgfVxuICByZXR1cm4gJ3llYXInO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXRpdmVUaW1lVmFsdWUoc2Vjb25kcywgdW5pdCkge1xuICAvLyBXZSBoYXZlIHRvIHJvdW5kIHRoZSByZXN1bHRpbmcgdmFsdWVzLCBhcyBgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXRgXG4gIC8vIHdpbGwgaW5jbHVkZSBmcmFjdGlvbnMgbGlrZSAnMi4xIGhvdXJzIGFnbycuXG4gIHJldHVybiBNYXRoLnJvdW5kKHNlY29uZHMgLyBVTklUX1NFQ09ORFNbdW5pdF0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRm9ybWF0dGVyKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBfY2FjaGU6IGNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICBfZm9ybWF0dGVyczogZm9ybWF0dGVycyA9IGNyZWF0ZUludGxGb3JtYXR0ZXJzKGNhY2hlKSxcbiAgICBmb3JtYXRzLFxuICAgIGxvY2FsZSxcbiAgICBvbkVycm9yID0gZGVmYXVsdE9uRXJyb3IsXG4gICAgdGltZVpvbmU6IGdsb2JhbFRpbWVab25lXG4gIH0gPSBwcm9wcztcbiAgZnVuY3Rpb24gYXBwbHlUaW1lWm9uZShvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zPy50aW1lWm9uZSkge1xuICAgICAgaWYgKGdsb2JhbFRpbWVab25lKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB0aW1lWm9uZTogZ2xvYmFsVGltZVpvbmVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLkVOVklST05NRU5UX0ZBTExCQUNLLCBgVGhlIFxcYHRpbWVab25lXFxgIHBhcmFtZXRlciB3YXNuJ3QgcHJvdmlkZWQgYW5kIHRoZXJlIGlzIG5vIGdsb2JhbCBkZWZhdWx0IGNvbmZpZ3VyZWQuIENvbnNpZGVyIGFkZGluZyBhIGdsb2JhbCBkZWZhdWx0IHRvIGF2b2lkIG1hcmt1cCBtaXNtYXRjaGVzIGNhdXNlZCBieSBlbnZpcm9ubWVudCBkaWZmZXJlbmNlcy4gTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvY29uZmlndXJhdGlvbiN0aW1lLXpvbmVgICkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICBmdW5jdGlvbiByZXNvbHZlRm9ybWF0T3JPcHRpb25zKHR5cGVGb3JtYXRzLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGlmICh0eXBlb2YgZm9ybWF0T3JPcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZm9ybWF0TmFtZSA9IGZvcm1hdE9yT3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB0eXBlRm9ybWF0cz8uW2Zvcm1hdE5hbWVdO1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLk1JU1NJTkdfRk9STUFULCBgRm9ybWF0IFxcYCR7Zm9ybWF0TmFtZX1cXGAgaXMgbm90IGF2YWlsYWJsZS5gICk7XG4gICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGZvcm1hdE9yT3B0aW9ucztcbiAgICB9XG4gICAgaWYgKG92ZXJyaWRlcykge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4ub3ZlcnJpZGVzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICBmdW5jdGlvbiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgdHlwZUZvcm1hdHMsIGZvcm1hdHRlciwgZ2V0RmFsbGJhY2spIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucyA9IHJlc29sdmVGb3JtYXRPck9wdGlvbnModHlwZUZvcm1hdHMsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFjaygpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcihvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRhdGVUaW1lKHZhbHVlLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgZm9ybWF0cz8uZGF0ZVRpbWUsIG9wdGlvbnMgPT4ge1xuICAgICAgb3B0aW9ucyA9IGFwcGx5VGltZVpvbmUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXREYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdCh2YWx1ZSk7XG4gICAgfSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZGF0ZVRpbWVSYW5nZShzdGFydCwgZW5kLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgZm9ybWF0cz8uZGF0ZVRpbWUsIG9wdGlvbnMgPT4ge1xuICAgICAgb3B0aW9ucyA9IGFwcGx5VGltZVpvbmUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXREYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdFJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIH0sICgpID0+IFtkYXRlVGltZShzdGFydCksIGRhdGVUaW1lKGVuZCldLmpvaW4oJ+KAieKAk+KAiScpKTtcbiAgfVxuICBmdW5jdGlvbiBudW1iZXIodmFsdWUsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzLCBmb3JtYXRzPy5udW1iZXIsIG9wdGlvbnMgPT4gZm9ybWF0dGVycy5nZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQodmFsdWUpLCAoKSA9PiBTdHJpbmcodmFsdWUpKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRHbG9iYWxOb3coKSB7XG4gICAgLy8gT25seSByZWFkIHdoZW4gbmVjZXNzYXJ5IHRvIGF2b2lkIHRyaWdnZXJpbmcgYSBgZHluYW1pY0lPYCBlcnJvclxuICAgIC8vIHVubmVjZXNzYXJpbHkgKGBub3dgIGlzIG9ubHkgbmVlZGVkIGZvciBgZm9ybWF0LnJlbGF0aXZlVGltZWApXG4gICAgaWYgKHByb3BzLm5vdykge1xuICAgICAgcmV0dXJuIHByb3BzLm5vdztcbiAgICB9IGVsc2Uge1xuICAgICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRU5WSVJPTk1FTlRfRkFMTEJBQ0ssIGBUaGUgXFxgbm93XFxgIHBhcmFtZXRlciB3YXNuJ3QgcHJvdmlkZWQgdG8gXFxgcmVsYXRpdmVUaW1lXFxgIGFuZCB0aGVyZSBpcyBubyBnbG9iYWwgZGVmYXVsdCBjb25maWd1cmVkLCB0aGVyZWZvcmUgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWQgYXMgYSBmYWxsYmFjay4gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL3VzYWdlL2RhdGVzLXRpbWVzI3JlbGF0aXZlLXRpbWVzLXVzZW5vd2AgKSk7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lKGRhdGUsIG5vd09yT3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBsZXQgbm93RGF0ZSwgdW5pdDtcbiAgICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICAgIGlmIChub3dPck9wdGlvbnMgaW5zdGFuY2VvZiBEYXRlIHx8IHR5cGVvZiBub3dPck9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vd0RhdGUgPSBuZXcgRGF0ZShub3dPck9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChub3dPck9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG5vd09yT3B0aW9ucy5ub3cgIT0gbnVsbCkge1xuICAgICAgICAgIG5vd0RhdGUgPSBuZXcgRGF0ZShub3dPck9wdGlvbnMubm93KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub3dEYXRlID0gZ2V0R2xvYmFsTm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdCA9IG5vd09yT3B0aW9ucy51bml0O1xuICAgICAgICBvcHRzLnN0eWxlID0gbm93T3JPcHRpb25zLnN0eWxlO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFR5cGVzIGFyZSBzbGlnaHRseSBvdXRkYXRlZFxuICAgICAgICBvcHRzLm51bWJlcmluZ1N5c3RlbSA9IG5vd09yT3B0aW9ucy5udW1iZXJpbmdTeXN0ZW07XG4gICAgICB9XG4gICAgICBpZiAoIW5vd0RhdGUpIHtcbiAgICAgICAgbm93RGF0ZSA9IGdldEdsb2JhbE5vdygpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0ZURhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgIGNvbnN0IHNlY29uZHMgPSAoZGF0ZURhdGUuZ2V0VGltZSgpIC0gbm93RGF0ZS5nZXRUaW1lKCkpIC8gMTAwMDtcbiAgICAgIGlmICghdW5pdCkge1xuICAgICAgICB1bml0ID0gcmVzb2x2ZVJlbGF0aXZlVGltZVVuaXQoc2Vjb25kcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGBudW1lcmljOiAnYXV0bydgIGNhbiB0aGVvcmV0aWNhbGx5IHByb2R1Y2Ugb3V0cHV0IGxpa2UgXCJ5ZXN0ZXJkYXlcIixcbiAgICAgIC8vIGJ1dCBpdCBvbmx5IHdvcmtzIHdpdGggaW50ZWdlcnMuIEUuZy4gLTEgZGF5IHdpbGwgcHJvZHVjZSBcInllc3RlcmRheVwiLFxuICAgICAgLy8gYnV0IC0xLjEgZGF5cyB3aWxsIHByb2R1Y2UgXCItMS4xIGRheXNcIi4gUm91bmRpbmcgYmVmb3JlIGZvcm1hdHRpbmcgaXNcbiAgICAgIC8vIG5vdCBkZXNpcmVkLCBhcyB0aGUgZ2l2ZW4gZGF0ZXMgbWlnaHQgY3Jvc3MgYSB0aHJlc2hvbGQgd2VyZSB0aGVcbiAgICAgIC8vIG91dHB1dCBpc24ndCBjb3JyZWN0IGFueW1vcmUuIEV4YW1wbGU6IDIwMjQtMDEtMDhUMjM6MDA6MDAuMDAwWiBhbmRcbiAgICAgIC8vIDIwMjQtMDEtMDhUMDE6MDA6MDAuMDAwWiB3b3VsZCBwcm9kdWNlIFwieWVzdGVyZGF5XCIsIHdoaWNoIGlzIG5vdCB0aGVcbiAgICAgIC8vIGNhc2UuIEJ5IHVzaW5nIGBhbHdheXNgIHdlIGNhbiBlbnN1cmUgY29ycmVjdCBvdXRwdXQuIFRoZSBvbmx5IGV4Y2VwdGlvblxuICAgICAgLy8gaXMgdGhlIGZvcm1hdHRpbmcgb2YgdGltZXMgPDEgc2Vjb25kIGFzIFwibm93XCIuXG4gICAgICBvcHRzLm51bWVyaWMgPSB1bml0ID09PSAnc2Vjb25kJyA/ICdhdXRvJyA6ICdhbHdheXMnO1xuICAgICAgY29uc3QgdmFsdWUgPSBjYWxjdWxhdGVSZWxhdGl2ZVRpbWVWYWx1ZShzZWNvbmRzLCB1bml0KTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldFJlbGF0aXZlVGltZUZvcm1hdChsb2NhbGUsIG9wdHMpLmZvcm1hdCh2YWx1ZSwgdW5pdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLkZPUk1BVFRJTkdfRVJST1IsIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgIHJldHVybiBTdHJpbmcoZGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGxpc3QodmFsdWUsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFZhbHVlID0gW107XG4gICAgY29uc3QgcmljaFZhbHVlcyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIGBmb3JtYXRUb1BhcnRzYCBvbmx5IGFjY2VwdHMgc3RyaW5ncywgdGhlcmVmb3JlIHdlIGhhdmUgdG8gdGVtcG9yYXJpbHlcbiAgICAvLyByZXBsYWNlIFJlYWN0IGVsZW1lbnRzIHdpdGggYSBwbGFjZWhvbGRlciBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlXG4gICAgLy8gdGhlIG9yaWdpbmFsIHZhbHVlIGFmdGVyd2FyZHMuXG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgIGxldCBzZXJpYWxpemVkSXRlbTtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgc2VyaWFsaXplZEl0ZW0gPSBTdHJpbmcoaW5kZXgpO1xuICAgICAgICByaWNoVmFsdWVzLnNldChzZXJpYWxpemVkSXRlbSwgaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkSXRlbSA9IFN0cmluZyhpdGVtKTtcbiAgICAgIH1cbiAgICAgIHNlcmlhbGl6ZWRWYWx1ZS5wdXNoKHNlcmlhbGl6ZWRJdGVtKTtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgZm9ybWF0cz8ubGlzdCxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGByaWNoVmFsdWVzLnNpemVgIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSByZXR1cm4gdHlwZSwgYnV0IFR5cGVTY3JpcHQgY2FuJ3QgaW5mZXIgdGhlIG1lYW5pbmcgb2YgdGhpcyBjb3JyZWN0bHlcbiAgICBvcHRpb25zID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZvcm1hdHRlcnMuZ2V0TGlzdEZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdFRvUGFydHMoc2VyaWFsaXplZFZhbHVlKS5tYXAocGFydCA9PiBwYXJ0LnR5cGUgPT09ICdsaXRlcmFsJyA/IHBhcnQudmFsdWUgOiByaWNoVmFsdWVzLmdldChwYXJ0LnZhbHVlKSB8fCBwYXJ0LnZhbHVlKTtcbiAgICAgIGlmIChyaWNoVmFsdWVzLnNpemUgPiAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICAgICAgfVxuICAgIH0sICgpID0+IFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0ZVRpbWUsXG4gICAgbnVtYmVyLFxuICAgIHJlbGF0aXZlVGltZSxcbiAgICBsaXN0LFxuICAgIGRhdGVUaW1lUmFuZ2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQobWVzc2FnZXMsIGludmFsaWRLZXlMYWJlbHMsIHBhcmVudFBhdGgpIHtcbiAgT2JqZWN0LmVudHJpZXMobWVzc2FnZXMpLmZvckVhY2goKFtrZXksIG1lc3NhZ2VPck1lc3NhZ2VzXSkgPT4ge1xuICAgIGlmIChrZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgbGV0IGtleUxhYmVsID0ga2V5O1xuICAgICAgaWYgKHBhcmVudFBhdGgpIGtleUxhYmVsICs9IGAgKGF0ICR7cGFyZW50UGF0aH0pYDtcbiAgICAgIGludmFsaWRLZXlMYWJlbHMucHVzaChrZXlMYWJlbCk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAobWVzc2FnZU9yTWVzc2FnZXMgIT0gbnVsbCAmJiB0eXBlb2YgbWVzc2FnZU9yTWVzc2FnZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudChtZXNzYWdlT3JNZXNzYWdlcywgaW52YWxpZEtleUxhYmVscywgam9pblBhdGgocGFyZW50UGF0aCwga2V5KSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZXMobWVzc2FnZXMsIG9uRXJyb3IpIHtcbiAgY29uc3QgaW52YWxpZEtleUxhYmVscyA9IFtdO1xuICB2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudChtZXNzYWdlcywgaW52YWxpZEtleUxhYmVscyk7XG4gIGlmIChpbnZhbGlkS2V5TGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5JTlZBTElEX0tFWSwgYE5hbWVzcGFjZSBrZXlzIGNhbiBub3QgY29udGFpbiB0aGUgY2hhcmFjdGVyIFwiLlwiIGFzIHRoaXMgaXMgdXNlZCB0byBleHByZXNzIG5lc3RpbmcuIFBsZWFzZSByZW1vdmUgaXQgb3IgcmVwbGFjZSBpdCB3aXRoIGFub3RoZXIgY2hhcmFjdGVyLlxuXG5JbnZhbGlkICR7aW52YWxpZEtleUxhYmVscy5sZW5ndGggPT09IDEgPyAna2V5JyA6ICdrZXlzJ306ICR7aW52YWxpZEtleUxhYmVscy5qb2luKCcsICcpfVxuXG5JZiB5b3UncmUgbWlncmF0aW5nIGZyb20gYSBmbGF0IHN0cnVjdHVyZSwgeW91IGNhbiBjb252ZXJ0IHlvdXIgbWVzc2FnZXMgYXMgZm9sbG93czpcblxuaW1wb3J0IHtzZXR9IGZyb20gXCJsb2Rhc2hcIjtcblxuY29uc3QgaW5wdXQgPSB7XG4gIFwib25lLm9uZVwiOiBcIjEuMVwiLFxuICBcIm9uZS50d29cIjogXCIxLjJcIixcbiAgXCJ0d28ub25lLm9uZVwiOiBcIjIuMS4xXCJcbn07XG5cbmNvbnN0IG91dHB1dCA9IE9iamVjdC5lbnRyaWVzKGlucHV0KS5yZWR1Y2UoXG4gIChhY2MsIFtrZXksIHZhbHVlXSkgPT4gc2V0KGFjYywga2V5LCB2YWx1ZSksXG4gIHt9XG4pO1xuXG4vLyBPdXRwdXQ6XG4vL1xuLy8ge1xuLy8gICBcIm9uZVwiOiB7XG4vLyAgICAgXCJvbmVcIjogXCIxLjFcIixcbi8vICAgICBcInR3b1wiOiBcIjEuMlwiXG4vLyAgIH0sXG4vLyAgIFwidHdvXCI6IHtcbi8vICAgICBcIm9uZVwiOiB7XG4vLyAgICAgICBcIm9uZVwiOiBcIjIuMS4xXCJcbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cbmAgKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmhhbmNlcyB0aGUgaW5jb21pbmcgcHJvcHMgd2l0aCBkZWZhdWx0cy5cbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUNvbmZpZyh7XG4gIGZvcm1hdHMsXG4gIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgbWVzc2FnZXMsXG4gIG9uRXJyb3IsXG4gIC4uLnJlc3Rcbn0pIHtcbiAgY29uc3QgZmluYWxPbkVycm9yID0gb25FcnJvciB8fCBkZWZhdWx0T25FcnJvcjtcbiAgY29uc3QgZmluYWxHZXRNZXNzYWdlRmFsbGJhY2sgPSBnZXRNZXNzYWdlRmFsbGJhY2sgfHwgZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjaztcbiAge1xuICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgdmFsaWRhdGVNZXNzYWdlcyhtZXNzYWdlcywgZmluYWxPbkVycm9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN0LFxuICAgIGZvcm1hdHM6IGZvcm1hdHMgfHwgdW5kZWZpbmVkLFxuICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyB8fCB1bmRlZmluZWQsXG4gICAgb25FcnJvcjogZmluYWxPbkVycm9yLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjazogZmluYWxHZXRNZXNzYWdlRmFsbGJhY2tcbiAgfTtcbn1cblxuZXhwb3J0IHsgSW50bEVycm9yIGFzIEksIEludGxFcnJvckNvZGUgYXMgYSwgY3JlYXRlSW50bEZvcm1hdHRlcnMgYXMgYiwgY3JlYXRlRm9ybWF0dGVyIGFzIGMsIGNyZWF0ZUNhY2hlIGFzIGQsIGNyZWF0ZUJhc2VUcmFuc2xhdG9yIGFzIGUsIGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2sgYXMgZiwgZGVmYXVsdE9uRXJyb3IgYXMgZywgaW5pdGlhbGl6ZUNvbmZpZyBhcyBpLCByZXNvbHZlTmFtZXNwYWNlIGFzIHIgfTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoi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QU07SUErQnZGO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELFNBQVMsaUJBQWlCLEtBTXpCO1FBTnlCLEVBQ3hCLE9BQU8sRUFDUCxrQkFBa0IsRUFDbEIsUUFBUSxFQUNSLE9BQU8sRUFDUCxHQUFHLE1BQ0osR0FOeUI7SUFPeEIsTUFBTSxlQUFlLFdBQVc7SUFDaEMsTUFBTSwwQkFBMEIsc0JBQXNCO0lBQ3REO1FBQ0UsSUFBSSxVQUFVO1lBQ1osaUJBQWlCLFVBQVU7UUFDN0I7SUFDRjtJQUNBLE9BQU87UUFDTCxHQUFHLElBQUk7UUFDUCxTQUFTLFdBQVc7UUFDcEIsVUFBVSxZQUFZO1FBQ3RCLFNBQVM7UUFDVCxvQkFBb0I7SUFDdEI7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA1MTM5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZXNtL2RldmVsb3BtZW50L3JlYWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZU1lbW8sIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBkIGFzIGNyZWF0ZUNhY2hlLCBiIGFzIGNyZWF0ZUludGxGb3JtYXR0ZXJzLCBpIGFzIGluaXRpYWxpemVDb25maWcsIHIgYXMgcmVzb2x2ZU5hbWVzcGFjZSwgSSBhcyBJbnRsRXJyb3IsIGEgYXMgSW50bEVycm9yQ29kZSwgZSBhcyBjcmVhdGVCYXNlVHJhbnNsYXRvciwgYyBhcyBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tICcuL2luaXRpYWxpemVDb25maWctQ1JENmV1dUsuanMnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuXG5cblxuY29uc3QgSW50bENvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuXG5mdW5jdGlvbiBJbnRsUHJvdmlkZXIoe1xuICBjaGlsZHJlbixcbiAgZm9ybWF0cyxcbiAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICBsb2NhbGUsXG4gIG1lc3NhZ2VzLFxuICBub3csXG4gIG9uRXJyb3IsXG4gIHRpbWVab25lXG59KSB7XG4gIGNvbnN0IHByZXZDb250ZXh0ID0gdXNlQ29udGV4dChJbnRsQ29udGV4dCk7XG5cbiAgLy8gVGhlIGZvcm1hdHRlciBjYWNoZSBpcyByZWxlYXNlZCB3aGVuIHRoZSBsb2NhbGUgY2hhbmdlcy4gRm9yXG4gIC8vIGxvbmctcnVubmluZyBhcHBzIHdpdGggYSBwZXJzaXN0ZW50IGBJbnRsUHJvdmlkZXJgIGF0IHRoZSByb290LFxuICAvLyB0aGlzIGNhbiByZWR1Y2UgdGhlIG1lbW9yeSBmb290cHJpbnQgKGUuZy4gaW4gUmVhY3QgTmF0aXZlKS5cbiAgY29uc3QgY2FjaGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gcHJldkNvbnRleHQ/LmNhY2hlIHx8IGNyZWF0ZUNhY2hlKCk7XG4gIH0sIFtsb2NhbGUsIHByZXZDb250ZXh0Py5jYWNoZV0pO1xuICBjb25zdCBmb3JtYXR0ZXJzID0gdXNlTWVtbygoKSA9PiBwcmV2Q29udGV4dD8uZm9ybWF0dGVycyB8fCBjcmVhdGVJbnRsRm9ybWF0dGVycyhjYWNoZSksIFtjYWNoZSwgcHJldkNvbnRleHQ/LmZvcm1hdHRlcnNdKTtcblxuICAvLyBNZW1vaXppbmcgdGhpcyB2YWx1ZSBoZWxwcyB0byBhdm9pZCB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyIG9mIGFsbFxuICAvLyBjb250ZXh0IGNvbnN1bWVycyBpbiBjYXNlIHRoZSBjb25maWd1cmF0aW9uIGRpZG4ndCBjaGFuZ2UuIEhvd2V2ZXIsXG4gIC8vIGlmIHNvbWUgb2YgdGhlIG5vbi1wcmltaXRpdmUgdmFsdWVzIGNoYW5nZSwgYSByZS1yZW5kZXIgd2lsbCBzdGlsbFxuICAvLyBiZSB0cmlnZ2VyZWQuIE5vdGUgdGhhdCB0aGVyZSdzIG5vIG5lZWQgdG8gcHV0IGBtZW1vYCBvbiBgSW50bFByb3ZpZGVyYFxuICAvLyBpdHNlbGYsIGJlY2F1c2UgdGhlIGBjaGlsZHJlbmAgdHlwaWNhbGx5IGNoYW5nZSBvbiBldmVyeSByZW5kZXIuXG4gIC8vIFRoZXJlJ3Mgc29tZSBidXJkZW4gb24gdGhlIGNvbnN1bWVyIHNpZGUgaWYgaXQncyBpbXBvcnRhbnQgdG8gcmVkdWNlXG4gIC8vIHJlLXJlbmRlcnMsIHB1dCB0aGF0J3MgaG93IFJlYWN0IHdvcmtzLlxuICAvLyBTZWU6IGh0dHBzOi8vYmxvZy5pc3F1YXJlZHNvZnR3YXJlLmNvbS8yMDIwLzA1L2Jsb2dnZWQtYW5zd2Vycy1hLW1vc3RseS1jb21wbGV0ZS1ndWlkZS10by1yZWFjdC1yZW5kZXJpbmctYmVoYXZpb3IvI2NvbnRleHQtdXBkYXRlcy1hbmQtcmVuZGVyLW9wdGltaXphdGlvbnNcbiAgY29uc3QgdmFsdWUgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgLi4uaW5pdGlhbGl6ZUNvbmZpZyh7XG4gICAgICBsb2NhbGUsXG4gICAgICAvLyAocmVxdWlyZWQgYnkgcHJvdmlkZXIpXG4gICAgICBmb3JtYXRzOiBmb3JtYXRzID09PSB1bmRlZmluZWQgPyBwcmV2Q29udGV4dD8uZm9ybWF0cyA6IGZvcm1hdHMsXG4gICAgICBnZXRNZXNzYWdlRmFsbGJhY2s6IGdldE1lc3NhZ2VGYWxsYmFjayB8fCBwcmV2Q29udGV4dD8uZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzID09PSB1bmRlZmluZWQgPyBwcmV2Q29udGV4dD8ubWVzc2FnZXMgOiBtZXNzYWdlcyxcbiAgICAgIG5vdzogbm93IHx8IHByZXZDb250ZXh0Py5ub3csXG4gICAgICBvbkVycm9yOiBvbkVycm9yIHx8IHByZXZDb250ZXh0Py5vbkVycm9yLFxuICAgICAgdGltZVpvbmU6IHRpbWVab25lIHx8IHByZXZDb250ZXh0Py50aW1lWm9uZVxuICAgIH0pLFxuICAgIGZvcm1hdHRlcnMsXG4gICAgY2FjaGVcbiAgfSksIFtjYWNoZSwgZm9ybWF0cywgZm9ybWF0dGVycywgZ2V0TWVzc2FnZUZhbGxiYWNrLCBsb2NhbGUsIG1lc3NhZ2VzLCBub3csIG9uRXJyb3IsIHByZXZDb250ZXh0LCB0aW1lWm9uZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChJbnRsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZUludGxDb250ZXh0KCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChJbnRsQ29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gaW50bCBjb250ZXh0IGZvdW5kLiBIYXZlIHlvdSBjb25maWd1cmVkIHRoZSBwcm92aWRlcj8gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL3VzYWdlL2NvbmZpZ3VyYXRpb24jc2VydmVyLWNsaWVudC1jb21wb25lbnRzJyApO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5sZXQgaGFzV2FybmVkRm9yTWlzc2luZ1RpbWV6b25lID0gZmFsc2U7XG5jb25zdCBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuZnVuY3Rpb24gdXNlVHJhbnNsYXRpb25zSW1wbChhbGxNZXNzYWdlc1ByZWZpeGVkLCBuYW1lc3BhY2VQcmVmaXhlZCwgbmFtZXNwYWNlUHJlZml4KSB7XG4gIGNvbnN0IHtcbiAgICBjYWNoZSxcbiAgICBmb3JtYXRzOiBnbG9iYWxGb3JtYXRzLFxuICAgIGZvcm1hdHRlcnMsXG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIGxvY2FsZSxcbiAgICBvbkVycm9yLFxuICAgIHRpbWVab25lXG4gIH0gPSB1c2VJbnRsQ29udGV4dCgpO1xuXG4gIC8vIFRoZSBgbmFtZXNwYWNlUHJlZml4YCBpcyBwYXJ0IG9mIHRoZSB0eXBlIHN5c3RlbS5cbiAgLy8gU2VlIHRoZSBjb21tZW50IGluIHRoZSBob29rIGludm9jYXRpb24uXG4gIGNvbnN0IGFsbE1lc3NhZ2VzID0gYWxsTWVzc2FnZXNQcmVmaXhlZFtuYW1lc3BhY2VQcmVmaXhdO1xuICBjb25zdCBuYW1lc3BhY2UgPSByZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZVByZWZpeGVkLCBuYW1lc3BhY2VQcmVmaXgpO1xuICBpZiAoIXRpbWVab25lICYmICFoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUgJiYgaXNTZXJ2ZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtY29tcGlsZXIvcmVhY3QtY29tcGlsZXJcbiAgICBoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUgPSB0cnVlO1xuICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLkVOVklST05NRU5UX0ZBTExCQUNLLCBgVGhlcmUgaXMgbm8gXFxgdGltZVpvbmVcXGAgY29uZmlndXJlZCwgdGhpcyBjYW4gbGVhZCB0byBtYXJrdXAgbWlzbWF0Y2hlcyBjYXVzZWQgYnkgZW52aXJvbm1lbnQgZGlmZmVyZW5jZXMuIENvbnNpZGVyIGFkZGluZyBhIGdsb2JhbCBkZWZhdWx0OiBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy9jb25maWd1cmF0aW9uI3RpbWUtem9uZWAgKSk7XG4gIH1cbiAgY29uc3QgdHJhbnNsYXRlID0gdXNlTWVtbygoKSA9PiBjcmVhdGVCYXNlVHJhbnNsYXRvcih7XG4gICAgY2FjaGUsXG4gICAgZm9ybWF0dGVycyxcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbWVzc2FnZXM6IGFsbE1lc3NhZ2VzLFxuICAgIG5hbWVzcGFjZSxcbiAgICBvbkVycm9yLFxuICAgIGZvcm1hdHM6IGdsb2JhbEZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIHRpbWVab25lXG4gIH0pLCBbY2FjaGUsIGZvcm1hdHRlcnMsIGdldE1lc3NhZ2VGYWxsYmFjaywgYWxsTWVzc2FnZXMsIG5hbWVzcGFjZSwgb25FcnJvciwgZ2xvYmFsRm9ybWF0cywgbG9jYWxlLCB0aW1lWm9uZV0pO1xuICByZXR1cm4gdHJhbnNsYXRlO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZXMgbWVzc2FnZXMgZnJvbSB0aGUgZ2l2ZW4gbmFtZXNwYWNlIGJ5IHVzaW5nIHRoZSBJQ1Ugc3ludGF4LlxuICogU2VlIGh0dHBzOi8vZm9ybWF0anMuaW8vZG9jcy9jb3JlLWNvbmNlcHRzL2ljdS1zeW50YXguXG4gKlxuICogSWYgbm8gbmFtZXNwYWNlIGlzIHByb3ZpZGVkLCBhbGwgYXZhaWxhYmxlIG1lc3NhZ2VzIGFyZSByZXR1cm5lZC5cbiAqIFRoZSBuYW1lc3BhY2UgY2FuIGFsc28gaW5kaWNhdGUgbmVzdGluZyBieSB1c2luZyBhIGRvdFxuICogKGUuZy4gYG5hbWVzcGFjZS5Db21wb25lbnRgKS5cbiAqL1xuZnVuY3Rpb24gdXNlVHJhbnNsYXRpb25zKG5hbWVzcGFjZSkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlSW50bENvbnRleHQoKTtcbiAgY29uc3QgbWVzc2FnZXMgPSBjb250ZXh0Lm1lc3NhZ2VzO1xuXG4gIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgYWN0dWFsIGhvb2sgc28gdGhlIHR5cGUgaW5mZXJlbmNlIGZvciB0aGUgb3B0aW9uYWxcbiAgLy8gbmFtZXNwYWNlIHdvcmtzIGNvcnJlY3RseS4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTUyOTU3NS8zNDMwNDVcbiAgLy8gVGhlIHByZWZpeCAoXCIhXCIpIGlzIGFyYml0cmFyeS5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBVc2UgdGhlIGV4cGxpY2l0IGFubm90YXRpb24gaW5zdGVhZFxuICByZXR1cm4gdXNlVHJhbnNsYXRpb25zSW1wbCh7XG4gICAgJyEnOiBtZXNzYWdlc1xuICB9LFxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIG5hbWVzcGFjZSA/IGAhLiR7bmFtZXNwYWNlfWAgOiAnIScsICchJyk7XG59XG5cbmZ1bmN0aW9uIHVzZUxvY2FsZSgpIHtcbiAgcmV0dXJuIHVzZUludGxDb250ZXh0KCkubG9jYWxlO1xufVxuXG5mdW5jdGlvbiBnZXROb3coKSB7XG4gIHJldHVybiBuZXcgRGF0ZSgpO1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvdXNhZ2UvZGF0ZXMtdGltZXMjcmVsYXRpdmUtdGltZXMtdXNlbm93XG4gKi9cbmZ1bmN0aW9uIHVzZU5vdyhvcHRpb25zKSB7XG4gIGNvbnN0IHVwZGF0ZUludGVydmFsID0gb3B0aW9ucz8udXBkYXRlSW50ZXJ2YWw7XG4gIGNvbnN0IHtcbiAgICBub3c6IGdsb2JhbE5vd1xuICB9ID0gdXNlSW50bENvbnRleHQoKTtcbiAgY29uc3QgW25vdywgc2V0Tm93XSA9IHVzZVN0YXRlKGdsb2JhbE5vdyB8fCBnZXROb3coKSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF1cGRhdGVJbnRlcnZhbCkgcmV0dXJuO1xuICAgIGNvbnN0IGludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBzZXROb3coZ2V0Tm93KCkpO1xuICAgIH0sIHVwZGF0ZUludGVydmFsKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICB9O1xuICB9LCBbZ2xvYmFsTm93LCB1cGRhdGVJbnRlcnZhbF0pO1xuICByZXR1cm4gdXBkYXRlSW50ZXJ2YWwgPT0gbnVsbCAmJiBnbG9iYWxOb3cgPyBnbG9iYWxOb3cgOiBub3c7XG59XG5cbmZ1bmN0aW9uIHVzZVRpbWVab25lKCkge1xuICByZXR1cm4gdXNlSW50bENvbnRleHQoKS50aW1lWm9uZTtcbn1cblxuZnVuY3Rpb24gdXNlTWVzc2FnZXMoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VJbnRsQ29udGV4dCgpO1xuICBpZiAoIWNvbnRleHQubWVzc2FnZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1lc3NhZ2VzIGZvdW5kLiBIYXZlIHlvdSBjb25maWd1cmVkIHRoZW0gY29ycmVjdGx5PyBTZWUgaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvY29uZmlndXJhdGlvbiNtZXNzYWdlcycgKTtcbiAgfVxuICByZXR1cm4gY29udGV4dC5tZXNzYWdlcztcbn1cblxuZnVuY3Rpb24gdXNlRm9ybWF0dGVyKCkge1xuICBjb25zdCB7XG4gICAgZm9ybWF0cyxcbiAgICBmb3JtYXR0ZXJzLFxuICAgIGxvY2FsZSxcbiAgICBub3c6IGdsb2JhbE5vdyxcbiAgICBvbkVycm9yLFxuICAgIHRpbWVab25lXG4gIH0gPSB1c2VJbnRsQ29udGV4dCgpO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBjcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIG5vdzogZ2xvYmFsTm93LFxuICAgIG9uRXJyb3IsXG4gICAgdGltZVpvbmUsXG4gICAgX2Zvcm1hdHRlcnM6IGZvcm1hdHRlcnNcbiAgfSksIFtmb3JtYXRzLCBmb3JtYXR0ZXJzLCBnbG9iYWxOb3csIGxvY2FsZSwgb25FcnJvciwgdGltZVpvbmVdKTtcbn1cblxuZXhwb3J0IHsgSW50bFByb3ZpZGVyLCB1c2VGb3JtYXR0ZXIsIHVzZUxvY2FsZSwgdXNlTWVzc2FnZXMsIHVzZU5vdywgdXNlVGltZVpvbmUsIHVzZVRyYW5zbGF0aW9ucyB9O1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7OztBQUlBLE1BQU0sY0FBYyxXQUFXLEdBQUUsQ0FBQSxHQUFBLDZKQUFBLENBQUEsZ0JBQWEsQUFBRCxFQUFFO0FBRS9DLFNBQVMsYUFBYSxLQVNyQjtRQVRxQixFQUNwQixRQUFRLEVBQ1IsT0FBTyxFQUNQLGtCQUFrQixFQUNsQixNQUFNLEVBQ04sUUFBUSxFQUNSLEdBQUcsRUFDSCxPQUFPLEVBQ1AsUUFB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LENBQUMsUUFBUSxRQUFRLEVBQUU7UUFDckIsTUFBTSxJQUFJLE1BQU07SUFDbEI7SUFDQSxPQUFPLFFBQVEsUUFBUTtBQUN6QjtBQUVBLFNBQVM7SUFDUCxNQUFNLEVBQ0osT0FBTyxFQUNQLFVBQVUsRUFDVixNQUFNLEVBQ04sS0FBSyxTQUFTLEVBQ2QsT0FBTyxFQUNQLFFBQVEsRUFDVCxHQUFHO0lBQ0osT0FBTyxDQUFBLEdBQUEsNkpBQUEsQ0FBQSxVQUFPLEFBQUQ7Z0NBQUUsSUFBTSxDQUFBLEdBQUEsNExBQUEsQ0FBQSxJQUFlLEFBQUQsRUFBRTtnQkFDbkM7Z0JBQ0E7Z0JBQ0EsS0FBSztnQkFDTDtnQkFDQTtnQkFDQSxhQUFhO1lBQ2Y7K0JBQUk7UUFBQztRQUFTO1FBQVk7UUFBVztRQUFRO1FBQVM7S0FBUztBQUNqRSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA1MzQ2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQtaW50bC9kaXN0L2VzbS9kZXZlbG9wbWVudC9zaGFyZWQvTmV4dEludGxDbGllbnRQcm92aWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IEludGxQcm92aWRlciB9IGZyb20gJ3VzZS1pbnRsL3JlYWN0JztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcblxuZnVuY3Rpb24gTmV4dEludGxDbGllbnRQcm92aWRlcih7XG4gIGxvY2FsZSxcbiAgLi4ucmVzdFxufSkge1xuICBpZiAoIWxvY2FsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGluZmVyIHRoZSBgbG9jYWxlYCBwcm9wIGluIGBOZXh0SW50bENsaWVudFByb3ZpZGVyYCwgcGxlYXNlIHByb3ZpZGUgaXQgZXhwbGljaXRseS5cXG5cXG5TZWUgaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvY29uZmlndXJhdGlvbiNsb2NhbGVcIiApO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KEludGxQcm92aWRlciwge1xuICAgIGxvY2FsZTogbG9jYWxlLFxuICAgIC4uLnJlc3RcbiAgfSk7XG59XG5cbmV4cG9ydCB7IE5leHRJbnRsQ2xpZW50UHJvdmlkZXIgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBO0FBQ0E7QUFGQTs7O0FBSUEsU0FBUyx1QkFBdUIsS0FHL0I7UUFIK0IsRUFDOUIsTUFBTSxFQUNOLEdBQUcsTUFDSixHQUgrQjtJQUk5QixJQUFJLENBQUMsUUFBUTtRQUNYLE1BQU0sSUFBSSxNQUFNO0lBQ2xCO0lBQ0EsT0FBTyxXQUFXLEdBQUUsQ0FBQSxHQUFBLHNLQUFBLENBQUEsTUFBRyxBQUFELEVBQUUscUtBQUEsQ0FBQSxlQUFZLEVBQUU7UUFDcEMsUUFBUTtRQUNSLEdBQUcsSUFBSTtJQUNUO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNTM2OSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0LXRoZW1lcy9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtpbXBvcnQqYXMgdCBmcm9tXCJyZWFjdFwiO3ZhciBNPShlLGkscyx1LG0sYSxsLGgpPT57bGV0IGQ9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHc9W1wibGlnaHRcIixcImRhcmtcIl07ZnVuY3Rpb24gcChuKXsoQXJyYXkuaXNBcnJheShlKT9lOltlXSkuZm9yRWFjaCh5PT57bGV0IGs9eT09PVwiY2xhc3NcIixTPWsmJmE/bS5tYXAoZj0+YVtmXXx8Zik6bTtrPyhkLmNsYXNzTGlzdC5yZW1vdmUoLi4uUyksZC5jbGFzc0xpc3QuYWRkKGEmJmFbbl0/YVtuXTpuKSk6ZC5zZXRBdHRyaWJ1dGUoeSxuKX0pLFIobil9ZnVuY3Rpb24gUihuKXtoJiZ3LmluY2x1ZGVzKG4pJiYoZC5zdHlsZS5jb2xvclNjaGVtZT1uKX1mdW5jdGlvbiBjKCl7cmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5tYXRjaGVzP1wiZGFya1wiOlwibGlnaHRcIn1pZih1KXAodSk7ZWxzZSB0cnl7bGV0IG49bG9jYWxTdG9yYWdlLmdldEl0ZW0oaSl8fHMseT1sJiZuPT09XCJzeXN0ZW1cIj9jKCk6bjtwKHkpfWNhdGNoKG4pe319O3ZhciBiPVtcImxpZ2h0XCIsXCJkYXJrXCJdLEk9XCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspXCIsTz10eXBlb2Ygd2luZG93PT1cInVuZGVmaW5lZFwiLHg9dC5jcmVhdGVDb250ZXh0KHZvaWQgMCksVT17c2V0VGhlbWU6ZT0+e30sdGhlbWVzOltdfSx6PSgpPT57dmFyIGU7cmV0dXJuKGU9dC51c2VDb250ZXh0KHgpKSE9bnVsbD9lOlV9LEo9ZT0+dC51c2VDb250ZXh0KHgpP3QuY3JlYXRlRWxlbWVudCh0LkZyYWdtZW50LG51bGwsZS5jaGlsZHJlbik6dC5jcmVhdGVFbGVtZW50KFYsey4uLmV9KSxOPVtcImxpZ2h0XCIsXCJkYXJrXCJdLFY9KHtmb3JjZWRUaGVtZTplLGRpc2FibGVUcmFuc2l0aW9uT25DaGFuZ2U6aT0hMSxlbmFibGVTeXN0ZW06cz0hMCxlbmFibGVDb2xvclNjaGVtZTp1PSEwLHN0b3JhZ2VLZXk6bT1cInRoZW1lXCIsdGhlbWVzOmE9TixkZWZhdWx0VGhlbWU6bD1zP1wic3lzdGVtXCI6XCJsaWdodFwiLGF0dHJpYnV0ZTpoPVwiZGF0YS10aGVtZVwiLHZhbHVlOmQsY2hpbGRyZW46dyxub25jZTpwLHNjcmlwdFByb3BzOlJ9KT0+e2xldFtjLG5dPXQudXNlU3RhdGUoKCk9PkgobSxsKSksW1QseV09dC51c2VTdGF0ZSgoKT0+Yz09PVwic3lzdGVtXCI/RSgpOmMpLGs9ZD9PYmplY3QudmFsdWVzKGQpOmEsUz10LnVzZUNhbGxiYWNrKG89PntsZXQgcj1vO2lmKCFyKXJldHVybjtvPT09XCJzeXN0ZW1cIiYmcyYmKHI9RSgpKTtsZXQgdj1kP2Rbcl06cixDPWk/VyhwKTpudWxsLFA9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LEw9Zz0+e2c9PT1cImNsYXNzXCI/KFAuY2xhc3NMaXN0LnJlbW92ZSguLi5rKSx2JiZQLmNsYXNzTGlzdC5hZGQodikpOmcuc3RhcnRzV2l0aChcImRhdGEtXCIpJiYodj9QLnNldEF0dHJpYnV0ZShnLHYpOlAucmVtb3ZlQXR0cmlidXRlKGcpKX07aWYoQXJyYXkuaXNBcnJheShoKT9oLmZvckVhY2goTCk6TChoKSx1KXtsZXQgZz1iLmluY2x1ZGVzKGwpP2w6bnVsbCxEPWIuaW5jbHVkZXMocik/cjpnO1Auc3R5bGUuY29sb3JTY2hlbWU9RH1DPT1udWxsfHxDKCl9LFtwXSksZj10LnVzZUNhbGxiYWNrKG89PntsZXQgcj10eXBlb2Ygbz09XCJmdW5jdGlvblwiP28oYyk6bztuKHIpO3RyeXtsb2NhbFN0b3JhZ2Uuc2V0SXRlbShtLHIpfWNhdGNoKHYpe319LFtjXSksQT10LnVzZUNhbGxiYWNrKG89PntsZXQgcj1FKG8pO3kociksYz09PVwic3lzdGVtXCImJnMmJiFlJiZTKFwic3lzdGVtXCIpfSxbYyxlXSk7dC51c2VFZmZlY3QoKCk9PntsZXQgbz13aW5kb3cubWF0Y2hNZWRpYShJKTtyZXR1cm4gby5hZGRMaXN0ZW5lcihBKSxBKG8pLCgpPT5vLnJlbW92ZUxpc3RlbmVyKEEpfSxbQV0pLHQudXNlRWZmZWN0KCgpPT57bGV0IG89cj0+e3Iua2V5PT09bSYmKHIubmV3VmFsdWU/bihyLm5ld1ZhbHVlKTpmKGwpKX07cmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic3RvcmFnZVwiLG8pLCgpPT53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN0b3JhZ2VcIixvKX0sW2ZdKSx0LnVzZUVmZmVjdCgoKT0+e1MoZSE9bnVsbD9lOmMpfSxbZSxjXSk7bGV0IFE9dC51c2VNZW1vKCgpPT4oe3RoZW1lOmMsc2V0VGhlbWU6Zixmb3JjZWRUaGVtZTplLHJlc29sdmVkVGhlbWU6Yz09PVwic3lzdGVtXCI/VDpjLHRoZW1lczpzP1suLi5hLFwic3lzdGVtXCJdOmEsc3lzdGVtVGhlbWU6cz9UOnZvaWQgMH0pLFtjLGYsZSxULHMsYV0pO3JldHVybiB0LmNyZWF0ZUVsZW1lbnQoeC5Qcm92aWRlcix7dmFsdWU6UX0sdC5jcmVhdGVFbGVtZW50KF8se2ZvcmNlZFRoZW1lOmUsc3RvcmFnZUtleTptLGF0dHJpYnV0ZTpoLGVuYWJsZVN5c3RlbTpzLGVuYWJsZUNvbG9yU2NoZW1lOnUsZGVmYXVsdFRoZW1lOmwsdmFsdWU6ZCx0aGVtZXM6YSxub25jZTpwLHNjcmlwdFByb3BzOlJ9KSx3KX0sXz10Lm1lbW8oKHtmb3JjZWRUaGVtZTplLHN0b3JhZ2VLZXk6aSxhdHRyaWJ1dGU6cyxlbmFibGVTeXN0ZW06dSxlbmFibGVDb2xvclNjaGVtZTptLGRlZmF1bHRUaGVtZTphLHZhbHVlOmwsdGhlbWVzOmgsbm9uY2U6ZCxzY3JpcHRQcm9wczp3fSk9PntsZXQgcD1KU09OLnN0cmluZ2lmeShbcyxpLGEsZSxoLGwsdSxtXSkuc2xpY2UoMSwtMSk7cmV0dXJuIHQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiLHsuLi53LHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzohMCxub25jZTp0eXBlb2Ygd2luZG93PT1cInVuZGVmaW5lZFwiP2Q6XCJcIixkYW5nZXJvdXNseVNldElubmVySFRNTDp7X19odG1sOmAoJHtNLnRvU3RyaW5nKCl9KSgke3B9KWB9fSl9KSxIPShlLGkpPT57aWYoTylyZXR1cm47bGV0IHM7dHJ5e3M9bG9jYWxTdG9yYWdlLmdldEl0ZW0oZSl8fHZvaWQgMH1jYXRjaCh1KXt9cmV0dXJuIHN8fGl9LFc9ZT0+e2xldCBpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtyZXR1cm4gZSYmaS5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLGUpLGkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIqLCo6OmJlZm9yZSwqOjphZnRlcnstd2Via2l0LXRyYW5zaXRpb246bm9uZSFpbXBvcnRhbnQ7LW1vei10cmFuc2l0aW9uOm5vbmUhaW1wb3J0YW50Oy1vLXRyYW5zaXRpb246bm9uZSFpbXBvcnRhbnQ7LW1zLXRyYW5zaXRpb246bm9uZSFpbXBvcnRhbnQ7dHJhbnNpdGlvbjpub25lIWltcG9ydGFudH1cIikpLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoaSksKCk9Pnt3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KSxzZXRUaW1lb3V0KCgpPT57ZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChpKX0sMSl9fSxFPWU9PihlfHwoZT13aW5kb3cubWF0Y2hNZWRpYShJKSksZS5tYXRjaGVzP1wiZGFya1wiOlwibGlnaHRcIik7ZXhwb3J0e0ogYXMgVGhlbWVQcm92aWRlcix6IGFzIHVzZVRoZW1lfTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQWE7QUFBYjs7QUFBcUMsSUFBSSxJQUFFLENBQUMsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRTtJQUFLLElBQUksSUFBRSxTQUFTLGVBQWUsRUFBQyxJQUFFO1FBQUM7UUFBUTtLQUFPO0lBQUMsU0FBUyxFQUFFLENBQUM7UUFBRSxDQUFDLE1BQU0sT0FBTyxDQUFDLEtBQUcsSUFBRTtZQUFDO1NBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQTtZQUFJLElBQUksSUFBRSxNQUFJLFNBQVEsSUFBRSxLQUFHLElBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQSxJQUFHLENBQUMsQ0FBQyxFQUFFLElBQUUsS0FBRztZQUFFLElBQUUsQ0FBQyxFQUFFLFNBQVMs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QUFLO0lBQUMsRUFBQyxPQUFNLEdBQUUsQ0FBQztJQUFDLE9BQU8sS0FBRztBQUFDLEdBQUUsSUFBRSxDQUFBO0lBQUksSUFBSSxJQUFFLFNBQVMsYUFBYSxDQUFDO0lBQVMsT0FBTyxLQUFHLEVBQUUsWUFBWSxDQUFDLFNBQVEsSUFBRyxFQUFFLFdBQVcsQ0FBQyxTQUFTLGNBQWMsQ0FBQyxpTEFBZ0wsU0FBUyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUc7UUFBSyxPQUFPLGdCQUFnQixDQUFDLFNBQVMsSUFBSSxHQUFFLFdBQVc7WUFBSyxTQUFTLElBQUksQ0FBQyxXQUFXLENBQUM7UUFBRSxHQUFFO0lBQUU7QUFBQyxHQUFFLElBQUUsQ0FBQSxJQUFHLENBQUMsS0FBRyxDQUFDLElBQUUsT0FBTyxVQUFVLENBQUMsRUFBRSxHQUFFLEVBQUUsT0FBTyxHQUFDLFNBQU8sT0FBTyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA1NTYyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3Nvbm5lci9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5mdW5jdGlvbiBfX2luc2VydENTUyhjb2RlKSB7XG4gIGlmICghY29kZSB8fCB0eXBlb2YgZG9jdW1lbnQgPT0gJ3VuZGVmaW5lZCcpIHJldHVyblxuICBsZXQgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXVxuICBsZXQgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpXG4gIDtzdHlsZS5zdHlsZVNoZWV0ID8gKHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNvZGUpIDogc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29kZSkpXG59XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxuY29uc3QgZ2V0QXNzZXQgPSAodHlwZSk9PntcbiAgICBzd2l0Y2godHlwZSl7XG4gICAgICAgIGNhc2UgJ3N1Y2Nlc3MnOlxuICAgICAgICAgICAgcmV0dXJuIFN1Y2Nlc3NJY29uO1xuICAgICAgICBjYXNlICdpbmZvJzpcbiAgICAgICAgICAgIHJldHVybiBJbmZvSWNvbjtcbiAgICAgICAgY2FzZSAnd2FybmluZyc6XG4gICAgICAgICAgICByZXR1cm4gV2FybmluZ0ljb247XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgIHJldHVybiBFcnJvckljb247XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuY29uc3QgYmFycyA9IEFycmF5KDEyKS5maWxsKDApO1xuY29uc3QgTG9hZGVyID0gKHsgdmlzaWJsZSwgY2xhc3NOYW1lIH0pPT57XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogW1xuICAgICAgICAgICAgJ3Nvbm5lci1sb2FkaW5nLXdyYXBwZXInLFxuICAgICAgICAgICAgY2xhc3NOYW1lXG4gICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKSxcbiAgICAgICAgXCJkYXRhLXZpc2libGVcIjogdmlzaWJsZVxuICAgIH0sIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJzb25uZXItc3Bpbm5lclwiXG4gICAgfSwgYmFycy5tYXAoKF8sIGkpPT4vKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInNvbm5lci1sb2FkaW5nLWJhclwiLFxuICAgICAgICAgICAga2V5OiBgc3Bpbm5lci1iYXItJHtpfWBcbiAgICAgICAgfSkpKSk7XG59O1xuY29uc3QgU3VjY2Vzc0ljb24gPSAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgdmlld0JveDogXCIwIDAgMjAgMjBcIixcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIGhlaWdodDogXCIyMFwiLFxuICAgIHdpZHRoOiBcIjIwXCJcbn0sIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk0xMCAxOGE4IDggMCAxMDAtMTYgOCA4IDAgMDAwIDE2em0zLjg1Ny05LjgwOWEuNzUuNzUgMCAwMC0xLjIxNC0uODgybC0zLjQ4MyA0Ljc5LTEuODgtMS44OGEuNzUuNzUgMCAxMC0xLjA2IDEuMDYxbDIuNSAyLjVhLjc1Ljc1IDAgMDAxLjEzNy0uMDg5bDQtNS41elwiLFxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIlxufSkpO1xuY29uc3QgV2FybmluZ0ljb24gPSAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIGhlaWdodDogXCIyMFwiLFxuICAgIHdpZHRoOiBcIjIwXCJcbn0sIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk05LjQwMSAzLjAwM2MxLjE1NS0yIDQuMDQzLTIgNS4xOTcgMGw3LjM1NSAxMi43NDhjMS4xNTQgMi0uMjkgNC41LTIuNTk5IDQuNUg0LjY0NWMtMi4zMDkgMC0zLjc1Mi0yLjUtMi41OTgtNC41TDkuNCAzLjAwM3pNMTIgOC4yNWEuNzUuNzUgMCAwMS43NS43NXYzLjc1YS43NS43NSAwIDAxLTEuNSAwVjlhLjc1Ljc1IDAgMDEuNzUtLjc1em0wIDguMjVhLjc1Ljc1IDAgMTAwLTEuNS43NS43NSAwIDAwMCAxLjV6XCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXG59KSk7XG5jb25zdCBJbmZvSWNvbiA9IC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB2aWV3Qm94OiBcIjAgMCAyMCAyMFwiLFxuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgaGVpZ2h0OiBcIjIwXCIsXG4gICAgd2lkdGg6IFwiMjBcIlxufSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTE4IDEwYTggOCAwIDExLTE2IDAgOCA4IDAgMDExNiAwem0tNy00YTEgMSAwIDExLTIgMCAxIDEgMCAwMTIgMHpNOSA5YS43NS43NSAwIDAwMCAxLjVoLjI1M2EuMjUuMjUgMCAwMS4yNDQuMzA0bC0uNDU5IDIuMDY2QTEuNzUgMS43NSAwIDAwMTAuNzQ3IDE1SDExYS43NS43NSAwIDAwMC0xLjVoLS4yNTNhLjI1LjI1IDAgMDEtLjI0NC0uMzA0bC40NTktMi4wNjZBMS43NSAxLjc1IDAgMDA5LjI1MyA5SDl6XCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXG59KSk7XG5jb25zdCBFcnJvckljb24gPSAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgdmlld0JveDogXCIwIDAgMjAgMjBcIixcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIGhlaWdodDogXCIyMFwiLFxuICAgIHdpZHRoOiBcIjIwXCJcbn0sIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk0xOCAxMGE4IDggMCAxMS0xNiAwIDggOCAwIDAxMTYgMHptLTgtNWEuNzUuNzUgMCAwMS43NS43NXY0LjVhLjc1Ljc1IDAgMDEtMS41IDB2LTQuNUEuNzUuNzUgMCAwMTEwIDV6bTAgMTBhMSAxIDAgMTAwLTIgMSAxIDAgMDAwIDJ6XCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXG59KSk7XG5jb25zdCBDbG9zZUljb24gPSAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgd2lkdGg6IFwiMTJcIixcbiAgICBoZWlnaHQ6IFwiMTJcIixcbiAgICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBzdHJva2VXaWR0aDogXCIxLjVcIixcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxufSwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7XG4gICAgeDE6IFwiMThcIixcbiAgICB5MTogXCI2XCIsXG4gICAgeDI6IFwiNlwiLFxuICAgIHkyOiBcIjE4XCJcbn0pLCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHtcbiAgICB4MTogXCI2XCIsXG4gICAgeTE6IFwiNlwiLFxuICAgIHgyOiBcIjE4XCIsXG4gICAgeTI6IFwiMThcIlxufSkpO1xuXG5jb25zdCB1c2VJc0RvY3VtZW50SGlkZGVuID0gKCk9PntcbiAgICBjb25zdCBbaXNEb2N1bWVudEhpZGRlbiwgc2V0SXNEb2N1bWVudEhpZGRlbl0gPSBSZWFjdC51c2VTdGF0ZShkb2N1bWVudC5oaWRkZW4pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICgpPT57XG4gICAgICAgICAgICBzZXRJc0RvY3VtZW50SGlkZGVuKGRvY3VtZW50LmhpZGRlbik7XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKT0+d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBjYWxsYmFjayk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBpc0RvY3VtZW50SGlkZGVuO1xufTtcblxubGV0IHRvYXN0c0NvdW50ZXIgPSAxO1xuY2xhc3MgT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIC8vIFdlIHVzZSBhcnJvdyBmdW5jdGlvbnMgdG8gbWFpbnRhaW4gdGhlIGNvcnJlY3QgYHRoaXNgIHJlZmVyZW5jZVxuICAgICAgICB0aGlzLnN1YnNjcmliZSA9IChzdWJzY3JpYmVyKT0+e1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnN1YnNjcmliZXJzLmluZGV4T2Yoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wdWJsaXNoID0gKGRhdGEpPT57XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmZvckVhY2goKHN1YnNjcmliZXIpPT5zdWJzY3JpYmVyKGRhdGEpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRUb2FzdCA9IChkYXRhKT0+e1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKGRhdGEpO1xuICAgICAgICAgICAgdGhpcy50b2FzdHMgPSBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy50b2FzdHMsXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGUgPSAoZGF0YSk9PntcbiAgICAgICAgICAgIHZhciBfZGF0YV9pZDtcbiAgICAgICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgLi4ucmVzdCB9ID0gZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdHlwZW9mIChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmlkKSA9PT0gJ251bWJlcicgfHwgKChfZGF0YV9pZCA9IGRhdGEuaWQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9pZC5sZW5ndGgpID4gMCA/IGRhdGEuaWQgOiB0b2FzdHNDb3VudGVyKys7XG4gICAgICAgICAgICBjb25zdCBhbHJlYWR5RXhpc3RzID0gdGhpcy50b2FzdHMuZmluZCgodG9hc3QpPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvYXN0LmlkID09PSBpZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZGlzbWlzc2libGUgPSBkYXRhLmRpc21pc3NpYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogZGF0YS5kaXNtaXNzaWJsZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc21pc3NlZFRvYXN0cy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNtaXNzZWRUb2FzdHMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2FzdHMgPSB0aGlzLnRvYXN0cy5tYXAoKHRvYXN0KT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9hc3QuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRvYXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi50b2FzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc21pc3NpYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2FzdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUb2FzdCh7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgICAgICAgICBkaXNtaXNzaWJsZSxcbiAgICAgICAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kaXNtaXNzID0gKGlkKT0+e1xuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNtaXNzZWRUb2FzdHMuYWRkKGlkKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PnRoaXMuc3Vic2NyaWJlcnMuZm9yRWFjaCgoc3Vic2NyaWJlcik9PnN1YnNjcmliZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc21pc3M6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudG9hc3RzLmZvckVhY2goKHRvYXN0KT0+e1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmZvckVhY2goKHN1YnNjcmliZXIpPT5zdWJzY3JpYmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdG9hc3QuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzbWlzczogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSAobWVzc2FnZSwgZGF0YSk9PntcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lcnJvciA9IChtZXNzYWdlLCBkYXRhKT0+e1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3VjY2VzcyA9IChtZXNzYWdlLCBkYXRhKT0+e1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbmZvID0gKG1lc3NhZ2UsIGRhdGEpPT57XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2luZm8nLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndhcm5pbmcgPSAobWVzc2FnZSwgZGF0YSk9PntcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9hZGluZyA9IChtZXNzYWdlLCBkYXRhKT0+e1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdsb2FkaW5nJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gKHByb21pc2UsIGRhdGEpPT57XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIHNob3dcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoZGF0YS5sb2FkaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZCA9IHRoaXMuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xvYWRpbmcnLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkYXRhLmxvYWRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0eXBlb2YgZGF0YS5kZXNjcmlwdGlvbiAhPT0gJ2Z1bmN0aW9uJyA/IGRhdGEuZGVzY3JpcHRpb24gOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHAgPSBQcm9taXNlLnJlc29sdmUocHJvbWlzZSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gcHJvbWlzZSgpIDogcHJvbWlzZSk7XG4gICAgICAgICAgICBsZXQgc2hvdWxkRGlzbWlzcyA9IGlkICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxQcm9taXNlID0gcC50aGVuKGFzeW5jIChyZXNwb25zZSk9PntcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICdyZXNvbHZlJyxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVhY3RFbGVtZW50UmVzcG9uc2UgPSBSZWFjdC5pc1ZhbGlkRWxlbWVudChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVhY3RFbGVtZW50UmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkRGlzbWlzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkZWZhdWx0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNIdHRwUmVzcG9uc2UocmVzcG9uc2UpICYmICFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGREaXNtaXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2VEYXRhID0gdHlwZW9mIGRhdGEuZXJyb3IgPT09ICdmdW5jdGlvbicgPyBhd2FpdCBkYXRhLmVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApIDogZGF0YS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB0eXBlb2YgZGF0YS5kZXNjcmlwdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGF3YWl0IGRhdGEuZGVzY3JpcHRpb24oYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCkgOiBkYXRhLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0V4dGVuZGVkUmVzdWx0ID0gdHlwZW9mIHByb21pc2VEYXRhID09PSAnb2JqZWN0JyAmJiAhUmVhY3QuaXNWYWxpZEVsZW1lbnQocHJvbWlzZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2FzdFNldHRpbmdzID0gaXNFeHRlbmRlZFJlc3VsdCA/IHByb21pc2VEYXRhIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcHJvbWlzZURhdGFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50b2FzdFNldHRpbmdzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGREaXNtaXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2VEYXRhID0gdHlwZW9mIGRhdGEuZXJyb3IgPT09ICdmdW5jdGlvbicgPyBhd2FpdCBkYXRhLmVycm9yKHJlc3BvbnNlKSA6IGRhdGEuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdHlwZW9mIGRhdGEuZGVzY3JpcHRpb24gPT09ICdmdW5jdGlvbicgPyBhd2FpdCBkYXRhLmRlc2NyaXB0aW9uKHJlc3BvbnNlKSA6IGRhdGEuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRXh0ZW5kZWRSZXN1bHQgPSB0eXBlb2YgcHJvbWlzZURhdGEgPT09ICdvYmplY3QnICYmICFSZWFjdC5pc1ZhbGlkRWxlbWVudChwcm9taXNlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvYXN0U2V0dGluZ3MgPSBpc0V4dGVuZGVkUmVzdWx0ID8gcHJvbWlzZURhdGEgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwcm9taXNlRGF0YVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRvYXN0U2V0dGluZ3NcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnN1Y2Nlc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGREaXNtaXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2VEYXRhID0gdHlwZW9mIGRhdGEuc3VjY2VzcyA9PT0gJ2Z1bmN0aW9uJyA/IGF3YWl0IGRhdGEuc3VjY2VzcyhyZXNwb25zZSkgOiBkYXRhLnN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdHlwZW9mIGRhdGEuZGVzY3JpcHRpb24gPT09ICdmdW5jdGlvbicgPyBhd2FpdCBkYXRhLmRlc2NyaXB0aW9uKHJlc3BvbnNlKSA6IGRhdGEuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRXh0ZW5kZWRSZXN1bHQgPSB0eXBlb2YgcHJvbWlzZURhdGEgPT09ICdvYmplY3QnICYmICFSZWFjdC5pc1ZhbGlkRWxlbWVudChwcm9taXNlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvYXN0U2V0dGluZ3MgPSBpc0V4dGVuZGVkUmVzdWx0ID8gcHJvbWlzZURhdGEgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwcm9taXNlRGF0YVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udG9hc3RTZXR0aW5nc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaChhc3luYyAoZXJyb3IpPT57XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAncmVqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkRGlzbWlzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlRGF0YSA9IHR5cGVvZiBkYXRhLmVycm9yID09PSAnZnVuY3Rpb24nID8gYXdhaXQgZGF0YS5lcnJvcihlcnJvcikgOiBkYXRhLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHR5cGVvZiBkYXRhLmRlc2NyaXB0aW9uID09PSAnZnVuY3Rpb24nID8gYXdhaXQgZGF0YS5kZXNjcmlwdGlvbihlcnJvcikgOiBkYXRhLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0V4dGVuZGVkUmVzdWx0ID0gdHlwZW9mIHByb21pc2VEYXRhID09PSAnb2JqZWN0JyAmJiAhUmVhY3QuaXNWYWxpZEVsZW1lbnQocHJvbWlzZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2FzdFNldHRpbmdzID0gaXNFeHRlbmRlZFJlc3VsdCA/IHByb21pc2VEYXRhIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcHJvbWlzZURhdGFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50b2FzdFNldHRpbmdzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmZpbmFsbHkoKCk9PntcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRGlzbWlzcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUb2FzdCBpcyBzdGlsbCBpbiBsb2FkIHN0YXRlIChhbmQgd2lsbCBiZSBpbmRlZmluaXRlbHkg4oCUIGRpc21pc3MgaXQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzbWlzcyhpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLmZpbmFsbHkgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZmluYWxseS5jYWxsKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB1bndyYXAgPSAoKT0+bmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9Pm9yaWdpbmFsUHJvbWlzZS50aGVuKCgpPT5yZXN1bHRbMF0gPT09ICdyZWplY3QnID8gcmVqZWN0KHJlc3VsdFsxXSkgOiByZXNvbHZlKHJlc3VsdFsxXSkpLmNhdGNoKHJlamVjdCkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGlkICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIGNhbm5vdCBPYmplY3QuYXNzaWduIG9uIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHVud3JhcFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGlkLCB7XG4gICAgICAgICAgICAgICAgICAgIHVud3JhcFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmN1c3RvbSA9IChqc3gsIGRhdGEpPT57XG4gICAgICAgICAgICBjb25zdCBpZCA9IChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmlkKSB8fCB0b2FzdHNDb3VudGVyKys7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAganN4OiBqc3goaWQpLFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIC4uLmRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEFjdGl2ZVRvYXN0cyA9ICgpPT57XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2FzdHMuZmlsdGVyKCh0b2FzdCk9PiF0aGlzLmRpc21pc3NlZFRvYXN0cy5oYXModG9hc3QuaWQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IFtdO1xuICAgICAgICB0aGlzLnRvYXN0cyA9IFtdO1xuICAgICAgICB0aGlzLmRpc21pc3NlZFRvYXN0cyA9IG5ldyBTZXQoKTtcbiAgICB9XG59XG5jb25zdCBUb2FzdFN0YXRlID0gbmV3IE9ic2VydmVyKCk7XG4vLyBiaW5kIHRoaXMgdG8gdGhlIHRvYXN0IGZ1bmN0aW9uXG5jb25zdCB0b2FzdEZ1bmN0aW9uID0gKG1lc3NhZ2UsIGRhdGEpPT57XG4gICAgY29uc3QgaWQgPSAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5pZCkgfHwgdG9hc3RzQ291bnRlcisrO1xuICAgIFRvYXN0U3RhdGUuYWRkVG9hc3Qoe1xuICAgICAgICB0aXRsZTogbWVzc2FnZSxcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgaWRcbiAgICB9KTtcbiAgICByZXR1cm4gaWQ7XG59O1xuY29uc3QgaXNIdHRwUmVzcG9uc2UgPSAoZGF0YSk9PntcbiAgICByZXR1cm4gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgJ29rJyBpbiBkYXRhICYmIHR5cGVvZiBkYXRhLm9rID09PSAnYm9vbGVhbicgJiYgJ3N0YXR1cycgaW4gZGF0YSAmJiB0eXBlb2YgZGF0YS5zdGF0dXMgPT09ICdudW1iZXInO1xufTtcbmNvbnN0IGJhc2ljVG9hc3QgPSB0b2FzdEZ1bmN0aW9uO1xuY29uc3QgZ2V0SGlzdG9yeSA9ICgpPT5Ub2FzdFN0YXRlLnRvYXN0cztcbmNvbnN0IGdldFRvYXN0cyA9ICgpPT5Ub2FzdFN0YXRlLmdldEFjdGl2ZVRvYXN0cygpO1xuLy8gV2UgdXNlIGBPYmplY3QuYXNzaWduYCB0byBtYWludGFpbiB0aGUgY29ycmVjdCB0eXBlcyBhcyB3ZSB3b3VsZCBsb3NlIHRoZW0gb3RoZXJ3aXNlXG5jb25zdCB0b2FzdCA9IE9iamVjdC5hc3NpZ24oYmFzaWNUb2FzdCwge1xuICAgIHN1Y2Nlc3M6IFRvYXN0U3RhdGUuc3VjY2VzcyxcbiAgICBpbmZvOiBUb2FzdFN0YXRlLmluZm8sXG4gICAgd2FybmluZzogVG9hc3RTdGF0ZS53YXJuaW5nLFxuICAgIGVycm9yOiBUb2FzdFN0YXRlLmVycm9yLFxuICAgIGN1c3RvbTogVG9hc3RTdGF0ZS5jdXN0b20sXG4gICAgbWVzc2FnZTogVG9hc3RTdGF0ZS5tZXNzYWdlLFxuICAgIHByb21pc2U6IFRvYXN0U3RhdGUucHJvbWlzZSxcbiAgICBkaXNtaXNzOiBUb2FzdFN0YXRlLmRpc21pc3MsXG4gICAgbG9hZGluZzogVG9hc3RTdGF0ZS5sb2FkaW5nXG59LCB7XG4gICAgZ2V0SGlzdG9yeSxcbiAgICBnZXRUb2FzdHNcbn0pO1xuXG5fX2luc2VydENTUyhcIltkYXRhLXNvbm5lci10b2FzdGVyXVtkaXI9bHRyXSxodG1sW2Rpcj1sdHJdey0tdG9hc3QtaWNvbi1tYXJnaW4tc3RhcnQ6LTNweDstLXRvYXN0LWljb24tbWFyZ2luLWVuZDo0cHg7LS10b2FzdC1zdmctbWFyZ2luLXN0YXJ0Oi0xcHg7LS10b2FzdC1zdmctbWFyZ2luLWVuZDowcHg7LS10b2FzdC1idXR0b24tbWFyZ2luLXN0YXJ0OmF1dG87LS10b2FzdC1idXR0b24tbWFyZ2luLWVuZDowOy0tdG9hc3QtY2xvc2UtYnV0dG9uLXN0YXJ0OjA7LS10b2FzdC1jbG9zZS1idXR0b24tZW5kOnVuc2V0Oy0tdG9hc3QtY2xvc2UtYnV0dG9uLXRyYW5zZm9ybTp0cmFuc2xhdGUoLTM1JSwgLTM1JSl9W2RhdGEtc29ubmVyLXRvYXN0ZXJdW2Rpcj1ydGxdLGh0bWxbZGlyPXJ0bF17LS10b2FzdC1pY29uLW1hcmdpbi1zdGFydDo0cHg7LS10b2FzdC1pY29uLW1hcmdpbi1lbmQ6LTNweDstLXRvYXN0LXN2Zy1tYXJnaW4tc3RhcnQ6MHB4Oy0tdG9hc3Qtc3ZnLW1hcmdpbi1lbmQ6LTFweDstLXRvYXN0LWJ1dHRvbi1tYXJnaW4tc3RhcnQ6MDstLXRvYXN0LWJ1dHRvbi1tYXJnaW4tZW5kOmF1dG87LS10b2FzdC1jbG9zZS1idXR0b24tc3RhcnQ6dW5zZXQ7LS10b2FzdC1jbG9zZS1idXR0b24tZW5kOjA7LS10b2FzdC1jbG9zZS1idXR0b24tdHJhbnNmb3JtOnRyYW5zbGF0ZSgzNSUsIC0zNSUpfVtkYXRhLXNvbm5lci10b2FzdGVyXXtwb3NpdGlvbjpmaXhlZDt3aWR0aDp2YXIoLS13aWR0aCk7Zm9udC1mYW1pbHk6dWktc2Fucy1zZXJpZixzeXN0ZW0tdWksLWFwcGxlLXN5c3RlbSxCbGlua01hY1N5c3RlbUZvbnQsU2Vnb2UgVUksUm9ib3RvLEhlbHZldGljYSBOZXVlLEFyaWFsLE5vdG8gU2FucyxzYW5zLXNlcmlmLEFwcGxlIENvbG9yIEVtb2ppLFNlZ29lIFVJIEVtb2ppLFNlZ29lIFVJIFN5bWJvbCxOb3RvIENvbG9yIEVtb2ppOy0tZ3JheTE6aHNsKDAsIDAlLCA5OSUpOy0tZ3JheTI6aHNsKDAsIDAlLCA5Ny4zJSk7LS1ncmF5Mzpoc2woMCwgMCUsIDk1LjElKTstLWdyYXk0OmhzbCgwLCAwJSwgOTMlKTstLWdyYXk1OmhzbCgwLCAwJSwgOTAuOSUpOy0tZ3JheTY6aHNsKDAsIDAlLCA4OC43JSk7LS1ncmF5Nzpoc2woMCwgMCUsIDg1LjglKTstLWdyYXk4OmhzbCgwLCAwJSwgNzglKTstLWdyYXk5OmhzbCgwLCAwJSwgNTYuMSUpOy0tZ3JheTEwOmhzbCgwLCAwJSwgNTIuMyUpOy0tZ3JheTExOmhzbCgwLCAwJSwgNDMuNSUpOy0tZ3JheTEyOmhzbCgwLCAwJSwgOSUpOy0tYm9yZGVyLXJhZGl1czo4cHg7Ym94LXNpemluZzpib3JkZXItYm94O3BhZGRpbmc6MDttYXJnaW46MDtsaXN0LXN0eWxlOm5vbmU7b3V0bGluZTowO3otaW5kZXg6OTk5OTk5OTk5O3RyYW5zaXRpb246dHJhbnNmb3JtIC40cyBlYXNlfUBtZWRpYSAoaG92ZXI6bm9uZSkgYW5kIChwb2ludGVyOmNvYXJzZSl7W2RhdGEtc29ubmVyLXRvYXN0ZXJdW2RhdGEtbGlmdGVkPXRydWVde3RyYW5zZm9ybTpub25lfX1bZGF0YS1zb25uZXItdG9hc3Rlcl1bZGF0YS14LXBvc2l0aW9uPXJpZ2h0XXtyaWdodDp2YXIoLS1vZmZzZXQtcmlnaHQpfVtkYXRhLXNvbm5lci10b2FzdGVyXVtkYXRhLXgtcG9zaXRpb249bGVmdF17bGVmdDp2YXIoLS1vZmZzZXQtbGVmdCl9W2RhdGEtc29ubmVyLXRvYXN0ZXJdW2RhdGEteC1wb3NpdGlvbj1jZW50ZXJde2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfVtkYXRhLXNvbm5lci10b2FzdGVyXVtkYXRhLXktcG9zaXRpb249dG9wXXt0b3A6dmFyKC0tb2Zmc2V0LXRvcCl9W2RhdGEtc29ubmVyLXRvYXN0ZXJdW2RhdGEteS1wb3NpdGlvbj1ib3R0b21de2JvdHRvbTp2YXIoLS1vZmZzZXQtYm90dG9tKX1bZGF0YS1zb25uZXItdG9hc3Rdey0teTp0cmFuc2xhdGVZKDEwMCUpOy0tbGlmdC1hbW91bnQ6Y2FsYyh2YXIoLS1saWZ0KSAqIHZhcigtLWdhcCkpO3otaW5kZXg6dmFyKC0tei1pbmRleCk7cG9zaXRpb246YWJzb2x1dGU7b3BhY2l0eTowO3RyYW5zZm9ybTp2YXIoLS15KTt0b3VjaC1hY3Rpb246bm9uZTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMsb3BhY2l0eSAuNHMsaGVpZ2h0IC40cyxib3gtc2hhZG93IC4ycztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3V0bGluZTowO292ZXJmbG93LXdyYXA6YW55d2hlcmV9W2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXN0eWxlZD10cnVlXXtwYWRkaW5nOjE2cHg7YmFja2dyb3VuZDp2YXIoLS1ub3JtYWwtYmcpO2JvcmRlcjoxcHggc29saWQgdmFyKC0tbm9ybWFsLWJvcmRlcik7Y29sb3I6dmFyKC0tbm9ybWFsLXRleHQpO2JvcmRlci1yYWRpdXM6dmFyKC0tYm9yZGVyLXJhZGl1cyk7Ym94LXNoYWRvdzowIDRweCAxMnB4IHJnYmEoMCwwLDAsLjEpO3dpZHRoOnZhcigtLXdpZHRoKTtmb250LXNpemU6MTNweDtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2dhcDo2cHh9W2RhdGEtc29ubmVyLXRvYXN0XTpmb2N1cy12aXNpYmxle2JveC1zaGFkb3c6MCA0cHggMTJweCByZ2JhKDAsMCwwLC4xKSwwIDAgMCAycHggcmdiYSgwLDAsMCwuMil9W2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXktcG9zaXRpb249dG9wXXt0b3A6MDstLXk6dHJhbnNsYXRlWSgtMTAwJSk7LS1saWZ0OjE7LS1saWZ0LWFtb3VudDpjYWxjKDEgKiB2YXIoLS1nYXApKX1bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEteS1wb3NpdGlvbj1ib3R0b21de2JvdHRvbTowOy0teTp0cmFuc2xhdGVZKDEwMCUpOy0tbGlmdDotMTstLWxpZnQtYW1vdW50OmNhbGModmFyKC0tbGlmdCkgKiB2YXIoLS1nYXApKX1bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtc3R5bGVkPXRydWVdIFtkYXRhLWRlc2NyaXB0aW9uXXtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MS40O2NvbG9yOiMzZjNmM2Z9W2RhdGEtcmljaC1jb2xvcnM9dHJ1ZV1bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtc3R5bGVkPXRydWVdIFtkYXRhLWRlc2NyaXB0aW9uXXtjb2xvcjppbmhlcml0fVtkYXRhLXNvbm5lci10b2FzdGVyXVtkYXRhLXNvbm5lci10aGVtZT1kYXJrXSBbZGF0YS1kZXNjcmlwdGlvbl17Y29sb3I6I2U4ZThlOH1bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtc3R5bGVkPXRydWVdIFtkYXRhLXRpdGxlXXtmb250LXdlaWdodDo1MDA7bGluZS1oZWlnaHQ6MS41O2NvbG9yOmluaGVyaXR9W2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXN0eWxlZD10cnVlXSBbZGF0YS1pY29uXXtkaXNwbGF5OmZsZXg7aGVpZ2h0OjE2cHg7d2lkdGg6MTZweDtwb3NpdGlvbjpyZWxhdGl2ZTtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDthbGlnbi1pdGVtczpjZW50ZXI7ZmxleC1zaHJpbms6MDttYXJnaW4tbGVmdDp2YXIoLS10b2FzdC1pY29uLW1hcmdpbi1zdGFydCk7bWFyZ2luLXJpZ2h0OnZhcigtLXRvYXN0LWljb24tbWFyZ2luLWVuZCl9W2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXByb21pc2U9dHJ1ZV0gW2RhdGEtaWNvbl0+c3Zne29wYWNpdHk6MDt0cmFuc2Zvcm06c2NhbGUoLjgpO3RyYW5zZm9ybS1vcmlnaW46Y2VudGVyO2FuaW1hdGlvbjpzb25uZXItZmFkZS1pbiAuM3MgZWFzZSBmb3J3YXJkc31bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtc3R5bGVkPXRydWVdIFtkYXRhLWljb25dPip7ZmxleC1zaHJpbms6MH1bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtc3R5bGVkPXRydWVdIFtkYXRhLWljb25dIHN2Z3ttYXJnaW4tbGVmdDp2YXIoLS10b2FzdC1zdmctbWFyZ2luLXN0YXJ0KTttYXJnaW4tcmlnaHQ6dmFyKC0tdG9hc3Qtc3ZnLW1hcmdpbi1lbmQpfVtkYXRhLXNvbm5lci10b2FzdF1bZGF0YS1zdHlsZWQ9dHJ1ZV0gW2RhdGEtY29udGVudF17ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtnYXA6MnB4fVtkYXRhLXNvbm5lci10b2FzdF1bZGF0YS1zdHlsZWQ9dHJ1ZV0gW2RhdGEtYnV0dG9uXXtib3JkZXItcmFkaXVzOjRweDtwYWRkaW5nLWxlZnQ6OHB4O3BhZGRpbmctcmlnaHQ6OHB4O2hlaWdodDoyNHB4O2ZvbnQtc2l6ZToxMnB4O2NvbG9yOnZhcigtLW5vcm1hbC1iZyk7YmFja2dyb3VuZDp2YXIoLS1ub3JtYWwtdGV4dCk7bWFyZ2luLWxlZnQ6dmFyKC0tdG9hc3QtYnV0dG9uLW1hcmdpbi1zdGFydCk7bWFyZ2luLXJpZ2h0OnZhcigtLXRvYXN0LWJ1dHRvbi1tYXJnaW4tZW5kKTtib3JkZXI6bm9uZTtmb250LXdlaWdodDo1MDA7Y3Vyc29yOnBvaW50ZXI7b3V0bGluZTowO2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7ZmxleC1zaHJpbms6MDt0cmFuc2l0aW9uOm9wYWNpdHkgLjRzLGJveC1zaGFkb3cgLjJzfVtkYXRhLXNvbm5lci10b2FzdF1bZGF0YS1zdHlsZWQ9dHJ1ZV0gW2RhdGEtYnV0dG9uXTpmb2N1cy12aXNpYmxle2JveC1zaGFkb3c6MCAwIDAgMnB4IHJnYmEoMCwwLDAsLjQpfVtkYXRhLXNvbm5lci10b2FzdF1bZGF0YS1zdHlsZWQ9dHJ1ZV0gW2RhdGEtYnV0dG9uXTpmaXJzdC1vZi10eXBle21hcmdpbi1sZWZ0OnZhcigtLXRvYXN0LWJ1dHRvbi1tYXJnaW4tc3RhcnQpO21hcmdpbi1yaWdodDp2YXIoLS10b2FzdC1idXR0b24tbWFyZ2luLWVuZCl9W2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXN0eWxlZD10cnVlXSBbZGF0YS1jYW5jZWxde2NvbG9yOnZhcigtLW5vcm1hbC10ZXh0KTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjA4KX1bZGF0YS1zb25uZXItdG9hc3Rlcl1bZGF0YS1zb25uZXItdGhlbWU9ZGFya10gW2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXN0eWxlZD10cnVlXSBbZGF0YS1jYW5jZWxde2JhY2tncm91bmQ6cmdiYSgyNTUsMjU1LDI1NSwuMyl9W2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXN0eWxlZD10cnVlXSBbZGF0YS1jbG9zZS1idXR0b25de3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6dmFyKC0tdG9hc3QtY2xvc2UtYnV0dG9uLXN0YXJ0KTtyaWdodDp2YXIoLS10b2FzdC1jbG9zZS1idXR0b24tZW5kKTt0b3A6MDtoZWlnaHQ6MjBweDt3aWR0aDoyMHB4O2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtwYWRkaW5nOjA7Y29sb3I6dmFyKC0tZ3JheTEyKTtiYWNrZ3JvdW5kOnZhcigtLW5vcm1hbC1iZyk7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1ncmF5NCk7dHJhbnNmb3JtOnZhcigtLXRvYXN0LWNsb3NlLWJ1dHRvbi10cmFuc2Zvcm0pO2JvcmRlci1yYWRpdXM6NTAlO2N1cnNvcjpwb2ludGVyO3otaW5kZXg6MTt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzLGJhY2tncm91bmQgLjJzLGJvcmRlci1jb2xvciAuMnN9W2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXN0eWxlZD10cnVlXSBbZGF0YS1jbG9zZS1idXR0b25dOmZvY3VzLXZpc2libGV7Ym94LXNoYWRvdzowIDRweCAxMnB4IHJnYmEoMCwwLDAsLjEpLDAgMCAwIDJweCByZ2JhKDAsMCwwLC4yKX1bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtc3R5bGVkPXRydWVdIFtkYXRhLWRpc2FibGVkPXRydWVde2N1cnNvcjpub3QtYWxsb3dlZH1bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtc3R5bGVkPXRydWVdOmhvdmVyIFtkYXRhLWNsb3NlLWJ1dHRvbl06aG92ZXJ7YmFja2dyb3VuZDp2YXIoLS1ncmF5Mik7Ym9yZGVyLWNvbG9yOnZhcigtLWdyYXk1KX1bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtc3dpcGluZz10cnVlXTo6YmVmb3Jle2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTAwJTtyaWdodDotMTAwJTtoZWlnaHQ6MTAwJTt6LWluZGV4Oi0xfVtkYXRhLXNvbm5lci10b2FzdF1bZGF0YS15LXBvc2l0aW9uPXRvcF1bZGF0YS1zd2lwaW5nPXRydWVdOjpiZWZvcmV7Ym90dG9tOjUwJTt0cmFuc2Zvcm06c2NhbGVZKDMpIHRyYW5zbGF0ZVkoNTAlKX1bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEteS1wb3NpdGlvbj1ib3R0b21dW2RhdGEtc3dpcGluZz10cnVlXTo6YmVmb3Jle3RvcDo1MCU7dHJhbnNmb3JtOnNjYWxlWSgzKSB0cmFuc2xhdGVZKC01MCUpfVtkYXRhLXNvbm5lci10b2FzdF1bZGF0YS1zd2lwaW5nPWZhbHNlXVtkYXRhLXJlbW92ZWQ9dHJ1ZV06OmJlZm9yZXtjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO2luc2V0OjA7dHJhbnNmb3JtOnNjYWxlWSgyKX1bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtZXhwYW5kZWQ9dHJ1ZV06OmFmdGVye2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO2hlaWdodDpjYWxjKHZhcigtLWdhcCkgKyAxcHgpO2JvdHRvbToxMDAlO3dpZHRoOjEwMCV9W2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLW1vdW50ZWQ9dHJ1ZV17LS15OnRyYW5zbGF0ZVkoMCk7b3BhY2l0eToxfVtkYXRhLXNvbm5lci10b2FzdF1bZGF0YS1leHBhbmRlZD1mYWxzZV1bZGF0YS1mcm9udD1mYWxzZV17LS1zY2FsZTp2YXIoLS10b2FzdHMtYmVmb3JlKSAqIDAuMDUgKyAxOy0teTp0cmFuc2xhdGVZKGNhbGModmFyKC0tbGlmdC1hbW91bnQpICogdmFyKC0tdG9hc3RzLWJlZm9yZSkpKSBzY2FsZShjYWxjKC0xICogdmFyKC0tc2NhbGUpKSk7aGVpZ2h0OnZhcigtLWZyb250LXRvYXN0LWhlaWdodCl9W2RhdGEtc29ubmVyLXRvYXN0XT4qe3RyYW5zaXRpb246b3BhY2l0eSAuNHN9W2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXgtcG9zaXRpb249cmlnaHRde3JpZ2h0OjB9W2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXgtcG9zaXRpb249bGVmdF17bGVmdDowfVtkYXRhLXNvbm5lci10b2FzdF1bZGF0YS1leHBhbmRlZD1mYWxzZV1bZGF0YS1mcm9udD1mYWxzZV1bZGF0YS1zdHlsZWQ9dHJ1ZV0+KntvcGFjaXR5OjB9W2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXZpc2libGU9ZmFsc2Vde29wYWNpdHk6MDtwb2ludGVyLWV2ZW50czpub25lfVtkYXRhLXNvbm5lci10b2FzdF1bZGF0YS1tb3VudGVkPXRydWVdW2RhdGEtZXhwYW5kZWQ9dHJ1ZV17LS15OnRyYW5zbGF0ZVkoY2FsYyh2YXIoLS1saWZ0KSAqIHZhcigtLW9mZnNldCkpKTtoZWlnaHQ6dmFyKC0taW5pdGlhbC1oZWlnaHQpfVtkYXRhLXNvbm5lci10b2FzdF1bZGF0YS1yZW1vdmVkPXRydWVdW2RhdGEtZnJvbnQ9dHJ1ZV1bZGF0YS1zd2lwZS1vdXQ9ZmFsc2Vdey0teTp0cmFuc2xhdGVZKGNhbGModmFyKC0tbGlmdCkgKiAtMTAwJSkpO29wYWNpdHk6MH1bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtcmVtb3ZlZD10cnVlXVtkYXRhLWZyb250PWZhbHNlXVtkYXRhLXN3aXBlLW91dD1mYWxzZV1bZGF0YS1leHBhbmRlZD10cnVlXXstLXk6dHJhbnNsYXRlWShjYWxjKHZhcigtLWxpZnQpICogdmFyKC0tb2Zmc2V0KSArIHZhcigtLWxpZnQpICogLTEwMCUpKTtvcGFjaXR5OjB9W2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXJlbW92ZWQ9dHJ1ZV1bZGF0YS1mcm9udD1mYWxzZV1bZGF0YS1zd2lwZS1vdXQ9ZmFsc2VdW2RhdGEtZXhwYW5kZWQ9ZmFsc2Vdey0teTp0cmFuc2xhdGVZKDQwJSk7b3BhY2l0eTowO3RyYW5zaXRpb246dHJhbnNmb3JtIC41cyxvcGFjaXR5IC4yc31bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtcmVtb3ZlZD10cnVlXVtkYXRhLWZyb250PWZhbHNlXTo6YmVmb3Jle2hlaWdodDpjYWxjKHZhcigtLWluaXRpYWwtaGVpZ2h0KSArIDIwJSl9W2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXN3aXBpbmc9dHJ1ZV17dHJhbnNmb3JtOnZhcigtLXkpIHRyYW5zbGF0ZVkodmFyKC0tc3dpcGUtYW1vdW50LXksMCkpIHRyYW5zbGF0ZVgodmFyKC0tc3dpcGUtYW1vdW50LXgsMCkpO3RyYW5zaXRpb246bm9uZX1bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtc3dpcGVkPXRydWVde3VzZXItc2VsZWN0Om5vbmV9W2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXN3aXBlLW91dD10cnVlXVtkYXRhLXktcG9zaXRpb249Ym90dG9tXSxbZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtc3dpcGUtb3V0PXRydWVdW2RhdGEteS1wb3NpdGlvbj10b3Bde2FuaW1hdGlvbi1kdXJhdGlvbjouMnM7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLW91dDthbmltYXRpb24tZmlsbC1tb2RlOmZvcndhcmRzfVtkYXRhLXNvbm5lci10b2FzdF1bZGF0YS1zd2lwZS1vdXQ9dHJ1ZV1bZGF0YS1zd2lwZS1kaXJlY3Rpb249bGVmdF17YW5pbWF0aW9uLW5hbWU6c3dpcGUtb3V0LWxlZnR9W2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXN3aXBlLW91dD10cnVlXVtkYXRhLXN3aXBlLWRpcmVjdGlvbj1yaWdodF17YW5pbWF0aW9uLW5hbWU6c3dpcGUtb3V0LXJpZ2h0fVtkYXRhLXNvbm5lci10b2FzdF1bZGF0YS1zd2lwZS1vdXQ9dHJ1ZV1bZGF0YS1zd2lwZS1kaXJlY3Rpb249dXBde2FuaW1hdGlvbi1uYW1lOnN3aXBlLW91dC11cH1bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtc3dpcGUtb3V0PXRydWVdW2RhdGEtc3dpcGUtZGlyZWN0aW9uPWRvd25de2FuaW1hdGlvbi1uYW1lOnN3aXBlLW91dC1kb3dufUBrZXlmcmFtZXMgc3dpcGUtb3V0LWxlZnR7ZnJvbXt0cmFuc2Zvcm06dmFyKC0teSkgdHJhbnNsYXRlWCh2YXIoLS1zd2lwZS1hbW91bnQteCkpO29wYWNpdHk6MX10b3t0cmFuc2Zvcm06dmFyKC0teSkgdHJhbnNsYXRlWChjYWxjKHZhcigtLXN3aXBlLWFtb3VudC14KSAtIDEwMCUpKTtvcGFjaXR5OjB9fUBrZXlmcmFtZXMgc3dpcGUtb3V0LXJpZ2h0e2Zyb217dHJhbnNmb3JtOnZhcigtLXkpIHRyYW5zbGF0ZVgodmFyKC0tc3dpcGUtYW1vdW50LXgpKTtvcGFjaXR5OjF9dG97dHJhbnNmb3JtOnZhcigtLXkpIHRyYW5zbGF0ZVgoY2FsYyh2YXIoLS1zd2lwZS1hbW91bnQteCkgKyAxMDAlKSk7b3BhY2l0eTowfX1Aa2V5ZnJhbWVzIHN3aXBlLW91dC11cHtmcm9te3RyYW5zZm9ybTp2YXIoLS15KSB0cmFuc2xhdGVZKHZhcigtLXN3aXBlLWFtb3VudC15KSk7b3BhY2l0eToxfXRve3RyYW5zZm9ybTp2YXIoLS15KSB0cmFuc2xhdGVZKGNhbGModmFyKC0tc3dpcGUtYW1vdW50LXkpIC0gMTAwJSkpO29wYWNpdHk6MH19QGtleWZyYW1lcyBzd2lwZS1vdXQtZG93bntmcm9te3RyYW5zZm9ybTp2YXIoLS15KSB0cmFuc2xhdGVZKHZhcigtLXN3aXBlLWFtb3VudC15KSk7b3BhY2l0eToxfXRve3RyYW5zZm9ybTp2YXIoLS15KSB0cmFuc2xhdGVZKGNhbGModmFyKC0tc3dpcGUtYW1vdW50LXkpICsgMTAwJSkpO29wYWNpdHk6MH19QG1lZGlhIChtYXgtd2lkdGg6NjAwcHgpe1tkYXRhLXNvbm5lci10b2FzdGVyXXtwb3NpdGlvbjpmaXhlZDtyaWdodDp2YXIoLS1tb2JpbGUtb2Zmc2V0LXJpZ2h0KTtsZWZ0OnZhcigtLW1vYmlsZS1vZmZzZXQtbGVmdCk7d2lkdGg6MTAwJX1bZGF0YS1zb25uZXItdG9hc3Rlcl1bZGlyPXJ0bF17bGVmdDpjYWxjKHZhcigtLW1vYmlsZS1vZmZzZXQtbGVmdCkgKiAtMSl9W2RhdGEtc29ubmVyLXRvYXN0ZXJdIFtkYXRhLXNvbm5lci10b2FzdF17bGVmdDowO3JpZ2h0OjA7d2lkdGg6Y2FsYygxMDAlIC0gdmFyKC0tbW9iaWxlLW9mZnNldC1sZWZ0KSAqIDIpfVtkYXRhLXNvbm5lci10b2FzdGVyXVtkYXRhLXgtcG9zaXRpb249bGVmdF17bGVmdDp2YXIoLS1tb2JpbGUtb2Zmc2V0LWxlZnQpfVtkYXRhLXNvbm5lci10b2FzdGVyXVtkYXRhLXktcG9zaXRpb249Ym90dG9tXXtib3R0b206dmFyKC0tbW9iaWxlLW9mZnNldC1ib3R0b20pfVtkYXRhLXNvbm5lci10b2FzdGVyXVtkYXRhLXktcG9zaXRpb249dG9wXXt0b3A6dmFyKC0tbW9iaWxlLW9mZnNldC10b3ApfVtkYXRhLXNvbm5lci10b2FzdGVyXVtkYXRhLXgtcG9zaXRpb249Y2VudGVyXXtsZWZ0OnZhcigtLW1vYmlsZS1vZmZzZXQtbGVmdCk7cmlnaHQ6dmFyKC0tbW9iaWxlLW9mZnNldC1yaWdodCk7dHJhbnNmb3JtOm5vbmV9fVtkYXRhLXNvbm5lci10b2FzdGVyXVtkYXRhLXNvbm5lci10aGVtZT1saWdodF17LS1ub3JtYWwtYmc6I2ZmZjstLW5vcm1hbC1ib3JkZXI6dmFyKC0tZ3JheTQpOy0tbm9ybWFsLXRleHQ6dmFyKC0tZ3JheTEyKTstLXN1Y2Nlc3MtYmc6aHNsKDE0MywgODUlLCA5NiUpOy0tc3VjY2Vzcy1ib3JkZXI6aHNsKDE0NSwgOTIlLCA4NyUpOy0tc3VjY2Vzcy10ZXh0OmhzbCgxNDAsIDEwMCUsIDI3JSk7LS1pbmZvLWJnOmhzbCgyMDgsIDEwMCUsIDk3JSk7LS1pbmZvLWJvcmRlcjpoc2woMjIxLCA5MSUsIDkzJSk7LS1pbmZvLXRleHQ6aHNsKDIxMCwgOTIlLCA0NSUpOy0td2FybmluZy1iZzpoc2woNDksIDEwMCUsIDk3JSk7LS13YXJuaW5nLWJvcmRlcjpoc2woNDksIDkxJSwgODQlKTstLXdhcm5pbmctdGV4dDpoc2woMzEsIDkyJSwgNDUlKTstLWVycm9yLWJnOmhzbCgzNTksIDEwMCUsIDk3JSk7LS1lcnJvci1ib3JkZXI6aHNsKDM1OSwgMTAwJSwgOTQlKTstLWVycm9yLXRleHQ6aHNsKDM2MCwgMTAwJSwgNDUlKX1bZGF0YS1zb25uZXItdG9hc3Rlcl1bZGF0YS1zb25uZXItdGhlbWU9bGlnaHRdIFtkYXRhLXNvbm5lci10b2FzdF1bZGF0YS1pbnZlcnQ9dHJ1ZV17LS1ub3JtYWwtYmc6IzAwMDstLW5vcm1hbC1ib3JkZXI6aHNsKDAsIDAlLCAyMCUpOy0tbm9ybWFsLXRleHQ6dmFyKC0tZ3JheTEpfVtkYXRhLXNvbm5lci10b2FzdGVyXVtkYXRhLXNvbm5lci10aGVtZT1kYXJrXSBbZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtaW52ZXJ0PXRydWVdey0tbm9ybWFsLWJnOiNmZmY7LS1ub3JtYWwtYm9yZGVyOnZhcigtLWdyYXkzKTstLW5vcm1hbC10ZXh0OnZhcigtLWdyYXkxMil9W2RhdGEtc29ubmVyLXRvYXN0ZXJdW2RhdGEtc29ubmVyLXRoZW1lPWRhcmtdey0tbm9ybWFsLWJnOiMwMDA7LS1ub3JtYWwtYmctaG92ZXI6aHNsKDAsIDAlLCAxMiUpOy0tbm9ybWFsLWJvcmRlcjpoc2woMCwgMCUsIDIwJSk7LS1ub3JtYWwtYm9yZGVyLWhvdmVyOmhzbCgwLCAwJSwgMjUlKTstLW5vcm1hbC10ZXh0OnZhcigtLWdyYXkxKTstLXN1Y2Nlc3MtYmc6aHNsKDE1MCwgMTAwJSwgNiUpOy0tc3VjY2Vzcy1ib3JkZXI6aHNsKDE0NywgMTAwJSwgMTIlKTstLXN1Y2Nlc3MtdGV4dDpoc2woMTUwLCA4NiUsIDY1JSk7LS1pbmZvLWJnOmhzbCgyMTUsIDEwMCUsIDYlKTstLWluZm8tYm9yZGVyOmhzbCgyMjMsIDQzJSwgMTclKTstLWluZm8tdGV4dDpoc2woMjE2LCA4NyUsIDY1JSk7LS13YXJuaW5nLWJnOmhzbCg2NCwgMTAwJSwgNiUpOy0td2FybmluZy1ib3JkZXI6aHNsKDYwLCAxMDAlLCA5JSk7LS13YXJuaW5nLXRleHQ6aHNsKDQ2LCA4NyUsIDY1JSk7LS1lcnJvci1iZzpoc2woMzU4LCA3NiUsIDEwJSk7LS1lcnJvci1ib3JkZXI6aHNsKDM1NywgODklLCAxNiUpOy0tZXJyb3ItdGV4dDpoc2woMzU4LCAxMDAlLCA4MSUpfVtkYXRhLXNvbm5lci10b2FzdGVyXVtkYXRhLXNvbm5lci10aGVtZT1kYXJrXSBbZGF0YS1zb25uZXItdG9hc3RdIFtkYXRhLWNsb3NlLWJ1dHRvbl17YmFja2dyb3VuZDp2YXIoLS1ub3JtYWwtYmcpO2JvcmRlci1jb2xvcjp2YXIoLS1ub3JtYWwtYm9yZGVyKTtjb2xvcjp2YXIoLS1ub3JtYWwtdGV4dCl9W2RhdGEtc29ubmVyLXRvYXN0ZXJdW2RhdGEtc29ubmVyLXRoZW1lPWRhcmtdIFtkYXRhLXNvbm5lci10b2FzdF0gW2RhdGEtY2xvc2UtYnV0dG9uXTpob3ZlcntiYWNrZ3JvdW5kOnZhcigtLW5vcm1hbC1iZy1ob3Zlcik7Ym9yZGVyLWNvbG9yOnZhcigtLW5vcm1hbC1ib3JkZXItaG92ZXIpfVtkYXRhLXJpY2gtY29sb3JzPXRydWVdW2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXR5cGU9c3VjY2Vzc117YmFja2dyb3VuZDp2YXIoLS1zdWNjZXNzLWJnKTtib3JkZXItY29sb3I6dmFyKC0tc3VjY2Vzcy1ib3JkZXIpO2NvbG9yOnZhcigtLXN1Y2Nlc3MtdGV4dCl9W2RhdGEtcmljaC1jb2xvcnM9dHJ1ZV1bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtdHlwZT1zdWNjZXNzXSBbZGF0YS1jbG9zZS1idXR0b25de2JhY2tncm91bmQ6dmFyKC0tc3VjY2Vzcy1iZyk7Ym9yZGVyLWNvbG9yOnZhcigtLXN1Y2Nlc3MtYm9yZGVyKTtjb2xvcjp2YXIoLS1zdWNjZXNzLXRleHQpfVtkYXRhLXJpY2gtY29sb3JzPXRydWVdW2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXR5cGU9aW5mb117YmFja2dyb3VuZDp2YXIoLS1pbmZvLWJnKTtib3JkZXItY29sb3I6dmFyKC0taW5mby1ib3JkZXIpO2NvbG9yOnZhcigtLWluZm8tdGV4dCl9W2RhdGEtcmljaC1jb2xvcnM9dHJ1ZV1bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtdHlwZT1pbmZvXSBbZGF0YS1jbG9zZS1idXR0b25de2JhY2tncm91bmQ6dmFyKC0taW5mby1iZyk7Ym9yZGVyLWNvbG9yOnZhcigtLWluZm8tYm9yZGVyKTtjb2xvcjp2YXIoLS1pbmZvLXRleHQpfVtkYXRhLXJpY2gtY29sb3JzPXRydWVdW2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXR5cGU9d2FybmluZ117YmFja2dyb3VuZDp2YXIoLS13YXJuaW5nLWJnKTtib3JkZXItY29sb3I6dmFyKC0td2FybmluZy1ib3JkZXIpO2NvbG9yOnZhcigtLXdhcm5pbmctdGV4dCl9W2RhdGEtcmljaC1jb2xvcnM9dHJ1ZV1bZGF0YS1zb25uZXItdG9hc3RdW2RhdGEtdHlwZT13YXJuaW5nXSBbZGF0YS1jbG9zZS1idXR0b25de2JhY2tncm91bmQ6dmFyKC0td2FybmluZy1iZyk7Ym9yZGVyLWNvbG9yOnZhcigtLXdhcm5pbmctYm9yZGVyKTtjb2xvcjp2YXIoLS13YXJuaW5nLXRleHQpfVtkYXRhLXJpY2gtY29sb3JzPXRydWVdW2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXR5cGU9ZXJyb3Jde2JhY2tncm91bmQ6dmFyKC0tZXJyb3ItYmcpO2JvcmRlci1jb2xvcjp2YXIoLS1lcnJvci1ib3JkZXIpO2NvbG9yOnZhcigtLWVycm9yLXRleHQpfVtkYXRhLXJpY2gtY29sb3JzPXRydWVdW2RhdGEtc29ubmVyLXRvYXN0XVtkYXRhLXR5cGU9ZXJyb3JdIFtkYXRhLWNsb3NlLWJ1dHRvbl17YmFja2dyb3VuZDp2YXIoLS1lcnJvci1iZyk7Ym9yZGVyLWNvbG9yOnZhcigtLWVycm9yLWJvcmRlcik7Y29sb3I6dmFyKC0tZXJyb3ItdGV4dCl9LnNvbm5lci1sb2FkaW5nLXdyYXBwZXJ7LS1zaXplOjE2cHg7aGVpZ2h0OnZhcigtLXNpemUpO3dpZHRoOnZhcigtLXNpemUpO3Bvc2l0aW9uOmFic29sdXRlO2luc2V0OjA7ei1pbmRleDoxMH0uc29ubmVyLWxvYWRpbmctd3JhcHBlcltkYXRhLXZpc2libGU9ZmFsc2Vde3RyYW5zZm9ybS1vcmlnaW46Y2VudGVyO2FuaW1hdGlvbjpzb25uZXItZmFkZS1vdXQgLjJzIGVhc2UgZm9yd2FyZHN9LnNvbm5lci1zcGlubmVye3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDo1MCU7bGVmdDo1MCU7aGVpZ2h0OnZhcigtLXNpemUpO3dpZHRoOnZhcigtLXNpemUpfS5zb25uZXItbG9hZGluZy1iYXJ7YW5pbWF0aW9uOnNvbm5lci1zcGluIDEuMnMgbGluZWFyIGluZmluaXRlO2JhY2tncm91bmQ6dmFyKC0tZ3JheTExKTtib3JkZXItcmFkaXVzOjZweDtoZWlnaHQ6OCU7bGVmdDotMTAlO3Bvc2l0aW9uOmFic29sdXRlO3RvcDotMy45JTt3aWR0aDoyNCV9LnNvbm5lci1sb2FkaW5nLWJhcjpmaXJzdC1jaGlsZHthbmltYXRpb24tZGVsYXk6LTEuMnM7dHJhbnNmb3JtOnJvdGF0ZSguMDAwMWRlZykgdHJhbnNsYXRlKDE0NiUpfS5zb25uZXItbG9hZGluZy1iYXI6bnRoLWNoaWxkKDIpe2FuaW1hdGlvbi1kZWxheTotMS4xczt0cmFuc2Zvcm06cm90YXRlKDMwZGVnKSB0cmFuc2xhdGUoMTQ2JSl9LnNvbm5lci1sb2FkaW5nLWJhcjpudGgtY2hpbGQoMyl7YW5pbWF0aW9uLWRlbGF5Oi0xczt0cmFuc2Zvcm06cm90YXRlKDYwZGVnKSB0cmFuc2xhdGUoMTQ2JSl9LnNvbm5lci1sb2FkaW5nLWJhcjpudGgtY2hpbGQoNCl7YW5pbWF0aW9uLWRlbGF5Oi0uOXM7dHJhbnNmb3JtOnJvdGF0ZSg5MGRlZykgdHJhbnNsYXRlKDE0NiUpfS5zb25uZXItbG9hZGluZy1iYXI6bnRoLWNoaWxkKDUpe2FuaW1hdGlvbi1kZWxheTotLjhzO3RyYW5zZm9ybTpyb3RhdGUoMTIwZGVnKSB0cmFuc2xhdGUoMTQ2JSl9LnNvbm5lci1sb2FkaW5nLWJhcjpudGgtY2hpbGQoNil7YW5pbWF0aW9uLWRlbGF5Oi0uN3M7dHJhbnNmb3JtOnJvdGF0ZSgxNTBkZWcpIHRyYW5zbGF0ZSgxNDYlKX0uc29ubmVyLWxvYWRpbmctYmFyOm50aC1jaGlsZCg3KXthbmltYXRpb24tZGVsYXk6LS42czt0cmFuc2Zvcm06cm90YXRlKDE4MGRlZykgdHJhbnNsYXRlKDE0NiUpfS5zb25uZXItbG9hZGluZy1iYXI6bnRoLWNoaWxkKDgpe2FuaW1hdGlvbi1kZWxheTotLjVzO3RyYW5zZm9ybTpyb3RhdGUoMjEwZGVnKSB0cmFuc2xhdGUoMTQ2JSl9LnNvbm5lci1sb2FkaW5nLWJhcjpudGgtY2hpbGQoOSl7YW5pbWF0aW9uLWRlbGF5Oi0uNHM7dHJhbnNmb3JtOnJvdGF0ZSgyNDBkZWcpIHRyYW5zbGF0ZSgxNDYlKX0uc29ubmVyLWxvYWRpbmctYmFyOm50aC1jaGlsZCgxMCl7YW5pbWF0aW9uLWRlbGF5Oi0uM3M7dHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpIHRyYW5zbGF0ZSgxNDYlKX0uc29ubmVyLWxvYWRpbmctYmFyOm50aC1jaGlsZCgxMSl7YW5pbWF0aW9uLWRlbGF5Oi0uMnM7dHJhbnNmb3JtOnJvdGF0ZSgzMDBkZWcpIHRyYW5zbGF0ZSgxNDYlKX0uc29ubmVyLWxvYWRpbmctYmFyOm50aC1jaGlsZCgxMil7YW5pbWF0aW9uLWRlbGF5Oi0uMXM7dHJhbnNmb3JtOnJvdGF0ZSgzMzBkZWcpIHRyYW5zbGF0ZSgxNDYlKX1Aa2V5ZnJhbWVzIHNvbm5lci1mYWRlLWluezAle29wYWNpdHk6MDt0cmFuc2Zvcm06c2NhbGUoLjgpfTEwMCV7b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZSgxKX19QGtleWZyYW1lcyBzb25uZXItZmFkZS1vdXR7MCV7b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZSgxKX0xMDAle29wYWNpdHk6MDt0cmFuc2Zvcm06c2NhbGUoLjgpfX1Aa2V5ZnJhbWVzIHNvbm5lci1zcGluezAle29wYWNpdHk6MX0xMDAle29wYWNpdHk6LjE1fX1AbWVkaWEgKHByZWZlcnMtcmVkdWNlZC1tb3Rpb24pey5zb25uZXItbG9hZGluZy1iYXIsW2RhdGEtc29ubmVyLXRvYXN0XSxbZGF0YS1zb25uZXItdG9hc3RdPip7dHJhbnNpdGlvbjpub25lIWltcG9ydGFudDthbmltYXRpb246bm9uZSFpbXBvcnRhbnR9fS5zb25uZXItbG9hZGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7bGVmdDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLC01MCUpO3RyYW5zZm9ybS1vcmlnaW46Y2VudGVyO3RyYW5zaXRpb246b3BhY2l0eSAuMnMsdHJhbnNmb3JtIC4yc30uc29ubmVyLWxvYWRlcltkYXRhLXZpc2libGU9ZmFsc2Vde29wYWNpdHk6MDt0cmFuc2Zvcm06c2NhbGUoLjgpIHRyYW5zbGF0ZSgtNTAlLC01MCUpfVwiKTtcblxuZnVuY3Rpb24gaXNBY3Rpb24oYWN0aW9uKSB7XG4gICAgcmV0dXJuIGFjdGlvbi5sYWJlbCAhPT0gdW5kZWZpbmVkO1xufVxuXG4vLyBWaXNpYmxlIHRvYXN0cyBhbW91bnRcbmNvbnN0IFZJU0lCTEVfVE9BU1RTX0FNT1VOVCA9IDM7XG4vLyBWaWV3cG9ydCBwYWRkaW5nXG5jb25zdCBWSUVXUE9SVF9PRkZTRVQgPSAnMjRweCc7XG4vLyBNb2JpbGUgdmlld3BvcnQgcGFkZGluZ1xuY29uc3QgTU9CSUxFX1ZJRVdQT1JUX09GRlNFVCA9ICcxNnB4Jztcbi8vIERlZmF1bHQgbGlmZXRpbWUgb2YgYSB0b2FzdHMgKGluIG1zKVxuY29uc3QgVE9BU1RfTElGRVRJTUUgPSA0MDAwO1xuLy8gRGVmYXVsdCB0b2FzdCB3aWR0aFxuY29uc3QgVE9BU1RfV0lEVEggPSAzNTY7XG4vLyBEZWZhdWx0IGdhcCBiZXR3ZWVuIHRvYXN0c1xuY29uc3QgR0FQID0gMTQ7XG4vLyBUaHJlc2hvbGQgdG8gZGlzbWlzcyBhIHRvYXN0XG5jb25zdCBTV0lQRV9USFJFU0hPTEQgPSA0NTtcbi8vIEVxdWFsIHRvIGV4aXQgYW5pbWF0aW9uIGR1cmF0aW9uXG5jb25zdCBUSU1FX0JFRk9SRV9VTk1PVU5UID0gMjAwO1xuZnVuY3Rpb24gY24oLi4uY2xhc3Nlcykge1xuICAgIHJldHVybiBjbGFzc2VzLmZpbHRlcihCb29sZWFuKS5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0U3dpcGVEaXJlY3Rpb25zKHBvc2l0aW9uKSB7XG4gICAgY29uc3QgW3ksIHhdID0gcG9zaXRpb24uc3BsaXQoJy0nKTtcbiAgICBjb25zdCBkaXJlY3Rpb25zID0gW107XG4gICAgaWYgKHkpIHtcbiAgICAgICAgZGlyZWN0aW9ucy5wdXNoKHkpO1xuICAgIH1cbiAgICBpZiAoeCkge1xuICAgICAgICBkaXJlY3Rpb25zLnB1c2goeCk7XG4gICAgfVxuICAgIHJldHVybiBkaXJlY3Rpb25zO1xufVxuY29uc3QgVG9hc3QgPSAocHJvcHMpPT57XG4gICAgdmFyIF90b2FzdF9jbGFzc05hbWVzLCBfdG9hc3RfY2xhc3NOYW1lczEsIF90b2FzdF9jbGFzc05hbWVzMiwgX3RvYXN0X2NsYXNzTmFtZXMzLCBfdG9hc3RfY2xhc3NOYW1lczQsIF90b2FzdF9jbGFzc05hbWVzNSwgX3RvYXN0X2NsYXNzTmFtZXM2LCBfdG9hc3RfY2xhc3NOYW1lczcsIF90b2FzdF9jbGFzc05hbWVzODtcbiAgICBjb25zdCB7IGludmVydDogVG9hc3RlckludmVydCwgdG9hc3QsIHVuc3R5bGVkLCBpbnRlcmFjdGluZywgc2V0SGVpZ2h0cywgdmlzaWJsZVRvYXN0cywgaGVpZ2h0cywgaW5kZXgsIHRvYXN0cywgZXhwYW5kZWQsIHJlbW92ZVRvYXN0LCBkZWZhdWx0UmljaENvbG9ycywgY2xvc2VCdXR0b246IGNsb3NlQnV0dG9uRnJvbVRvYXN0ZXIsIHN0eWxlLCBjYW5jZWxCdXR0b25TdHlsZSwgYWN0aW9uQnV0dG9uU3R5bGUsIGNsYXNzTmFtZSA9ICcnLCBkZXNjcmlwdGlvbkNsYXNzTmFtZSA9ICcnLCBkdXJhdGlvbjogZHVyYXRpb25Gcm9tVG9hc3RlciwgcG9zaXRpb24sIGdhcCwgZXhwYW5kQnlEZWZhdWx0LCBjbGFzc05hbWVzLCBpY29ucywgY2xvc2VCdXR0b25BcmlhTGFiZWwgPSAnQ2xvc2UgdG9hc3QnIH0gPSBwcm9wcztcbiAgICBjb25zdCBbc3dpcGVEaXJlY3Rpb24sIHNldFN3aXBlRGlyZWN0aW9uXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtzd2lwZU91dERpcmVjdGlvbiwgc2V0U3dpcGVPdXREaXJlY3Rpb25dID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtyZW1vdmVkLCBzZXRSZW1vdmVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbc3dpcGluZywgc2V0U3dpcGluZ10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3N3aXBlT3V0LCBzZXRTd2lwZU91dF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2lzU3dpcGVkLCBzZXRJc1N3aXBlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW29mZnNldEJlZm9yZVJlbW92ZSwgc2V0T2Zmc2V0QmVmb3JlUmVtb3ZlXSA9IFJlYWN0LnVzZVN0YXRlKDApO1xuICAgIGNvbnN0IFtpbml0aWFsSGVpZ2h0LCBzZXRJbml0aWFsSGVpZ2h0XSA9IFJlYWN0LnVzZVN0YXRlKDApO1xuICAgIGNvbnN0IHJlbWFpbmluZ1RpbWUgPSBSZWFjdC51c2VSZWYodG9hc3QuZHVyYXRpb24gfHwgZHVyYXRpb25Gcm9tVG9hc3RlciB8fCBUT0FTVF9MSUZFVElNRSk7XG4gICAgY29uc3QgZHJhZ1N0YXJ0VGltZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCB0b2FzdFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBpc0Zyb250ID0gaW5kZXggPT09IDA7XG4gICAgY29uc3QgaXNWaXNpYmxlID0gaW5kZXggKyAxIDw9IHZpc2libGVUb2FzdHM7XG4gICAgY29uc3QgdG9hc3RUeXBlID0gdG9hc3QudHlwZTtcbiAgICBjb25zdCBkaXNtaXNzaWJsZSA9IHRvYXN0LmRpc21pc3NpYmxlICE9PSBmYWxzZTtcbiAgICBjb25zdCB0b2FzdENsYXNzbmFtZSA9IHRvYXN0LmNsYXNzTmFtZSB8fCAnJztcbiAgICBjb25zdCB0b2FzdERlc2NyaXB0aW9uQ2xhc3NuYW1lID0gdG9hc3QuZGVzY3JpcHRpb25DbGFzc05hbWUgfHwgJyc7XG4gICAgLy8gSGVpZ2h0IGluZGV4IGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBvZmZzZXQgYXMgaXQgZ2V0cyB1cGRhdGVkIGJlZm9yZSB0aGUgdG9hc3QgYXJyYXksIHdoaWNoIG1lYW5zIHdlIGNhbiBjYWxjdWxhdGUgdGhlIG5ldyBsYXlvdXQgZmFzdGVyLlxuICAgIGNvbnN0IGhlaWdodEluZGV4ID0gUmVhY3QudXNlTWVtbygoKT0+aGVpZ2h0cy5maW5kSW5kZXgoKGhlaWdodCk9PmhlaWdodC50b2FzdElkID09PSB0b2FzdC5pZCkgfHwgMCwgW1xuICAgICAgICBoZWlnaHRzLFxuICAgICAgICB0b2FzdC5pZFxuICAgIF0pO1xuICAgIGNvbnN0IGNsb3NlQnV0dG9uID0gUmVhY3QudXNlTWVtbygoKT0+e1xuICAgICAgICB2YXIgX3RvYXN0X2Nsb3NlQnV0dG9uO1xuICAgICAgICByZXR1cm4gKF90b2FzdF9jbG9zZUJ1dHRvbiA9IHRvYXN0LmNsb3NlQnV0dG9uKSAhPSBudWxsID8gX3RvYXN0X2Nsb3NlQnV0dG9uIDogY2xvc2VCdXR0b25Gcm9tVG9hc3RlcjtcbiAgICB9LCBbXG4gICAgICAgIHRvYXN0LmNsb3NlQnV0dG9uLFxuICAgICAgICBjbG9zZUJ1dHRvbkZyb21Ub2FzdGVyXG4gICAgXSk7XG4gICAgY29uc3QgZHVyYXRpb24gPSBSZWFjdC51c2VNZW1vKCgpPT50b2FzdC5kdXJhdGlvbiB8fCBkdXJhdGlvbkZyb21Ub2FzdGVyIHx8IFRPQVNUX0xJRkVUSU1FLCBbXG4gICAgICAgIHRvYXN0LmR1cmF0aW9uLFxuICAgICAgICBkdXJhdGlvbkZyb21Ub2FzdGVyXG4gICAgXSk7XG4gICAgY29uc3QgY2xvc2VUaW1lclN0YXJ0VGltZVJlZiA9IFJlYWN0LnVzZVJlZigwKTtcbiAgICBjb25zdCBvZmZzZXQgPSBSZWFjdC51c2VSZWYoMCk7XG4gICAgY29uc3QgbGFzdENsb3NlVGltZXJTdGFydFRpbWVSZWYgPSBSZWFjdC51c2VSZWYoMCk7XG4gICAgY29uc3QgcG9pbnRlclN0YXJ0UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IFt5LCB4XSA9IHBvc2l0aW9uLnNwbGl0KCctJyk7XG4gICAgY29uc3QgdG9hc3RzSGVpZ2h0QmVmb3JlID0gUmVhY3QudXNlTWVtbygoKT0+e1xuICAgICAgICByZXR1cm4gaGVpZ2h0cy5yZWR1Y2UoKHByZXYsIGN1cnIsIHJlZHVjZXJJbmRleCk9PntcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBvZmZzZXQgdXAgdW50aWwgY3VycmVudCB0b2FzdFxuICAgICAgICAgICAgaWYgKHJlZHVjZXJJbmRleCA+PSBoZWlnaHRJbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZXYgKyBjdXJyLmhlaWdodDtcbiAgICAgICAgfSwgMCk7XG4gICAgfSwgW1xuICAgICAgICBoZWlnaHRzLFxuICAgICAgICBoZWlnaHRJbmRleFxuICAgIF0pO1xuICAgIGNvbnN0IGlzRG9jdW1lbnRIaWRkZW4gPSB1c2VJc0RvY3VtZW50SGlkZGVuKCk7XG4gICAgY29uc3QgaW52ZXJ0ID0gdG9hc3QuaW52ZXJ0IHx8IFRvYXN0ZXJJbnZlcnQ7XG4gICAgY29uc3QgZGlzYWJsZWQgPSB0b2FzdFR5cGUgPT09ICdsb2FkaW5nJztcbiAgICBvZmZzZXQuY3VycmVudCA9IFJlYWN0LnVzZU1lbW8oKCk9PmhlaWdodEluZGV4ICogZ2FwICsgdG9hc3RzSGVpZ2h0QmVmb3JlLCBbXG4gICAgICAgIGhlaWdodEluZGV4LFxuICAgICAgICB0b2FzdHNIZWlnaHRCZWZvcmVcbiAgICBdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgcmVtYWluaW5nVGltZS5jdXJyZW50ID0gZHVyYXRpb247XG4gICAgfSwgW1xuICAgICAgICBkdXJhdGlvblxuICAgIF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBUcmlnZ2VyIGVudGVyIGFuaW1hdGlvbiB3aXRob3V0IHVzaW5nIENTUyBhbmltYXRpb25cbiAgICAgICAgc2V0TW91bnRlZCh0cnVlKTtcbiAgICB9LCBbXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGNvbnN0IHRvYXN0Tm9kZSA9IHRvYXN0UmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICh0b2FzdE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRvYXN0Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBBZGQgdG9hc3QgaGVpZ2h0IHRvIGhlaWdodHMgYXJyYXkgYWZ0ZXIgdGhlIHRvYXN0IGlzIG1vdW50ZWRcbiAgICAgICAgICAgIHNldEluaXRpYWxIZWlnaHQoaGVpZ2h0KTtcbiAgICAgICAgICAgIHNldEhlaWdodHMoKGgpPT5bXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvYXN0SWQ6IHRvYXN0LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHRvYXN0LnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC4uLmhcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJldHVybiAoKT0+c2V0SGVpZ2h0cygoaCk9PmguZmlsdGVyKChoZWlnaHQpPT5oZWlnaHQudG9hc3RJZCAhPT0gdG9hc3QuaWQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgc2V0SGVpZ2h0cyxcbiAgICAgICAgdG9hc3QuaWRcbiAgICBdKTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgLy8gS2VlcCBoZWlnaHQgdXAgdG8gZGF0ZSB3aXRoIHRoZSBjb250ZW50IGluIGNhc2UgaXQgdXBkYXRlc1xuICAgICAgICBpZiAoIW1vdW50ZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgdG9hc3ROb2RlID0gdG9hc3RSZWYuY3VycmVudDtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxIZWlnaHQgPSB0b2FzdE5vZGUuc3R5bGUuaGVpZ2h0O1xuICAgICAgICB0b2FzdE5vZGUuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICBjb25zdCBuZXdIZWlnaHQgPSB0b2FzdE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICB0b2FzdE5vZGUuc3R5bGUuaGVpZ2h0ID0gb3JpZ2luYWxIZWlnaHQ7XG4gICAgICAgIHNldEluaXRpYWxIZWlnaHQobmV3SGVpZ2h0KTtcbiAgICAgICAgc2V0SGVpZ2h0cygoaGVpZ2h0cyk9PntcbiAgICAgICAgICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSBoZWlnaHRzLmZpbmQoKGhlaWdodCk9PmhlaWdodC50b2FzdElkID09PSB0b2FzdC5pZCk7XG4gICAgICAgICAgICBpZiAoIWFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2FzdElkOiB0b2FzdC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbmV3SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHRvYXN0LnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC4uLmhlaWdodHNcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVpZ2h0cy5tYXAoKGhlaWdodCk9PmhlaWdodC50b2FzdElkID09PSB0b2FzdC5pZCA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbmV3SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0gOiBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIG1vdW50ZWQsXG4gICAgICAgIHRvYXN0LnRpdGxlLFxuICAgICAgICB0b2FzdC5kZXNjcmlwdGlvbixcbiAgICAgICAgc2V0SGVpZ2h0cyxcbiAgICAgICAgdG9hc3QuaWQsXG4gICAgICAgIHRvYXN0LmpzeCxcbiAgICAgICAgdG9hc3QuYWN0aW9uLFxuICAgICAgICB0b2FzdC5jYW5jZWxcbiAgICBdKTtcbiAgICBjb25zdCBkZWxldGVUb2FzdCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpPT57XG4gICAgICAgIC8vIFNhdmUgdGhlIG9mZnNldCBmb3IgdGhlIGV4aXQgc3dpcGUgYW5pbWF0aW9uXG4gICAgICAgIHNldFJlbW92ZWQodHJ1ZSk7XG4gICAgICAgIHNldE9mZnNldEJlZm9yZVJlbW92ZShvZmZzZXQuY3VycmVudCk7XG4gICAgICAgIHNldEhlaWdodHMoKGgpPT5oLmZpbHRlcigoaGVpZ2h0KT0+aGVpZ2h0LnRvYXN0SWQgIT09IHRvYXN0LmlkKSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIHJlbW92ZVRvYXN0KHRvYXN0KTtcbiAgICAgICAgfSwgVElNRV9CRUZPUkVfVU5NT1VOVCk7XG4gICAgfSwgW1xuICAgICAgICB0b2FzdCxcbiAgICAgICAgcmVtb3ZlVG9hc3QsXG4gICAgICAgIHNldEhlaWdodHMsXG4gICAgICAgIG9mZnNldFxuICAgIF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAodG9hc3QucHJvbWlzZSAmJiB0b2FzdFR5cGUgPT09ICdsb2FkaW5nJyB8fCB0b2FzdC5kdXJhdGlvbiA9PT0gSW5maW5pdHkgfHwgdG9hc3QudHlwZSA9PT0gJ2xvYWRpbmcnKSByZXR1cm47XG4gICAgICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgICAgIC8vIFBhdXNlIHRoZSB0aW1lciBvbiBlYWNoIGhvdmVyXG4gICAgICAgIGNvbnN0IHBhdXNlVGltZXIgPSAoKT0+e1xuICAgICAgICAgICAgaWYgKGxhc3RDbG9zZVRpbWVyU3RhcnRUaW1lUmVmLmN1cnJlbnQgPCBjbG9zZVRpbWVyU3RhcnRUaW1lUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGVsYXBzZWQgdGltZSBzaW5jZSB0aGUgdGltZXIgc3RhcnRlZFxuICAgICAgICAgICAgICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBjbG9zZVRpbWVyU3RhcnRUaW1lUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nVGltZS5jdXJyZW50ID0gcmVtYWluaW5nVGltZS5jdXJyZW50IC0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2xvc2VUaW1lclN0YXJ0VGltZVJlZi5jdXJyZW50ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZXIgPSAoKT0+e1xuICAgICAgICAgICAgLy8gc2V0VGltZW91dCgsIEluZmluaXR5KSBiZWhhdmVzIGFzIGlmIHRoZSBkZWxheSBpcyAwLlxuICAgICAgICAgICAgLy8gQXMgYSByZXN1bHQsIHRoZSB0b2FzdCB3b3VsZCBiZSBjbG9zZWQgaW1tZWRpYXRlbHksIGdpdmluZyB0aGUgYXBwZWFyYW5jZSB0aGF0IGl0IHdhcyBuZXZlciByZW5kZXJlZC5cbiAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RlbnlzZG92aGFuL3d0ZmpzP3RhYj1yZWFkbWUtb3YtZmlsZSNhbi1pbmZpbml0ZS10aW1lb3V0XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nVGltZS5jdXJyZW50ID09PSBJbmZpbml0eSkgcmV0dXJuO1xuICAgICAgICAgICAgY2xvc2VUaW1lclN0YXJ0VGltZVJlZi5jdXJyZW50ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAvLyBMZXQgdGhlIHRvYXN0IGtub3cgaXQgaGFzIHN0YXJ0ZWRcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICB0b2FzdC5vbkF1dG9DbG9zZSA9PSBudWxsID8gdm9pZCAwIDogdG9hc3Qub25BdXRvQ2xvc2UuY2FsbCh0b2FzdCwgdG9hc3QpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZVRvYXN0KCk7XG4gICAgICAgICAgICB9LCByZW1haW5pbmdUaW1lLmN1cnJlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZXhwYW5kZWQgfHwgaW50ZXJhY3RpbmcgfHwgaXNEb2N1bWVudEhpZGRlbikge1xuICAgICAgICAgICAgcGF1c2VUaW1lcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRUaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKT0+Y2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfSwgW1xuICAgICAgICBleHBhbmRlZCxcbiAgICAgICAgaW50ZXJhY3RpbmcsXG4gICAgICAgIHRvYXN0LFxuICAgICAgICB0b2FzdFR5cGUsXG4gICAgICAgIGlzRG9jdW1lbnRIaWRkZW4sXG4gICAgICAgIGRlbGV0ZVRvYXN0XG4gICAgXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmICh0b2FzdC5kZWxldGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZVRvYXN0KCk7XG4gICAgICAgICAgICB0b2FzdC5vbkRpc21pc3MgPT0gbnVsbCA/IHZvaWQgMCA6IHRvYXN0Lm9uRGlzbWlzcy5jYWxsKHRvYXN0LCB0b2FzdCk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGRlbGV0ZVRvYXN0LFxuICAgICAgICB0b2FzdC5kZWxldGVcbiAgICBdKTtcbiAgICBmdW5jdGlvbiBnZXRMb2FkaW5nSWNvbigpIHtcbiAgICAgICAgdmFyIF90b2FzdF9jbGFzc05hbWVzO1xuICAgICAgICBpZiAoaWNvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGljb25zLmxvYWRpbmcpIHtcbiAgICAgICAgICAgIHZhciBfdG9hc3RfY2xhc3NOYW1lczE7XG4gICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNuKGNsYXNzTmFtZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGNsYXNzTmFtZXMubG9hZGVyLCB0b2FzdCA9PSBudWxsID8gdm9pZCAwIDogKF90b2FzdF9jbGFzc05hbWVzMSA9IHRvYXN0LmNsYXNzTmFtZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdG9hc3RfY2xhc3NOYW1lczEubG9hZGVyLCAnc29ubmVyLWxvYWRlcicpLFxuICAgICAgICAgICAgICAgIFwiZGF0YS12aXNpYmxlXCI6IHRvYXN0VHlwZSA9PT0gJ2xvYWRpbmcnXG4gICAgICAgICAgICB9LCBpY29ucy5sb2FkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KExvYWRlciwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbihjbGFzc05hbWVzID09IG51bGwgPyB2b2lkIDAgOiBjbGFzc05hbWVzLmxvYWRlciwgdG9hc3QgPT0gbnVsbCA/IHZvaWQgMCA6IChfdG9hc3RfY2xhc3NOYW1lcyA9IHRvYXN0LmNsYXNzTmFtZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdG9hc3RfY2xhc3NOYW1lcy5sb2FkZXIpLFxuICAgICAgICAgICAgdmlzaWJsZTogdG9hc3RUeXBlID09PSAnbG9hZGluZydcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGljb24gPSB0b2FzdC5pY29uIHx8IChpY29ucyA9PSBudWxsID8gdm9pZCAwIDogaWNvbnNbdG9hc3RUeXBlXSkgfHwgZ2V0QXNzZXQodG9hc3RUeXBlKTtcbiAgICB2YXIgX3RvYXN0X3JpY2hDb2xvcnMsIF9pY29uc19jbG9zZTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGlcIiwge1xuICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgcmVmOiB0b2FzdFJlZixcbiAgICAgICAgY2xhc3NOYW1lOiBjbihjbGFzc05hbWUsIHRvYXN0Q2xhc3NuYW1lLCBjbGFzc05hbWVzID09IG51bGwgPyB2b2lkIDAgOiBjbGFzc05hbWVzLnRvYXN0LCB0b2FzdCA9PSBudWxsID8gdm9pZCAwIDogKF90b2FzdF9jbGFzc05hbWVzID0gdG9hc3QuY2xhc3NOYW1lcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90b2FzdF9jbGFzc05hbWVzLnRvYXN0LCBjbGFzc05hbWVzID09IG51bGwgPyB2b2lkIDAgOiBjbGFzc05hbWVzLmRlZmF1bHQsIGNsYXNzTmFtZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGNsYXNzTmFtZXNbdG9hc3RUeXBlXSwgdG9hc3QgPT0gbnVsbCA/IHZvaWQgMCA6IChfdG9hc3RfY2xhc3NOYW1lczEgPSB0b2FzdC5jbGFzc05hbWVzKSA9PSBudWxsID8gdm9pZCAwIDogX3RvYXN0X2NsYXNzTmFtZXMxW3RvYXN0VHlwZV0pLFxuICAgICAgICBcImRhdGEtc29ubmVyLXRvYXN0XCI6IFwiXCIsXG4gICAgICAgIFwiZGF0YS1yaWNoLWNvbG9yc1wiOiAoX3RvYXN0X3JpY2hDb2xvcnMgPSB0b2FzdC5yaWNoQ29sb3JzKSAhPSBudWxsID8gX3RvYXN0X3JpY2hDb2xvcnMgOiBkZWZhdWx0UmljaENvbG9ycyxcbiAgICAgICAgXCJkYXRhLXN0eWxlZFwiOiAhQm9vbGVhbih0b2FzdC5qc3ggfHwgdG9hc3QudW5zdHlsZWQgfHwgdW5zdHlsZWQpLFxuICAgICAgICBcImRhdGEtbW91bnRlZFwiOiBtb3VudGVkLFxuICAgICAgICBcImRhdGEtcHJvbWlzZVwiOiBCb29sZWFuKHRvYXN0LnByb21pc2UpLFxuICAgICAgICBcImRhdGEtc3dpcGVkXCI6IGlzU3dpcGVkLFxuICAgICAgICBcImRhdGEtcmVtb3ZlZFwiOiByZW1vdmVkLFxuICAgICAgICBcImRhdGEtdmlzaWJsZVwiOiBpc1Zpc2libGUsXG4gICAgICAgIFwiZGF0YS15LXBvc2l0aW9uXCI6IHksXG4gICAgICAgIFwiZGF0YS14LXBvc2l0aW9uXCI6IHgsXG4gICAgICAgIFwiZGF0YS1pbmRleFwiOiBpbmRleCxcbiAgICAgICAgXCJkYXRhLWZyb250XCI6IGlzRnJvbnQsXG4gICAgICAgIFwiZGF0YS1zd2lwaW5nXCI6IHN3aXBpbmcsXG4gICAgICAgIFwiZGF0YS1kaXNtaXNzaWJsZVwiOiBkaXNtaXNzaWJsZSxcbiAgICAgICAgXCJkYXRhLXR5cGVcIjogdG9hc3RUeXBlLFxuICAgICAgICBcImRhdGEtaW52ZXJ0XCI6IGludmVydCxcbiAgICAgICAgXCJkYXRhLXN3aXBlLW91dFwiOiBzd2lwZU91dCxcbiAgICAgICAgXCJkYXRhLXN3aXBlLWRpcmVjdGlvblwiOiBzd2lwZU91dERpcmVjdGlvbixcbiAgICAgICAgXCJkYXRhLWV4cGFuZGVkXCI6IEJvb2xlYW4oZXhwYW5kZWQgfHwgZXhwYW5kQnlEZWZhdWx0ICYmIG1vdW50ZWQpLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgJy0taW5kZXgnOiBpbmRleCxcbiAgICAgICAgICAgICctLXRvYXN0cy1iZWZvcmUnOiBpbmRleCxcbiAgICAgICAgICAgICctLXotaW5kZXgnOiB0b2FzdHMubGVuZ3RoIC0gaW5kZXgsXG4gICAgICAgICAgICAnLS1vZmZzZXQnOiBgJHtyZW1vdmVkID8gb2Zmc2V0QmVmb3JlUmVtb3ZlIDogb2Zmc2V0LmN1cnJlbnR9cHhgLFxuICAgICAgICAgICAgJy0taW5pdGlhbC1oZWlnaHQnOiBleHBhbmRCeURlZmF1bHQgPyAnYXV0bycgOiBgJHtpbml0aWFsSGVpZ2h0fXB4YCxcbiAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgLi4udG9hc3Quc3R5bGVcbiAgICAgICAgfSxcbiAgICAgICAgb25EcmFnRW5kOiAoKT0+e1xuICAgICAgICAgICAgc2V0U3dpcGluZyhmYWxzZSk7XG4gICAgICAgICAgICBzZXRTd2lwZURpcmVjdGlvbihudWxsKTtcbiAgICAgICAgICAgIHBvaW50ZXJTdGFydFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyRG93bjogKGV2ZW50KT0+e1xuICAgICAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMikgcmV0dXJuOyAvLyBSZXR1cm4gZWFybHkgb24gcmlnaHQgY2xpY2tcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZCB8fCAhZGlzbWlzc2libGUpIHJldHVybjtcbiAgICAgICAgICAgIGRyYWdTdGFydFRpbWUuY3VycmVudCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBzZXRPZmZzZXRCZWZvcmVSZW1vdmUob2Zmc2V0LmN1cnJlbnQpO1xuICAgICAgICAgICAgLy8gRW5zdXJlIHdlIG1haW50YWluIGNvcnJlY3QgcG9pbnRlciBjYXB0dXJlIGV2ZW4gd2hlbiBnb2luZyBvdXRzaWRlIG9mIHRoZSB0b2FzdCAoZS5nLiB3aGVuIHN3aXBpbmcpXG4gICAgICAgICAgICBldmVudC50YXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQudGFnTmFtZSA9PT0gJ0JVVFRPTicpIHJldHVybjtcbiAgICAgICAgICAgIHNldFN3aXBpbmcodHJ1ZSk7XG4gICAgICAgICAgICBwb2ludGVyU3RhcnRSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uUG9pbnRlclVwOiAoKT0+e1xuICAgICAgICAgICAgdmFyIF90b2FzdFJlZl9jdXJyZW50LCBfdG9hc3RSZWZfY3VycmVudDEsIF9kcmFnU3RhcnRUaW1lX2N1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoc3dpcGVPdXQgfHwgIWRpc21pc3NpYmxlKSByZXR1cm47XG4gICAgICAgICAgICBwb2ludGVyU3RhcnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBzd2lwZUFtb3VudFggPSBOdW1iZXIoKChfdG9hc3RSZWZfY3VycmVudCA9IHRvYXN0UmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfdG9hc3RSZWZfY3VycmVudC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCctLXN3aXBlLWFtb3VudC14JykucmVwbGFjZSgncHgnLCAnJykpIHx8IDApO1xuICAgICAgICAgICAgY29uc3Qgc3dpcGVBbW91bnRZID0gTnVtYmVyKCgoX3RvYXN0UmVmX2N1cnJlbnQxID0gdG9hc3RSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90b2FzdFJlZl9jdXJyZW50MS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCctLXN3aXBlLWFtb3VudC15JykucmVwbGFjZSgncHgnLCAnJykpIHx8IDApO1xuICAgICAgICAgICAgY29uc3QgdGltZVRha2VuID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSAoKF9kcmFnU3RhcnRUaW1lX2N1cnJlbnQgPSBkcmFnU3RhcnRUaW1lLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZHJhZ1N0YXJ0VGltZV9jdXJyZW50LmdldFRpbWUoKSk7XG4gICAgICAgICAgICBjb25zdCBzd2lwZUFtb3VudCA9IHN3aXBlRGlyZWN0aW9uID09PSAneCcgPyBzd2lwZUFtb3VudFggOiBzd2lwZUFtb3VudFk7XG4gICAgICAgICAgICBjb25zdCB2ZWxvY2l0eSA9IE1hdGguYWJzKHN3aXBlQW1vdW50KSAvIHRpbWVUYWtlbjtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzd2lwZUFtb3VudCkgPj0gU1dJUEVfVEhSRVNIT0xEIHx8IHZlbG9jaXR5ID4gMC4xMSkge1xuICAgICAgICAgICAgICAgIHNldE9mZnNldEJlZm9yZVJlbW92ZShvZmZzZXQuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgdG9hc3Qub25EaXNtaXNzID09IG51bGwgPyB2b2lkIDAgOiB0b2FzdC5vbkRpc21pc3MuY2FsbCh0b2FzdCwgdG9hc3QpO1xuICAgICAgICAgICAgICAgIGlmIChzd2lwZURpcmVjdGlvbiA9PT0gJ3gnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFN3aXBlT3V0RGlyZWN0aW9uKHN3aXBlQW1vdW50WCA+IDAgPyAncmlnaHQnIDogJ2xlZnQnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRTd2lwZU91dERpcmVjdGlvbihzd2lwZUFtb3VudFkgPiAwID8gJ2Rvd24nIDogJ3VwJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZVRvYXN0KCk7XG4gICAgICAgICAgICAgICAgc2V0U3dpcGVPdXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RvYXN0UmVmX2N1cnJlbnQyLCBfdG9hc3RSZWZfY3VycmVudDM7XG4gICAgICAgICAgICAgICAgKF90b2FzdFJlZl9jdXJyZW50MiA9IHRvYXN0UmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfdG9hc3RSZWZfY3VycmVudDIuc3R5bGUuc2V0UHJvcGVydHkoJy0tc3dpcGUtYW1vdW50LXgnLCBgMHB4YCk7XG4gICAgICAgICAgICAgICAgKF90b2FzdFJlZl9jdXJyZW50MyA9IHRvYXN0UmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfdG9hc3RSZWZfY3VycmVudDMuc3R5bGUuc2V0UHJvcGVydHkoJy0tc3dpcGUtYW1vdW50LXknLCBgMHB4YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRJc1N3aXBlZChmYWxzZSk7XG4gICAgICAgICAgICBzZXRTd2lwaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHNldFN3aXBlRGlyZWN0aW9uKG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJNb3ZlOiAoZXZlbnQpPT57XG4gICAgICAgICAgICB2YXIgX3dpbmRvd19nZXRTZWxlY3Rpb24sIC8vIEFwcGx5IHRyYW5zZm9ybSB1c2luZyBib3RoIHggYW5kIHkgdmFsdWVzXG4gICAgICAgICAgICBfdG9hc3RSZWZfY3VycmVudCwgX3RvYXN0UmVmX2N1cnJlbnQxO1xuICAgICAgICAgICAgaWYgKCFwb2ludGVyU3RhcnRSZWYuY3VycmVudCB8fCAhZGlzbWlzc2libGUpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGlzSGlnaGxpZ2h0ZWQgPSAoKF93aW5kb3dfZ2V0U2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpKSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvd19nZXRTZWxlY3Rpb24udG9TdHJpbmcoKS5sZW5ndGgpID4gMDtcbiAgICAgICAgICAgIGlmIChpc0hpZ2hsaWdodGVkKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB5RGVsdGEgPSBldmVudC5jbGllbnRZIC0gcG9pbnRlclN0YXJ0UmVmLmN1cnJlbnQueTtcbiAgICAgICAgICAgIGNvbnN0IHhEZWx0YSA9IGV2ZW50LmNsaWVudFggLSBwb2ludGVyU3RhcnRSZWYuY3VycmVudC54O1xuICAgICAgICAgICAgdmFyIF9wcm9wc19zd2lwZURpcmVjdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBzd2lwZURpcmVjdGlvbnMgPSAoX3Byb3BzX3N3aXBlRGlyZWN0aW9ucyA9IHByb3BzLnN3aXBlRGlyZWN0aW9ucykgIT0gbnVsbCA/IF9wcm9wc19zd2lwZURpcmVjdGlvbnMgOiBnZXREZWZhdWx0U3dpcGVEaXJlY3Rpb25zKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIC8vIERldGVybWluZSBzd2lwZSBkaXJlY3Rpb24gaWYgbm90IGFscmVhZHkgbG9ja2VkXG4gICAgICAgICAgICBpZiAoIXN3aXBlRGlyZWN0aW9uICYmIChNYXRoLmFicyh4RGVsdGEpID4gMSB8fCBNYXRoLmFicyh5RGVsdGEpID4gMSkpIHtcbiAgICAgICAgICAgICAgICBzZXRTd2lwZURpcmVjdGlvbihNYXRoLmFicyh4RGVsdGEpID4gTWF0aC5hYnMoeURlbHRhKSA/ICd4JyA6ICd5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3dpcGVBbW91bnQgPSB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZ2V0RGFtcGVuaW5nID0gKGRlbHRhKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhY3RvciA9IE1hdGguYWJzKGRlbHRhKSAvIDIwO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8gKDEuNSArIGZhY3Rvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gT25seSBhcHBseSBzd2lwZSBpbiB0aGUgbG9ja2VkIGRpcmVjdGlvblxuICAgICAgICAgICAgaWYgKHN3aXBlRGlyZWN0aW9uID09PSAneScpIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdmVydGljYWwgc3dpcGVzXG4gICAgICAgICAgICAgICAgaWYgKHN3aXBlRGlyZWN0aW9ucy5pbmNsdWRlcygndG9wJykgfHwgc3dpcGVEaXJlY3Rpb25zLmluY2x1ZGVzKCdib3R0b20nKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3dpcGVEaXJlY3Rpb25zLmluY2x1ZGVzKCd0b3AnKSAmJiB5RGVsdGEgPCAwIHx8IHN3aXBlRGlyZWN0aW9ucy5pbmNsdWRlcygnYm90dG9tJykgJiYgeURlbHRhID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpcGVBbW91bnQueSA9IHlEZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNtb290aGx5IHRyYW5zaXRpb24gdG8gZGFtcGVuZWQgbW92ZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhbXBlbmVkRGVsdGEgPSB5RGVsdGEgKiBnZXREYW1wZW5pbmcoeURlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB3ZSBkb24ndCBqdW1wIHdoZW4gdHJhbnNpdGlvbmluZyB0byBkYW1wZW5lZCBtb3ZlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpcGVBbW91bnQueSA9IE1hdGguYWJzKGRhbXBlbmVkRGVsdGEpIDwgTWF0aC5hYnMoeURlbHRhKSA/IGRhbXBlbmVkRGVsdGEgOiB5RGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN3aXBlRGlyZWN0aW9uID09PSAneCcpIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgaG9yaXpvbnRhbCBzd2lwZXNcbiAgICAgICAgICAgICAgICBpZiAoc3dpcGVEaXJlY3Rpb25zLmluY2x1ZGVzKCdsZWZ0JykgfHwgc3dpcGVEaXJlY3Rpb25zLmluY2x1ZGVzKCdyaWdodCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzd2lwZURpcmVjdGlvbnMuaW5jbHVkZXMoJ2xlZnQnKSAmJiB4RGVsdGEgPCAwIHx8IHN3aXBlRGlyZWN0aW9ucy5pbmNsdWRlcygncmlnaHQnKSAmJiB4RGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2lwZUFtb3VudC54ID0geERlbHRhO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU21vb3RobHkgdHJhbnNpdGlvbiB0byBkYW1wZW5lZCBtb3ZlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGFtcGVuZWREZWx0YSA9IHhEZWx0YSAqIGdldERhbXBlbmluZyh4RGVsdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHdlIGRvbid0IGp1bXAgd2hlbiB0cmFuc2l0aW9uaW5nIHRvIGRhbXBlbmVkIG1vdmVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2lwZUFtb3VudC54ID0gTWF0aC5hYnMoZGFtcGVuZWREZWx0YSkgPCBNYXRoLmFicyh4RGVsdGEpID8gZGFtcGVuZWREZWx0YSA6IHhEZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzd2lwZUFtb3VudC54KSA+IDAgfHwgTWF0aC5hYnMoc3dpcGVBbW91bnQueSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgc2V0SXNTd2lwZWQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX3RvYXN0UmVmX2N1cnJlbnQgPSB0b2FzdFJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3RvYXN0UmVmX2N1cnJlbnQuc3R5bGUuc2V0UHJvcGVydHkoJy0tc3dpcGUtYW1vdW50LXgnLCBgJHtzd2lwZUFtb3VudC54fXB4YCk7XG4gICAgICAgICAgICAoX3RvYXN0UmVmX2N1cnJlbnQxID0gdG9hc3RSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90b2FzdFJlZl9jdXJyZW50MS5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1zd2lwZS1hbW91bnQteScsIGAke3N3aXBlQW1vdW50Lnl9cHhgKTtcbiAgICAgICAgfVxuICAgIH0sIGNsb3NlQnV0dG9uICYmICF0b2FzdC5qc3ggJiYgdG9hc3RUeXBlICE9PSAnbG9hZGluZycgPyAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgICAgICBcImFyaWEtbGFiZWxcIjogY2xvc2VCdXR0b25BcmlhTGFiZWwsXG4gICAgICAgIFwiZGF0YS1kaXNhYmxlZFwiOiBkaXNhYmxlZCxcbiAgICAgICAgXCJkYXRhLWNsb3NlLWJ1dHRvblwiOiB0cnVlLFxuICAgICAgICBvbkNsaWNrOiBkaXNhYmxlZCB8fCAhZGlzbWlzc2libGUgPyAoKT0+e30gOiAoKT0+e1xuICAgICAgICAgICAgZGVsZXRlVG9hc3QoKTtcbiAgICAgICAgICAgIHRvYXN0Lm9uRGlzbWlzcyA9PSBudWxsID8gdm9pZCAwIDogdG9hc3Qub25EaXNtaXNzLmNhbGwodG9hc3QsIHRvYXN0KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbihjbGFzc05hbWVzID09IG51bGwgPyB2b2lkIDAgOiBjbGFzc05hbWVzLmNsb3NlQnV0dG9uLCB0b2FzdCA9PSBudWxsID8gdm9pZCAwIDogKF90b2FzdF9jbGFzc05hbWVzMiA9IHRvYXN0LmNsYXNzTmFtZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdG9hc3RfY2xhc3NOYW1lczIuY2xvc2VCdXR0b24pXG4gICAgfSwgKF9pY29uc19jbG9zZSA9IGljb25zID09IG51bGwgPyB2b2lkIDAgOiBpY29ucy5jbG9zZSkgIT0gbnVsbCA/IF9pY29uc19jbG9zZSA6IENsb3NlSWNvbikgOiBudWxsLCAodG9hc3RUeXBlIHx8IHRvYXN0Lmljb24gfHwgdG9hc3QucHJvbWlzZSkgJiYgdG9hc3QuaWNvbiAhPT0gbnVsbCAmJiAoKGljb25zID09IG51bGwgPyB2b2lkIDAgOiBpY29uc1t0b2FzdFR5cGVdKSAhPT0gbnVsbCB8fCB0b2FzdC5pY29uKSA/IC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIFwiZGF0YS1pY29uXCI6IFwiXCIsXG4gICAgICAgIGNsYXNzTmFtZTogY24oY2xhc3NOYW1lcyA9PSBudWxsID8gdm9pZCAwIDogY2xhc3NOYW1lcy5pY29uLCB0b2FzdCA9PSBudWxsID8gdm9pZCAwIDogKF90b2FzdF9jbGFzc05hbWVzMyA9IHRvYXN0LmNsYXNzTmFtZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdG9hc3RfY2xhc3NOYW1lczMuaWNvbilcbiAgICB9LCB0b2FzdC5wcm9taXNlIHx8IHRvYXN0LnR5cGUgPT09ICdsb2FkaW5nJyAmJiAhdG9hc3QuaWNvbiA/IHRvYXN0Lmljb24gfHwgZ2V0TG9hZGluZ0ljb24oKSA6IG51bGwsIHRvYXN0LnR5cGUgIT09ICdsb2FkaW5nJyA/IGljb24gOiBudWxsKSA6IG51bGwsIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIFwiZGF0YS1jb250ZW50XCI6IFwiXCIsXG4gICAgICAgIGNsYXNzTmFtZTogY24oY2xhc3NOYW1lcyA9PSBudWxsID8gdm9pZCAwIDogY2xhc3NOYW1lcy5jb250ZW50LCB0b2FzdCA9PSBudWxsID8gdm9pZCAwIDogKF90b2FzdF9jbGFzc05hbWVzNCA9IHRvYXN0LmNsYXNzTmFtZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdG9hc3RfY2xhc3NOYW1lczQuY29udGVudClcbiAgICB9LCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBcImRhdGEtdGl0bGVcIjogXCJcIixcbiAgICAgICAgY2xhc3NOYW1lOiBjbihjbGFzc05hbWVzID09IG51bGwgPyB2b2lkIDAgOiBjbGFzc05hbWVzLnRpdGxlLCB0b2FzdCA9PSBudWxsID8gdm9pZCAwIDogKF90b2FzdF9jbGFzc05hbWVzNSA9IHRvYXN0LmNsYXNzTmFtZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdG9hc3RfY2xhc3NOYW1lczUudGl0bGUpXG4gICAgfSwgdG9hc3QuanN4ID8gdG9hc3QuanN4IDogdHlwZW9mIHRvYXN0LnRpdGxlID09PSAnZnVuY3Rpb24nID8gdG9hc3QudGl0bGUoKSA6IHRvYXN0LnRpdGxlKSwgdG9hc3QuZGVzY3JpcHRpb24gPyAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBcImRhdGEtZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICAgICAgY2xhc3NOYW1lOiBjbihkZXNjcmlwdGlvbkNsYXNzTmFtZSwgdG9hc3REZXNjcmlwdGlvbkNsYXNzbmFtZSwgY2xhc3NOYW1lcyA9PSBudWxsID8gdm9pZCAwIDogY2xhc3NOYW1lcy5kZXNjcmlwdGlvbiwgdG9hc3QgPT0gbnVsbCA/IHZvaWQgMCA6IChfdG9hc3RfY2xhc3NOYW1lczYgPSB0b2FzdC5jbGFzc05hbWVzKSA9PSBudWxsID8gdm9pZCAwIDogX3RvYXN0X2NsYXNzTmFtZXM2LmRlc2NyaXB0aW9uKVxuICAgIH0sIHR5cGVvZiB0b2FzdC5kZXNjcmlwdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHRvYXN0LmRlc2NyaXB0aW9uKCkgOiB0b2FzdC5kZXNjcmlwdGlvbikgOiBudWxsKSwgLyojX19QVVJFX18qLyBSZWFjdC5pc1ZhbGlkRWxlbWVudCh0b2FzdC5jYW5jZWwpID8gdG9hc3QuY2FuY2VsIDogdG9hc3QuY2FuY2VsICYmIGlzQWN0aW9uKHRvYXN0LmNhbmNlbCkgPyAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgICAgICBcImRhdGEtYnV0dG9uXCI6IHRydWUsXG4gICAgICAgIFwiZGF0YS1jYW5jZWxcIjogdHJ1ZSxcbiAgICAgICAgc3R5bGU6IHRvYXN0LmNhbmNlbEJ1dHRvblN0eWxlIHx8IGNhbmNlbEJ1dHRvblN0eWxlLFxuICAgICAgICBvbkNsaWNrOiAoZXZlbnQpPT57XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIHR3aWNlIGJlY2F1c2UgdHlwZXNjcmlwdFxuICAgICAgICAgICAgaWYgKCFpc0FjdGlvbih0b2FzdC5jYW5jZWwpKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWRpc21pc3NpYmxlKSByZXR1cm47XG4gICAgICAgICAgICB0b2FzdC5jYW5jZWwub25DbGljayA9PSBudWxsID8gdm9pZCAwIDogdG9hc3QuY2FuY2VsLm9uQ2xpY2suY2FsbCh0b2FzdC5jYW5jZWwsIGV2ZW50KTtcbiAgICAgICAgICAgIGRlbGV0ZVRvYXN0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzTmFtZTogY24oY2xhc3NOYW1lcyA9PSBudWxsID8gdm9pZCAwIDogY2xhc3NOYW1lcy5jYW5jZWxCdXR0b24sIHRvYXN0ID09IG51bGwgPyB2b2lkIDAgOiAoX3RvYXN0X2NsYXNzTmFtZXM3ID0gdG9hc3QuY2xhc3NOYW1lcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90b2FzdF9jbGFzc05hbWVzNy5jYW5jZWxCdXR0b24pXG4gICAgfSwgdG9hc3QuY2FuY2VsLmxhYmVsKSA6IG51bGwsIC8qI19fUFVSRV9fKi8gUmVhY3QuaXNWYWxpZEVsZW1lbnQodG9hc3QuYWN0aW9uKSA/IHRvYXN0LmFjdGlvbiA6IHRvYXN0LmFjdGlvbiAmJiBpc0FjdGlvbih0b2FzdC5hY3Rpb24pID8gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgXCJkYXRhLWJ1dHRvblwiOiB0cnVlLFxuICAgICAgICBcImRhdGEtYWN0aW9uXCI6IHRydWUsXG4gICAgICAgIHN0eWxlOiB0b2FzdC5hY3Rpb25CdXR0b25TdHlsZSB8fCBhY3Rpb25CdXR0b25TdHlsZSxcbiAgICAgICAgb25DbGljazogKGV2ZW50KT0+e1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayB0d2ljZSBiZWNhdXNlIHR5cGVzY3JpcHRcbiAgICAgICAgICAgIGlmICghaXNBY3Rpb24odG9hc3QuYWN0aW9uKSkgcmV0dXJuO1xuICAgICAgICAgICAgdG9hc3QuYWN0aW9uLm9uQ2xpY2sgPT0gbnVsbCA/IHZvaWQgMCA6IHRvYXN0LmFjdGlvbi5vbkNsaWNrLmNhbGwodG9hc3QuYWN0aW9uLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgICAgICAgZGVsZXRlVG9hc3QoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbihjbGFzc05hbWVzID09IG51bGwgPyB2b2lkIDAgOiBjbGFzc05hbWVzLmFjdGlvbkJ1dHRvbiwgdG9hc3QgPT0gbnVsbCA/IHZvaWQgMCA6IChfdG9hc3RfY2xhc3NOYW1lczggPSB0b2FzdC5jbGFzc05hbWVzKSA9PSBudWxsID8gdm9pZCAwIDogX3RvYXN0X2NsYXNzTmFtZXM4LmFjdGlvbkJ1dHRvbilcbiAgICB9LCB0b2FzdC5hY3Rpb24ubGFiZWwpIDogbnVsbCk7XG59O1xuZnVuY3Rpb24gZ2V0RG9jdW1lbnREaXJlY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gJ2x0cic7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiAnbHRyJzsgLy8gRm9yIEZyZXNoIHB1cnBvc2VcbiAgICBjb25zdCBkaXJBdHRyaWJ1dGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXInKTtcbiAgICBpZiAoZGlyQXR0cmlidXRlID09PSAnYXV0bycgfHwgIWRpckF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5kaXJlY3Rpb247XG4gICAgfVxuICAgIHJldHVybiBkaXJBdHRyaWJ1dGU7XG59XG5mdW5jdGlvbiBhc3NpZ25PZmZzZXQoZGVmYXVsdE9mZnNldCwgbW9iaWxlT2Zmc2V0KSB7XG4gICAgY29uc3Qgc3R5bGVzID0ge307XG4gICAgW1xuICAgICAgICBkZWZhdWx0T2Zmc2V0LFxuICAgICAgICBtb2JpbGVPZmZzZXRcbiAgICBdLmZvckVhY2goKG9mZnNldCwgaW5kZXgpPT57XG4gICAgICAgIGNvbnN0IGlzTW9iaWxlID0gaW5kZXggPT09IDE7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGlzTW9iaWxlID8gJy0tbW9iaWxlLW9mZnNldCcgOiAnLS1vZmZzZXQnO1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBpc01vYmlsZSA/IE1PQklMRV9WSUVXUE9SVF9PRkZTRVQgOiBWSUVXUE9SVF9PRkZTRVQ7XG4gICAgICAgIGZ1bmN0aW9uIGFzc2lnbkFsbChvZmZzZXQpIHtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAndG9wJyxcbiAgICAgICAgICAgICAgICAncmlnaHQnLFxuICAgICAgICAgICAgICAgICdib3R0b20nLFxuICAgICAgICAgICAgICAgICdsZWZ0J1xuICAgICAgICAgICAgXS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICAgICAgc3R5bGVzW2Ake3ByZWZpeH0tJHtrZXl9YF0gPSB0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJyA/IGAke29mZnNldH1weGAgOiBvZmZzZXQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGFzc2lnbkFsbChvZmZzZXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3RvcCcsXG4gICAgICAgICAgICAgICAgJ3JpZ2h0JyxcbiAgICAgICAgICAgICAgICAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICAnbGVmdCdcbiAgICAgICAgICAgIF0uZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc1tgJHtwcmVmaXh9LSR7a2V5fWBdID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc1tgJHtwcmVmaXh9LSR7a2V5fWBdID0gdHlwZW9mIG9mZnNldFtrZXldID09PSAnbnVtYmVyJyA/IGAke29mZnNldFtrZXldfXB4YCA6IG9mZnNldFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXNzaWduQWxsKGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3R5bGVzO1xufVxuZnVuY3Rpb24gdXNlU29ubmVyKCkge1xuICAgIGNvbnN0IFthY3RpdmVUb2FzdHMsIHNldEFjdGl2ZVRvYXN0c10gPSBSZWFjdC51c2VTdGF0ZShbXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIHJldHVybiBUb2FzdFN0YXRlLnN1YnNjcmliZSgodG9hc3QpPT57XG4gICAgICAgICAgICBpZiAodG9hc3QuZGlzbWlzcykge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgUmVhY3RET00uZmx1c2hTeW5jKCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmVUb2FzdHMoKHRvYXN0cyk9PnRvYXN0cy5maWx0ZXIoKHQpPT50LmlkICE9PSB0b2FzdC5pZCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGJhdGNoaW5nLCB0ZW1wIHNvbHV0aW9uLlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgIFJlYWN0RE9NLmZsdXNoU3luYygoKT0+e1xuICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmVUb2FzdHMoKHRvYXN0cyk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4T2ZFeGlzdGluZ1RvYXN0ID0gdG9hc3RzLmZpbmRJbmRleCgodCk9PnQuaWQgPT09IHRvYXN0LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdG9hc3QgaWYgaXQgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleE9mRXhpc3RpbmdUb2FzdCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi50b2FzdHMuc2xpY2UoMCwgaW5kZXhPZkV4aXN0aW5nVG9hc3QpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi50b2FzdHNbaW5kZXhPZkV4aXN0aW5nVG9hc3RdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udG9hc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udG9hc3RzLnNsaWNlKGluZGV4T2ZFeGlzdGluZ1RvYXN0ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2FzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi50b2FzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b2FzdHM6IGFjdGl2ZVRvYXN0c1xuICAgIH07XG59XG5jb25zdCBUb2FzdGVyID0gLyojX19QVVJFX18qLyBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFRvYXN0ZXIocHJvcHMsIHJlZikge1xuICAgIGNvbnN0IHsgaW52ZXJ0LCBwb3NpdGlvbiA9ICdib3R0b20tcmlnaHQnLCBob3RrZXkgPSBbXG4gICAgICAgICdhbHRLZXknLFxuICAgICAgICAnS2V5VCdcbiAgICBdLCBleHBhbmQsIGNsb3NlQnV0dG9uLCBjbGFzc05hbWUsIG9mZnNldCwgbW9iaWxlT2Zmc2V0LCB0aGVtZSA9ICdsaWdodCcsIHJpY2hDb2xvcnMsIGR1cmF0aW9uLCBzdHlsZSwgdmlzaWJsZVRvYXN0cyA9IFZJU0lCTEVfVE9BU1RTX0FNT1VOVCwgdG9hc3RPcHRpb25zLCBkaXIgPSBnZXREb2N1bWVudERpcmVjdGlvbigpLCBnYXAgPSBHQVAsIGljb25zLCBjb250YWluZXJBcmlhTGFiZWwgPSAnTm90aWZpY2F0aW9ucycgfSA9IHByb3BzO1xuICAgIGNvbnN0IFt0b2FzdHMsIHNldFRvYXN0c10gPSBSZWFjdC51c2VTdGF0ZShbXSk7XG4gICAgY29uc3QgcG9zc2libGVQb3NpdGlvbnMgPSBSZWFjdC51c2VNZW1vKCgpPT57XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoW1xuICAgICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgXS5jb25jYXQodG9hc3RzLmZpbHRlcigodG9hc3QpPT50b2FzdC5wb3NpdGlvbikubWFwKCh0b2FzdCk9PnRvYXN0LnBvc2l0aW9uKSkpKTtcbiAgICB9LCBbXG4gICAgICAgIHRvYXN0cyxcbiAgICAgICAgcG9zaXRpb25cbiAgICBdKTtcbiAgICBjb25zdCBbaGVpZ2h0cywgc2V0SGVpZ2h0c10gPSBSZWFjdC51c2VTdGF0ZShbXSk7XG4gICAgY29uc3QgW2V4cGFuZGVkLCBzZXRFeHBhbmRlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2ludGVyYWN0aW5nLCBzZXRJbnRlcmFjdGluZ10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2FjdHVhbFRoZW1lLCBzZXRBY3R1YWxUaGVtZV0gPSBSZWFjdC51c2VTdGF0ZSh0aGVtZSAhPT0gJ3N5c3RlbScgPyB0aGVtZSA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93Lm1hdGNoTWVkaWEgJiYgd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKS5tYXRjaGVzID8gJ2RhcmsnIDogJ2xpZ2h0JyA6ICdsaWdodCcpO1xuICAgIGNvbnN0IGxpc3RSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgaG90a2V5TGFiZWwgPSBob3RrZXkuam9pbignKycpLnJlcGxhY2UoL0tleS9nLCAnJykucmVwbGFjZSgvRGlnaXQvZywgJycpO1xuICAgIGNvbnN0IGxhc3RGb2N1c2VkRWxlbWVudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBpc0ZvY3VzV2l0aGluUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCByZW1vdmVUb2FzdCA9IFJlYWN0LnVzZUNhbGxiYWNrKCh0b2FzdFRvUmVtb3ZlKT0+e1xuICAgICAgICBzZXRUb2FzdHMoKHRvYXN0cyk9PntcbiAgICAgICAgICAgIHZhciBfdG9hc3RzX2ZpbmQ7XG4gICAgICAgICAgICBpZiAoISgoX3RvYXN0c19maW5kID0gdG9hc3RzLmZpbmQoKHRvYXN0KT0+dG9hc3QuaWQgPT09IHRvYXN0VG9SZW1vdmUuaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RvYXN0c19maW5kLmRlbGV0ZSkpIHtcbiAgICAgICAgICAgICAgICBUb2FzdFN0YXRlLmRpc21pc3ModG9hc3RUb1JlbW92ZS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9hc3RzLmZpbHRlcigoeyBpZCB9KT0+aWQgIT09IHRvYXN0VG9SZW1vdmUuaWQpO1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIHJldHVybiBUb2FzdFN0YXRlLnN1YnNjcmliZSgodG9hc3QpPT57XG4gICAgICAgICAgICBpZiAodG9hc3QuZGlzbWlzcykge1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgYmF0Y2hpbmcgb2Ygb3RoZXIgc3RhdGUgdXBkYXRlc1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgICAgICAgICBzZXRUb2FzdHMoKHRvYXN0cyk9PnRvYXN0cy5tYXAoKHQpPT50LmlkID09PSB0b2FzdC5pZCA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHQpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGJhdGNoaW5nLCB0ZW1wIHNvbHV0aW9uLlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgIFJlYWN0RE9NLmZsdXNoU3luYygoKT0+e1xuICAgICAgICAgICAgICAgICAgICBzZXRUb2FzdHMoKHRvYXN0cyk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4T2ZFeGlzdGluZ1RvYXN0ID0gdG9hc3RzLmZpbmRJbmRleCgodCk9PnQuaWQgPT09IHRvYXN0LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdG9hc3QgaWYgaXQgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleE9mRXhpc3RpbmdUb2FzdCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi50b2FzdHMuc2xpY2UoMCwgaW5kZXhPZkV4aXN0aW5nVG9hc3QpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi50b2FzdHNbaW5kZXhPZkV4aXN0aW5nVG9hc3RdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udG9hc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udG9hc3RzLnNsaWNlKGluZGV4T2ZFeGlzdGluZ1RvYXN0ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2FzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi50b2FzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgdG9hc3RzXG4gICAgXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmICh0aGVtZSAhPT0gJ3N5c3RlbScpIHtcbiAgICAgICAgICAgIHNldEFjdHVhbFRoZW1lKHRoZW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhlbWUgPT09ICdzeXN0ZW0nKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBjdXJyZW50IHByZWZlcmVuY2UgaXMgZGFya1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJykubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIC8vIGl0J3MgY3VycmVudGx5IGRhcmtcbiAgICAgICAgICAgICAgICBzZXRBY3R1YWxUaGVtZSgnZGFyaycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBkYXJrXG4gICAgICAgICAgICAgICAgc2V0QWN0dWFsVGhlbWUoJ2xpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGRhcmtNZWRpYVF1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENocm9tZSAmIEZpcmVmb3hcbiAgICAgICAgICAgIGRhcmtNZWRpYVF1ZXJ5LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICh7IG1hdGNoZXMgfSk9PntcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBzZXRBY3R1YWxUaGVtZSgnZGFyaycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFjdHVhbFRoZW1lKCdsaWdodCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gU2FmYXJpIDwgMTRcbiAgICAgICAgICAgIGRhcmtNZWRpYVF1ZXJ5LmFkZExpc3RlbmVyKCh7IG1hdGNoZXMgfSk9PntcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWN0dWFsVGhlbWUoJ2RhcmsnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFjdHVhbFRoZW1lKCdsaWdodCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICB0aGVtZVxuICAgIF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBFbnN1cmUgZXhwYW5kZWQgaXMgYWx3YXlzIGZhbHNlIHdoZW4gbm8gdG9hc3RzIGFyZSBwcmVzZW50IC8gb25seSBvbmUgbGVmdFxuICAgICAgICBpZiAodG9hc3RzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICBzZXRFeHBhbmRlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHRvYXN0c1xuICAgIF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50KT0+e1xuICAgICAgICAgICAgdmFyIF9saXN0UmVmX2N1cnJlbnQ7XG4gICAgICAgICAgICBjb25zdCBpc0hvdGtleVByZXNzZWQgPSBob3RrZXkuZXZlcnkoKGtleSk9PmV2ZW50W2tleV0gfHwgZXZlbnQuY29kZSA9PT0ga2V5KTtcbiAgICAgICAgICAgIGlmIChpc0hvdGtleVByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2xpc3RSZWZfY3VycmVudDE7XG4gICAgICAgICAgICAgICAgc2V0RXhwYW5kZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgKF9saXN0UmVmX2N1cnJlbnQxID0gbGlzdFJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2xpc3RSZWZfY3VycmVudDEuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVudC5jb2RlID09PSAnRXNjYXBlJyAmJiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gbGlzdFJlZi5jdXJyZW50IHx8ICgoX2xpc3RSZWZfY3VycmVudCA9IGxpc3RSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9saXN0UmVmX2N1cnJlbnQuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpKSkge1xuICAgICAgICAgICAgICAgIHNldEV4cGFuZGVkKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pO1xuICAgICAgICByZXR1cm4gKCk9PmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgICB9LCBbXG4gICAgICAgIGhvdGtleVxuICAgIF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAobGlzdFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICAgICBpZiAobGFzdEZvY3VzZWRFbGVtZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEZvY3VzZWRFbGVtZW50UmVmLmN1cnJlbnQuZm9jdXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEZvY3VzZWRFbGVtZW50UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpc0ZvY3VzV2l0aGluUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBsaXN0UmVmLmN1cnJlbnRcbiAgICBdKTtcbiAgICByZXR1cm4oLy8gUmVtb3ZlIGl0ZW0gZnJvbSBub3JtYWwgbmF2aWdhdGlvbiBmbG93LCBvbmx5IGF2YWlsYWJsZSB2aWEgaG90a2V5XG4gICAgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCB7XG4gICAgICAgIHJlZjogcmVmLFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogYCR7Y29udGFpbmVyQXJpYUxhYmVsfSAke2hvdGtleUxhYmVsfWAsXG4gICAgICAgIHRhYkluZGV4OiAtMSxcbiAgICAgICAgXCJhcmlhLWxpdmVcIjogXCJwb2xpdGVcIixcbiAgICAgICAgXCJhcmlhLXJlbGV2YW50XCI6IFwiYWRkaXRpb25zIHRleHRcIixcbiAgICAgICAgXCJhcmlhLWF0b21pY1wiOiBcImZhbHNlXCIsXG4gICAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZVxuICAgIH0sIHBvc3NpYmxlUG9zaXRpb25zLm1hcCgocG9zaXRpb24sIGluZGV4KT0+e1xuICAgICAgICB2YXIgX2hlaWdodHNfO1xuICAgICAgICBjb25zdCBbeSwgeF0gPSBwb3NpdGlvbi5zcGxpdCgnLScpO1xuICAgICAgICBpZiAoIXRvYXN0cy5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwib2xcIiwge1xuICAgICAgICAgICAga2V5OiBwb3NpdGlvbixcbiAgICAgICAgICAgIGRpcjogZGlyID09PSAnYXV0bycgPyBnZXREb2N1bWVudERpcmVjdGlvbigpIDogZGlyLFxuICAgICAgICAgICAgdGFiSW5kZXg6IC0xLFxuICAgICAgICAgICAgcmVmOiBsaXN0UmVmLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgICAgICBcImRhdGEtc29ubmVyLXRvYXN0ZXJcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiZGF0YS1zb25uZXItdGhlbWVcIjogYWN0dWFsVGhlbWUsXG4gICAgICAgICAgICBcImRhdGEteS1wb3NpdGlvblwiOiB5LFxuICAgICAgICAgICAgXCJkYXRhLXgtcG9zaXRpb25cIjogeCxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgJy0tZnJvbnQtdG9hc3QtaGVpZ2h0JzogYCR7KChfaGVpZ2h0c18gPSBoZWlnaHRzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2hlaWdodHNfLmhlaWdodCkgfHwgMH1weGAsXG4gICAgICAgICAgICAgICAgJy0td2lkdGgnOiBgJHtUT0FTVF9XSURUSH1weGAsXG4gICAgICAgICAgICAgICAgJy0tZ2FwJzogYCR7Z2FwfXB4YCxcbiAgICAgICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgICAgICAuLi5hc3NpZ25PZmZzZXQob2Zmc2V0LCBtb2JpbGVPZmZzZXQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25CbHVyOiAoZXZlbnQpPT57XG4gICAgICAgICAgICAgICAgaWYgKGlzRm9jdXNXaXRoaW5SZWYuY3VycmVudCAmJiAhZXZlbnQuY3VycmVudFRhcmdldC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBpc0ZvY3VzV2l0aGluUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RGb2N1c2VkRWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Rm9jdXNlZEVsZW1lbnRSZWYuY3VycmVudC5mb2N1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Rm9jdXNlZEVsZW1lbnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Gb2N1czogKGV2ZW50KT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzTm90RGlzbWlzc2libGUgPSBldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBldmVudC50YXJnZXQuZGF0YXNldC5kaXNtaXNzaWJsZSA9PT0gJ2ZhbHNlJztcbiAgICAgICAgICAgICAgICBpZiAoaXNOb3REaXNtaXNzaWJsZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghaXNGb2N1c1dpdGhpblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRm9jdXNXaXRoaW5SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RGb2N1c2VkRWxlbWVudFJlZi5jdXJyZW50ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Nb3VzZUVudGVyOiAoKT0+c2V0RXhwYW5kZWQodHJ1ZSksXG4gICAgICAgICAgICBvbk1vdXNlTW92ZTogKCk9PnNldEV4cGFuZGVkKHRydWUpLFxuICAgICAgICAgICAgb25Nb3VzZUxlYXZlOiAoKT0+e1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHNldHRpbmcgZXhwYW5kZWQgdG8gZmFsc2Ugd2hlbiBpbnRlcmFjdGluZyB3aXRoIGEgdG9hc3QsIGUuZy4gc3dpcGluZ1xuICAgICAgICAgICAgICAgIGlmICghaW50ZXJhY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RXhwYW5kZWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRyYWdFbmQ6ICgpPT5zZXRFeHBhbmRlZChmYWxzZSksXG4gICAgICAgICAgICBvblBvaW50ZXJEb3duOiAoZXZlbnQpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgaXNOb3REaXNtaXNzaWJsZSA9IGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGV2ZW50LnRhcmdldC5kYXRhc2V0LmRpc21pc3NpYmxlID09PSAnZmFsc2UnO1xuICAgICAgICAgICAgICAgIGlmIChpc05vdERpc21pc3NpYmxlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc2V0SW50ZXJhY3RpbmcodHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Qb2ludGVyVXA6ICgpPT5zZXRJbnRlcmFjdGluZyhmYWxzZSlcbiAgICAgICAgfSwgdG9hc3RzLmZpbHRlcigodG9hc3QpPT4hdG9hc3QucG9zaXRpb24gJiYgaW5kZXggPT09IDAgfHwgdG9hc3QucG9zaXRpb24gPT09IHBvc2l0aW9uKS5tYXAoKHRvYXN0LCBpbmRleCk9PntcbiAgICAgICAgICAgIHZhciBfdG9hc3RPcHRpb25zX2R1cmF0aW9uLCBfdG9hc3RPcHRpb25zX2Nsb3NlQnV0dG9uO1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChUb2FzdCwge1xuICAgICAgICAgICAgICAgIGtleTogdG9hc3QuaWQsXG4gICAgICAgICAgICAgICAgaWNvbnM6IGljb25zLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICB0b2FzdDogdG9hc3QsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFJpY2hDb2xvcnM6IHJpY2hDb2xvcnMsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IChfdG9hc3RPcHRpb25zX2R1cmF0aW9uID0gdG9hc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiB0b2FzdE9wdGlvbnMuZHVyYXRpb24pICE9IG51bGwgPyBfdG9hc3RPcHRpb25zX2R1cmF0aW9uIDogZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB0b2FzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvYXN0T3B0aW9ucy5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb25DbGFzc05hbWU6IHRvYXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogdG9hc3RPcHRpb25zLmRlc2NyaXB0aW9uQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGludmVydDogaW52ZXJ0LFxuICAgICAgICAgICAgICAgIHZpc2libGVUb2FzdHM6IHZpc2libGVUb2FzdHMsXG4gICAgICAgICAgICAgICAgY2xvc2VCdXR0b246IChfdG9hc3RPcHRpb25zX2Nsb3NlQnV0dG9uID0gdG9hc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiB0b2FzdE9wdGlvbnMuY2xvc2VCdXR0b24pICE9IG51bGwgPyBfdG9hc3RPcHRpb25zX2Nsb3NlQnV0dG9uIDogY2xvc2VCdXR0b24sXG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpbmc6IGludGVyYWN0aW5nLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICBzdHlsZTogdG9hc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiB0b2FzdE9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICAgICAgdW5zdHlsZWQ6IHRvYXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogdG9hc3RPcHRpb25zLnVuc3R5bGVkLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IHRvYXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogdG9hc3RPcHRpb25zLmNsYXNzTmFtZXMsXG4gICAgICAgICAgICAgICAgY2FuY2VsQnV0dG9uU3R5bGU6IHRvYXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogdG9hc3RPcHRpb25zLmNhbmNlbEJ1dHRvblN0eWxlLFxuICAgICAgICAgICAgICAgIGFjdGlvbkJ1dHRvblN0eWxlOiB0b2FzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvYXN0T3B0aW9ucy5hY3Rpb25CdXR0b25TdHlsZSxcbiAgICAgICAgICAgICAgICBjbG9zZUJ1dHRvbkFyaWFMYWJlbDogdG9hc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiB0b2FzdE9wdGlvbnMuY2xvc2VCdXR0b25BcmlhTGFiZWwsXG4gICAgICAgICAgICAgICAgcmVtb3ZlVG9hc3Q6IHJlbW92ZVRvYXN0LFxuICAgICAgICAgICAgICAgIHRvYXN0czogdG9hc3RzLmZpbHRlcigodCk9PnQucG9zaXRpb24gPT0gdG9hc3QucG9zaXRpb24pLFxuICAgICAgICAgICAgICAgIGhlaWdodHM6IGhlaWdodHMuZmlsdGVyKChoKT0+aC5wb3NpdGlvbiA9PSB0b2FzdC5wb3NpdGlvbiksXG4gICAgICAgICAgICAgICAgc2V0SGVpZ2h0czogc2V0SGVpZ2h0cyxcbiAgICAgICAgICAgICAgICBleHBhbmRCeURlZmF1bHQ6IGV4cGFuZCxcbiAgICAgICAgICAgICAgICBnYXA6IGdhcCxcbiAgICAgICAgICAgICAgICBleHBhbmRlZDogZXhwYW5kZWQsXG4gICAgICAgICAgICAgICAgc3dpcGVEaXJlY3Rpb25zOiBwcm9wcy5zd2lwZURpcmVjdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgfSkpKTtcbn0pO1xuXG5leHBvcnQgeyBUb2FzdGVyLCB0b2FzdCwgdXNlU29ubmVyIH07XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFVQTtBQUNBO0FBWEE7QUFDQSxTQUFTLFlBQVksSUFBSTtJQUN2QixJQUFJLENBQUMsUUFBUSxPQUFPLFlBQVksYUFBYTtJQUM3QyxJQUFJLE9BQU8sU0FBUyxJQUFJLElBQUksU0FBUyxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsRUFBRTtJQUNwRSxJQUFJLFFBQVEsU0FBUyxhQUFhLENBQUM7SUFDbkMsTUFBTSxJQUFJLEdBQUc7SUFDYixLQUFLLFdBQVcsQ0FBQztJQUNoQixNQUFNLFVBQVUsR0FBSSxNQUFNLFVBQVUsQ0FBQyxPQUFPLEdBQUcsT0FBUSxNQUFNLFdBQVcsQ0FBQyxTQUFTLGNBQWMsQ0FBQztBQUNwRzs7O0FBS0EsTUFBTSxXQUFXLENBQUM7SUFDZCxPQUFPO1FBQ0gsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWDtZQUNJLE9BQU87SUFDZjtBQUNKO0FBQ0EsTUFBTSxPQUFPLE1BQU0sSUFBSSxJQUFJLENBQUM7QUFDNUIsTUFBTSxTQUFTO1FBQUMsRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFO0lBQ2xDLE9BQU8sV0FBVyxHQUFHLDZKQUFBLENBQUEsVUFBSyxDQUFDLGFBQWEsQ0FBQyxPQUFPO1FBQzVDLFdBQVc7WUFDUDtZQUNBO1NBQ0gsQ0FBQyxNQUFNLENBQUMsU0FBUyxJQUFJLENBQUM7UUFDdkIsZ0JBQWdCO0lBQ3BCLEdBQUcsV0FBVyxHQUFHLDZKQUFBLENBQUEsVUFBSyxDQUFDLGFBQWEsQ0FBQyxPQUFPO1FBQ3hDLFdBQVc7SUFDZixHQUFHLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLFdBQVcsR0FBRyw2SkFBQSxDQUFBLFVBQUssQ0FBQyxhQUFhLENBQUMs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LGFBQWEsVUFBVTtnQkFDbkUsbUJBQW1CLGdCQUFnQixPQUFPLEtBQUssSUFBSSxhQUFhLGlCQUFpQjtnQkFDakYsbUJBQW1CLGdCQUFnQixPQUFPLEtBQUssSUFBSSxhQUFhLGlCQUFpQjtnQkFDakYsc0JBQXNCLGdCQUFnQixPQUFPLEtBQUssSUFBSSxhQUFhLG9CQUFvQjtnQkFDdkYsYUFBYTtnQkFDYixRQUFRLE9BQU8sTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLFFBQVEsSUFBSSxNQUFNLFFBQVE7Z0JBQ3ZELFNBQVMsUUFBUSxNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsUUFBUSxJQUFJLE1BQU0sUUFBUTtnQkFDekQsWUFBWTtnQkFDWixpQkFBaUI7Z0JBQ2pCLEtBQUs7Z0JBQ0wsVUFBVTtnQkFDVixpQkFBaUIsTUFBTSxlQUFlO1lBQzFDO1FBQ0o7SUFDSjtBQUNKIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDY4NzYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfQUNUSVZJVFlfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJBY3Rpdml0eVwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY29uc29sZTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5lcnJvcjtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgICBcIk9iamVjdFwiO1xuICAgICAgICBKU0NvbXBpbGVyX3RlbXBfY29uc3QuY2FsbChcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQsXG4gICAgICAgICAgXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGFza05hbWUodHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHJldHVybiBcIjw+XCI7XG4gICAgICBpZiAoXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFXG4gICAgICApXG4gICAgICAgIHJldHVybiBcIjwuLi4+XCI7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIG5hbWUgPyBcIjxcIiArIG5hbWUgKyBcIj5cIiA6IFwiPC4uLj5cIjtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVua25vd25Pd25lcigpIHtcbiAgICAgIHJldHVybiBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29uZmlnLmtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gICAgICBmdW5jdGlvbiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkoKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIHx8XG4gICAgICAgICAgKChzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3BlY2lhbC1wcm9wcylcIixcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSAhMDtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgXCJrZXlcIiwge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nKCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodGhpcy50eXBlKTtcbiAgICAgIGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgKChkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQWNjZXNzaW5nIGVsZW1lbnQucmVmIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiByZWYgaXMgbm93IGEgcmVndWxhciBwcm9wLiBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgSlNYIEVsZW1lbnQgdHlwZSBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiXG4gICAgICAgICkpO1xuICAgICAgY29tcG9uZW50TmFtZSA9IHRoaXMucHJvcHMucmVmO1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29tcG9uZW50TmFtZSA/IGNvbXBvbmVudE5hbWUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFjdEVsZW1lbnQoXG4gICAgICB0eXBlLFxuICAgICAga2V5LFxuICAgICAgc2VsZixcbiAgICAgIHNvdXJjZSxcbiAgICAgIG93bmVyLFxuICAgICAgcHJvcHMsXG4gICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICBzZWxmID0gcHJvcHMucmVmO1xuICAgICAgdHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgX293bmVyOiBvd25lclxuICAgICAgfTtcbiAgICAgIG51bGwgIT09ICh2b2lkIDAgIT09IHNlbGYgPyBzZWxmIDogbnVsbClcbiAgICAgICAgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQ6IGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6IG51bGwgfSk7XG4gICAgICB0eXBlLl9zdG9yZSA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdTdGFja1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1N0YWNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1Rhc2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdUYXNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZixcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuKVxuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID0gMDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbisrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dKTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbik7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5XCIgIT09IGs7XG4gICAgICAgIH0pO1xuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID1cbiAgICAgICAgICAwIDwga2V5cy5sZW5ndGhcbiAgICAgICAgICAgID8gXCJ7a2V5OiBzb21lS2V5LCBcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiXG4gICAgICAgICAgICA6IFwie2tleTogc29tZUtleX1cIjtcbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gfHxcbiAgICAgICAgICAoKGtleXMgPVxuICAgICAgICAgICAgMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIHsuLi5wcm9wc30gLz5cXG5SZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsXG4gICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2b2lkIDAgIT09IG1heWJlS2V5ICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIG1heWJlS2V5KSk7XG4gICAgICBoYXNWYWxpZEtleShjb25maWcpICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgY29uZmlnLmtleSkpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJlxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgICBtYXliZUtleSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICAgICAgICA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICA6IHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBzZWxmLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGdldE93bmVyKCksXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgICBkZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUpIHtcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgIG51bGwgIT09IG5vZGUgJiZcbiAgICAgICAgbm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFICYmXG4gICAgICAgIG5vZGUuX3N0b3JlICYmXG4gICAgICAgIChub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSAxKTtcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgICAgIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfQUNUSVZJVFlfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5hY3Rpdml0eVwiKSxcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgY3JlYXRlVGFzayA9IGNvbnNvbGUuY3JlYXRlVGFza1xuICAgICAgICA/IGNvbnNvbGUuY3JlYXRlVGFza1xuICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH07XG4gICAgUmVhY3QgPSB7XG4gICAgICByZWFjdF9zdGFja19ib3R0b21fZnJhbWU6IGZ1bmN0aW9uIChjYWxsU3RhY2tGb3JFcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbFN0YWNrRm9yRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1N0YWNrID0gUmVhY3QucmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lLmJpbmQoXG4gICAgICBSZWFjdCxcbiAgICAgIFVua25vd25Pd25lclxuICAgICkoKTtcbiAgICB2YXIgdW5rbm93bk93bmVyRGVidWdUYXNrID0gY3JlYXRlVGFzayhnZXRUYXNrTmFtZShVbmtub3duT3duZXIpKTtcbiAgICB2YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge307XG4gICAgZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG4gICAgZXhwb3J0cy5qc3hERVYgPSBmdW5jdGlvbiAoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgdmFyIHRyYWNrQWN0dWFsT3duZXIgPVxuICAgICAgICAxZTQgPiBSZWFjdFNoYXJlZEludGVybmFscy5yZWNlbnRseUNyZWF0ZWRPd25lclN0YWNrcysrO1xuICAgICAgcmV0dXJuIGpzeERFVkltcGwoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgc2VsZixcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lclxuICAgICAgICAgID8gRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIilcbiAgICAgICAgICA6IHVua25vd25Pd25lckRlYnVnU3RhY2ssXG4gICAgICAgIHRyYWNrQWN0dWFsT3duZXIgPyBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKHR5cGUpKSA6IHVua25vd25Pd25lckRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9O1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBR2dCO0FBRGpCO0FBQ0Esb0VBQ0UsQUFBQztJQUNDLFNBQVMseUJBQXlCLElBQUk7UUFDcEMsSUFBSSxRQUFRLE1BQU0sT0FBTztRQUN6QixJQUFJLGVBQWUsT0FBTyxNQUN4QixPQUFPLEtBQUssUUFBUSxLQUFLLHlCQUNyQixPQUNBLEtBQUssV0FBVyxJQUFJLEtBQUssSUFBSSxJQUFJO1FBQ3ZDLElBQUksYUFBYSxPQUFPLE1BQU0sT0FBTztRQUNyQyxPQUFRO1lBQ04sS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1FBQ1g7UUFDQSxJQUFJLGFBQWEsT0FBTyxNQUN0QixPQUNHLGFBQWEsT0FBTyxLQUFLLEdBQUcsSUFDM0IsUUFBUSxLQUFLLENBQ1gsc0hBRUosS0FBSyxRQUFRO1lBRWIsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPLEtBQUssV0FBVyxJQUFJO1lBQzdCLEtB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d0JBQXdCLENBQUMsSUFBSSxDQUM5RCxPQUNBO0lBRUYsSUFBSSx3QkFBd0IsV0FBVyxZQUFZO0lBQ25ELElBQUksd0JBQXdCLENBQUM7SUFDN0IsUUFBUSxRQUFRLEdBQUc7SUFDbkIsUUFBUSxNQUFNLEdBQUcsU0FDZixJQUFJLEVBQ0osTUFBTSxFQUNOLFFBQVEsRUFDUixnQkFBZ0IsRUFDaEIsTUFBTSxFQUNOLElBQUk7UUFFSixJQUFJLG1CQUNGLE1BQU0scUJBQXFCLDBCQUEwQjtRQUN2RCxPQUFPLFdBQ0wsTUFDQSxRQUNBLFVBQ0Esa0JBQ0EsUUFDQSxNQUNBLG1CQUNJLE1BQU0sMkJBQ04sd0JBQ0osbUJBQW1CLFdBQVcsWUFBWSxTQUFTO0lBRXZEO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzA4MywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFSTtBQUZKO0FBRUE7O0tBRU87SUFDTCxPQUFPLE9BQU87QUFDaEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzA5NiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS13aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAgIHJldHVybiAoeCA9PT0geSAmJiAoMCAhPT0geCB8fCAxIC8geCA9PT0gMSAvIHkpKSB8fCAoeCAhPT0geCAmJiB5ICE9PSB5KTtcbiAgICB9XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChFcnJvcigpKTtcbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIiksXG4gICAgICBvYmplY3RJcyA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IGlzLFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSxcbiAgICAgIHVzZVJlZiA9IFJlYWN0LnVzZVJlZixcbiAgICAgIHVzZUVmZmVjdCA9IFJlYWN0LnVzZUVmZmVjdCxcbiAgICAgIHVzZU1lbW8gPSBSZWFjdC51c2VNZW1vLFxuICAgICAgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWU7XG4gICAgZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciA9IGZ1bmN0aW9uIChcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIGdldFNuYXBzaG90LFxuICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICBzZWxlY3RvcixcbiAgICAgIGlzRXF1YWxcbiAgICApIHtcbiAgICAgIHZhciBpbnN0UmVmID0gdXNlUmVmKG51bGwpO1xuICAgICAgaWYgKG51bGwgPT09IGluc3RSZWYuY3VycmVudCkge1xuICAgICAgICB2YXIgaW5zdCA9IHsgaGFzVmFsdWU6ICExLCB2YWx1ZTogbnVsbCB9O1xuICAgICAgICBpbnN0UmVmLmN1cnJlbnQgPSBpbnN0O1xuICAgICAgfSBlbHNlIGluc3QgPSBpbnN0UmVmLmN1cnJlbnQ7XG4gICAgICBpbnN0UmVmID0gdXNlTWVtbyhcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIG1lbW9pemVkU2VsZWN0b3IobmV4dFNuYXBzaG90KSB7XG4gICAgICAgICAgICBpZiAoIWhhc01lbW8pIHtcbiAgICAgICAgICAgICAgaGFzTWVtbyA9ICEwO1xuICAgICAgICAgICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuICAgICAgICAgICAgICBuZXh0U25hcHNob3QgPSBzZWxlY3RvcihuZXh0U25hcHNob3QpO1xuICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBpc0VxdWFsICYmIGluc3QuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGluc3QudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXF1YWwoY3VycmVudFNlbGVjdGlvbiwgbmV4dFNuYXBzaG90KSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiAobWVtb2l6ZWRTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gKG1lbW9pemVkU2VsZWN0aW9uID0gbmV4dFNuYXBzaG90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24gPSBtZW1vaXplZFNlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmIChvYmplY3RJcyhtZW1vaXplZFNuYXBzaG90LCBuZXh0U25hcHNob3QpKVxuICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgIHZhciBuZXh0U2VsZWN0aW9uID0gc2VsZWN0b3IobmV4dFNuYXBzaG90KTtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGlzRXF1YWwgJiYgaXNFcXVhbChjdXJyZW50U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgcmV0dXJuIChtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90KSwgY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgIG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3Q7XG4gICAgICAgICAgICByZXR1cm4gKG1lbW9pemVkU2VsZWN0aW9uID0gbmV4dFNlbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBoYXNNZW1vID0gITEsXG4gICAgICAgICAgICBtZW1vaXplZFNuYXBzaG90LFxuICAgICAgICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24sXG4gICAgICAgICAgICBtYXliZUdldFNlcnZlclNuYXBzaG90ID1cbiAgICAgICAgICAgICAgdm9pZCAwID09PSBnZXRTZXJ2ZXJTbmFwc2hvdCA/IG51bGwgOiBnZXRTZXJ2ZXJTbmFwc2hvdDtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihnZXRTbmFwc2hvdCgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudWxsID09PSBtYXliZUdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IobWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgXTtcbiAgICAgICAgfSxcbiAgICAgICAgW2dldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWxdXG4gICAgICApO1xuICAgICAgdmFyIHZhbHVlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBpbnN0UmVmWzBdLCBpbnN0UmVmWzFdKTtcbiAgICAgIHVzZUVmZmVjdChcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGluc3QuaGFzVmFsdWUgPSAhMDtcbiAgICAgICAgICBpbnN0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIFt2YWx1ZV1cbiAgICAgICk7XG4gICAgICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKEVycm9yKCkpO1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBR2dCO0FBRGpCO0FBQ0Esb0VBQ0UsQUFBQztJQUNDLFNBQVMsR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUNkLE9BQU8sQUFBQyxNQUFNLEtBQUssQ0FBQyxNQUFNLEtBQUssSUFBSSxNQUFNLElBQUksQ0FBQyxLQUFPLE1BQU0sS0FBSyxNQUFNO0lBQ3hFO0lBQ0EsZ0JBQWdCLE9BQU8sa0NBQ3JCLGVBQ0UsT0FBTywrQkFBK0IsMkJBQTJCLElBQ25FLCtCQUErQiwyQkFBMkIsQ0FBQztJQUM3RCxJQUFJLHVIQUNGLFdBQVcsZUFBZSxPQUFPLE9BQU8sRUFBRSxHQUFHLE9BQU8sRUFBRSxHQUFHLElBQ3pELHVCQUF1QixNQUFNLG9CQUFvQixFQUNqRCxTQUFTLE1BQU0sTUFBTSxFQUNyQixZQUFZLE1BQU0sU0FBUyxFQUMzQixVQUFVLE1BQU0sT0FBTyxFQUN2QixnQkFBZ0IsTUFBTSxhQUFhO0lBQ3JDLFFBQVEsZ0NBQWdDLEdBQUcsU0FDekMsU0FBUyxFQUNULFdBQVcsRUFDWCxpQkFBaUIsRUFDakIsUUFBUSxFQUNSLE9BQU87UUFFUCxJQUFJLFVBQVUsT0FBTztRQUNyQixJQUFJLFNBQVMsUUFBUSxPQUFPLEVBQUU7WUFDNUIsSUFBSSxPQUFPO2dCQUFFLFVBQVUsQ0FBQztnQkFBRyxPQUFPO1lBQUs7WUFDdkMsUUFBUSxPQUFPLEdBQUc7UUFDcEIsT0FBTyxPQUFPLFFBQVEsT0FBTztRQUM3QixVQUFVLFFBQ1I7WUFDRSxTQUFTLGlCQUFpQixZQUFZO2dCQUNwQyxJQUFJLENBQUMsU0FBUztvQkFDWixVQUFVLENBQUM7b0JBQ1gsbUJBQW1CO29CQUNuQixlQUFlLFNBQVM7b0JBQ3hCLElBQUksS0FBSyxNQUFNLFdBQVcsS0FBSyxRQUFRLEVBQUU7d0JBQ3ZDLElBQUksbUJBQW1CLEtBQUssS0FBSzt3QkFDakMsSUFBSSxRQUFRLGtCQUFrQixlQUM1QixPQUFRLG9CQUFvQjtvQkFDaEM7b0JBQ0EsT0FBUSxvQkFBb0I7Z0JBQzlCO2dCQUNBLG1CQUFtQjtnQkFDbkIsSUFBSSxTQUFTLGtCQUFrQixlQUM3QixPQUFPO2dCQUNULElBQUksZ0JBQWdCLFNBQVM7Z0JBQzdCLElBQUksS0FBSyxNQUFNLFdBQVcsUUFBUSxrQkFBa0IsZ0JBQ2xELE9BQU8sQUFBQyxtQkFBbUIsY0FBZTtnQkFDNUMsbUJBQW1CO2dCQUNuQixPQUFRLG9CQUFvQjtZQUM5QjtZQUNBLElBQUksVUFBVSxDQUFDLEdBQ2Isa0JBQ0EsbUJBQ0EseUJBQ0UsS0FBSyxNQUFNLG9CQUFvQixPQUFPO1lBQzFDLE9BQU87Z0JBQ0w7b0JBQ0UsT0FBTyxpQkFBaUI7Z0JBQzFCO2dCQUNBLFNBQVMseUJBQ0wsS0FBSyxJQUNMO29CQUNFLE9BQU8saUJBQWlCO2dCQUMxQjthQUNMO1FBQ0gsR0FDQTtZQUFDO1lBQWE7WUFBbUI7WUFBVTtTQUFRO1FBRXJELElBQUksUUFBUSxxQkFBcUIsV0FBVyxPQUFPLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxFQUFFO1FBQ2xFLFVBQ0U7WUFDRSxLQUFLLFFBQVEsR0FBRyxDQUFDO1lBQ2pCLEtBQUssS0FBSyxHQUFHO1FBQ2YsR0FDQTtZQUFDO1NBQU07UUFFVCxjQUFjO1FBQ2QsT0FBTztJQUNUO0lBQ0EsZ0JBQWdCLE9BQU8sa0NBQ3JCLGVBQ0UsT0FBTywrQkFBK0IsMEJBQTBCLElBQ2xFLCtCQUErQiwwQkFBMEIsQ0FBQztBQUM5RCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA3MTczLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3dpdGgtc2VsZWN0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXdpdGgtc2VsZWN0b3IucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS13aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUk7QUFGSjtBQUVBOztLQUVPO0lBQ0wsT0FBTyxPQUFPO0FBQ2hCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDcxODQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvc3JjL3V0aWxzL3JlYWN0LnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy91dGlscy9yZWFjdC1pcy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvdXRpbHMvd2FybmluZy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvY29ubmVjdC92ZXJpZnlTdWJzZWxlY3RvcnMudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvc3JjL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5LnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy91dGlscy9iaW5kQWN0aW9uQ3JlYXRvcnMudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvc3JjL3V0aWxzL2lzUGxhaW5PYmplY3QudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvc3JjL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0LnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy9jb25uZWN0L3dyYXBNYXBUb1Byb3BzLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy9jb25uZWN0L2ludmFsaWRBcmdGYWN0b3J5LnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy9jb25uZWN0L21hcERpc3BhdGNoVG9Qcm9wcy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvY29ubmVjdC9tYXBTdGF0ZVRvUHJvcHMudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvc3JjL2Nvbm5lY3QvbWVyZ2VQcm9wcy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvdXRpbHMvYmF0Y2gudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvc3JjL3V0aWxzL1N1YnNjcmlwdGlvbi50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvdXRpbHMvdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdC50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvdXRpbHMvc2hhbGxvd0VxdWFsLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy91dGlscy9ob2lzdFN0YXRpY3MudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvc3JjL2NvbXBvbmVudHMvQ29udGV4dC50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvY29tcG9uZW50cy9jb25uZWN0LnRzeCIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvY29tcG9uZW50cy9Qcm92aWRlci50c3giLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvc3JjL2hvb2tzL3VzZVJlZHV4Q29udGV4dC50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvaG9va3MvdXNlU3RvcmUudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvc3JjL2hvb2tzL3VzZURpc3BhdGNoLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L3NyYy9ob29rcy91c2VTZWxlY3Rvci50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9zcmMvZXhwb3J0cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IHsgUmVhY3QgfVxuIiwiaW1wb3J0IHR5cGUgeyBFbGVtZW50VHlwZSwgTWVtb0V4b3RpY0NvbXBvbmVudCwgUmVhY3RFbGVtZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBSZWFjdCB9IGZyb20gJy4vcmVhY3QnXG5cbi8vIERpcmVjdGx5IHBvcnRlZCBmcm9tOlxuLy8gaHR0cHM6Ly91bnBrZy5jb20vYnJvd3NlL3JlYWN0LWlzQDE5LjAuMC9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5qc1xuLy8gSXQncyB2ZXJ5IHBvc3NpYmxlIHRoaXMgY291bGQgY2hhbmdlIGluIHRoZSBmdXR1cmUsIGJ1dCBnaXZlbiB0aGF0XG4vLyB3ZSBvbmx5IHVzZSB0aGVzZSBpbiBgY29ubmVjdGAsIHRoaXMgaXMgYSBsb3cgcHJpb3JpdHkuXG5cbmV4cG9ydCBjb25zdCBJU19SRUFDVF8xOSA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC52ZXJzaW9uLnN0YXJ0c1dpdGgoJzE5JylcblxuY29uc3QgUkVBQ1RfRUxFTUVOVF9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXG4gIElTX1JFQUNUXzE5ID8gJ3JlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50JyA6ICdyZWFjdC5lbGVtZW50JyxcbilcbmNvbnN0IFJFQUNUX1BPUlRBTF9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpXG5jb25zdCBSRUFDVF9GUkFHTUVOVF9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JylcbmNvbnN0IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKVxuY29uc3QgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpXG5jb25zdCBSRUFDVF9DT05TVU1FUl9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnN1bWVyJylcbmNvbnN0IFJFQUNUX0NPTlRFWFRfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JylcbmNvbnN0IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKVxuY29uc3QgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpXG5jb25zdCBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcbiAgJ3JlYWN0LnN1c3BlbnNlX2xpc3QnLFxuKVxuY29uc3QgUkVBQ1RfTUVNT19UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKVxuY29uc3QgUkVBQ1RfTEFaWV9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKVxuY29uc3QgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJylcbmNvbnN0IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcbiAgJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnLFxuKVxuXG5leHBvcnQgY29uc3QgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEVcbmV4cG9ydCBjb25zdCBNZW1vID0gUkVBQ1RfTUVNT19UWVBFXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZTogYW55KTogdHlwZSBpcyBFbGVtZW50VHlwZSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHxcbiAgICB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8XG4gICAgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fFxuICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHxcbiAgICB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHxcbiAgICB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fFxuICAgICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGUgIT09IG51bGwgJiZcbiAgICAgICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHxcbiAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8XG4gICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fFxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFIHx8XG4gICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHxcbiAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSB8fFxuICAgICAgICB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpKVxuICAgID8gITBcbiAgICA6ICExXG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3Q6IGFueSk6IHN5bWJvbCB8IHVuZGVmaW5lZCB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICBjb25zdCB7ICQkdHlwZW9mIH0gPSBvYmplY3RcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBzd2l0Y2ggKCgob2JqZWN0ID0gb2JqZWN0LnR5cGUpLCBvYmplY3QpKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzd2l0Y2ggKCgob2JqZWN0ID0gb2JqZWN0ICYmIG9iamVjdC4kJHR5cGVvZiksIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3RcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3RcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3Q6IGFueSk6IG9iamVjdCBpcyBSZWFjdEVsZW1lbnQge1xuICByZXR1cm4gSVNfUkVBQ1RfMTlcbiAgICA/IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05TVU1FUl9UWVBFXG4gICAgOiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc01lbW8ob2JqZWN0OiBhbnkpOiBvYmplY3QgaXMgTWVtb0V4b3RpY0NvbXBvbmVudDxhbnk+IHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEVcbn1cbiIsIi8qKlxyXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cclxuICogQHJldHVybnMge3ZvaWR9XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2U6IHN0cmluZykge1xyXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cclxuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpXHJcbiAgfVxyXG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xyXG4gIHRyeSB7XHJcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGlmIHlvdSBlbmFibGVcclxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXHJcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cclxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cclxuICB9IGNhdGNoIChlKSB7fVxyXG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cclxufVxyXG4iLCJpbXBvcnQgd2FybmluZyBmcm9tICcuLi91dGlscy93YXJuaW5nJ1xuXG5mdW5jdGlvbiB2ZXJpZnkoc2VsZWN0b3I6IHVua25vd24sIG1ldGhvZE5hbWU6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHZhbHVlIGZvciAke21ldGhvZE5hbWV9IGluIGNvbm5lY3QuYClcbiAgfSBlbHNlIGlmIChcbiAgICBtZXRob2ROYW1lID09PSAnbWFwU3RhdGVUb1Byb3BzJyB8fFxuICAgIG1ldGhvZE5hbWUgPT09ICdtYXBEaXNwYXRjaFRvUHJvcHMnXG4gICkge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGVjdG9yLCAnZGVwZW5kc09uT3duUHJvcHMnKSkge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgYFRoZSBzZWxlY3RvciBmb3IgJHttZXRob2ROYW1lfSBvZiBjb25uZWN0IGRpZCBub3Qgc3BlY2lmeSBhIHZhbHVlIGZvciBkZXBlbmRzT25Pd25Qcm9wcy5gLFxuICAgICAgKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2ZXJpZnlTdWJzZWxlY3RvcnMoXG4gIG1hcFN0YXRlVG9Qcm9wczogdW5rbm93bixcbiAgbWFwRGlzcGF0Y2hUb1Byb3BzOiB1bmtub3duLFxuICBtZXJnZVByb3BzOiB1bmtub3duLFxuKTogdm9pZCB7XG4gIHZlcmlmeShtYXBTdGF0ZVRvUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnKVxuICB2ZXJpZnkobWFwRGlzcGF0Y2hUb1Byb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJylcbiAgdmVyaWZ5KG1lcmdlUHJvcHMsICdtZXJnZVByb3BzJylcbn1cbiIsImltcG9ydCB0eXBlIHsgRGlzcGF0Y2gsIEFjdGlvbiB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgdmVyaWZ5U3Vic2VsZWN0b3JzIGZyb20gJy4vdmVyaWZ5U3Vic2VsZWN0b3JzJ1xuaW1wb3J0IHR5cGUgeyBFcXVhbGl0eUZuLCBFeHRlbmRlZEVxdWFsaXR5Rm4gfSBmcm9tICcuLi90eXBlcydcblxuZXhwb3J0IHR5cGUgU2VsZWN0b3JGYWN0b3J5PFMsIFRQcm9wcywgVE93blByb3BzLCBURmFjdG9yeU9wdGlvbnM+ID0gKFxuICBkaXNwYXRjaDogRGlzcGF0Y2g8QWN0aW9uPHN0cmluZz4+LFxuICBmYWN0b3J5T3B0aW9uczogVEZhY3RvcnlPcHRpb25zLFxuKSA9PiBTZWxlY3RvcjxTLCBUUHJvcHMsIFRPd25Qcm9wcz5cblxuZXhwb3J0IHR5cGUgU2VsZWN0b3I8UywgVFByb3BzLCBUT3duUHJvcHMgPSBudWxsPiA9IFRPd25Qcm9wcyBleHRlbmRzXG4gIHwgbnVsbFxuICB8IHVuZGVmaW5lZFxuICA/IChzdGF0ZTogUykgPT4gVFByb3BzXG4gIDogKHN0YXRlOiBTLCBvd25Qcm9wczogVE93blByb3BzKSA9PiBUUHJvcHNcblxuZXhwb3J0IHR5cGUgTWFwU3RhdGVUb1Byb3BzPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPiA9IChcbiAgc3RhdGU6IFN0YXRlLFxuICBvd25Qcm9wczogVE93blByb3BzLFxuKSA9PiBUU3RhdGVQcm9wc1xuXG5leHBvcnQgdHlwZSBNYXBTdGF0ZVRvUHJvcHNGYWN0b3J5PFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPiA9IChcbiAgaW5pdGlhbFN0YXRlOiBTdGF0ZSxcbiAgb3duUHJvcHM6IFRPd25Qcm9wcyxcbikgPT4gTWFwU3RhdGVUb1Byb3BzPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPlxuXG5leHBvcnQgdHlwZSBNYXBTdGF0ZVRvUHJvcHNQYXJhbTxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4gPVxuICB8IE1hcFN0YXRlVG9Qcm9wc0ZhY3Rvcnk8VFN0YXRlUHJvcHMsIFRPd25Qcm9wcywgU3RhdGU+XG4gIHwgTWFwU3RhdGVUb1Byb3BzPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPlxuICB8IG51bGxcbiAgfCB1bmRlZmluZWRcblxuZXhwb3J0IHR5cGUgTWFwRGlzcGF0Y2hUb1Byb3BzRnVuY3Rpb248VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz4gPSAoXG4gIGRpc3BhdGNoOiBEaXNwYXRjaDxBY3Rpb248c3RyaW5nPj4sXG4gIG93blByb3BzOiBUT3duUHJvcHMsXG4pID0+IFREaXNwYXRjaFByb3BzXG5cbmV4cG9ydCB0eXBlIE1hcERpc3BhdGNoVG9Qcm9wczxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPiA9XG4gIHwgTWFwRGlzcGF0Y2hUb1Byb3BzRnVuY3Rpb248VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz5cbiAgfCBURGlzcGF0Y2hQcm9wc1xuXG5leHBvcnQgdHlwZSBNYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5PFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+ID0gKFxuICBkaXNwYXRjaDogRGlzcGF0Y2g8QWN0aW9uPHN0cmluZz4+LFxuICBvd25Qcm9wczogVE93blByb3BzLFxuKSA9PiBNYXBEaXNwYXRjaFRvUHJvcHNGdW5jdGlvbjxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPlxuXG5leHBvcnQgdHlwZSBNYXBEaXNwYXRjaFRvUHJvcHNQYXJhbTxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPiA9XG4gIHwgTWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeTxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPlxuICB8IE1hcERpc3BhdGNoVG9Qcm9wczxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPlxuXG5leHBvcnQgdHlwZSBNYXBEaXNwYXRjaFRvUHJvcHNOb25PYmplY3Q8VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz4gPVxuICB8IE1hcERpc3BhdGNoVG9Qcm9wc0ZhY3Rvcnk8VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz5cbiAgfCBNYXBEaXNwYXRjaFRvUHJvcHNGdW5jdGlvbjxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPlxuXG5leHBvcnQgdHlwZSBNZXJnZVByb3BzPFRTdGF0ZVByb3BzLCBURGlzcGF0Y2hQcm9wcywgVE93blByb3BzLCBUTWVyZ2VkUHJvcHM+ID0gKFxuICBzdGF0ZVByb3BzOiBUU3RhdGVQcm9wcyxcbiAgZGlzcGF0Y2hQcm9wczogVERpc3BhdGNoUHJvcHMsXG4gIG93blByb3BzOiBUT3duUHJvcHMsXG4pID0+IFRNZXJnZWRQcm9wc1xuXG5pbnRlcmZhY2UgUHVyZVNlbGVjdG9yRmFjdG9yeUNvbXBhcmlzb25PcHRpb25zPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPiB7XG4gIHJlYWRvbmx5IGFyZVN0YXRlc0VxdWFsOiBFeHRlbmRlZEVxdWFsaXR5Rm48U3RhdGUsIFRPd25Qcm9wcz5cbiAgcmVhZG9ubHkgYXJlU3RhdGVQcm9wc0VxdWFsOiBFcXVhbGl0eUZuPFRTdGF0ZVByb3BzPlxuICByZWFkb25seSBhcmVPd25Qcm9wc0VxdWFsOiBFcXVhbGl0eUZuPFRPd25Qcm9wcz5cbn1cblxuZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnk8XG4gIFRTdGF0ZVByb3BzLFxuICBUT3duUHJvcHMsXG4gIFREaXNwYXRjaFByb3BzLFxuICBUTWVyZ2VkUHJvcHMsXG4gIFN0YXRlLFxuPihcbiAgbWFwU3RhdGVUb1Byb3BzOiBXcmFwcGVkTWFwU3RhdGVUb1Byb3BzPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPixcbiAgbWFwRGlzcGF0Y2hUb1Byb3BzOiBXcmFwcGVkTWFwRGlzcGF0Y2hUb1Byb3BzPFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+LFxuICBtZXJnZVByb3BzOiBNZXJnZVByb3BzPFRTdGF0ZVByb3BzLCBURGlzcGF0Y2hQcm9wcywgVE93blByb3BzLCBUTWVyZ2VkUHJvcHM+LFxuICBkaXNwYXRjaDogRGlzcGF0Y2g8QWN0aW9uPHN0cmluZz4+LFxuICB7XG4gICAgYXJlU3RhdGVzRXF1YWwsXG4gICAgYXJlT3duUHJvcHNFcXVhbCxcbiAgICBhcmVTdGF0ZVByb3BzRXF1YWwsXG4gIH06IFB1cmVTZWxlY3RvckZhY3RvcnlDb21wYXJpc29uT3B0aW9uczxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4sXG4pIHtcbiAgbGV0IGhhc1J1bkF0TGVhc3RPbmNlID0gZmFsc2VcbiAgbGV0IHN0YXRlOiBTdGF0ZVxuICBsZXQgb3duUHJvcHM6IFRPd25Qcm9wc1xuICBsZXQgc3RhdGVQcm9wczogVFN0YXRlUHJvcHNcbiAgbGV0IGRpc3BhdGNoUHJvcHM6IFREaXNwYXRjaFByb3BzXG4gIGxldCBtZXJnZWRQcm9wczogVE1lcmdlZFByb3BzXG5cbiAgZnVuY3Rpb24gaGFuZGxlRmlyc3RDYWxsKGZpcnN0U3RhdGU6IFN0YXRlLCBmaXJzdE93blByb3BzOiBUT3duUHJvcHMpIHtcbiAgICBzdGF0ZSA9IGZpcnN0U3RhdGVcbiAgICBvd25Qcm9wcyA9IGZpcnN0T3duUHJvcHNcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcylcbiAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcylcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpXG4gICAgaGFzUnVuQXRMZWFzdE9uY2UgPSB0cnVlXG4gICAgcmV0dXJuIG1lcmdlZFByb3BzXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCkge1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKVxuXG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKVxuXG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKVxuICAgIHJldHVybiBtZXJnZWRQcm9wc1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHMoKSB7XG4gICAgaWYgKG1hcFN0YXRlVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKVxuXG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKVxuXG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKVxuICAgIHJldHVybiBtZXJnZWRQcm9wc1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3U3RhdGUoKSB7XG4gICAgY29uc3QgbmV4dFN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKVxuICAgIGNvbnN0IHN0YXRlUHJvcHNDaGFuZ2VkID0gIWFyZVN0YXRlUHJvcHNFcXVhbChuZXh0U3RhdGVQcm9wcywgc3RhdGVQcm9wcylcbiAgICBzdGF0ZVByb3BzID0gbmV4dFN0YXRlUHJvcHNcblxuICAgIGlmIChzdGF0ZVByb3BzQ2hhbmdlZClcbiAgICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcylcblxuICAgIHJldHVybiBtZXJnZWRQcm9wc1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZTogU3RhdGUsIG5leHRPd25Qcm9wczogVE93blByb3BzKSB7XG4gICAgY29uc3QgcHJvcHNDaGFuZ2VkID0gIWFyZU93blByb3BzRXF1YWwobmV4dE93blByb3BzLCBvd25Qcm9wcylcbiAgICBjb25zdCBzdGF0ZUNoYW5nZWQgPSAhYXJlU3RhdGVzRXF1YWwoXG4gICAgICBuZXh0U3RhdGUsXG4gICAgICBzdGF0ZSxcbiAgICAgIG5leHRPd25Qcm9wcyxcbiAgICAgIG93blByb3BzLFxuICAgIClcbiAgICBzdGF0ZSA9IG5leHRTdGF0ZVxuICAgIG93blByb3BzID0gbmV4dE93blByb3BzXG5cbiAgICBpZiAocHJvcHNDaGFuZ2VkICYmIHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKVxuICAgIGlmIChwcm9wc0NoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wcygpXG4gICAgaWYgKHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1N0YXRlKClcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHNcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yKFxuICAgIG5leHRTdGF0ZTogU3RhdGUsXG4gICAgbmV4dE93blByb3BzOiBUT3duUHJvcHMsXG4gICkge1xuICAgIHJldHVybiBoYXNSdW5BdExlYXN0T25jZVxuICAgICAgPyBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpXG4gICAgICA6IGhhbmRsZUZpcnN0Q2FsbChuZXh0U3RhdGUsIG5leHRPd25Qcm9wcylcbiAgfVxufVxuXG5pbnRlcmZhY2UgV3JhcHBlZE1hcFN0YXRlVG9Qcm9wczxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4ge1xuICAoc3RhdGU6IFN0YXRlLCBvd25Qcm9wczogVE93blByb3BzKTogVFN0YXRlUHJvcHNcbiAgcmVhZG9ubHkgZGVwZW5kc09uT3duUHJvcHM6IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIFdyYXBwZWRNYXBEaXNwYXRjaFRvUHJvcHM8VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz4ge1xuICAoZGlzcGF0Y2g6IERpc3BhdGNoPEFjdGlvbjxzdHJpbmc+Piwgb3duUHJvcHM6IFRPd25Qcm9wcyk6IFREaXNwYXRjaFByb3BzXG4gIHJlYWRvbmx5IGRlcGVuZHNPbk93blByb3BzOiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5pdE9wdGlvbnM8VFN0YXRlUHJvcHMsIFRPd25Qcm9wcywgVE1lcmdlZFByb3BzLCBTdGF0ZT5cbiAgZXh0ZW5kcyBQdXJlU2VsZWN0b3JGYWN0b3J5Q29tcGFyaXNvbk9wdGlvbnM8VFN0YXRlUHJvcHMsIFRPd25Qcm9wcywgU3RhdGU+IHtcbiAgcmVhZG9ubHkgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzOiBib29sZWFuXG4gIHJlYWRvbmx5IGRpc3BsYXlOYW1lOiBzdHJpbmdcbiAgcmVhZG9ubHkgd3JhcHBlZENvbXBvbmVudE5hbWU6IHN0cmluZ1xuICByZWFkb25seSBXcmFwcGVkQ29tcG9uZW50OiBDb21wb25lbnRUeXBlPFRPd25Qcm9wcz5cbiAgcmVhZG9ubHkgYXJlTWVyZ2VkUHJvcHNFcXVhbDogRXF1YWxpdHlGbjxUTWVyZ2VkUHJvcHM+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0b3JGYWN0b3J5T3B0aW9uczxcbiAgVFN0YXRlUHJvcHMsXG4gIFRPd25Qcm9wcyxcbiAgVERpc3BhdGNoUHJvcHMsXG4gIFRNZXJnZWRQcm9wcyxcbiAgU3RhdGUsXG4+IGV4dGVuZHMgSW5pdE9wdGlvbnM8VFN0YXRlUHJvcHMsIFRPd25Qcm9wcywgVE1lcmdlZFByb3BzLCBTdGF0ZT4ge1xuICByZWFkb25seSBpbml0TWFwU3RhdGVUb1Byb3BzOiAoXG4gICAgZGlzcGF0Y2g6IERpc3BhdGNoPEFjdGlvbjxzdHJpbmc+PixcbiAgICBvcHRpb25zOiBJbml0T3B0aW9uczxUU3RhdGVQcm9wcywgVE93blByb3BzLCBUTWVyZ2VkUHJvcHMsIFN0YXRlPixcbiAgKSA9PiBXcmFwcGVkTWFwU3RhdGVUb1Byb3BzPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPlxuICByZWFkb25seSBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzOiAoXG4gICAgZGlzcGF0Y2g6IERpc3BhdGNoPEFjdGlvbjxzdHJpbmc+PixcbiAgICBvcHRpb25zOiBJbml0T3B0aW9uczxUU3RhdGVQcm9wcywgVE93blByb3BzLCBUTWVyZ2VkUHJvcHMsIFN0YXRlPixcbiAgKSA9PiBXcmFwcGVkTWFwRGlzcGF0Y2hUb1Byb3BzPFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+XG4gIHJlYWRvbmx5IGluaXRNZXJnZVByb3BzOiAoXG4gICAgZGlzcGF0Y2g6IERpc3BhdGNoPEFjdGlvbjxzdHJpbmc+PixcbiAgICBvcHRpb25zOiBJbml0T3B0aW9uczxUU3RhdGVQcm9wcywgVE93blByb3BzLCBUTWVyZ2VkUHJvcHMsIFN0YXRlPixcbiAgKSA9PiBNZXJnZVByb3BzPFRTdGF0ZVByb3BzLCBURGlzcGF0Y2hQcm9wcywgVE93blByb3BzLCBUTWVyZ2VkUHJvcHM+XG59XG5cbi8vIFRPRE86IEFkZCBtb3JlIGNvbW1lbnRzXG5cbi8vIFRoZSBzZWxlY3RvciByZXR1cm5lZCBieSBzZWxlY3RvckZhY3Rvcnkgd2lsbCBtZW1vaXplIGl0cyByZXN1bHRzLFxuLy8gYWxsb3dpbmcgY29ubmVjdCdzIHNob3VsZENvbXBvbmVudFVwZGF0ZSB0byByZXR1cm4gZmFsc2UgaWYgZmluYWxcbi8vIHByb3BzIGhhdmUgbm90IGNoYW5nZWQuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnk8XG4gIFRTdGF0ZVByb3BzLFxuICBUT3duUHJvcHMsXG4gIFREaXNwYXRjaFByb3BzLFxuICBUTWVyZ2VkUHJvcHMsXG4gIFN0YXRlLFxuPihcbiAgZGlzcGF0Y2g6IERpc3BhdGNoPEFjdGlvbjxzdHJpbmc+PixcbiAge1xuICAgIGluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICBpbml0TWVyZ2VQcm9wcyxcbiAgICAuLi5vcHRpb25zXG4gIH06IFNlbGVjdG9yRmFjdG9yeU9wdGlvbnM8XG4gICAgVFN0YXRlUHJvcHMsXG4gICAgVE93blByb3BzLFxuICAgIFREaXNwYXRjaFByb3BzLFxuICAgIFRNZXJnZWRQcm9wcyxcbiAgICBTdGF0ZVxuICA+LFxuKSB7XG4gIGNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IGluaXRNYXBTdGF0ZVRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpXG4gIGNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpXG4gIGNvbnN0IG1lcmdlUHJvcHMgPSBpbml0TWVyZ2VQcm9wcyhkaXNwYXRjaCwgb3B0aW9ucylcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcylcbiAgfVxuXG4gIHJldHVybiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeTxcbiAgICBUU3RhdGVQcm9wcyxcbiAgICBUT3duUHJvcHMsXG4gICAgVERpc3BhdGNoUHJvcHMsXG4gICAgVE1lcmdlZFByb3BzLFxuICAgIFN0YXRlXG4gID4obWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKVxufVxuIiwiaW1wb3J0IHR5cGUgeyBBY3Rpb25DcmVhdG9yc01hcE9iamVjdCwgRGlzcGF0Y2ggfSBmcm9tICdyZWR1eCdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKFxuICBhY3Rpb25DcmVhdG9yczogQWN0aW9uQ3JlYXRvcnNNYXBPYmplY3QsXG4gIGRpc3BhdGNoOiBEaXNwYXRjaCxcbik6IEFjdGlvbkNyZWF0b3JzTWFwT2JqZWN0IHtcbiAgY29uc3QgYm91bmRBY3Rpb25DcmVhdG9yczogQWN0aW9uQ3JlYXRvcnNNYXBPYmplY3QgPSB7fVxuXG4gIGZvciAoY29uc3Qga2V5IGluIGFjdGlvbkNyZWF0b3JzKSB7XG4gICAgY29uc3QgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV1cbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9ICguLi5hcmdzKSA9PiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yKC4uLmFyZ3MpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9yc1xufVxuIiwiLyoqXG4gKiBAcGFyYW0ge2FueX0gb2JqIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBhcmd1bWVudCBhcHBlYXJzIHRvIGJlIGEgcGxhaW4gb2JqZWN0LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iajogdW5rbm93bikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopXG4gIGlmIChwcm90byA9PT0gbnVsbCkgcmV0dXJuIHRydWVcblxuICBsZXQgYmFzZVByb3RvID0gcHJvdG9cbiAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlUHJvdG8pICE9PSBudWxsKSB7XG4gICAgYmFzZVByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90bylcbiAgfVxuXG4gIHJldHVybiBwcm90byA9PT0gYmFzZVByb3RvXG59XG4iLCJpbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL2lzUGxhaW5PYmplY3QnXG5pbXBvcnQgd2FybmluZyBmcm9tICcuL3dhcm5pbmcnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZlcmlmeVBsYWluT2JqZWN0KFxuICB2YWx1ZTogdW5rbm93bixcbiAgZGlzcGxheU5hbWU6IHN0cmluZyxcbiAgbWV0aG9kTmFtZTogc3RyaW5nLFxuKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgYCR7bWV0aG9kTmFtZX0oKSBpbiAke2Rpc3BsYXlOYW1lfSBtdXN0IHJldHVybiBhIHBsYWluIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZCAke3ZhbHVlfS5gLFxuICAgIClcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBBY3Rpb25DcmVhdG9yc01hcE9iamVjdCwgRGlzcGF0Y2gsIEFjdGlvbkNyZWF0b3IgfSBmcm9tICdyZWR1eCdcblxuaW1wb3J0IHR5cGUgeyBGaXhUeXBlTGF0ZXIgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB2ZXJpZnlQbGFpbk9iamVjdCBmcm9tICcuLi91dGlscy92ZXJpZnlQbGFpbk9iamVjdCdcblxudHlwZSBBbnlTdGF0ZSA9IHsgW2tleTogc3RyaW5nXTogYW55IH1cbnR5cGUgU3RhdGVPckRpc3BhdGNoPFMgZXh0ZW5kcyBBbnlTdGF0ZSA9IEFueVN0YXRlPiA9IFMgfCBEaXNwYXRjaFxuXG50eXBlIEFueVByb3BzID0geyBba2V5OiBzdHJpbmddOiBhbnkgfVxuXG5leHBvcnQgdHlwZSBNYXBUb1Byb3BzPFAgZXh0ZW5kcyBBbnlQcm9wcyA9IEFueVByb3BzPiA9IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIChzdGF0ZU9yRGlzcGF0Y2g6IFN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHM/OiBQKTogRml4VHlwZUxhdGVyXG4gIGRlcGVuZHNPbk93blByb3BzPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNDb25zdGFudChcbiAgLy8gKiBOb3RlOlxuICAvLyAgSXQgc2VlbXMgdGhhdCB0aGUgZGlzcGF0Y2ggYXJndW1lbnRcbiAgLy8gIGNvdWxkIGJlIGEgZGlzcGF0Y2ggZnVuY3Rpb24gaW4gc29tZSBjYXNlcyAoZXg6IHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc01pc3NpbmcpXG4gIC8vICBhbmQgYSBzdGF0ZSBvYmplY3QgaW4gc29tZSBvdGhlcnMgKGV4OiB3aGVuTWFwU3RhdGVUb1Byb3BzSXNNaXNzaW5nKVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgZ2V0Q29uc3RhbnQ6IChkaXNwYXRjaDogRGlzcGF0Y2gpID0+XG4gICAgfCB7XG4gICAgICAgIGRpc3BhdGNoPzogRGlzcGF0Y2hcbiAgICAgICAgZGVwZW5kc09uT3duUHJvcHM/OiBib29sZWFuXG4gICAgICB9XG4gICAgfCBBY3Rpb25DcmVhdG9yc01hcE9iamVjdFxuICAgIHwgQWN0aW9uQ3JlYXRvcjxhbnk+LFxuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0Q29uc3RhbnRTZWxlY3RvcihkaXNwYXRjaDogRGlzcGF0Y2gpIHtcbiAgICBjb25zdCBjb25zdGFudCA9IGdldENvbnN0YW50KGRpc3BhdGNoKVxuXG4gICAgZnVuY3Rpb24gY29uc3RhbnRTZWxlY3RvcigpIHtcbiAgICAgIHJldHVybiBjb25zdGFudFxuICAgIH1cbiAgICBjb25zdGFudFNlbGVjdG9yLmRlcGVuZHNPbk93blByb3BzID0gZmFsc2VcbiAgICByZXR1cm4gY29uc3RhbnRTZWxlY3RvclxuICB9XG59XG5cbi8vIGRlcGVuZHNPbk93blByb3BzIGlzIHVzZWQgYnkgY3JlYXRlTWFwVG9Qcm9wc1Byb3h5IHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHBhc3MgcHJvcHMgYXMgYXJnc1xuLy8gdG8gdGhlIG1hcFRvUHJvcHMgZnVuY3Rpb24gYmVpbmcgd3JhcHBlZC4gSXQgaXMgYWxzbyB1c2VkIGJ5IG1ha2VQdXJlUHJvcHNTZWxlY3RvciB0byBkZXRlcm1pbmVcbi8vIHdoZXRoZXIgbWFwVG9Qcm9wcyBuZWVkcyB0byBiZSBpbnZva2VkIHdoZW4gcHJvcHMgaGF2ZSBjaGFuZ2VkLlxuLy9cbi8vIEEgbGVuZ3RoIG9mIG9uZSBzaWduYWxzIHRoYXQgbWFwVG9Qcm9wcyBkb2VzIG5vdCBkZXBlbmQgb24gcHJvcHMgZnJvbSB0aGUgcGFyZW50IGNvbXBvbmVudC5cbi8vIEEgbGVuZ3RoIG9mIHplcm8gaXMgYXNzdW1lZCB0byBtZWFuIG1hcFRvUHJvcHMgaXMgZ2V0dGluZyBhcmdzIHZpYSBhcmd1bWVudHMgb3IgLi4uYXJncyBhbmRcbi8vIHRoZXJlZm9yZSBub3QgcmVwb3J0aW5nIGl0cyBsZW5ndGggYWNjdXJhdGVseS4uXG4vLyBUT0RPIENhbiB0aGlzIGdldCBwdWxsZWQgb3V0IHNvIHRoYXQgd2UgY2FuIHN1YnNjcmliZSBkaXJlY3RseSB0byB0aGUgc3RvcmUgaWYgd2UgZG9uJ3QgbmVlZCBvd25Qcm9wcz9cbmZ1bmN0aW9uIGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHM6IE1hcFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHNcbiAgICA/IEJvb2xlYW4obWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICA6IG1hcFRvUHJvcHMubGVuZ3RoICE9PSAxXG59XG5cbi8vIFVzZWQgYnkgd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb24gYW5kIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc0Z1bmN0aW9uLFxuLy8gdGhpcyBmdW5jdGlvbiB3cmFwcyBtYXBUb1Byb3BzIGluIGEgcHJveHkgZnVuY3Rpb24gd2hpY2ggZG9lcyBzZXZlcmFsIHRoaW5nczpcbi8vXG4vLyAgKiBEZXRlY3RzIHdoZXRoZXIgdGhlIG1hcFRvUHJvcHMgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIGRlcGVuZHMgb24gcHJvcHMsIHdoaWNoXG4vLyAgICBpcyB1c2VkIGJ5IHNlbGVjdG9yRmFjdG9yeSB0byBkZWNpZGUgaWYgaXQgc2hvdWxkIHJlaW52b2tlIG9uIHByb3BzIGNoYW5nZXMuXG4vL1xuLy8gICogT24gZmlyc3QgY2FsbCwgaGFuZGxlcyBtYXBUb1Byb3BzIGlmIHJldHVybnMgYW5vdGhlciBmdW5jdGlvbiwgYW5kIHRyZWF0cyB0aGF0XG4vLyAgICBuZXcgZnVuY3Rpb24gYXMgdGhlIHRydWUgbWFwVG9Qcm9wcyBmb3Igc3Vic2VxdWVudCBjYWxscy5cbi8vXG4vLyAgKiBPbiBmaXJzdCBjYWxsLCB2ZXJpZmllcyB0aGUgZmlyc3QgcmVzdWx0IGlzIGEgcGxhaW4gb2JqZWN0LCBpbiBvcmRlciB0byB3YXJuXG4vLyAgICB0aGUgZGV2ZWxvcGVyIHRoYXQgdGhlaXIgbWFwVG9Qcm9wcyBmdW5jdGlvbiBpcyBub3QgcmV0dXJuaW5nIGEgdmFsaWQgcmVzdWx0LlxuLy9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0Z1bmM8UCBleHRlbmRzIEFueVByb3BzID0gQW55UHJvcHM+KFxuICBtYXBUb1Byb3BzOiBNYXBUb1Byb3BzLFxuICBtZXRob2ROYW1lOiBzdHJpbmcsXG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRQcm94eVNlbGVjdG9yKFxuICAgIGRpc3BhdGNoOiBEaXNwYXRjaCxcbiAgICB7IGRpc3BsYXlOYW1lIH06IHsgZGlzcGxheU5hbWU6IHN0cmluZyB9LFxuICApIHtcbiAgICBjb25zdCBwcm94eSA9IGZ1bmN0aW9uIG1hcFRvUHJvcHNQcm94eShcbiAgICAgIHN0YXRlT3JEaXNwYXRjaDogU3RhdGVPckRpc3BhdGNoLFxuICAgICAgb3duUHJvcHM/OiBQLFxuICAgICk6IE1hcFRvUHJvcHMge1xuICAgICAgcmV0dXJuIHByb3h5LmRlcGVuZHNPbk93blByb3BzXG4gICAgICAgID8gcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKVxuICAgICAgICA6IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCB1bmRlZmluZWQpXG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeSB0byBnZXQgb3duUHJvcHNcbiAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IHRydWVcblxuICAgIHByb3h5Lm1hcFRvUHJvcHMgPSBmdW5jdGlvbiBkZXRlY3RGYWN0b3J5QW5kVmVyaWZ5KFxuICAgICAgc3RhdGVPckRpc3BhdGNoOiBTdGF0ZU9yRGlzcGF0Y2gsXG4gICAgICBvd25Qcm9wcz86IFAsXG4gICAgKTogTWFwVG9Qcm9wcyB7XG4gICAgICBwcm94eS5tYXBUb1Byb3BzID0gbWFwVG9Qcm9wc1xuICAgICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSBnZXREZXBlbmRzT25Pd25Qcm9wcyhtYXBUb1Byb3BzKVxuICAgICAgbGV0IHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcylcblxuICAgICAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm94eS5tYXBUb1Byb3BzID0gcHJvcHNcbiAgICAgICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSBnZXREZXBlbmRzT25Pd25Qcm9wcyhwcm9wcylcbiAgICAgICAgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKVxuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgdmVyaWZ5UGxhaW5PYmplY3QocHJvcHMsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKVxuXG4gICAgICByZXR1cm4gcHJvcHNcbiAgICB9XG5cbiAgICByZXR1cm4gcHJveHlcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBBY3Rpb24sIERpc3BhdGNoIH0gZnJvbSAncmVkdXgnXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShhcmc6IHVua25vd24sIG5hbWU6IHN0cmluZykge1xuICByZXR1cm4gKFxuICAgIGRpc3BhdGNoOiBEaXNwYXRjaDxBY3Rpb248c3RyaW5nPj4sXG4gICAgb3B0aW9uczogeyByZWFkb25seSB3cmFwcGVkQ29tcG9uZW50TmFtZTogc3RyaW5nIH0sXG4gICkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgYXJnfSBmb3IgJHtuYW1lfSBhcmd1bWVudCB3aGVuIGNvbm5lY3RpbmcgY29tcG9uZW50ICR7XG4gICAgICAgIG9wdGlvbnMud3JhcHBlZENvbXBvbmVudE5hbWVcbiAgICAgIH0uYCxcbiAgICApXG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgQWN0aW9uLCBEaXNwYXRjaCB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IGJpbmRBY3Rpb25DcmVhdG9ycyBmcm9tICcuLi91dGlscy9iaW5kQWN0aW9uQ3JlYXRvcnMnXG5pbXBvcnQgeyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50LCB3cmFwTWFwVG9Qcm9wc0Z1bmMgfSBmcm9tICcuL3dyYXBNYXBUb1Byb3BzJ1xuaW1wb3J0IHsgY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkgfSBmcm9tICcuL2ludmFsaWRBcmdGYWN0b3J5J1xuaW1wb3J0IHR5cGUgeyBNYXBEaXNwYXRjaFRvUHJvcHNQYXJhbSB9IGZyb20gJy4vc2VsZWN0b3JGYWN0b3J5J1xuXG5leHBvcnQgZnVuY3Rpb24gbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeTxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPihcbiAgbWFwRGlzcGF0Y2hUb1Byb3BzOlxuICAgIHwgTWFwRGlzcGF0Y2hUb1Byb3BzUGFyYW08VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz5cbiAgICB8IHVuZGVmaW5lZCxcbikge1xuICByZXR1cm4gbWFwRGlzcGF0Y2hUb1Byb3BzICYmIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09ICdvYmplY3QnXG4gICAgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KChkaXNwYXRjaDogRGlzcGF0Y2g8QWN0aW9uPHN0cmluZz4+KSA9PlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGJpbmRBY3Rpb25DcmVhdG9ycyhtYXBEaXNwYXRjaFRvUHJvcHMsIGRpc3BhdGNoKSxcbiAgICAgIClcbiAgICA6ICFtYXBEaXNwYXRjaFRvUHJvcHNcbiAgICAgID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudCgoZGlzcGF0Y2g6IERpc3BhdGNoPEFjdGlvbjxzdHJpbmc+PikgPT4gKHtcbiAgICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgfSkpXG4gICAgICA6IHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgd3JhcE1hcFRvUHJvcHNGdW5jKG1hcERpc3BhdGNoVG9Qcm9wcywgJ21hcERpc3BhdGNoVG9Qcm9wcycpXG4gICAgICAgIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJylcbn1cbiIsImltcG9ydCB7IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQsIHdyYXBNYXBUb1Byb3BzRnVuYyB9IGZyb20gJy4vd3JhcE1hcFRvUHJvcHMnXG5pbXBvcnQgeyBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeSB9IGZyb20gJy4vaW52YWxpZEFyZ0ZhY3RvcnknXG5pbXBvcnQgdHlwZSB7IE1hcFN0YXRlVG9Qcm9wc1BhcmFtIH0gZnJvbSAnLi9zZWxlY3RvckZhY3RvcnknXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5PFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPihcbiAgbWFwU3RhdGVUb1Byb3BzOiBNYXBTdGF0ZVRvUHJvcHNQYXJhbTxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4sXG4pIHtcbiAgcmV0dXJuICFtYXBTdGF0ZVRvUHJvcHNcbiAgICA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoKCkgPT4gKHt9KSlcbiAgICA6IHR5cGVvZiBtYXBTdGF0ZVRvUHJvcHMgPT09ICdmdW5jdGlvbidcbiAgICAgID8gLy8gQHRzLWlnbm9yZVxuICAgICAgICB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwU3RhdGVUb1Byb3BzLCAnbWFwU3RhdGVUb1Byb3BzJylcbiAgICAgIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCAnbWFwU3RhdGVUb1Byb3BzJylcbn1cbiIsImltcG9ydCB0eXBlIHsgQWN0aW9uLCBEaXNwYXRjaCB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IHZlcmlmeVBsYWluT2JqZWN0IGZyb20gJy4uL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0J1xuaW1wb3J0IHsgY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkgfSBmcm9tICcuL2ludmFsaWRBcmdGYWN0b3J5J1xuaW1wb3J0IHR5cGUgeyBNZXJnZVByb3BzIH0gZnJvbSAnLi9zZWxlY3RvckZhY3RvcnknXG5pbXBvcnQgdHlwZSB7IEVxdWFsaXR5Rm4gfSBmcm9tICcuLi90eXBlcydcblxuZnVuY3Rpb24gZGVmYXVsdE1lcmdlUHJvcHM8XG4gIFRTdGF0ZVByb3BzLFxuICBURGlzcGF0Y2hQcm9wcyxcbiAgVE93blByb3BzLFxuICBUTWVyZ2VkUHJvcHMsXG4+KFxuICBzdGF0ZVByb3BzOiBUU3RhdGVQcm9wcyxcbiAgZGlzcGF0Y2hQcm9wczogVERpc3BhdGNoUHJvcHMsXG4gIG93blByb3BzOiBUT3duUHJvcHMsXG4pOiBUTWVyZ2VkUHJvcHMge1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiB7IC4uLm93blByb3BzLCAuLi5zdGF0ZVByb3BzLCAuLi5kaXNwYXRjaFByb3BzIH1cbn1cblxuZnVuY3Rpb24gd3JhcE1lcmdlUHJvcHNGdW5jPFxuICBUU3RhdGVQcm9wcyxcbiAgVERpc3BhdGNoUHJvcHMsXG4gIFRPd25Qcm9wcyxcbiAgVE1lcmdlZFByb3BzLFxuPihcbiAgbWVyZ2VQcm9wczogTWVyZ2VQcm9wczxUU3RhdGVQcm9wcywgVERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcywgVE1lcmdlZFByb3BzPixcbik6IChcbiAgZGlzcGF0Y2g6IERpc3BhdGNoPEFjdGlvbjxzdHJpbmc+PixcbiAgb3B0aW9uczoge1xuICAgIHJlYWRvbmx5IGRpc3BsYXlOYW1lOiBzdHJpbmdcbiAgICByZWFkb25seSBhcmVNZXJnZWRQcm9wc0VxdWFsOiBFcXVhbGl0eUZuPFRNZXJnZWRQcm9wcz5cbiAgfSxcbikgPT4gTWVyZ2VQcm9wczxUU3RhdGVQcm9wcywgVERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcywgVE1lcmdlZFByb3BzPiB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0TWVyZ2VQcm9wc1Byb3h5KFxuICAgIGRpc3BhdGNoLFxuICAgIHsgZGlzcGxheU5hbWUsIGFyZU1lcmdlZFByb3BzRXF1YWwgfSxcbiAgKSB7XG4gICAgbGV0IGhhc1J1bk9uY2UgPSBmYWxzZVxuICAgIGxldCBtZXJnZWRQcm9wczogVE1lcmdlZFByb3BzXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VQcm9wc1Byb3h5KFxuICAgICAgc3RhdGVQcm9wczogVFN0YXRlUHJvcHMsXG4gICAgICBkaXNwYXRjaFByb3BzOiBURGlzcGF0Y2hQcm9wcyxcbiAgICAgIG93blByb3BzOiBUT3duUHJvcHMsXG4gICAgKSB7XG4gICAgICBjb25zdCBuZXh0TWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKVxuXG4gICAgICBpZiAoaGFzUnVuT25jZSkge1xuICAgICAgICBpZiAoIWFyZU1lcmdlZFByb3BzRXF1YWwobmV4dE1lcmdlZFByb3BzLCBtZXJnZWRQcm9wcykpXG4gICAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1J1bk9uY2UgPSB0cnVlXG4gICAgICAgIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzXG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgICAgdmVyaWZ5UGxhaW5PYmplY3QobWVyZ2VkUHJvcHMsIGRpc3BsYXlOYW1lLCAnbWVyZ2VQcm9wcycpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXJnZWRQcm9wc1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VQcm9wc0ZhY3Rvcnk8XG4gIFRTdGF0ZVByb3BzLFxuICBURGlzcGF0Y2hQcm9wcyxcbiAgVE93blByb3BzLFxuICBUTWVyZ2VkUHJvcHMsXG4+KFxuICBtZXJnZVByb3BzPzogTWVyZ2VQcm9wczxUU3RhdGVQcm9wcywgVERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcywgVE1lcmdlZFByb3BzPixcbikge1xuICByZXR1cm4gIW1lcmdlUHJvcHNcbiAgICA/ICgpID0+IGRlZmF1bHRNZXJnZVByb3BzXG4gICAgOiB0eXBlb2YgbWVyZ2VQcm9wcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcylcbiAgICAgIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWVyZ2VQcm9wcywgJ21lcmdlUHJvcHMnKVxufVxuIiwiLy8gRGVmYXVsdCB0byBhIGR1bW15IFwiYmF0Y2hcIiBpbXBsZW1lbnRhdGlvbiB0aGF0IGp1c3QgcnVucyB0aGUgY2FsbGJhY2tcclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHROb29wQmF0Y2goY2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcclxuICBjYWxsYmFjaygpXHJcbn1cclxuIiwiaW1wb3J0IHsgZGVmYXVsdE5vb3BCYXRjaCBhcyBiYXRjaCB9IGZyb20gJy4vYmF0Y2gnXG5cbi8vIGVuY2Fwc3VsYXRlcyB0aGUgc3Vic2NyaXB0aW9uIGxvZ2ljIGZvciBjb25uZWN0aW5nIGEgY29tcG9uZW50IHRvIHRoZSByZWR1eCBzdG9yZSwgYXNcbi8vIHdlbGwgYXMgbmVzdGluZyBzdWJzY3JpcHRpb25zIG9mIGRlc2NlbmRhbnQgY29tcG9uZW50cywgc28gdGhhdCB3ZSBjYW4gZW5zdXJlIHRoZVxuLy8gYW5jZXN0b3IgY29tcG9uZW50cyByZS1yZW5kZXIgYmVmb3JlIGRlc2NlbmRhbnRzXG5cbnR5cGUgVm9pZEZ1bmMgPSAoKSA9PiB2b2lkXG5cbnR5cGUgTGlzdGVuZXIgPSB7XG4gIGNhbGxiYWNrOiBWb2lkRnVuY1xuICBuZXh0OiBMaXN0ZW5lciB8IG51bGxcbiAgcHJldjogTGlzdGVuZXIgfCBudWxsXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpIHtcbiAgbGV0IGZpcnN0OiBMaXN0ZW5lciB8IG51bGwgPSBudWxsXG4gIGxldCBsYXN0OiBMaXN0ZW5lciB8IG51bGwgPSBudWxsXG5cbiAgcmV0dXJuIHtcbiAgICBjbGVhcigpIHtcbiAgICAgIGZpcnN0ID0gbnVsbFxuICAgICAgbGFzdCA9IG51bGxcbiAgICB9LFxuXG4gICAgbm90aWZ5KCkge1xuICAgICAgYmF0Y2goKCkgPT4ge1xuICAgICAgICBsZXQgbGlzdGVuZXIgPSBmaXJzdFxuICAgICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjaygpXG4gICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVyczogTGlzdGVuZXJbXSA9IFtdXG4gICAgICBsZXQgbGlzdGVuZXIgPSBmaXJzdFxuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKVxuICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHRcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0ZW5lcnNcbiAgICB9LFxuXG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7XG4gICAgICBsZXQgaXNTdWJzY3JpYmVkID0gdHJ1ZVxuXG4gICAgICBjb25zdCBsaXN0ZW5lcjogTGlzdGVuZXIgPSAobGFzdCA9IHtcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgIHByZXY6IGxhc3QsXG4gICAgICB9KVxuXG4gICAgICBpZiAobGlzdGVuZXIucHJldikge1xuICAgICAgICBsaXN0ZW5lci5wcmV2Lm5leHQgPSBsaXN0ZW5lclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3QgPSBsaXN0ZW5lclxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICghaXNTdWJzY3JpYmVkIHx8IGZpcnN0ID09PSBudWxsKSByZXR1cm5cbiAgICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2VcblxuICAgICAgICBpZiAobGlzdGVuZXIubmV4dCkge1xuICAgICAgICAgIGxpc3RlbmVyLm5leHQucHJldiA9IGxpc3RlbmVyLnByZXZcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0ID0gbGlzdGVuZXIucHJldlxuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lci5wcmV2KSB7XG4gICAgICAgICAgbGlzdGVuZXIucHJldi5uZXh0ID0gbGlzdGVuZXIubmV4dFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpcnN0ID0gbGlzdGVuZXIubmV4dFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfVxufVxuXG50eXBlIExpc3RlbmVyQ29sbGVjdGlvbiA9IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbj5cblxuZXhwb3J0IGludGVyZmFjZSBTdWJzY3JpcHRpb24ge1xuICBhZGROZXN0ZWRTdWI6IChsaXN0ZW5lcjogVm9pZEZ1bmMpID0+IFZvaWRGdW5jXG4gIG5vdGlmeU5lc3RlZFN1YnM6IFZvaWRGdW5jXG4gIGhhbmRsZUNoYW5nZVdyYXBwZXI6IFZvaWRGdW5jXG4gIGlzU3Vic2NyaWJlZDogKCkgPT4gYm9vbGVhblxuICBvblN0YXRlQ2hhbmdlPzogVm9pZEZ1bmMgfCBudWxsXG4gIHRyeVN1YnNjcmliZTogVm9pZEZ1bmNcbiAgdHJ5VW5zdWJzY3JpYmU6IFZvaWRGdW5jXG4gIGdldExpc3RlbmVyczogKCkgPT4gTGlzdGVuZXJDb2xsZWN0aW9uXG59XG5cbmNvbnN0IG51bGxMaXN0ZW5lcnMgPSB7XG4gIG5vdGlmeSgpIHt9LFxuICBnZXQ6ICgpID0+IFtdLFxufSBhcyB1bmtub3duIGFzIExpc3RlbmVyQ29sbGVjdGlvblxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3Vic2NyaXB0aW9uKHN0b3JlOiBhbnksIHBhcmVudFN1Yj86IFN1YnNjcmlwdGlvbikge1xuICBsZXQgdW5zdWJzY3JpYmU6IFZvaWRGdW5jIHwgdW5kZWZpbmVkXG4gIGxldCBsaXN0ZW5lcnM6IExpc3RlbmVyQ29sbGVjdGlvbiA9IG51bGxMaXN0ZW5lcnNcblxuICAvLyBSZWFzb25zIHRvIGtlZXAgdGhlIHN1YnNjcmlwdGlvbiBhY3RpdmVcbiAgbGV0IHN1YnNjcmlwdGlvbnNBbW91bnQgPSAwXG5cbiAgLy8gSXMgdGhpcyBzcGVjaWZpYyBzdWJzY3JpcHRpb24gc3Vic2NyaWJlZCAob3Igb25seSBuZXN0ZWQgb25lcz8pXG4gIGxldCBzZWxmU3Vic2NyaWJlZCA9IGZhbHNlXG5cbiAgZnVuY3Rpb24gYWRkTmVzdGVkU3ViKGxpc3RlbmVyOiAoKSA9PiB2b2lkKSB7XG4gICAgdHJ5U3Vic2NyaWJlKClcblxuICAgIGNvbnN0IGNsZWFudXBMaXN0ZW5lciA9IGxpc3RlbmVycy5zdWJzY3JpYmUobGlzdGVuZXIpXG5cbiAgICAvLyBjbGVhbnVwIG5lc3RlZCBzdWJcbiAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghcmVtb3ZlZCkge1xuICAgICAgICByZW1vdmVkID0gdHJ1ZVxuICAgICAgICBjbGVhbnVwTGlzdGVuZXIoKVxuICAgICAgICB0cnlVbnN1YnNjcmliZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5TmVzdGVkU3VicygpIHtcbiAgICBsaXN0ZW5lcnMubm90aWZ5KClcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNoYW5nZVdyYXBwZXIoKSB7XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlKSB7XG4gICAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgIHJldHVybiBzZWxmU3Vic2NyaWJlZFxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5U3Vic2NyaWJlKCkge1xuICAgIHN1YnNjcmlwdGlvbnNBbW91bnQrK1xuICAgIGlmICghdW5zdWJzY3JpYmUpIHtcbiAgICAgIHVuc3Vic2NyaWJlID0gcGFyZW50U3ViXG4gICAgICAgID8gcGFyZW50U3ViLmFkZE5lc3RlZFN1YihoYW5kbGVDaGFuZ2VXcmFwcGVyKVxuICAgICAgICA6IHN0b3JlLnN1YnNjcmliZShoYW5kbGVDaGFuZ2VXcmFwcGVyKVxuXG4gICAgICBsaXN0ZW5lcnMgPSBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xuICAgIHN1YnNjcmlwdGlvbnNBbW91bnQtLVxuICAgIGlmICh1bnN1YnNjcmliZSAmJiBzdWJzY3JpcHRpb25zQW1vdW50ID09PSAwKSB7XG4gICAgICB1bnN1YnNjcmliZSgpXG4gICAgICB1bnN1YnNjcmliZSA9IHVuZGVmaW5lZFxuICAgICAgbGlzdGVuZXJzLmNsZWFyKClcbiAgICAgIGxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnNcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cnlTdWJzY3JpYmVTZWxmKCkge1xuICAgIGlmICghc2VsZlN1YnNjcmliZWQpIHtcbiAgICAgIHNlbGZTdWJzY3JpYmVkID0gdHJ1ZVxuICAgICAgdHJ5U3Vic2NyaWJlKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZVNlbGYoKSB7XG4gICAgaWYgKHNlbGZTdWJzY3JpYmVkKSB7XG4gICAgICBzZWxmU3Vic2NyaWJlZCA9IGZhbHNlXG4gICAgICB0cnlVbnN1YnNjcmliZSgpXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gPSB7XG4gICAgYWRkTmVzdGVkU3ViLFxuICAgIG5vdGlmeU5lc3RlZFN1YnMsXG4gICAgaGFuZGxlQ2hhbmdlV3JhcHBlcixcbiAgICBpc1N1YnNjcmliZWQsXG4gICAgdHJ5U3Vic2NyaWJlOiB0cnlTdWJzY3JpYmVTZWxmLFxuICAgIHRyeVVuc3Vic2NyaWJlOiB0cnlVbnN1YnNjcmliZVNlbGYsXG4gICAgZ2V0TGlzdGVuZXJzOiAoKSA9PiBsaXN0ZW5lcnMsXG4gIH1cblxuICByZXR1cm4gc3Vic2NyaXB0aW9uXG59XG4iLCJpbXBvcnQgeyBSZWFjdCB9IGZyb20gJy4uL3V0aWxzL3JlYWN0J1xuXG4vLyBSZWFjdCBjdXJyZW50bHkgdGhyb3dzIGEgd2FybmluZyB3aGVuIHVzaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgc2VydmVyLlxuLy8gVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcbi8vIHVzZUxheW91dEVmZmVjdCBpbiB0aGUgYnJvd3Nlci4gV2UgbmVlZCB1c2VMYXlvdXRFZmZlY3QgdG8gZW5zdXJlIHRoZSBzdG9yZVxuLy8gc3Vic2NyaXB0aW9uIGNhbGxiYWNrIGFsd2F5cyBoYXMgdGhlIHNlbGVjdG9yIGZyb20gdGhlIGxhdGVzdCByZW5kZXIgY29tbWl0XG4vLyBhdmFpbGFibGUsIG90aGVyd2lzZSBhIHN0b3JlIHVwZGF0ZSBtYXkgaGFwcGVuIGJldHdlZW4gcmVuZGVyIGFuZCB0aGUgZWZmZWN0LFxuLy8gd2hpY2ggbWF5IGNhdXNlIG1pc3NlZCB1cGRhdGVzOyB3ZSBhbHNvIG11c3QgZW5zdXJlIHRoZSBzdG9yZSBzdWJzY3JpcHRpb25cbi8vIGlzIGNyZWF0ZWQgc3luY2hyb25vdXNseSwgb3RoZXJ3aXNlIGEgc3RvcmUgdXBkYXRlIG1heSBvY2N1ciBiZWZvcmUgdGhlXG4vLyBzdWJzY3JpcHRpb24gaXMgY3JlYXRlZCBhbmQgYW4gaW5jb25zaXN0ZW50IHN0YXRlIG1heSBiZSBvYnNlcnZlZFxuXG4vLyBNYXRjaGVzIGxvZ2ljIGluIFJlYWN0J3MgYHNoYXJlZC9FeGVjdXRpb25FbnZpcm9ubWVudGAgZmlsZVxuY29uc3QgY2FuVXNlRE9NID0gKCkgPT5cbiAgISEoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKVxuXG5jb25zdCBpc0RPTSA9IC8qIEBfX1BVUkVfXyAqLyBjYW5Vc2VET00oKVxuXG4vLyBVbmRlciBSZWFjdCBOYXRpdmUsIHdlIGtub3cgdGhhdCB3ZSBhbHdheXMgd2FudCB0byB1c2UgdXNlTGF5b3V0RWZmZWN0XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBjb2RlIGlzIHJ1bm5pbmcgaW4gYSBSZWFjdCBOYXRpdmUgZW52aXJvbm1lbnQuXG4gKlxuICogQHJldHVybnMgV2hldGhlciB0aGUgY29kZSBpcyBydW5uaW5nIGluIGEgUmVhY3QgTmF0aXZlIGVudmlyb25tZW50LlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvaXNzdWVzLzEzMzEgUmVmZXJlbmNlfVxuICovXG5jb25zdCBpc1J1bm5pbmdJblJlYWN0TmF0aXZlID0gKCkgPT5cbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZSdcblxuY29uc3QgaXNSZWFjdE5hdGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBpc1J1bm5pbmdJblJlYWN0TmF0aXZlKClcblxuY29uc3QgZ2V0VXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9ICgpID0+XG4gIGlzRE9NIHx8IGlzUmVhY3ROYXRpdmUgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3RcblxuZXhwb3J0IGNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPVxuICAvKiBAX19QVVJFX18gKi8gZ2V0VXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgpXG4iLCJmdW5jdGlvbiBpcyh4OiB1bmtub3duLCB5OiB1bmtub3duKSB7XHJcbiAgaWYgKHggPT09IHkpIHtcclxuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHlcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBOiBhbnksIG9iakI6IGFueSkge1xyXG4gIGlmIChpcyhvYmpBLCBvYmpCKSkgcmV0dXJuIHRydWVcclxuXHJcbiAgaWYgKFxyXG4gICAgdHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8XHJcbiAgICBvYmpBID09PSBudWxsIHx8XHJcbiAgICB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHxcclxuICAgIG9iakIgPT09IG51bGxcclxuICApIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKVxyXG4gIGNvbnN0IGtleXNCID0gT2JqZWN0LmtleXMob2JqQilcclxuXHJcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKFxyXG4gICAgICAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fFxyXG4gICAgICAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKVxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWVcclxufVxyXG4iLCIvLyBDb3BpZWQgZGlyZWN0bHkgZnJvbTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmlkZ3dheS9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9ibG9iL21haW4vc3JjL2luZGV4LmpzXG4vLyBodHRwczovL3VucGtnLmNvbS9icm93c2UvQHR5cGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzQDMuMy42L2luZGV4LmQudHNcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuaW1wb3J0IHR5cGUgeyBGb3J3YXJkUmVmRXhvdGljQ29tcG9uZW50LCBNZW1vRXhvdGljQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBGb3J3YXJkUmVmLCBNZW1vLCBpc01lbW8gfSBmcm9tICcuLi91dGlscy9yZWFjdC1pcydcblxuY29uc3QgUkVBQ1RfU1RBVElDUyA9IHtcbiAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gIGNvbnRleHRUeXBlOiB0cnVlLFxuICBjb250ZXh0VHlwZXM6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gIG1peGluczogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlLFxufSBhcyBjb25zdFxuXG5jb25zdCBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWUsXG59IGFzIGNvbnN0XG5cbmNvbnN0IEZPUldBUkRfUkVGX1NUQVRJQ1MgPSB7XG4gICQkdHlwZW9mOiB0cnVlLFxuICByZW5kZXI6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbn0gYXMgY29uc3RcblxuY29uc3QgTUVNT19TVEFUSUNTID0ge1xuICAkJHR5cGVvZjogdHJ1ZSxcbiAgY29tcGFyZTogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlLFxufSBhcyBjb25zdFxuXG5jb25zdCBUWVBFX1NUQVRJQ1MgPSB7XG4gIFtGb3J3YXJkUmVmXTogRk9SV0FSRF9SRUZfU1RBVElDUyxcbiAgW01lbW9dOiBNRU1PX1NUQVRJQ1MsXG59IGFzIGNvbnN0XG5cbmZ1bmN0aW9uIGdldFN0YXRpY3MoY29tcG9uZW50OiBhbnkpIHtcbiAgLy8gUmVhY3QgdjE2LjExIGFuZCBiZWxvd1xuICBpZiAoaXNNZW1vKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gTUVNT19TVEFUSUNTXG4gIH1cblxuICAvLyBSZWFjdCB2MTYuMTIgYW5kIGFib3ZlXG4gIHJldHVybiBUWVBFX1NUQVRJQ1NbY29tcG9uZW50WyckJHR5cGVvZiddXSB8fCBSRUFDVF9TVEFUSUNTXG59XG5cbmV4cG9ydCB0eXBlIE5vblJlYWN0U3RhdGljczxcbiAgU291cmNlLFxuICBDIGV4dGVuZHMge1xuICAgIFtrZXk6IHN0cmluZ106IHRydWVcbiAgfSA9IHt9LFxuPiA9IHtcbiAgW2tleSBpbiBFeGNsdWRlPFxuICAgIGtleW9mIFNvdXJjZSxcbiAgICBTb3VyY2UgZXh0ZW5kcyBNZW1vRXhvdGljQ29tcG9uZW50PGFueT5cbiAgICAgID8ga2V5b2YgdHlwZW9mIE1FTU9fU1RBVElDUyB8IGtleW9mIENcbiAgICAgIDogU291cmNlIGV4dGVuZHMgRm9yd2FyZFJlZkV4b3RpY0NvbXBvbmVudDxhbnk+XG4gICAgICAgID8ga2V5b2YgdHlwZW9mIEZPUldBUkRfUkVGX1NUQVRJQ1MgfCBrZXlvZiBDXG4gICAgICAgIDoga2V5b2YgdHlwZW9mIFJFQUNUX1NUQVRJQ1MgfCBrZXlvZiB0eXBlb2YgS05PV05fU1RBVElDUyB8IGtleW9mIENcbiAgPl06IFNvdXJjZVtrZXldXG59XG5cbmNvbnN0IGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG5jb25zdCBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbmNvbnN0IGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbmNvbnN0IGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbmNvbnN0IGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mXG5jb25zdCBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzPFxuICBUYXJnZXQsXG4gIFNvdXJjZSxcbiAgQ3VzdG9tU3RhdGljIGV4dGVuZHMge1xuICAgIFtrZXk6IHN0cmluZ106IHRydWVcbiAgfSA9IHt9LFxuPihcbiAgdGFyZ2V0Q29tcG9uZW50OiBUYXJnZXQsXG4gIHNvdXJjZUNvbXBvbmVudDogU291cmNlLFxuKTogVGFyZ2V0ICYgTm9uUmVhY3RTdGF0aWNzPFNvdXJjZSwgQ3VzdG9tU3RhdGljPiB7XG4gIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG5cbiAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICBjb25zdCBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpXG4gICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBrZXlzOiAoc3RyaW5nIHwgc3ltYm9sKVtdID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpXG5cbiAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0U3RhdGljcyA9IGdldFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50KVxuICAgIGNvbnN0IHNvdXJjZVN0YXRpY3MgPSBnZXRTdGF0aWNzKHNvdXJjZUNvbXBvbmVudClcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgaWYgKFxuICAgICAgICAhS05PV05fU1RBVElDU1trZXkgYXMga2V5b2YgdHlwZW9mIEtOT1dOX1NUQVRJQ1NdICYmXG4gICAgICAgICEoc291cmNlU3RhdGljcyAmJiBzb3VyY2VTdGF0aWNzW2tleSBhcyBrZXlvZiB0eXBlb2Ygc291cmNlU3RhdGljc10pICYmXG4gICAgICAgICEodGFyZ2V0U3RhdGljcyAmJiB0YXJnZXRTdGF0aWNzW2tleSBhcyBrZXlvZiB0eXBlb2YgdGFyZ2V0U3RhdGljc10pXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IhKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50IGFzIGFueVxufVxuIiwiaW1wb3J0IHR5cGUgeyBDb250ZXh0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBSZWFjdCB9IGZyb20gJy4uL3V0aWxzL3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBBY3Rpb24sIFN0b3JlLCBVbmtub3duQWN0aW9uIH0gZnJvbSAncmVkdXgnXG5pbXBvcnQgdHlwZSB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL3V0aWxzL1N1YnNjcmlwdGlvbidcbmltcG9ydCB0eXBlIHsgUHJvdmlkZXJQcm9wcyB9IGZyb20gJy4vUHJvdmlkZXInXG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVhY3RSZWR1eENvbnRleHRWYWx1ZTxcbiAgU1MgPSBhbnksXG4gIEEgZXh0ZW5kcyBBY3Rpb248c3RyaW5nPiA9IFVua25vd25BY3Rpb24sXG4+IGV4dGVuZHMgUGljazxQcm92aWRlclByb3BzLCAnc3RhYmlsaXR5Q2hlY2snIHwgJ2lkZW50aXR5RnVuY3Rpb25DaGVjayc+IHtcbiAgc3RvcmU6IFN0b3JlPFNTLCBBPlxuICBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvblxuICBnZXRTZXJ2ZXJTdGF0ZT86ICgpID0+IFNTXG59XG5cbmNvbnN0IENvbnRleHRLZXkgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihgcmVhY3QtcmVkdXgtY29udGV4dGApXG5jb25zdCBnVDoge1xuICBbQ29udGV4dEtleV0/OiBNYXA8XG4gICAgdHlwZW9mIFJlYWN0LmNyZWF0ZUNvbnRleHQsXG4gICAgQ29udGV4dDxSZWFjdFJlZHV4Q29udGV4dFZhbHVlIHwgbnVsbD5cbiAgPlxufSA9IChcbiAgdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gICAgPyBnbG9iYWxUaGlzXG4gICAgOiAvKiBmYWxsIGJhY2sgdG8gYSBwZXItbW9kdWxlIHNjb3BlIChwcmUtOC4xIGJlaGF2aW91cikgaWYgYGdsb2JhbFRoaXNgIGlzIG5vdCBhdmFpbGFibGUgKi8ge31cbikgYXMgYW55XG5cbmZ1bmN0aW9uIGdldENvbnRleHQoKTogQ29udGV4dDxSZWFjdFJlZHV4Q29udGV4dFZhbHVlIHwgbnVsbD4ge1xuICBpZiAoIVJlYWN0LmNyZWF0ZUNvbnRleHQpIHJldHVybiB7fSBhcyBhbnlcblxuICBjb25zdCBjb250ZXh0TWFwID0gKGdUW0NvbnRleHRLZXldID8/PSBuZXcgTWFwPFxuICAgIHR5cGVvZiBSZWFjdC5jcmVhdGVDb250ZXh0LFxuICAgIENvbnRleHQ8UmVhY3RSZWR1eENvbnRleHRWYWx1ZSB8IG51bGw+XG4gID4oKSlcbiAgbGV0IHJlYWxDb250ZXh0ID0gY29udGV4dE1hcC5nZXQoUmVhY3QuY3JlYXRlQ29udGV4dClcbiAgaWYgKCFyZWFsQ29udGV4dCkge1xuICAgIHJlYWxDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxSZWFjdFJlZHV4Q29udGV4dFZhbHVlIHwgbnVsbD4oXG4gICAgICBudWxsIGFzIGFueSxcbiAgICApXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJlYWxDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1JlYWN0UmVkdXgnXG4gICAgfVxuICAgIGNvbnRleHRNYXAuc2V0KFJlYWN0LmNyZWF0ZUNvbnRleHQsIHJlYWxDb250ZXh0KVxuICB9XG4gIHJldHVybiByZWFsQ29udGV4dFxufVxuXG5leHBvcnQgY29uc3QgUmVhY3RSZWR1eENvbnRleHQgPSAvKiNfX1BVUkVfXyovIGdldENvbnRleHQoKVxuXG5leHBvcnQgdHlwZSBSZWFjdFJlZHV4Q29udGV4dEluc3RhbmNlID0gdHlwZW9mIFJlYWN0UmVkdXhDb250ZXh0XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG5pbXBvcnQgdHlwZSB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFJlYWN0IH0gZnJvbSAnLi4vdXRpbHMvcmVhY3QnXG5pbXBvcnQgeyBpc1ZhbGlkRWxlbWVudFR5cGUsIGlzQ29udGV4dENvbnN1bWVyIH0gZnJvbSAnLi4vdXRpbHMvcmVhY3QtaXMnXG5cbmltcG9ydCB0eXBlIHsgU3RvcmUgfSBmcm9tICdyZWR1eCdcblxuaW1wb3J0IHR5cGUge1xuICBDb25uZWN0ZWRDb21wb25lbnQsXG4gIEluZmVyYWJsZUNvbXBvbmVudEVuaGFuY2VyLFxuICBJbmZlcmFibGVDb21wb25lbnRFbmhhbmNlcldpdGhQcm9wcyxcbiAgUmVzb2x2ZVRodW5rcyxcbiAgRGlzcGF0Y2hQcm9wLFxuICBDb25uZWN0UHJvcHNNYXliZVdpdGhvdXRDb250ZXh0LFxufSBmcm9tICcuLi90eXBlcydcblxuaW1wb3J0IHR5cGUge1xuICBNYXBTdGF0ZVRvUHJvcHNQYXJhbSxcbiAgTWFwRGlzcGF0Y2hUb1Byb3BzUGFyYW0sXG4gIE1lcmdlUHJvcHMsXG4gIE1hcERpc3BhdGNoVG9Qcm9wc05vbk9iamVjdCxcbiAgU2VsZWN0b3JGYWN0b3J5T3B0aW9ucyxcbn0gZnJvbSAnLi4vY29ubmVjdC9zZWxlY3RvckZhY3RvcnknXG5pbXBvcnQgZGVmYXVsdFNlbGVjdG9yRmFjdG9yeSBmcm9tICcuLi9jb25uZWN0L3NlbGVjdG9yRmFjdG9yeSdcbmltcG9ydCB7IG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkgfSBmcm9tICcuLi9jb25uZWN0L21hcERpc3BhdGNoVG9Qcm9wcydcbmltcG9ydCB7IG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkgfSBmcm9tICcuLi9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcydcbmltcG9ydCB7IG1lcmdlUHJvcHNGYWN0b3J5IH0gZnJvbSAnLi4vY29ubmVjdC9tZXJnZVByb3BzJ1xuXG5pbXBvcnQgdHlwZSB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL3V0aWxzL1N1YnNjcmlwdGlvbidcbmltcG9ydCB7IGNyZWF0ZVN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL3V0aWxzL1N1YnNjcmlwdGlvbidcbmltcG9ydCB7IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfSBmcm9tICcuLi91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0J1xuaW1wb3J0IHNoYWxsb3dFcXVhbCBmcm9tICcuLi91dGlscy9zaGFsbG93RXF1YWwnXG5pbXBvcnQgaG9pc3RTdGF0aWNzIGZyb20gJy4uL3V0aWxzL2hvaXN0U3RhdGljcydcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4uL3V0aWxzL3dhcm5pbmcnXG5cbmltcG9ydCB0eXBlIHtcbiAgUmVhY3RSZWR1eENvbnRleHRWYWx1ZSxcbiAgUmVhY3RSZWR1eENvbnRleHRJbnN0YW5jZSxcbn0gZnJvbSAnLi9Db250ZXh0J1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuL0NvbnRleHQnXG5cbi8vIERlZmluZSBzb21lIGNvbnN0YW50IGFycmF5cyBqdXN0IHRvIGF2b2lkIHJlLWNyZWF0aW5nIHRoZXNlXG5jb25zdCBFTVBUWV9BUlJBWTogW3Vua25vd24sIG51bWJlcl0gPSBbbnVsbCwgMF1cbmNvbnN0IE5PX1NVQlNDUklQVElPTl9BUlJBWSA9IFtudWxsLCBudWxsXVxuXG4vLyBBdHRlbXB0cyB0byBzdHJpbmdpZnkgd2hhdGV2ZXIgbm90LXJlYWxseS1hLWNvbXBvbmVudCB2YWx1ZSB3ZSB3ZXJlIGdpdmVuXG4vLyBmb3IgbG9nZ2luZyBpbiBhbiBlcnJvciBtZXNzYWdlXG5jb25zdCBzdHJpbmdpZnlDb21wb25lbnQgPSAoQ29tcDogdW5rbm93bikgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShDb21wKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nKENvbXApXG4gIH1cbn1cblxudHlwZSBFZmZlY3RGdW5jID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkIHwgUmV0dXJuVHlwZTxSZWFjdC5FZmZlY3RDYWxsYmFjaz5cblxuLy8gVGhpcyBpcyBcImp1c3RcIiBhIGB1c2VMYXlvdXRFZmZlY3RgLCBidXQgd2l0aCB0d28gbW9kaWZpY2F0aW9uczpcbi8vIC0gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gYHVzZUVmZmVjdGAgaW4gU1NSIHRvIGF2b2lkIGFubm95aW5nIHdhcm5pbmdzXG4vLyAtIHdlIGV4dHJhY3QgdGhpcyB0byBhIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGF2b2lkIGNsb3Npbmcgb3ZlciB2YWx1ZXNcbi8vICAgYW5kIGNhdXNpbmcgbWVtb3J5IGxlYWtzXG5mdW5jdGlvbiB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MoXG4gIGVmZmVjdEZ1bmM6IEVmZmVjdEZ1bmMsXG4gIGVmZmVjdEFyZ3M6IGFueVtdLFxuICBkZXBlbmRlbmNpZXM/OiBSZWFjdC5EZXBlbmRlbmN5TGlzdCxcbikge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IGVmZmVjdEZ1bmMoLi4uZWZmZWN0QXJncyksIGRlcGVuZGVuY2llcylcbn1cblxuLy8gRWZmZWN0IGNhbGxiYWNrLCBleHRyYWN0ZWQ6IGFzc2lnbiB0aGUgbGF0ZXN0IHByb3BzIHZhbHVlcyB0byByZWZzIGZvciBsYXRlciB1c2FnZVxuZnVuY3Rpb24gY2FwdHVyZVdyYXBwZXJQcm9wcyhcbiAgbGFzdFdyYXBwZXJQcm9wczogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDx1bmtub3duPixcbiAgbGFzdENoaWxkUHJvcHM6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8dW5rbm93bj4sXG4gIHJlbmRlcklzU2NoZWR1bGVkOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PGJvb2xlYW4+LFxuICB3cmFwcGVyUHJvcHM6IHVua25vd24sXG4gIC8vIGFjdHVhbENoaWxkUHJvcHM6IHVua25vd24sXG4gIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGU6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8dW5rbm93bj4sXG4gIG5vdGlmeU5lc3RlZFN1YnM6ICgpID0+IHZvaWQsXG4pIHtcbiAgLy8gV2Ugd2FudCB0byBjYXB0dXJlIHRoZSB3cmFwcGVyIHByb3BzIGFuZCBjaGlsZCBwcm9wcyB3ZSB1c2VkIGZvciBsYXRlciBjb21wYXJpc29uc1xuICBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQgPSB3cmFwcGVyUHJvcHNcbiAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IGZhbHNlXG5cbiAgLy8gSWYgdGhlIHJlbmRlciB3YXMgZnJvbSBhIHN0b3JlIHVwZGF0ZSwgY2xlYXIgb3V0IHRoYXQgcmVmZXJlbmNlIGFuZCBjYXNjYWRlIHRoZSBzdWJzY3JpYmVyIHVwZGF0ZVxuICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50KSB7XG4gICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbnVsbFxuICAgIG5vdGlmeU5lc3RlZFN1YnMoKVxuICB9XG59XG5cbi8vIEVmZmVjdCBjYWxsYmFjaywgZXh0cmFjdGVkOiBzdWJzY3JpYmUgdG8gdGhlIFJlZHV4IHN0b3JlIG9yIG5lYXJlc3QgY29ubmVjdGVkIGFuY2VzdG9yLFxuLy8gY2hlY2sgZm9yIHVwZGF0ZXMgYWZ0ZXIgZGlzcGF0Y2hlZCBhY3Rpb25zLCBhbmQgdHJpZ2dlciByZS1yZW5kZXJzLlxuZnVuY3Rpb24gc3Vic2NyaWJlVXBkYXRlcyhcbiAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzOiBib29sZWFuLFxuICBzdG9yZTogU3RvcmUsXG4gIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uLFxuICBjaGlsZFByb3BzU2VsZWN0b3I6IChzdGF0ZTogdW5rbm93biwgcHJvcHM6IHVua25vd24pID0+IHVua25vd24sXG4gIGxhc3RXcmFwcGVyUHJvcHM6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8dW5rbm93bj4sXG4gIGxhc3RDaGlsZFByb3BzOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PHVua25vd24+LFxuICByZW5kZXJJc1NjaGVkdWxlZDogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxib29sZWFuPixcbiAgaXNNb3VudGVkOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PGJvb2xlYW4+LFxuICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PHVua25vd24+LFxuICBub3RpZnlOZXN0ZWRTdWJzOiAoKSA9PiB2b2lkLFxuICAvLyBmb3JjZUNvbXBvbmVudFVwZGF0ZURpc3BhdGNoOiBSZWFjdC5EaXNwYXRjaDxhbnk+LFxuICBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXI6ICgpID0+IHZvaWQsXG4pIHtcbiAgLy8gSWYgd2UncmUgbm90IHN1YnNjcmliZWQgdG8gdGhlIHN0b3JlLCBub3RoaW5nIHRvIGRvIGhlcmVcbiAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybiAoKSA9PiB7fVxuXG4gIC8vIENhcHR1cmUgdmFsdWVzIGZvciBjaGVja2luZyBpZiBhbmQgd2hlbiB0aGlzIGNvbXBvbmVudCB1bm1vdW50c1xuICBsZXQgZGlkVW5zdWJzY3JpYmUgPSBmYWxzZVxuICBsZXQgbGFzdFRocm93bkVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsXG5cbiAgLy8gV2UnbGwgcnVuIHRoaXMgY2FsbGJhY2sgZXZlcnkgdGltZSBhIHN0b3JlIHN1YnNjcmlwdGlvbiB1cGRhdGUgcHJvcGFnYXRlcyB0byB0aGlzIGNvbXBvbmVudFxuICBjb25zdCBjaGVja0ZvclVwZGF0ZXMgPSAoKSA9PiB7XG4gICAgaWYgKGRpZFVuc3Vic2NyaWJlIHx8ICFpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgLy8gRG9uJ3QgcnVuIHN0YWxlIGxpc3RlbmVycy5cbiAgICAgIC8vIFJlZHV4IGRvZXNuJ3QgZ3VhcmFudGVlIHVuc3Vic2NyaXB0aW9ucyBoYXBwZW4gdW50aWwgbmV4dCBkaXNwYXRjaC5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFRPRE8gV2UncmUgY3VycmVudGx5IGNhbGxpbmcgZ2V0U3RhdGUgb3Vyc2VsdmVzIGhlcmUsIHJhdGhlciB0aGFuIGxldHRpbmcgYHVTRVNgIGRvIGl0XG4gICAgY29uc3QgbGF0ZXN0U3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKClcblxuICAgIGxldCBuZXdDaGlsZFByb3BzLCBlcnJvclxuICAgIHRyeSB7XG4gICAgICAvLyBBY3R1YWxseSBydW4gdGhlIHNlbGVjdG9yIHdpdGggdGhlIG1vc3QgcmVjZW50IHN0b3JlIHN0YXRlIGFuZCB3cmFwcGVyIHByb3BzXG4gICAgICAvLyB0byBkZXRlcm1pbmUgd2hhdCB0aGUgY2hpbGQgcHJvcHMgc2hvdWxkIGJlXG4gICAgICBuZXdDaGlsZFByb3BzID0gY2hpbGRQcm9wc1NlbGVjdG9yKFxuICAgICAgICBsYXRlc3RTdG9yZVN0YXRlLFxuICAgICAgICBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQsXG4gICAgICApXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IgPSBlXG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBlIGFzIEVycm9yIHwgbnVsbFxuICAgIH1cblxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IG51bGxcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgY2hpbGQgcHJvcHMgaGF2ZW4ndCBjaGFuZ2VkLCBub3RoaW5nIHRvIGRvIGhlcmUgLSBjYXNjYWRlIHRoZSBzdWJzY3JpcHRpb24gdXBkYXRlXG4gICAgaWYgKG5ld0NoaWxkUHJvcHMgPT09IGxhc3RDaGlsZFByb3BzLmN1cnJlbnQpIHtcbiAgICAgIGlmICghcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCkge1xuICAgICAgICBub3RpZnlOZXN0ZWRTdWJzKClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2F2ZSByZWZlcmVuY2VzIHRvIHRoZSBuZXcgY2hpbGQgcHJvcHMuICBOb3RlIHRoYXQgd2UgdHJhY2sgdGhlIFwiY2hpbGQgcHJvcHMgZnJvbSBzdG9yZSB1cGRhdGVcIlxuICAgICAgLy8gYXMgYSByZWYgaW5zdGVhZCBvZiBhIHVzZVN0YXRlL3VzZVJlZHVjZXIgYmVjYXVzZSB3ZSBuZWVkIGEgd2F5IHRvIGRldGVybWluZSBpZiB0aGF0IHZhbHVlIGhhc1xuICAgICAgLy8gYmVlbiBwcm9jZXNzZWQuICBJZiB0aGlzIHdlbnQgaW50byB1c2VTdGF0ZS91c2VSZWR1Y2VyLCB3ZSBjb3VsZG4ndCBjbGVhciBvdXQgdGhlIHZhbHVlIHdpdGhvdXRcbiAgICAgIC8vIGZvcmNpbmcgYW5vdGhlciByZS1yZW5kZXIsIHdoaWNoIHdlIGRvbid0IHdhbnQuXG4gICAgICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wc1xuICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wc1xuICAgICAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IHRydWVcblxuICAgICAgLy8gVE9ETyBUaGlzIGlzIGhhY2t5IGFuZCBub3QgaG93IGB1U0VTYCBpcyBtZWFudCB0byBiZSB1c2VkXG4gICAgICAvLyBUcmlnZ2VyIHRoZSBSZWFjdCBgdXNlU3luY0V4dGVybmFsU3RvcmVgIHN1YnNjcmliZXJcbiAgICAgIGFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lcigpXG4gICAgfVxuICB9XG5cbiAgLy8gQWN0dWFsbHkgc3Vic2NyaWJlIHRvIHRoZSBuZWFyZXN0IGNvbm5lY3RlZCBhbmNlc3RvciAob3Igc3RvcmUpXG4gIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gY2hlY2tGb3JVcGRhdGVzXG4gIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKVxuXG4gIC8vIFB1bGwgZGF0YSBmcm9tIHRoZSBzdG9yZSBhZnRlciBmaXJzdCByZW5kZXIgaW4gY2FzZSB0aGUgc3RvcmUgaGFzXG4gIC8vIGNoYW5nZWQgc2luY2Ugd2UgYmVnYW4uXG4gIGNoZWNrRm9yVXBkYXRlcygpXG5cbiAgY29uc3QgdW5zdWJzY3JpYmVXcmFwcGVyID0gKCkgPT4ge1xuICAgIGRpZFVuc3Vic2NyaWJlID0gdHJ1ZVxuICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpXG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBudWxsXG5cbiAgICBpZiAobGFzdFRocm93bkVycm9yKSB7XG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgd2UgY2F1Z2h0IGFuIGVycm9yIGR1ZSB0byBhIGJhZCBtYXBTdGF0ZSBmdW5jdGlvbiwgYnV0IHRoZVxuICAgICAgLy8gcGFyZW50IHJlLXJlbmRlcmVkIHdpdGhvdXQgdGhpcyBjb21wb25lbnQgYW5kIHdlJ3JlIGFib3V0IHRvIHVubW91bnQuXG4gICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gYXMgbG9uZyBhcyB3ZSBkbyB0b3AtZG93biBzdWJzY3JpcHRpb25zIGNvcnJlY3RseSwgYnV0XG4gICAgICAvLyBpZiB3ZSBldmVyIGRvIHRob3NlIHdyb25nLCB0aGlzIHRocm93IHdpbGwgc3VyZmFjZSB0aGUgZXJyb3IgaW4gb3VyIHRlc3RzLlxuICAgICAgLy8gSW4gdGhhdCBjYXNlLCB0aHJvdyB0aGUgZXJyb3IgZnJvbSBoZXJlIHNvIGl0IGRvZXNuJ3QgZ2V0IGxvc3QuXG4gICAgICB0aHJvdyBsYXN0VGhyb3duRXJyb3JcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5zdWJzY3JpYmVXcmFwcGVyXG59XG5cbi8vIFJlZHVjZXIgaW5pdGlhbCBzdGF0ZSBjcmVhdGlvbiBmb3Igb3VyIHVwZGF0ZSByZWR1Y2VyXG5jb25zdCBpbml0U3RhdGVVcGRhdGVzID0gKCkgPT4gRU1QVFlfQVJSQVlcblxuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0UHJvcHMge1xuICAvKiogQSBjdXN0b20gQ29udGV4dCBpbnN0YW5jZSB0aGF0IHRoZSBjb21wb25lbnQgY2FuIHVzZSB0byBhY2Nlc3MgdGhlIHN0b3JlIGZyb20gYW4gYWx0ZXJuYXRlIFByb3ZpZGVyIHVzaW5nIHRoYXQgc2FtZSBDb250ZXh0IGluc3RhbmNlICovXG4gIGNvbnRleHQ/OiBSZWFjdFJlZHV4Q29udGV4dEluc3RhbmNlXG4gIC8qKiBBIFJlZHV4IHN0b3JlIGluc3RhbmNlIHRvIGJlIHVzZWQgZm9yIHN1YnNjcmlwdGlvbnMgaW5zdGVhZCBvZiB0aGUgc3RvcmUgZnJvbSBhIFByb3ZpZGVyICovXG4gIHN0b3JlPzogU3RvcmVcbn1cblxuaW50ZXJmYWNlIEludGVybmFsQ29ubmVjdFByb3BzIGV4dGVuZHMgQ29ubmVjdFByb3BzIHtcbiAgcmVhY3RSZWR1eEZvcndhcmRlZFJlZj86IFJlYWN0LkZvcndhcmRlZFJlZjx1bmtub3duPlxufVxuXG5mdW5jdGlvbiBzdHJpY3RFcXVhbChhOiB1bmtub3duLCBiOiB1bmtub3duKSB7XG4gIHJldHVybiBhID09PSBiXG59XG5cbi8qKlxuICogSW5mZXJzIHRoZSB0eXBlIG9mIHByb3BzIHRoYXQgYSBjb25uZWN0b3Igd2lsbCBpbmplY3QgaW50byBhIGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IHR5cGUgQ29ubmVjdGVkUHJvcHM8VENvbm5lY3Rvcj4gPVxuICBUQ29ubmVjdG9yIGV4dGVuZHMgSW5mZXJhYmxlQ29tcG9uZW50RW5oYW5jZXJXaXRoUHJvcHM8XG4gICAgaW5mZXIgVEluamVjdGVkUHJvcHMsXG4gICAgYW55XG4gID5cbiAgICA/IHVua25vd24gZXh0ZW5kcyBUSW5qZWN0ZWRQcm9wc1xuICAgICAgPyBUQ29ubmVjdG9yIGV4dGVuZHMgSW5mZXJhYmxlQ29tcG9uZW50RW5oYW5jZXI8aW5mZXIgVEluamVjdGVkUHJvcHM+XG4gICAgICAgID8gVEluamVjdGVkUHJvcHNcbiAgICAgICAgOiBuZXZlclxuICAgICAgOiBUSW5qZWN0ZWRQcm9wc1xuICAgIDogbmV2ZXJcblxuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0T3B0aW9uczxcbiAgU3RhdGUgPSB1bmtub3duLFxuICBUU3RhdGVQcm9wcyA9IHt9LFxuICBUT3duUHJvcHMgPSB7fSxcbiAgVE1lcmdlZFByb3BzID0ge30sXG4+IHtcbiAgZm9yd2FyZFJlZj86IGJvb2xlYW5cbiAgY29udGV4dD86IHR5cGVvZiBSZWFjdFJlZHV4Q29udGV4dFxuICBhcmVTdGF0ZXNFcXVhbD86IChcbiAgICBuZXh0U3RhdGU6IFN0YXRlLFxuICAgIHByZXZTdGF0ZTogU3RhdGUsXG4gICAgbmV4dE93blByb3BzOiBUT3duUHJvcHMsXG4gICAgcHJldk93blByb3BzOiBUT3duUHJvcHMsXG4gICkgPT4gYm9vbGVhblxuXG4gIGFyZU93blByb3BzRXF1YWw/OiAoXG4gICAgbmV4dE93blByb3BzOiBUT3duUHJvcHMsXG4gICAgcHJldk93blByb3BzOiBUT3duUHJvcHMsXG4gICkgPT4gYm9vbGVhblxuXG4gIGFyZVN0YXRlUHJvcHNFcXVhbD86IChcbiAgICBuZXh0U3RhdGVQcm9wczogVFN0YXRlUHJvcHMsXG4gICAgcHJldlN0YXRlUHJvcHM6IFRTdGF0ZVByb3BzLFxuICApID0+IGJvb2xlYW5cbiAgYXJlTWVyZ2VkUHJvcHNFcXVhbD86IChcbiAgICBuZXh0TWVyZ2VkUHJvcHM6IFRNZXJnZWRQcm9wcyxcbiAgICBwcmV2TWVyZ2VkUHJvcHM6IFRNZXJnZWRQcm9wcyxcbiAgKSA9PiBib29sZWFuXG59XG5cbi8qKlxuICogQ29ubmVjdHMgYSBSZWFjdCBjb21wb25lbnQgdG8gYSBSZWR1eCBzdG9yZS5cbiAqXG4gKiAtIFdpdGhvdXQgYXJndW1lbnRzLCBqdXN0IHdyYXBzIHRoZSBjb21wb25lbnQsIHdpdGhvdXQgY2hhbmdpbmcgdGhlIGJlaGF2aW9yIC8gcHJvcHNcbiAqXG4gKiAtIElmIDIgcGFyYW1zIGFyZSBwYXNzZWQgKDNyZCBwYXJhbSwgbWVyZ2VQcm9wcywgaXMgc2tpcHBlZCksIGRlZmF1bHQgYmVoYXZpb3JcbiAqIGlzIHRvIG92ZXJyaWRlIG93blByb3BzIChhcyBzdGF0ZWQgaW4gdGhlIGRvY3MpLCBzbyB3aGF0IHJlbWFpbnMgaXMgZXZlcnl0aGluZyB0aGF0J3NcbiAqIG5vdCBhIHN0YXRlIG9yIGRpc3BhdGNoIHByb3BcbiAqXG4gKiAtIFdoZW4gM3JkIHBhcmFtIGlzIHBhc3NlZCwgd2UgZG9uJ3Qga25vdyBpZiBvd25Qcm9wcyBwcm9wYWdhdGUgYW5kIHdoZXRoZXIgdGhleVxuICogc2hvdWxkIGJlIHZhbGlkIGNvbXBvbmVudCBwcm9wcywgYmVjYXVzZSBpdCBkZXBlbmRzIG9uIG1lcmdlUHJvcHMgaW1wbGVtZW50YXRpb24uXG4gKiBBcyBzdWNoLCBpdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGV4dGVuZCBvd25Qcm9wcyBpbnRlcmZhY2UgZnJvbSBzdGF0ZSBvclxuICogZGlzcGF0Y2ggcHJvcHMgb3IgYm90aCB3aGVuIGFwcGxpY2FibGVcbiAqXG4gKiBAcGFyYW0gbWFwU3RhdGVUb1Byb3BzXG4gKiBAcGFyYW0gbWFwRGlzcGF0Y2hUb1Byb3BzXG4gKiBAcGFyYW0gbWVyZ2VQcm9wc1xuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0PERlZmF1bHRTdGF0ZSA9IHVua25vd24+IHtcbiAgLy8gdHNsaW50OmRpc2FibGU6bm8tdW5uZWNlc3NhcnktZ2VuZXJpY3NcbiAgKCk6IEluZmVyYWJsZUNvbXBvbmVudEVuaGFuY2VyPERpc3BhdGNoUHJvcD5cblxuICAvKiogbWFwU3RhdGUgb25seSAqL1xuICA8VFN0YXRlUHJvcHMgPSB7fSwgbm9fZGlzcGF0Y2ggPSB7fSwgVE93blByb3BzID0ge30sIFN0YXRlID0gRGVmYXVsdFN0YXRlPihcbiAgICBtYXBTdGF0ZVRvUHJvcHM6IE1hcFN0YXRlVG9Qcm9wc1BhcmFtPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPixcbiAgKTogSW5mZXJhYmxlQ29tcG9uZW50RW5oYW5jZXJXaXRoUHJvcHM8VFN0YXRlUHJvcHMgJiBEaXNwYXRjaFByb3AsIFRPd25Qcm9wcz5cblxuICAvKiogbWFwRGlzcGF0Y2ggb25seSAoYXMgYSBmdW5jdGlvbikgKi9cbiAgPG5vX3N0YXRlID0ge30sIFREaXNwYXRjaFByb3BzID0ge30sIFRPd25Qcm9wcyA9IHt9PihcbiAgICBtYXBTdGF0ZVRvUHJvcHM6IG51bGwgfCB1bmRlZmluZWQsXG4gICAgbWFwRGlzcGF0Y2hUb1Byb3BzOiBNYXBEaXNwYXRjaFRvUHJvcHNOb25PYmplY3Q8VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz4sXG4gICk6IEluZmVyYWJsZUNvbXBvbmVudEVuaGFuY2VyV2l0aFByb3BzPFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+XG5cbiAgLyoqIG1hcERpc3BhdGNoIG9ubHkgKGFzIGFuIG9iamVjdCkgKi9cbiAgPG5vX3N0YXRlID0ge30sIFREaXNwYXRjaFByb3BzID0ge30sIFRPd25Qcm9wcyA9IHt9PihcbiAgICBtYXBTdGF0ZVRvUHJvcHM6IG51bGwgfCB1bmRlZmluZWQsXG4gICAgbWFwRGlzcGF0Y2hUb1Byb3BzOiBNYXBEaXNwYXRjaFRvUHJvcHNQYXJhbTxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPixcbiAgKTogSW5mZXJhYmxlQ29tcG9uZW50RW5oYW5jZXJXaXRoUHJvcHM8XG4gICAgUmVzb2x2ZVRodW5rczxURGlzcGF0Y2hQcm9wcz4sXG4gICAgVE93blByb3BzXG4gID5cblxuICAvKiogbWFwU3RhdGUgYW5kIG1hcERpc3BhdGNoIChhcyBhIGZ1bmN0aW9uKSovXG4gIDxUU3RhdGVQcm9wcyA9IHt9LCBURGlzcGF0Y2hQcm9wcyA9IHt9LCBUT3duUHJvcHMgPSB7fSwgU3RhdGUgPSBEZWZhdWx0U3RhdGU+KFxuICAgIG1hcFN0YXRlVG9Qcm9wczogTWFwU3RhdGVUb1Byb3BzUGFyYW08VFN0YXRlUHJvcHMsIFRPd25Qcm9wcywgU3RhdGU+LFxuICAgIG1hcERpc3BhdGNoVG9Qcm9wczogTWFwRGlzcGF0Y2hUb1Byb3BzTm9uT2JqZWN0PFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+LFxuICApOiBJbmZlcmFibGVDb21wb25lbnRFbmhhbmNlcldpdGhQcm9wczxcbiAgICBUU3RhdGVQcm9wcyAmIFREaXNwYXRjaFByb3BzLFxuICAgIFRPd25Qcm9wc1xuICA+XG5cbiAgLyoqIG1hcFN0YXRlIGFuZCBtYXBEaXNwYXRjaCAobnVsbGlzaCkgKi9cbiAgPFRTdGF0ZVByb3BzID0ge30sIFREaXNwYXRjaFByb3BzID0ge30sIFRPd25Qcm9wcyA9IHt9LCBTdGF0ZSA9IERlZmF1bHRTdGF0ZT4oXG4gICAgbWFwU3RhdGVUb1Byb3BzOiBNYXBTdGF0ZVRvUHJvcHNQYXJhbTxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4sXG4gICAgbWFwRGlzcGF0Y2hUb1Byb3BzOiBudWxsIHwgdW5kZWZpbmVkLFxuICApOiBJbmZlcmFibGVDb21wb25lbnRFbmhhbmNlcldpdGhQcm9wczxUU3RhdGVQcm9wcywgVE93blByb3BzPlxuXG4gIC8qKiBtYXBTdGF0ZSBhbmQgbWFwRGlzcGF0Y2ggKGFzIGFuIG9iamVjdCkgKi9cbiAgPFRTdGF0ZVByb3BzID0ge30sIFREaXNwYXRjaFByb3BzID0ge30sIFRPd25Qcm9wcyA9IHt9LCBTdGF0ZSA9IERlZmF1bHRTdGF0ZT4oXG4gICAgbWFwU3RhdGVUb1Byb3BzOiBNYXBTdGF0ZVRvUHJvcHNQYXJhbTxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4sXG4gICAgbWFwRGlzcGF0Y2hUb1Byb3BzOiBNYXBEaXNwYXRjaFRvUHJvcHNQYXJhbTxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPixcbiAgKTogSW5mZXJhYmxlQ29tcG9uZW50RW5oYW5jZXJXaXRoUHJvcHM8XG4gICAgVFN0YXRlUHJvcHMgJiBSZXNvbHZlVGh1bmtzPFREaXNwYXRjaFByb3BzPixcbiAgICBUT3duUHJvcHNcbiAgPlxuXG4gIC8qKiBtZXJnZVByb3BzIG9ubHkgKi9cbiAgPG5vX3N0YXRlID0ge30sIG5vX2Rpc3BhdGNoID0ge30sIFRPd25Qcm9wcyA9IHt9LCBUTWVyZ2VkUHJvcHMgPSB7fT4oXG4gICAgbWFwU3RhdGVUb1Byb3BzOiBudWxsIHwgdW5kZWZpbmVkLFxuICAgIG1hcERpc3BhdGNoVG9Qcm9wczogbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBtZXJnZVByb3BzOiBNZXJnZVByb3BzPHVuZGVmaW5lZCwgRGlzcGF0Y2hQcm9wLCBUT3duUHJvcHMsIFRNZXJnZWRQcm9wcz4sXG4gICk6IEluZmVyYWJsZUNvbXBvbmVudEVuaGFuY2VyV2l0aFByb3BzPFRNZXJnZWRQcm9wcywgVE93blByb3BzPlxuXG4gIC8qKiBtYXBTdGF0ZSBhbmQgbWVyZ2VQcm9wcyAqL1xuICA8XG4gICAgVFN0YXRlUHJvcHMgPSB7fSxcbiAgICBub19kaXNwYXRjaCA9IHt9LFxuICAgIFRPd25Qcm9wcyA9IHt9LFxuICAgIFRNZXJnZWRQcm9wcyA9IHt9LFxuICAgIFN0YXRlID0gRGVmYXVsdFN0YXRlLFxuICA+KFxuICAgIG1hcFN0YXRlVG9Qcm9wczogTWFwU3RhdGVUb1Byb3BzUGFyYW08VFN0YXRlUHJvcHMsIFRPd25Qcm9wcywgU3RhdGU+LFxuICAgIG1hcERpc3BhdGNoVG9Qcm9wczogbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBtZXJnZVByb3BzOiBNZXJnZVByb3BzPFRTdGF0ZVByb3BzLCBEaXNwYXRjaFByb3AsIFRPd25Qcm9wcywgVE1lcmdlZFByb3BzPixcbiAgKTogSW5mZXJhYmxlQ29tcG9uZW50RW5oYW5jZXJXaXRoUHJvcHM8VE1lcmdlZFByb3BzLCBUT3duUHJvcHM+XG5cbiAgLyoqIG1hcERpc3BhdGNoIChhcyBhIG9iamVjdCkgYW5kIG1lcmdlUHJvcHMgKi9cbiAgPG5vX3N0YXRlID0ge30sIFREaXNwYXRjaFByb3BzID0ge30sIFRPd25Qcm9wcyA9IHt9LCBUTWVyZ2VkUHJvcHMgPSB7fT4oXG4gICAgbWFwU3RhdGVUb1Byb3BzOiBudWxsIHwgdW5kZWZpbmVkLFxuICAgIG1hcERpc3BhdGNoVG9Qcm9wczogTWFwRGlzcGF0Y2hUb1Byb3BzUGFyYW08VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz4sXG4gICAgbWVyZ2VQcm9wczogTWVyZ2VQcm9wczx1bmRlZmluZWQsIFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHMsIFRNZXJnZWRQcm9wcz4sXG4gICk6IEluZmVyYWJsZUNvbXBvbmVudEVuaGFuY2VyV2l0aFByb3BzPFRNZXJnZWRQcm9wcywgVE93blByb3BzPlxuXG4gIC8qKiBtYXBTdGF0ZSBhbmQgb3B0aW9ucyAqL1xuICA8VFN0YXRlUHJvcHMgPSB7fSwgbm9fZGlzcGF0Y2ggPSB7fSwgVE93blByb3BzID0ge30sIFN0YXRlID0gRGVmYXVsdFN0YXRlPihcbiAgICBtYXBTdGF0ZVRvUHJvcHM6IE1hcFN0YXRlVG9Qcm9wc1BhcmFtPFRTdGF0ZVByb3BzLCBUT3duUHJvcHMsIFN0YXRlPixcbiAgICBtYXBEaXNwYXRjaFRvUHJvcHM6IG51bGwgfCB1bmRlZmluZWQsXG4gICAgbWVyZ2VQcm9wczogbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBvcHRpb25zOiBDb25uZWN0T3B0aW9uczxTdGF0ZSwgVFN0YXRlUHJvcHMsIFRPd25Qcm9wcz4sXG4gICk6IEluZmVyYWJsZUNvbXBvbmVudEVuaGFuY2VyV2l0aFByb3BzPERpc3BhdGNoUHJvcCAmIFRTdGF0ZVByb3BzLCBUT3duUHJvcHM+XG5cbiAgLyoqIG1hcERpc3BhdGNoIChhcyBhIGZ1bmN0aW9uKSBhbmQgb3B0aW9ucyAqL1xuICA8VFN0YXRlUHJvcHMgPSB7fSwgVERpc3BhdGNoUHJvcHMgPSB7fSwgVE93blByb3BzID0ge30+KFxuICAgIG1hcFN0YXRlVG9Qcm9wczogbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBtYXBEaXNwYXRjaFRvUHJvcHM6IE1hcERpc3BhdGNoVG9Qcm9wc05vbk9iamVjdDxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPixcbiAgICBtZXJnZVByb3BzOiBudWxsIHwgdW5kZWZpbmVkLFxuICAgIG9wdGlvbnM6IENvbm5lY3RPcHRpb25zPHt9LCBUU3RhdGVQcm9wcywgVE93blByb3BzPixcbiAgKTogSW5mZXJhYmxlQ29tcG9uZW50RW5oYW5jZXJXaXRoUHJvcHM8VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz5cblxuICAvKiogbWFwRGlzcGF0Y2ggKGFzIGFuIG9iamVjdCkgYW5kIG9wdGlvbnMqL1xuICA8VFN0YXRlUHJvcHMgPSB7fSwgVERpc3BhdGNoUHJvcHMgPSB7fSwgVE93blByb3BzID0ge30+KFxuICAgIG1hcFN0YXRlVG9Qcm9wczogbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBtYXBEaXNwYXRjaFRvUHJvcHM6IE1hcERpc3BhdGNoVG9Qcm9wc1BhcmFtPFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+LFxuICAgIG1lcmdlUHJvcHM6IG51bGwgfCB1bmRlZmluZWQsXG4gICAgb3B0aW9uczogQ29ubmVjdE9wdGlvbnM8e30sIFRTdGF0ZVByb3BzLCBUT3duUHJvcHM+LFxuICApOiBJbmZlcmFibGVDb21wb25lbnRFbmhhbmNlcldpdGhQcm9wczxcbiAgICBSZXNvbHZlVGh1bmtzPFREaXNwYXRjaFByb3BzPixcbiAgICBUT3duUHJvcHNcbiAgPlxuXG4gIC8qKiBtYXBTdGF0ZSwgIG1hcERpc3BhdGNoIChhcyBhIGZ1bmN0aW9uKSwgYW5kIG9wdGlvbnMgKi9cbiAgPFRTdGF0ZVByb3BzID0ge30sIFREaXNwYXRjaFByb3BzID0ge30sIFRPd25Qcm9wcyA9IHt9LCBTdGF0ZSA9IERlZmF1bHRTdGF0ZT4oXG4gICAgbWFwU3RhdGVUb1Byb3BzOiBNYXBTdGF0ZVRvUHJvcHNQYXJhbTxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4sXG4gICAgbWFwRGlzcGF0Y2hUb1Byb3BzOiBNYXBEaXNwYXRjaFRvUHJvcHNOb25PYmplY3Q8VERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcz4sXG4gICAgbWVyZ2VQcm9wczogbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBvcHRpb25zOiBDb25uZWN0T3B0aW9uczxTdGF0ZSwgVFN0YXRlUHJvcHMsIFRPd25Qcm9wcz4sXG4gICk6IEluZmVyYWJsZUNvbXBvbmVudEVuaGFuY2VyV2l0aFByb3BzPFxuICAgIFRTdGF0ZVByb3BzICYgVERpc3BhdGNoUHJvcHMsXG4gICAgVE93blByb3BzXG4gID5cblxuICAvKiogbWFwU3RhdGUsICBtYXBEaXNwYXRjaCAoYXMgYW4gb2JqZWN0KSwgYW5kIG9wdGlvbnMgKi9cbiAgPFRTdGF0ZVByb3BzID0ge30sIFREaXNwYXRjaFByb3BzID0ge30sIFRPd25Qcm9wcyA9IHt9LCBTdGF0ZSA9IERlZmF1bHRTdGF0ZT4oXG4gICAgbWFwU3RhdGVUb1Byb3BzOiBNYXBTdGF0ZVRvUHJvcHNQYXJhbTxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4sXG4gICAgbWFwRGlzcGF0Y2hUb1Byb3BzOiBNYXBEaXNwYXRjaFRvUHJvcHNQYXJhbTxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPixcbiAgICBtZXJnZVByb3BzOiBudWxsIHwgdW5kZWZpbmVkLFxuICAgIG9wdGlvbnM6IENvbm5lY3RPcHRpb25zPFN0YXRlLCBUU3RhdGVQcm9wcywgVE93blByb3BzPixcbiAgKTogSW5mZXJhYmxlQ29tcG9uZW50RW5oYW5jZXJXaXRoUHJvcHM8XG4gICAgVFN0YXRlUHJvcHMgJiBSZXNvbHZlVGh1bmtzPFREaXNwYXRjaFByb3BzPixcbiAgICBUT3duUHJvcHNcbiAgPlxuXG4gIC8qKiBtYXBTdGF0ZSwgbWFwRGlzcGF0Y2gsIG1lcmdlUHJvcHMsIGFuZCBvcHRpb25zICovXG4gIDxcbiAgICBUU3RhdGVQcm9wcyA9IHt9LFxuICAgIFREaXNwYXRjaFByb3BzID0ge30sXG4gICAgVE93blByb3BzID0ge30sXG4gICAgVE1lcmdlZFByb3BzID0ge30sXG4gICAgU3RhdGUgPSBEZWZhdWx0U3RhdGUsXG4gID4oXG4gICAgbWFwU3RhdGVUb1Byb3BzOiBNYXBTdGF0ZVRvUHJvcHNQYXJhbTxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4sXG4gICAgbWFwRGlzcGF0Y2hUb1Byb3BzOiBNYXBEaXNwYXRjaFRvUHJvcHNQYXJhbTxURGlzcGF0Y2hQcm9wcywgVE93blByb3BzPixcbiAgICBtZXJnZVByb3BzOiBNZXJnZVByb3BzPFxuICAgICAgVFN0YXRlUHJvcHMsXG4gICAgICBURGlzcGF0Y2hQcm9wcyxcbiAgICAgIFRPd25Qcm9wcyxcbiAgICAgIFRNZXJnZWRQcm9wc1xuICAgID4sXG4gICAgb3B0aW9ucz86IENvbm5lY3RPcHRpb25zPFN0YXRlLCBUU3RhdGVQcm9wcywgVE93blByb3BzLCBUTWVyZ2VkUHJvcHM+LFxuICApOiBJbmZlcmFibGVDb21wb25lbnRFbmhhbmNlcldpdGhQcm9wczxUTWVyZ2VkUHJvcHMsIFRPd25Qcm9wcz5cbiAgLy8gdHNsaW50OmVuYWJsZTpuby11bm5lY2Vzc2FyeS1nZW5lcmljc1xufVxuXG5sZXQgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbiA9IGZhbHNlXG5cbi8qKlxuICogQ29ubmVjdHMgYSBSZWFjdCBjb21wb25lbnQgdG8gYSBSZWR1eCBzdG9yZS5cbiAqXG4gKiAtIFdpdGhvdXQgYXJndW1lbnRzLCBqdXN0IHdyYXBzIHRoZSBjb21wb25lbnQsIHdpdGhvdXQgY2hhbmdpbmcgdGhlIGJlaGF2aW9yIC8gcHJvcHNcbiAqXG4gKiAtIElmIDIgcGFyYW1zIGFyZSBwYXNzZWQgKDNyZCBwYXJhbSwgbWVyZ2VQcm9wcywgaXMgc2tpcHBlZCksIGRlZmF1bHQgYmVoYXZpb3JcbiAqIGlzIHRvIG92ZXJyaWRlIG93blByb3BzIChhcyBzdGF0ZWQgaW4gdGhlIGRvY3MpLCBzbyB3aGF0IHJlbWFpbnMgaXMgZXZlcnl0aGluZyB0aGF0J3NcbiAqIG5vdCBhIHN0YXRlIG9yIGRpc3BhdGNoIHByb3BcbiAqXG4gKiAtIFdoZW4gM3JkIHBhcmFtIGlzIHBhc3NlZCwgd2UgZG9uJ3Qga25vdyBpZiBvd25Qcm9wcyBwcm9wYWdhdGUgYW5kIHdoZXRoZXIgdGhleVxuICogc2hvdWxkIGJlIHZhbGlkIGNvbXBvbmVudCBwcm9wcywgYmVjYXVzZSBpdCBkZXBlbmRzIG9uIG1lcmdlUHJvcHMgaW1wbGVtZW50YXRpb24uXG4gKiBBcyBzdWNoLCBpdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGV4dGVuZCBvd25Qcm9wcyBpbnRlcmZhY2UgZnJvbSBzdGF0ZSBvclxuICogZGlzcGF0Y2ggcHJvcHMgb3IgYm90aCB3aGVuIGFwcGxpY2FibGVcbiAqXG4gKiBAcGFyYW0gbWFwU3RhdGVUb1Byb3BzIEEgZnVuY3Rpb24gdGhhdCBleHRyYWN0cyB2YWx1ZXMgZnJvbSBzdGF0ZVxuICogQHBhcmFtIG1hcERpc3BhdGNoVG9Qcm9wcyBTZXR1cCBmb3IgZGlzcGF0Y2hpbmcgYWN0aW9uc1xuICogQHBhcmFtIG1lcmdlUHJvcHMgT3B0aW9uYWwgY2FsbGJhY2sgdG8gbWVyZ2Ugc3RhdGUgYW5kIGRpc3BhdGNoIHByb3BzIHRvZ2V0aGVyXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciBjb25maWd1cmluZyB0aGUgY29ubmVjdGlvblxuICpcbiAqL1xuZnVuY3Rpb24gY29ubmVjdDxcbiAgVFN0YXRlUHJvcHMgPSB7fSxcbiAgVERpc3BhdGNoUHJvcHMgPSB7fSxcbiAgVE93blByb3BzID0ge30sXG4gIFRNZXJnZWRQcm9wcyA9IHt9LFxuICBTdGF0ZSA9IHVua25vd24sXG4+KFxuICBtYXBTdGF0ZVRvUHJvcHM/OiBNYXBTdGF0ZVRvUHJvcHNQYXJhbTxUU3RhdGVQcm9wcywgVE93blByb3BzLCBTdGF0ZT4sXG4gIG1hcERpc3BhdGNoVG9Qcm9wcz86IE1hcERpc3BhdGNoVG9Qcm9wc1BhcmFtPFREaXNwYXRjaFByb3BzLCBUT3duUHJvcHM+LFxuICBtZXJnZVByb3BzPzogTWVyZ2VQcm9wczxUU3RhdGVQcm9wcywgVERpc3BhdGNoUHJvcHMsIFRPd25Qcm9wcywgVE1lcmdlZFByb3BzPixcbiAge1xuICAgIC8vIFRoZSBgcHVyZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQsIHNvIFRTIGRvZXNuJ3QgbGlrZSB1cyBkZXN0cnVjdHVyaW5nIHRoaXMgdG8gY2hlY2sgaXRzIGV4aXN0ZW5jZS5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcHVyZSxcbiAgICBhcmVTdGF0ZXNFcXVhbCA9IHN0cmljdEVxdWFsLFxuICAgIGFyZU93blByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gICAgYXJlU3RhdGVQcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICAgIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG5cbiAgICAvLyB1c2UgUmVhY3QncyBmb3J3YXJkUmVmIHRvIGV4cG9zZSBhIHJlZiBvZiB0aGUgd3JhcHBlZCBjb21wb25lbnRcbiAgICBmb3J3YXJkUmVmID0gZmFsc2UsXG5cbiAgICAvLyB0aGUgY29udGV4dCBjb25zdW1lciB0byB1c2VcbiAgICBjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQsXG4gIH06IENvbm5lY3RPcHRpb25zPHVua25vd24sIHVua25vd24sIHVua25vd24sIHVua25vd24+ID0ge30sXG4pOiB1bmtub3duIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAocHVyZSAhPT0gdW5kZWZpbmVkICYmICFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uID0gdHJ1ZVxuICAgICAgd2FybmluZyhcbiAgICAgICAgJ1RoZSBgcHVyZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQuIGBjb25uZWN0YCBpcyBub3cgYWx3YXlzIGEgXCJwdXJlL21lbW9pemVkXCIgY29tcG9uZW50JyxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBjb25zdCBDb250ZXh0ID0gY29udGV4dFxuXG4gIGNvbnN0IGluaXRNYXBTdGF0ZVRvUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcylcbiAgY29uc3QgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzKVxuICBjb25zdCBpbml0TWVyZ2VQcm9wcyA9IG1lcmdlUHJvcHNGYWN0b3J5KG1lcmdlUHJvcHMpXG5cbiAgY29uc3Qgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzID0gQm9vbGVhbihtYXBTdGF0ZVRvUHJvcHMpXG5cbiAgY29uc3Qgd3JhcFdpdGhDb25uZWN0ID0gPFRQcm9wcyw+KFxuICAgIFdyYXBwZWRDb21wb25lbnQ6IENvbXBvbmVudFR5cGU8VFByb3BzPixcbiAgKSA9PiB7XG4gICAgdHlwZSBXcmFwcGVkQ29tcG9uZW50UHJvcHMgPSBUUHJvcHMgJlxuICAgICAgQ29ubmVjdFByb3BzTWF5YmVXaXRob3V0Q29udGV4dDxUUHJvcHM+XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc3QgaXNWYWxpZCA9IC8qI19fUFVSRV9fKi8gaXNWYWxpZEVsZW1lbnRUeXBlKFdyYXBwZWRDb21wb25lbnQpXG4gICAgICBpZiAoIWlzVmFsaWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgWW91IG11c3QgcGFzcyBhIGNvbXBvbmVudCB0byB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgY29ubmVjdC4gSW5zdGVhZCByZWNlaXZlZCAke3N0cmluZ2lmeUNvbXBvbmVudChcbiAgICAgICAgICAgIFdyYXBwZWRDb21wb25lbnQsXG4gICAgICAgICAgKX1gLFxuICAgICAgICApXG4gICAgfVxuXG4gICAgY29uc3Qgd3JhcHBlZENvbXBvbmVudE5hbWUgPVxuICAgICAgV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCdcblxuICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gYENvbm5lY3QoJHt3cmFwcGVkQ29tcG9uZW50TmFtZX0pYFxuXG4gICAgY29uc3Qgc2VsZWN0b3JGYWN0b3J5T3B0aW9uczogU2VsZWN0b3JGYWN0b3J5T3B0aW9uczxcbiAgICAgIGFueSxcbiAgICAgIGFueSxcbiAgICAgIGFueSxcbiAgICAgIGFueSxcbiAgICAgIFN0YXRlXG4gICAgPiA9IHtcbiAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgd3JhcHBlZENvbXBvbmVudE5hbWUsXG4gICAgICBXcmFwcGVkQ29tcG9uZW50LFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgICBpbml0TWVyZ2VQcm9wcyxcbiAgICAgIGFyZVN0YXRlc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsLFxuICAgICAgYXJlT3duUHJvcHNFcXVhbCxcbiAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWwsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ29ubmVjdEZ1bmN0aW9uPFRPd25Qcm9wcz4oXG4gICAgICBwcm9wczogSW50ZXJuYWxDb25uZWN0UHJvcHMgJiBUT3duUHJvcHMsXG4gICAgKSB7XG4gICAgICBjb25zdCBbcHJvcHNDb250ZXh0LCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCB3cmFwcGVyUHJvcHNdID1cbiAgICAgICAgUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgICAgLy8gRGlzdGluZ3Vpc2ggYmV0d2VlbiBhY3R1YWwgXCJkYXRhXCIgcHJvcHMgdGhhdCB3ZXJlIHBhc3NlZCB0byB0aGUgd3JhcHBlciBjb21wb25lbnQsXG4gICAgICAgICAgLy8gYW5kIHZhbHVlcyBuZWVkZWQgdG8gY29udHJvbCBiZWhhdmlvciAoZm9yd2FyZGVkIHJlZnMsIGFsdGVybmF0ZSBjb250ZXh0IGluc3RhbmNlcykuXG4gICAgICAgICAgLy8gVG8gbWFpbnRhaW4gdGhlIHdyYXBwZXJQcm9wcyBvYmplY3QgcmVmZXJlbmNlLCBtZW1vaXplIHRoaXMgZGVzdHJ1Y3R1cmluZy5cbiAgICAgICAgICBjb25zdCB7IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIC4uLndyYXBwZXJQcm9wcyB9ID0gcHJvcHNcbiAgICAgICAgICByZXR1cm4gW3Byb3BzLmNvbnRleHQsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIHdyYXBwZXJQcm9wc11cbiAgICAgICAgfSwgW3Byb3BzXSlcblxuICAgICAgY29uc3QgQ29udGV4dFRvVXNlOiBSZWFjdFJlZHV4Q29udGV4dEluc3RhbmNlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIC8vIFVzZXJzIG1heSBvcHRpb25hbGx5IHBhc3MgaW4gYSBjdXN0b20gY29udGV4dCBpbnN0YW5jZSB0byB1c2UgaW5zdGVhZCBvZiBvdXIgUmVhY3RSZWR1eENvbnRleHQuXG4gICAgICAgIC8vIE1lbW9pemUgdGhlIGNoZWNrIHRoYXQgZGV0ZXJtaW5lcyB3aGljaCBjb250ZXh0IGluc3RhbmNlIHdlIHNob3VsZCB1c2UuXG4gICAgICAgIGxldCBSZXN1bHRDb250ZXh0ID0gQ29udGV4dFxuICAgICAgICBpZiAocHJvcHNDb250ZXh0Py5Db25zdW1lcikge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gLyojX19QVVJFX18qLyBpc0NvbnRleHRDb25zdW1lcihcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICA8cHJvcHNDb250ZXh0LkNvbnN1bWVyIC8+LFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnWW91IG11c3QgcGFzcyBhIHZhbGlkIFJlYWN0IGNvbnRleHQgY29uc3VtZXIgYXMgYHByb3BzLmNvbnRleHRgJyxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVzdWx0Q29udGV4dCA9IHByb3BzQ29udGV4dFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVzdWx0Q29udGV4dFxuICAgICAgfSwgW3Byb3BzQ29udGV4dCwgQ29udGV4dF0pXG5cbiAgICAgIC8vIFJldHJpZXZlIHRoZSBzdG9yZSBhbmQgYW5jZXN0b3Igc3Vic2NyaXB0aW9uIHZpYSBjb250ZXh0LCBpZiBhdmFpbGFibGVcbiAgICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dFRvVXNlKVxuXG4gICAgICAvLyBUaGUgc3RvcmUgX211c3RfIGV4aXN0IGFzIGVpdGhlciBhIHByb3Agb3IgaW4gY29udGV4dC5cbiAgICAgIC8vIFdlJ2xsIGNoZWNrIHRvIHNlZSBpZiBpdCBfbG9va3NfIGxpa2UgYSBSZWR1eCBzdG9yZSBmaXJzdC5cbiAgICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHBhc3MgdGhyb3VnaCBhIGBzdG9yZWAgcHJvcCB0aGF0IGlzIGp1c3QgYSBwbGFpbiB2YWx1ZS5cbiAgICAgIGNvbnN0IGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA9XG4gICAgICAgIEJvb2xlYW4ocHJvcHMuc3RvcmUpICYmXG4gICAgICAgIEJvb2xlYW4ocHJvcHMuc3RvcmUhLmdldFN0YXRlKSAmJlxuICAgICAgICBCb29sZWFuKHByb3BzLnN0b3JlIS5kaXNwYXRjaClcbiAgICAgIGNvbnN0IGRpZFN0b3JlQ29tZUZyb21Db250ZXh0ID1cbiAgICAgICAgQm9vbGVhbihjb250ZXh0VmFsdWUpICYmIEJvb2xlYW4oY29udGV4dFZhbHVlIS5zdG9yZSlcblxuICAgICAgaWYgKFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICFkaWRTdG9yZUNvbWVGcm9tUHJvcHMgJiZcbiAgICAgICAgIWRpZFN0b3JlQ29tZUZyb21Db250ZXh0XG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDb3VsZCBub3QgZmluZCBcInN0b3JlXCIgaW4gdGhlIGNvbnRleHQgb2YgYCArXG4gICAgICAgICAgICBgXCIke2Rpc3BsYXlOYW1lfVwiLiBFaXRoZXIgd3JhcCB0aGUgcm9vdCBjb21wb25lbnQgaW4gYSA8UHJvdmlkZXI+LCBgICtcbiAgICAgICAgICAgIGBvciBwYXNzIGEgY3VzdG9tIFJlYWN0IGNvbnRleHQgcHJvdmlkZXIgdG8gPFByb3ZpZGVyPiBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgYCArXG4gICAgICAgICAgICBgUmVhY3QgY29udGV4dCBjb25zdW1lciB0byAke2Rpc3BsYXlOYW1lfSBpbiBjb25uZWN0IG9wdGlvbnMuYCxcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBCYXNlZCBvbiB0aGUgcHJldmlvdXMgY2hlY2ssIG9uZSBvZiB0aGVzZSBtdXN0IGJlIHRydWVcbiAgICAgIGNvbnN0IHN0b3JlOiBTdG9yZSA9IGRpZFN0b3JlQ29tZUZyb21Qcm9wc1xuICAgICAgICA/IHByb3BzLnN0b3JlIVxuICAgICAgICA6IGNvbnRleHRWYWx1ZSEuc3RvcmVcblxuICAgICAgY29uc3QgZ2V0U2VydmVyU3RhdGUgPSBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dFxuICAgICAgICA/IGNvbnRleHRWYWx1ZSEuZ2V0U2VydmVyU3RhdGVcbiAgICAgICAgOiBzdG9yZS5nZXRTdGF0ZVxuXG4gICAgICBjb25zdCBjaGlsZFByb3BzU2VsZWN0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgLy8gVGhlIGNoaWxkIHByb3BzIHNlbGVjdG9yIG5lZWRzIHRoZSBzdG9yZSByZWZlcmVuY2UgYXMgYW4gaW5wdXQuXG4gICAgICAgIC8vIFJlLWNyZWF0ZSB0aGlzIHNlbGVjdG9yIHdoZW5ldmVyIHRoZSBzdG9yZSBjaGFuZ2VzLlxuICAgICAgICByZXR1cm4gZGVmYXVsdFNlbGVjdG9yRmFjdG9yeShzdG9yZS5kaXNwYXRjaCwgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucylcbiAgICAgIH0sIFtzdG9yZV0pXG5cbiAgICAgIGNvbnN0IFtzdWJzY3JpcHRpb24sIG5vdGlmeU5lc3RlZFN1YnNdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSByZXR1cm4gTk9fU1VCU0NSSVBUSU9OX0FSUkFZXG5cbiAgICAgICAgLy8gVGhpcyBTdWJzY3JpcHRpb24ncyBzb3VyY2Ugc2hvdWxkIG1hdGNoIHdoZXJlIHN0b3JlIGNhbWUgZnJvbTogcHJvcHMgdnMuIGNvbnRleHQuIEEgY29tcG9uZW50XG4gICAgICAgIC8vIGNvbm5lY3RlZCB0byB0aGUgc3RvcmUgdmlhIHByb3BzIHNob3VsZG4ndCB1c2Ugc3Vic2NyaXB0aW9uIGZyb20gY29udGV4dCwgb3IgdmljZSB2ZXJzYS5cbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gY3JlYXRlU3Vic2NyaXB0aW9uKFxuICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgIGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IHVuZGVmaW5lZCA6IGNvbnRleHRWYWx1ZSEuc3Vic2NyaXB0aW9uLFxuICAgICAgICApXG5cbiAgICAgICAgLy8gYG5vdGlmeU5lc3RlZFN1YnNgIGlzIGR1cGxpY2F0ZWQgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGluXG4gICAgICAgIC8vIHRoZSBtaWRkbGUgb2YgdGhlIG5vdGlmaWNhdGlvbiBsb29wLCB3aGVyZSBgc3Vic2NyaXB0aW9uYCB3aWxsIHRoZW4gYmUgbnVsbC4gVGhpcyBjYW5cbiAgICAgICAgLy8gcHJvYmFibHkgYmUgYXZvaWRlZCBpZiBTdWJzY3JpcHRpb24ncyBsaXN0ZW5lcnMgbG9naWMgaXMgY2hhbmdlZCB0byBub3QgY2FsbCBsaXN0ZW5lcnNcbiAgICAgICAgLy8gdGhhdCBoYXZlIGJlZW4gdW5zdWJzY3JpYmVkIGluIHRoZSAgbWlkZGxlIG9mIHRoZSBub3RpZmljYXRpb24gbG9vcC5cbiAgICAgICAgY29uc3Qgbm90aWZ5TmVzdGVkU3VicyA9XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnMuYmluZChzdWJzY3JpcHRpb24pXG5cbiAgICAgICAgcmV0dXJuIFtzdWJzY3JpcHRpb24sIG5vdGlmeU5lc3RlZFN1YnNdXG4gICAgICB9LCBbc3RvcmUsIGRpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlXSlcblxuICAgICAgLy8gRGV0ZXJtaW5lIHdoYXQge3N0b3JlLCBzdWJzY3JpcHRpb259IHZhbHVlIHNob3VsZCBiZSBwdXQgaW50byBuZXN0ZWQgY29udGV4dCwgaWYgbmVjZXNzYXJ5LFxuICAgICAgLy8gYW5kIG1lbW9pemUgdGhhdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjb250ZXh0IHVwZGF0ZXMuXG4gICAgICBjb25zdCBvdmVycmlkZGVuQ29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChkaWRTdG9yZUNvbWVGcm9tUHJvcHMpIHtcbiAgICAgICAgICAvLyBUaGlzIGNvbXBvbmVudCBpcyBkaXJlY3RseSBzdWJzY3JpYmVkIHRvIGEgc3RvcmUgZnJvbSBwcm9wcy5cbiAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IGRlc2NlbmRhbnRzIHJlYWRpbmcgZnJvbSB0aGlzIHN0b3JlIC0gcGFzcyBkb3duIHdoYXRldmVyXG4gICAgICAgICAgLy8gdGhlIGV4aXN0aW5nIGNvbnRleHQgdmFsdWUgaXMgZnJvbSB0aGUgbmVhcmVzdCBjb25uZWN0ZWQgYW5jZXN0b3IuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHRWYWx1ZSFcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgcHV0IHRoaXMgY29tcG9uZW50J3Mgc3Vic2NyaXB0aW9uIGluc3RhbmNlIGludG8gY29udGV4dCwgc28gdGhhdFxuICAgICAgICAvLyBjb25uZWN0ZWQgZGVzY2VuZGFudHMgd29uJ3QgdXBkYXRlIHVudGlsIGFmdGVyIHRoaXMgY29tcG9uZW50IGlzIGRvbmVcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5jb250ZXh0VmFsdWUsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgICB9IGFzIFJlYWN0UmVkdXhDb250ZXh0VmFsdWVcbiAgICAgIH0sIFtkaWRTdG9yZUNvbWVGcm9tUHJvcHMsIGNvbnRleHRWYWx1ZSwgc3Vic2NyaXB0aW9uXSlcblxuICAgICAgLy8gU2V0IHVwIHJlZnMgdG8gY29vcmRpbmF0ZSB2YWx1ZXMgYmV0d2VlbiB0aGUgc3Vic2NyaXB0aW9uIGVmZmVjdCBhbmQgdGhlIHJlbmRlciBsb2dpY1xuICAgICAgY29uc3QgbGFzdENoaWxkUHJvcHMgPSBSZWFjdC51c2VSZWY8dW5rbm93bj4odW5kZWZpbmVkKVxuICAgICAgY29uc3QgbGFzdFdyYXBwZXJQcm9wcyA9IFJlYWN0LnVzZVJlZih3cmFwcGVyUHJvcHMpXG4gICAgICBjb25zdCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlID0gUmVhY3QudXNlUmVmPHVua25vd24+KHVuZGVmaW5lZClcbiAgICAgIGNvbnN0IHJlbmRlcklzU2NoZWR1bGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKVxuICAgICAgY29uc3QgaXNNb3VudGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKVxuXG4gICAgICAvLyBUT0RPOiBDaGFuZ2UgdGhpcyB0byBgUmVhY3QudXNlUmVmPEVycm9yPih1bmRlZmluZWQpYCBhZnRlciB1cGdyYWRpbmcgdG8gUmVhY3QgMTkuXG4gICAgICAvKipcbiAgICAgICAqIEB0b2RvIENoYW5nZSB0aGlzIHRvIGBSZWFjdC51c2VSZWY8RXJyb3I+KHVuZGVmaW5lZClgIGFmdGVyIHVwZ3JhZGluZyB0byBSZWFjdCAxOS5cbiAgICAgICAqL1xuICAgICAgY29uc3QgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciA9IFJlYWN0LnVzZVJlZjxFcnJvciB8IHVuZGVmaW5lZD4oXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgIClcblxuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSwgW10pXG5cbiAgICAgIGNvbnN0IGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9ICgpID0+IHtcbiAgICAgICAgICAvLyBUcmlja3kgbG9naWMgaGVyZTpcbiAgICAgICAgICAvLyAtIFRoaXMgcmVuZGVyIG1heSBoYXZlIGJlZW4gdHJpZ2dlcmVkIGJ5IGEgUmVkdXggc3RvcmUgdXBkYXRlIHRoYXQgcHJvZHVjZWQgbmV3IGNoaWxkIHByb3BzXG4gICAgICAgICAgLy8gLSBIb3dldmVyLCB3ZSBtYXkgaGF2ZSBnb3R0ZW4gbmV3IHdyYXBwZXIgcHJvcHMgYWZ0ZXIgdGhhdFxuICAgICAgICAgIC8vIElmIHdlIGhhdmUgbmV3IGNoaWxkIHByb3BzLCBhbmQgdGhlIHNhbWUgd3JhcHBlciBwcm9wcywgd2Uga25vdyB3ZSBzaG91bGQgdXNlIHRoZSBuZXcgY2hpbGQgcHJvcHMgYXMtaXMuXG4gICAgICAgICAgLy8gQnV0LCBpZiB3ZSBoYXZlIG5ldyB3cmFwcGVyIHByb3BzLCB0aG9zZSBtaWdodCBjaGFuZ2UgdGhlIGNoaWxkIHByb3BzLCBzbyB3ZSBoYXZlIHRvIHJlY2FsY3VsYXRlIHRoaW5ncy5cbiAgICAgICAgICAvLyBTbywgd2UnbGwgdXNlIHRoZSBjaGlsZCBwcm9wcyBmcm9tIHN0b3JlIHVwZGF0ZSBvbmx5IGlmIHRoZSB3cmFwcGVyIHByb3BzIGFyZSB0aGUgc2FtZSBhcyBsYXN0IHRpbWUuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ICYmXG4gICAgICAgICAgICB3cmFwcGVyUHJvcHMgPT09IGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRPRE8gV2UncmUgcmVhZGluZyB0aGUgc3RvcmUgZGlyZWN0bHkgaW4gcmVuZGVyKCkgaGVyZS4gQmFkIGlkZWE/XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIGxpa2VseSBjYXVzZSBCYWQgVGhpbmdzIChUTSkgdG8gaGFwcGVuIGluIENvbmN1cnJlbnQgTW9kZS5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgd2UgZG8gdGhpcyBiZWNhdXNlIG9uIHJlbmRlcnMgX25vdF8gY2F1c2VkIGJ5IHN0b3JlIHVwZGF0ZXMsIHdlIG5lZWQgdGhlIGxhdGVzdCBzdG9yZSBzdGF0ZVxuICAgICAgICAgIC8vIHRvIGRldGVybWluZSB3aGF0IHRoZSBjaGlsZCBwcm9wcyBzaG91bGQgYmUuXG4gICAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNTZWxlY3RvcihzdG9yZS5nZXRTdGF0ZSgpLCB3cmFwcGVyUHJvcHMpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yXG4gICAgICB9LCBbc3RvcmUsIHdyYXBwZXJQcm9wc10pXG5cbiAgICAgIC8vIFdlIG5lZWQgdGhpcyB0byBleGVjdXRlIHN5bmNocm9ub3VzbHkgZXZlcnkgdGltZSB3ZSByZS1yZW5kZXIuIEhvd2V2ZXIsIFJlYWN0IHdhcm5zXG4gICAgICAvLyBhYm91dCB1c2VMYXlvdXRFZmZlY3QgaW4gU1NSLCBzbyB3ZSB0cnkgdG8gZGV0ZWN0IGVudmlyb25tZW50IGFuZCBmYWxsIGJhY2sgdG9cbiAgICAgIC8vIGp1c3QgdXNlRWZmZWN0IGluc3RlYWQgdG8gYXZvaWQgdGhlIHdhcm5pbmcsIHNpbmNlIG5laXRoZXIgd2lsbCBydW4gYW55d2F5LlxuXG4gICAgICBjb25zdCBzdWJzY3JpYmVGb3JSZWFjdCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmUgPSAocmVhY3RMaXN0ZW5lcjogKCkgPT4gdm9pZCkgPT4ge1xuICAgICAgICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlVXBkYXRlcyhcbiAgICAgICAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2hpbGRQcm9wc1NlbGVjdG9yLFxuICAgICAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcbiAgICAgICAgICAgIGxhc3RDaGlsZFByb3BzLFxuICAgICAgICAgICAgcmVuZGVySXNTY2hlZHVsZWQsXG4gICAgICAgICAgICBpc01vdW50ZWQsXG4gICAgICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLFxuICAgICAgICAgICAgbm90aWZ5TmVzdGVkU3VicyxcbiAgICAgICAgICAgIHJlYWN0TGlzdGVuZXIsXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVxuICAgICAgfSwgW3N1YnNjcmlwdGlvbl0pXG5cbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyhjYXB0dXJlV3JhcHBlclByb3BzLCBbXG4gICAgICAgIGxhc3RXcmFwcGVyUHJvcHMsXG4gICAgICAgIGxhc3RDaGlsZFByb3BzLFxuICAgICAgICByZW5kZXJJc1NjaGVkdWxlZCxcbiAgICAgICAgd3JhcHBlclByb3BzLFxuICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLFxuICAgICAgICBub3RpZnlOZXN0ZWRTdWJzLFxuICAgICAgXSlcblxuICAgICAgbGV0IGFjdHVhbENoaWxkUHJvcHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdHVhbENoaWxkUHJvcHMgPSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICAvLyBUT0RPIFdlJ3JlIHBhc3NpbmcgdGhyb3VnaCBhIGJpZyB3cmFwcGVyIHRoYXQgZG9lcyBhIGJ1bmNoIG9mIGV4dHJhIHNpZGUgZWZmZWN0cyBiZXNpZGVzIHN1YnNjcmliaW5nXG4gICAgICAgICAgc3Vic2NyaWJlRm9yUmVhY3QsXG4gICAgICAgICAgLy8gVE9ETyBUaGlzIGlzIGluY3JlZGlibHkgaGFja3kuIFdlJ3ZlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZSBzdG9yZSB1cGRhdGUgYW5kIGNhbGN1bGF0ZWQgbmV3IGNoaWxkIHByb3BzLFxuICAgICAgICAgIC8vIFRPRE8gYW5kIHdlJ3JlIGp1c3QgcGFzc2luZyB0aGF0IHRocm91Z2ggc28gaXQgdHJpZ2dlcnMgYSByZS1yZW5kZXIgZm9yIHVzIHJhdGhlciB0aGFuIHJlbHlpbmcgb24gYHVTRVNgLlxuICAgICAgICAgIGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvcixcbiAgICAgICAgICBnZXRTZXJ2ZXJTdGF0ZVxuICAgICAgICAgICAgPyAoKSA9PiBjaGlsZFByb3BzU2VsZWN0b3IoZ2V0U2VydmVyU3RhdGUoKSwgd3JhcHBlclByb3BzKVxuICAgICAgICAgICAgOiBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IsXG4gICAgICAgIClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAobGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50KSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXNlbWlcbiAgICAgICAgICA7KGVyciBhcyBFcnJvcikubWVzc2FnZSArPVxuICAgICAgICAgICAgYFxcblRoZSBlcnJvciBtYXkgYmUgY29ycmVsYXRlZCB3aXRoIHRoaXMgcHJldmlvdXMgZXJyb3I6XFxuJHtsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQuc3RhY2t9XFxuXFxuYFxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG5cbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgPSB1bmRlZmluZWRcbiAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gdW5kZWZpbmVkXG4gICAgICAgIGxhc3RDaGlsZFByb3BzLmN1cnJlbnQgPSBhY3R1YWxDaGlsZFByb3BzXG4gICAgICB9KVxuXG4gICAgICAvLyBOb3cgdGhhdCBhbGwgdGhhdCdzIGRvbmUsIHdlIGNhbiBmaW5hbGx5IHRyeSB0byBhY3R1YWxseSByZW5kZXIgdGhlIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgIC8vIFdlIG1lbW9pemUgdGhlIGVsZW1lbnRzIGZvciB0aGUgcmVuZGVyZWQgY2hpbGQgY29tcG9uZW50IGFzIGFuIG9wdGltaXphdGlvbi5cbiAgICAgIGNvbnN0IHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICA8V3JhcHBlZENvbXBvbmVudFxuICAgICAgICAgICAgey4uLmFjdHVhbENoaWxkUHJvcHN9XG4gICAgICAgICAgICByZWY9e3JlYWN0UmVkdXhGb3J3YXJkZWRSZWZ9XG4gICAgICAgICAgLz5cbiAgICAgICAgKVxuICAgICAgfSwgW3JlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIFdyYXBwZWRDb21wb25lbnQsIGFjdHVhbENoaWxkUHJvcHNdKVxuXG4gICAgICAvLyBJZiBSZWFjdCBzZWVzIHRoZSBleGFjdCBzYW1lIGVsZW1lbnQgcmVmZXJlbmNlIGFzIGxhc3QgdGltZSwgaXQgYmFpbHMgb3V0IG9mIHJlLXJlbmRlcmluZ1xuICAgICAgLy8gdGhhdCBjaGlsZCwgc2FtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBSZWFjdC5tZW1vKCkgb3IgcmV0dXJuZWQgZmFsc2UgZnJvbSBzaG91bGRDb21wb25lbnRVcGRhdGUuXG4gICAgICBjb25zdCByZW5kZXJlZENoaWxkID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGNvbXBvbmVudCBpcyBzdWJzY3JpYmVkIHRvIHN0b3JlIHVwZGF0ZXMsIHdlIG5lZWQgdG8gcGFzcyBpdHMgb3duXG4gICAgICAgICAgLy8gc3Vic2NyaXB0aW9uIGluc3RhbmNlIGRvd24gdG8gb3VyIGRlc2NlbmRhbnRzLiBUaGF0IG1lYW5zIHJlbmRlcmluZyB0aGUgc2FtZVxuICAgICAgICAgIC8vIENvbnRleHQgaW5zdGFuY2UsIGFuZCBwdXR0aW5nIGEgZGlmZmVyZW50IHZhbHVlIGludG8gdGhlIGNvbnRleHQuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxDb250ZXh0VG9Vc2UuUHJvdmlkZXIgdmFsdWU9e292ZXJyaWRkZW5Db250ZXh0VmFsdWV9PlxuICAgICAgICAgICAgICB7cmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50fVxuICAgICAgICAgICAgPC9Db250ZXh0VG9Vc2UuUHJvdmlkZXI+XG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudFxuICAgICAgfSwgW0NvbnRleHRUb1VzZSwgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50LCBvdmVycmlkZGVuQ29udGV4dFZhbHVlXSlcblxuICAgICAgcmV0dXJuIHJlbmRlcmVkQ2hpbGRcbiAgICB9XG5cbiAgICBjb25zdCBfQ29ubmVjdCA9IFJlYWN0Lm1lbW8oQ29ubmVjdEZ1bmN0aW9uKVxuXG4gICAgdHlwZSBDb25uZWN0ZWRXcmFwcGVyQ29tcG9uZW50ID0gdHlwZW9mIF9Db25uZWN0ICYge1xuICAgICAgV3JhcHBlZENvbXBvbmVudDogdHlwZW9mIFdyYXBwZWRDb21wb25lbnRcbiAgICB9XG5cbiAgICAvLyBBZGQgYSBoYWNreSBjYXN0IHRvIGdldCB0aGUgcmlnaHQgb3V0cHV0IHR5cGVcbiAgICBjb25zdCBDb25uZWN0ID0gX0Nvbm5lY3QgYXMgdW5rbm93biBhcyBDb25uZWN0ZWRDb21wb25lbnQ8XG4gICAgICB0eXBlb2YgV3JhcHBlZENvbXBvbmVudCxcbiAgICAgIFdyYXBwZWRDb21wb25lbnRQcm9wc1xuICAgID5cbiAgICBDb25uZWN0LldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50XG4gICAgQ29ubmVjdC5kaXNwbGF5TmFtZSA9IENvbm5lY3RGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lXG5cbiAgICBpZiAoZm9yd2FyZFJlZikge1xuICAgICAgY29uc3QgX2ZvcndhcmRlZCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmRDb25uZWN0UmVmKHByb3BzLCByZWYpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgcmV0dXJuIDxDb25uZWN0IHsuLi5wcm9wc30gcmVhY3RSZWR1eEZvcndhcmRlZFJlZj17cmVmfSAvPlxuICAgICAgICB9LFxuICAgICAgKVxuXG4gICAgICBjb25zdCBmb3J3YXJkZWQgPSBfZm9yd2FyZGVkIGFzIENvbm5lY3RlZFdyYXBwZXJDb21wb25lbnRcbiAgICAgIGZvcndhcmRlZC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lXG4gICAgICBmb3J3YXJkZWQuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnRcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIGhvaXN0U3RhdGljcyhmb3J3YXJkZWQsIFdyYXBwZWRDb21wb25lbnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gaG9pc3RTdGF0aWNzKENvbm5lY3QsIFdyYXBwZWRDb21wb25lbnQpXG4gIH1cblxuICByZXR1cm4gd3JhcFdpdGhDb25uZWN0XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3QgYXMgQ29ubmVjdFxuIiwiaW1wb3J0IHR5cGUgeyBDb250ZXh0LCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFJlYWN0IH0gZnJvbSAnLi4vdXRpbHMvcmVhY3QnXG5pbXBvcnQgdHlwZSB7IEFjdGlvbiwgU3RvcmUsIFVua25vd25BY3Rpb24gfSBmcm9tICdyZWR1eCdcbmltcG9ydCB0eXBlIHsgRGV2TW9kZUNoZWNrRnJlcXVlbmN5IH0gZnJvbSAnLi4vaG9va3MvdXNlU2VsZWN0b3InXG5pbXBvcnQgeyBjcmVhdGVTdWJzY3JpcHRpb24gfSBmcm9tICcuLi91dGlscy9TdWJzY3JpcHRpb24nXG5pbXBvcnQgeyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IH0gZnJvbSAnLi4vdXRpbHMvdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCdcbmltcG9ydCB0eXBlIHsgUmVhY3RSZWR1eENvbnRleHRWYWx1ZSB9IGZyb20gJy4vQ29udGV4dCdcbmltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi9Db250ZXh0J1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3ZpZGVyUHJvcHM8XG4gIEEgZXh0ZW5kcyBBY3Rpb248c3RyaW5nPiA9IFVua25vd25BY3Rpb24sXG4gIFMgPSB1bmtub3duLFxuPiB7XG4gIC8qKlxuICAgKiBUaGUgc2luZ2xlIFJlZHV4IHN0b3JlIGluIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuICBzdG9yZTogU3RvcmU8UywgQT5cblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgc2VydmVyIHN0YXRlIHNuYXBzaG90LiBXaWxsIGJlIHVzZWQgZHVyaW5nIGluaXRpYWwgaHlkcmF0aW9uIHJlbmRlciBpZiBhdmFpbGFibGUsIHRvIGVuc3VyZSB0aGF0IHRoZSBVSSBvdXRwdXQgaXMgY29uc2lzdGVudCB3aXRoIHRoZSBIVE1MIGdlbmVyYXRlZCBvbiB0aGUgc2VydmVyLlxuICAgKi9cbiAgc2VydmVyU3RhdGU/OiBTXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGNvbnRleHQgdG8gYmUgdXNlZCBpbnRlcm5hbGx5IGluIHJlYWN0LXJlZHV4LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHRvIGNyZWF0ZSBhIGNvbnRleHQgdG8gYmUgdXNlZC5cbiAgICogSWYgdGhpcyBpcyB1c2VkLCB5b3UnbGwgbmVlZCB0byBjdXN0b21pemUgYGNvbm5lY3RgIGJ5IHN1cHBseWluZyB0aGUgc2FtZSBjb250ZXh0IHByb3ZpZGVkIHRvIHRoZSBQcm92aWRlci5cbiAgICogU2V0IHRoZSBpbml0aWFsIHZhbHVlIHRvIG51bGwsIGFuZCB0aGUgaG9va3Mgd2lsbCBlcnJvclxuICAgKiBpZiB0aGlzIGlzIG5vdCBvdmVyd3JpdHRlbiBieSBQcm92aWRlci5cbiAgICovXG4gIGNvbnRleHQ/OiBDb250ZXh0PFJlYWN0UmVkdXhDb250ZXh0VmFsdWU8UywgQT4gfCBudWxsPlxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBmcmVxdWVuY3kgb2Ygc3RhYmlsaXR5IGNoZWNrcyBmb3IgYWxsIHNlbGVjdG9ycy5cbiAgICogVGhpcyBzZXR0aW5nIG92ZXJyaWRlcyB0aGUgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gZm9yXG4gICAqIHRoZSBgdXNlU2VsZWN0b3JgIHN0YWJpbGl0eSBjaGVjaywgYWxsb3dpbmcgeW91IHRvIHNwZWNpZnkgaG93IG9mdGVuXG4gICAqIHRoZXNlIGNoZWNrcyBzaG91bGQgb2NjdXIgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cbiAgICpcbiAgICogQHNpbmNlIDguMS4wXG4gICAqL1xuICBzdGFiaWxpdHlDaGVjaz86IERldk1vZGVDaGVja0ZyZXF1ZW5jeVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBmcmVxdWVuY3kgb2YgaWRlbnRpdHkgZnVuY3Rpb24gY2hlY2tzIGZvciBhbGwgc2VsZWN0b3JzLlxuICAgKiBUaGlzIHNldHRpbmcgb3ZlcnJpZGVzIHRoZSBnbG9iYWwgY29uZmlndXJhdGlvbiBmb3JcbiAgICogdGhlIGB1c2VTZWxlY3RvcmAgaWRlbnRpdHkgZnVuY3Rpb24gY2hlY2ssIGFsbG93aW5nIHlvdSB0byBzcGVjaWZ5IGhvdyBvZnRlblxuICAgKiB0aGVzZSBjaGVja3Mgc2hvdWxkIG9jY3VyIGluIGRldmVsb3BtZW50IG1vZGUuXG4gICAqXG4gICAqICoqTm90ZSoqOiBQcmV2aW91c2x5IHJlZmVycmVkIHRvIGFzIGBub29wQ2hlY2tgLlxuICAgKlxuICAgKiBAc2luY2UgOS4wLjBcbiAgICovXG4gIGlkZW50aXR5RnVuY3Rpb25DaGVjaz86IERldk1vZGVDaGVja0ZyZXF1ZW5jeVxuXG4gIGNoaWxkcmVuOiBSZWFjdE5vZGVcbn1cblxuZnVuY3Rpb24gUHJvdmlkZXI8QSBleHRlbmRzIEFjdGlvbjxzdHJpbmc+ID0gVW5rbm93bkFjdGlvbiwgUyA9IHVua25vd24+KFxuICBwcm92aWRlclByb3BzOiBQcm92aWRlclByb3BzPEEsIFM+LFxuKSB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGNvbnRleHQsIHNlcnZlclN0YXRlLCBzdG9yZSB9ID0gcHJvdmlkZXJQcm9wc1xuXG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZSlcblxuICAgIGNvbnN0IGJhc2VDb250ZXh0VmFsdWUgPSB7XG4gICAgICBzdG9yZSxcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGdldFNlcnZlclN0YXRlOiBzZXJ2ZXJTdGF0ZSA/ICgpID0+IHNlcnZlclN0YXRlIDogdW5kZWZpbmVkLFxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXR1cm4gYmFzZUNvbnRleHRWYWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IGlkZW50aXR5RnVuY3Rpb25DaGVjayA9ICdvbmNlJywgc3RhYmlsaXR5Q2hlY2sgPSAnb25jZScgfSA9XG4gICAgICAgIHByb3ZpZGVyUHJvcHNcblxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKGJhc2VDb250ZXh0VmFsdWUsIHtcbiAgICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjayxcbiAgICAgIH0pXG4gICAgfVxuICB9LCBbc3RvcmUsIHNlcnZlclN0YXRlXSlcblxuICBjb25zdCBwcmV2aW91c1N0YXRlID0gUmVhY3QudXNlTWVtbygoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLCBbc3RvcmVdKVxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHsgc3Vic2NyaXB0aW9uIH0gPSBjb250ZXh0VmFsdWVcbiAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzXG4gICAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpXG5cbiAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gc3RvcmUuZ2V0U3RhdGUoKSkge1xuICAgICAgc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnMoKVxuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKClcbiAgICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gdW5kZWZpbmVkXG4gICAgfVxuICB9LCBbY29udGV4dFZhbHVlLCBwcmV2aW91c1N0YXRlXSlcblxuICBjb25zdCBDb250ZXh0ID0gY29udGV4dCB8fCBSZWFjdFJlZHV4Q29udGV4dFxuXG4gIHJldHVybiA8Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dFZhbHVlfT57Y2hpbGRyZW59PC9Db250ZXh0LlByb3ZpZGVyPlxufVxuXG5leHBvcnQgZGVmYXVsdCBQcm92aWRlclxuIiwiaW1wb3J0IHsgUmVhY3QgfSBmcm9tICcuLi91dGlscy9yZWFjdCdcbmltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9Db250ZXh0J1xuaW1wb3J0IHR5cGUgeyBSZWFjdFJlZHV4Q29udGV4dFZhbHVlIH0gZnJvbSAnLi4vY29tcG9uZW50cy9Db250ZXh0J1xuXG4vKipcbiAqIEhvb2sgZmFjdG9yeSwgd2hpY2ggY3JlYXRlcyBhIGB1c2VSZWR1eENvbnRleHRgIGhvb2sgYm91bmQgdG8gYSBnaXZlbiBjb250ZXh0LiBUaGlzIGlzIGEgbG93LWxldmVsXG4gKiBob29rIHRoYXQgeW91IHNob3VsZCB1c3VhbGx5IG5vdCBuZWVkIHRvIGNhbGwgZGlyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtSZWFjdC5Db250ZXh0fSBbY29udGV4dD1SZWFjdFJlZHV4Q29udGV4dF0gQ29udGV4dCBwYXNzZWQgdG8geW91ciBgPFByb3ZpZGVyPmAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgYHVzZVJlZHV4Q29udGV4dGAgaG9vayBib3VuZCB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gdXNlUmVkdXhDb250ZXh0KCk6IFJlYWN0UmVkdXhDb250ZXh0VmFsdWUge1xuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoY29udGV4dClcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb250ZXh0VmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2NvdWxkIG5vdCBmaW5kIHJlYWN0LXJlZHV4IGNvbnRleHQgdmFsdWU7IHBsZWFzZSBlbnN1cmUgdGhlIGNvbXBvbmVudCBpcyB3cmFwcGVkIGluIGEgPFByb3ZpZGVyPicsXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHRWYWx1ZSFcbiAgfVxufVxuXG4vKipcbiAqIEEgaG9vayB0byBhY2Nlc3MgdGhlIHZhbHVlIG9mIHRoZSBgUmVhY3RSZWR1eENvbnRleHRgLiBUaGlzIGlzIGEgbG93LWxldmVsXG4gKiBob29rIHRoYXQgeW91IHNob3VsZCB1c3VhbGx5IG5vdCBuZWVkIHRvIGNhbGwgZGlyZWN0bHkuXG4gKlxuICogQHJldHVybnMge2FueX0gdGhlIHZhbHVlIG9mIHRoZSBgUmVhY3RSZWR1eENvbnRleHRgXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG4gKiBpbXBvcnQgeyB1c2VSZWR1eENvbnRleHQgfSBmcm9tICdyZWFjdC1yZWR1eCdcbiAqXG4gKiBleHBvcnQgY29uc3QgQ291bnRlckNvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgeyBzdG9yZSB9ID0gdXNlUmVkdXhDb250ZXh0KClcbiAqICAgcmV0dXJuIDxkaXY+e3N0b3JlLmdldFN0YXRlKCl9PC9kaXY+XG4gKiB9XG4gKi9cbmV4cG9ydCBjb25zdCB1c2VSZWR1eENvbnRleHQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soKVxuIiwiaW1wb3J0IHR5cGUgeyBDb250ZXh0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgdHlwZSB7IEFjdGlvbiwgU3RvcmUgfSBmcm9tICdyZWR1eCdcbmltcG9ydCB0eXBlIHsgUmVhY3RSZWR1eENvbnRleHRWYWx1ZSB9IGZyb20gJy4uL2NvbXBvbmVudHMvQ29udGV4dCdcbmltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9Db250ZXh0J1xuaW1wb3J0IHtcbiAgY3JlYXRlUmVkdXhDb250ZXh0SG9vayxcbiAgdXNlUmVkdXhDb250ZXh0IGFzIHVzZURlZmF1bHRSZWR1eENvbnRleHQsXG59IGZyb20gJy4vdXNlUmVkdXhDb250ZXh0J1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0eXBlIHRoYXQgZXh0cmFjdHMgdGhlIGFjdGlvbiB0eXBlIGZyb20gYSBnaXZlbiBSZWR1eCBzdG9yZS5cbiAqXG4gKiBAdGVtcGxhdGUgU3RvcmVUeXBlIC0gVGhlIHNwZWNpZmljIHR5cGUgb2YgdGhlIFJlZHV4IHN0b3JlLlxuICpcbiAqIEBzaW5jZSA5LjEuMFxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCB0eXBlIEV4dHJhY3RTdG9yZUFjdGlvblR5cGU8U3RvcmVUeXBlIGV4dGVuZHMgU3RvcmU+ID1cbiAgU3RvcmVUeXBlIGV4dGVuZHMgU3RvcmU8YW55LCBpbmZlciBBY3Rpb25UeXBlPiA/IEFjdGlvblR5cGUgOiBuZXZlclxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjdXN0b20gaG9vayB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgUmVkdXggc3RvcmUuXG4gKlxuICogQHRlbXBsYXRlIFN0b3JlVHlwZSAtIFRoZSBzcGVjaWZpYyB0eXBlIG9mIHRoZSBSZWR1eCBzdG9yZSB0aGF0IGdldHMgcmV0dXJuZWQuXG4gKlxuICogQHNpbmNlIDkuMS4wXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU3RvcmU8U3RvcmVUeXBlIGV4dGVuZHMgU3RvcmU+IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFJlZHV4IHN0b3JlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgUmVkdXggc3RvcmUgaW5zdGFuY2UuXG4gICAqL1xuICAoKTogU3RvcmVUeXBlXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFJlZHV4IHN0b3JlIGluc3RhbmNlIHdpdGggc3BlY2lmaWMgc3RhdGUgYW5kIGFjdGlvbiB0eXBlcy5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIFJlZHV4IHN0b3JlIHdpdGggdGhlIHNwZWNpZmllZCBzdGF0ZSBhbmQgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAdGVtcGxhdGUgU3RhdGVUeXBlIC0gVGhlIHNwZWNpZmljIHR5cGUgb2YgdGhlIHN0YXRlIHVzZWQgaW4gdGhlIHN0b3JlLlxuICAgKiBAdGVtcGxhdGUgQWN0aW9uVHlwZSAtIFRoZSBzcGVjaWZpYyB0eXBlIG9mIHRoZSBhY3Rpb25zIHVzZWQgaW4gdGhlIHN0b3JlLlxuICAgKi9cbiAgPFxuICAgIFN0YXRlVHlwZSBleHRlbmRzIFJldHVyblR5cGU8U3RvcmVUeXBlWydnZXRTdGF0ZSddPiA9IFJldHVyblR5cGU8XG4gICAgICBTdG9yZVR5cGVbJ2dldFN0YXRlJ11cbiAgICA+LFxuICAgIEFjdGlvblR5cGUgZXh0ZW5kcyBBY3Rpb24gPSBFeHRyYWN0U3RvcmVBY3Rpb25UeXBlPFN0b3JlPixcbiAgPigpOiBTdG9yZTxTdGF0ZVR5cGUsIEFjdGlvblR5cGU+XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBcInByZS10eXBlZFwiIHZlcnNpb24gb2Yge0BsaW5rY29kZSB1c2VTdG9yZSB1c2VTdG9yZX1cbiAgICogd2hlcmUgdGhlIHR5cGUgb2YgdGhlIFJlZHV4IGBzdG9yZWAgaXMgcHJlZGVmaW5lZC5cbiAgICpcbiAgICogVGhpcyBhbGxvd3MgeW91IHRvIHNldCB0aGUgYHN0b3JlYCB0eXBlIG9uY2UsIGVsaW1pbmF0aW5nIHRoZSBuZWVkIHRvXG4gICAqIHNwZWNpZnkgaXQgd2l0aCBldmVyeSB7QGxpbmtjb2RlIHVzZVN0b3JlIHVzZVN0b3JlfSBjYWxsLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByZS10eXBlZCBgdXNlU3RvcmVgIHdpdGggdGhlIHN0b3JlIHR5cGUgYWxyZWFkeSBkZWZpbmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBleHBvcnQgY29uc3QgdXNlQXBwU3RvcmUgPSB1c2VTdG9yZS53aXRoVHlwZXM8QXBwU3RvcmU+KClcbiAgICogYGBgXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBPdmVycmlkZVN0b3JlVHlwZSAtIFRoZSBzcGVjaWZpYyB0eXBlIG9mIHRoZSBSZWR1eCBzdG9yZSB0aGF0IGdldHMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBzaW5jZSA5LjEuMFxuICAgKi9cbiAgd2l0aFR5cGVzOiA8XG4gICAgT3ZlcnJpZGVTdG9yZVR5cGUgZXh0ZW5kcyBTdG9yZVR5cGUsXG4gID4oKSA9PiBVc2VTdG9yZTxPdmVycmlkZVN0b3JlVHlwZT5cbn1cblxuLyoqXG4gKiBIb29rIGZhY3RvcnksIHdoaWNoIGNyZWF0ZXMgYSBgdXNlU3RvcmVgIGhvb2sgYm91bmQgdG8gYSBnaXZlbiBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7UmVhY3QuQ29udGV4dH0gW2NvbnRleHQ9UmVhY3RSZWR1eENvbnRleHRdIENvbnRleHQgcGFzc2VkIHRvIHlvdXIgYDxQcm92aWRlcj5gLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGB1c2VTdG9yZWAgaG9vayBib3VuZCB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdG9yZUhvb2s8XG4gIFN0YXRlVHlwZSA9IHVua25vd24sXG4gIEFjdGlvblR5cGUgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24sXG4+KFxuICAvLyBAdHMtaWdub3JlXG4gIGNvbnRleHQ/OiBDb250ZXh0PFJlYWN0UmVkdXhDb250ZXh0VmFsdWU8XG4gICAgU3RhdGVUeXBlLFxuICAgIEFjdGlvblR5cGVcbiAgPiB8IG51bGw+ID0gUmVhY3RSZWR1eENvbnRleHQsXG4pIHtcbiAgY29uc3QgdXNlUmVkdXhDb250ZXh0ID1cbiAgICBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dFxuICAgICAgPyB1c2VEZWZhdWx0UmVkdXhDb250ZXh0XG4gICAgICA6IC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0KVxuICBjb25zdCB1c2VTdG9yZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IHN0b3JlIH0gPSB1c2VSZWR1eENvbnRleHQoKVxuICAgIHJldHVybiBzdG9yZVxuICB9XG5cbiAgT2JqZWN0LmFzc2lnbih1c2VTdG9yZSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gdXNlU3RvcmUsXG4gIH0pXG5cbiAgcmV0dXJuIHVzZVN0b3JlIGFzIFVzZVN0b3JlPFN0b3JlPFN0YXRlVHlwZSwgQWN0aW9uVHlwZT4+XG59XG5cbi8qKlxuICogQSBob29rIHRvIGFjY2VzcyB0aGUgcmVkdXggc3RvcmUuXG4gKlxuICogQHJldHVybnMge2FueX0gdGhlIHJlZHV4IHN0b3JlXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG4gKiBpbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuICpcbiAqIGV4cG9ydCBjb25zdCBFeGFtcGxlQ29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKClcbiAqICAgcmV0dXJuIDxkaXY+e3N0b3JlLmdldFN0YXRlKCl9PC9kaXY+XG4gKiB9XG4gKi9cbmV4cG9ydCBjb25zdCB1c2VTdG9yZSA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU3RvcmVIb29rKClcbiIsImltcG9ydCB0eXBlIHsgQ29udGV4dCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBBY3Rpb24sIERpc3BhdGNoLCBVbmtub3duQWN0aW9uIH0gZnJvbSAncmVkdXgnXG5cbmltcG9ydCB0eXBlIHsgUmVhY3RSZWR1eENvbnRleHRWYWx1ZSB9IGZyb20gJy4uL2NvbXBvbmVudHMvQ29udGV4dCdcbmltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9Db250ZXh0J1xuaW1wb3J0IHsgY3JlYXRlU3RvcmVIb29rLCB1c2VTdG9yZSBhcyB1c2VEZWZhdWx0U3RvcmUgfSBmcm9tICcuL3VzZVN0b3JlJ1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjdXN0b20gaG9vayB0aGF0IHByb3ZpZGVzIGEgZGlzcGF0Y2ggZnVuY3Rpb25cbiAqIGZyb20gdGhlIFJlZHV4IHN0b3JlLlxuICpcbiAqIEB0ZW1wbGF0ZSBEaXNwYXRjaFR5cGUgLSBUaGUgc3BlY2lmaWMgdHlwZSBvZiB0aGUgZGlzcGF0Y2ggZnVuY3Rpb24uXG4gKlxuICogQHNpbmNlIDkuMS4wXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRGlzcGF0Y2g8XG4gIERpc3BhdGNoVHlwZSBleHRlbmRzIERpc3BhdGNoPFVua25vd25BY3Rpb24+ID0gRGlzcGF0Y2g8VW5rbm93bkFjdGlvbj4sXG4+IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpc3BhdGNoIGZ1bmN0aW9uIGZyb20gdGhlIFJlZHV4IHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgZGlzcGF0Y2ggZnVuY3Rpb24gZnJvbSB0aGUgUmVkdXggc3RvcmUuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBBcHBEaXNwYXRjaCAtIFRoZSBzcGVjaWZpYyB0eXBlIG9mIHRoZSBkaXNwYXRjaCBmdW5jdGlvbi5cbiAgICovXG4gIDxBcHBEaXNwYXRjaCBleHRlbmRzIERpc3BhdGNoVHlwZSA9IERpc3BhdGNoVHlwZT4oKTogQXBwRGlzcGF0Y2hcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFwicHJlLXR5cGVkXCIgdmVyc2lvbiBvZiB7QGxpbmtjb2RlIHVzZURpc3BhdGNoIHVzZURpc3BhdGNofVxuICAgKiB3aGVyZSB0aGUgdHlwZSBvZiB0aGUgYGRpc3BhdGNoYCBmdW5jdGlvbiBpcyBwcmVkZWZpbmVkLlxuICAgKlxuICAgKiBUaGlzIGFsbG93cyB5b3UgdG8gc2V0IHRoZSBgZGlzcGF0Y2hgIHR5cGUgb25jZSwgZWxpbWluYXRpbmcgdGhlIG5lZWQgdG9cbiAgICogc3BlY2lmeSBpdCB3aXRoIGV2ZXJ5IHtAbGlua2NvZGUgdXNlRGlzcGF0Y2ggdXNlRGlzcGF0Y2h9IGNhbGwuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJlLXR5cGVkIGB1c2VEaXNwYXRjaGAgd2l0aCB0aGUgZGlzcGF0Y2ggdHlwZSBhbHJlYWR5IGRlZmluZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGV4cG9ydCBjb25zdCB1c2VBcHBEaXNwYXRjaCA9IHVzZURpc3BhdGNoLndpdGhUeXBlczxBcHBEaXNwYXRjaD4oKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHRlbXBsYXRlIE92ZXJyaWRlRGlzcGF0Y2hUeXBlIC0gVGhlIHNwZWNpZmljIHR5cGUgb2YgdGhlIGRpc3BhdGNoIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAc2luY2UgOS4xLjBcbiAgICovXG4gIHdpdGhUeXBlczogPFxuICAgIE92ZXJyaWRlRGlzcGF0Y2hUeXBlIGV4dGVuZHMgRGlzcGF0Y2hUeXBlLFxuICA+KCkgPT4gVXNlRGlzcGF0Y2g8T3ZlcnJpZGVEaXNwYXRjaFR5cGU+XG59XG5cbi8qKlxuICogSG9vayBmYWN0b3J5LCB3aGljaCBjcmVhdGVzIGEgYHVzZURpc3BhdGNoYCBob29rIGJvdW5kIHRvIGEgZ2l2ZW4gY29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0LkNvbnRleHR9IFtjb250ZXh0PVJlYWN0UmVkdXhDb250ZXh0XSBDb250ZXh0IHBhc3NlZCB0byB5b3VyIGA8UHJvdmlkZXI+YC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBgdXNlRGlzcGF0Y2hgIGhvb2sgYm91bmQgdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hIb29rPFxuICBTdGF0ZVR5cGUgPSB1bmtub3duLFxuICBBY3Rpb25UeXBlIGV4dGVuZHMgQWN0aW9uID0gVW5rbm93bkFjdGlvbixcbj4oXG4gIC8vIEB0cy1pZ25vcmVcbiAgY29udGV4dD86IENvbnRleHQ8UmVhY3RSZWR1eENvbnRleHRWYWx1ZTxcbiAgICBTdGF0ZVR5cGUsXG4gICAgQWN0aW9uVHlwZVxuICA+IHwgbnVsbD4gPSBSZWFjdFJlZHV4Q29udGV4dCxcbikge1xuICBjb25zdCB1c2VTdG9yZSA9XG4gICAgY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VEZWZhdWx0U3RvcmUgOiBjcmVhdGVTdG9yZUhvb2soY29udGV4dClcblxuICBjb25zdCB1c2VEaXNwYXRjaCA9ICgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKClcbiAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2hcbiAgfVxuXG4gIE9iamVjdC5hc3NpZ24odXNlRGlzcGF0Y2gsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHVzZURpc3BhdGNoLFxuICB9KVxuXG4gIHJldHVybiB1c2VEaXNwYXRjaCBhcyBVc2VEaXNwYXRjaDxEaXNwYXRjaDxBY3Rpb25UeXBlPj5cbn1cblxuLyoqXG4gKiBBIGhvb2sgdG8gYWNjZXNzIHRoZSByZWR1eCBgZGlzcGF0Y2hgIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHthbnl8ZnVuY3Rpb259IHJlZHV4IHN0b3JlJ3MgYGRpc3BhdGNoYCBmdW5jdGlvblxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXG4gKiBpbXBvcnQgeyB1c2VEaXNwYXRjaCB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuICpcbiAqIGV4cG9ydCBjb25zdCBDb3VudGVyQ29tcG9uZW50ID0gKHsgdmFsdWUgfSkgPT4ge1xuICogICBjb25zdCBkaXNwYXRjaCA9IHVzZURpc3BhdGNoKClcbiAqICAgY29uc3QgaW5jcmVhc2VDb3VudGVyID0gdXNlQ2FsbGJhY2soKCkgPT4gZGlzcGF0Y2goeyB0eXBlOiAnaW5jcmVhc2UtY291bnRlcicgfSksIFtdKVxuICogICByZXR1cm4gKFxuICogICAgIDxkaXY+XG4gKiAgICAgICA8c3Bhbj57dmFsdWV9PC9zcGFuPlxuICogICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtpbmNyZWFzZUNvdW50ZXJ9PkluY3JlYXNlIGNvdW50ZXI8L2J1dHRvbj5cbiAqICAgICA8L2Rpdj5cbiAqICAgKVxuICogfVxuICovXG5leHBvcnQgY29uc3QgdXNlRGlzcGF0Y2ggPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURpc3BhdGNoSG9vaygpXG4iLCIvL2ltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgUmVhY3QgfSBmcm9tICcuLi91dGlscy9yZWFjdCdcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIH0gZnJvbSAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvd2l0aC1zZWxlY3Rvci5qcydcbmltcG9ydCB0eXBlIHsgUmVhY3RSZWR1eENvbnRleHRWYWx1ZSB9IGZyb20gJy4uL2NvbXBvbmVudHMvQ29udGV4dCdcbmltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9Db250ZXh0J1xuaW1wb3J0IHR5cGUgeyBFcXVhbGl0eUZuLCBOb0luZmVyIH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQge1xuICBjcmVhdGVSZWR1eENvbnRleHRIb29rLFxuICB1c2VSZWR1eENvbnRleHQgYXMgdXNlRGVmYXVsdFJlZHV4Q29udGV4dCxcbn0gZnJvbSAnLi91c2VSZWR1eENvbnRleHQnXG5cbi8qKlxuICogVGhlIGZyZXF1ZW5jeSBvZiBkZXZlbG9wbWVudCBtb2RlIGNoZWNrcy5cbiAqXG4gKiBAc2luY2UgOC4xLjBcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdHlwZSBEZXZNb2RlQ2hlY2tGcmVxdWVuY3kgPSAnbmV2ZXInIHwgJ29uY2UnIHwgJ2Fsd2F5cydcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjb25maWd1cmF0aW9uIGZvciBkZXZlbG9wbWVudCBtb2RlIGNoZWNrcy5cbiAqXG4gKiBAc2luY2UgOS4wLjBcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIERldk1vZGVDaGVja3Mge1xuICAvKipcbiAgICogT3ZlcnJpZGVzIHRoZSBnbG9iYWwgc3RhYmlsaXR5IGNoZWNrIGZvciB0aGUgc2VsZWN0b3IuXG4gICAqIC0gYG9uY2VgIC0gUnVuIG9ubHkgdGhlIGZpcnN0IHRpbWUgdGhlIHNlbGVjdG9yIGlzIGNhbGxlZC5cbiAgICogLSBgYWx3YXlzYCAtIFJ1biBldmVyeSB0aW1lIHRoZSBzZWxlY3RvciBpcyBjYWxsZWQuXG4gICAqIC0gYG5ldmVyYCAtIE5ldmVyIHJ1biB0aGUgc3RhYmlsaXR5IGNoZWNrLlxuICAgKlxuICAgKiBAZGVmYXVsdCAnb25jZSdcbiAgICpcbiAgICogQHNpbmNlIDguMS4wXG4gICAqL1xuICBzdGFiaWxpdHlDaGVjazogRGV2TW9kZUNoZWNrRnJlcXVlbmN5XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgZ2xvYmFsIGlkZW50aXR5IGZ1bmN0aW9uIGNoZWNrIGZvciB0aGUgc2VsZWN0b3IuXG4gICAqIC0gYG9uY2VgIC0gUnVuIG9ubHkgdGhlIGZpcnN0IHRpbWUgdGhlIHNlbGVjdG9yIGlzIGNhbGxlZC5cbiAgICogLSBgYWx3YXlzYCAtIFJ1biBldmVyeSB0aW1lIHRoZSBzZWxlY3RvciBpcyBjYWxsZWQuXG4gICAqIC0gYG5ldmVyYCAtIE5ldmVyIHJ1biB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gY2hlY2suXG4gICAqXG4gICAqICoqTm90ZSoqOiBQcmV2aW91c2x5IHJlZmVycmVkIHRvIGFzIGBub29wQ2hlY2tgLlxuICAgKlxuICAgKiBAZGVmYXVsdCAnb25jZSdcbiAgICpcbiAgICogQHNpbmNlIDkuMC4wXG4gICAqL1xuICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6IERldk1vZGVDaGVja0ZyZXF1ZW5jeVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNlbGVjdG9yT3B0aW9uczxTZWxlY3RlZCA9IHVua25vd24+IHtcbiAgZXF1YWxpdHlGbj86IEVxdWFsaXR5Rm48U2VsZWN0ZWQ+XG5cbiAgLyoqXG4gICAqIGB1c2VTZWxlY3RvcmAgcGVyZm9ybXMgYWRkaXRpb25hbCBjaGVja3MgaW4gZGV2ZWxvcG1lbnQgbW9kZSB0byBoZWxwXG4gICAqIGlkZW50aWZ5IGFuZCB3YXJuIGFib3V0IHBvdGVudGlhbCBpc3N1ZXMgaW4gc2VsZWN0b3IgYmVoYXZpb3IuIFRoaXNcbiAgICogb3B0aW9uIGFsbG93cyB5b3UgdG8gY3VzdG9taXplIHRoZSBiZWhhdmlvciBvZiB0aGVzZSBjaGVja3MgcGVyIHNlbGVjdG9yLlxuICAgKlxuICAgKiBAc2luY2UgOS4wLjBcbiAgICovXG4gIGRldk1vZGVDaGVja3M/OiBQYXJ0aWFsPERldk1vZGVDaGVja3M+XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGN1c3RvbSBob29rIHRoYXQgYWxsb3dzIHlvdSB0byBleHRyYWN0IGRhdGEgZnJvbSB0aGVcbiAqIFJlZHV4IHN0b3JlIHN0YXRlLCB1c2luZyBhIHNlbGVjdG9yIGZ1bmN0aW9uLiBUaGUgc2VsZWN0b3IgZnVuY3Rpb25cbiAqIHRha2VzIHRoZSBjdXJyZW50IHN0YXRlIGFzIGFuIGFyZ3VtZW50IGFuZCByZXR1cm5zIGEgcGFydCBvZiB0aGUgc3RhdGVcbiAqIG9yIHNvbWUgZGVyaXZlZCBkYXRhLiBUaGUgaG9vayBhbHNvIHN1cHBvcnRzIGFuIG9wdGlvbmFsIGVxdWFsaXR5XG4gKiBmdW5jdGlvbiBvciBvcHRpb25zIG9iamVjdCB0byBjdXN0b21pemUgaXRzIGJlaGF2aW9yLlxuICpcbiAqIEB0ZW1wbGF0ZSBTdGF0ZVR5cGUgLSBUaGUgc3BlY2lmaWMgdHlwZSBvZiBzdGF0ZSB0aGlzIGhvb2sgb3BlcmF0ZXMgb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNlbGVjdG9yPFN0YXRlVHlwZSA9IHVua25vd24+IHtcbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHNlbGVjdG9yIGZ1bmN0aW9uIGFzIGl0cyBmaXJzdCBhcmd1bWVudC5cbiAgICogVGhlIHNlbGVjdG9yIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBzZWxlY3RpbmcgYSBwYXJ0IG9mXG4gICAqIHRoZSBSZWR1eCBzdG9yZSdzIHN0YXRlIG9yIGNvbXB1dGluZyBkZXJpdmVkIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3RvciAtIEEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgY3VycmVudCBzdGF0ZSBhbmQgcmV0dXJucyBhIHBhcnQgb2YgdGhlIHN0YXRlIG9yIHNvbWUgZGVyaXZlZCBkYXRhLlxuICAgKiBAcGFyYW0gZXF1YWxpdHlGbk9yT3B0aW9ucyAtIEFuIG9wdGlvbmFsIGVxdWFsaXR5IGZ1bmN0aW9uIG9yIG9wdGlvbnMgb2JqZWN0IGZvciBjdXN0b21pemluZyB0aGUgYmVoYXZpb3Igb2YgdGhlIHNlbGVjdG9yLlxuICAgKiBAcmV0dXJucyBUaGUgc2VsZWN0ZWQgcGFydCBvZiB0aGUgc3RhdGUgb3IgZGVyaXZlZCBkYXRhLlxuICAgKlxuICAgKiBAdGVtcGxhdGUgVFN0YXRlIC0gVGhlIHNwZWNpZmljIHR5cGUgb2Ygc3RhdGUgdGhpcyBob29rIG9wZXJhdGVzIG9uLlxuICAgKiBAdGVtcGxhdGUgU2VsZWN0ZWQgLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdGhhdCB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gd2lsbCByZXR1cm4uXG4gICAqL1xuICA8VFN0YXRlIGV4dGVuZHMgU3RhdGVUeXBlID0gU3RhdGVUeXBlLCBTZWxlY3RlZCA9IHVua25vd24+KFxuICAgIHNlbGVjdG9yOiAoc3RhdGU6IFRTdGF0ZSkgPT4gU2VsZWN0ZWQsXG4gICAgZXF1YWxpdHlGbk9yT3B0aW9ucz86IEVxdWFsaXR5Rm48U2VsZWN0ZWQ+IHwgVXNlU2VsZWN0b3JPcHRpb25zPFNlbGVjdGVkPixcbiAgKTogU2VsZWN0ZWRcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFwicHJlLXR5cGVkXCIgdmVyc2lvbiBvZiB7QGxpbmtjb2RlIHVzZVNlbGVjdG9yIHVzZVNlbGVjdG9yfVxuICAgKiB3aGVyZSB0aGUgYHN0YXRlYCB0eXBlIGlzIHByZWRlZmluZWQuXG4gICAqXG4gICAqIFRoaXMgYWxsb3dzIHlvdSB0byBzZXQgdGhlIGBzdGF0ZWAgdHlwZSBvbmNlLCBlbGltaW5hdGluZyB0aGUgbmVlZCB0b1xuICAgKiBzcGVjaWZ5IGl0IHdpdGggZXZlcnkge0BsaW5rY29kZSB1c2VTZWxlY3RvciB1c2VTZWxlY3Rvcn0gY2FsbC5cbiAgICpcbiAgICogQHJldHVybnMgQSBwcmUtdHlwZWQgYHVzZVNlbGVjdG9yYCB3aXRoIHRoZSBzdGF0ZSB0eXBlIGFscmVhZHkgZGVmaW5lZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogZXhwb3J0IGNvbnN0IHVzZUFwcFNlbGVjdG9yID0gdXNlU2VsZWN0b3Iud2l0aFR5cGVzPFJvb3RTdGF0ZT4oKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHRlbXBsYXRlIE92ZXJyaWRlU3RhdGVUeXBlIC0gVGhlIHNwZWNpZmljIHR5cGUgb2Ygc3RhdGUgdGhpcyBob29rIG9wZXJhdGVzIG9uLlxuICAgKlxuICAgKiBAc2luY2UgOS4xLjBcbiAgICovXG4gIHdpdGhUeXBlczogPFxuICAgIE92ZXJyaWRlU3RhdGVUeXBlIGV4dGVuZHMgU3RhdGVUeXBlLFxuICA+KCkgPT4gVXNlU2VsZWN0b3I8T3ZlcnJpZGVTdGF0ZVR5cGU+XG59XG5cbmNvbnN0IHJlZkVxdWFsaXR5OiBFcXVhbGl0eUZuPGFueT4gPSAoYSwgYikgPT4gYSA9PT0gYlxuXG4vKipcbiAqIEhvb2sgZmFjdG9yeSwgd2hpY2ggY3JlYXRlcyBhIGB1c2VTZWxlY3RvcmAgaG9vayBib3VuZCB0byBhIGdpdmVuIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtSZWFjdC5Db250ZXh0fSBbY29udGV4dD1SZWFjdFJlZHV4Q29udGV4dF0gQ29udGV4dCBwYXNzZWQgdG8geW91ciBgPFByb3ZpZGVyPmAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgYHVzZVNlbGVjdG9yYCBob29rIGJvdW5kIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9ySG9vayhcbiAgY29udGV4dDogUmVhY3QuQ29udGV4dDxSZWFjdFJlZHV4Q29udGV4dFZhbHVlPFxuICAgIGFueSxcbiAgICBhbnlcbiAgPiB8IG51bGw+ID0gUmVhY3RSZWR1eENvbnRleHQsXG4pOiBVc2VTZWxlY3RvciB7XG4gIGNvbnN0IHVzZVJlZHV4Q29udGV4dCA9XG4gICAgY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHRcbiAgICAgID8gdXNlRGVmYXVsdFJlZHV4Q29udGV4dFxuICAgICAgOiBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQpXG5cbiAgY29uc3QgdXNlU2VsZWN0b3IgPSA8VFN0YXRlLCBTZWxlY3RlZD4oXG4gICAgc2VsZWN0b3I6IChzdGF0ZTogVFN0YXRlKSA9PiBTZWxlY3RlZCxcbiAgICBlcXVhbGl0eUZuT3JPcHRpb25zOlxuICAgICAgfCBFcXVhbGl0eUZuPE5vSW5mZXI8U2VsZWN0ZWQ+PlxuICAgICAgfCBVc2VTZWxlY3Rvck9wdGlvbnM8Tm9JbmZlcjxTZWxlY3RlZD4+ID0ge30sXG4gICk6IFNlbGVjdGVkID0+IHtcbiAgICBjb25zdCB7IGVxdWFsaXR5Rm4gPSByZWZFcXVhbGl0eSB9ID1cbiAgICAgIHR5cGVvZiBlcXVhbGl0eUZuT3JPcHRpb25zID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8geyBlcXVhbGl0eUZuOiBlcXVhbGl0eUZuT3JPcHRpb25zIH1cbiAgICAgICAgOiBlcXVhbGl0eUZuT3JPcHRpb25zXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgc2VsZWN0b3IgdG8gdXNlU2VsZWN0b3JgKVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhIHNlbGVjdG9yIHRvIHVzZVNlbGVjdG9yYClcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZXF1YWxpdHlGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhbiBlcXVhbGl0eSBmdW5jdGlvbiB0byB1c2VTZWxlY3RvcmAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZWR1eENvbnRleHQgPSB1c2VSZWR1eENvbnRleHQoKVxuXG4gICAgY29uc3QgeyBzdG9yZSwgc3Vic2NyaXB0aW9uLCBnZXRTZXJ2ZXJTdGF0ZSB9ID0gcmVkdXhDb250ZXh0XG5cbiAgICBjb25zdCBmaXJzdFJ1biA9IFJlYWN0LnVzZVJlZih0cnVlKVxuXG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QudXNlQ2FsbGJhY2s8dHlwZW9mIHNlbGVjdG9yPihcbiAgICAgIHtcbiAgICAgICAgW3NlbGVjdG9yLm5hbWVdKHN0YXRlOiBUU3RhdGUpIHtcbiAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHNlbGVjdG9yKHN0YXRlKVxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRldk1vZGVDaGVja3MgPSB7fSB9ID1cbiAgICAgICAgICAgICAgdHlwZW9mIGVxdWFsaXR5Rm5Pck9wdGlvbnMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICAgICAgOiBlcXVhbGl0eUZuT3JPcHRpb25zXG4gICAgICAgICAgICBjb25zdCB7IGlkZW50aXR5RnVuY3Rpb25DaGVjaywgc3RhYmlsaXR5Q2hlY2sgfSA9IHJlZHV4Q29udGV4dFxuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6IGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrLFxuICAgICAgICAgICAgICBzdGFiaWxpdHlDaGVjazogZmluYWxTdGFiaWxpdHlDaGVjayxcbiAgICAgICAgICAgIH0gPSB7XG4gICAgICAgICAgICAgIHN0YWJpbGl0eUNoZWNrLFxuICAgICAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2ssXG4gICAgICAgICAgICAgIC4uLmRldk1vZGVDaGVja3MsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGZpbmFsU3RhYmlsaXR5Q2hlY2sgPT09ICdhbHdheXMnIHx8XG4gICAgICAgICAgICAgIChmaW5hbFN0YWJpbGl0eUNoZWNrID09PSAnb25jZScgJiYgZmlyc3RSdW4uY3VycmVudClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb25zdCB0b0NvbXBhcmUgPSBzZWxlY3RvcihzdGF0ZSlcbiAgICAgICAgICAgICAgaWYgKCFlcXVhbGl0eUZuKHNlbGVjdGVkLCB0b0NvbXBhcmUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKClcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtc2VtaVxuICAgICAgICAgICAgICAgICAgOyh7IHN0YWNrIH0gPSBlIGFzIEVycm9yKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAnU2VsZWN0b3IgJyArXG4gICAgICAgICAgICAgICAgICAgIChzZWxlY3Rvci5uYW1lIHx8ICd1bmtub3duJykgK1xuICAgICAgICAgICAgICAgICAgICAnIHJldHVybmVkIGEgZGlmZmVyZW50IHJlc3VsdCB3aGVuIGNhbGxlZCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLicgK1xuICAgICAgICAgICAgICAgICAgICAnXFxuU2VsZWN0b3JzIHRoYXQgcmV0dXJuIGEgbmV3IHJlZmVyZW5jZSAoc3VjaCBhcyBhbiBvYmplY3Qgb3IgYW4gYXJyYXkpIHNob3VsZCBiZSBtZW1vaXplZDogaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdXNhZ2UvZGVyaXZpbmctZGF0YS1zZWxlY3RvcnMjb3B0aW1pemluZy1zZWxlY3RvcnMtd2l0aC1tZW1vaXphdGlvbicsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQyOiB0b0NvbXBhcmUsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09ICdhbHdheXMnIHx8XG4gICAgICAgICAgICAgIChmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gJ29uY2UnICYmIGZpcnN0UnVuLmN1cnJlbnQpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKClcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtc2VtaVxuICAgICAgICAgICAgICAgICAgOyh7IHN0YWNrIH0gPSBlIGFzIEVycm9yKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAnU2VsZWN0b3IgJyArXG4gICAgICAgICAgICAgICAgICAgIChzZWxlY3Rvci5uYW1lIHx8ICd1bmtub3duJykgK1xuICAgICAgICAgICAgICAgICAgICAnIHJldHVybmVkIHRoZSByb290IHN0YXRlIHdoZW4gY2FsbGVkLiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHJlcmVuZGVycy4nICtcbiAgICAgICAgICAgICAgICAgICAgJ1xcblNlbGVjdG9ycyB0aGF0IHJldHVybiB0aGUgZW50aXJlIHN0YXRlIGFyZSBhbG1vc3QgY2VydGFpbmx5IGEgbWlzdGFrZSwgYXMgdGhleSB3aWxsIGNhdXNlIGEgcmVyZW5kZXIgd2hlbmV2ZXIgKmFueXRoaW5nKiBpbiBzdGF0ZSBjaGFuZ2VzLicsXG4gICAgICAgICAgICAgICAgICB7IHN0YWNrIH0sXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RSdW4uY3VycmVudCkgZmlyc3RSdW4uY3VycmVudCA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZWxlY3RlZFxuICAgICAgICB9LFxuICAgICAgfVtzZWxlY3Rvci5uYW1lXSxcbiAgICAgIFtzZWxlY3Rvcl0sXG4gICAgKVxuXG4gICAgY29uc3Qgc2VsZWN0ZWRTdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgICAgc3Vic2NyaXB0aW9uLmFkZE5lc3RlZFN1YixcbiAgICAgIHN0b3JlLmdldFN0YXRlLFxuICAgICAgZ2V0U2VydmVyU3RhdGUgfHwgc3RvcmUuZ2V0U3RhdGUsXG4gICAgICB3cmFwcGVkU2VsZWN0b3IsXG4gICAgICBlcXVhbGl0eUZuLFxuICAgIClcblxuICAgIFJlYWN0LnVzZURlYnVnVmFsdWUoc2VsZWN0ZWRTdGF0ZSlcblxuICAgIHJldHVybiBzZWxlY3RlZFN0YXRlXG4gIH1cblxuICBPYmplY3QuYXNzaWduKHVzZVNlbGVjdG9yLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VTZWxlY3RvcixcbiAgfSlcblxuICByZXR1cm4gdXNlU2VsZWN0b3IgYXMgVXNlU2VsZWN0b3Jcbn1cblxuLyoqXG4gKiBBIGhvb2sgdG8gYWNjZXNzIHRoZSByZWR1eCBzdG9yZSdzIHN0YXRlLiBUaGlzIGhvb2sgdGFrZXMgYSBzZWxlY3RvciBmdW5jdGlvblxuICogYXMgYW4gYXJndW1lbnQuIFRoZSBzZWxlY3RvciBpcyBjYWxsZWQgd2l0aCB0aGUgc3RvcmUgc3RhdGUuXG4gKlxuICogVGhpcyBob29rIHRha2VzIGFuIG9wdGlvbmFsIGVxdWFsaXR5IGNvbXBhcmlzb24gZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXJcbiAqIHRoYXQgYWxsb3dzIHlvdSB0byBjdXN0b21pemUgdGhlIHdheSB0aGUgc2VsZWN0ZWQgc3RhdGUgaXMgY29tcGFyZWQgdG8gZGV0ZXJtaW5lXG4gKiB3aGV0aGVyIHRoZSBjb21wb25lbnQgbmVlZHMgdG8gYmUgcmUtcmVuZGVyZWQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZXF1YWxpdHlGbiB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGVxdWFsaXR5XG4gKlxuICogQHJldHVybnMge2FueX0gdGhlIHNlbGVjdGVkIHN0YXRlXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG4gKiBpbXBvcnQgeyB1c2VTZWxlY3RvciB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuICpcbiAqIGV4cG9ydCBjb25zdCBDb3VudGVyQ29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCBjb3VudGVyID0gdXNlU2VsZWN0b3Ioc3RhdGUgPT4gc3RhdGUuY291bnRlcilcbiAqICAgcmV0dXJuIDxkaXY+e2NvdW50ZXJ9PC9kaXY+XG4gKiB9XG4gKi9cbmV4cG9ydCBjb25zdCB1c2VTZWxlY3RvciA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU2VsZWN0b3JIb29rKClcbiIsImltcG9ydCBjb25uZWN0IGZyb20gJy4vY29tcG9uZW50cy9jb25uZWN0J1xuZXhwb3J0IHR5cGUge1xuICBDb25uZWN0LFxuICBDb25uZWN0UHJvcHMsXG4gIENvbm5lY3RlZFByb3BzLFxufSBmcm9tICcuL2NvbXBvbmVudHMvY29ubmVjdCdcblxuaW1wb3J0IHNoYWxsb3dFcXVhbCBmcm9tICcuL3V0aWxzL3NoYWxsb3dFcXVhbCdcblxuaW1wb3J0IFByb3ZpZGVyIGZyb20gJy4vY29tcG9uZW50cy9Qcm92aWRlcidcbmltcG9ydCB7IGRlZmF1bHROb29wQmF0Y2ggfSBmcm9tICcuL3V0aWxzL2JhdGNoJ1xuXG5leHBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4vY29tcG9uZW50cy9Db250ZXh0J1xuZXhwb3J0IHR5cGUgeyBSZWFjdFJlZHV4Q29udGV4dFZhbHVlIH0gZnJvbSAnLi9jb21wb25lbnRzL0NvbnRleHQnXG5cbmV4cG9ydCB0eXBlIHsgUHJvdmlkZXJQcm9wcyB9IGZyb20gJy4vY29tcG9uZW50cy9Qcm92aWRlcidcblxuZXhwb3J0IHR5cGUge1xuICBNYXBEaXNwYXRjaFRvUHJvcHMsXG4gIE1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnksXG4gIE1hcERpc3BhdGNoVG9Qcm9wc0Z1bmN0aW9uLFxuICBNYXBEaXNwYXRjaFRvUHJvcHNOb25PYmplY3QsXG4gIE1hcERpc3BhdGNoVG9Qcm9wc1BhcmFtLFxuICBNYXBTdGF0ZVRvUHJvcHMsXG4gIE1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnksXG4gIE1hcFN0YXRlVG9Qcm9wc1BhcmFtLFxuICBNZXJnZVByb3BzLFxuICBTZWxlY3RvcixcbiAgU2VsZWN0b3JGYWN0b3J5LFxufSBmcm9tICcuL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5J1xuXG5leHBvcnQgeyBjcmVhdGVEaXNwYXRjaEhvb2ssIHVzZURpc3BhdGNoIH0gZnJvbSAnLi9ob29rcy91c2VEaXNwYXRjaCdcbmV4cG9ydCB0eXBlIHsgVXNlRGlzcGF0Y2ggfSBmcm9tICcuL2hvb2tzL3VzZURpc3BhdGNoJ1xuXG5leHBvcnQgeyBjcmVhdGVTZWxlY3Rvckhvb2ssIHVzZVNlbGVjdG9yIH0gZnJvbSAnLi9ob29rcy91c2VTZWxlY3RvcidcbmV4cG9ydCB0eXBlIHsgVXNlU2VsZWN0b3IgfSBmcm9tICcuL2hvb2tzL3VzZVNlbGVjdG9yJ1xuXG5leHBvcnQgeyBjcmVhdGVTdG9yZUhvb2ssIHVzZVN0b3JlIH0gZnJvbSAnLi9ob29rcy91c2VTdG9yZSdcbmV4cG9ydCB0eXBlIHsgVXNlU3RvcmUgfSBmcm9tICcuL2hvb2tzL3VzZVN0b3JlJ1xuXG5leHBvcnQgdHlwZSB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4vdXRpbHMvU3Vic2NyaXB0aW9uJ1xuXG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJ1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIEFzIG9mIFJlYWN0IDE4LCBiYXRjaGluZyBpcyBlbmFibGVkIGJ5IGRlZmF1bHQgZm9yIFJlYWN0RE9NIGFuZCBSZWFjdCBOYXRpdmUuXG4gKiBUaGlzIGlzIG5vdyBhIG5vLW9wIHRoYXQgaW1tZWRpYXRlbHkgcnVucyB0aGUgY2FsbGJhY2suXG4gKi9cbmNvbnN0IGJhdGNoID0gZGVmYXVsdE5vb3BCYXRjaFxuXG5leHBvcnQgeyBQcm92aWRlciwgYmF0Y2gsIGNvbm5lY3QsIHNoYWxsb3dFcXVhbCB9XG4iXSwibmFtZXMiOlsicmVhY3RSZWR1eEZvcndhcmRlZFJlZiIsIndyYXBwZXJQcm9wcyIsInN1YnNjcmlwdGlvbiIsIm5vdGlmeU5lc3RlZFN1YnMiLCJ1c2VSZWR1eENvbnRleHQiLCJ1c2VSZWR1eENvbnRleHQiLCJ1c2VTdG9yZSIsInVzZVN0b3JlIiwidXNlRGlzcGF0Y2giLCJ1c2VSZWR1eENvbnRleHQiLCJ1c2VTZWxlY3RvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUlzT00sUUFBUSxJQUFJLGFBQWE7QUp0Ty9CLFlBQVksV0FBVzs7QXdCRXZCLFNBQVMsd0NBQXdDOzs7QXZCTTFDLElBQU0sY0FBOEIsYUFBQSxHQUFBLDZKQUFBLENBQUEsTUFBTSxJQUFBLENBQVEsVUFBQSxDQUFXLElBQUk7QUFFeEUsSUFBTSxxQkFBcUMsYUFBQSxHQUFBLE9BQU8sR0FBQSxDQUNoRCxjQUFjLCtCQUErQjtBQUUvQyxJQUFNLG9CQUFvQyxhQUFBLEdBQUEsT0FBTyxHQUFBLENBQUksY0FBYztBQUNuRSxJQUFNLHNCQUFzQyxhQUFBLEdBQUEsT0FBTyxHQUFBLENBQUksZ0JBQWdCO0FBQ3ZFLElBQU0seUJBQXlDLGFBQUEsR0FBQSxPQUFPLEdBQUEsQ0FBSSxtQkFBbUI7QUFDN0UsSUFBTSxzQkFBc0MsYUFBQSxHQUFBLE9BQU8sR0FBQSxDQUFJLGdCQUFnQjtBQUN2RSxJQUFNLHNCQUFzQyxhQUFBLEdBQUEsT0FBTyxHQUFBLENBQUksZ0JBQWdCO0FBQ3ZFLElBQU0scUJBQXFDLGFBQUEsR0FBQSxPQUFPLEdBQUEsQ0FBSSxlQUFlO0FBQ3JFLElBQU0seUJBQXlDLGFBQUEsR0FBQSxPQUFPLEdBQUEsQ0FBSSxtQkFBbUI7QUFDN0UsSUFBTSxzQkFBc0MsYUFBQSxHQUFBLE9BQU8sR0FBQSxDQUFJLGdCQUFnQjtBQUN2RSxJQUFNLDJCQUEyQyxhQUFBLEdBQUEsT0FBTyxHQUFBLENBQ3REO0FBRUYsSUFBTSxrQkFBa0MsYUFBQSxHQUFBLE9BQU8sR0FBQSxDQUFJLFlBQVk7QUFDL0QsSUFBTSxrQkFBa0MsYUFBQSxHQUFBLE9BQU8sR0FBQSxDQUFJLFlBQVk7QUFDL0QsSUFB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UUFBUTtTQUFBO1FBR1gsTUFBTSw0TEFBZ0IsbUNBQUEsRUFDcEIsYUFBYSxZQUFBLEVBQ2IsTUFBTSxRQUFBLEVBQ04sa0JBQWtCLE1BQU0sUUFBQSxFQUN4QixpQkFDQTtRQUdGLDZKQUFBLENBQUEsTUFBTSxVQUFBLENBQWMsYUFBYTtRQUVqQyxPQUFPO0lBQ1Q7SUFFQSxPQUFPLE1BQUEsQ0FBT0MsY0FBYTtRQUN6QixXQUFXLElBQU1BO0lBQ25CLENBQUM7SUFFRCxPQUFPQTtBQUNUO0FBeUJPLElBQU0sY0FBNEIsYUFBQSxHQUFBLG1CQUFtQjs7QUM3TzVELElBQU0sUUFBUSIsImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODIyOSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDBzd2MvaGVscGVycy9lc20vX2RlZmluZV9wcm9wZXJ0eS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgfSBlbHNlIG9ialtrZXldID0gdmFsdWU7XG5cbiAgICByZXR1cm4gb2JqO1xufVxuZXhwb3J0IHsgX2RlZmluZV9wcm9wZXJ0eSBhcyBfIH07XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsU0FBUyxpQkFBaUIsR0FBRyxFQUFFLEdBQUcsRUFBRSxLQUFLO0lBQ3JDLElBQUksT0FBTyxLQUFLO1FBQ1osT0FBTyxjQUFjLENBQUMsS0FBSyxLQUFLO1lBQUUsT0FBTztZQUFPLFlBQVk7WUFBTSxjQUFjO1lBQU0sVUFBVTtRQUFLO0lBQ3pHLE9BQU8sR0FBRyxDQUFDLElBQUksR0FBRztJQUVsQixPQUFPO0FBQ1giLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODI0OCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9pbW1lci9zcmMvdXRpbHMvZW52LnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL2ltbWVyL3NyYy91dGlscy9lcnJvcnMudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvaW1tZXIvc3JjL3V0aWxzL2NvbW1vbi50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9pbW1lci9zcmMvdXRpbHMvcGx1Z2lucy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9pbW1lci9zcmMvY29yZS9zY29wZS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9pbW1lci9zcmMvY29yZS9maW5hbGl6ZS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9pbW1lci9zcmMvY29yZS9wcm94eS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9pbW1lci9zcmMvY29yZS9pbW1lckNsYXNzLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL2ltbWVyL3NyYy9jb3JlL2N1cnJlbnQudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvaW1tZXIvc3JjL3BsdWdpbnMvcGF0Y2hlcy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9pbW1lci9zcmMvcGx1Z2lucy9tYXBzZXQudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvaW1tZXIvc3JjL2ltbWVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNob3VsZCBiZSBubyBpbXBvcnRzIGhlcmUhXG5cbi8qKlxuICogVGhlIHNlbnRpbmVsIHZhbHVlIHJldHVybmVkIGJ5IHByb2R1Y2VycyB0byByZXBsYWNlIHRoZSBkcmFmdCB3aXRoIHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IE5PVEhJTkc6IHVuaXF1ZSBzeW1ib2wgPSBTeW1ib2wuZm9yKFwiaW1tZXItbm90aGluZ1wiKVxuXG4vKipcbiAqIFRvIGxldCBJbW1lciB0cmVhdCB5b3VyIGNsYXNzIGluc3RhbmNlcyBhcyBwbGFpbiBpbW11dGFibGUgb2JqZWN0c1xuICogKGFsYmVpdCB3aXRoIGEgY3VzdG9tIHByb3RvdHlwZSksIHlvdSBtdXN0IGRlZmluZSBlaXRoZXIgYW4gaW5zdGFuY2UgcHJvcGVydHlcbiAqIG9yIGEgc3RhdGljIHByb3BlcnR5IG9uIGVhY2ggb2YgeW91ciBjdXN0b20gY2xhc3Nlcy5cbiAqXG4gKiBPdGhlcndpc2UsIHlvdXIgY2xhc3MgaW5zdGFuY2Ugd2lsbCBuZXZlciBiZSBkcmFmdGVkLCB3aGljaCBtZWFucyBpdCB3b24ndCBiZVxuICogc2FmZSB0byBtdXRhdGUgaW4gYSBwcm9kdWNlIGNhbGxiYWNrLlxuICovXG5leHBvcnQgY29uc3QgRFJBRlRBQkxFOiB1bmlxdWUgc3ltYm9sID0gU3ltYm9sLmZvcihcImltbWVyLWRyYWZ0YWJsZVwiKVxuXG5leHBvcnQgY29uc3QgRFJBRlRfU1RBVEU6IHVuaXF1ZSBzeW1ib2wgPSBTeW1ib2wuZm9yKFwiaW1tZXItc3RhdGVcIilcbiIsImV4cG9ydCBjb25zdCBlcnJvcnMgPVxuXHRwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCJcblx0XHQ/IFtcblx0XHRcdFx0Ly8gQWxsIGVycm9yIGNvZGVzLCBzdGFydGluZyBieSAwOlxuXHRcdFx0XHRmdW5jdGlvbihwbHVnaW46IHN0cmluZykge1xuXHRcdFx0XHRcdHJldHVybiBgVGhlIHBsdWdpbiBmb3IgJyR7cGx1Z2lufScgaGFzIG5vdCBiZWVuIGxvYWRlZCBpbnRvIEltbWVyLiBUbyBlbmFibGUgdGhlIHBsdWdpbiwgaW1wb3J0IGFuZCBjYWxsIFxcYGVuYWJsZSR7cGx1Z2lufSgpXFxgIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXIgYXBwbGljYXRpb24uYFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbih0aGluZzogc3RyaW5nKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGBwcm9kdWNlIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB0aGluZ3MgdGhhdCBhcmUgZHJhZnRhYmxlOiBwbGFpbiBvYmplY3RzLCBhcnJheXMsIE1hcCwgU2V0IG9yIGNsYXNzZXMgdGhhdCBhcmUgbWFya2VkIHdpdGggJ1tpbW1lcmFibGVdOiB0cnVlJy4gR290ICcke3RoaW5nfSdgXG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIixcblx0XHRcdFx0ZnVuY3Rpb24oZGF0YTogYW55KSB7XG5cdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdFwiQ2Fubm90IHVzZSBhIHByb3h5IHRoYXQgaGFzIGJlZW4gcmV2b2tlZC4gRGlkIHlvdSBwYXNzIGFuIG9iamVjdCBmcm9tIGluc2lkZSBhbiBpbW1lciBmdW5jdGlvbiB0byBhbiBhc3luYyBwcm9jZXNzPyBcIiArXG5cdFx0XHRcdFx0XHRkYXRhXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcIkFuIGltbWVyIHByb2R1Y2VyIHJldHVybmVkIGEgbmV3IHZhbHVlICphbmQqIG1vZGlmaWVkIGl0cyBkcmFmdC4gRWl0aGVyIHJldHVybiBhIG5ldyB2YWx1ZSAqb3IqIG1vZGlmeSB0aGUgZHJhZnQuXCIsXG5cdFx0XHRcdFwiSW1tZXIgZm9yYmlkcyBjaXJjdWxhciByZWZlcmVuY2VzXCIsXG5cdFx0XHRcdFwiVGhlIGZpcnN0IG9yIHNlY29uZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uXCIsXG5cdFx0XHRcdFwiVGhlIHRoaXJkIGFyZ3VtZW50IHRvIGBwcm9kdWNlYCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgdW5kZWZpbmVkXCIsXG5cdFx0XHRcdFwiRmlyc3QgYXJndW1lbnQgdG8gYGNyZWF0ZURyYWZ0YCBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LCBhbiBhcnJheSwgb3IgYW4gaW1tZXJhYmxlIG9iamVjdFwiLFxuXHRcdFx0XHRcIkZpcnN0IGFyZ3VtZW50IHRvIGBmaW5pc2hEcmFmdGAgbXVzdCBiZSBhIGRyYWZ0IHJldHVybmVkIGJ5IGBjcmVhdGVEcmFmdGBcIixcblx0XHRcdFx0ZnVuY3Rpb24odGhpbmc6IHN0cmluZykge1xuXHRcdFx0XHRcdHJldHVybiBgJ2N1cnJlbnQnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiAke3RoaW5nfWBcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJPYmplY3QuZGVmaW5lUHJvcGVydHkoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLFxuXHRcdFx0XHRcIk9iamVjdC5zZXRQcm90b3R5cGVPZigpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsXG5cdFx0XHRcdFwiSW1tZXIgb25seSBzdXBwb3J0cyBkZWxldGluZyBhcnJheSBpbmRpY2VzXCIsXG5cdFx0XHRcdFwiSW1tZXIgb25seSBzdXBwb3J0cyBzZXR0aW5nIGFycmF5IGluZGljZXMgYW5kIHRoZSAnbGVuZ3RoJyBwcm9wZXJ0eVwiLFxuXHRcdFx0XHRmdW5jdGlvbih0aGluZzogc3RyaW5nKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGAnb3JpZ2luYWwnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiAke3RoaW5nfWBcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBOb3RlOiBpZiBtb3JlIGVycm9ycyBhcmUgYWRkZWQsIHRoZSBlcnJvck9mZnNldCBpbiBQYXRjaGVzLnRzIHNob3VsZCBiZSBpbmNyZWFzZWRcblx0XHRcdFx0Ly8gU2VlIFBhdGNoZXMudHMgZm9yIGFkZGl0aW9uYWwgZXJyb3JzXG5cdFx0ICBdXG5cdFx0OiBbXVxuXG5leHBvcnQgZnVuY3Rpb24gZGllKGVycm9yOiBudW1iZXIsIC4uLmFyZ3M6IGFueVtdKTogbmV2ZXIge1xuXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG5cdFx0Y29uc3QgZSA9IGVycm9yc1tlcnJvcl1cblx0XHRjb25zdCBtc2cgPSB0eXBlb2YgZSA9PT0gXCJmdW5jdGlvblwiID8gZS5hcHBseShudWxsLCBhcmdzIGFzIGFueSkgOiBlXG5cdFx0dGhyb3cgbmV3IEVycm9yKGBbSW1tZXJdICR7bXNnfWApXG5cdH1cblx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdGBbSW1tZXJdIG1pbmlmaWVkIGVycm9yIG5yOiAke2Vycm9yfS4gRnVsbCBlcnJvciBhdDogaHR0cHM6Ly9iaXQubHkvM2NYRUtXZmBcblx0KVxufVxuIiwiaW1wb3J0IHtcblx0RFJBRlRfU1RBVEUsXG5cdERSQUZUQUJMRSxcblx0T2JqZWN0aXNoLFxuXHREcmFmdGVkLFxuXHRBbnlPYmplY3QsXG5cdEFueU1hcCxcblx0QW55U2V0LFxuXHRJbW1lclN0YXRlLFxuXHRBcmNoVHlwZSxcblx0ZGllLFxuXHRTdHJpY3RNb2RlXG59IGZyb20gXCIuLi9pbnRlcm5hbFwiXG5cbmV4cG9ydCBjb25zdCBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZlxuXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBJbW1lciBkcmFmdCAqL1xuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRHJhZnQodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiAhIXZhbHVlW0RSQUZUX1NUQVRFXVxufVxuXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBjYW4gYmUgZHJhZnRlZCBieSBJbW1lciAqL1xuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRHJhZnRhYmxlKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcblx0aWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlXG5cdHJldHVybiAoXG5cdFx0aXNQbGFpbk9iamVjdCh2YWx1ZSkgfHxcblx0XHRBcnJheS5pc0FycmF5KHZhbHVlKSB8fFxuXHRcdCEhdmFsdWVbRFJBRlRBQkxFXSB8fFxuXHRcdCEhdmFsdWUuY29uc3RydWN0b3I/LltEUkFGVEFCTEVdIHx8XG5cdFx0aXNNYXAodmFsdWUpIHx8XG5cdFx0aXNTZXQodmFsdWUpXG5cdClcbn1cblxuY29uc3Qgb2JqZWN0Q3RvclN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IudG9TdHJpbmcoKVxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuXHRpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlXG5cdGNvbnN0IHByb3RvID0gZ2V0UHJvdG90eXBlT2YodmFsdWUpXG5cdGlmIChwcm90byA9PT0gbnVsbCkge1xuXHRcdHJldHVybiB0cnVlXG5cdH1cblx0Y29uc3QgQ3RvciA9XG5cdFx0T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3JcblxuXHRpZiAoQ3RvciA9PT0gT2JqZWN0KSByZXR1cm4gdHJ1ZVxuXG5cdHJldHVybiAoXG5cdFx0dHlwZW9mIEN0b3IgPT0gXCJmdW5jdGlvblwiICYmXG5cdFx0RnVuY3Rpb24udG9TdHJpbmcuY2FsbChDdG9yKSA9PT0gb2JqZWN0Q3RvclN0cmluZ1xuXHQpXG59XG5cbi8qKiBHZXQgdGhlIHVuZGVybHlpbmcgb2JqZWN0IHRoYXQgaXMgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIGRyYWZ0ICovXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gb3JpZ2luYWw8VD4odmFsdWU6IFQpOiBUIHwgdW5kZWZpbmVkXG5leHBvcnQgZnVuY3Rpb24gb3JpZ2luYWwodmFsdWU6IERyYWZ0ZWQ8YW55Pik6IGFueSB7XG5cdGlmICghaXNEcmFmdCh2YWx1ZSkpIGRpZSgxNSwgdmFsdWUpXG5cdHJldHVybiB2YWx1ZVtEUkFGVF9TVEFURV0uYmFzZV9cbn1cblxuLyoqXG4gKiBFYWNoIGl0ZXJhdGVzIGEgbWFwLCBzZXQgb3IgYXJyYXkuXG4gKiBPciwgaWYgYW55IG90aGVyIGtpbmQgb2Ygb2JqZWN0LCBhbGwgb2YgaXRzIG93biBwcm9wZXJ0aWVzLlxuICogUmVnYXJkbGVzcyB3aGV0aGVyIHRoZXkgYXJlIGVudW1lcmFibGUgb3Igc3ltYm9sc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZWFjaDxUIGV4dGVuZHMgT2JqZWN0aXNoPihcblx0b2JqOiBULFxuXHRpdGVyOiAoa2V5OiBzdHJpbmcgfCBudW1iZXIsIHZhbHVlOiBhbnksIHNvdXJjZTogVCkgPT4gdm9pZFxuKTogdm9pZFxuZXhwb3J0IGZ1bmN0aW9uIGVhY2gob2JqOiBhbnksIGl0ZXI6IGFueSkge1xuXHRpZiAoZ2V0QXJjaHR5cGUob2JqKSA9PT0gQXJjaFR5cGUuT2JqZWN0KSB7XG5cdFx0UmVmbGVjdC5vd25LZXlzKG9iaikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0aXRlcihrZXksIG9ialtrZXldLCBvYmopXG5cdFx0fSlcblx0fSBlbHNlIHtcblx0XHRvYmouZm9yRWFjaCgoZW50cnk6IGFueSwgaW5kZXg6IGFueSkgPT4gaXRlcihpbmRleCwgZW50cnksIG9iaikpXG5cdH1cbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFyY2h0eXBlKHRoaW5nOiBhbnkpOiBBcmNoVHlwZSB7XG5cdGNvbnN0IHN0YXRlOiB1bmRlZmluZWQgfCBJbW1lclN0YXRlID0gdGhpbmdbRFJBRlRfU1RBVEVdXG5cdHJldHVybiBzdGF0ZVxuXHRcdD8gc3RhdGUudHlwZV9cblx0XHQ6IEFycmF5LmlzQXJyYXkodGhpbmcpXG5cdFx0PyBBcmNoVHlwZS5BcnJheVxuXHRcdDogaXNNYXAodGhpbmcpXG5cdFx0PyBBcmNoVHlwZS5NYXBcblx0XHQ6IGlzU2V0KHRoaW5nKVxuXHRcdD8gQXJjaFR5cGUuU2V0XG5cdFx0OiBBcmNoVHlwZS5PYmplY3Rcbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGhhcyh0aGluZzogYW55LCBwcm9wOiBQcm9wZXJ0eUtleSk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSBBcmNoVHlwZS5NYXBcblx0XHQ/IHRoaW5nLmhhcyhwcm9wKVxuXHRcdDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaW5nLCBwcm9wKVxufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHRoaW5nOiBBbnlNYXAgfCBBbnlPYmplY3QsIHByb3A6IFByb3BlcnR5S2V5KTogYW55IHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRyZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSBBcmNoVHlwZS5NYXAgPyB0aGluZy5nZXQocHJvcCkgOiB0aGluZ1twcm9wXVxufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gc2V0KHRoaW5nOiBhbnksIHByb3BPck9sZFZhbHVlOiBQcm9wZXJ0eUtleSwgdmFsdWU6IGFueSkge1xuXHRjb25zdCB0ID0gZ2V0QXJjaHR5cGUodGhpbmcpXG5cdGlmICh0ID09PSBBcmNoVHlwZS5NYXApIHRoaW5nLnNldChwcm9wT3JPbGRWYWx1ZSwgdmFsdWUpXG5cdGVsc2UgaWYgKHQgPT09IEFyY2hUeXBlLlNldCkge1xuXHRcdHRoaW5nLmFkZCh2YWx1ZSlcblx0fSBlbHNlIHRoaW5nW3Byb3BPck9sZFZhbHVlXSA9IHZhbHVlXG59XG5cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBmdW5jdGlvbiBpcyh4OiBhbnksIHk6IGFueSk6IGJvb2xlYW4ge1xuXHQvLyBGcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2M2OTkwNGE1MTFiOTAwMjY2OTM1MTY4MjIzMDYzZGQ4NzcyZGZjNDAvcGFja2FnZXMvZmJqcy9zcmMvY29yZS9zaGFsbG93RXF1YWwuanNcblx0aWYgKHggPT09IHkpIHtcblx0XHRyZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHlcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5XG5cdH1cbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTWFwKHRhcmdldDogYW55KTogdGFyZ2V0IGlzIEFueU1hcCB7XG5cdHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBNYXBcbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2V0KHRhcmdldDogYW55KTogdGFyZ2V0IGlzIEFueVNldCB7XG5cdHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBTZXRcbn1cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXRlc3Qoc3RhdGU6IEltbWVyU3RhdGUpOiBhbnkge1xuXHRyZXR1cm4gc3RhdGUuY29weV8gfHwgc3RhdGUuYmFzZV9cbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dDb3B5KGJhc2U6IGFueSwgc3RyaWN0OiBTdHJpY3RNb2RlKSB7XG5cdGlmIChpc01hcChiYXNlKSkge1xuXHRcdHJldHVybiBuZXcgTWFwKGJhc2UpXG5cdH1cblx0aWYgKGlzU2V0KGJhc2UpKSB7XG5cdFx0cmV0dXJuIG5ldyBTZXQoYmFzZSlcblx0fVxuXHRpZiAoQXJyYXkuaXNBcnJheShiYXNlKSkgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJhc2UpXG5cblx0Y29uc3QgaXNQbGFpbiA9IGlzUGxhaW5PYmplY3QoYmFzZSlcblxuXHRpZiAoc3RyaWN0ID09PSB0cnVlIHx8IChzdHJpY3QgPT09IFwiY2xhc3Nfb25seVwiICYmICFpc1BsYWluKSkge1xuXHRcdC8vIFBlcmZvcm0gYSBzdHJpY3QgY29weVxuXHRcdGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoYmFzZSlcblx0XHRkZWxldGUgZGVzY3JpcHRvcnNbRFJBRlRfU1RBVEUgYXMgYW55XVxuXHRcdGxldCBrZXlzID0gUmVmbGVjdC5vd25LZXlzKGRlc2NyaXB0b3JzKVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3Qga2V5OiBhbnkgPSBrZXlzW2ldXG5cdFx0XHRjb25zdCBkZXNjID0gZGVzY3JpcHRvcnNba2V5XVxuXHRcdFx0aWYgKGRlc2Mud3JpdGFibGUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGRlc2Mud3JpdGFibGUgPSB0cnVlXG5cdFx0XHRcdGRlc2MuY29uZmlndXJhYmxlID0gdHJ1ZVxuXHRcdFx0fVxuXHRcdFx0Ly8gbGlrZSBvYmplY3QuYXNzaWduLCB3ZSB3aWxsIHJlYWQgYW55IF9vd25fLCBnZXQvc2V0IGFjY2Vzc29ycy4gVGhpcyBoZWxwcyBpbiBkZWFsaW5nXG5cdFx0XHQvLyB3aXRoIGxpYnJhcmllcyB0aGF0IHRyYXAgdmFsdWVzLCBsaWtlIG1vYnggb3IgdnVlXG5cdFx0XHQvLyB1bmxpa2Ugb2JqZWN0LmFzc2lnbiwgbm9uLWVudW1lcmFibGVzIHdpbGwgYmUgY29waWVkIGFzIHdlbGxcblx0XHRcdGlmIChkZXNjLmdldCB8fCBkZXNjLnNldClcblx0XHRcdFx0ZGVzY3JpcHRvcnNba2V5XSA9IHtcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsIC8vIGNvdWxkIGxpdmUgd2l0aCAhIWRlc2Muc2V0IGFzIHdlbGwgaGVyZS4uLlxuXHRcdFx0XHRcdGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcblx0XHRcdFx0XHR2YWx1ZTogYmFzZVtrZXldXG5cdFx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIE9iamVjdC5jcmVhdGUoZ2V0UHJvdG90eXBlT2YoYmFzZSksIGRlc2NyaXB0b3JzKVxuXHR9IGVsc2Uge1xuXHRcdC8vIHBlcmZvcm0gYSBzbG9wcHkgY29weVxuXHRcdGNvbnN0IHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYmFzZSlcblx0XHRpZiAocHJvdG8gIT09IG51bGwgJiYgaXNQbGFpbikge1xuXHRcdFx0cmV0dXJuIHsuLi5iYXNlfSAvLyBhc3N1bXB0aW9uOiBiZXR0ZXIgaW5uZXIgY2xhc3Mgb3B0aW1pemF0aW9uIHRoYW4gdGhlIGFzc2lnbiBiZWxvd1xuXHRcdH1cblx0XHRjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKHByb3RvKVxuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgYmFzZSlcblx0fVxufVxuXG4vKipcbiAqIEZyZWV6ZXMgZHJhZnRhYmxlIG9iamVjdHMuIFJldHVybnMgdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAqIEJ5IGRlZmF1bHQgZnJlZXplcyBzaGFsbG93bHksIGJ1dCBpZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIGB0cnVlYCBpdCB3aWxsIGZyZWV6ZSByZWN1cnNpdmVseS5cbiAqXG4gKiBAcGFyYW0gb2JqXG4gKiBAcGFyYW0gZGVlcFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJlZXplPFQ+KG9iajogVCwgZGVlcD86IGJvb2xlYW4pOiBUXG5leHBvcnQgZnVuY3Rpb24gZnJlZXplPFQ+KG9iajogYW55LCBkZWVwOiBib29sZWFuID0gZmFsc2UpOiBUIHtcblx0aWYgKGlzRnJvemVuKG9iaikgfHwgaXNEcmFmdChvYmopIHx8ICFpc0RyYWZ0YWJsZShvYmopKSByZXR1cm4gb2JqXG5cdGlmIChnZXRBcmNodHlwZShvYmopID4gMSAvKiBNYXAgb3IgU2V0ICovKSB7XG5cdFx0b2JqLnNldCA9IG9iai5hZGQgPSBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zIGFzIGFueVxuXHR9XG5cdE9iamVjdC5mcmVlemUob2JqKVxuXHRpZiAoZGVlcClcblx0XHQvLyBTZWUgIzU5MCwgZG9uJ3QgcmVjdXJzZSBpbnRvIG5vbi1lbnVtZXJhYmxlIC8gU3ltYm9sIHByb3BlcnRpZXMgd2hlbiBmcmVlemluZ1xuXHRcdC8vIFNvIHVzZSBPYmplY3QuZW50cmllcyAob25seSBzdHJpbmctbGlrZSwgZW51bWVyYWJsZXMpIGluc3RlYWQgb2YgZWFjaCgpXG5cdFx0T2JqZWN0LmVudHJpZXMob2JqKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IGZyZWV6ZSh2YWx1ZSwgdHJ1ZSkpXG5cdHJldHVybiBvYmpcbn1cblxuZnVuY3Rpb24gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zKCkge1xuXHRkaWUoMilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRnJvemVuKG9iajogYW55KTogYm9vbGVhbiB7XG5cdHJldHVybiBPYmplY3QuaXNGcm96ZW4ob2JqKVxufVxuIiwiaW1wb3J0IHtcblx0SW1tZXJTdGF0ZSxcblx0UGF0Y2gsXG5cdERyYWZ0ZWQsXG5cdEltbWVyQmFzZVN0YXRlLFxuXHRBbnlNYXAsXG5cdEFueVNldCxcblx0QXJjaFR5cGUsXG5cdGRpZVxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG4vKiogUGx1Z2luIHV0aWxpdGllcyAqL1xuY29uc3QgcGx1Z2luczoge1xuXHRQYXRjaGVzPzoge1xuXHRcdGdlbmVyYXRlUGF0Y2hlc18oXG5cdFx0XHRzdGF0ZTogSW1tZXJTdGF0ZSxcblx0XHRcdGJhc2VQYXRoOiBQYXRjaFBhdGgsXG5cdFx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdFx0aW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0XHQpOiB2b2lkXG5cdFx0Z2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKFxuXHRcdFx0YmFzZTogYW55LFxuXHRcdFx0cmVwbGFjZW1lbnQ6IGFueSxcblx0XHRcdHBhdGNoZXM6IFBhdGNoW10sXG5cdFx0XHRpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHRcdCk6IHZvaWRcblx0XHRhcHBseVBhdGNoZXNfPFQ+KGRyYWZ0OiBULCBwYXRjaGVzOiByZWFkb25seSBQYXRjaFtdKTogVFxuXHR9XG5cdE1hcFNldD86IHtcblx0XHRwcm94eU1hcF88VCBleHRlbmRzIEFueU1hcD4odGFyZ2V0OiBULCBwYXJlbnQ/OiBJbW1lclN0YXRlKTogVFxuXHRcdHByb3h5U2V0XzxUIGV4dGVuZHMgQW55U2V0Pih0YXJnZXQ6IFQsIHBhcmVudD86IEltbWVyU3RhdGUpOiBUXG5cdH1cbn0gPSB7fVxuXG50eXBlIFBsdWdpbnMgPSB0eXBlb2YgcGx1Z2luc1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGx1Z2luPEsgZXh0ZW5kcyBrZXlvZiBQbHVnaW5zPihcblx0cGx1Z2luS2V5OiBLXG4pOiBFeGNsdWRlPFBsdWdpbnNbS10sIHVuZGVmaW5lZD4ge1xuXHRjb25zdCBwbHVnaW4gPSBwbHVnaW5zW3BsdWdpbktleV1cblx0aWYgKCFwbHVnaW4pIHtcblx0XHRkaWUoMCwgcGx1Z2luS2V5KVxuXHR9XG5cdC8vIEB0cy1pZ25vcmVcblx0cmV0dXJuIHBsdWdpblxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZFBsdWdpbjxLIGV4dGVuZHMga2V5b2YgUGx1Z2lucz4oXG5cdHBsdWdpbktleTogSyxcblx0aW1wbGVtZW50YXRpb246IFBsdWdpbnNbS11cbik6IHZvaWQge1xuXHRpZiAoIXBsdWdpbnNbcGx1Z2luS2V5XSkgcGx1Z2luc1twbHVnaW5LZXldID0gaW1wbGVtZW50YXRpb25cbn1cbi8qKiBNYXAgLyBTZXQgcGx1Z2luICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFwU3RhdGUgZXh0ZW5kcyBJbW1lckJhc2VTdGF0ZSB7XG5cdHR5cGVfOiBBcmNoVHlwZS5NYXBcblx0Y29weV86IEFueU1hcCB8IHVuZGVmaW5lZFxuXHRhc3NpZ25lZF86IE1hcDxhbnksIGJvb2xlYW4+IHwgdW5kZWZpbmVkXG5cdGJhc2VfOiBBbnlNYXBcblx0cmV2b2tlZF86IGJvb2xlYW5cblx0ZHJhZnRfOiBEcmFmdGVkPEFueU1hcCwgTWFwU3RhdGU+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0U3RhdGUgZXh0ZW5kcyBJbW1lckJhc2VTdGF0ZSB7XG5cdHR5cGVfOiBBcmNoVHlwZS5TZXRcblx0Y29weV86IEFueVNldCB8IHVuZGVmaW5lZFxuXHRiYXNlXzogQW55U2V0XG5cdGRyYWZ0c186IE1hcDxhbnksIERyYWZ0ZWQ+IC8vIG1hcHMgdGhlIG9yaWdpbmFsIHZhbHVlIHRvIHRoZSBkcmFmdCB2YWx1ZSBpbiB0aGUgbmV3IHNldFxuXHRyZXZva2VkXzogYm9vbGVhblxuXHRkcmFmdF86IERyYWZ0ZWQ8QW55U2V0LCBTZXRTdGF0ZT5cbn1cblxuLyoqIFBhdGNoZXMgcGx1Z2luICovXG5cbmV4cG9ydCB0eXBlIFBhdGNoUGF0aCA9IChzdHJpbmcgfCBudW1iZXIpW11cbiIsImltcG9ydCB7XG5cdFBhdGNoLFxuXHRQYXRjaExpc3RlbmVyLFxuXHREcmFmdGVkLFxuXHRJbW1lcixcblx0RFJBRlRfU1RBVEUsXG5cdEltbWVyU3RhdGUsXG5cdEFyY2hUeXBlLFxuXHRnZXRQbHVnaW5cbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuLyoqIEVhY2ggc2NvcGUgcmVwcmVzZW50cyBhIGBwcm9kdWNlYCBjYWxsLiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIEltbWVyU2NvcGUge1xuXHRwYXRjaGVzXz86IFBhdGNoW11cblx0aW52ZXJzZVBhdGNoZXNfPzogUGF0Y2hbXVxuXHRjYW5BdXRvRnJlZXplXzogYm9vbGVhblxuXHRkcmFmdHNfOiBhbnlbXVxuXHRwYXJlbnRfPzogSW1tZXJTY29wZVxuXHRwYXRjaExpc3RlbmVyXz86IFBhdGNoTGlzdGVuZXJcblx0aW1tZXJfOiBJbW1lclxuXHR1bmZpbmFsaXplZERyYWZ0c186IG51bWJlclxufVxuXG5sZXQgY3VycmVudFNjb3BlOiBJbW1lclNjb3BlIHwgdW5kZWZpbmVkXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG5cdHJldHVybiBjdXJyZW50U2NvcGUhXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjb3BlKFxuXHRwYXJlbnRfOiBJbW1lclNjb3BlIHwgdW5kZWZpbmVkLFxuXHRpbW1lcl86IEltbWVyXG4pOiBJbW1lclNjb3BlIHtcblx0cmV0dXJuIHtcblx0XHRkcmFmdHNfOiBbXSxcblx0XHRwYXJlbnRfLFxuXHRcdGltbWVyXyxcblx0XHQvLyBXaGVuZXZlciB0aGUgbW9kaWZpZWQgZHJhZnQgY29udGFpbnMgYSBkcmFmdCBmcm9tIGFub3RoZXIgc2NvcGUsIHdlXG5cdFx0Ly8gbmVlZCB0byBwcmV2ZW50IGF1dG8tZnJlZXppbmcgc28gdGhlIHVub3duZWQgZHJhZnQgY2FuIGJlIGZpbmFsaXplZC5cblx0XHRjYW5BdXRvRnJlZXplXzogdHJ1ZSxcblx0XHR1bmZpbmFsaXplZERyYWZ0c186IDBcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUGF0Y2hlc0luU2NvcGUoXG5cdHNjb3BlOiBJbW1lclNjb3BlLFxuXHRwYXRjaExpc3RlbmVyPzogUGF0Y2hMaXN0ZW5lclxuKSB7XG5cdGlmIChwYXRjaExpc3RlbmVyKSB7XG5cdFx0Z2V0UGx1Z2luKFwiUGF0Y2hlc1wiKSAvLyBhc3NlcnQgd2UgaGF2ZSB0aGUgcGx1Z2luXG5cdFx0c2NvcGUucGF0Y2hlc18gPSBbXVxuXHRcdHNjb3BlLmludmVyc2VQYXRjaGVzXyA9IFtdXG5cdFx0c2NvcGUucGF0Y2hMaXN0ZW5lcl8gPSBwYXRjaExpc3RlbmVyXG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldm9rZVNjb3BlKHNjb3BlOiBJbW1lclNjb3BlKSB7XG5cdGxlYXZlU2NvcGUoc2NvcGUpXG5cdHNjb3BlLmRyYWZ0c18uZm9yRWFjaChyZXZva2VEcmFmdClcblx0Ly8gQHRzLWlnbm9yZVxuXHRzY29wZS5kcmFmdHNfID0gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVhdmVTY29wZShzY29wZTogSW1tZXJTY29wZSkge1xuXHRpZiAoc2NvcGUgPT09IGN1cnJlbnRTY29wZSkge1xuXHRcdGN1cnJlbnRTY29wZSA9IHNjb3BlLnBhcmVudF9cblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZW50ZXJTY29wZShpbW1lcjogSW1tZXIpIHtcblx0cmV0dXJuIChjdXJyZW50U2NvcGUgPSBjcmVhdGVTY29wZShjdXJyZW50U2NvcGUsIGltbWVyKSlcbn1cblxuZnVuY3Rpb24gcmV2b2tlRHJhZnQoZHJhZnQ6IERyYWZ0ZWQpIHtcblx0Y29uc3Qgc3RhdGU6IEltbWVyU3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV1cblx0aWYgKHN0YXRlLnR5cGVfID09PSBBcmNoVHlwZS5PYmplY3QgfHwgc3RhdGUudHlwZV8gPT09IEFyY2hUeXBlLkFycmF5KVxuXHRcdHN0YXRlLnJldm9rZV8oKVxuXHRlbHNlIHN0YXRlLnJldm9rZWRfID0gdHJ1ZVxufVxuIiwiaW1wb3J0IHtcblx0SW1tZXJTY29wZSxcblx0RFJBRlRfU1RBVEUsXG5cdGlzRHJhZnRhYmxlLFxuXHROT1RISU5HLFxuXHRQYXRjaFBhdGgsXG5cdGVhY2gsXG5cdGhhcyxcblx0ZnJlZXplLFxuXHRJbW1lclN0YXRlLFxuXHRpc0RyYWZ0LFxuXHRTZXRTdGF0ZSxcblx0c2V0LFxuXHRBcmNoVHlwZSxcblx0Z2V0UGx1Z2luLFxuXHRkaWUsXG5cdHJldm9rZVNjb3BlLFxuXHRpc0Zyb3plblxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1Jlc3VsdChyZXN1bHQ6IGFueSwgc2NvcGU6IEltbWVyU2NvcGUpIHtcblx0c2NvcGUudW5maW5hbGl6ZWREcmFmdHNfID0gc2NvcGUuZHJhZnRzXy5sZW5ndGhcblx0Y29uc3QgYmFzZURyYWZ0ID0gc2NvcGUuZHJhZnRzXyFbMF1cblx0Y29uc3QgaXNSZXBsYWNlZCA9IHJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdCAhPT0gYmFzZURyYWZ0XG5cdGlmIChpc1JlcGxhY2VkKSB7XG5cdFx0aWYgKGJhc2VEcmFmdFtEUkFGVF9TVEFURV0ubW9kaWZpZWRfKSB7XG5cdFx0XHRyZXZva2VTY29wZShzY29wZSlcblx0XHRcdGRpZSg0KVxuXHRcdH1cblx0XHRpZiAoaXNEcmFmdGFibGUocmVzdWx0KSkge1xuXHRcdFx0Ly8gRmluYWxpemUgdGhlIHJlc3VsdCBpbiBjYXNlIGl0IGNvbnRhaW5zIChvciBpcykgYSBzdWJzZXQgb2YgdGhlIGRyYWZ0LlxuXHRcdFx0cmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIHJlc3VsdClcblx0XHRcdGlmICghc2NvcGUucGFyZW50XykgbWF5YmVGcmVlemUoc2NvcGUsIHJlc3VsdClcblx0XHR9XG5cdFx0aWYgKHNjb3BlLnBhdGNoZXNfKSB7XG5cdFx0XHRnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhcblx0XHRcdFx0YmFzZURyYWZ0W0RSQUZUX1NUQVRFXS5iYXNlXyxcblx0XHRcdFx0cmVzdWx0LFxuXHRcdFx0XHRzY29wZS5wYXRjaGVzXyxcblx0XHRcdFx0c2NvcGUuaW52ZXJzZVBhdGNoZXNfIVxuXHRcdFx0KVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBGaW5hbGl6ZSB0aGUgYmFzZSBkcmFmdC5cblx0XHRyZXN1bHQgPSBmaW5hbGl6ZShzY29wZSwgYmFzZURyYWZ0LCBbXSlcblx0fVxuXHRyZXZva2VTY29wZShzY29wZSlcblx0aWYgKHNjb3BlLnBhdGNoZXNfKSB7XG5cdFx0c2NvcGUucGF0Y2hMaXN0ZW5lcl8hKHNjb3BlLnBhdGNoZXNfLCBzY29wZS5pbnZlcnNlUGF0Y2hlc18hKVxuXHR9XG5cdHJldHVybiByZXN1bHQgIT09IE5PVEhJTkcgPyByZXN1bHQgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gZmluYWxpemUocm9vdFNjb3BlOiBJbW1lclNjb3BlLCB2YWx1ZTogYW55LCBwYXRoPzogUGF0Y2hQYXRoKSB7XG5cdC8vIERvbid0IHJlY3Vyc2UgaW4gdGhvIHJlY3Vyc2l2ZSBkYXRhIHN0cnVjdHVyZXNcblx0aWYgKGlzRnJvemVuKHZhbHVlKSkgcmV0dXJuIHZhbHVlXG5cblx0Y29uc3Qgc3RhdGU6IEltbWVyU3RhdGUgPSB2YWx1ZVtEUkFGVF9TVEFURV1cblx0Ly8gQSBwbGFpbiBvYmplY3QsIG1pZ2h0IG5lZWQgZnJlZXppbmcsIG1pZ2h0IGNvbnRhaW4gZHJhZnRzXG5cdGlmICghc3RhdGUpIHtcblx0XHRlYWNoKHZhbHVlLCAoa2V5LCBjaGlsZFZhbHVlKSA9PlxuXHRcdFx0ZmluYWxpemVQcm9wZXJ0eShyb290U2NvcGUsIHN0YXRlLCB2YWx1ZSwga2V5LCBjaGlsZFZhbHVlLCBwYXRoKVxuXHRcdClcblx0XHRyZXR1cm4gdmFsdWVcblx0fVxuXHQvLyBOZXZlciBmaW5hbGl6ZSBkcmFmdHMgb3duZWQgYnkgYW5vdGhlciBzY29wZS5cblx0aWYgKHN0YXRlLnNjb3BlXyAhPT0gcm9vdFNjb3BlKSByZXR1cm4gdmFsdWVcblx0Ly8gVW5tb2RpZmllZCBkcmFmdCwgcmV0dXJuIHRoZSAoZnJvemVuKSBvcmlnaW5hbFxuXHRpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuXHRcdG1heWJlRnJlZXplKHJvb3RTY29wZSwgc3RhdGUuYmFzZV8sIHRydWUpXG5cdFx0cmV0dXJuIHN0YXRlLmJhc2VfXG5cdH1cblx0Ly8gTm90IGZpbmFsaXplZCB5ZXQsIGxldCdzIGRvIHRoYXQgbm93XG5cdGlmICghc3RhdGUuZmluYWxpemVkXykge1xuXHRcdHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlXG5cdFx0c3RhdGUuc2NvcGVfLnVuZmluYWxpemVkRHJhZnRzXy0tXG5cdFx0Y29uc3QgcmVzdWx0ID0gc3RhdGUuY29weV9cblx0XHQvLyBGaW5hbGl6ZSBhbGwgY2hpbGRyZW4gb2YgdGhlIGNvcHlcblx0XHQvLyBGb3Igc2V0cyB3ZSBjbG9uZSBiZWZvcmUgaXRlcmF0aW5nLCBvdGhlcndpc2Ugd2UgY2FuIGdldCBpbiBlbmRsZXNzIGxvb3AgZHVlIHRvIG1vZGlmeWluZyBkdXJpbmcgaXRlcmF0aW9uLCBzZWUgIzYyOFxuXHRcdC8vIFRvIHByZXNlcnZlIGluc2VydGlvbiBvcmRlciBpbiBhbGwgY2FzZXMgd2UgdGhlbiBjbGVhciB0aGUgc2V0XG5cdFx0Ly8gQW5kIHdlIGxldCBmaW5hbGl6ZVByb3BlcnR5IGtub3cgaXQgbmVlZHMgdG8gcmUtYWRkIG5vbi1kcmFmdCBjaGlsZHJlbiBiYWNrIHRvIHRoZSB0YXJnZXRcblx0XHRsZXQgcmVzdWx0RWFjaCA9IHJlc3VsdFxuXHRcdGxldCBpc1NldCA9IGZhbHNlXG5cdFx0aWYgKHN0YXRlLnR5cGVfID09PSBBcmNoVHlwZS5TZXQpIHtcblx0XHRcdHJlc3VsdEVhY2ggPSBuZXcgU2V0KHJlc3VsdClcblx0XHRcdHJlc3VsdC5jbGVhcigpXG5cdFx0XHRpc1NldCA9IHRydWVcblx0XHR9XG5cdFx0ZWFjaChyZXN1bHRFYWNoLCAoa2V5LCBjaGlsZFZhbHVlKSA9PlxuXHRcdFx0ZmluYWxpemVQcm9wZXJ0eShyb290U2NvcGUsIHN0YXRlLCByZXN1bHQsIGtleSwgY2hpbGRWYWx1ZSwgcGF0aCwgaXNTZXQpXG5cdFx0KVxuXHRcdC8vIGV2ZXJ5dGhpbmcgaW5zaWRlIGlzIGZyb3plbiwgd2UgY2FuIGZyZWV6ZSBoZXJlXG5cdFx0bWF5YmVGcmVlemUocm9vdFNjb3BlLCByZXN1bHQsIGZhbHNlKVxuXHRcdC8vIGZpcnN0IHRpbWUgZmluYWxpemluZywgbGV0J3MgY3JlYXRlIHRob3NlIHBhdGNoZXNcblx0XHRpZiAocGF0aCAmJiByb290U2NvcGUucGF0Y2hlc18pIHtcblx0XHRcdGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVQYXRjaGVzXyhcblx0XHRcdFx0c3RhdGUsXG5cdFx0XHRcdHBhdGgsXG5cdFx0XHRcdHJvb3RTY29wZS5wYXRjaGVzXyxcblx0XHRcdFx0cm9vdFNjb3BlLmludmVyc2VQYXRjaGVzXyFcblx0XHRcdClcblx0XHR9XG5cdH1cblx0cmV0dXJuIHN0YXRlLmNvcHlfXG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplUHJvcGVydHkoXG5cdHJvb3RTY29wZTogSW1tZXJTY29wZSxcblx0cGFyZW50U3RhdGU6IHVuZGVmaW5lZCB8IEltbWVyU3RhdGUsXG5cdHRhcmdldE9iamVjdDogYW55LFxuXHRwcm9wOiBzdHJpbmcgfCBudW1iZXIsXG5cdGNoaWxkVmFsdWU6IGFueSxcblx0cm9vdFBhdGg/OiBQYXRjaFBhdGgsXG5cdHRhcmdldElzU2V0PzogYm9vbGVhblxuKSB7XG5cdGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY2hpbGRWYWx1ZSA9PT0gdGFyZ2V0T2JqZWN0KVxuXHRcdGRpZSg1KVxuXHRpZiAoaXNEcmFmdChjaGlsZFZhbHVlKSkge1xuXHRcdGNvbnN0IHBhdGggPVxuXHRcdFx0cm9vdFBhdGggJiZcblx0XHRcdHBhcmVudFN0YXRlICYmXG5cdFx0XHRwYXJlbnRTdGF0ZSEudHlwZV8gIT09IEFyY2hUeXBlLlNldCAmJiAvLyBTZXQgb2JqZWN0cyBhcmUgYXRvbWljIHNpbmNlIHRoZXkgaGF2ZSBubyBrZXlzLlxuXHRcdFx0IWhhcygocGFyZW50U3RhdGUgYXMgRXhjbHVkZTxJbW1lclN0YXRlLCBTZXRTdGF0ZT4pLmFzc2lnbmVkXyEsIHByb3ApIC8vIFNraXAgZGVlcCBwYXRjaGVzIGZvciBhc3NpZ25lZCBrZXlzLlxuXHRcdFx0XHQ/IHJvb3RQYXRoIS5jb25jYXQocHJvcClcblx0XHRcdFx0OiB1bmRlZmluZWRcblx0XHQvLyBEcmFmdHMgb3duZWQgYnkgYHNjb3BlYCBhcmUgZmluYWxpemVkIGhlcmUuXG5cdFx0Y29uc3QgcmVzID0gZmluYWxpemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlLCBwYXRoKVxuXHRcdHNldCh0YXJnZXRPYmplY3QsIHByb3AsIHJlcylcblx0XHQvLyBEcmFmdHMgZnJvbSBhbm90aGVyIHNjb3BlIG11c3QgcHJldmVudGVkIHRvIGJlIGZyb3plblxuXHRcdC8vIGlmIHdlIGdvdCBhIGRyYWZ0IGJhY2sgZnJvbSBmaW5hbGl6ZSwgd2UncmUgaW4gYSBuZXN0ZWQgcHJvZHVjZSBhbmQgc2hvdWxkbid0IGZyZWV6ZVxuXHRcdGlmIChpc0RyYWZ0KHJlcykpIHtcblx0XHRcdHJvb3RTY29wZS5jYW5BdXRvRnJlZXplXyA9IGZhbHNlXG5cdFx0fSBlbHNlIHJldHVyblxuXHR9IGVsc2UgaWYgKHRhcmdldElzU2V0KSB7XG5cdFx0dGFyZ2V0T2JqZWN0LmFkZChjaGlsZFZhbHVlKVxuXHR9XG5cdC8vIFNlYXJjaCBuZXcgb2JqZWN0cyBmb3IgdW5maW5hbGl6ZWQgZHJhZnRzLiBGcm96ZW4gb2JqZWN0cyBzaG91bGQgbmV2ZXIgY29udGFpbiBkcmFmdHMuXG5cdGlmIChpc0RyYWZ0YWJsZShjaGlsZFZhbHVlKSAmJiAhaXNGcm96ZW4oY2hpbGRWYWx1ZSkpIHtcblx0XHRpZiAoIXJvb3RTY29wZS5pbW1lcl8uYXV0b0ZyZWV6ZV8gJiYgcm9vdFNjb3BlLnVuZmluYWxpemVkRHJhZnRzXyA8IDEpIHtcblx0XHRcdC8vIG9wdGltaXphdGlvbjogaWYgYW4gb2JqZWN0IGlzIG5vdCBhIGRyYWZ0LCBhbmQgd2UgZG9uJ3QgaGF2ZSB0b1xuXHRcdFx0Ly8gZGVlcGZyZWV6ZSBldmVyeXRoaW5nLCBhbmQgd2UgYXJlIHN1cmUgdGhhdCBubyBkcmFmdHMgYXJlIGxlZnQgaW4gdGhlIHJlbWFpbmluZyBvYmplY3Rcblx0XHRcdC8vIGNhdXNlIHdlIHNhdyBhbmQgZmluYWxpemVkIGFsbCBkcmFmdHMgYWxyZWFkeTsgd2UgY2FuIHN0b3AgdmlzaXRpbmcgdGhlIHJlc3Qgb2YgdGhlIHRyZWUuXG5cdFx0XHQvLyBUaGlzIGJlbmVmaXRzIGVzcGVjaWFsbHkgYWRkaW5nIGxhcmdlIGRhdGEgdHJlZSdzIHdpdGhvdXQgZnVydGhlciBwcm9jZXNzaW5nLlxuXHRcdFx0Ly8gU2VlIGFkZC1kYXRhLmpzIHBlcmYgdGVzdFxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGZpbmFsaXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSlcblx0XHQvLyBJbW1lciBkZWVwIGZyZWV6ZXMgcGxhaW4gb2JqZWN0cywgc28gaWYgdGhlcmUgaXMgbm8gcGFyZW50IHN0YXRlLCB3ZSBmcmVlemUgYXMgd2VsbFxuXHRcdC8vIFBlciAjNTkwLCB3ZSBuZXZlciBmcmVlemUgc3ltYm9saWMgcHJvcGVydGllcy4gSnVzdCB0byBtYWtlIHN1cmUgZG9uJ3QgYWNjaWRlbnRhbGx5IGludGVyZmVyZVxuXHRcdC8vIHdpdGggb3RoZXIgZnJhbWV3b3Jrcy5cblx0XHRpZiAoXG5cdFx0XHQoIXBhcmVudFN0YXRlIHx8ICFwYXJlbnRTdGF0ZS5zY29wZV8ucGFyZW50XykgJiZcblx0XHRcdHR5cGVvZiBwcm9wICE9PSBcInN5bWJvbFwiICYmXG5cdFx0XHRPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0T2JqZWN0LCBwcm9wKVxuXHRcdClcblx0XHRcdG1heWJlRnJlZXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSlcblx0fVxufVxuXG5mdW5jdGlvbiBtYXliZUZyZWV6ZShzY29wZTogSW1tZXJTY29wZSwgdmFsdWU6IGFueSwgZGVlcCA9IGZhbHNlKSB7XG5cdC8vIHdlIG5ldmVyIGZyZWV6ZSBmb3IgYSBub24tcm9vdCBzY29wZTsgYXMgaXQgd291bGQgcHJldmVudCBwcnVuaW5nIGZvciBkcmFmdHMgaW5zaWRlIHdyYXBwaW5nIG9iamVjdHNcblx0aWYgKCFzY29wZS5wYXJlbnRfICYmIHNjb3BlLmltbWVyXy5hdXRvRnJlZXplXyAmJiBzY29wZS5jYW5BdXRvRnJlZXplXykge1xuXHRcdGZyZWV6ZSh2YWx1ZSwgZGVlcClcblx0fVxufVxuIiwiaW1wb3J0IHtcblx0ZWFjaCxcblx0aGFzLFxuXHRpcyxcblx0aXNEcmFmdGFibGUsXG5cdHNoYWxsb3dDb3B5LFxuXHRsYXRlc3QsXG5cdEltbWVyQmFzZVN0YXRlLFxuXHRJbW1lclN0YXRlLFxuXHREcmFmdGVkLFxuXHRBbnlPYmplY3QsXG5cdEFueUFycmF5LFxuXHRPYmplY3Rpc2gsXG5cdGdldEN1cnJlbnRTY29wZSxcblx0Z2V0UHJvdG90eXBlT2YsXG5cdERSQUZUX1NUQVRFLFxuXHRkaWUsXG5cdGNyZWF0ZVByb3h5LFxuXHRBcmNoVHlwZSxcblx0SW1tZXJTY29wZVxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG5pbnRlcmZhY2UgUHJveHlCYXNlU3RhdGUgZXh0ZW5kcyBJbW1lckJhc2VTdGF0ZSB7XG5cdGFzc2lnbmVkXzoge1xuXHRcdFtwcm9wZXJ0eTogc3RyaW5nXTogYm9vbGVhblxuXHR9XG5cdHBhcmVudF8/OiBJbW1lclN0YXRlXG5cdHJldm9rZV8oKTogdm9pZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb3h5T2JqZWN0U3RhdGUgZXh0ZW5kcyBQcm94eUJhc2VTdGF0ZSB7XG5cdHR5cGVfOiBBcmNoVHlwZS5PYmplY3Rcblx0YmFzZV86IGFueVxuXHRjb3B5XzogYW55XG5cdGRyYWZ0XzogRHJhZnRlZDxBbnlPYmplY3QsIFByb3h5T2JqZWN0U3RhdGU+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJveHlBcnJheVN0YXRlIGV4dGVuZHMgUHJveHlCYXNlU3RhdGUge1xuXHR0eXBlXzogQXJjaFR5cGUuQXJyYXlcblx0YmFzZV86IEFueUFycmF5XG5cdGNvcHlfOiBBbnlBcnJheSB8IG51bGxcblx0ZHJhZnRfOiBEcmFmdGVkPEFueUFycmF5LCBQcm94eUFycmF5U3RhdGU+XG59XG5cbnR5cGUgUHJveHlTdGF0ZSA9IFByb3h5T2JqZWN0U3RhdGUgfCBQcm94eUFycmF5U3RhdGVcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGRyYWZ0IG9mIHRoZSBgYmFzZWAgb2JqZWN0LlxuICpcbiAqIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgdGhlIHBhcmVudCBkcmFmdC1zdGF0ZSAodXNlZCBpbnRlcm5hbGx5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVByb3h5UHJveHk8VCBleHRlbmRzIE9iamVjdGlzaD4oXG5cdGJhc2U6IFQsXG5cdHBhcmVudD86IEltbWVyU3RhdGVcbik6IERyYWZ0ZWQ8VCwgUHJveHlTdGF0ZT4ge1xuXHRjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShiYXNlKVxuXHRjb25zdCBzdGF0ZTogUHJveHlTdGF0ZSA9IHtcblx0XHR0eXBlXzogaXNBcnJheSA/IEFyY2hUeXBlLkFycmF5IDogKEFyY2hUeXBlLk9iamVjdCBhcyBhbnkpLFxuXHRcdC8vIFRyYWNrIHdoaWNoIHByb2R1Y2UgY2FsbCB0aGlzIGlzIGFzc29jaWF0ZWQgd2l0aC5cblx0XHRzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSEsXG5cdFx0Ly8gVHJ1ZSBmb3IgYm90aCBzaGFsbG93IGFuZCBkZWVwIGNoYW5nZXMuXG5cdFx0bW9kaWZpZWRfOiBmYWxzZSxcblx0XHQvLyBVc2VkIGR1cmluZyBmaW5hbGl6YXRpb24uXG5cdFx0ZmluYWxpemVkXzogZmFsc2UsXG5cdFx0Ly8gVHJhY2sgd2hpY2ggcHJvcGVydGllcyBoYXZlIGJlZW4gYXNzaWduZWQgKHRydWUpIG9yIGRlbGV0ZWQgKGZhbHNlKS5cblx0XHRhc3NpZ25lZF86IHt9LFxuXHRcdC8vIFRoZSBwYXJlbnQgZHJhZnQgc3RhdGUuXG5cdFx0cGFyZW50XzogcGFyZW50LFxuXHRcdC8vIFRoZSBiYXNlIHN0YXRlLlxuXHRcdGJhc2VfOiBiYXNlLFxuXHRcdC8vIFRoZSBiYXNlIHByb3h5LlxuXHRcdGRyYWZ0XzogbnVsbCBhcyBhbnksIC8vIHNldCBiZWxvd1xuXHRcdC8vIFRoZSBiYXNlIGNvcHkgd2l0aCBhbnkgdXBkYXRlZCB2YWx1ZXMuXG5cdFx0Y29weV86IG51bGwsXG5cdFx0Ly8gQ2FsbGVkIGJ5IHRoZSBgcHJvZHVjZWAgZnVuY3Rpb24uXG5cdFx0cmV2b2tlXzogbnVsbCBhcyBhbnksXG5cdFx0aXNNYW51YWxfOiBmYWxzZVxuXHR9XG5cblx0Ly8gdGhlIHRyYXBzIG11c3QgdGFyZ2V0IHNvbWV0aGluZywgYSBiaXQgbGlrZSB0aGUgJ3JlYWwnIGJhc2UuXG5cdC8vIGJ1dCBhbHNvLCB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gZGV0ZXJtaW5lIGZyb20gdGhlIHRhcmdldCB3aGF0IHRoZSByZWxldmFudCBzdGF0ZSBpc1xuXHQvLyAodG8gYXZvaWQgY3JlYXRpbmcgdHJhcHMgcGVyIGluc3RhbmNlIHRvIGNhcHR1cmUgdGhlIHN0YXRlIGluIGNsb3N1cmUsXG5cdC8vIGFuZCB0byBhdm9pZCBjcmVhdGluZyB3ZWlyZCBoaWRkZW4gcHJvcGVydGllcyBhcyB3ZWxsKVxuXHQvLyBTbyB0aGUgdHJpY2sgaXMgdG8gdXNlICdzdGF0ZScgYXMgdGhlIGFjdHVhbCAndGFyZ2V0JyEgKGFuZCBtYWtlIHN1cmUgd2UgaW50ZXJjZXB0IGV2ZXJ5dGhpbmcpXG5cdC8vIE5vdGUgdGhhdCBpbiB0aGUgY2FzZSBvZiBhbiBhcnJheSwgd2UgcHV0IHRoZSBzdGF0ZSBpbiBhbiBhcnJheSB0byBoYXZlIGJldHRlciBSZWZsZWN0IGRlZmF1bHRzIG9vdGJcblx0bGV0IHRhcmdldDogVCA9IHN0YXRlIGFzIGFueVxuXHRsZXQgdHJhcHM6IFByb3h5SGFuZGxlcjxvYmplY3QgfCBBcnJheTxhbnk+PiA9IG9iamVjdFRyYXBzXG5cdGlmIChpc0FycmF5KSB7XG5cdFx0dGFyZ2V0ID0gW3N0YXRlXSBhcyBhbnlcblx0XHR0cmFwcyA9IGFycmF5VHJhcHNcblx0fVxuXG5cdGNvbnN0IHtyZXZva2UsIHByb3h5fSA9IFByb3h5LnJldm9jYWJsZSh0YXJnZXQsIHRyYXBzKVxuXHRzdGF0ZS5kcmFmdF8gPSBwcm94eSBhcyBhbnlcblx0c3RhdGUucmV2b2tlXyA9IHJldm9rZVxuXHRyZXR1cm4gcHJveHkgYXMgYW55XG59XG5cbi8qKlxuICogT2JqZWN0IGRyYWZ0c1xuICovXG5leHBvcnQgY29uc3Qgb2JqZWN0VHJhcHM6IFByb3h5SGFuZGxlcjxQcm94eVN0YXRlPiA9IHtcblx0Z2V0KHN0YXRlLCBwcm9wKSB7XG5cdFx0aWYgKHByb3AgPT09IERSQUZUX1NUQVRFKSByZXR1cm4gc3RhdGVcblxuXHRcdGNvbnN0IHNvdXJjZSA9IGxhdGVzdChzdGF0ZSlcblx0XHRpZiAoIWhhcyhzb3VyY2UsIHByb3ApKSB7XG5cdFx0XHQvLyBub24tZXhpc3Rpbmcgb3Igbm9uLW93biBwcm9wZXJ0eS4uLlxuXHRcdFx0cmV0dXJuIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlLCBzb3VyY2UsIHByb3ApXG5cdFx0fVxuXHRcdGNvbnN0IHZhbHVlID0gc291cmNlW3Byb3BdXG5cdFx0aWYgKHN0YXRlLmZpbmFsaXplZF8gfHwgIWlzRHJhZnRhYmxlKHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0fVxuXHRcdC8vIENoZWNrIGZvciBleGlzdGluZyBkcmFmdCBpbiBtb2RpZmllZCBzdGF0ZS5cblx0XHQvLyBBc3NpZ25lZCB2YWx1ZXMgYXJlIG5ldmVyIGRyYWZ0ZWQuIFRoaXMgY2F0Y2hlcyBhbnkgZHJhZnRzIHdlIGNyZWF0ZWQsIHRvby5cblx0XHRpZiAodmFsdWUgPT09IHBlZWsoc3RhdGUuYmFzZV8sIHByb3ApKSB7XG5cdFx0XHRwcmVwYXJlQ29weShzdGF0ZSlcblx0XHRcdHJldHVybiAoc3RhdGUuY29weV8hW3Byb3AgYXMgYW55XSA9IGNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSkpXG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZVxuXHR9LFxuXHRoYXMoc3RhdGUsIHByb3ApIHtcblx0XHRyZXR1cm4gcHJvcCBpbiBsYXRlc3Qoc3RhdGUpXG5cdH0sXG5cdG93bktleXMoc3RhdGUpIHtcblx0XHRyZXR1cm4gUmVmbGVjdC5vd25LZXlzKGxhdGVzdChzdGF0ZSkpXG5cdH0sXG5cdHNldChcblx0XHRzdGF0ZTogUHJveHlPYmplY3RTdGF0ZSxcblx0XHRwcm9wOiBzdHJpbmcgLyogc3RyaWN0bHkgbm90LCBidXQgaGVscHMgVFMgKi8sXG5cdFx0dmFsdWVcblx0KSB7XG5cdFx0Y29uc3QgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8obGF0ZXN0KHN0YXRlKSwgcHJvcClcblx0XHRpZiAoZGVzYz8uc2V0KSB7XG5cdFx0XHQvLyBzcGVjaWFsIGNhc2U6IGlmIHRoaXMgd3JpdGUgaXMgY2FwdHVyZWQgYnkgYSBzZXR0ZXIsIHdlIGhhdmVcblx0XHRcdC8vIHRvIHRyaWdnZXIgaXQgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG5cdFx0XHRkZXNjLnNldC5jYWxsKHN0YXRlLmRyYWZ0XywgdmFsdWUpXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblx0XHRpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuXHRcdFx0Ly8gdGhlIGxhc3QgY2hlY2sgaXMgYmVjYXVzZSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggc2V0dGluZyBhIG5vbi1leGlzdGluZyB0byB1bmRlZmluZWQgKHdoaWNoIGlzIGEgY2hhbmdlKVxuXHRcdFx0Ly8gZnJvbSBzZXR0aW5nIGFuIGV4aXN0aW5nIHByb3BlcnR5IHdpdGggdmFsdWUgdW5kZWZpbmVkIHRvIHVuZGVmaW5lZCAod2hpY2ggaXMgbm90IGEgY2hhbmdlKVxuXHRcdFx0Y29uc3QgY3VycmVudCA9IHBlZWsobGF0ZXN0KHN0YXRlKSwgcHJvcClcblx0XHRcdC8vIHNwZWNpYWwgY2FzZSwgaWYgd2UgYXNzaWduaW5nIHRoZSBvcmlnaW5hbCB2YWx1ZSB0byBhIGRyYWZ0LCB3ZSBjYW4gaWdub3JlIHRoZSBhc3NpZ25tZW50XG5cdFx0XHRjb25zdCBjdXJyZW50U3RhdGU6IFByb3h5T2JqZWN0U3RhdGUgPSBjdXJyZW50Py5bRFJBRlRfU1RBVEVdXG5cdFx0XHRpZiAoY3VycmVudFN0YXRlICYmIGN1cnJlbnRTdGF0ZS5iYXNlXyA9PT0gdmFsdWUpIHtcblx0XHRcdFx0c3RhdGUuY29weV8hW3Byb3BdID0gdmFsdWVcblx0XHRcdFx0c3RhdGUuYXNzaWduZWRfW3Byb3BdID0gZmFsc2Vcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHRcdGlmIChpcyh2YWx1ZSwgY3VycmVudCkgJiYgKHZhbHVlICE9PSB1bmRlZmluZWQgfHwgaGFzKHN0YXRlLmJhc2VfLCBwcm9wKSkpXG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHRwcmVwYXJlQ29weShzdGF0ZSlcblx0XHRcdG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdChzdGF0ZS5jb3B5XyFbcHJvcF0gPT09IHZhbHVlICYmXG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FzZTogaGFuZGxlIG5ldyBwcm9wcyB3aXRoIHZhbHVlICd1bmRlZmluZWQnXG5cdFx0XHRcdCh2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IHByb3AgaW4gc3RhdGUuY29weV8pKSB8fFxuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlOiBOYU5cblx0XHRcdChOdW1iZXIuaXNOYU4odmFsdWUpICYmIE51bWJlci5pc05hTihzdGF0ZS5jb3B5XyFbcHJvcF0pKVxuXHRcdClcblx0XHRcdHJldHVybiB0cnVlXG5cblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0c3RhdGUuY29weV8hW3Byb3BdID0gdmFsdWVcblx0XHRzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSB0cnVlXG5cdFx0cmV0dXJuIHRydWVcblx0fSxcblx0ZGVsZXRlUHJvcGVydHkoc3RhdGUsIHByb3A6IHN0cmluZykge1xuXHRcdC8vIFRoZSBgdW5kZWZpbmVkYCBjaGVjayBpcyBhIGZhc3QgcGF0aCBmb3IgcHJlLWV4aXN0aW5nIGtleXMuXG5cdFx0aWYgKHBlZWsoc3RhdGUuYmFzZV8sIHByb3ApICE9PSB1bmRlZmluZWQgfHwgcHJvcCBpbiBzdGF0ZS5iYXNlXykge1xuXHRcdFx0c3RhdGUuYXNzaWduZWRfW3Byb3BdID0gZmFsc2Vcblx0XHRcdHByZXBhcmVDb3B5KHN0YXRlKVxuXHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGlmIGFuIG9yaWdpbmFsbHkgbm90IGFzc2lnbmVkIHByb3BlcnR5IHdhcyBkZWxldGVkXG5cdFx0XHRkZWxldGUgc3RhdGUuYXNzaWduZWRfW3Byb3BdXG5cdFx0fVxuXHRcdGlmIChzdGF0ZS5jb3B5Xykge1xuXHRcdFx0ZGVsZXRlIHN0YXRlLmNvcHlfW3Byb3BdXG5cdFx0fVxuXHRcdHJldHVybiB0cnVlXG5cdH0sXG5cdC8vIE5vdGU6IFdlIG5ldmVyIGNvZXJjZSBgZGVzYy52YWx1ZWAgaW50byBhbiBJbW1lciBkcmFmdCwgYmVjYXVzZSB3ZSBjYW4ndCBtYWtlXG5cdC8vIHRoZSBzYW1lIGd1YXJhbnRlZSBpbiBFUzUgbW9kZS5cblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHN0YXRlLCBwcm9wKSB7XG5cdFx0Y29uc3Qgb3duZXIgPSBsYXRlc3Qoc3RhdGUpXG5cdFx0Y29uc3QgZGVzYyA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG93bmVyLCBwcm9wKVxuXHRcdGlmICghZGVzYykgcmV0dXJuIGRlc2Ncblx0XHRyZXR1cm4ge1xuXHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHN0YXRlLnR5cGVfICE9PSBBcmNoVHlwZS5BcnJheSB8fCBwcm9wICE9PSBcImxlbmd0aFwiLFxuXHRcdFx0ZW51bWVyYWJsZTogZGVzYy5lbnVtZXJhYmxlLFxuXHRcdFx0dmFsdWU6IG93bmVyW3Byb3BdXG5cdFx0fVxuXHR9LFxuXHRkZWZpbmVQcm9wZXJ0eSgpIHtcblx0XHRkaWUoMTEpXG5cdH0sXG5cdGdldFByb3RvdHlwZU9mKHN0YXRlKSB7XG5cdFx0cmV0dXJuIGdldFByb3RvdHlwZU9mKHN0YXRlLmJhc2VfKVxuXHR9LFxuXHRzZXRQcm90b3R5cGVPZigpIHtcblx0XHRkaWUoMTIpXG5cdH1cbn1cblxuLyoqXG4gKiBBcnJheSBkcmFmdHNcbiAqL1xuXG5jb25zdCBhcnJheVRyYXBzOiBQcm94eUhhbmRsZXI8W1Byb3h5QXJyYXlTdGF0ZV0+ID0ge31cbmVhY2gob2JqZWN0VHJhcHMsIChrZXksIGZuKSA9PiB7XG5cdC8vIEB0cy1pZ25vcmVcblx0YXJyYXlUcmFwc1trZXldID0gZnVuY3Rpb24oKSB7XG5cdFx0YXJndW1lbnRzWzBdID0gYXJndW1lbnRzWzBdWzBdXG5cdFx0cmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblx0fVxufSlcbmFycmF5VHJhcHMuZGVsZXRlUHJvcGVydHkgPSBmdW5jdGlvbihzdGF0ZSwgcHJvcCkge1xuXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzTmFOKHBhcnNlSW50KHByb3AgYXMgYW55KSkpXG5cdFx0ZGllKDEzKVxuXHQvLyBAdHMtaWdub3JlXG5cdHJldHVybiBhcnJheVRyYXBzLnNldCEuY2FsbCh0aGlzLCBzdGF0ZSwgcHJvcCwgdW5kZWZpbmVkKVxufVxuYXJyYXlUcmFwcy5zZXQgPSBmdW5jdGlvbihzdGF0ZSwgcHJvcCwgdmFsdWUpIHtcblx0aWYgKFxuXHRcdHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJlxuXHRcdHByb3AgIT09IFwibGVuZ3RoXCIgJiZcblx0XHRpc05hTihwYXJzZUludChwcm9wIGFzIGFueSkpXG5cdClcblx0XHRkaWUoMTQpXG5cdHJldHVybiBvYmplY3RUcmFwcy5zZXQhLmNhbGwodGhpcywgc3RhdGVbMF0sIHByb3AsIHZhbHVlLCBzdGF0ZVswXSlcbn1cblxuLy8gQWNjZXNzIGEgcHJvcGVydHkgd2l0aG91dCBjcmVhdGluZyBhbiBJbW1lciBkcmFmdC5cbmZ1bmN0aW9uIHBlZWsoZHJhZnQ6IERyYWZ0ZWQsIHByb3A6IFByb3BlcnR5S2V5KSB7XG5cdGNvbnN0IHN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdXG5cdGNvbnN0IHNvdXJjZSA9IHN0YXRlID8gbGF0ZXN0KHN0YXRlKSA6IGRyYWZ0XG5cdHJldHVybiBzb3VyY2VbcHJvcF1cbn1cblxuZnVuY3Rpb24gcmVhZFByb3BGcm9tUHJvdG8oc3RhdGU6IEltbWVyU3RhdGUsIHNvdXJjZTogYW55LCBwcm9wOiBQcm9wZXJ0eUtleSkge1xuXHRjb25zdCBkZXNjID0gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhzb3VyY2UsIHByb3ApXG5cdHJldHVybiBkZXNjXG5cdFx0PyBgdmFsdWVgIGluIGRlc2Ncblx0XHRcdD8gZGVzYy52YWx1ZVxuXHRcdFx0OiAvLyBUaGlzIGlzIGEgdmVyeSBzcGVjaWFsIGNhc2UsIGlmIHRoZSBwcm9wIGlzIGEgZ2V0dGVyIGRlZmluZWQgYnkgdGhlXG5cdFx0XHQgIC8vIHByb3RvdHlwZSwgd2Ugc2hvdWxkIGludm9rZSBpdCB3aXRoIHRoZSBkcmFmdCBhcyBjb250ZXh0IVxuXHRcdFx0ICBkZXNjLmdldD8uY2FsbChzdGF0ZS5kcmFmdF8pXG5cdFx0OiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhcblx0c291cmNlOiBhbnksXG5cdHByb3A6IFByb3BlcnR5S2V5XG4pOiBQcm9wZXJ0eURlc2NyaXB0b3IgfCB1bmRlZmluZWQge1xuXHQvLyAnaW4nIGNoZWNrcyBwcm90byFcblx0aWYgKCEocHJvcCBpbiBzb3VyY2UpKSByZXR1cm4gdW5kZWZpbmVkXG5cdGxldCBwcm90byA9IGdldFByb3RvdHlwZU9mKHNvdXJjZSlcblx0d2hpbGUgKHByb3RvKSB7XG5cdFx0Y29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIHByb3ApXG5cdFx0aWYgKGRlc2MpIHJldHVybiBkZXNjXG5cdFx0cHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90bylcblx0fVxuXHRyZXR1cm4gdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXJrQ2hhbmdlZChzdGF0ZTogSW1tZXJTdGF0ZSkge1xuXHRpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuXHRcdHN0YXRlLm1vZGlmaWVkXyA9IHRydWVcblx0XHRpZiAoc3RhdGUucGFyZW50Xykge1xuXHRcdFx0bWFya0NoYW5nZWQoc3RhdGUucGFyZW50Xylcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVDb3B5KHN0YXRlOiB7XG5cdGJhc2VfOiBhbnlcblx0Y29weV86IGFueVxuXHRzY29wZV86IEltbWVyU2NvcGVcbn0pIHtcblx0aWYgKCFzdGF0ZS5jb3B5Xykge1xuXHRcdHN0YXRlLmNvcHlfID0gc2hhbGxvd0NvcHkoXG5cdFx0XHRzdGF0ZS5iYXNlXyxcblx0XHRcdHN0YXRlLnNjb3BlXy5pbW1lcl8udXNlU3RyaWN0U2hhbGxvd0NvcHlfXG5cdFx0KVxuXHR9XG59XG4iLCJpbXBvcnQge1xuXHRJUHJvZHVjZVdpdGhQYXRjaGVzLFxuXHRJUHJvZHVjZSxcblx0SW1tZXJTdGF0ZSxcblx0RHJhZnRlZCxcblx0aXNEcmFmdGFibGUsXG5cdHByb2Nlc3NSZXN1bHQsXG5cdFBhdGNoLFxuXHRPYmplY3Rpc2gsXG5cdERSQUZUX1NUQVRFLFxuXHREcmFmdCxcblx0UGF0Y2hMaXN0ZW5lcixcblx0aXNEcmFmdCxcblx0aXNNYXAsXG5cdGlzU2V0LFxuXHRjcmVhdGVQcm94eVByb3h5LFxuXHRnZXRQbHVnaW4sXG5cdGRpZSxcblx0ZW50ZXJTY29wZSxcblx0cmV2b2tlU2NvcGUsXG5cdGxlYXZlU2NvcGUsXG5cdHVzZVBhdGNoZXNJblNjb3BlLFxuXHRnZXRDdXJyZW50U2NvcGUsXG5cdE5PVEhJTkcsXG5cdGZyZWV6ZSxcblx0Y3VycmVudFxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG5pbnRlcmZhY2UgUHJvZHVjZXJzRm5zIHtcblx0cHJvZHVjZTogSVByb2R1Y2Vcblx0cHJvZHVjZVdpdGhQYXRjaGVzOiBJUHJvZHVjZVdpdGhQYXRjaGVzXG59XG5cbmV4cG9ydCB0eXBlIFN0cmljdE1vZGUgPSBib29sZWFuIHwgXCJjbGFzc19vbmx5XCI7XG5cbmV4cG9ydCBjbGFzcyBJbW1lciBpbXBsZW1lbnRzIFByb2R1Y2Vyc0ZucyB7XG5cdGF1dG9GcmVlemVfOiBib29sZWFuID0gdHJ1ZVxuXHR1c2VTdHJpY3RTaGFsbG93Q29weV86IFN0cmljdE1vZGUgPSBmYWxzZVxuXG5cdGNvbnN0cnVjdG9yKGNvbmZpZz86IHtcblx0XHRhdXRvRnJlZXplPzogYm9vbGVhblxuXHRcdHVzZVN0cmljdFNoYWxsb3dDb3B5PzogU3RyaWN0TW9kZVxuXHR9KSB7XG5cdFx0aWYgKHR5cGVvZiBjb25maWc/LmF1dG9GcmVlemUgPT09IFwiYm9vbGVhblwiKVxuXHRcdFx0dGhpcy5zZXRBdXRvRnJlZXplKGNvbmZpZyEuYXV0b0ZyZWV6ZSlcblx0XHRpZiAodHlwZW9mIGNvbmZpZz8udXNlU3RyaWN0U2hhbGxvd0NvcHkgPT09IFwiYm9vbGVhblwiKVxuXHRcdFx0dGhpcy5zZXRVc2VTdHJpY3RTaGFsbG93Q29weShjb25maWchLnVzZVN0cmljdFNoYWxsb3dDb3B5KVxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHJvZHVjZWAgZnVuY3Rpb24gdGFrZXMgYSB2YWx1ZSBhbmQgYSBcInJlY2lwZSBmdW5jdGlvblwiICh3aG9zZVxuXHQgKiByZXR1cm4gdmFsdWUgb2Z0ZW4gZGVwZW5kcyBvbiB0aGUgYmFzZSBzdGF0ZSkuIFRoZSByZWNpcGUgZnVuY3Rpb24gaXNcblx0ICogZnJlZSB0byBtdXRhdGUgaXRzIGZpcnN0IGFyZ3VtZW50IGhvd2V2ZXIgaXQgd2FudHMuIEFsbCBtdXRhdGlvbnMgYXJlXG5cdCAqIG9ubHkgZXZlciBhcHBsaWVkIHRvIGEgX19jb3B5X18gb2YgdGhlIGJhc2Ugc3RhdGUuXG5cdCAqXG5cdCAqIFBhc3Mgb25seSBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIFwiY3VycmllZCBwcm9kdWNlclwiIHdoaWNoIHJlbGlldmVzIHlvdVxuXHQgKiBmcm9tIHBhc3NpbmcgdGhlIHJlY2lwZSBmdW5jdGlvbiBldmVyeSB0aW1lLlxuXHQgKlxuXHQgKiBPbmx5IHBsYWluIG9iamVjdHMgYW5kIGFycmF5cyBhcmUgbWFkZSBtdXRhYmxlLiBBbGwgb3RoZXIgb2JqZWN0cyBhcmVcblx0ICogY29uc2lkZXJlZCB1bmNvcHlhYmxlLlxuXHQgKlxuXHQgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIF9fYm91bmRfXyB0byBpdHMgYEltbWVyYCBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHthbnl9IGJhc2UgLSB0aGUgaW5pdGlhbCBzdGF0ZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWNpcGUgLSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcHJveHkgb2YgdGhlIGJhc2Ugc3RhdGUgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHdoaWNoIGNhbiBiZSBmcmVlbHkgbW9kaWZpZWRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gcGF0Y2hMaXN0ZW5lciAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdGhlIHBhdGNoZXMgcHJvZHVjZWQgaGVyZVxuXHQgKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcblx0ICovXG5cdHByb2R1Y2U6IElQcm9kdWNlID0gKGJhc2U6IGFueSwgcmVjaXBlPzogYW55LCBwYXRjaExpc3RlbmVyPzogYW55KSA9PiB7XG5cdFx0Ly8gY3VycmllZCBpbnZvY2F0aW9uXG5cdFx0aWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHJlY2lwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRjb25zdCBkZWZhdWx0QmFzZSA9IHJlY2lwZVxuXHRcdFx0cmVjaXBlID0gYmFzZVxuXG5cdFx0XHRjb25zdCBzZWxmID0gdGhpc1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGN1cnJpZWRQcm9kdWNlKFxuXHRcdFx0XHR0aGlzOiBhbnksXG5cdFx0XHRcdGJhc2UgPSBkZWZhdWx0QmFzZSxcblx0XHRcdFx0Li4uYXJnczogYW55W11cblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gc2VsZi5wcm9kdWNlKGJhc2UsIChkcmFmdDogRHJhZnRlZCkgPT4gcmVjaXBlLmNhbGwodGhpcywgZHJhZnQsIC4uLmFyZ3MpKSAvLyBwcmV0dGllci1pZ25vcmVcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIHJlY2lwZSAhPT0gXCJmdW5jdGlvblwiKSBkaWUoNilcblx0XHRpZiAocGF0Y2hMaXN0ZW5lciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwYXRjaExpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpXG5cdFx0XHRkaWUoNylcblxuXHRcdGxldCByZXN1bHRcblxuXHRcdC8vIE9ubHkgcGxhaW4gb2JqZWN0cywgYXJyYXlzLCBhbmQgXCJpbW1lcmFibGUgY2xhc3Nlc1wiIGFyZSBkcmFmdGVkLlxuXHRcdGlmIChpc0RyYWZ0YWJsZShiYXNlKSkge1xuXHRcdFx0Y29uc3Qgc2NvcGUgPSBlbnRlclNjb3BlKHRoaXMpXG5cdFx0XHRjb25zdCBwcm94eSA9IGNyZWF0ZVByb3h5KGJhc2UsIHVuZGVmaW5lZClcblx0XHRcdGxldCBoYXNFcnJvciA9IHRydWVcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJlc3VsdCA9IHJlY2lwZShwcm94eSlcblx0XHRcdFx0aGFzRXJyb3IgPSBmYWxzZVxuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0Ly8gZmluYWxseSBpbnN0ZWFkIG9mIGNhdGNoICsgcmV0aHJvdyBiZXR0ZXIgcHJlc2VydmVzIG9yaWdpbmFsIHN0YWNrXG5cdFx0XHRcdGlmIChoYXNFcnJvcikgcmV2b2tlU2NvcGUoc2NvcGUpXG5cdFx0XHRcdGVsc2UgbGVhdmVTY29wZShzY29wZSlcblx0XHRcdH1cblx0XHRcdHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKVxuXHRcdFx0cmV0dXJuIHByb2Nlc3NSZXN1bHQocmVzdWx0LCBzY29wZSlcblx0XHR9IGVsc2UgaWYgKCFiYXNlIHx8IHR5cGVvZiBiYXNlICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRyZXN1bHQgPSByZWNpcGUoYmFzZSlcblx0XHRcdGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkgcmVzdWx0ID0gYmFzZVxuXHRcdFx0aWYgKHJlc3VsdCA9PT0gTk9USElORykgcmVzdWx0ID0gdW5kZWZpbmVkXG5cdFx0XHRpZiAodGhpcy5hdXRvRnJlZXplXykgZnJlZXplKHJlc3VsdCwgdHJ1ZSlcblx0XHRcdGlmIChwYXRjaExpc3RlbmVyKSB7XG5cdFx0XHRcdGNvbnN0IHA6IFBhdGNoW10gPSBbXVxuXHRcdFx0XHRjb25zdCBpcDogUGF0Y2hbXSA9IFtdXG5cdFx0XHRcdGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKGJhc2UsIHJlc3VsdCwgcCwgaXApXG5cdFx0XHRcdHBhdGNoTGlzdGVuZXIocCwgaXApXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdFx0fSBlbHNlIGRpZSgxLCBiYXNlKVxuXHR9XG5cblx0cHJvZHVjZVdpdGhQYXRjaGVzOiBJUHJvZHVjZVdpdGhQYXRjaGVzID0gKGJhc2U6IGFueSwgcmVjaXBlPzogYW55KTogYW55ID0+IHtcblx0XHQvLyBjdXJyaWVkIGludm9jYXRpb25cblx0XHRpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0cmV0dXJuIChzdGF0ZTogYW55LCAuLi5hcmdzOiBhbnlbXSkgPT5cblx0XHRcdFx0dGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMoc3RhdGUsIChkcmFmdDogYW55KSA9PiBiYXNlKGRyYWZ0LCAuLi5hcmdzKSlcblx0XHR9XG5cblx0XHRsZXQgcGF0Y2hlczogUGF0Y2hbXSwgaW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0XHRjb25zdCByZXN1bHQgPSB0aGlzLnByb2R1Y2UoYmFzZSwgcmVjaXBlLCAocDogUGF0Y2hbXSwgaXA6IFBhdGNoW10pID0+IHtcblx0XHRcdHBhdGNoZXMgPSBwXG5cdFx0XHRpbnZlcnNlUGF0Y2hlcyA9IGlwXG5cdFx0fSlcblx0XHRyZXR1cm4gW3Jlc3VsdCwgcGF0Y2hlcyEsIGludmVyc2VQYXRjaGVzIV1cblx0fVxuXG5cdGNyZWF0ZURyYWZ0PFQgZXh0ZW5kcyBPYmplY3Rpc2g+KGJhc2U6IFQpOiBEcmFmdDxUPiB7XG5cdFx0aWYgKCFpc0RyYWZ0YWJsZShiYXNlKSkgZGllKDgpXG5cdFx0aWYgKGlzRHJhZnQoYmFzZSkpIGJhc2UgPSBjdXJyZW50KGJhc2UpXG5cdFx0Y29uc3Qgc2NvcGUgPSBlbnRlclNjb3BlKHRoaXMpXG5cdFx0Y29uc3QgcHJveHkgPSBjcmVhdGVQcm94eShiYXNlLCB1bmRlZmluZWQpXG5cdFx0cHJveHlbRFJBRlRfU1RBVEVdLmlzTWFudWFsXyA9IHRydWVcblx0XHRsZWF2ZVNjb3BlKHNjb3BlKVxuXHRcdHJldHVybiBwcm94eSBhcyBhbnlcblx0fVxuXG5cdGZpbmlzaERyYWZ0PEQgZXh0ZW5kcyBEcmFmdDxhbnk+Pihcblx0XHRkcmFmdDogRCxcblx0XHRwYXRjaExpc3RlbmVyPzogUGF0Y2hMaXN0ZW5lclxuXHQpOiBEIGV4dGVuZHMgRHJhZnQ8aW5mZXIgVD4gPyBUIDogbmV2ZXIge1xuXHRcdGNvbnN0IHN0YXRlOiBJbW1lclN0YXRlID0gZHJhZnQgJiYgKGRyYWZ0IGFzIGFueSlbRFJBRlRfU1RBVEVdXG5cdFx0aWYgKCFzdGF0ZSB8fCAhc3RhdGUuaXNNYW51YWxfKSBkaWUoOSlcblx0XHRjb25zdCB7c2NvcGVfOiBzY29wZX0gPSBzdGF0ZVxuXHRcdHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKVxuXHRcdHJldHVybiBwcm9jZXNzUmVzdWx0KHVuZGVmaW5lZCwgc2NvcGUpXG5cdH1cblxuXHQvKipcblx0ICogUGFzcyB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgZnJlZXplIGFsbCBjb3BpZXMgY3JlYXRlZCBieSBJbW1lci5cblx0ICpcblx0ICogQnkgZGVmYXVsdCwgYXV0by1mcmVlemluZyBpcyBlbmFibGVkLlxuXHQgKi9cblx0c2V0QXV0b0ZyZWV6ZSh2YWx1ZTogYm9vbGVhbikge1xuXHRcdHRoaXMuYXV0b0ZyZWV6ZV8gPSB2YWx1ZVxuXHR9XG5cblx0LyoqXG5cdCAqIFBhc3MgdHJ1ZSB0byBlbmFibGUgc3RyaWN0IHNoYWxsb3cgY29weS5cblx0ICpcblx0ICogQnkgZGVmYXVsdCwgaW1tZXIgZG9lcyBub3QgY29weSB0aGUgb2JqZWN0IGRlc2NyaXB0b3JzIHN1Y2ggYXMgZ2V0dGVyLCBzZXR0ZXIgYW5kIG5vbi1lbnVtcmFibGUgcHJvcGVydGllcy5cblx0ICovXG5cdHNldFVzZVN0cmljdFNoYWxsb3dDb3B5KHZhbHVlOiBTdHJpY3RNb2RlKSB7XG5cdFx0dGhpcy51c2VTdHJpY3RTaGFsbG93Q29weV8gPSB2YWx1ZVxuXHR9XG5cblx0YXBwbHlQYXRjaGVzPFQgZXh0ZW5kcyBPYmplY3Rpc2g+KGJhc2U6IFQsIHBhdGNoZXM6IHJlYWRvbmx5IFBhdGNoW10pOiBUIHtcblx0XHQvLyBJZiBhIHBhdGNoIHJlcGxhY2VzIHRoZSBlbnRpcmUgc3RhdGUsIHRha2UgdGhhdCByZXBsYWNlbWVudCBhcyBiYXNlXG5cdFx0Ly8gYmVmb3JlIGFwcGx5aW5nIHBhdGNoZXNcblx0XHRsZXQgaTogbnVtYmVyXG5cdFx0Zm9yIChpID0gcGF0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0Y29uc3QgcGF0Y2ggPSBwYXRjaGVzW2ldXG5cdFx0XHRpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDAgJiYgcGF0Y2gub3AgPT09IFwicmVwbGFjZVwiKSB7XG5cdFx0XHRcdGJhc2UgPSBwYXRjaC52YWx1ZVxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBJZiB0aGVyZSB3YXMgYSBwYXRjaCB0aGF0IHJlcGxhY2VkIHRoZSBlbnRpcmUgc3RhdGUsIHN0YXJ0IGZyb20gdGhlXG5cdFx0Ly8gcGF0Y2ggYWZ0ZXIgdGhhdC5cblx0XHRpZiAoaSA+IC0xKSB7XG5cdFx0XHRwYXRjaGVzID0gcGF0Y2hlcy5zbGljZShpICsgMSlcblx0XHR9XG5cblx0XHRjb25zdCBhcHBseVBhdGNoZXNJbXBsID0gZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5hcHBseVBhdGNoZXNfXG5cdFx0aWYgKGlzRHJhZnQoYmFzZSkpIHtcblx0XHRcdC8vIE4uQjogbmV2ZXIgaGl0cyBpZiBzb21lIHBhdGNoIGEgcmVwbGFjZW1lbnQsIHBhdGNoZXMgYXJlIG5ldmVyIGRyYWZ0c1xuXHRcdFx0cmV0dXJuIGFwcGx5UGF0Y2hlc0ltcGwoYmFzZSwgcGF0Y2hlcylcblx0XHR9XG5cdFx0Ly8gT3RoZXJ3aXNlLCBwcm9kdWNlIGEgY29weSBvZiB0aGUgYmFzZSBzdGF0ZS5cblx0XHRyZXR1cm4gdGhpcy5wcm9kdWNlKGJhc2UsIChkcmFmdDogRHJhZnRlZCkgPT5cblx0XHRcdGFwcGx5UGF0Y2hlc0ltcGwoZHJhZnQsIHBhdGNoZXMpXG5cdFx0KVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm94eTxUIGV4dGVuZHMgT2JqZWN0aXNoPihcblx0dmFsdWU6IFQsXG5cdHBhcmVudD86IEltbWVyU3RhdGVcbik6IERyYWZ0ZWQ8VCwgSW1tZXJTdGF0ZT4ge1xuXHQvLyBwcmVjb25kaXRpb246IGNyZWF0ZVByb3h5IHNob3VsZCBiZSBndWFyZGVkIGJ5IGlzRHJhZnRhYmxlLCBzbyB3ZSBrbm93IHdlIGNhbiBzYWZlbHkgZHJhZnRcblx0Y29uc3QgZHJhZnQ6IERyYWZ0ZWQgPSBpc01hcCh2YWx1ZSlcblx0XHQ/IGdldFBsdWdpbihcIk1hcFNldFwiKS5wcm94eU1hcF8odmFsdWUsIHBhcmVudClcblx0XHQ6IGlzU2V0KHZhbHVlKVxuXHRcdD8gZ2V0UGx1Z2luKFwiTWFwU2V0XCIpLnByb3h5U2V0Xyh2YWx1ZSwgcGFyZW50KVxuXHRcdDogY3JlYXRlUHJveHlQcm94eSh2YWx1ZSwgcGFyZW50KVxuXG5cdGNvbnN0IHNjb3BlID0gcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpXG5cdHNjb3BlLmRyYWZ0c18ucHVzaChkcmFmdClcblx0cmV0dXJuIGRyYWZ0XG59XG4iLCJpbXBvcnQge1xuXHRkaWUsXG5cdGlzRHJhZnQsXG5cdHNoYWxsb3dDb3B5LFxuXHRlYWNoLFxuXHREUkFGVF9TVEFURSxcblx0c2V0LFxuXHRJbW1lclN0YXRlLFxuXHRpc0RyYWZ0YWJsZSxcblx0aXNGcm96ZW5cbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuLyoqIFRha2VzIGEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYSBkcmFmdCBhbmQgZmluYWxpemVzIGl0IChidXQgd2l0aG91dCBmcmVlemluZykuIFRoaXMgaXMgYSBncmVhdCB1dGlsaXR5IHRvIHByaW50IHRoZSBjdXJyZW50IHN0YXRlIGR1cmluZyBkZWJ1Z2dpbmcgKG5vIFByb3hpZXMgaW4gdGhlIHdheSkuIFRoZSBvdXRwdXQgb2YgY3VycmVudCBjYW4gYWxzbyBiZSBzYWZlbHkgbGVha2VkIG91dHNpZGUgdGhlIHByb2R1Y2VyLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1cnJlbnQ8VD4odmFsdWU6IFQpOiBUXG5leHBvcnQgZnVuY3Rpb24gY3VycmVudCh2YWx1ZTogYW55KTogYW55IHtcblx0aWYgKCFpc0RyYWZ0KHZhbHVlKSkgZGllKDEwLCB2YWx1ZSlcblx0cmV0dXJuIGN1cnJlbnRJbXBsKHZhbHVlKVxufVxuXG5mdW5jdGlvbiBjdXJyZW50SW1wbCh2YWx1ZTogYW55KTogYW55IHtcblx0aWYgKCFpc0RyYWZ0YWJsZSh2YWx1ZSkgfHwgaXNGcm96ZW4odmFsdWUpKSByZXR1cm4gdmFsdWVcblx0Y29uc3Qgc3RhdGU6IEltbWVyU3RhdGUgfCB1bmRlZmluZWQgPSB2YWx1ZVtEUkFGVF9TVEFURV1cblx0bGV0IGNvcHk6IGFueVxuXHRpZiAoc3RhdGUpIHtcblx0XHRpZiAoIXN0YXRlLm1vZGlmaWVkXykgcmV0dXJuIHN0YXRlLmJhc2VfXG5cdFx0Ly8gT3B0aW1pemF0aW9uOiBhdm9pZCBnZW5lcmF0aW5nIG5ldyBkcmFmdHMgZHVyaW5nIGNvcHlpbmdcblx0XHRzdGF0ZS5maW5hbGl6ZWRfID0gdHJ1ZVxuXHRcdGNvcHkgPSBzaGFsbG93Q29weSh2YWx1ZSwgc3RhdGUuc2NvcGVfLmltbWVyXy51c2VTdHJpY3RTaGFsbG93Q29weV8pXG5cdH0gZWxzZSB7XG5cdFx0Y29weSA9IHNoYWxsb3dDb3B5KHZhbHVlLCB0cnVlKVxuXHR9XG5cdC8vIHJlY3Vyc2Vcblx0ZWFjaChjb3B5LCAoa2V5LCBjaGlsZFZhbHVlKSA9PiB7XG5cdFx0c2V0KGNvcHksIGtleSwgY3VycmVudEltcGwoY2hpbGRWYWx1ZSkpXG5cdH0pXG5cdGlmIChzdGF0ZSkge1xuXHRcdHN0YXRlLmZpbmFsaXplZF8gPSBmYWxzZVxuXHR9XG5cdHJldHVybiBjb3B5XG59XG4iLCJpbXBvcnQge2ltbWVyYWJsZX0gZnJvbSBcIi4uL2ltbWVyXCJcbmltcG9ydCB7XG5cdEltbWVyU3RhdGUsXG5cdFBhdGNoLFxuXHRTZXRTdGF0ZSxcblx0UHJveHlBcnJheVN0YXRlLFxuXHRNYXBTdGF0ZSxcblx0UHJveHlPYmplY3RTdGF0ZSxcblx0UGF0Y2hQYXRoLFxuXHRnZXQsXG5cdGVhY2gsXG5cdGhhcyxcblx0Z2V0QXJjaHR5cGUsXG5cdGdldFByb3RvdHlwZU9mLFxuXHRpc1NldCxcblx0aXNNYXAsXG5cdGxvYWRQbHVnaW4sXG5cdEFyY2hUeXBlLFxuXHRkaWUsXG5cdGlzRHJhZnQsXG5cdGlzRHJhZnRhYmxlLFxuXHROT1RISU5HLFxuXHRlcnJvcnNcbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZVBhdGNoZXMoKSB7XG5cdGNvbnN0IGVycm9yT2Zmc2V0ID0gMTZcblx0aWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuXHRcdGVycm9ycy5wdXNoKFxuXHRcdFx0J1NldHMgY2Fubm90IGhhdmUgXCJyZXBsYWNlXCIgcGF0Y2hlcy4nLFxuXHRcdFx0ZnVuY3Rpb24ob3A6IHN0cmluZykge1xuXHRcdFx0XHRyZXR1cm4gXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiICsgb3Bcblx0XHRcdH0sXG5cdFx0XHRmdW5jdGlvbihwYXRoOiBzdHJpbmcpIHtcblx0XHRcdFx0cmV0dXJuIFwiQ2Fubm90IGFwcGx5IHBhdGNoLCBwYXRoIGRvZXNuJ3QgcmVzb2x2ZTogXCIgKyBwYXRoXG5cdFx0XHR9LFxuXHRcdFx0XCJQYXRjaGluZyByZXNlcnZlZCBhdHRyaWJ1dGVzIGxpa2UgX19wcm90b19fLCBwcm90b3R5cGUgYW5kIGNvbnN0cnVjdG9yIGlzIG5vdCBhbGxvd2VkXCJcblx0XHQpXG5cdH1cblxuXHRjb25zdCBSRVBMQUNFID0gXCJyZXBsYWNlXCJcblx0Y29uc3QgQUREID0gXCJhZGRcIlxuXHRjb25zdCBSRU1PVkUgPSBcInJlbW92ZVwiXG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVQYXRjaGVzXyhcblx0XHRzdGF0ZTogSW1tZXJTdGF0ZSxcblx0XHRiYXNlUGF0aDogUGF0Y2hQYXRoLFxuXHRcdHBhdGNoZXM6IFBhdGNoW10sXG5cdFx0aW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0KTogdm9pZCB7XG5cdFx0c3dpdGNoIChzdGF0ZS50eXBlXykge1xuXHRcdFx0Y2FzZSBBcmNoVHlwZS5PYmplY3Q6XG5cdFx0XHRjYXNlIEFyY2hUeXBlLk1hcDpcblx0XHRcdFx0cmV0dXJuIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChcblx0XHRcdFx0XHRzdGF0ZSxcblx0XHRcdFx0XHRiYXNlUGF0aCxcblx0XHRcdFx0XHRwYXRjaGVzLFxuXHRcdFx0XHRcdGludmVyc2VQYXRjaGVzXG5cdFx0XHRcdClcblx0XHRcdGNhc2UgQXJjaFR5cGUuQXJyYXk6XG5cdFx0XHRcdHJldHVybiBnZW5lcmF0ZUFycmF5UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKVxuXHRcdFx0Y2FzZSBBcmNoVHlwZS5TZXQ6XG5cdFx0XHRcdHJldHVybiBnZW5lcmF0ZVNldFBhdGNoZXMoXG5cdFx0XHRcdFx0KHN0YXRlIGFzIGFueSkgYXMgU2V0U3RhdGUsXG5cdFx0XHRcdFx0YmFzZVBhdGgsXG5cdFx0XHRcdFx0cGF0Y2hlcyxcblx0XHRcdFx0XHRpbnZlcnNlUGF0Y2hlc1xuXHRcdFx0XHQpXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVBcnJheVBhdGNoZXMoXG5cdFx0c3RhdGU6IFByb3h5QXJyYXlTdGF0ZSxcblx0XHRiYXNlUGF0aDogUGF0Y2hQYXRoLFxuXHRcdHBhdGNoZXM6IFBhdGNoW10sXG5cdFx0aW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0KSB7XG5cdFx0bGV0IHtiYXNlXywgYXNzaWduZWRffSA9IHN0YXRlXG5cdFx0bGV0IGNvcHlfID0gc3RhdGUuY29weV8hXG5cblx0XHQvLyBSZWR1Y2UgY29tcGxleGl0eSBieSBlbnN1cmluZyBgYmFzZWAgaXMgbmV2ZXIgbG9uZ2VyLlxuXHRcdGlmIChjb3B5Xy5sZW5ndGggPCBiYXNlXy5sZW5ndGgpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdDtbYmFzZV8sIGNvcHlfXSA9IFtjb3B5XywgYmFzZV9dXG5cdFx0XHQ7W3BhdGNoZXMsIGludmVyc2VQYXRjaGVzXSA9IFtpbnZlcnNlUGF0Y2hlcywgcGF0Y2hlc11cblx0XHR9XG5cblx0XHQvLyBQcm9jZXNzIHJlcGxhY2VkIGluZGljZXMuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBiYXNlXy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGFzc2lnbmVkX1tpXSAmJiBjb3B5X1tpXSAhPT0gYmFzZV9baV0pIHtcblx0XHRcdFx0Y29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pXG5cdFx0XHRcdHBhdGNoZXMucHVzaCh7XG5cdFx0XHRcdFx0b3A6IFJFUExBQ0UsXG5cdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHQvLyBOZWVkIHRvIG1heWJlIGNsb25lIGl0LCBhcyBpdCBjYW4gaW4gZmFjdCBiZSB0aGUgb3JpZ2luYWwgdmFsdWVcblx0XHRcdFx0XHQvLyBkdWUgdG8gdGhlIGJhc2UvY29weSBpbnZlcnNpb24gYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb25cblx0XHRcdFx0XHR2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXG5cdFx0XHRcdH0pXG5cdFx0XHRcdGludmVyc2VQYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRcdG9wOiBSRVBMQUNFLFxuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0dmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGJhc2VfW2ldKVxuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByb2Nlc3MgYWRkZWQgaW5kaWNlcy5cblx0XHRmb3IgKGxldCBpID0gYmFzZV8ubGVuZ3RoOyBpIDwgY29weV8ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKVxuXHRcdFx0cGF0Y2hlcy5wdXNoKHtcblx0XHRcdFx0b3A6IEFERCxcblx0XHRcdFx0cGF0aCxcblx0XHRcdFx0Ly8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG5cdFx0XHRcdC8vIGR1ZSB0byB0aGUgYmFzZS9jb3B5IGludmVyc2lvbiBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvblxuXHRcdFx0XHR2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXG5cdFx0XHR9KVxuXHRcdH1cblx0XHRmb3IgKGxldCBpID0gY29weV8ubGVuZ3RoIC0gMTsgYmFzZV8ubGVuZ3RoIDw9IGk7IC0taSkge1xuXHRcdFx0Y29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pXG5cdFx0XHRpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcblx0XHRcdFx0b3A6IFJFTU9WRSxcblx0XHRcdFx0cGF0aFxuXHRcdFx0fSlcblx0XHR9XG5cdH1cblxuXHQvLyBUaGlzIGlzIHVzZWQgZm9yIGJvdGggTWFwIG9iamVjdHMgYW5kIG5vcm1hbCBvYmplY3RzLlxuXHRmdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQoXG5cdFx0c3RhdGU6IE1hcFN0YXRlIHwgUHJveHlPYmplY3RTdGF0ZSxcblx0XHRiYXNlUGF0aDogUGF0Y2hQYXRoLFxuXHRcdHBhdGNoZXM6IFBhdGNoW10sXG5cdFx0aW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0KSB7XG5cdFx0Y29uc3Qge2Jhc2VfLCBjb3B5X30gPSBzdGF0ZVxuXHRcdGVhY2goc3RhdGUuYXNzaWduZWRfISwgKGtleSwgYXNzaWduZWRWYWx1ZSkgPT4ge1xuXHRcdFx0Y29uc3Qgb3JpZ1ZhbHVlID0gZ2V0KGJhc2VfLCBrZXkpXG5cdFx0XHRjb25zdCB2YWx1ZSA9IGdldChjb3B5XyEsIGtleSlcblx0XHRcdGNvbnN0IG9wID0gIWFzc2lnbmVkVmFsdWUgPyBSRU1PVkUgOiBoYXMoYmFzZV8sIGtleSkgPyBSRVBMQUNFIDogQUREXG5cdFx0XHRpZiAob3JpZ1ZhbHVlID09PSB2YWx1ZSAmJiBvcCA9PT0gUkVQTEFDRSkgcmV0dXJuXG5cdFx0XHRjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KGtleSBhcyBhbnkpXG5cdFx0XHRwYXRjaGVzLnB1c2gob3AgPT09IFJFTU9WRSA/IHtvcCwgcGF0aH0gOiB7b3AsIHBhdGgsIHZhbHVlfSlcblx0XHRcdGludmVyc2VQYXRjaGVzLnB1c2goXG5cdFx0XHRcdG9wID09PSBBRERcblx0XHRcdFx0XHQ/IHtvcDogUkVNT1ZFLCBwYXRofVxuXHRcdFx0XHRcdDogb3AgPT09IFJFTU9WRVxuXHRcdFx0XHRcdD8ge29wOiBBREQsIHBhdGgsIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvcmlnVmFsdWUpfVxuXHRcdFx0XHRcdDoge29wOiBSRVBMQUNFLCBwYXRoLCB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob3JpZ1ZhbHVlKX1cblx0XHRcdClcblx0XHR9KVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVTZXRQYXRjaGVzKFxuXHRcdHN0YXRlOiBTZXRTdGF0ZSxcblx0XHRiYXNlUGF0aDogUGF0Y2hQYXRoLFxuXHRcdHBhdGNoZXM6IFBhdGNoW10sXG5cdFx0aW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0KSB7XG5cdFx0bGV0IHtiYXNlXywgY29weV99ID0gc3RhdGVcblxuXHRcdGxldCBpID0gMFxuXHRcdGJhc2VfLmZvckVhY2goKHZhbHVlOiBhbnkpID0+IHtcblx0XHRcdGlmICghY29weV8hLmhhcyh2YWx1ZSkpIHtcblx0XHRcdFx0Y29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pXG5cdFx0XHRcdHBhdGNoZXMucHVzaCh7XG5cdFx0XHRcdFx0b3A6IFJFTU9WRSxcblx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdHZhbHVlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuXHRcdFx0XHRcdG9wOiBBREQsXG5cdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHR2YWx1ZVxuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdFx0aSsrXG5cdFx0fSlcblx0XHRpID0gMFxuXHRcdGNvcHlfIS5mb3JFYWNoKCh2YWx1ZTogYW55KSA9PiB7XG5cdFx0XHRpZiAoIWJhc2VfLmhhcyh2YWx1ZSkpIHtcblx0XHRcdFx0Y29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pXG5cdFx0XHRcdHBhdGNoZXMucHVzaCh7XG5cdFx0XHRcdFx0b3A6IEFERCxcblx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdHZhbHVlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuXHRcdFx0XHRcdG9wOiBSRU1PVkUsXG5cdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHR2YWx1ZVxuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdFx0aSsrXG5cdFx0fSlcblx0fVxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhcblx0XHRiYXNlVmFsdWU6IGFueSxcblx0XHRyZXBsYWNlbWVudDogYW55LFxuXHRcdHBhdGNoZXM6IFBhdGNoW10sXG5cdFx0aW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0KTogdm9pZCB7XG5cdFx0cGF0Y2hlcy5wdXNoKHtcblx0XHRcdG9wOiBSRVBMQUNFLFxuXHRcdFx0cGF0aDogW10sXG5cdFx0XHR2YWx1ZTogcmVwbGFjZW1lbnQgPT09IE5PVEhJTkcgPyB1bmRlZmluZWQgOiByZXBsYWNlbWVudFxuXHRcdH0pXG5cdFx0aW52ZXJzZVBhdGNoZXMucHVzaCh7XG5cdFx0XHRvcDogUkVQTEFDRSxcblx0XHRcdHBhdGg6IFtdLFxuXHRcdFx0dmFsdWU6IGJhc2VWYWx1ZVxuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseVBhdGNoZXNfPFQ+KGRyYWZ0OiBULCBwYXRjaGVzOiByZWFkb25seSBQYXRjaFtdKTogVCB7XG5cdFx0cGF0Y2hlcy5mb3JFYWNoKHBhdGNoID0+IHtcblx0XHRcdGNvbnN0IHtwYXRoLCBvcH0gPSBwYXRjaFxuXG5cdFx0XHRsZXQgYmFzZTogYW55ID0gZHJhZnRcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgcGFyZW50VHlwZSA9IGdldEFyY2h0eXBlKGJhc2UpXG5cdFx0XHRcdGxldCBwID0gcGF0aFtpXVxuXHRcdFx0XHRpZiAodHlwZW9mIHAgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHAgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRwID0gXCJcIiArIHBcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNlZSAjNzM4LCBhdm9pZCBwcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQocGFyZW50VHlwZSA9PT0gQXJjaFR5cGUuT2JqZWN0IHx8IHBhcmVudFR5cGUgPT09IEFyY2hUeXBlLkFycmF5KSAmJlxuXHRcdFx0XHRcdChwID09PSBcIl9fcHJvdG9fX1wiIHx8IHAgPT09IFwiY29uc3RydWN0b3JcIilcblx0XHRcdFx0KVxuXHRcdFx0XHRcdGRpZShlcnJvck9mZnNldCArIDMpXG5cdFx0XHRcdGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiICYmIHAgPT09IFwicHJvdG90eXBlXCIpXG5cdFx0XHRcdFx0ZGllKGVycm9yT2Zmc2V0ICsgMylcblx0XHRcdFx0YmFzZSA9IGdldChiYXNlLCBwKVxuXHRcdFx0XHRpZiAodHlwZW9mIGJhc2UgIT09IFwib2JqZWN0XCIpIGRpZShlcnJvck9mZnNldCArIDIsIHBhdGguam9pbihcIi9cIikpXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHR5cGUgPSBnZXRBcmNodHlwZShiYXNlKVxuXHRcdFx0Y29uc3QgdmFsdWUgPSBkZWVwQ2xvbmVQYXRjaFZhbHVlKHBhdGNoLnZhbHVlKSAvLyB1c2VkIHRvIGNsb25lIHBhdGNoIHRvIGVuc3VyZSBvcmlnaW5hbCBwYXRjaCBpcyBub3QgbW9kaWZpZWQsIHNlZSAjNDExXG5cdFx0XHRjb25zdCBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV1cblx0XHRcdHN3aXRjaCAob3ApIHtcblx0XHRcdFx0Y2FzZSBSRVBMQUNFOlxuXHRcdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSBBcmNoVHlwZS5NYXA6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBiYXNlLnNldChrZXksIHZhbHVlKVxuXHRcdFx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRcdFx0XHRcdGNhc2UgQXJjaFR5cGUuU2V0OlxuXHRcdFx0XHRcdFx0XHRkaWUoZXJyb3JPZmZzZXQpXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHQvLyBpZiB2YWx1ZSBpcyBhbiBvYmplY3QsIHRoZW4gaXQncyBhc3NpZ25lZCBieSByZWZlcmVuY2Vcblx0XHRcdFx0XHRcdFx0Ly8gaW4gdGhlIGZvbGxvd2luZyBhZGQgb3IgcmVtb3ZlIG9wcywgdGhlIHZhbHVlIGZpZWxkIGluc2lkZSB0aGUgcGF0Y2ggd2lsbCBhbHNvIGJlIG1vZGlmeWVkXG5cdFx0XHRcdFx0XHRcdC8vIHNvIHdlIHVzZSB2YWx1ZSBmcm9tIHRoZSBjbG9uZWQgcGF0Y2hcblx0XHRcdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKGJhc2Vba2V5XSA9IHZhbHVlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBBREQ6XG5cdFx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0XHRjYXNlIEFyY2hUeXBlLkFycmF5OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4ga2V5ID09PSBcIi1cIlxuXHRcdFx0XHRcdFx0XHRcdD8gYmFzZS5wdXNoKHZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdDogYmFzZS5zcGxpY2Uoa2V5IGFzIGFueSwgMCwgdmFsdWUpXG5cdFx0XHRcdFx0XHRjYXNlIEFyY2hUeXBlLk1hcDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpXG5cdFx0XHRcdFx0XHRjYXNlIEFyY2hUeXBlLlNldDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGJhc2UuYWRkKHZhbHVlKVxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChiYXNlW2tleV0gPSB2YWx1ZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgUkVNT1ZFOlxuXHRcdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSBBcmNoVHlwZS5BcnJheTpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGJhc2Uuc3BsaWNlKGtleSBhcyBhbnksIDEpXG5cdFx0XHRcdFx0XHRjYXNlIEFyY2hUeXBlLk1hcDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGJhc2UuZGVsZXRlKGtleSlcblx0XHRcdFx0XHRcdGNhc2UgQXJjaFR5cGUuU2V0OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5kZWxldGUocGF0Y2gudmFsdWUpXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZGVsZXRlIGJhc2Vba2V5XVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRkaWUoZXJyb3JPZmZzZXQgKyAxLCBvcClcblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0cmV0dXJuIGRyYWZ0XG5cdH1cblxuXHQvLyBvcHRpbWl6ZTogdGhpcyBpcyBxdWl0ZSBhIHBlcmZvcm1hbmNlIGhpdCwgY2FuIHdlIGRldGVjdCBpbnRlbGxpZ2VudGx5IHdoZW4gaXQgaXMgbmVlZGVkP1xuXHQvLyBFLmcuIGF1dG8tZHJhZnQgd2hlbiBuZXcgb2JqZWN0cyBmcm9tIG91dHNpZGUgYXJlIGFzc2lnbmVkIGFuZCBtb2RpZmllZD9cblx0Ly8gKFNlZSBmYWlsaW5nIHRlc3Qgd2hlbiBkZWVwQ2xvbmUganVzdCByZXR1cm5zIG9iailcblx0ZnVuY3Rpb24gZGVlcENsb25lUGF0Y2hWYWx1ZTxUPihvYmo6IFQpOiBUXG5cdGZ1bmN0aW9uIGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqOiBhbnkpIHtcblx0XHRpZiAoIWlzRHJhZnRhYmxlKG9iaikpIHJldHVybiBvYmpcblx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmopKSByZXR1cm4gb2JqLm1hcChkZWVwQ2xvbmVQYXRjaFZhbHVlKVxuXHRcdGlmIChpc01hcChvYmopKVxuXHRcdFx0cmV0dXJuIG5ldyBNYXAoXG5cdFx0XHRcdEFycmF5LmZyb20ob2JqLmVudHJpZXMoKSkubWFwKChbaywgdl0pID0+IFtrLCBkZWVwQ2xvbmVQYXRjaFZhbHVlKHYpXSlcblx0XHRcdClcblx0XHRpZiAoaXNTZXQob2JqKSkgcmV0dXJuIG5ldyBTZXQoQXJyYXkuZnJvbShvYmopLm1hcChkZWVwQ2xvbmVQYXRjaFZhbHVlKSlcblx0XHRjb25zdCBjbG9uZWQgPSBPYmplY3QuY3JlYXRlKGdldFByb3RvdHlwZU9mKG9iaikpXG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gb2JqKSBjbG9uZWRba2V5XSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqW2tleV0pXG5cdFx0aWYgKGhhcyhvYmosIGltbWVyYWJsZSkpIGNsb25lZFtpbW1lcmFibGVdID0gb2JqW2ltbWVyYWJsZV1cblx0XHRyZXR1cm4gY2xvbmVkXG5cdH1cblxuXHRmdW5jdGlvbiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZDxUPihvYmo6IFQpOiBUIHtcblx0XHRpZiAoaXNEcmFmdChvYmopKSB7XG5cdFx0XHRyZXR1cm4gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmopXG5cdFx0fSBlbHNlIHJldHVybiBvYmpcblx0fVxuXG5cdGxvYWRQbHVnaW4oXCJQYXRjaGVzXCIsIHtcblx0XHRhcHBseVBhdGNoZXNfLFxuXHRcdGdlbmVyYXRlUGF0Y2hlc18sXG5cdFx0Z2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfXG5cdH0pXG59XG4iLCIvLyB0eXBlcyBvbmx5IVxuaW1wb3J0IHtcblx0SW1tZXJTdGF0ZSxcblx0QW55TWFwLFxuXHRBbnlTZXQsXG5cdE1hcFN0YXRlLFxuXHRTZXRTdGF0ZSxcblx0RFJBRlRfU1RBVEUsXG5cdGdldEN1cnJlbnRTY29wZSxcblx0bGF0ZXN0LFxuXHRpc0RyYWZ0YWJsZSxcblx0Y3JlYXRlUHJveHksXG5cdGxvYWRQbHVnaW4sXG5cdG1hcmtDaGFuZ2VkLFxuXHRkaWUsXG5cdEFyY2hUeXBlLFxuXHRlYWNoXG59IGZyb20gXCIuLi9pbnRlcm5hbFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVNYXBTZXQoKSB7XG5cdGNsYXNzIERyYWZ0TWFwIGV4dGVuZHMgTWFwIHtcblx0XHRbRFJBRlRfU1RBVEVdOiBNYXBTdGF0ZVxuXG5cdFx0Y29uc3RydWN0b3IodGFyZ2V0OiBBbnlNYXAsIHBhcmVudD86IEltbWVyU3RhdGUpIHtcblx0XHRcdHN1cGVyKClcblx0XHRcdHRoaXNbRFJBRlRfU1RBVEVdID0ge1xuXHRcdFx0XHR0eXBlXzogQXJjaFR5cGUuTWFwLFxuXHRcdFx0XHRwYXJlbnRfOiBwYXJlbnQsXG5cdFx0XHRcdHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpISxcblx0XHRcdFx0bW9kaWZpZWRfOiBmYWxzZSxcblx0XHRcdFx0ZmluYWxpemVkXzogZmFsc2UsXG5cdFx0XHRcdGNvcHlfOiB1bmRlZmluZWQsXG5cdFx0XHRcdGFzc2lnbmVkXzogdW5kZWZpbmVkLFxuXHRcdFx0XHRiYXNlXzogdGFyZ2V0LFxuXHRcdFx0XHRkcmFmdF86IHRoaXMgYXMgYW55LFxuXHRcdFx0XHRpc01hbnVhbF86IGZhbHNlLFxuXHRcdFx0XHRyZXZva2VkXzogZmFsc2Vcblx0XHRcdH1cblx0XHR9XG5cblx0XHRnZXQgc2l6ZSgpOiBudW1iZXIge1xuXHRcdFx0cmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuc2l6ZVxuXHRcdH1cblxuXHRcdGhhcyhrZXk6IGFueSk6IGJvb2xlYW4ge1xuXHRcdFx0cmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuaGFzKGtleSlcblx0XHR9XG5cblx0XHRzZXQoa2V5OiBhbnksIHZhbHVlOiBhbnkpIHtcblx0XHRcdGNvbnN0IHN0YXRlOiBNYXBTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHRpZiAoIWxhdGVzdChzdGF0ZSkuaGFzKGtleSkgfHwgbGF0ZXN0KHN0YXRlKS5nZXQoa2V5KSAhPT0gdmFsdWUpIHtcblx0XHRcdFx0cHJlcGFyZU1hcENvcHkoc3RhdGUpXG5cdFx0XHRcdG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdFx0XHRzdGF0ZS5hc3NpZ25lZF8hLnNldChrZXksIHRydWUpXG5cdFx0XHRcdHN0YXRlLmNvcHlfIS5zZXQoa2V5LCB2YWx1ZSlcblx0XHRcdFx0c3RhdGUuYXNzaWduZWRfIS5zZXQoa2V5LCB0cnVlKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cblx0XHRkZWxldGUoa2V5OiBhbnkpOiBib29sZWFuIHtcblx0XHRcdGlmICghdGhpcy5oYXMoa2V5KSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc3RhdGU6IE1hcFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdHByZXBhcmVNYXBDb3B5KHN0YXRlKVxuXHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRpZiAoc3RhdGUuYmFzZV8uaGFzKGtleSkpIHtcblx0XHRcdFx0c3RhdGUuYXNzaWduZWRfIS5zZXQoa2V5LCBmYWxzZSlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0YXRlLmFzc2lnbmVkXyEuZGVsZXRlKGtleSlcblx0XHRcdH1cblx0XHRcdHN0YXRlLmNvcHlfIS5kZWxldGUoa2V5KVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cblx0XHRjbGVhcigpIHtcblx0XHRcdGNvbnN0IHN0YXRlOiBNYXBTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHRpZiAobGF0ZXN0KHN0YXRlKS5zaXplKSB7XG5cdFx0XHRcdHByZXBhcmVNYXBDb3B5KHN0YXRlKVxuXHRcdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdFx0c3RhdGUuYXNzaWduZWRfID0gbmV3IE1hcCgpXG5cdFx0XHRcdGVhY2goc3RhdGUuYmFzZV8sIGtleSA9PiB7XG5cdFx0XHRcdFx0c3RhdGUuYXNzaWduZWRfIS5zZXQoa2V5LCBmYWxzZSlcblx0XHRcdFx0fSlcblx0XHRcdFx0c3RhdGUuY29weV8hLmNsZWFyKClcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3JFYWNoKGNiOiAodmFsdWU6IGFueSwga2V5OiBhbnksIHNlbGY6IGFueSkgPT4gdm9pZCwgdGhpc0FyZz86IGFueSkge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IE1hcFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGxhdGVzdChzdGF0ZSkuZm9yRWFjaCgoX3ZhbHVlOiBhbnksIGtleTogYW55LCBfbWFwOiBhbnkpID0+IHtcblx0XHRcdFx0Y2IuY2FsbCh0aGlzQXJnLCB0aGlzLmdldChrZXkpLCBrZXksIHRoaXMpXG5cdFx0XHR9KVxuXHRcdH1cblxuXHRcdGdldChrZXk6IGFueSk6IGFueSB7XG5cdFx0XHRjb25zdCBzdGF0ZTogTWFwU3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0Y29uc3QgdmFsdWUgPSBsYXRlc3Qoc3RhdGUpLmdldChrZXkpXG5cdFx0XHRpZiAoc3RhdGUuZmluYWxpemVkXyB8fCAhaXNEcmFmdGFibGUodmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlICE9PSBzdGF0ZS5iYXNlXy5nZXQoa2V5KSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgLy8gZWl0aGVyIGFscmVhZHkgZHJhZnRlZCBvciByZWFzc2lnbmVkXG5cdFx0XHR9XG5cdFx0XHQvLyBkZXNwaXRlIHdoYXQgaXQgbG9va3MsIHRoaXMgY3JlYXRlcyBhIGRyYWZ0IG9ubHkgb25jZSwgc2VlIGFib3ZlIGNvbmRpdGlvblxuXHRcdFx0Y29uc3QgZHJhZnQgPSBjcmVhdGVQcm94eSh2YWx1ZSwgc3RhdGUpXG5cdFx0XHRwcmVwYXJlTWFwQ29weShzdGF0ZSlcblx0XHRcdHN0YXRlLmNvcHlfIS5zZXQoa2V5LCBkcmFmdClcblx0XHRcdHJldHVybiBkcmFmdFxuXHRcdH1cblxuXHRcdGtleXMoKTogSXRlcmFibGVJdGVyYXRvcjxhbnk+IHtcblx0XHRcdHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmtleXMoKVxuXHRcdH1cblxuXHRcdHZhbHVlcygpOiBJdGVyYWJsZUl0ZXJhdG9yPGFueT4ge1xuXHRcdFx0Y29uc3QgaXRlcmF0b3IgPSB0aGlzLmtleXMoKVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0W1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHRoaXMudmFsdWVzKCksXG5cdFx0XHRcdG5leHQ6ICgpID0+IHtcblx0XHRcdFx0XHRjb25zdCByID0gaXRlcmF0b3IubmV4dCgpXG5cdFx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRcdFx0XHRpZiAoci5kb25lKSByZXR1cm4gclxuXHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoci52YWx1ZSlcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZG9uZTogZmFsc2UsXG5cdFx0XHRcdFx0XHR2YWx1ZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBhcyBhbnlcblx0XHR9XG5cblx0XHRlbnRyaWVzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8W2FueSwgYW55XT4ge1xuXHRcdFx0Y29uc3QgaXRlcmF0b3IgPSB0aGlzLmtleXMoKVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0W1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHRoaXMuZW50cmllcygpLFxuXHRcdFx0XHRuZXh0OiAoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgciA9IGl0ZXJhdG9yLm5leHQoKVxuXHRcdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdFx0XHRcdFx0aWYgKHIuZG9uZSkgcmV0dXJuIHJcblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KHIudmFsdWUpXG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGRvbmU6IGZhbHNlLFxuXHRcdFx0XHRcdFx0dmFsdWU6IFtyLnZhbHVlLCB2YWx1ZV1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gYXMgYW55XG5cdFx0fVxuXG5cdFx0W1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lbnRyaWVzKClcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwcm94eU1hcF88VCBleHRlbmRzIEFueU1hcD4odGFyZ2V0OiBULCBwYXJlbnQ/OiBJbW1lclN0YXRlKTogVCB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBuZXcgRHJhZnRNYXAodGFyZ2V0LCBwYXJlbnQpXG5cdH1cblxuXHRmdW5jdGlvbiBwcmVwYXJlTWFwQ29weShzdGF0ZTogTWFwU3RhdGUpIHtcblx0XHRpZiAoIXN0YXRlLmNvcHlfKSB7XG5cdFx0XHRzdGF0ZS5hc3NpZ25lZF8gPSBuZXcgTWFwKClcblx0XHRcdHN0YXRlLmNvcHlfID0gbmV3IE1hcChzdGF0ZS5iYXNlXylcblx0XHR9XG5cdH1cblxuXHRjbGFzcyBEcmFmdFNldCBleHRlbmRzIFNldCB7XG5cdFx0W0RSQUZUX1NUQVRFXTogU2V0U3RhdGVcblx0XHRjb25zdHJ1Y3Rvcih0YXJnZXQ6IEFueVNldCwgcGFyZW50PzogSW1tZXJTdGF0ZSkge1xuXHRcdFx0c3VwZXIoKVxuXHRcdFx0dGhpc1tEUkFGVF9TVEFURV0gPSB7XG5cdFx0XHRcdHR5cGVfOiBBcmNoVHlwZS5TZXQsXG5cdFx0XHRcdHBhcmVudF86IHBhcmVudCxcblx0XHRcdFx0c2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCkhLFxuXHRcdFx0XHRtb2RpZmllZF86IGZhbHNlLFxuXHRcdFx0XHRmaW5hbGl6ZWRfOiBmYWxzZSxcblx0XHRcdFx0Y29weV86IHVuZGVmaW5lZCxcblx0XHRcdFx0YmFzZV86IHRhcmdldCxcblx0XHRcdFx0ZHJhZnRfOiB0aGlzLFxuXHRcdFx0XHRkcmFmdHNfOiBuZXcgTWFwKCksXG5cdFx0XHRcdHJldm9rZWRfOiBmYWxzZSxcblx0XHRcdFx0aXNNYW51YWxfOiBmYWxzZVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGdldCBzaXplKCk6IG51bWJlciB7XG5cdFx0XHRyZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5zaXplXG5cdFx0fVxuXG5cdFx0aGFzKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcblx0XHRcdGNvbnN0IHN0YXRlOiBTZXRTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHQvLyBiaXQgb2YgdHJpY2tlcnkgaGVyZSwgdG8gYmUgYWJsZSB0byByZWNvZ25pemUgYm90aCB0aGUgdmFsdWUsIGFuZCB0aGUgZHJhZnQgb2YgaXRzIHZhbHVlXG5cdFx0XHRpZiAoIXN0YXRlLmNvcHlfKSB7XG5cdFx0XHRcdHJldHVybiBzdGF0ZS5iYXNlXy5oYXModmFsdWUpXG5cdFx0XHR9XG5cdFx0XHRpZiAoc3RhdGUuY29weV8uaGFzKHZhbHVlKSkgcmV0dXJuIHRydWVcblx0XHRcdGlmIChzdGF0ZS5kcmFmdHNfLmhhcyh2YWx1ZSkgJiYgc3RhdGUuY29weV8uaGFzKHN0YXRlLmRyYWZ0c18uZ2V0KHZhbHVlKSkpXG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHR9XG5cblx0XHRhZGQodmFsdWU6IGFueSk6IGFueSB7XG5cdFx0XHRjb25zdCBzdGF0ZTogU2V0U3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0aWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcblx0XHRcdFx0cHJlcGFyZVNldENvcHkoc3RhdGUpXG5cdFx0XHRcdG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdFx0XHRzdGF0ZS5jb3B5XyEuYWRkKHZhbHVlKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cblx0XHRkZWxldGUodmFsdWU6IGFueSk6IGFueSB7XG5cdFx0XHRpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc3RhdGU6IFNldFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdHByZXBhcmVTZXRDb3B5KHN0YXRlKVxuXHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRzdGF0ZS5jb3B5XyEuZGVsZXRlKHZhbHVlKSB8fFxuXHRcdFx0XHQoc3RhdGUuZHJhZnRzXy5oYXModmFsdWUpXG5cdFx0XHRcdFx0PyBzdGF0ZS5jb3B5XyEuZGVsZXRlKHN0YXRlLmRyYWZ0c18uZ2V0KHZhbHVlKSlcblx0XHRcdFx0XHQ6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZhbHNlKVxuXHRcdFx0KVxuXHRcdH1cblxuXHRcdGNsZWFyKCkge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IFNldFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcblx0XHRcdFx0cHJlcGFyZVNldENvcHkoc3RhdGUpXG5cdFx0XHRcdG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdFx0XHRzdGF0ZS5jb3B5XyEuY2xlYXIoKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhbHVlcygpOiBJdGVyYWJsZUl0ZXJhdG9yPGFueT4ge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IFNldFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdHByZXBhcmVTZXRDb3B5KHN0YXRlKVxuXHRcdFx0cmV0dXJuIHN0YXRlLmNvcHlfIS52YWx1ZXMoKVxuXHRcdH1cblxuXHRcdGVudHJpZXMoKTogSXRlcmFibGVJdGVyYXRvcjxbYW55LCBhbnldPiB7XG5cdFx0XHRjb25zdCBzdGF0ZTogU2V0U3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0cHJlcGFyZVNldENvcHkoc3RhdGUpXG5cdFx0XHRyZXR1cm4gc3RhdGUuY29weV8hLmVudHJpZXMoKVxuXHRcdH1cblxuXHRcdGtleXMoKTogSXRlcmFibGVJdGVyYXRvcjxhbnk+IHtcblx0XHRcdHJldHVybiB0aGlzLnZhbHVlcygpXG5cdFx0fVxuXG5cdFx0W1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZXMoKVxuXHRcdH1cblxuXHRcdGZvckVhY2goY2I6IGFueSwgdGhpc0FyZz86IGFueSkge1xuXHRcdFx0Y29uc3QgaXRlcmF0b3IgPSB0aGlzLnZhbHVlcygpXG5cdFx0XHRsZXQgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpXG5cdFx0XHR3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG5cdFx0XHRcdGNiLmNhbGwodGhpc0FyZywgcmVzdWx0LnZhbHVlLCByZXN1bHQudmFsdWUsIHRoaXMpXG5cdFx0XHRcdHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBwcm94eVNldF88VCBleHRlbmRzIEFueVNldD4odGFyZ2V0OiBULCBwYXJlbnQ/OiBJbW1lclN0YXRlKTogVCB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBuZXcgRHJhZnRTZXQodGFyZ2V0LCBwYXJlbnQpXG5cdH1cblxuXHRmdW5jdGlvbiBwcmVwYXJlU2V0Q29weShzdGF0ZTogU2V0U3RhdGUpIHtcblx0XHRpZiAoIXN0YXRlLmNvcHlfKSB7XG5cdFx0XHQvLyBjcmVhdGUgZHJhZnRzIGZvciBhbGwgZW50cmllcyB0byBwcmVzZXJ2ZSBpbnNlcnRpb24gb3JkZXJcblx0XHRcdHN0YXRlLmNvcHlfID0gbmV3IFNldCgpXG5cdFx0XHRzdGF0ZS5iYXNlXy5mb3JFYWNoKHZhbHVlID0+IHtcblx0XHRcdFx0aWYgKGlzRHJhZnRhYmxlKHZhbHVlKSkge1xuXHRcdFx0XHRcdGNvbnN0IGRyYWZ0ID0gY3JlYXRlUHJveHkodmFsdWUsIHN0YXRlKVxuXHRcdFx0XHRcdHN0YXRlLmRyYWZ0c18uc2V0KHZhbHVlLCBkcmFmdClcblx0XHRcdFx0XHRzdGF0ZS5jb3B5XyEuYWRkKGRyYWZ0KVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXRlLmNvcHlfIS5hZGQodmFsdWUpXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYXNzZXJ0VW5yZXZva2VkKHN0YXRlOiBhbnkgLypFUzVTdGF0ZSB8IE1hcFN0YXRlIHwgU2V0U3RhdGUqLykge1xuXHRcdGlmIChzdGF0ZS5yZXZva2VkXykgZGllKDMsIEpTT04uc3RyaW5naWZ5KGxhdGVzdChzdGF0ZSkpKVxuXHR9XG5cblx0bG9hZFBsdWdpbihcIk1hcFNldFwiLCB7cHJveHlNYXBfLCBwcm94eVNldF99KVxufVxuIiwiaW1wb3J0IHtcblx0SVByb2R1Y2UsXG5cdElQcm9kdWNlV2l0aFBhdGNoZXMsXG5cdEltbWVyLFxuXHREcmFmdCxcblx0SW1tdXRhYmxlXG59IGZyb20gXCIuL2ludGVybmFsXCJcblxuZXhwb3J0IHtcblx0RHJhZnQsXG5cdFdyaXRhYmxlRHJhZnQsXG5cdEltbXV0YWJsZSxcblx0UGF0Y2gsXG5cdFBhdGNoTGlzdGVuZXIsXG5cdFByb2R1Y2VyLFxuXHRvcmlnaW5hbCxcblx0Y3VycmVudCxcblx0aXNEcmFmdCxcblx0aXNEcmFmdGFibGUsXG5cdE5PVEhJTkcgYXMgbm90aGluZyxcblx0RFJBRlRBQkxFIGFzIGltbWVyYWJsZSxcblx0ZnJlZXplLFxuXHRPYmplY3Rpc2gsXG5cdFN0cmljdE1vZGVcbn0gZnJvbSBcIi4vaW50ZXJuYWxcIlxuXG5jb25zdCBpbW1lciA9IG5ldyBJbW1lcigpXG5cbi8qKlxuICogVGhlIGBwcm9kdWNlYCBmdW5jdGlvbiB0YWtlcyBhIHZhbHVlIGFuZCBhIFwicmVjaXBlIGZ1bmN0aW9uXCIgKHdob3NlXG4gKiByZXR1cm4gdmFsdWUgb2Z0ZW4gZGVwZW5kcyBvbiB0aGUgYmFzZSBzdGF0ZSkuIFRoZSByZWNpcGUgZnVuY3Rpb24gaXNcbiAqIGZyZWUgdG8gbXV0YXRlIGl0cyBmaXJzdCBhcmd1bWVudCBob3dldmVyIGl0IHdhbnRzLiBBbGwgbXV0YXRpb25zIGFyZVxuICogb25seSBldmVyIGFwcGxpZWQgdG8gYSBfX2NvcHlfXyBvZiB0aGUgYmFzZSBzdGF0ZS5cbiAqXG4gKiBQYXNzIG9ubHkgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBcImN1cnJpZWQgcHJvZHVjZXJcIiB3aGljaCByZWxpZXZlcyB5b3VcbiAqIGZyb20gcGFzc2luZyB0aGUgcmVjaXBlIGZ1bmN0aW9uIGV2ZXJ5IHRpbWUuXG4gKlxuICogT25seSBwbGFpbiBvYmplY3RzIGFuZCBhcnJheXMgYXJlIG1hZGUgbXV0YWJsZS4gQWxsIG90aGVyIG9iamVjdHMgYXJlXG4gKiBjb25zaWRlcmVkIHVuY29weWFibGUuXG4gKlxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBfX2JvdW5kX18gdG8gaXRzIGBJbW1lcmAgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHthbnl9IGJhc2UgLSB0aGUgaW5pdGlhbCBzdGF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvZHVjZXIgLSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcHJveHkgb2YgdGhlIGJhc2Ugc3RhdGUgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHdoaWNoIGNhbiBiZSBmcmVlbHkgbW9kaWZpZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhdGNoTGlzdGVuZXIgLSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHRoZSBwYXRjaGVzIHByb2R1Y2VkIGhlcmVcbiAqIEByZXR1cm5zIHthbnl9IGEgbmV3IHN0YXRlLCBvciB0aGUgaW5pdGlhbCBzdGF0ZSBpZiBub3RoaW5nIHdhcyBtb2RpZmllZFxuICovXG5leHBvcnQgY29uc3QgcHJvZHVjZTogSVByb2R1Y2UgPSBpbW1lci5wcm9kdWNlXG5cbi8qKlxuICogTGlrZSBgcHJvZHVjZWAsIGJ1dCBgcHJvZHVjZVdpdGhQYXRjaGVzYCBhbHdheXMgcmV0dXJucyBhIHR1cGxlXG4gKiBbbmV4dFN0YXRlLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlc10gKGluc3RlYWQgb2YganVzdCB0aGUgbmV4dCBzdGF0ZSlcbiAqL1xuZXhwb3J0IGNvbnN0IHByb2R1Y2VXaXRoUGF0Y2hlczogSVByb2R1Y2VXaXRoUGF0Y2hlcyA9IGltbWVyLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKFxuXHRpbW1lclxuKVxuXG4vKipcbiAqIFBhc3MgdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IGZyZWV6ZSBhbGwgY29waWVzIGNyZWF0ZWQgYnkgSW1tZXIuXG4gKlxuICogQWx3YXlzIGZyZWV6ZSBieSBkZWZhdWx0LCBldmVuIGluIHByb2R1Y3Rpb24gbW9kZVxuICovXG5leHBvcnQgY29uc3Qgc2V0QXV0b0ZyZWV6ZSA9IGltbWVyLnNldEF1dG9GcmVlemUuYmluZChpbW1lcilcblxuLyoqXG4gKiBQYXNzIHRydWUgdG8gZW5hYmxlIHN0cmljdCBzaGFsbG93IGNvcHkuXG4gKlxuICogQnkgZGVmYXVsdCwgaW1tZXIgZG9lcyBub3QgY29weSB0aGUgb2JqZWN0IGRlc2NyaXB0b3JzIHN1Y2ggYXMgZ2V0dGVyLCBzZXR0ZXIgYW5kIG5vbi1lbnVtcmFibGUgcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0IGNvbnN0IHNldFVzZVN0cmljdFNoYWxsb3dDb3B5ID0gaW1tZXIuc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkuYmluZChpbW1lcilcblxuLyoqXG4gKiBBcHBseSBhbiBhcnJheSBvZiBJbW1lciBwYXRjaGVzIHRvIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGEgcHJvZHVjZXIsIHdoaWNoIG1lYW5zIGNvcHktb24td3JpdGUgaXMgaW4gZWZmZWN0LlxuICovXG5leHBvcnQgY29uc3QgYXBwbHlQYXRjaGVzID0gaW1tZXIuYXBwbHlQYXRjaGVzLmJpbmQoaW1tZXIpXG5cbi8qKlxuICogQ3JlYXRlIGFuIEltbWVyIGRyYWZ0IGZyb20gdGhlIGdpdmVuIGJhc2Ugc3RhdGUsIHdoaWNoIG1heSBiZSBhIGRyYWZ0IGl0c2VsZi5cbiAqIFRoZSBkcmFmdCBjYW4gYmUgbW9kaWZpZWQgdW50aWwgeW91IGZpbmFsaXplIGl0IHdpdGggdGhlIGBmaW5pc2hEcmFmdGAgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVEcmFmdCA9IGltbWVyLmNyZWF0ZURyYWZ0LmJpbmQoaW1tZXIpXG5cbi8qKlxuICogRmluYWxpemUgYW4gSW1tZXIgZHJhZnQgZnJvbSBhIGBjcmVhdGVEcmFmdGAgY2FsbCwgcmV0dXJuaW5nIHRoZSBiYXNlIHN0YXRlXG4gKiAoaWYgbm8gY2hhbmdlcyB3ZXJlIG1hZGUpIG9yIGEgbW9kaWZpZWQgY29weS4gVGhlIGRyYWZ0IG11c3QgKm5vdCogYmVcbiAqIG11dGF0ZWQgYWZ0ZXJ3YXJkcy5cbiAqXG4gKiBQYXNzIGEgZnVuY3Rpb24gYXMgdGhlIDJuZCBhcmd1bWVudCB0byBnZW5lcmF0ZSBJbW1lciBwYXRjaGVzIGJhc2VkIG9uIHRoZVxuICogY2hhbmdlcyB0aGF0IHdlcmUgbWFkZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmlzaERyYWZ0ID0gaW1tZXIuZmluaXNoRHJhZnQuYmluZChpbW1lcilcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGFjdHVhbGx5IGEgbm8tb3AsIGJ1dCBjYW4gYmUgdXNlZCB0byBjYXN0IGFuIGltbXV0YWJsZSB0eXBlXG4gKiB0byBhbiBkcmFmdCB0eXBlIGFuZCBtYWtlIFR5cGVTY3JpcHQgaGFwcHlcbiAqXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhc3REcmFmdDxUPih2YWx1ZTogVCk6IERyYWZ0PFQ+IHtcblx0cmV0dXJuIHZhbHVlIGFzIGFueVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgYSBuby1vcCwgYnV0IGNhbiBiZSB1c2VkIHRvIGNhc3QgYSBtdXRhYmxlIHR5cGVcbiAqIHRvIGFuIGltbXV0YWJsZSB0eXBlIGFuZCBtYWtlIFR5cGVTY3JpcHQgaGFwcHlcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FzdEltbXV0YWJsZTxUPih2YWx1ZTogVCk6IEltbXV0YWJsZTxUPiB7XG5cdHJldHVybiB2YWx1ZSBhcyBhbnlcbn1cblxuZXhwb3J0IHtJbW1lcn1cblxuZXhwb3J0IHtlbmFibGVQYXRjaGVzfSBmcm9tIFwiLi9wbHVnaW5zL3BhdGNoZXNcIlxuZXhwb3J0IHtlbmFibGVNYXBTZXR9IGZyb20gXCIuL3BsdWdpbnMvbWFwc2V0XCJcbiJdLCJuYW1lcyI6WyJpbW1lciIsImlzU2V0IiwiY3VycmVudCIsIkltbWVyIiwiYmFzZSIsIkltbWVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQ0MsUUFBUSxJQUFJLGFBQWE7QURJbkIsSUFBTSxVQUF5QixPQUFPLEdBQUEsQ0FBSSxlQUFlO0FBVXpELElBQU0sWUFBMkIsT0FBTyxHQUFBLENBQUksaUJBQWlCO0FBRTdELElBQU0sY0FBNkIsT0FBTyxHQUFBLENBQUksYUFBYTs7QUNqQjNELElBQU0sZ0RBRVQ7SUFBQSxrQ0FBQTtJQUVBLFNBQVMsTUFBQSxFQUFnQjtRQUN4QixPQUFPLDBCQUFtQixRQUFBLG1GQUF5RixPQUFBLFFBQUE7SUFDcEg7SUFDQSxTQUFTLEtBQUEsRUFBZTtRQUN2QixPQUFPLHNKQUFzSixPQUFBLE9BQUE7SUFDOUo7SUFDQTtJQUNBLFNBQVMsSUFBQSxFQUFXO1FBQ25CLE9BQ0MseUhBQ0E7SUFFRjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsS0FB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RDtJQUVBLFdBQVcsVUFBVTtRQUFDO1FBQVc7SUFBUyxDQUFDO0FBQzVDOztBQ3JSQSxJQUFNLFFBQVEsSUFBSUMsT0FBTTtBQXFCakIsSUFBTSxVQUFvQixNQUFNLE9BQUE7QUFNaEMsSUFBTSxxQkFBMEMsTUFBTSxrQkFBQSxDQUFtQixJQUFBLENBQy9FO0FBUU0sSUFBTSxnQkFBZ0IsTUFBTSxhQUFBLENBQWMsSUFBQSxDQUFLLEtBQUs7QUFPcEQsSUFBTSwwQkFBMEIsTUFBTSx1QkFBQSxDQUF3QixJQUFBLENBQUssS0FBSztBQU94RSxJQUFNLGVBQWUsTUFBTSxZQUFBLENBQWEsSUFBQSxDQUFLLEtBQUs7QUFNbEQsSUFBTSxjQUFjLE1BQU0sV0FBQSxDQUFZLElBQUEsQ0FBSyxLQUFLO0FBVWhELElBQU0sY0FBYyxNQUFNLFdBQUEsQ0FBWSxJQUFBLENBQUssS0FBSztBQVFoRCxTQUFTLFVBQWEsS0FBQSxFQUFvQjtJQUNoRCxPQUFPO0FBQ1I7QUFPTyxTQUFTLGNBQWlCLEtBQUEsRUFBd0I7SUFDeEQsT0FBTztBQUNSIiwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA5NDM0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L3NyYy9kZXZNb2RlQ2hlY2tzL2lkZW50aXR5RnVuY3Rpb25DaGVjay50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZXNlbGVjdC9zcmMvZGV2TW9kZUNoZWNrcy9pbnB1dFN0YWJpbGl0eUNoZWNrLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L3NyYy9kZXZNb2RlQ2hlY2tzL3NldEdsb2JhbERldk1vZGVDaGVja3MudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVzZWxlY3Qvc3JjL3V0aWxzLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L3NyYy9hdXRvdHJhY2tNZW1vaXplL2F1dG90cmFja2luZy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZXNlbGVjdC9zcmMvYXV0b3RyYWNrTWVtb2l6ZS90cmFja2luZy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZXNlbGVjdC9zcmMvYXV0b3RyYWNrTWVtb2l6ZS9wcm94eS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZXNlbGVjdC9zcmMvbHJ1TWVtb2l6ZS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZXNlbGVjdC9zcmMvYXV0b3RyYWNrTWVtb2l6ZS9hdXRvdHJhY2tNZW1vaXplLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L3NyYy93ZWFrTWFwTWVtb2l6ZS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZXNlbGVjdC9zcmMvY3JlYXRlU2VsZWN0b3JDcmVhdG9yLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L3NyYy9jcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBBbnlGdW5jdGlvbiB9IGZyb20gJy4uL3R5cGVzJ1xyXG5cclxuLyoqXHJcbiAqIFJ1bnMgYSBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGhlIGdpdmVuIHJlc3VsdCBmdW5jdGlvbiBiZWhhdmVzIGFzIGFuXHJcbiAqIGlkZW50aXR5IGZ1bmN0aW9uLiBBbiBpZGVudGl0eSBmdW5jdGlvbiBpcyBvbmUgdGhhdCByZXR1cm5zIGl0c1xyXG4gKiBpbnB1dCB1bmNoYW5nZWQsIGZvciBleGFtcGxlLCBgeCA9PiB4YC4gVGhpcyBjaGVjayBoZWxwcyBlbnN1cmVcclxuICogZWZmaWNpZW50IG1lbW9pemF0aW9uIGFuZCBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMgYnkgZW5jb3VyYWdpbmdcclxuICogcHJvcGVyIHVzZSBvZiB0cmFuc2Zvcm1hdGlvbiBsb2dpYyBpbiByZXN1bHQgZnVuY3Rpb25zIGFuZFxyXG4gKiBleHRyYWN0aW9uIGxvZ2ljIGluIGlucHV0IHNlbGVjdG9ycy5cclxuICpcclxuICogQHBhcmFtIHJlc3VsdEZ1bmMgLSBUaGUgcmVzdWx0IGZ1bmN0aW9uIHRvIGJlIGNoZWNrZWQuXHJcbiAqIEBwYXJhbSBpbnB1dFNlbGVjdG9yc1Jlc3VsdHMgLSBUaGUgcmVzdWx0cyBvZiB0aGUgaW5wdXQgc2VsZWN0b3JzLlxyXG4gKiBAcGFyYW0gb3V0cHV0U2VsZWN0b3JSZXN1bHQgLSBUaGUgcmVzdWx0IG9mIHRoZSBvdXRwdXQgc2VsZWN0b3IuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVzZWxlY3QuanMub3JnL2FwaS9kZXZlbG9wbWVudC1vbmx5LXN0YWJpbGl0eS1jaGVja3MjaWRlbnRpdHlmdW5jdGlvbmNoZWNrIGBpZGVudGl0eUZ1bmN0aW9uQ2hlY2tgfVxyXG4gKlxyXG4gKiBAc2luY2UgNS4wLjBcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcnVuSWRlbnRpdHlGdW5jdGlvbkNoZWNrID0gKFxyXG4gIHJlc3VsdEZ1bmM6IEFueUZ1bmN0aW9uLFxyXG4gIGlucHV0U2VsZWN0b3JzUmVzdWx0czogdW5rbm93bltdLFxyXG4gIG91dHB1dFNlbGVjdG9yUmVzdWx0OiB1bmtub3duXHJcbikgPT4ge1xyXG4gIGlmIChcclxuICAgIGlucHV0U2VsZWN0b3JzUmVzdWx0cy5sZW5ndGggPT09IDEgJiZcclxuICAgIGlucHV0U2VsZWN0b3JzUmVzdWx0c1swXSA9PT0gb3V0cHV0U2VsZWN0b3JSZXN1bHRcclxuICApIHtcclxuICAgIGxldCBpc0lucHV0U2FtZUFzT3V0cHV0ID0gZmFsc2VcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGVtcHR5T2JqZWN0ID0ge31cclxuICAgICAgaWYgKHJlc3VsdEZ1bmMoZW1wdHlPYmplY3QpID09PSBlbXB0eU9iamVjdCkgaXNJbnB1dFNhbWVBc091dHB1dCA9IHRydWVcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICAvLyBEbyBub3RoaW5nXHJcbiAgICB9XHJcbiAgICBpZiAoaXNJbnB1dFNhbWVBc091dHB1dCkge1xyXG4gICAgICBsZXQgc3RhY2s6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpXHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWksIG5vLWV4dHJhLXNlbWlcclxuICAgICAgICA7KHsgc3RhY2sgfSA9IGUgYXMgRXJyb3IpXHJcbiAgICAgIH1cclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICdUaGUgcmVzdWx0IGZ1bmN0aW9uIHJldHVybmVkIGl0cyBvd24gaW5wdXRzIHdpdGhvdXQgbW9kaWZpY2F0aW9uLiBlLmcnICtcclxuICAgICAgICAgICdcXG5gY3JlYXRlU2VsZWN0b3IoW3N0YXRlID0+IHN0YXRlLnRvZG9zXSwgdG9kb3MgPT4gdG9kb3MpYCcgK1xyXG4gICAgICAgICAgJ1xcblRoaXMgY291bGQgbGVhZCB0byBpbmVmZmljaWVudCBtZW1vaXphdGlvbiBhbmQgdW5uZWNlc3NhcnkgcmUtcmVuZGVycy4nICtcclxuICAgICAgICAgICdcXG5FbnN1cmUgdHJhbnNmb3JtYXRpb24gbG9naWMgaXMgaW4gdGhlIHJlc3VsdCBmdW5jdGlvbiwgYW5kIGV4dHJhY3Rpb24gbG9naWMgaXMgaW4gdGhlIGlucHV0IHNlbGVjdG9ycy4nLFxyXG4gICAgICAgIHsgc3RhY2sgfVxyXG4gICAgICApXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB0eXBlIHsgQ3JlYXRlU2VsZWN0b3JPcHRpb25zLCBVbmtub3duTWVtb2l6ZXIgfSBmcm9tICcuLi90eXBlcydcclxuXHJcbi8qKlxyXG4gKiBSdW5zIGEgc3RhYmlsaXR5IGNoZWNrIHRvIGVuc3VyZSB0aGUgaW5wdXQgc2VsZWN0b3IgcmVzdWx0cyByZW1haW4gc3RhYmxlXHJcbiAqIHdoZW4gcHJvdmlkZWQgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMuIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gZGV0ZWN0XHJcbiAqIGNoYW5nZXMgaW4gdGhlIG91dHB1dCBvZiBpbnB1dCBzZWxlY3RvcnMsIHdoaWNoIGNhbiBpbXBhY3QgdGhlIHBlcmZvcm1hbmNlIG9mIG1lbW9pemVkIHNlbGVjdG9ycy5cclxuICpcclxuICogQHBhcmFtIGlucHV0U2VsZWN0b3JSZXN1bHRzT2JqZWN0IC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdHdvIGFycmF5czogYGlucHV0U2VsZWN0b3JSZXN1bHRzYCBhbmQgYGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weWAsIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0cyBvZiBpbnB1dCBzZWxlY3RvcnMuXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBvYmplY3QgY29uc2lzdGluZyBvZiBhIGBtZW1vaXplYCBmdW5jdGlvbiBhbmQgYSBgbWVtb2l6ZU9wdGlvbnNgIG9iamVjdC5cclxuICogQHBhcmFtIGlucHV0U2VsZWN0b3JBcmdzIC0gTGlzdCBvZiBhcmd1bWVudHMgYmVpbmcgcGFzc2VkIHRvIHRoZSBpbnB1dCBzZWxlY3RvcnMuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVzZWxlY3QuanMub3JnL2FwaS9kZXZlbG9wbWVudC1vbmx5LXN0YWJpbGl0eS1jaGVja3MvI2lucHV0c3RhYmlsaXR5Y2hlY2sgYGlucHV0U3RhYmlsaXR5Q2hlY2tgfVxyXG4gKlxyXG4gKiBAc2luY2UgNS4wLjBcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcnVuSW5wdXRTdGFiaWxpdHlDaGVjayA9IChcclxuICBpbnB1dFNlbGVjdG9yUmVzdWx0c09iamVjdDoge1xyXG4gICAgaW5wdXRTZWxlY3RvclJlc3VsdHM6IHVua25vd25bXVxyXG4gICAgaW5wdXRTZWxlY3RvclJlc3VsdHNDb3B5OiB1bmtub3duW11cclxuICB9LFxyXG4gIG9wdGlvbnM6IFJlcXVpcmVkPFxyXG4gICAgUGljazxcclxuICAgICAgQ3JlYXRlU2VsZWN0b3JPcHRpb25zPFVua25vd25NZW1vaXplciwgVW5rbm93bk1lbW9pemVyPixcclxuICAgICAgJ21lbW9pemUnIHwgJ21lbW9pemVPcHRpb25zJ1xyXG4gICAgPlxyXG4gID4sXHJcbiAgaW5wdXRTZWxlY3RvckFyZ3M6IHVua25vd25bXSB8IElBcmd1bWVudHNcclxuKSA9PiB7XHJcbiAgY29uc3QgeyBtZW1vaXplLCBtZW1vaXplT3B0aW9ucyB9ID0gb3B0aW9uc1xyXG4gIGNvbnN0IHsgaW5wdXRTZWxlY3RvclJlc3VsdHMsIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSB9ID1cclxuICAgIGlucHV0U2VsZWN0b3JSZXN1bHRzT2JqZWN0XHJcbiAgY29uc3QgY3JlYXRlQW5FbXB0eU9iamVjdCA9IG1lbW9pemUoKCkgPT4gKHt9KSwgLi4ubWVtb2l6ZU9wdGlvbnMpXHJcbiAgLy8gaWYgdGhlIG1lbW9pemUgbWV0aG9kIHRoaW5rcyB0aGUgcGFyYW1ldGVycyBhcmUgZXF1YWwsIHRoZXNlICpzaG91bGQqIGJlIHRoZSBzYW1lIHJlZmVyZW5jZVxyXG4gIGNvbnN0IGFyZUlucHV0U2VsZWN0b3JSZXN1bHRzRXF1YWwgPVxyXG4gICAgY3JlYXRlQW5FbXB0eU9iamVjdC5hcHBseShudWxsLCBpbnB1dFNlbGVjdG9yUmVzdWx0cykgPT09XHJcbiAgICBjcmVhdGVBbkVtcHR5T2JqZWN0LmFwcGx5KG51bGwsIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSlcclxuICBpZiAoIWFyZUlucHV0U2VsZWN0b3JSZXN1bHRzRXF1YWwpIHtcclxuICAgIGxldCBzdGFjazogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXHJcbiAgICB0cnkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWksIG5vLWV4dHJhLXNlbWlcclxuICAgICAgOyh7IHN0YWNrIH0gPSBlIGFzIEVycm9yKVxyXG4gICAgfVxyXG4gICAgY29uc29sZS53YXJuKFxyXG4gICAgICAnQW4gaW5wdXQgc2VsZWN0b3IgcmV0dXJuZWQgYSBkaWZmZXJlbnQgcmVzdWx0IHdoZW4gcGFzc2VkIHNhbWUgYXJndW1lbnRzLicgK1xyXG4gICAgICAgICdcXG5UaGlzIG1lYW5zIHlvdXIgb3V0cHV0IHNlbGVjdG9yIHdpbGwgbGlrZWx5IHJ1biBtb3JlIGZyZXF1ZW50bHkgdGhhbiBpbnRlbmRlZC4nICtcclxuICAgICAgICAnXFxuQXZvaWQgcmV0dXJuaW5nIGEgbmV3IHJlZmVyZW5jZSBpbnNpZGUgeW91ciBpbnB1dCBzZWxlY3RvciwgZS5nLicgK1xyXG4gICAgICAgICdcXG5gY3JlYXRlU2VsZWN0b3IoW3N0YXRlID0+IHN0YXRlLnRvZG9zLm1hcCh0b2RvID0+IHRvZG8uaWQpXSwgdG9kb0lkcyA9PiB0b2RvSWRzLmxlbmd0aClgJyxcclxuICAgICAge1xyXG4gICAgICAgIGFyZ3VtZW50czogaW5wdXRTZWxlY3RvckFyZ3MsXHJcbiAgICAgICAgZmlyc3RJbnB1dHM6IGlucHV0U2VsZWN0b3JSZXN1bHRzLFxyXG4gICAgICAgIHNlY29uZElucHV0czogaW5wdXRTZWxlY3RvclJlc3VsdHNDb3B5LFxyXG4gICAgICAgIHN0YWNrXHJcbiAgICAgIH1cclxuICAgIClcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHR5cGUgeyBEZXZNb2RlQ2hlY2tzIH0gZnJvbSAnLi4vdHlwZXMnXHJcblxyXG4vKipcclxuICogR2xvYmFsIGNvbmZpZ3VyYXRpb24gZm9yIGRldmVsb3BtZW50IG1vZGUgY2hlY2tzLiBUaGlzIHNwZWNpZmllcyB0aGUgZGVmYXVsdFxyXG4gKiBmcmVxdWVuY3kgYXQgd2hpY2ggZWFjaCBkZXZlbG9wbWVudCBtb2RlIGNoZWNrIHNob3VsZCBiZSBwZXJmb3JtZWQuXHJcbiAqXHJcbiAqIEBzaW5jZSA1LjAuMFxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmV4cG9ydCBjb25zdCBnbG9iYWxEZXZNb2RlQ2hlY2tzOiBEZXZNb2RlQ2hlY2tzID0ge1xyXG4gIGlucHV0U3RhYmlsaXR5Q2hlY2s6ICdvbmNlJyxcclxuICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6ICdvbmNlJ1xyXG59XHJcblxyXG4vKipcclxuICogT3ZlcnJpZGVzIHRoZSBkZXZlbG9wbWVudCBtb2RlIGNoZWNrcyBzZXR0aW5ncyBmb3IgYWxsIHNlbGVjdG9ycy5cclxuICpcclxuICogUmVzZWxlY3QgcGVyZm9ybXMgYWRkaXRpb25hbCBjaGVja3MgaW4gZGV2ZWxvcG1lbnQgbW9kZSB0byBoZWxwIGlkZW50aWZ5IGFuZFxyXG4gKiB3YXJuIGFib3V0IHBvdGVudGlhbCBpc3N1ZXMgaW4gc2VsZWN0b3IgYmVoYXZpb3IuIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0b1xyXG4gKiBjdXN0b21pemUgdGhlIGJlaGF2aW9yIG9mIHRoZXNlIGNoZWNrcyBhY3Jvc3MgYWxsIHNlbGVjdG9ycyBpbiB5b3VyIGFwcGxpY2F0aW9uLlxyXG4gKlxyXG4gKiAqKk5vdGUqKjogVGhpcyBzZXR0aW5nIGNhbiBzdGlsbCBiZSBvdmVycmlkZGVuIHBlciBzZWxlY3RvciBpbnNpZGUgYGNyZWF0ZVNlbGVjdG9yYCdzIGBvcHRpb25zYCBvYmplY3QuXHJcbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3JlZHV4anMvcmVzZWxlY3QjMi1wZXItc2VsZWN0b3ItYnktcGFzc2luZy1hbi1pZGVudGl0eWZ1bmN0aW9uY2hlY2stb3B0aW9uLWRpcmVjdGx5LXRvLWNyZWF0ZXNlbGVjdG9yIHBlci1zZWxlY3Rvci1jb25maWd1cmF0aW9ufVxyXG4gKiBhbmQge0BsaW5rY29kZSBDcmVhdGVTZWxlY3Rvck9wdGlvbnMuaWRlbnRpdHlGdW5jdGlvbkNoZWNrIGlkZW50aXR5RnVuY3Rpb25DaGVja30gZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogX1RoZSBkZXZlbG9wbWVudCBtb2RlIGNoZWNrcyBkbyBub3QgcnVuIGluIHByb2R1Y3Rpb24gYnVpbGRzLl9cclxuICpcclxuICogQHBhcmFtIGRldk1vZGVDaGVja3MgLSBBbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgZGVzaXJlZCBzZXR0aW5ncyBmb3IgZGV2ZWxvcG1lbnQgbW9kZSBjaGVja3MuIFlvdSBjYW4gcHJvdmlkZSBwYXJ0aWFsIG92ZXJyaWRlcy4gVW5zcGVjaWZpZWQgc2V0dGluZ3Mgd2lsbCByZXRhaW4gdGhlaXIgY3VycmVudCB2YWx1ZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHRzXHJcbiAqIGltcG9ydCB7IHNldEdsb2JhbERldk1vZGVDaGVja3MgfSBmcm9tICdyZXNlbGVjdCdcclxuICogaW1wb3J0IHsgRGV2TW9kZUNoZWNrcyB9IGZyb20gJy4uL3R5cGVzJ1xyXG4gKlxyXG4gKiAvLyBSdW4gb25seSB0aGUgZmlyc3QgdGltZSB0aGUgc2VsZWN0b3IgaXMgY2FsbGVkLiAoZGVmYXVsdClcclxuICogc2V0R2xvYmFsRGV2TW9kZUNoZWNrcyh7IGlucHV0U3RhYmlsaXR5Q2hlY2s6ICdvbmNlJyB9KVxyXG4gKlxyXG4gKiAvLyBSdW4gZXZlcnkgdGltZSB0aGUgc2VsZWN0b3IgaXMgY2FsbGVkLlxyXG4gKiBzZXRHbG9iYWxEZXZNb2RlQ2hlY2tzKHsgaW5wdXRTdGFiaWxpdHlDaGVjazogJ2Fsd2F5cycgfSlcclxuICpcclxuICogLy8gTmV2ZXIgcnVuIHRoZSBpbnB1dCBzdGFiaWxpdHkgY2hlY2suXHJcbiAqIHNldEdsb2JhbERldk1vZGVDaGVja3MoeyBpbnB1dFN0YWJpbGl0eUNoZWNrOiAnbmV2ZXInIH0pXHJcbiAqXHJcbiAqIC8vIFJ1biBvbmx5IHRoZSBmaXJzdCB0aW1lIHRoZSBzZWxlY3RvciBpcyBjYWxsZWQuIChkZWZhdWx0KVxyXG4gKiBzZXRHbG9iYWxEZXZNb2RlQ2hlY2tzKHsgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiAnb25jZScgfSlcclxuICpcclxuICogLy8gUnVuIGV2ZXJ5IHRpbWUgdGhlIHNlbGVjdG9yIGlzIGNhbGxlZC5cclxuICogc2V0R2xvYmFsRGV2TW9kZUNoZWNrcyh7IGlkZW50aXR5RnVuY3Rpb25DaGVjazogJ2Fsd2F5cycgfSlcclxuICpcclxuICogLy8gTmV2ZXIgcnVuIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBjaGVjay5cclxuICogc2V0R2xvYmFsRGV2TW9kZUNoZWNrcyh7IGlkZW50aXR5RnVuY3Rpb25DaGVjazogJ25ldmVyJyB9KVxyXG4gKiBgYGBcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZXNlbGVjdC5qcy5vcmcvYXBpL2RldmVsb3BtZW50LW9ubHktc3RhYmlsaXR5LWNoZWNrcyBEZXZlbG9wbWVudC1Pbmx5IFN0YWJpbGl0eSBDaGVja3N9XHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVzZWxlY3QuanMub3JnL2FwaS9kZXZlbG9wbWVudC1vbmx5LXN0YWJpbGl0eS1jaGVja3MjMS1nbG9iYWxseS10aHJvdWdoLXNldGdsb2JhbGRldm1vZGVjaGVja3MgZ2xvYmFsLWNvbmZpZ3VyYXRpb259XHJcbiAqXHJcbiAqIEBzaW5jZSA1LjAuMFxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2V0R2xvYmFsRGV2TW9kZUNoZWNrcyA9IChcclxuICBkZXZNb2RlQ2hlY2tzOiBQYXJ0aWFsPERldk1vZGVDaGVja3M+XHJcbikgPT4ge1xyXG4gIE9iamVjdC5hc3NpZ24oZ2xvYmFsRGV2TW9kZUNoZWNrcywgZGV2TW9kZUNoZWNrcylcclxufVxyXG4iLCJpbXBvcnQgeyBydW5JZGVudGl0eUZ1bmN0aW9uQ2hlY2sgfSBmcm9tICcuL2Rldk1vZGVDaGVja3MvaWRlbnRpdHlGdW5jdGlvbkNoZWNrJ1xyXG5pbXBvcnQgeyBydW5JbnB1dFN0YWJpbGl0eUNoZWNrIH0gZnJvbSAnLi9kZXZNb2RlQ2hlY2tzL2lucHV0U3RhYmlsaXR5Q2hlY2snXHJcbmltcG9ydCB7IGdsb2JhbERldk1vZGVDaGVja3MgfSBmcm9tICcuL2Rldk1vZGVDaGVja3Mvc2V0R2xvYmFsRGV2TW9kZUNoZWNrcydcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jb25zaXN0ZW50LXR5cGUtaW1wb3J0c1xyXG5pbXBvcnQgdHlwZSB7XHJcbiAgRGV2TW9kZUNoZWNrcyxcclxuICBTZWxlY3RvcixcclxuICBTZWxlY3RvckFycmF5LFxyXG4gIERldk1vZGVDaGVja3NFeGVjdXRpb25JbmZvXHJcbn0gZnJvbSAnLi90eXBlcydcclxuXHJcbmV4cG9ydCBjb25zdCBOT1RfRk9VTkQgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCdOT1RfRk9VTkQnKVxyXG5leHBvcnQgdHlwZSBOT1RfRk9VTkRfVFlQRSA9IHR5cGVvZiBOT1RfRk9VTkRcclxuXHJcbi8qKlxyXG4gKiBBc3NlcnQgdGhhdCB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSBmdW5jdGlvbi4gSWYgdGhlIGFzc2VydGlvbiBmYWlscyxcclxuICogYSBgVHlwZUVycm9yYCBpcyB0aHJvd24gd2l0aCBhbiBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZS5cclxuICpcclxuICogQHBhcmFtIGZ1bmMgLSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cclxuICogQHBhcmFtICBlcnJvck1lc3NhZ2UgLSBBbiBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZSB0byB1c2UgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cclxuICogQHRocm93cyBBIGBUeXBlRXJyb3JgIGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNGdW5jdGlvbjxGdW5jdGlvblR5cGUgZXh0ZW5kcyBGdW5jdGlvbj4oXHJcbiAgZnVuYzogdW5rbm93bixcclxuICBlcnJvck1lc3NhZ2UgPSBgZXhwZWN0ZWQgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCAke3R5cGVvZiBmdW5jfWBcclxuKTogYXNzZXJ0cyBmdW5jIGlzIEZ1bmN0aW9uVHlwZSB7XHJcbiAgaWYgKHR5cGVvZiBmdW5jICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGVycm9yTWVzc2FnZSlcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBc3NlcnQgdGhhdCB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYW4gb2JqZWN0LiBJZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLFxyXG4gKiBhIGBUeXBlRXJyb3JgIGlzIHRocm93biB3aXRoIGFuIG9wdGlvbmFsIGN1c3RvbSBlcnJvciBtZXNzYWdlLlxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXHJcbiAqIEBwYXJhbSAgZXJyb3JNZXNzYWdlIC0gQW4gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2UgdG8gdXNlIGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXHJcbiAqIEB0aHJvd3MgQSBgVHlwZUVycm9yYCBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydElzT2JqZWN0PE9iamVjdFR5cGUgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXHJcbiAgb2JqZWN0OiB1bmtub3duLFxyXG4gIGVycm9yTWVzc2FnZSA9IGBleHBlY3RlZCBhbiBvYmplY3QsIGluc3RlYWQgcmVjZWl2ZWQgJHt0eXBlb2Ygb2JqZWN0fWBcclxuKTogYXNzZXJ0cyBvYmplY3QgaXMgT2JqZWN0VHlwZSB7XHJcbiAgaWYgKHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGVycm9yTWVzc2FnZSlcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBc3NlcnQgdGhhdCB0aGUgcHJvdmlkZWQgYXJyYXkgaXMgYW4gYXJyYXkgb2YgZnVuY3Rpb25zLiBJZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLFxyXG4gKiBhIGBUeXBlRXJyb3JgIGlzIHRocm93biB3aXRoIGFuIG9wdGlvbmFsIGN1c3RvbSBlcnJvciBtZXNzYWdlLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gYmUgY2hlY2tlZC5cclxuICogQHBhcmFtICBlcnJvck1lc3NhZ2UgLSBBbiBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZSB0byB1c2UgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cclxuICogQHRocm93cyBBIGBUeXBlRXJyb3JgIGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNBcnJheU9mRnVuY3Rpb25zPEZ1bmN0aW9uVHlwZSBleHRlbmRzIEZ1bmN0aW9uPihcclxuICBhcnJheTogdW5rbm93bltdLFxyXG4gIGVycm9yTWVzc2FnZSA9IGBleHBlY3RlZCBhbGwgaXRlbXMgdG8gYmUgZnVuY3Rpb25zLCBpbnN0ZWFkIHJlY2VpdmVkIHRoZSBmb2xsb3dpbmcgdHlwZXM6IGBcclxuKTogYXNzZXJ0cyBhcnJheSBpcyBGdW5jdGlvblR5cGVbXSB7XHJcbiAgaWYgKFxyXG4gICAgIWFycmF5LmV2ZXJ5KChpdGVtKTogaXRlbSBpcyBGdW5jdGlvblR5cGUgPT4gdHlwZW9mIGl0ZW0gPT09ICdmdW5jdGlvbicpXHJcbiAgKSB7XHJcbiAgICBjb25zdCBpdGVtVHlwZXMgPSBhcnJheVxyXG4gICAgICAubWFwKGl0ZW0gPT5cclxuICAgICAgICB0eXBlb2YgaXRlbSA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICAgPyBgZnVuY3Rpb24gJHtpdGVtLm5hbWUgfHwgJ3VubmFtZWQnfSgpYFxyXG4gICAgICAgICAgOiB0eXBlb2YgaXRlbVxyXG4gICAgICApXHJcbiAgICAgIC5qb2luKCcsICcpXHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2Vycm9yTWVzc2FnZX1bJHtpdGVtVHlwZXN9XWApXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRW5zdXJlIHRoYXQgdGhlIGlucHV0IGlzIGFuIGFycmF5LiBJZiBpdCdzIGFscmVhZHkgYW4gYXJyYXksIGl0J3MgcmV0dXJuZWQgYXMgaXMuXHJcbiAqIElmIGl0J3Mgbm90IGFuIGFycmF5LCBpdCB3aWxsIGJlIHdyYXBwZWQgaW4gYSBuZXcgYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSBpdGVtIC0gVGhlIGl0ZW0gdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgaW5wdXQgaXRlbS4gSWYgdGhlIGlucHV0IGlzIGFscmVhZHkgYW4gYXJyYXksIGl0J3MgcmV0dXJuZWQgd2l0aG91dCBtb2RpZmljYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZW5zdXJlSXNBcnJheSA9IChpdGVtOiB1bmtub3duKSA9PiB7XHJcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaXRlbSkgPyBpdGVtIDogW2l0ZW1dXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0cyB0aGUgXCJkZXBlbmRlbmNpZXNcIiAvIFwiaW5wdXQgc2VsZWN0b3JzXCIgZnJvbSB0aGUgYXJndW1lbnRzIG9mIGBjcmVhdGVTZWxlY3RvcmAuXHJcbiAqXHJcbiAqIEBwYXJhbSBjcmVhdGVTZWxlY3RvckFyZ3MgLSBBcmd1bWVudHMgcGFzc2VkIHRvIGBjcmVhdGVTZWxlY3RvcmAgYXMgYW4gYXJyYXkuXHJcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIFwiaW5wdXQgc2VsZWN0b3JzXCIgLyBcImRlcGVuZGVuY2llc1wiLlxyXG4gKiBAdGhyb3dzIEEgYFR5cGVFcnJvcmAgaWYgYW55IG9mIHRoZSBpbnB1dCBzZWxlY3RvcnMgaXMgbm90IGZ1bmN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERlcGVuZGVuY2llcyhjcmVhdGVTZWxlY3RvckFyZ3M6IHVua25vd25bXSkge1xyXG4gIGNvbnN0IGRlcGVuZGVuY2llcyA9IEFycmF5LmlzQXJyYXkoY3JlYXRlU2VsZWN0b3JBcmdzWzBdKVxyXG4gICAgPyBjcmVhdGVTZWxlY3RvckFyZ3NbMF1cclxuICAgIDogY3JlYXRlU2VsZWN0b3JBcmdzXHJcblxyXG4gIGFzc2VydElzQXJyYXlPZkZ1bmN0aW9uczxTZWxlY3Rvcj4oXHJcbiAgICBkZXBlbmRlbmNpZXMsXHJcbiAgICBgY3JlYXRlU2VsZWN0b3IgZXhwZWN0cyBhbGwgaW5wdXQtc2VsZWN0b3JzIHRvIGJlIGZ1bmN0aW9ucywgYnV0IHJlY2VpdmVkIHRoZSBmb2xsb3dpbmcgdHlwZXM6IGBcclxuICApXHJcblxyXG4gIHJldHVybiBkZXBlbmRlbmNpZXMgYXMgU2VsZWN0b3JBcnJheVxyXG59XHJcblxyXG4vKipcclxuICogUnVucyBlYWNoIGlucHV0IHNlbGVjdG9yIGFuZCByZXR1cm5zIHRoZWlyIGNvbGxlY3RpdmUgcmVzdWx0cyBhcyBhbiBhcnJheS5cclxuICpcclxuICogQHBhcmFtIGRlcGVuZGVuY2llcyAtIEFuIGFycmF5IG9mIFwiZGVwZW5kZW5jaWVzXCIgb3IgXCJpbnB1dCBzZWxlY3RvcnNcIi5cclxuICogQHBhcmFtIGlucHV0U2VsZWN0b3JBcmdzIC0gQW4gYXJyYXkgb2YgYXJndW1lbnRzIGJlaW5nIHBhc3NlZCB0byB0aGUgaW5wdXQgc2VsZWN0b3JzLlxyXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBpbnB1dCBzZWxlY3RvciByZXN1bHRzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RJbnB1dFNlbGVjdG9yUmVzdWx0cyhcclxuICBkZXBlbmRlbmNpZXM6IFNlbGVjdG9yQXJyYXksXHJcbiAgaW5wdXRTZWxlY3RvckFyZ3M6IHVua25vd25bXSB8IElBcmd1bWVudHNcclxuKSB7XHJcbiAgY29uc3QgaW5wdXRTZWxlY3RvclJlc3VsdHMgPSBbXVxyXG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBkZXBlbmRlbmNpZXNcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAvLyBhcHBseSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgYW5kIG11dGF0ZSBhIGxvY2FsIGxpc3Qgb2YgcGFyYW1zIGZvciBwZXJmb3JtYW5jZS5cclxuICAgIGlucHV0U2VsZWN0b3JSZXN1bHRzLnB1c2goZGVwZW5kZW5jaWVzW2ldLmFwcGx5KG51bGwsIGlucHV0U2VsZWN0b3JBcmdzKSlcclxuICB9XHJcbiAgcmV0dXJuIGlucHV0U2VsZWN0b3JSZXN1bHRzXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgZXhlY3V0aW9uIGluZm9ybWF0aW9uIGZvciBkZXZlbG9wbWVudCBtb2RlIGNoZWNrcy5cclxuICpcclxuICogQHBhcmFtIGRldk1vZGVDaGVja3MgLSBDdXN0b20gU2V0dGluZ3MgZm9yIGRldmVsb3BtZW50IG1vZGUgY2hlY2tzLiBUaGVzZSBzZXR0aW5ncyB3aWxsIG92ZXJyaWRlIHRoZSBnbG9iYWwgZGVmYXVsdHMuXHJcbiAqIEBwYXJhbSBmaXJzdFJ1biAtIEluZGljYXRlcyB3aGV0aGVyIGl0IGlzIHRoZSBmaXJzdCB0aW1lIHRoZSBzZWxlY3RvciBoYXMgcnVuLlxyXG4gKiBAcmV0dXJucyAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGV4ZWN1dGlvbiBpbmZvcm1hdGlvbiBmb3IgZWFjaCBkZXZlbG9wbWVudCBtb2RlIGNoZWNrLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldERldk1vZGVDaGVja3NFeGVjdXRpb25JbmZvID0gKFxyXG4gIGZpcnN0UnVuOiBib29sZWFuLFxyXG4gIGRldk1vZGVDaGVja3M6IFBhcnRpYWw8RGV2TW9kZUNoZWNrcz5cclxuKSA9PiB7XHJcbiAgY29uc3QgeyBpZGVudGl0eUZ1bmN0aW9uQ2hlY2ssIGlucHV0U3RhYmlsaXR5Q2hlY2sgfSA9IHtcclxuICAgIC4uLmdsb2JhbERldk1vZGVDaGVja3MsXHJcbiAgICAuLi5kZXZNb2RlQ2hlY2tzXHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6IHtcclxuICAgICAgc2hvdWxkUnVuOlxyXG4gICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gJ2Fsd2F5cycgfHxcclxuICAgICAgICAoaWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSAnb25jZScgJiYgZmlyc3RSdW4pLFxyXG4gICAgICBydW46IHJ1bklkZW50aXR5RnVuY3Rpb25DaGVja1xyXG4gICAgfSxcclxuICAgIGlucHV0U3RhYmlsaXR5Q2hlY2s6IHtcclxuICAgICAgc2hvdWxkUnVuOlxyXG4gICAgICAgIGlucHV0U3RhYmlsaXR5Q2hlY2sgPT09ICdhbHdheXMnIHx8XHJcbiAgICAgICAgKGlucHV0U3RhYmlsaXR5Q2hlY2sgPT09ICdvbmNlJyAmJiBmaXJzdFJ1biksXHJcbiAgICAgIHJ1bjogcnVuSW5wdXRTdGFiaWxpdHlDaGVja1xyXG4gICAgfVxyXG4gIH0gc2F0aXNmaWVzIERldk1vZGVDaGVja3NFeGVjdXRpb25JbmZvXHJcbn1cclxuIiwiLy8gT3JpZ2luYWwgYXV0b3RyYWNraW5nIGltcGxlbWVudGF0aW9uIHNvdXJjZTpcclxuLy8gLSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wenVyYXEvNzliZjg2MmUwZjhjZDk1MjFiNzljNGI2ZWNjZGM0ZjlcclxuLy8gQWRkaXRpb25hbCByZWZlcmVuY2VzOlxyXG4vLyAtIGh0dHBzOi8vd3d3LnB6dXJhcS5jb20vYmxvZy9ob3ctYXV0b3RyYWNraW5nLXdvcmtzXHJcbi8vIC0gaHR0cHM6Ly92NS5jaHJpc2tyeWNoby5jb20vam91cm5hbC9hdXRvdHJhY2tpbmctZWxlZ2FudC1keC12aWEtY3V0dGluZy1lZGdlLWNzL1xyXG5pbXBvcnQgdHlwZSB7IEVxdWFsaXR5Rm4gfSBmcm9tICcuLi90eXBlcydcclxuaW1wb3J0IHsgYXNzZXJ0SXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzJ1xyXG5cclxuLy8gVGhlIGdsb2JhbCByZXZpc2lvbiBjbG9jay4gRXZlcnkgdGltZSBzdGF0ZSBjaGFuZ2VzLCB0aGUgY2xvY2sgaW5jcmVtZW50cy5cclxuZXhwb3J0IGxldCAkUkVWSVNJT04gPSAwXHJcblxyXG4vLyBUaGUgY3VycmVudCBkZXBlbmRlbmN5IHRyYWNrZXIuIFdoZW5ldmVyIHdlIGNvbXB1dGUgYSBjYWNoZSwgd2UgY3JlYXRlIGEgU2V0XHJcbi8vIHRvIHRyYWNrIGFueSBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgdXNlZCB3aGlsZSBjb21wdXRpbmcuIElmIG5vIGNhY2hlIGlzXHJcbi8vIGNvbXB1dGluZywgdGhlbiB0aGUgdHJhY2tlciBpcyBudWxsLlxyXG5sZXQgQ1VSUkVOVF9UUkFDS0VSOiBTZXQ8Q2VsbDxhbnk+IHwgVHJhY2tpbmdDYWNoZT4gfCBudWxsID0gbnVsbFxyXG5cclxuLy8gU3RvcmFnZSByZXByZXNlbnRzIGEgcm9vdCB2YWx1ZSBpbiB0aGUgc3lzdGVtIC0gdGhlIGFjdHVhbCBzdGF0ZSBvZiBvdXIgYXBwLlxyXG5leHBvcnQgY2xhc3MgQ2VsbDxUPiB7XHJcbiAgcmV2aXNpb24gPSAkUkVWSVNJT05cclxuXHJcbiAgX3ZhbHVlOiBUXHJcbiAgX2xhc3RWYWx1ZTogVFxyXG4gIF9pc0VxdWFsOiBFcXVhbGl0eUZuID0gdHJpcGxlRXFcclxuXHJcbiAgY29uc3RydWN0b3IoaW5pdGlhbFZhbHVlOiBULCBpc0VxdWFsOiBFcXVhbGl0eUZuID0gdHJpcGxlRXEpIHtcclxuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fbGFzdFZhbHVlID0gaW5pdGlhbFZhbHVlXHJcbiAgICB0aGlzLl9pc0VxdWFsID0gaXNFcXVhbFxyXG4gIH1cclxuXHJcbiAgLy8gV2hlbmV2ZXIgYSBzdG9yYWdlIHZhbHVlIGlzIHJlYWQsIGl0J2xsIGFkZCBpdHNlbGYgdG8gdGhlIGN1cnJlbnQgdHJhY2tlciBpZlxyXG4gIC8vIG9uZSBleGlzdHMsIGVudGFuZ2xpbmcgaXRzIHN0YXRlIHdpdGggdGhhdCBjYWNoZS5cclxuICBnZXQgdmFsdWUoKSB7XHJcbiAgICBDVVJSRU5UX1RSQUNLRVI/LmFkZCh0aGlzKVxyXG5cclxuICAgIHJldHVybiB0aGlzLl92YWx1ZVxyXG4gIH1cclxuXHJcbiAgLy8gV2hlbmV2ZXIgYSBzdG9yYWdlIHZhbHVlIGlzIHVwZGF0ZWQsIHdlIGJ1bXAgdGhlIGdsb2JhbCByZXZpc2lvbiBjbG9jayxcclxuICAvLyBhc3NpZ24gdGhlIHJldmlzaW9uIGZvciB0aGlzIHN0b3JhZ2UgdG8gdGhlIG5ldyB2YWx1ZSwgX2FuZF8gd2Ugc2NoZWR1bGUgYVxyXG4gIC8vIHJlcmVuZGVyLiBUaGlzIGlzIGltcG9ydGFudCwgYW5kIGl0J3Mgd2hhdCBtYWtlcyBhdXRvdHJhY2tpbmcgIF9wdWxsX1xyXG4gIC8vIGJhc2VkLiBXZSBkb24ndCBhY3RpdmVseSB0ZWxsIHRoZSBjYWNoZXMgd2hpY2ggZGVwZW5kIG9uIHRoZSBzdG9yYWdlIHRoYXRcclxuICAvLyBhbnl0aGluZyBoYXMgaGFwcGVuZWQuIEluc3RlYWQsIHdlIHJlY29tcHV0ZSB0aGUgY2FjaGVzIHdoZW4gbmVlZGVkLlxyXG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xyXG4gICAgaWYgKHRoaXMudmFsdWUgPT09IG5ld1ZhbHVlKSByZXR1cm5cclxuXHJcbiAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlXHJcbiAgICB0aGlzLnJldmlzaW9uID0gKyskUkVWSVNJT05cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyaXBsZUVxKGE6IHVua25vd24sIGI6IHVua25vd24pIHtcclxuICByZXR1cm4gYSA9PT0gYlxyXG59XHJcblxyXG4vLyBDYWNoZXMgcmVwcmVzZW50IGRlcml2ZWQgc3RhdGUgaW4gdGhlIHN5c3RlbS4gVGhleSBhcmUgdWx0aW1hdGVseSBmdW5jdGlvbnNcclxuLy8gdGhhdCBhcmUgbWVtb2l6ZWQgYmFzZWQgb24gd2hhdCBzdGF0ZSB0aGV5IHVzZSB0byBwcm9kdWNlIHRoZWlyIG91dHB1dCxcclxuLy8gbWVhbmluZyB0aGV5IHdpbGwgb25seSByZXJ1biBJRkYgYSBzdG9yYWdlIHZhbHVlIHRoYXQgY291bGQgYWZmZWN0IHRoZSBvdXRwdXRcclxuLy8gaGFzIGNoYW5nZWQuIE90aGVyd2lzZSwgdGhleSdsbCByZXR1cm4gdGhlIGNhY2hlZCB2YWx1ZS5cclxuZXhwb3J0IGNsYXNzIFRyYWNraW5nQ2FjaGUge1xyXG4gIF9jYWNoZWRWYWx1ZTogYW55XHJcbiAgX2NhY2hlZFJldmlzaW9uID0gLTFcclxuICBfZGVwczogYW55W10gPSBbXVxyXG4gIGhpdHMgPSAwXHJcblxyXG4gIGZuOiAoKSA9PiBhbnlcclxuXHJcbiAgY29uc3RydWN0b3IoZm46ICgpID0+IGFueSkge1xyXG4gICAgdGhpcy5mbiA9IGZuXHJcbiAgfVxyXG5cclxuICBjbGVhcigpIHtcclxuICAgIHRoaXMuX2NhY2hlZFZhbHVlID0gdW5kZWZpbmVkXHJcbiAgICB0aGlzLl9jYWNoZWRSZXZpc2lvbiA9IC0xXHJcbiAgICB0aGlzLl9kZXBzID0gW11cclxuICAgIHRoaXMuaGl0cyA9IDBcclxuICB9XHJcblxyXG4gIGdldCB2YWx1ZSgpIHtcclxuICAgIC8vIFdoZW4gZ2V0dGluZyB0aGUgdmFsdWUgZm9yIGEgQ2FjaGUsIGZpcnN0IHdlIGNoZWNrIGFsbCB0aGUgZGVwZW5kZW5jaWVzIG9mXHJcbiAgICAvLyB0aGUgY2FjaGUgdG8gc2VlIHdoYXQgdGhlaXIgY3VycmVudCByZXZpc2lvbiBpcy4gSWYgdGhlIGN1cnJlbnQgcmV2aXNpb24gaXNcclxuICAgIC8vIGdyZWF0ZXIgdGhhbiB0aGUgY2FjaGVkIHJldmlzaW9uLCB0aGVuIHNvbWV0aGluZyBoYXMgY2hhbmdlZC5cclxuICAgIGlmICh0aGlzLnJldmlzaW9uID4gdGhpcy5fY2FjaGVkUmV2aXNpb24pIHtcclxuICAgICAgY29uc3QgeyBmbiB9ID0gdGhpc1xyXG5cclxuICAgICAgLy8gV2UgY3JlYXRlIGEgbmV3IGRlcGVuZGVuY3kgdHJhY2tlciBmb3IgdGhpcyBjYWNoZS4gQXMgdGhlIGNhY2hlIHJ1bnNcclxuICAgICAgLy8gaXRzIGZ1bmN0aW9uLCBhbnkgU3RvcmFnZSBvciBDYWNoZSBpbnN0YW5jZXMgd2hpY2ggYXJlIHVzZWQgd2hpbGVcclxuICAgICAgLy8gY29tcHV0aW5nIHdpbGwgYmUgYWRkZWQgdG8gdGhpcyB0cmFja2VyLiBJbiB0aGUgZW5kLCBpdCB3aWxsIGJlIHRoZVxyXG4gICAgICAvLyBmdWxsIGxpc3Qgb2YgZGVwZW5kZW5jaWVzIHRoYXQgdGhpcyBDYWNoZSBkZXBlbmRzIG9uLlxyXG4gICAgICBjb25zdCBjdXJyZW50VHJhY2tlciA9IG5ldyBTZXQ8Q2VsbDxhbnk+PigpXHJcbiAgICAgIGNvbnN0IHByZXZUcmFja2VyID0gQ1VSUkVOVF9UUkFDS0VSXHJcblxyXG4gICAgICBDVVJSRU5UX1RSQUNLRVIgPSBjdXJyZW50VHJhY2tlclxyXG5cclxuICAgICAgLy8gdHJ5IHtcclxuICAgICAgdGhpcy5fY2FjaGVkVmFsdWUgPSBmbigpXHJcbiAgICAgIC8vIH0gZmluYWxseSB7XHJcbiAgICAgIENVUlJFTlRfVFJBQ0tFUiA9IHByZXZUcmFja2VyXHJcbiAgICAgIHRoaXMuaGl0cysrXHJcbiAgICAgIHRoaXMuX2RlcHMgPSBBcnJheS5mcm9tKGN1cnJlbnRUcmFja2VyKVxyXG5cclxuICAgICAgLy8gU2V0IHRoZSBjYWNoZWQgcmV2aXNpb24uIFRoaXMgaXMgdGhlIGN1cnJlbnQgY2xvY2sgY291bnQgb2YgYWxsIHRoZVxyXG4gICAgICAvLyBkZXBlbmRlbmNpZXMuIElmIGFueSBkZXBlbmRlbmN5IGNoYW5nZXMsIHRoaXMgbnVtYmVyIHdpbGwgYmUgbGVzc1xyXG4gICAgICAvLyB0aGFuIHRoZSBuZXcgcmV2aXNpb24uXHJcbiAgICAgIHRoaXMuX2NhY2hlZFJldmlzaW9uID0gdGhpcy5yZXZpc2lvblxyXG4gICAgICAvLyB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBjdXJyZW50IHRyYWNrZXIsIGl0IG1lYW5zIGFub3RoZXIgQ2FjaGUgaXMgY29tcHV0aW5nIGFuZFxyXG4gICAgLy8gdXNpbmcgdGhpcyBvbmUsIHNvIHdlIGFkZCB0aGlzIG9uZSB0byB0aGUgdHJhY2tlci5cclxuICAgIENVUlJFTlRfVFJBQ0tFUj8uYWRkKHRoaXMpXHJcblxyXG4gICAgLy8gQWx3YXlzIHJldHVybiB0aGUgY2FjaGVkIHZhbHVlLlxyXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFZhbHVlXHJcbiAgfVxyXG5cclxuICBnZXQgcmV2aXNpb24oKSB7XHJcbiAgICAvLyBUaGUgY3VycmVudCByZXZpc2lvbiBpcyB0aGUgbWF4IG9mIGFsbCB0aGUgZGVwZW5kZW5jaWVzJyByZXZpc2lvbnMuXHJcbiAgICByZXR1cm4gTWF0aC5tYXgoLi4udGhpcy5fZGVwcy5tYXAoZCA9PiBkLnJldmlzaW9uKSwgMClcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZTxUPihjZWxsOiBDZWxsPFQ+KTogVCB7XHJcbiAgaWYgKCEoY2VsbCBpbnN0YW5jZW9mIENlbGwpKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ05vdCBhIHZhbGlkIGNlbGwhICcsIGNlbGwpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gY2VsbC52YWx1ZVxyXG59XHJcblxyXG50eXBlIENlbGxWYWx1ZTxUIGV4dGVuZHMgQ2VsbDx1bmtub3duPj4gPSBUIGV4dGVuZHMgQ2VsbDxpbmZlciBVPiA/IFUgOiBuZXZlclxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFZhbHVlPFQgZXh0ZW5kcyBDZWxsPHVua25vd24+PihcclxuICBzdG9yYWdlOiBULFxyXG4gIHZhbHVlOiBDZWxsVmFsdWU8VD5cclxuKTogdm9pZCB7XHJcbiAgaWYgKCEoc3RvcmFnZSBpbnN0YW5jZW9mIENlbGwpKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgICAnc2V0VmFsdWUgbXVzdCBiZSBwYXNzZWQgYSB0cmFja2VkIHN0b3JlIGNyZWF0ZWQgd2l0aCBgY3JlYXRlU3RvcmFnZWAuJ1xyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgc3RvcmFnZS52YWx1ZSA9IHN0b3JhZ2UuX2xhc3RWYWx1ZSA9IHZhbHVlXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDZWxsPFQgPSB1bmtub3duPihcclxuICBpbml0aWFsVmFsdWU6IFQsXHJcbiAgaXNFcXVhbDogRXF1YWxpdHlGbiA9IHRyaXBsZUVxXHJcbik6IENlbGw8VD4ge1xyXG4gIHJldHVybiBuZXcgQ2VsbChpbml0aWFsVmFsdWUsIGlzRXF1YWwpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYWNoZTxUID0gdW5rbm93bj4oZm46ICgpID0+IFQpOiBUcmFja2luZ0NhY2hlIHtcclxuICBhc3NlcnRJc0Z1bmN0aW9uKFxyXG4gICAgZm4sXHJcbiAgICAndGhlIGZpcnN0IHBhcmFtZXRlciB0byBgY3JlYXRlQ2FjaGVgIG11c3QgYmUgYSBmdW5jdGlvbidcclxuICApXHJcblxyXG4gIHJldHVybiBuZXcgVHJhY2tpbmdDYWNoZShmbilcclxufVxyXG4iLCJpbXBvcnQgdHlwZSB7IENlbGwgfSBmcm9tICcuL2F1dG90cmFja2luZydcclxuaW1wb3J0IHtcclxuICBnZXRWYWx1ZSBhcyBjb25zdW1lVGFnLFxyXG4gIGNyZWF0ZUNlbGwgYXMgY3JlYXRlU3RvcmFnZSxcclxuICBzZXRWYWx1ZVxyXG59IGZyb20gJy4vYXV0b3RyYWNraW5nJ1xyXG5cclxuZXhwb3J0IHR5cGUgVGFnID0gQ2VsbDx1bmtub3duPlxyXG5cclxuY29uc3QgbmV2ZXJFcSA9IChhOiBhbnksIGI6IGFueSk6IGJvb2xlYW4gPT4gZmFsc2VcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUYWcoKTogVGFnIHtcclxuICByZXR1cm4gY3JlYXRlU3RvcmFnZShudWxsLCBuZXZlckVxKVxyXG59XHJcbmV4cG9ydCB7IGNvbnN1bWVUYWcgfVxyXG5leHBvcnQgZnVuY3Rpb24gZGlydHlUYWcodGFnOiBUYWcsIHZhbHVlOiBhbnkpOiB2b2lkIHtcclxuICBzZXRWYWx1ZSh0YWcsIHZhbHVlKVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE5vZGU8XHJcbiAgVCBleHRlbmRzIEFycmF5PHVua25vd24+IHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPVxyXG4gICAgfCBBcnJheTx1bmtub3duPlxyXG4gICAgfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxyXG4+IHtcclxuICBjb2xsZWN0aW9uVGFnOiBUYWcgfCBudWxsXHJcbiAgdGFnOiBUYWcgfCBudWxsXHJcbiAgdGFnczogUmVjb3JkPHN0cmluZywgVGFnPlxyXG4gIGNoaWxkcmVuOiBSZWNvcmQ8c3RyaW5nLCBOb2RlPlxyXG4gIHByb3h5OiBUXHJcbiAgdmFsdWU6IFRcclxuICBpZDogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjb25zdW1lQ29sbGVjdGlvbiA9IChub2RlOiBOb2RlKTogdm9pZCA9PiB7XHJcbiAgbGV0IHRhZyA9IG5vZGUuY29sbGVjdGlvblRhZ1xyXG5cclxuICBpZiAodGFnID09PSBudWxsKSB7XHJcbiAgICB0YWcgPSBub2RlLmNvbGxlY3Rpb25UYWcgPSBjcmVhdGVUYWcoKVxyXG4gIH1cclxuXHJcbiAgY29uc3VtZVRhZyh0YWcpXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBkaXJ0eUNvbGxlY3Rpb24gPSAobm9kZTogTm9kZSk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IHRhZyA9IG5vZGUuY29sbGVjdGlvblRhZ1xyXG5cclxuICBpZiAodGFnICE9PSBudWxsKSB7XHJcbiAgICBkaXJ0eVRhZyh0YWcsIG51bGwpXHJcbiAgfVxyXG59XHJcbiIsIi8vIE9yaWdpbmFsIHNvdXJjZTpcclxuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vc2ltb25paG1pZy90cmFja2VkLXJlZHV4L2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3RyYWNrZWQtcmVkdXgvc3JjLy1wcml2YXRlL3Byb3h5LnRzXHJcblxyXG5pbXBvcnQgdHlwZSB7IE5vZGUsIFRhZyB9IGZyb20gJy4vdHJhY2tpbmcnXHJcbmltcG9ydCB7XHJcbiAgY29uc3VtZUNvbGxlY3Rpb24sXHJcbiAgY29uc3VtZVRhZyxcclxuICBjcmVhdGVUYWcsXHJcbiAgZGlydHlDb2xsZWN0aW9uLFxyXG4gIGRpcnR5VGFnXHJcbn0gZnJvbSAnLi90cmFja2luZydcclxuXHJcbmV4cG9ydCBjb25zdCBSRURVWF9QUk9YWV9MQUJFTCA9IFN5bWJvbCgpXHJcblxyXG5sZXQgbmV4dElkID0gMFxyXG5cclxuY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pXHJcblxyXG5jbGFzcyBPYmplY3RUcmVlTm9kZTxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+IGltcGxlbWVudHMgTm9kZTxUPiB7XHJcbiAgcHJveHk6IFQgPSBuZXcgUHJveHkodGhpcywgb2JqZWN0UHJveHlIYW5kbGVyKSBhcyB1bmtub3duIGFzIFRcclxuICB0YWcgPSBjcmVhdGVUYWcoKVxyXG4gIHRhZ3MgPSB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBUYWc+XHJcbiAgY2hpbGRyZW4gPSB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBOb2RlPlxyXG4gIGNvbGxlY3Rpb25UYWcgPSBudWxsXHJcbiAgaWQgPSBuZXh0SWQrK1xyXG5cclxuICBjb25zdHJ1Y3RvcihwdWJsaWMgdmFsdWU6IFQpIHtcclxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxyXG4gICAgdGhpcy50YWcudmFsdWUgPSB2YWx1ZVxyXG4gIH1cclxufVxyXG5cclxuY29uc3Qgb2JqZWN0UHJveHlIYW5kbGVyID0ge1xyXG4gIGdldChub2RlOiBOb2RlLCBrZXk6IHN0cmluZyB8IHN5bWJvbCk6IHVua25vd24ge1xyXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlUmVzdWx0KCkge1xyXG4gICAgICBjb25zdCB7IHZhbHVlIH0gPSBub2RlXHJcblxyXG4gICAgICBjb25zdCBjaGlsZFZhbHVlID0gUmVmbGVjdC5nZXQodmFsdWUsIGtleSlcclxuXHJcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3ltYm9sJykge1xyXG4gICAgICAgIHJldHVybiBjaGlsZFZhbHVlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChrZXkgaW4gcHJvdG8pIHtcclxuICAgICAgICByZXR1cm4gY2hpbGRWYWx1ZVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGNoaWxkVmFsdWUgPT09ICdvYmplY3QnICYmIGNoaWxkVmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICBsZXQgY2hpbGROb2RlID0gbm9kZS5jaGlsZHJlbltrZXldXHJcblxyXG4gICAgICAgIGlmIChjaGlsZE5vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgY2hpbGROb2RlID0gbm9kZS5jaGlsZHJlbltrZXldID0gY3JlYXRlTm9kZShjaGlsZFZhbHVlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNoaWxkTm9kZS50YWcpIHtcclxuICAgICAgICAgIGNvbnN1bWVUYWcoY2hpbGROb2RlLnRhZylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGlsZE5vZGUucHJveHlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZXQgdGFnID0gbm9kZS50YWdzW2tleV1cclxuXHJcbiAgICAgICAgaWYgKHRhZyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0YWcgPSBub2RlLnRhZ3Nba2V5XSA9IGNyZWF0ZVRhZygpXHJcbiAgICAgICAgICB0YWcudmFsdWUgPSBjaGlsZFZhbHVlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdW1lVGFnKHRhZylcclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkVmFsdWVcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzID0gY2FsY3VsYXRlUmVzdWx0KClcclxuICAgIHJldHVybiByZXNcclxuICB9LFxyXG5cclxuICBvd25LZXlzKG5vZGU6IE5vZGUpOiBBcnJheUxpa2U8c3RyaW5nIHwgc3ltYm9sPiB7XHJcbiAgICBjb25zdW1lQ29sbGVjdGlvbihub2RlKVxyXG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhub2RlLnZhbHVlKVxyXG4gIH0sXHJcblxyXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihcclxuICAgIG5vZGU6IE5vZGUsXHJcbiAgICBwcm9wOiBzdHJpbmcgfCBzeW1ib2xcclxuICApOiBQcm9wZXJ0eURlc2NyaXB0b3IgfCB1bmRlZmluZWQge1xyXG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUudmFsdWUsIHByb3ApXHJcbiAgfSxcclxuXHJcbiAgaGFzKG5vZGU6IE5vZGUsIHByb3A6IHN0cmluZyB8IHN5bWJvbCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIFJlZmxlY3QuaGFzKG5vZGUudmFsdWUsIHByb3ApXHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBBcnJheVRyZWVOb2RlPFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPj4gaW1wbGVtZW50cyBOb2RlPFQ+IHtcclxuICBwcm94eTogVCA9IG5ldyBQcm94eShbdGhpc10sIGFycmF5UHJveHlIYW5kbGVyKSBhcyB1bmtub3duIGFzIFRcclxuICB0YWcgPSBjcmVhdGVUYWcoKVxyXG4gIHRhZ3MgPSB7fVxyXG4gIGNoaWxkcmVuID0ge31cclxuICBjb2xsZWN0aW9uVGFnID0gbnVsbFxyXG4gIGlkID0gbmV4dElkKytcclxuXHJcbiAgY29uc3RydWN0b3IocHVibGljIHZhbHVlOiBUKSB7XHJcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcclxuICAgIHRoaXMudGFnLnZhbHVlID0gdmFsdWVcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGFycmF5UHJveHlIYW5kbGVyID0ge1xyXG4gIGdldChbbm9kZV06IFtOb2RlXSwga2V5OiBzdHJpbmcgfCBzeW1ib2wpOiB1bmtub3duIHtcclxuICAgIGlmIChrZXkgPT09ICdsZW5ndGgnKSB7XHJcbiAgICAgIGNvbnN1bWVDb2xsZWN0aW9uKG5vZGUpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9iamVjdFByb3h5SGFuZGxlci5nZXQobm9kZSwga2V5KVxyXG4gIH0sXHJcblxyXG4gIG93bktleXMoW25vZGVdOiBbTm9kZV0pOiBBcnJheUxpa2U8c3RyaW5nIHwgc3ltYm9sPiB7XHJcbiAgICByZXR1cm4gb2JqZWN0UHJveHlIYW5kbGVyLm93bktleXMobm9kZSlcclxuICB9LFxyXG5cclxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXHJcbiAgICBbbm9kZV06IFtOb2RlXSxcclxuICAgIHByb3A6IHN0cmluZyB8IHN5bWJvbFxyXG4gICk6IFByb3BlcnR5RGVzY3JpcHRvciB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gb2JqZWN0UHJveHlIYW5kbGVyLmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLCBwcm9wKVxyXG4gIH0sXHJcblxyXG4gIGhhcyhbbm9kZV06IFtOb2RlXSwgcHJvcDogc3RyaW5nIHwgc3ltYm9sKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gb2JqZWN0UHJveHlIYW5kbGVyLmhhcyhub2RlLCBwcm9wKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5vZGU8VCBleHRlbmRzIEFycmF5PHVua25vd24+IHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KFxyXG4gIHZhbHVlOiBUXHJcbik6IE5vZGU8VD4ge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIG5ldyBBcnJheVRyZWVOb2RlKHZhbHVlKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ldyBPYmplY3RUcmVlTm9kZSh2YWx1ZSkgYXMgTm9kZTxUPlxyXG59XHJcblxyXG5jb25zdCBrZXlzTWFwID0gbmV3IFdlYWtNYXA8XHJcbiAgQXJyYXk8dW5rbm93bj4gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcclxuICBTZXQ8c3RyaW5nPlxyXG4+KClcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVOb2RlPFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPiB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcclxuICBub2RlOiBOb2RlPFQ+LFxyXG4gIG5ld1ZhbHVlOiBUXHJcbik6IHZvaWQge1xyXG4gIGNvbnN0IHsgdmFsdWUsIHRhZ3MsIGNoaWxkcmVuIH0gPSBub2RlXHJcblxyXG4gIG5vZGUudmFsdWUgPSBuZXdWYWx1ZVxyXG5cclxuICBpZiAoXHJcbiAgICBBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxyXG4gICAgQXJyYXkuaXNBcnJheShuZXdWYWx1ZSkgJiZcclxuICAgIHZhbHVlLmxlbmd0aCAhPT0gbmV3VmFsdWUubGVuZ3RoXHJcbiAgKSB7XHJcbiAgICBkaXJ0eUNvbGxlY3Rpb24obm9kZSlcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKHZhbHVlICE9PSBuZXdWYWx1ZSkge1xyXG4gICAgICBsZXQgb2xkS2V5c1NpemUgPSAwXHJcbiAgICAgIGxldCBuZXdLZXlzU2l6ZSA9IDBcclxuICAgICAgbGV0IGFueUtleXNBZGRlZCA9IGZhbHNlXHJcblxyXG4gICAgICBmb3IgKGNvbnN0IF9rZXkgaW4gdmFsdWUpIHtcclxuICAgICAgICBvbGRLZXlzU2l6ZSsrXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgbmV3S2V5c1NpemUrK1xyXG4gICAgICAgIGlmICghKGtleSBpbiB2YWx1ZSkpIHtcclxuICAgICAgICAgIGFueUtleXNBZGRlZCA9IHRydWVcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBpc0RpZmZlcmVudCA9IGFueUtleXNBZGRlZCB8fCBvbGRLZXlzU2l6ZSAhPT0gbmV3S2V5c1NpemVcclxuXHJcbiAgICAgIGlmIChpc0RpZmZlcmVudCkge1xyXG4gICAgICAgIGRpcnR5Q29sbGVjdGlvbihub2RlKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmb3IgKGNvbnN0IGtleSBpbiB0YWdzKSB7XHJcbiAgICBjb25zdCBjaGlsZFZhbHVlID0gKHZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVtrZXldXHJcbiAgICBjb25zdCBuZXdDaGlsZFZhbHVlID0gKG5ld1ZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVtrZXldXHJcblxyXG4gICAgaWYgKGNoaWxkVmFsdWUgIT09IG5ld0NoaWxkVmFsdWUpIHtcclxuICAgICAgZGlydHlDb2xsZWN0aW9uKG5vZGUpXHJcbiAgICAgIGRpcnR5VGFnKHRhZ3Nba2V5XSwgbmV3Q2hpbGRWYWx1ZSlcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkVmFsdWUgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkVmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgZGVsZXRlIHRhZ3Nba2V5XVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZm9yIChjb25zdCBrZXkgaW4gY2hpbGRyZW4pIHtcclxuICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNoaWxkcmVuW2tleV1cclxuICAgIGNvbnN0IG5ld0NoaWxkVmFsdWUgPSAobmV3VmFsdWUgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pW2tleV1cclxuXHJcbiAgICBjb25zdCBjaGlsZFZhbHVlID0gY2hpbGROb2RlLnZhbHVlXHJcblxyXG4gICAgaWYgKGNoaWxkVmFsdWUgPT09IG5ld0NoaWxkVmFsdWUpIHtcclxuICAgICAgY29udGludWVcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5ld0NoaWxkVmFsdWUgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkVmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgdXBkYXRlTm9kZShjaGlsZE5vZGUsIG5ld0NoaWxkVmFsdWUgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkZWxldGVOb2RlKGNoaWxkTm9kZSlcclxuICAgICAgZGVsZXRlIGNoaWxkcmVuW2tleV1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlbGV0ZU5vZGUobm9kZTogTm9kZSk6IHZvaWQge1xyXG4gIGlmIChub2RlLnRhZykge1xyXG4gICAgZGlydHlUYWcobm9kZS50YWcsIG51bGwpXHJcbiAgfVxyXG4gIGRpcnR5Q29sbGVjdGlvbihub2RlKVxyXG4gIGZvciAoY29uc3Qga2V5IGluIG5vZGUudGFncykge1xyXG4gICAgZGlydHlUYWcobm9kZS50YWdzW2tleV0sIG51bGwpXHJcbiAgfVxyXG4gIGZvciAoY29uc3Qga2V5IGluIG5vZGUuY2hpbGRyZW4pIHtcclxuICAgIGRlbGV0ZU5vZGUobm9kZS5jaGlsZHJlbltrZXldKVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgdHlwZSB7XHJcbiAgQW55RnVuY3Rpb24sXHJcbiAgRGVmYXVsdE1lbW9pemVGaWVsZHMsXHJcbiAgRXF1YWxpdHlGbixcclxuICBTaW1wbGlmeVxyXG59IGZyb20gJy4vdHlwZXMnXHJcblxyXG5pbXBvcnQgdHlwZSB7IE5PVF9GT1VORF9UWVBFIH0gZnJvbSAnLi91dGlscydcclxuaW1wb3J0IHsgTk9UX0ZPVU5EIH0gZnJvbSAnLi91dGlscydcclxuXHJcbi8vIENhY2hlIGltcGxlbWVudGF0aW9uIGJhc2VkIG9uIEVyaWsgUmFzbXVzc2VuJ3MgYGxydS1tZW1vaXplYDpcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2VyaWtyYXMvbHJ1LW1lbW9pemVcclxuXHJcbmludGVyZmFjZSBFbnRyeSB7XHJcbiAga2V5OiB1bmtub3duXHJcbiAgdmFsdWU6IHVua25vd25cclxufVxyXG5cclxuaW50ZXJmYWNlIENhY2hlIHtcclxuICBnZXQoa2V5OiB1bmtub3duKTogdW5rbm93biB8IE5PVF9GT1VORF9UWVBFXHJcbiAgcHV0KGtleTogdW5rbm93biwgdmFsdWU6IHVua25vd24pOiB2b2lkXHJcbiAgZ2V0RW50cmllcygpOiBFbnRyeVtdXHJcbiAgY2xlYXIoKTogdm9pZFxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTaW5nbGV0b25DYWNoZShlcXVhbHM6IEVxdWFsaXR5Rm4pOiBDYWNoZSB7XHJcbiAgbGV0IGVudHJ5OiBFbnRyeSB8IHVuZGVmaW5lZFxyXG4gIHJldHVybiB7XHJcbiAgICBnZXQoa2V5OiB1bmtub3duKSB7XHJcbiAgICAgIGlmIChlbnRyeSAmJiBlcXVhbHMoZW50cnkua2V5LCBrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBOT1RfRk9VTkRcclxuICAgIH0sXHJcblxyXG4gICAgcHV0KGtleTogdW5rbm93biwgdmFsdWU6IHVua25vd24pIHtcclxuICAgICAgZW50cnkgPSB7IGtleSwgdmFsdWUgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRFbnRyaWVzKCkge1xyXG4gICAgICByZXR1cm4gZW50cnkgPyBbZW50cnldIDogW11cclxuICAgIH0sXHJcblxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgIGVudHJ5ID0gdW5kZWZpbmVkXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMcnVDYWNoZShtYXhTaXplOiBudW1iZXIsIGVxdWFsczogRXF1YWxpdHlGbik6IENhY2hlIHtcclxuICBsZXQgZW50cmllczogRW50cnlbXSA9IFtdXHJcblxyXG4gIGZ1bmN0aW9uIGdldChrZXk6IHVua25vd24pIHtcclxuICAgIGNvbnN0IGNhY2hlSW5kZXggPSBlbnRyaWVzLmZpbmRJbmRleChlbnRyeSA9PiBlcXVhbHMoa2V5LCBlbnRyeS5rZXkpKVxyXG5cclxuICAgIC8vIFdlIGZvdW5kIGEgY2FjaGVkIGVudHJ5XHJcbiAgICBpZiAoY2FjaGVJbmRleCA+IC0xKSB7XHJcbiAgICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1tjYWNoZUluZGV4XVxyXG5cclxuICAgICAgLy8gQ2FjaGVkIGVudHJ5IG5vdCBhdCB0b3Agb2YgY2FjaGUsIG1vdmUgaXQgdG8gdGhlIHRvcFxyXG4gICAgICBpZiAoY2FjaGVJbmRleCA+IDApIHtcclxuICAgICAgICBlbnRyaWVzLnNwbGljZShjYWNoZUluZGV4LCAxKVxyXG4gICAgICAgIGVudHJpZXMudW5zaGlmdChlbnRyeSlcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlXHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm8gZW50cnkgZm91bmQgaW4gY2FjaGUsIHJldHVybiBzZW50aW5lbFxyXG4gICAgcmV0dXJuIE5PVF9GT1VORFxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHV0KGtleTogdW5rbm93biwgdmFsdWU6IHVua25vd24pIHtcclxuICAgIGlmIChnZXQoa2V5KSA9PT0gTk9UX0ZPVU5EKSB7XHJcbiAgICAgIC8vIFRPRE8gSXMgdW5zaGlmdCBzbG93P1xyXG4gICAgICBlbnRyaWVzLnVuc2hpZnQoeyBrZXksIHZhbHVlIH0pXHJcbiAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IG1heFNpemUpIHtcclxuICAgICAgICBlbnRyaWVzLnBvcCgpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldEVudHJpZXMoKSB7XHJcbiAgICByZXR1cm4gZW50cmllc1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2xlYXIoKSB7XHJcbiAgICBlbnRyaWVzID0gW11cclxuICB9XHJcblxyXG4gIHJldHVybiB7IGdldCwgcHV0LCBnZXRFbnRyaWVzLCBjbGVhciB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSdW5zIGEgc2ltcGxlIHJlZmVyZW5jZSBlcXVhbGl0eSBjaGVjay5cclxuICogV2hhdCB7QGxpbmtjb2RlIGxydU1lbW9pemUgbHJ1TWVtb2l6ZX0gdXNlcyBieSBkZWZhdWx0LlxyXG4gKlxyXG4gKiAqKk5vdGUqKjogVGhpcyBmdW5jdGlvbiB3YXMgcHJldmlvdXNseSBrbm93biBhcyBgZGVmYXVsdEVxdWFsaXR5Q2hlY2tgLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmVmZXJlbmNlRXF1YWxpdHlDaGVjazogRXF1YWxpdHlGbiA9IChhLCBiKSA9PiBhID09PSBiXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKGVxdWFsaXR5Q2hlY2s6IEVxdWFsaXR5Rm4pIHtcclxuICByZXR1cm4gZnVuY3Rpb24gYXJlQXJndW1lbnRzU2hhbGxvd2x5RXF1YWwoXHJcbiAgICBwcmV2OiB1bmtub3duW10gfCBJQXJndW1lbnRzIHwgbnVsbCxcclxuICAgIG5leHQ6IHVua25vd25bXSB8IElBcmd1bWVudHMgfCBudWxsXHJcbiAgKTogYm9vbGVhbiB7XHJcbiAgICBpZiAocHJldiA9PT0gbnVsbCB8fCBuZXh0ID09PSBudWxsIHx8IHByZXYubGVuZ3RoICE9PSBuZXh0Lmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyB0aGlzIGluIGEgZm9yIGxvb3AgKGFuZCBub3QgYSBgZm9yRWFjaGAgb3IgYW4gYGV2ZXJ5YCkgc28gd2UgY2FuIGRldGVybWluZSBlcXVhbGl0eSBhcyBmYXN0IGFzIHBvc3NpYmxlLlxyXG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHByZXZcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKCFlcXVhbGl0eUNoZWNrKHByZXZbaV0sIG5leHRbaV0pKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE9wdGlvbnMgZm9yIGNvbmZpZ3VyaW5nIHRoZSBiZWhhdmlvciBvZiBhIGZ1bmN0aW9uIG1lbW9pemVkIHdpdGhcclxuICogTFJVIChMZWFzdCBSZWNlbnRseSBVc2VkKSBjYWNoaW5nLlxyXG4gKlxyXG4gKiBAdGVtcGxhdGUgUmVzdWx0IC0gVGhlIHR5cGUgb2YgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgTHJ1TWVtb2l6ZU9wdGlvbnM8UmVzdWx0ID0gYW55PiB7XHJcbiAgLyoqXHJcbiAgICogRnVuY3Rpb24gdXNlZCB0byBjb21wYXJlIHRoZSBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvZiB0aGVcclxuICAgKiBwcm92aWRlZCBjYWxjdWxhdGlvbiBmdW5jdGlvbi5cclxuICAgKlxyXG4gICAqIEBkZWZhdWx0IHJlZmVyZW5jZUVxdWFsaXR5Q2hlY2tcclxuICAgKi9cclxuICBlcXVhbGl0eUNoZWNrPzogRXF1YWxpdHlGblxyXG5cclxuICAvKipcclxuICAgKiBJZiBwcm92aWRlZCwgdXNlZCB0byBjb21wYXJlIGEgbmV3bHkgZ2VuZXJhdGVkIG91dHB1dCB2YWx1ZSBhZ2FpbnN0XHJcbiAgICogcHJldmlvdXMgdmFsdWVzIGluIHRoZSBjYWNoZS4gSWYgYSBtYXRjaCBpcyBmb3VuZCxcclxuICAgKiB0aGUgb2xkIHZhbHVlIGlzIHJldHVybmVkLiBUaGlzIGFkZHJlc3NlcyB0aGUgY29tbW9uXHJcbiAgICogYGBgdHNcclxuICAgKiB0b2Rvcy5tYXAodG9kbyA9PiB0b2RvLmlkKVxyXG4gICAqIGBgYFxyXG4gICAqIHVzZSBjYXNlLCB3aGVyZSBhbiB1cGRhdGUgdG8gYW5vdGhlciBmaWVsZCBpbiB0aGUgb3JpZ2luYWwgZGF0YSBjYXVzZXNcclxuICAgKiBhIHJlY2FsY3VsYXRpb24gZHVlIHRvIGNoYW5nZWQgcmVmZXJlbmNlcywgYnV0IHRoZSBvdXRwdXQgaXMgc3RpbGxcclxuICAgKiBlZmZlY3RpdmVseSB0aGUgc2FtZS5cclxuICAgKlxyXG4gICAqIEBzaW5jZSA0LjEuMFxyXG4gICAqL1xyXG4gIHJlc3VsdEVxdWFsaXR5Q2hlY2s/OiBFcXVhbGl0eUZuPFJlc3VsdD5cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIG1heGltdW0gc2l6ZSBvZiB0aGUgY2FjaGUgdXNlZCBieSB0aGUgc2VsZWN0b3IuXHJcbiAgICogQSBzaXplIGdyZWF0ZXIgdGhhbiAxIG1lYW5zIHRoZSBzZWxlY3RvciB3aWxsIHVzZSBhblxyXG4gICAqIExSVSAoTGVhc3QgUmVjZW50bHkgVXNlZCkgY2FjaGUsIGFsbG93aW5nIGZvciB0aGUgY2FjaGluZyBvZiBtdWx0aXBsZVxyXG4gICAqIHJlc3VsdHMgYmFzZWQgb24gZGlmZmVyZW50IHNldHMgb2YgYXJndW1lbnRzLlxyXG4gICAqXHJcbiAgICogQGRlZmF1bHQgMVxyXG4gICAqL1xyXG4gIG1heFNpemU/OiBudW1iZXJcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtZW1vaXplZCB2ZXJzaW9uIG9mIGEgZnVuY3Rpb24gd2l0aCBhbiBvcHRpb25hbFxyXG4gKiBMUlUgKExlYXN0IFJlY2VudGx5IFVzZWQpIGNhY2hlLiBUaGUgbWVtb2l6ZWQgZnVuY3Rpb24gdXNlcyBhIGNhY2hlIHRvXHJcbiAqIHN0b3JlIGNvbXB1dGVkIHZhbHVlcy4gRGVwZW5kaW5nIG9uIHRoZSBgbWF4U2l6ZWAgb3B0aW9uLCBpdCB3aWxsIHVzZVxyXG4gKiBlaXRoZXIgYSBzaW5nbGV0b24gY2FjaGUgKGZvciBhIHNpbmdsZSBlbnRyeSkgb3IgYW5cclxuICogTFJVIGNhY2hlIChmb3IgbXVsdGlwbGUgZW50cmllcykuXHJcbiAqXHJcbiAqICoqTm90ZSoqOiBUaGlzIGZ1bmN0aW9uIHdhcyBwcmV2aW91c2x5IGtub3duIGFzIGBkZWZhdWx0TWVtb2l6ZWAuXHJcbiAqXHJcbiAqIEBwYXJhbSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGJlIG1lbW9pemVkLlxyXG4gKiBAcGFyYW0gZXF1YWxpdHlDaGVja09yT3B0aW9ucyAtIEVpdGhlciBhbiBlcXVhbGl0eSBjaGVjayBmdW5jdGlvbiBvciBhbiBvcHRpb25zIG9iamVjdC5cclxuICogQHJldHVybnMgQSBtZW1vaXplZCBmdW5jdGlvbiB3aXRoIGEgYC5jbGVhckNhY2hlKClgIG1ldGhvZCBhdHRhY2hlZC5cclxuICpcclxuICogQHRlbXBsYXRlIEZ1bmMgLSBUaGUgdHlwZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBpcyBtZW1vaXplZC5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZXNlbGVjdC5qcy5vcmcvYXBpL2xydU1lbW9pemUgYGxydU1lbW9pemVgfVxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbHJ1TWVtb2l6ZTxGdW5jIGV4dGVuZHMgQW55RnVuY3Rpb24+KFxyXG4gIGZ1bmM6IEZ1bmMsXHJcbiAgZXF1YWxpdHlDaGVja09yT3B0aW9ucz86IEVxdWFsaXR5Rm4gfCBMcnVNZW1vaXplT3B0aW9uczxSZXR1cm5UeXBlPEZ1bmM+PlxyXG4pIHtcclxuICBjb25zdCBwcm92aWRlZE9wdGlvbnMgPVxyXG4gICAgdHlwZW9mIGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgPT09ICdvYmplY3QnXHJcbiAgICAgID8gZXF1YWxpdHlDaGVja09yT3B0aW9uc1xyXG4gICAgICA6IHsgZXF1YWxpdHlDaGVjazogZXF1YWxpdHlDaGVja09yT3B0aW9ucyB9XHJcblxyXG4gIGNvbnN0IHtcclxuICAgIGVxdWFsaXR5Q2hlY2sgPSByZWZlcmVuY2VFcXVhbGl0eUNoZWNrLFxyXG4gICAgbWF4U2l6ZSA9IDEsXHJcbiAgICByZXN1bHRFcXVhbGl0eUNoZWNrXHJcbiAgfSA9IHByb3ZpZGVkT3B0aW9uc1xyXG5cclxuICBjb25zdCBjb21wYXJhdG9yID0gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKGVxdWFsaXR5Q2hlY2spXHJcblxyXG4gIGxldCByZXN1bHRzQ291bnQgPSAwXHJcblxyXG4gIGNvbnN0IGNhY2hlID1cclxuICAgIG1heFNpemUgPD0gMVxyXG4gICAgICA/IGNyZWF0ZVNpbmdsZXRvbkNhY2hlKGNvbXBhcmF0b3IpXHJcbiAgICAgIDogY3JlYXRlTHJ1Q2FjaGUobWF4U2l6ZSwgY29tcGFyYXRvcilcclxuXHJcbiAgZnVuY3Rpb24gbWVtb2l6ZWQoKSB7XHJcbiAgICBsZXQgdmFsdWUgPSBjYWNoZS5nZXQoYXJndW1lbnRzKSBhcyBSZXR1cm5UeXBlPEZ1bmM+XHJcbiAgICBpZiAodmFsdWUgPT09IE5PVF9GT1VORCkge1xyXG4gICAgICAvLyBhcHBseSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgZm9yIHBlcmZvcm1hbmNlLlxyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgIHZhbHVlID0gZnVuYy5hcHBseShudWxsLCBhcmd1bWVudHMpIGFzIFJldHVyblR5cGU8RnVuYz5cclxuICAgICAgcmVzdWx0c0NvdW50KytcclxuXHJcbiAgICAgIGlmIChyZXN1bHRFcXVhbGl0eUNoZWNrKSB7XHJcbiAgICAgICAgY29uc3QgZW50cmllcyA9IGNhY2hlLmdldEVudHJpZXMoKVxyXG4gICAgICAgIGNvbnN0IG1hdGNoaW5nRW50cnkgPSBlbnRyaWVzLmZpbmQoZW50cnkgPT5cclxuICAgICAgICAgIHJlc3VsdEVxdWFsaXR5Q2hlY2soZW50cnkudmFsdWUgYXMgUmV0dXJuVHlwZTxGdW5jPiwgdmFsdWUpXHJcbiAgICAgICAgKVxyXG5cclxuICAgICAgICBpZiAobWF0Y2hpbmdFbnRyeSkge1xyXG4gICAgICAgICAgdmFsdWUgPSBtYXRjaGluZ0VudHJ5LnZhbHVlIGFzIFJldHVyblR5cGU8RnVuYz5cclxuICAgICAgICAgIHJlc3VsdHNDb3VudCAhPT0gMCAmJiByZXN1bHRzQ291bnQtLVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgY2FjaGUucHV0KGFyZ3VtZW50cywgdmFsdWUpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWVcclxuICB9XHJcblxyXG4gIG1lbW9pemVkLmNsZWFyQ2FjaGUgPSAoKSA9PiB7XHJcbiAgICBjYWNoZS5jbGVhcigpXHJcbiAgICBtZW1vaXplZC5yZXNldFJlc3VsdHNDb3VudCgpXHJcbiAgfVxyXG5cclxuICBtZW1vaXplZC5yZXN1bHRzQ291bnQgPSAoKSA9PiByZXN1bHRzQ291bnRcclxuXHJcbiAgbWVtb2l6ZWQucmVzZXRSZXN1bHRzQ291bnQgPSAoKSA9PiB7XHJcbiAgICByZXN1bHRzQ291bnQgPSAwXHJcbiAgfVxyXG5cclxuICByZXR1cm4gbWVtb2l6ZWQgYXMgRnVuYyAmIFNpbXBsaWZ5PERlZmF1bHRNZW1vaXplRmllbGRzPlxyXG59XHJcbiIsImltcG9ydCB7IGNyZWF0ZU5vZGUsIHVwZGF0ZU5vZGUgfSBmcm9tICcuL3Byb3h5J1xyXG5pbXBvcnQgdHlwZSB7IE5vZGUgfSBmcm9tICcuL3RyYWNraW5nJ1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yLCByZWZlcmVuY2VFcXVhbGl0eUNoZWNrIH0gZnJvbSAnLi4vbHJ1TWVtb2l6ZSdcclxuaW1wb3J0IHR5cGUgeyBBbnlGdW5jdGlvbiwgRGVmYXVsdE1lbW9pemVGaWVsZHMsIFNpbXBsaWZ5IH0gZnJvbSAnLi4vdHlwZXMnXHJcbmltcG9ydCB7IGNyZWF0ZUNhY2hlIH0gZnJvbSAnLi9hdXRvdHJhY2tpbmcnXHJcblxyXG4vKipcclxuICogVXNlcyBhbiBcImF1dG8tdHJhY2tpbmdcIiBhcHByb2FjaCBpbnNwaXJlZCBieSB0aGUgd29yayBvZiB0aGUgRW1iZXIgR2xpbW1lciB0ZWFtLlxyXG4gKiBJdCB1c2VzIGEgUHJveHkgdG8gd3JhcCBhcmd1bWVudHMgYW5kIHRyYWNrIGFjY2Vzc2VzIHRvIG5lc3RlZCBmaWVsZHNcclxuICogaW4geW91ciBzZWxlY3RvciBvbiBmaXJzdCByZWFkLiBMYXRlciwgd2hlbiB0aGUgc2VsZWN0b3IgaXMgY2FsbGVkIHdpdGhcclxuICogbmV3IGFyZ3VtZW50cywgaXQgaWRlbnRpZmllcyB3aGljaCBhY2Nlc3NlZCBmaWVsZHMgaGF2ZSBjaGFuZ2VkIGFuZFxyXG4gKiBvbmx5IHJlY2FsY3VsYXRlcyB0aGUgcmVzdWx0IGlmIG9uZSBvciBtb3JlIG9mIHRob3NlIGFjY2Vzc2VkIGZpZWxkcyBoYXZlIGNoYW5nZWQuXHJcbiAqIFRoaXMgYWxsb3dzIGl0IHRvIGJlIG1vcmUgcHJlY2lzZSB0aGFuIHRoZSBzaGFsbG93IGVxdWFsaXR5IGNoZWNrcyBpbiBgbHJ1TWVtb2l6ZWAuXHJcbiAqXHJcbiAqIF9fRGVzaWduIFRyYWRlb2ZmcyBmb3IgYGF1dG90cmFja01lbW9pemVgOl9fXHJcbiAqIC0gUHJvczpcclxuICogICAgLSBJdCBpcyBsaWtlbHkgdG8gYXZvaWQgZXhjZXNzIGNhbGN1bGF0aW9ucyBhbmQgcmVjYWxjdWxhdGUgZmV3ZXIgdGltZXMgdGhhbiBgbHJ1TWVtb2l6ZWAgd2lsbCxcclxuICogICAgd2hpY2ggbWF5IGFsc28gcmVzdWx0IGluIGZld2VyIGNvbXBvbmVudCByZS1yZW5kZXJzLlxyXG4gKiAtIENvbnM6XHJcbiAqICAgIC0gSXQgb25seSBoYXMgYSBjYWNoZSBzaXplIG9mIDEuXHJcbiAqICAgIC0gSXQgaXMgc2xvd2VyIHRoYW4gYGxydU1lbW9pemVgLCBiZWNhdXNlIGl0IGhhcyB0byBkbyBtb3JlIHdvcmsuIChIb3cgbXVjaCBzbG93ZXIgaXMgZGVwZW5kZW50IG9uIHRoZSBudW1iZXIgb2YgYWNjZXNzZWQgZmllbGRzIGluIGEgc2VsZWN0b3IsIG51bWJlciBvZiBjYWxscywgZnJlcXVlbmN5IG9mIGlucHV0IGNoYW5nZXMsIGV0YylcclxuICogICAgLSBJdCBjYW4gaGF2ZSBzb21lIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIEJlY2F1c2UgaXQgdHJhY2tzIG5lc3RlZCBmaWVsZCBhY2Nlc3NlcyxcclxuICogICAgY2FzZXMgd2hlcmUgeW91IGRvbid0IGFjY2VzcyBhIGZpZWxkIHdpbGwgbm90IHJlY2FsY3VsYXRlIHByb3Blcmx5LlxyXG4gKiAgICBGb3IgZXhhbXBsZSwgYSBiYWRseS13cml0dGVuIHNlbGVjdG9yIGxpa2U6XHJcbiAqICAgICAgYGBgdHNcclxuICogICAgICBjcmVhdGVTZWxlY3Rvcihbc3RhdGUgPT4gc3RhdGUudG9kb3NdLCB0b2RvcyA9PiB0b2RvcylcclxuICogICAgICBgYGBcclxuICogICAgICB0aGF0IGp1c3QgaW1tZWRpYXRlbHkgcmV0dXJucyB0aGUgZXh0cmFjdGVkIHZhbHVlIHdpbGwgbmV2ZXIgdXBkYXRlLCBiZWNhdXNlIGl0IGRvZXNuJ3Qgc2VlIGFueSBmaWVsZCBhY2Nlc3NlcyB0byBjaGVjay5cclxuICpcclxuICogX19Vc2UgQ2FzZXMgZm9yIGBhdXRvdHJhY2tNZW1vaXplYDpfX1xyXG4gKiAtIEl0IGlzIGxpa2VseSBiZXN0IHVzZWQgZm9yIGNhc2VzIHdoZXJlIHlvdSBuZWVkIHRvIGFjY2VzcyBzcGVjaWZpYyBuZXN0ZWQgZmllbGRzXHJcbiAqIGluIGRhdGEsIGFuZCBhdm9pZCByZWNhbGN1bGF0aW5nIGlmIG90aGVyIGZpZWxkcyBpbiB0aGUgc2FtZSBkYXRhIG9iamVjdHMgYXJlIGltbXV0YWJseSB1cGRhdGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gZnVuYyAtIFRoZSBmdW5jdGlvbiB0byBiZSBtZW1vaXplZC5cclxuICogQHJldHVybnMgQSBtZW1vaXplZCBmdW5jdGlvbiB3aXRoIGEgYC5jbGVhckNhY2hlKClgIG1ldGhvZCBhdHRhY2hlZC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogPGNhcHRpb24+VXNpbmcgYGNyZWF0ZVNlbGVjdG9yYDwvY2FwdGlvbj5cclxuICogYGBgdHNcclxuICogaW1wb3J0IHsgdW5zdGFibGVfYXV0b3RyYWNrTWVtb2l6ZSBhcyBhdXRvdHJhY2tNZW1vaXplLCBjcmVhdGVTZWxlY3RvciB9IGZyb20gJ3Jlc2VsZWN0J1xyXG4gKlxyXG4gKiBjb25zdCBzZWxlY3RUb2RvSWRzID0gY3JlYXRlU2VsZWN0b3IoXHJcbiAqICAgWyhzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZS50b2Rvc10sXHJcbiAqICAgKHRvZG9zKSA9PiB0b2Rvcy5tYXAodG9kbyA9PiB0b2RvLmlkKSxcclxuICogICB7IG1lbW9pemU6IGF1dG90cmFja01lbW9pemUgfVxyXG4gKiApXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiA8Y2FwdGlvbj5Vc2luZyBgY3JlYXRlU2VsZWN0b3JDcmVhdG9yYDwvY2FwdGlvbj5cclxuICogYGBgdHNcclxuICogaW1wb3J0IHsgdW5zdGFibGVfYXV0b3RyYWNrTWVtb2l6ZSBhcyBhdXRvdHJhY2tNZW1vaXplLCBjcmVhdGVTZWxlY3RvckNyZWF0b3IgfSBmcm9tICdyZXNlbGVjdCdcclxuICpcclxuICogY29uc3QgY3JlYXRlU2VsZWN0b3JBdXRvdHJhY2sgPSBjcmVhdGVTZWxlY3RvckNyZWF0b3IoeyBtZW1vaXplOiBhdXRvdHJhY2tNZW1vaXplIH0pXHJcbiAqXHJcbiAqIGNvbnN0IHNlbGVjdFRvZG9JZHMgPSBjcmVhdGVTZWxlY3RvckF1dG90cmFjayhcclxuICogICBbKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLnRvZG9zXSxcclxuICogICAodG9kb3MpID0+IHRvZG9zLm1hcCh0b2RvID0+IHRvZG8uaWQpXHJcbiAqIClcclxuICogYGBgXHJcbiAqXHJcbiAqIEB0ZW1wbGF0ZSBGdW5jIC0gVGhlIHR5cGUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgbWVtb2l6ZWQuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVzZWxlY3QuanMub3JnL2FwaS91bnN0YWJsZV9hdXRvdHJhY2tNZW1vaXplIGF1dG90cmFja01lbW9pemV9XHJcbiAqXHJcbiAqIEBzaW5jZSA1LjAuMFxyXG4gKiBAcHVibGljXHJcbiAqIEBleHBlcmltZW50YWxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhdXRvdHJhY2tNZW1vaXplPEZ1bmMgZXh0ZW5kcyBBbnlGdW5jdGlvbj4oZnVuYzogRnVuYykge1xyXG4gIC8vIHdlIHJlZmVyZW5jZSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgdGhlbSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xyXG5cclxuICBjb25zdCBub2RlOiBOb2RlPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiA9IGNyZWF0ZU5vZGUoXHJcbiAgICBbXSBhcyB1bmtub3duIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+XHJcbiAgKVxyXG5cclxuICBsZXQgbGFzdEFyZ3M6IElBcmd1bWVudHMgfCBudWxsID0gbnVsbFxyXG5cclxuICBjb25zdCBzaGFsbG93RXF1YWwgPSBjcmVhdGVDYWNoZUtleUNvbXBhcmF0b3IocmVmZXJlbmNlRXF1YWxpdHlDaGVjaylcclxuXHJcbiAgY29uc3QgY2FjaGUgPSBjcmVhdGVDYWNoZSgoKSA9PiB7XHJcbiAgICBjb25zdCByZXMgPSBmdW5jLmFwcGx5KG51bGwsIG5vZGUucHJveHkgYXMgdW5rbm93biBhcyBhbnlbXSlcclxuICAgIHJldHVybiByZXNcclxuICB9KVxyXG5cclxuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcclxuICAgIGlmICghc2hhbGxvd0VxdWFsKGxhc3RBcmdzLCBhcmd1bWVudHMpKSB7XHJcbiAgICAgIHVwZGF0ZU5vZGUobm9kZSwgYXJndW1lbnRzIGFzIHVua25vd24gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pXHJcbiAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzXHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FjaGUudmFsdWVcclxuICB9XHJcblxyXG4gIG1lbW9pemVkLmNsZWFyQ2FjaGUgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gY2FjaGUuY2xlYXIoKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1lbW9pemVkIGFzIEZ1bmMgJiBTaW1wbGlmeTxEZWZhdWx0TWVtb2l6ZUZpZWxkcz5cclxufVxyXG4iLCIvLyBPcmlnaW5hbCBzb3VyY2U6XHJcbi8vIC0gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvMGI5NzQ0MThjOWE1NmY2YzU2MDI5ODU2MDI2NWRjZjRiNjU3ODRiYy9wYWNrYWdlcy9yZWFjdC9zcmMvUmVhY3RDYWNoZS5qc1xyXG5cclxuaW1wb3J0IHR5cGUge1xyXG4gIEFueUZ1bmN0aW9uLFxyXG4gIERlZmF1bHRNZW1vaXplRmllbGRzLFxyXG4gIEVxdWFsaXR5Rm4sXHJcbiAgU2ltcGxpZnlcclxufSBmcm9tICcuL3R5cGVzJ1xyXG5cclxuY2xhc3MgU3Ryb25nUmVmPFQ+IHtcclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHZhbHVlOiBUKSB7fVxyXG4gIGRlcmVmKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudmFsdWVcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IFJlZiA9XHJcbiAgdHlwZW9mIFdlYWtSZWYgIT09ICd1bmRlZmluZWQnXHJcbiAgICA/IFdlYWtSZWZcclxuICAgIDogKFN0cm9uZ1JlZiBhcyB1bmtub3duIGFzIHR5cGVvZiBXZWFrUmVmKVxyXG5cclxuY29uc3QgVU5URVJNSU5BVEVEID0gMFxyXG5jb25zdCBURVJNSU5BVEVEID0gMVxyXG5cclxuaW50ZXJmYWNlIFVudGVybWluYXRlZENhY2hlTm9kZTxUPiB7XHJcbiAgLyoqXHJcbiAgICogU3RhdHVzLCByZXByZXNlbnRzIHdoZXRoZXIgdGhlIGNhY2hlZCBjb21wdXRhdGlvbiByZXR1cm5lZCBhIHZhbHVlIG9yIHRocmV3IGFuIGVycm9yLlxyXG4gICAqL1xyXG4gIHM6IDBcclxuICAvKipcclxuICAgKiBWYWx1ZSwgZWl0aGVyIHRoZSBjYWNoZWQgcmVzdWx0IG9yIGFuIGVycm9yLCBkZXBlbmRpbmcgb24gc3RhdHVzLlxyXG4gICAqL1xyXG4gIHY6IHZvaWRcclxuICAvKipcclxuICAgKiBPYmplY3QgY2FjaGUsIGEgYFdlYWtNYXBgIHdoZXJlIG5vbi1wcmltaXRpdmUgYXJndW1lbnRzIGFyZSBzdG9yZWQuXHJcbiAgICovXHJcbiAgbzogbnVsbCB8IFdlYWtNYXA8RnVuY3Rpb24gfCBPYmplY3QsIENhY2hlTm9kZTxUPj5cclxuICAvKipcclxuICAgKiBQcmltaXRpdmUgY2FjaGUsIGEgcmVndWxhciBNYXAgd2hlcmUgcHJpbWl0aXZlIGFyZ3VtZW50cyBhcmUgc3RvcmVkLlxyXG4gICAqL1xyXG4gIHA6IG51bGwgfCBNYXA8c3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHZvaWQgfCBzeW1ib2wgfCBib29sZWFuLCBDYWNoZU5vZGU8VD4+XHJcbn1cclxuXHJcbmludGVyZmFjZSBUZXJtaW5hdGVkQ2FjaGVOb2RlPFQ+IHtcclxuICAvKipcclxuICAgKiBTdGF0dXMsIHJlcHJlc2VudHMgd2hldGhlciB0aGUgY2FjaGVkIGNvbXB1dGF0aW9uIHJldHVybmVkIGEgdmFsdWUgb3IgdGhyZXcgYW4gZXJyb3IuXHJcbiAgICovXHJcbiAgczogMVxyXG4gIC8qKlxyXG4gICAqIFZhbHVlLCBlaXRoZXIgdGhlIGNhY2hlZCByZXN1bHQgb3IgYW4gZXJyb3IsIGRlcGVuZGluZyBvbiBzdGF0dXMuXHJcbiAgICovXHJcbiAgdjogVFxyXG4gIC8qKlxyXG4gICAqIE9iamVjdCBjYWNoZSwgYSBgV2Vha01hcGAgd2hlcmUgbm9uLXByaW1pdGl2ZSBhcmd1bWVudHMgYXJlIHN0b3JlZC5cclxuICAgKi9cclxuICBvOiBudWxsIHwgV2Vha01hcDxGdW5jdGlvbiB8IE9iamVjdCwgQ2FjaGVOb2RlPFQ+PlxyXG4gIC8qKlxyXG4gICAqIFByaW1pdGl2ZSBjYWNoZSwgYSByZWd1bGFyIGBNYXBgIHdoZXJlIHByaW1pdGl2ZSBhcmd1bWVudHMgYXJlIHN0b3JlZC5cclxuICAgKi9cclxuICBwOiBudWxsIHwgTWFwPHN0cmluZyB8IG51bWJlciB8IG51bGwgfCB2b2lkIHwgc3ltYm9sIHwgYm9vbGVhbiwgQ2FjaGVOb2RlPFQ+PlxyXG59XHJcblxyXG50eXBlIENhY2hlTm9kZTxUPiA9IFRlcm1pbmF0ZWRDYWNoZU5vZGU8VD4gfCBVbnRlcm1pbmF0ZWRDYWNoZU5vZGU8VD5cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlTm9kZTxUPigpOiBDYWNoZU5vZGU8VD4ge1xyXG4gIHJldHVybiB7XHJcbiAgICBzOiBVTlRFUk1JTkFURUQsXHJcbiAgICB2OiB1bmRlZmluZWQsXHJcbiAgICBvOiBudWxsLFxyXG4gICAgcDogbnVsbFxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgYSBtZW1vaXphdGlvbiBmdW5jdGlvbiB1dGlsaXppbmcgYFdlYWtNYXBgIGZvclxyXG4gKiBpdHMgY2FjaGluZyBtZWNoYW5pc20uXHJcbiAqXHJcbiAqIEB0ZW1wbGF0ZSBSZXN1bHQgLSBUaGUgdHlwZSBvZiB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cclxuICpcclxuICogQHNpbmNlIDUuMC4wXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2Vha01hcE1lbW9pemVPcHRpb25zPFJlc3VsdCA9IGFueT4ge1xyXG4gIC8qKlxyXG4gICAqIElmIHByb3ZpZGVkLCB1c2VkIHRvIGNvbXBhcmUgYSBuZXdseSBnZW5lcmF0ZWQgb3V0cHV0IHZhbHVlIGFnYWluc3QgcHJldmlvdXMgdmFsdWVzIGluIHRoZSBjYWNoZS5cclxuICAgKiBJZiBhIG1hdGNoIGlzIGZvdW5kLCB0aGUgb2xkIHZhbHVlIGlzIHJldHVybmVkLiBUaGlzIGFkZHJlc3NlcyB0aGUgY29tbW9uXHJcbiAgICogYGBgdHNcclxuICAgKiB0b2Rvcy5tYXAodG9kbyA9PiB0b2RvLmlkKVxyXG4gICAqIGBgYFxyXG4gICAqIHVzZSBjYXNlLCB3aGVyZSBhbiB1cGRhdGUgdG8gYW5vdGhlciBmaWVsZCBpbiB0aGUgb3JpZ2luYWwgZGF0YSBjYXVzZXMgYSByZWNhbGN1bGF0aW9uXHJcbiAgICogZHVlIHRvIGNoYW5nZWQgcmVmZXJlbmNlcywgYnV0IHRoZSBvdXRwdXQgaXMgc3RpbGwgZWZmZWN0aXZlbHkgdGhlIHNhbWUuXHJcbiAgICpcclxuICAgKiBAc2luY2UgNS4wLjBcclxuICAgKi9cclxuICByZXN1bHRFcXVhbGl0eUNoZWNrPzogRXF1YWxpdHlGbjxSZXN1bHQ+XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgdHJlZSBvZiBgV2Vha01hcGAtYmFzZWQgY2FjaGUgbm9kZXMgYmFzZWQgb24gdGhlIGlkZW50aXR5IG9mIHRoZVxyXG4gKiBhcmd1bWVudHMgaXQncyBiZWVuIGNhbGxlZCB3aXRoIChpbiB0aGlzIGNhc2UsIHRoZSBleHRyYWN0ZWQgdmFsdWVzIGZyb20geW91ciBpbnB1dCBzZWxlY3RvcnMpLlxyXG4gKiBUaGlzIGFsbG93cyBgd2Vha01hcE1lbW9pemVgIHRvIGhhdmUgYW4gZWZmZWN0aXZlbHkgaW5maW5pdGUgY2FjaGUgc2l6ZS5cclxuICogQ2FjaGUgcmVzdWx0cyB3aWxsIGJlIGtlcHQgaW4gbWVtb3J5IGFzIGxvbmcgYXMgcmVmZXJlbmNlcyB0byB0aGUgYXJndW1lbnRzIHN0aWxsIGV4aXN0LFxyXG4gKiBhbmQgdGhlbiBjbGVhcmVkIG91dCBhcyB0aGUgYXJndW1lbnRzIGFyZSBnYXJiYWdlLWNvbGxlY3RlZC5cclxuICpcclxuICogX19EZXNpZ24gVHJhZGVvZmZzIGZvciBgd2Vha01hcE1lbW9pemVgOl9fXHJcbiAqIC0gUHJvczpcclxuICogICAtIEl0IGhhcyBhbiBlZmZlY3RpdmVseSBpbmZpbml0ZSBjYWNoZSBzaXplLCBidXQgeW91IGhhdmUgbm8gY29udHJvbCBvdmVyXHJcbiAqICAgaG93IGxvbmcgdmFsdWVzIGFyZSBrZXB0IGluIGNhY2hlIGFzIGl0J3MgYmFzZWQgb24gZ2FyYmFnZSBjb2xsZWN0aW9uIGFuZCBgV2Vha01hcGBzLlxyXG4gKiAtIENvbnM6XHJcbiAqICAgLSBUaGVyZSdzIGN1cnJlbnRseSBubyB3YXkgdG8gYWx0ZXIgdGhlIGFyZ3VtZW50IGNvbXBhcmlzb25zLlxyXG4gKiAgIFRoZXkncmUgYmFzZWQgb24gc3RyaWN0IHJlZmVyZW5jZSBlcXVhbGl0eS5cclxuICogICAtIEl0J3Mgcm91Z2hseSB0aGUgc2FtZSBzcGVlZCBhcyBgbHJ1TWVtb2l6ZWAsIGFsdGhvdWdoIGxpa2VseSBhIGZyYWN0aW9uIHNsb3dlci5cclxuICpcclxuICogX19Vc2UgQ2FzZXMgZm9yIGB3ZWFrTWFwTWVtb2l6ZWA6X19cclxuICogLSBUaGlzIG1lbW9pemVyIGlzIGxpa2VseSBiZXN0IHVzZWQgZm9yIGNhc2VzIHdoZXJlIHlvdSBuZWVkIHRvIGNhbGwgdGhlXHJcbiAqIHNhbWUgc2VsZWN0b3IgaW5zdGFuY2Ugd2l0aCBtYW55IGRpZmZlcmVudCBhcmd1bWVudHMsIHN1Y2ggYXMgYSBzaW5nbGVcclxuICogc2VsZWN0b3IgaW5zdGFuY2UgdGhhdCBpcyB1c2VkIGluIGEgbGlzdCBpdGVtIGNvbXBvbmVudCBhbmQgY2FsbGVkIHdpdGhcclxuICogaXRlbSBJRHMgbGlrZTpcclxuICogICBgYGB0c1xyXG4gKiAgIHVzZVNlbGVjdG9yKHN0YXRlID0+IHNlbGVjdFNvbWVEYXRhKHN0YXRlLCBwcm9wcy5jYXRlZ29yeSkpXHJcbiAqICAgYGBgXHJcbiAqIEBwYXJhbSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGJlIG1lbW9pemVkLlxyXG4gKiBAcmV0dXJucyBBIG1lbW9pemVkIGZ1bmN0aW9uIHdpdGggYSBgLmNsZWFyQ2FjaGUoKWAgbWV0aG9kIGF0dGFjaGVkLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiA8Y2FwdGlvbj5Vc2luZyBgY3JlYXRlU2VsZWN0b3JgPC9jYXB0aW9uPlxyXG4gKiBgYGB0c1xyXG4gKiBpbXBvcnQgeyBjcmVhdGVTZWxlY3Rvciwgd2Vha01hcE1lbW9pemUgfSBmcm9tICdyZXNlbGVjdCdcclxuICpcclxuICogaW50ZXJmYWNlIFJvb3RTdGF0ZSB7XHJcbiAqICAgaXRlbXM6IHsgaWQ6IG51bWJlcjsgY2F0ZWdvcnk6IHN0cmluZzsgbmFtZTogc3RyaW5nIH1bXVxyXG4gKiB9XHJcbiAqXHJcbiAqIGNvbnN0IHNlbGVjdEl0ZW1zQnlDYXRlZ29yeSA9IGNyZWF0ZVNlbGVjdG9yKFxyXG4gKiAgIFtcclxuICogICAgIChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZS5pdGVtcyxcclxuICogICAgIChzdGF0ZTogUm9vdFN0YXRlLCBjYXRlZ29yeTogc3RyaW5nKSA9PiBjYXRlZ29yeVxyXG4gKiAgIF0sXHJcbiAqICAgKGl0ZW1zLCBjYXRlZ29yeSkgPT4gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkpLFxyXG4gKiAgIHtcclxuICogICAgIG1lbW9pemU6IHdlYWtNYXBNZW1vaXplLFxyXG4gKiAgICAgYXJnc01lbW9pemU6IHdlYWtNYXBNZW1vaXplXHJcbiAqICAgfVxyXG4gKiApXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiA8Y2FwdGlvbj5Vc2luZyBgY3JlYXRlU2VsZWN0b3JDcmVhdG9yYDwvY2FwdGlvbj5cclxuICogYGBgdHNcclxuICogaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JDcmVhdG9yLCB3ZWFrTWFwTWVtb2l6ZSB9IGZyb20gJ3Jlc2VsZWN0J1xyXG4gKlxyXG4gKiBjb25zdCBjcmVhdGVTZWxlY3RvcldlYWtNYXAgPSBjcmVhdGVTZWxlY3RvckNyZWF0b3IoeyBtZW1vaXplOiB3ZWFrTWFwTWVtb2l6ZSwgYXJnc01lbW9pemU6IHdlYWtNYXBNZW1vaXplIH0pXHJcbiAqXHJcbiAqIGNvbnN0IHNlbGVjdEl0ZW1zQnlDYXRlZ29yeSA9IGNyZWF0ZVNlbGVjdG9yV2Vha01hcChcclxuICogICBbXHJcbiAqICAgICAoc3RhdGU6IFJvb3RTdGF0ZSkgPT4gc3RhdGUuaXRlbXMsXHJcbiAqICAgICAoc3RhdGU6IFJvb3RTdGF0ZSwgY2F0ZWdvcnk6IHN0cmluZykgPT4gY2F0ZWdvcnlcclxuICogICBdLFxyXG4gKiAgIChpdGVtcywgY2F0ZWdvcnkpID0+IGl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uY2F0ZWdvcnkgPT09IGNhdGVnb3J5KVxyXG4gKiApXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAdGVtcGxhdGUgRnVuYyAtIFRoZSB0eXBlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGlzIG1lbW9pemVkLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3Jlc2VsZWN0LmpzLm9yZy9hcGkvd2Vha01hcE1lbW9pemUgYHdlYWtNYXBNZW1vaXplYH1cclxuICpcclxuICogQHNpbmNlIDUuMC4wXHJcbiAqIEBwdWJsaWNcclxuICogQGV4cGVyaW1lbnRhbFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHdlYWtNYXBNZW1vaXplPEZ1bmMgZXh0ZW5kcyBBbnlGdW5jdGlvbj4oXHJcbiAgZnVuYzogRnVuYyxcclxuICBvcHRpb25zOiBXZWFrTWFwTWVtb2l6ZU9wdGlvbnM8UmV0dXJuVHlwZTxGdW5jPj4gPSB7fVxyXG4pIHtcclxuICBsZXQgZm5Ob2RlID0gY3JlYXRlQ2FjaGVOb2RlKClcclxuICBjb25zdCB7IHJlc3VsdEVxdWFsaXR5Q2hlY2sgfSA9IG9wdGlvbnNcclxuXHJcbiAgbGV0IGxhc3RSZXN1bHQ6IFdlYWtSZWY8b2JqZWN0PiB8IHVuZGVmaW5lZFxyXG5cclxuICBsZXQgcmVzdWx0c0NvdW50ID0gMFxyXG5cclxuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcclxuICAgIGxldCBjYWNoZU5vZGUgPSBmbk5vZGVcclxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBhcmd1bWVudHNcclxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGFyZyA9IGFyZ3VtZW50c1tpXVxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJyB8fFxyXG4gICAgICAgICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGwpXHJcbiAgICAgICkge1xyXG4gICAgICAgIC8vIE9iamVjdHMgZ28gaW50byBhIFdlYWtNYXBcclxuICAgICAgICBsZXQgb2JqZWN0Q2FjaGUgPSBjYWNoZU5vZGUub1xyXG4gICAgICAgIGlmIChvYmplY3RDYWNoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgY2FjaGVOb2RlLm8gPSBvYmplY3RDYWNoZSA9IG5ldyBXZWFrTWFwKClcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0Tm9kZSA9IG9iamVjdENhY2hlLmdldChhcmcpXHJcbiAgICAgICAgaWYgKG9iamVjdE5vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgY2FjaGVOb2RlID0gY3JlYXRlQ2FjaGVOb2RlKClcclxuICAgICAgICAgIG9iamVjdENhY2hlLnNldChhcmcsIGNhY2hlTm9kZSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2FjaGVOb2RlID0gb2JqZWN0Tm9kZVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBQcmltaXRpdmVzIGdvIGludG8gYSByZWd1bGFyIE1hcFxyXG4gICAgICAgIGxldCBwcmltaXRpdmVDYWNoZSA9IGNhY2hlTm9kZS5wXHJcbiAgICAgICAgaWYgKHByaW1pdGl2ZUNhY2hlID09PSBudWxsKSB7XHJcbiAgICAgICAgICBjYWNoZU5vZGUucCA9IHByaW1pdGl2ZUNhY2hlID0gbmV3IE1hcCgpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZU5vZGUgPSBwcmltaXRpdmVDYWNoZS5nZXQoYXJnKVxyXG4gICAgICAgIGlmIChwcmltaXRpdmVOb2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGNhY2hlTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpXHJcbiAgICAgICAgICBwcmltaXRpdmVDYWNoZS5zZXQoYXJnLCBjYWNoZU5vZGUpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNhY2hlTm9kZSA9IHByaW1pdGl2ZU5vZGVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0ZXJtaW5hdGVkTm9kZSA9IGNhY2hlTm9kZSBhcyB1bmtub3duIGFzIFRlcm1pbmF0ZWRDYWNoZU5vZGU8YW55PlxyXG5cclxuICAgIGxldCByZXN1bHRcclxuXHJcbiAgICBpZiAoY2FjaGVOb2RlLnMgPT09IFRFUk1JTkFURUQpIHtcclxuICAgICAgcmVzdWx0ID0gY2FjaGVOb2RlLnZcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEFsbG93IGVycm9ycyB0byBwcm9wYWdhdGVcclxuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShudWxsLCBhcmd1bWVudHMgYXMgdW5rbm93biBhcyBhbnlbXSlcclxuICAgICAgcmVzdWx0c0NvdW50KytcclxuXHJcbiAgICAgIGlmIChyZXN1bHRFcXVhbGl0eUNoZWNrKSB7XHJcbiAgICAgICAgY29uc3QgbGFzdFJlc3VsdFZhbHVlID0gbGFzdFJlc3VsdD8uZGVyZWY/LigpID8/IGxhc3RSZXN1bHRcclxuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgbGFzdFJlc3VsdFZhbHVlICE9IG51bGwgJiZcclxuICAgICAgICAgIHJlc3VsdEVxdWFsaXR5Q2hlY2sobGFzdFJlc3VsdFZhbHVlIGFzIFJldHVyblR5cGU8RnVuYz4sIHJlc3VsdClcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJlc3VsdCA9IGxhc3RSZXN1bHRWYWx1ZVxyXG5cclxuICAgICAgICAgIHJlc3VsdHNDb3VudCAhPT0gMCAmJiByZXN1bHRzQ291bnQtLVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbmVlZHNXZWFrUmVmID1cclxuICAgICAgICAgICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiByZXN1bHQgIT09IG51bGwpIHx8XHJcbiAgICAgICAgICB0eXBlb2YgcmVzdWx0ID09PSAnZnVuY3Rpb24nXHJcblxyXG4gICAgICAgIGxhc3RSZXN1bHQgPSBuZWVkc1dlYWtSZWYgPyBuZXcgUmVmKHJlc3VsdCkgOiByZXN1bHRcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRlcm1pbmF0ZWROb2RlLnMgPSBURVJNSU5BVEVEXHJcblxyXG4gICAgdGVybWluYXRlZE5vZGUudiA9IHJlc3VsdFxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxuXHJcbiAgbWVtb2l6ZWQuY2xlYXJDYWNoZSA9ICgpID0+IHtcclxuICAgIGZuTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpXHJcbiAgICBtZW1vaXplZC5yZXNldFJlc3VsdHNDb3VudCgpXHJcbiAgfVxyXG5cclxuICBtZW1vaXplZC5yZXN1bHRzQ291bnQgPSAoKSA9PiByZXN1bHRzQ291bnRcclxuXHJcbiAgbWVtb2l6ZWQucmVzZXRSZXN1bHRzQ291bnQgPSAoKSA9PiB7XHJcbiAgICByZXN1bHRzQ291bnQgPSAwXHJcbiAgfVxyXG5cclxuICByZXR1cm4gbWVtb2l6ZWQgYXMgRnVuYyAmIFNpbXBsaWZ5PERlZmF1bHRNZW1vaXplRmllbGRzPlxyXG59XHJcbiIsImltcG9ydCB7IHdlYWtNYXBNZW1vaXplIH0gZnJvbSAnLi93ZWFrTWFwTWVtb2l6ZSdcclxuXHJcbmltcG9ydCB0eXBlIHtcclxuICBDb21iaW5lcixcclxuICBDcmVhdGVTZWxlY3Rvck9wdGlvbnMsXHJcbiAgRHJvcEZpcnN0UGFyYW1ldGVyLFxyXG4gIEV4dHJhY3RNZW1vaXplckZpZWxkcyxcclxuICBHZXRQYXJhbXNGcm9tU2VsZWN0b3JzLFxyXG4gIEdldFN0YXRlRnJvbVNlbGVjdG9ycyxcclxuICBJbnRlcnJ1cHRSZWN1cnNpb24sXHJcbiAgT3V0cHV0U2VsZWN0b3IsXHJcbiAgU2VsZWN0b3IsXHJcbiAgU2VsZWN0b3JBcnJheSxcclxuICBTZXRSZXF1aXJlZCxcclxuICBTaW1wbGlmeSxcclxuICBVbmtub3duTWVtb2l6ZXJcclxufSBmcm9tICcuL3R5cGVzJ1xyXG5cclxuaW1wb3J0IHtcclxuICBhc3NlcnRJc0Z1bmN0aW9uLFxyXG4gIGNvbGxlY3RJbnB1dFNlbGVjdG9yUmVzdWx0cyxcclxuICBlbnN1cmVJc0FycmF5LFxyXG4gIGdldERlcGVuZGVuY2llcyxcclxuICBnZXREZXZNb2RlQ2hlY2tzRXhlY3V0aW9uSW5mb1xyXG59IGZyb20gJy4vdXRpbHMnXHJcblxyXG4vKipcclxuICogQW4gaW5zdGFuY2Ugb2YgYGNyZWF0ZVNlbGVjdG9yYCwgY3VzdG9taXplZCB3aXRoIGEgZ2l2ZW4gbWVtb2l6ZSBpbXBsZW1lbnRhdGlvbi5cclxuICpcclxuICogQHRlbXBsYXRlIE1lbW9pemVGdW5jdGlvbiAtIFRoZSB0eXBlIG9mIHRoZSBtZW1vaXplIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBtZW1vaXplIHRoZSBgcmVzdWx0RnVuY2AgaW5zaWRlIGBjcmVhdGVTZWxlY3RvcmAgKGUuZy4sIGBscnVNZW1vaXplYCBvciBgd2Vha01hcE1lbW9pemVgKS5cclxuICogQHRlbXBsYXRlIEFyZ3NNZW1vaXplRnVuY3Rpb24gLSBUaGUgdHlwZSBvZiB0aGUgb3B0aW9uYWwgbWVtb2l6ZSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gbWVtb2l6ZSB0aGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBvdXRwdXQgc2VsZWN0b3IgZ2VuZXJhdGVkIGJ5IGBjcmVhdGVTZWxlY3RvcmAgKGUuZy4sIGBscnVNZW1vaXplYCBvciBgd2Vha01hcE1lbW9pemVgKS4gSWYgbm9uZSBpcyBleHBsaWNpdGx5IHByb3ZpZGVkLCBgd2Vha01hcE1lbW9pemVgIHdpbGwgYmUgdXNlZC5cclxuICogQHRlbXBsYXRlIFN0YXRlVHlwZSAtIFRoZSB0eXBlIG9mIHN0YXRlIHRoYXQgdGhlIHNlbGVjdG9ycyBjcmVhdGVkIHdpdGggdGhpcyBzZWxlY3RvciBjcmVhdG9yIHdpbGwgb3BlcmF0ZSBvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVTZWxlY3RvckZ1bmN0aW9uPFxyXG4gIE1lbW9pemVGdW5jdGlvbiBleHRlbmRzIFVua25vd25NZW1vaXplciA9IHR5cGVvZiB3ZWFrTWFwTWVtb2l6ZSxcclxuICBBcmdzTWVtb2l6ZUZ1bmN0aW9uIGV4dGVuZHMgVW5rbm93bk1lbW9pemVyID0gdHlwZW9mIHdlYWtNYXBNZW1vaXplLFxyXG4gIFN0YXRlVHlwZSA9IGFueVxyXG4+IHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbWVtb2l6ZWQgc2VsZWN0b3IgZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gY3JlYXRlU2VsZWN0b3JBcmdzIC0gQW4gYXJiaXRyYXJ5IG51bWJlciBvZiBpbnB1dCBzZWxlY3RvcnMgYXMgc2VwYXJhdGUgaW5saW5lIGFyZ3VtZW50cyBhbmQgYSBgY29tYmluZXJgIGZ1bmN0aW9uLlxyXG4gICAqIEByZXR1cm5zIEEgbWVtb2l6ZWQgb3V0cHV0IHNlbGVjdG9yLlxyXG4gICAqXHJcbiAgICogQHRlbXBsYXRlIElucHV0U2VsZWN0b3JzIC0gVGhlIHR5cGUgb2YgdGhlIGlucHV0IHNlbGVjdG9ycyBhcyBhbiBhcnJheS5cclxuICAgKiBAdGVtcGxhdGUgUmVzdWx0IC0gVGhlIHJldHVybiB0eXBlIG9mIHRoZSBgY29tYmluZXJgIGFzIHdlbGwgYXMgdGhlIG91dHB1dCBzZWxlY3Rvci5cclxuICAgKiBAdGVtcGxhdGUgT3ZlcnJpZGVNZW1vaXplRnVuY3Rpb24gLSBUaGUgdHlwZSBvZiB0aGUgb3B0aW9uYWwgYG1lbW9pemVgIGZ1bmN0aW9uIHRoYXQgY291bGQgYmUgcGFzc2VkIGludG8gdGhlIG9wdGlvbnMgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvcmlnaW5hbCBgbWVtb2l6ZWAgZnVuY3Rpb24gdGhhdCB3YXMgaW5pdGlhbGx5IHBhc3NlZCBpbnRvIGBjcmVhdGVTZWxlY3RvckNyZWF0b3JgLlxyXG4gICAqIEB0ZW1wbGF0ZSBPdmVycmlkZUFyZ3NNZW1vaXplRnVuY3Rpb24gLSBUaGUgdHlwZSBvZiB0aGUgb3B0aW9uYWwgYGFyZ3NNZW1vaXplYCBmdW5jdGlvbiB0aGF0IGNvdWxkIGJlIHBhc3NlZCBpbnRvIHRoZSBvcHRpb25zIG9iamVjdCB0byBvdmVycmlkZSB0aGUgb3JpZ2luYWwgYGFyZ3NNZW1vaXplYCBmdW5jdGlvbiB0aGF0IHdhcyBpbml0aWFsbHkgcGFzc2VkIGludG8gYGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcmAuXHJcbiAgICpcclxuICAgKiBAc2VlIHtAbGluayBodHRwczovL3Jlc2VsZWN0LmpzLm9yZy9hcGkvY3JlYXRlc2VsZWN0b3IgYGNyZWF0ZVNlbGVjdG9yYH1cclxuICAgKi9cclxuICA8SW5wdXRTZWxlY3RvcnMgZXh0ZW5kcyBTZWxlY3RvckFycmF5PFN0YXRlVHlwZT4sIFJlc3VsdD4oXHJcbiAgICAuLi5jcmVhdGVTZWxlY3RvckFyZ3M6IFtcclxuICAgICAgLi4uaW5wdXRTZWxlY3RvcnM6IElucHV0U2VsZWN0b3JzLFxyXG4gICAgICBjb21iaW5lcjogQ29tYmluZXI8SW5wdXRTZWxlY3RvcnMsIFJlc3VsdD5cclxuICAgIF1cclxuICApOiBPdXRwdXRTZWxlY3RvcjxcclxuICAgIElucHV0U2VsZWN0b3JzLFxyXG4gICAgUmVzdWx0LFxyXG4gICAgTWVtb2l6ZUZ1bmN0aW9uLFxyXG4gICAgQXJnc01lbW9pemVGdW5jdGlvblxyXG4gID4gJlxyXG4gICAgSW50ZXJydXB0UmVjdXJzaW9uXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBtZW1vaXplZCBzZWxlY3RvciBmdW5jdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBjcmVhdGVTZWxlY3RvckFyZ3MgLSBBbiBhcmJpdHJhcnkgbnVtYmVyIG9mIGlucHV0IHNlbGVjdG9ycyBhcyBzZXBhcmF0ZSBpbmxpbmUgYXJndW1lbnRzLCBhIGBjb21iaW5lcmAgZnVuY3Rpb24gYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbiAgICogQHJldHVybnMgQSBtZW1vaXplZCBvdXRwdXQgc2VsZWN0b3IuXHJcbiAgICpcclxuICAgKiBAdGVtcGxhdGUgSW5wdXRTZWxlY3RvcnMgLSBUaGUgdHlwZSBvZiB0aGUgaW5wdXQgc2VsZWN0b3JzIGFzIGFuIGFycmF5LlxyXG4gICAqIEB0ZW1wbGF0ZSBSZXN1bHQgLSBUaGUgcmV0dXJuIHR5cGUgb2YgdGhlIGBjb21iaW5lcmAgYXMgd2VsbCBhcyB0aGUgb3V0cHV0IHNlbGVjdG9yLlxyXG4gICAqIEB0ZW1wbGF0ZSBPdmVycmlkZU1lbW9pemVGdW5jdGlvbiAtIFRoZSB0eXBlIG9mIHRoZSBvcHRpb25hbCBgbWVtb2l6ZWAgZnVuY3Rpb24gdGhhdCBjb3VsZCBiZSBwYXNzZWQgaW50byB0aGUgb3B0aW9ucyBvYmplY3QgdG8gb3ZlcnJpZGUgdGhlIG9yaWdpbmFsIGBtZW1vaXplYCBmdW5jdGlvbiB0aGF0IHdhcyBpbml0aWFsbHkgcGFzc2VkIGludG8gYGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcmAuXHJcbiAgICogQHRlbXBsYXRlIE92ZXJyaWRlQXJnc01lbW9pemVGdW5jdGlvbiAtIFRoZSB0eXBlIG9mIHRoZSBvcHRpb25hbCBgYXJnc01lbW9pemVgIGZ1bmN0aW9uIHRoYXQgY291bGQgYmUgcGFzc2VkIGludG8gdGhlIG9wdGlvbnMgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvcmlnaW5hbCBgYXJnc01lbW9pemVgIGZ1bmN0aW9uIHRoYXQgd2FzIGluaXRpYWxseSBwYXNzZWQgaW50byBgY3JlYXRlU2VsZWN0b3JDcmVhdG9yYC5cclxuICAgKlxyXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVzZWxlY3QuanMub3JnL2FwaS9jcmVhdGVzZWxlY3RvciBgY3JlYXRlU2VsZWN0b3JgfVxyXG4gICAqL1xyXG4gIDxcclxuICAgIElucHV0U2VsZWN0b3JzIGV4dGVuZHMgU2VsZWN0b3JBcnJheTxTdGF0ZVR5cGU+LFxyXG4gICAgUmVzdWx0LFxyXG4gICAgT3ZlcnJpZGVNZW1vaXplRnVuY3Rpb24gZXh0ZW5kcyBVbmtub3duTWVtb2l6ZXIgPSBNZW1vaXplRnVuY3Rpb24sXHJcbiAgICBPdmVycmlkZUFyZ3NNZW1vaXplRnVuY3Rpb24gZXh0ZW5kcyBVbmtub3duTWVtb2l6ZXIgPSBBcmdzTWVtb2l6ZUZ1bmN0aW9uXHJcbiAgPihcclxuICAgIC4uLmNyZWF0ZVNlbGVjdG9yQXJnczogW1xyXG4gICAgICAuLi5pbnB1dFNlbGVjdG9yczogSW5wdXRTZWxlY3RvcnMsXHJcbiAgICAgIGNvbWJpbmVyOiBDb21iaW5lcjxJbnB1dFNlbGVjdG9ycywgUmVzdWx0PixcclxuICAgICAgY3JlYXRlU2VsZWN0b3JPcHRpb25zOiBTaW1wbGlmeTxcclxuICAgICAgICBDcmVhdGVTZWxlY3Rvck9wdGlvbnM8XHJcbiAgICAgICAgICBNZW1vaXplRnVuY3Rpb24sXHJcbiAgICAgICAgICBBcmdzTWVtb2l6ZUZ1bmN0aW9uLFxyXG4gICAgICAgICAgT3ZlcnJpZGVNZW1vaXplRnVuY3Rpb24sXHJcbiAgICAgICAgICBPdmVycmlkZUFyZ3NNZW1vaXplRnVuY3Rpb25cclxuICAgICAgICA+XHJcbiAgICAgID5cclxuICAgIF1cclxuICApOiBPdXRwdXRTZWxlY3RvcjxcclxuICAgIElucHV0U2VsZWN0b3JzLFxyXG4gICAgUmVzdWx0LFxyXG4gICAgT3ZlcnJpZGVNZW1vaXplRnVuY3Rpb24sXHJcbiAgICBPdmVycmlkZUFyZ3NNZW1vaXplRnVuY3Rpb25cclxuICA+ICZcclxuICAgIEludGVycnVwdFJlY3Vyc2lvblxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbWVtb2l6ZWQgc2VsZWN0b3IgZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaW5wdXRTZWxlY3RvcnMgLSBBbiBhcnJheSBvZiBpbnB1dCBzZWxlY3RvcnMuXHJcbiAgICogQHBhcmFtIGNvbWJpbmVyIC0gQSBmdW5jdGlvbiB0aGF0IENvbWJpbmVzIHRoZSBpbnB1dCBzZWxlY3RvcnMgYW5kIHJldHVybnMgYW4gb3V0cHV0IHNlbGVjdG9yLiBPdGhlcndpc2Uga25vd24gYXMgdGhlIHJlc3VsdCBmdW5jdGlvbi5cclxuICAgKiBAcGFyYW0gY3JlYXRlU2VsZWN0b3JPcHRpb25zIC0gQW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIGZ1cnRoZXIgY3VzdG9taXphdGlvbiBwZXIgc2VsZWN0b3IuXHJcbiAgICogQHJldHVybnMgQSBtZW1vaXplZCBvdXRwdXQgc2VsZWN0b3IuXHJcbiAgICpcclxuICAgKiBAdGVtcGxhdGUgSW5wdXRTZWxlY3RvcnMgLSBUaGUgdHlwZSBvZiB0aGUgaW5wdXQgc2VsZWN0b3JzIGFycmF5LlxyXG4gICAqIEB0ZW1wbGF0ZSBSZXN1bHQgLSBUaGUgcmV0dXJuIHR5cGUgb2YgdGhlIGBjb21iaW5lcmAgYXMgd2VsbCBhcyB0aGUgb3V0cHV0IHNlbGVjdG9yLlxyXG4gICAqIEB0ZW1wbGF0ZSBPdmVycmlkZU1lbW9pemVGdW5jdGlvbiAtIFRoZSB0eXBlIG9mIHRoZSBvcHRpb25hbCBgbWVtb2l6ZWAgZnVuY3Rpb24gdGhhdCBjb3VsZCBiZSBwYXNzZWQgaW50byB0aGUgb3B0aW9ucyBvYmplY3QgdG8gb3ZlcnJpZGUgdGhlIG9yaWdpbmFsIGBtZW1vaXplYCBmdW5jdGlvbiB0aGF0IHdhcyBpbml0aWFsbHkgcGFzc2VkIGludG8gYGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcmAuXHJcbiAgICogQHRlbXBsYXRlIE92ZXJyaWRlQXJnc01lbW9pemVGdW5jdGlvbiAtIFRoZSB0eXBlIG9mIHRoZSBvcHRpb25hbCBgYXJnc01lbW9pemVgIGZ1bmN0aW9uIHRoYXQgY291bGQgYmUgcGFzc2VkIGludG8gdGhlIG9wdGlvbnMgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvcmlnaW5hbCBgYXJnc01lbW9pemVgIGZ1bmN0aW9uIHRoYXQgd2FzIGluaXRpYWxseSBwYXNzZWQgaW50byBgY3JlYXRlU2VsZWN0b3JDcmVhdG9yYC5cclxuICAgKlxyXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVzZWxlY3QuanMub3JnL2FwaS9jcmVhdGVzZWxlY3RvciBgY3JlYXRlU2VsZWN0b3JgfVxyXG4gICAqL1xyXG4gIDxcclxuICAgIElucHV0U2VsZWN0b3JzIGV4dGVuZHMgU2VsZWN0b3JBcnJheTxTdGF0ZVR5cGU+LFxyXG4gICAgUmVzdWx0LFxyXG4gICAgT3ZlcnJpZGVNZW1vaXplRnVuY3Rpb24gZXh0ZW5kcyBVbmtub3duTWVtb2l6ZXIgPSBNZW1vaXplRnVuY3Rpb24sXHJcbiAgICBPdmVycmlkZUFyZ3NNZW1vaXplRnVuY3Rpb24gZXh0ZW5kcyBVbmtub3duTWVtb2l6ZXIgPSBBcmdzTWVtb2l6ZUZ1bmN0aW9uXHJcbiAgPihcclxuICAgIGlucHV0U2VsZWN0b3JzOiBbLi4uSW5wdXRTZWxlY3RvcnNdLFxyXG4gICAgY29tYmluZXI6IENvbWJpbmVyPElucHV0U2VsZWN0b3JzLCBSZXN1bHQ+LFxyXG4gICAgY3JlYXRlU2VsZWN0b3JPcHRpb25zPzogU2ltcGxpZnk8XHJcbiAgICAgIENyZWF0ZVNlbGVjdG9yT3B0aW9uczxcclxuICAgICAgICBNZW1vaXplRnVuY3Rpb24sXHJcbiAgICAgICAgQXJnc01lbW9pemVGdW5jdGlvbixcclxuICAgICAgICBPdmVycmlkZU1lbW9pemVGdW5jdGlvbixcclxuICAgICAgICBPdmVycmlkZUFyZ3NNZW1vaXplRnVuY3Rpb25cclxuICAgICAgPlxyXG4gICAgPlxyXG4gICk6IE91dHB1dFNlbGVjdG9yPFxyXG4gICAgSW5wdXRTZWxlY3RvcnMsXHJcbiAgICBSZXN1bHQsXHJcbiAgICBPdmVycmlkZU1lbW9pemVGdW5jdGlvbixcclxuICAgIE92ZXJyaWRlQXJnc01lbW9pemVGdW5jdGlvblxyXG4gID4gJlxyXG4gICAgSW50ZXJydXB0UmVjdXJzaW9uXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBcInByZS10eXBlZFwiIHZlcnNpb24gb2Yge0BsaW5rY29kZSBjcmVhdGVTZWxlY3RvciBjcmVhdGVTZWxlY3Rvcn1cclxuICAgKiB3aGVyZSB0aGUgYHN0YXRlYCB0eXBlIGlzIHByZWRlZmluZWQuXHJcbiAgICpcclxuICAgKiBUaGlzIGFsbG93cyB5b3UgdG8gc2V0IHRoZSBgc3RhdGVgIHR5cGUgb25jZSwgZWxpbWluYXRpbmcgdGhlIG5lZWQgdG9cclxuICAgKiBzcGVjaWZ5IGl0IHdpdGggZXZlcnkge0BsaW5rY29kZSBjcmVhdGVTZWxlY3RvciBjcmVhdGVTZWxlY3Rvcn0gY2FsbC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIEEgcHJlLXR5cGVkIGBjcmVhdGVTZWxlY3RvcmAgd2l0aCB0aGUgc3RhdGUgdHlwZSBhbHJlYWR5IGRlZmluZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHRzXHJcbiAgICogaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgfSBmcm9tICdyZXNlbGVjdCdcclxuICAgKlxyXG4gICAqIGV4cG9ydCBpbnRlcmZhY2UgUm9vdFN0YXRlIHtcclxuICAgKiAgIHRvZG9zOiB7IGlkOiBudW1iZXI7IGNvbXBsZXRlZDogYm9vbGVhbiB9W11cclxuICAgKiAgIGFsZXJ0czogeyBpZDogbnVtYmVyOyByZWFkOiBib29sZWFuIH1bXVxyXG4gICAqIH1cclxuICAgKlxyXG4gICAqIGV4cG9ydCBjb25zdCBjcmVhdGVBcHBTZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yLndpdGhUeXBlczxSb290U3RhdGU+KClcclxuICAgKlxyXG4gICAqIGNvbnN0IHNlbGVjdFRvZG9JZHMgPSBjcmVhdGVBcHBTZWxlY3RvcihcclxuICAgKiAgIFtcclxuICAgKiAgICAgLy8gVHlwZSBvZiBgc3RhdGVgIGlzIHNldCB0byBgUm9vdFN0YXRlYCwgbm8gbmVlZCB0byBtYW51YWxseSBzZXQgdGhlIHR5cGVcclxuICAgKiAgICAgc3RhdGUgPT4gc3RhdGUudG9kb3NcclxuICAgKiAgIF0sXHJcbiAgICogICB0b2RvcyA9PiB0b2Rvcy5tYXAoKHsgaWQgfSkgPT4gaWQpXHJcbiAgICogKVxyXG4gICAqIGBgYFxyXG4gICAqIEB0ZW1wbGF0ZSBPdmVycmlkZVN0YXRlVHlwZSAtIFRoZSBzcGVjaWZpYyB0eXBlIG9mIHN0YXRlIHVzZWQgYnkgYWxsIHNlbGVjdG9ycyBjcmVhdGVkIHdpdGggdGhpcyBzZWxlY3RvciBjcmVhdG9yLlxyXG4gICAqXHJcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZXNlbGVjdC5qcy5vcmcvYXBpL2NyZWF0ZXNlbGVjdG9yI2RlZmluaW5nLWEtcHJlLXR5cGVkLWNyZWF0ZXNlbGVjdG9yIGBjcmVhdGVTZWxlY3Rvci53aXRoVHlwZXNgfVxyXG4gICAqXHJcbiAgICogQHNpbmNlIDUuMS4wXHJcbiAgICovXHJcbiAgd2l0aFR5cGVzOiA8T3ZlcnJpZGVTdGF0ZVR5cGUgZXh0ZW5kcyBTdGF0ZVR5cGU+KCkgPT4gQ3JlYXRlU2VsZWN0b3JGdW5jdGlvbjxcclxuICAgIE1lbW9pemVGdW5jdGlvbixcclxuICAgIEFyZ3NNZW1vaXplRnVuY3Rpb24sXHJcbiAgICBPdmVycmlkZVN0YXRlVHlwZVxyXG4gID5cclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzZWxlY3RvciBjcmVhdG9yIGZ1bmN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBtZW1vaXphdGlvbiBmdW5jdGlvblxyXG4gKiBhbmQgb3B0aW9ucyBmb3IgY3VzdG9taXppbmcgbWVtb2l6YXRpb24gYmVoYXZpb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyB0aGUgYG1lbW9pemVgIGZ1bmN0aW9uIHJlc3BvbnNpYmxlIGZvciBtZW1vaXppbmcgdGhlIGByZXN1bHRGdW5jYCBpbnNpZGUgYGNyZWF0ZVNlbGVjdG9yYCAoZS5nLiwgYGxydU1lbW9pemVgIG9yIGB3ZWFrTWFwTWVtb2l6ZWApLiBJdCBhbHNvIHByb3ZpZGVzIGFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgY3VzdG9taXppbmcgbWVtb2l6YXRpb24uIFdoaWxlIHRoZSBgbWVtb2l6ZWAgcHJvcGVydHkgaXMgbWFuZGF0b3J5LCB0aGUgcmVzdCBhcmUgb3B0aW9uYWwuXHJcbiAqIEByZXR1cm5zIEEgY3VzdG9taXplZCBgY3JlYXRlU2VsZWN0b3JgIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0c1xyXG4gKiBjb25zdCBjdXN0b21DcmVhdGVTZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcih7XHJcbiAqICAgbWVtb2l6ZTogY3VzdG9tTWVtb2l6ZSwgLy8gRnVuY3Rpb24gdG8gYmUgdXNlZCB0byBtZW1vaXplIGByZXN1bHRGdW5jYFxyXG4gKiAgIG1lbW9pemVPcHRpb25zOiBbbWVtb2l6ZU9wdGlvbjEsIG1lbW9pemVPcHRpb24yXSwgLy8gT3B0aW9ucyBwYXNzZWQgdG8gYGN1c3RvbU1lbW9pemVgIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgb253YXJkc1xyXG4gKiAgIGFyZ3NNZW1vaXplOiBjdXN0b21BcmdzTWVtb2l6ZSwgLy8gRnVuY3Rpb24gdG8gYmUgdXNlZCB0byBtZW1vaXplIHRoZSBzZWxlY3RvcidzIGFyZ3VtZW50c1xyXG4gKiAgIGFyZ3NNZW1vaXplT3B0aW9uczogW2FyZ3NNZW1vaXplT3B0aW9uMSwgYXJnc01lbW9pemVPcHRpb24yXSAvLyBPcHRpb25zIHBhc3NlZCB0byBgY3VzdG9tQXJnc01lbW9pemVgIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgb253YXJkc1xyXG4gKiB9KVxyXG4gKlxyXG4gKiBjb25zdCBjdXN0b21TZWxlY3RvciA9IGN1c3RvbUNyZWF0ZVNlbGVjdG9yKFxyXG4gKiAgIFtpbnB1dFNlbGVjdG9yMSwgaW5wdXRTZWxlY3RvcjJdLFxyXG4gKiAgIHJlc3VsdEZ1bmMgLy8gYHJlc3VsdEZ1bmNgIHdpbGwgYmUgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBgY3VzdG9tTWVtb2l6ZWBcclxuICogKVxyXG4gKlxyXG4gKiBjdXN0b21TZWxlY3RvcihcclxuICogICAuLi5zZWxlY3RvckFyZ3MgLy8gV2lsbCBiZSBtZW1vaXplZCBieSBgY3VzdG9tQXJnc01lbW9pemVgXHJcbiAqIClcclxuICogYGBgXHJcbiAqXHJcbiAqIEB0ZW1wbGF0ZSBNZW1vaXplRnVuY3Rpb24gLSBUaGUgdHlwZSBvZiB0aGUgbWVtb2l6ZSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gbWVtb2l6ZSB0aGUgYHJlc3VsdEZ1bmNgIGluc2lkZSBgY3JlYXRlU2VsZWN0b3JgIChlLmcuLCBgbHJ1TWVtb2l6ZWAgb3IgYHdlYWtNYXBNZW1vaXplYCkuXHJcbiAqIEB0ZW1wbGF0ZSBBcmdzTWVtb2l6ZUZ1bmN0aW9uIC0gVGhlIHR5cGUgb2YgdGhlIG9wdGlvbmFsIG1lbW9pemUgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIG1lbW9pemUgdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgb3V0cHV0IHNlbGVjdG9yIGdlbmVyYXRlZCBieSBgY3JlYXRlU2VsZWN0b3JgIChlLmcuLCBgbHJ1TWVtb2l6ZWAgb3IgYHdlYWtNYXBNZW1vaXplYCkuIElmIG5vbmUgaXMgZXhwbGljaXRseSBwcm92aWRlZCwgYHdlYWtNYXBNZW1vaXplYCB3aWxsIGJlIHVzZWQuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVzZWxlY3QuanMub3JnL2FwaS9jcmVhdGVTZWxlY3RvckNyZWF0b3IjdXNpbmctb3B0aW9ucy1zaW5jZS01MDAgYGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcmB9XHJcbiAqXHJcbiAqIEBzaW5jZSA1LjAuMFxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JDcmVhdG9yPFxyXG4gIE1lbW9pemVGdW5jdGlvbiBleHRlbmRzIFVua25vd25NZW1vaXplcixcclxuICBBcmdzTWVtb2l6ZUZ1bmN0aW9uIGV4dGVuZHMgVW5rbm93bk1lbW9pemVyID0gdHlwZW9mIHdlYWtNYXBNZW1vaXplXHJcbj4oXHJcbiAgb3B0aW9uczogU2ltcGxpZnk8XHJcbiAgICBTZXRSZXF1aXJlZDxcclxuICAgICAgQ3JlYXRlU2VsZWN0b3JPcHRpb25zPFxyXG4gICAgICAgIHR5cGVvZiB3ZWFrTWFwTWVtb2l6ZSxcclxuICAgICAgICB0eXBlb2Ygd2Vha01hcE1lbW9pemUsXHJcbiAgICAgICAgTWVtb2l6ZUZ1bmN0aW9uLFxyXG4gICAgICAgIEFyZ3NNZW1vaXplRnVuY3Rpb25cclxuICAgICAgPixcclxuICAgICAgJ21lbW9pemUnXHJcbiAgICA+XHJcbiAgPlxyXG4pOiBDcmVhdGVTZWxlY3RvckZ1bmN0aW9uPE1lbW9pemVGdW5jdGlvbiwgQXJnc01lbW9pemVGdW5jdGlvbj5cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2VsZWN0b3IgY3JlYXRvciBmdW5jdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgbWVtb2l6YXRpb24gZnVuY3Rpb25cclxuICogYW5kIG9wdGlvbnMgZm9yIGN1c3RvbWl6aW5nIG1lbW9pemF0aW9uIGJlaGF2aW9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gbWVtb2l6ZSAtIFRoZSBgbWVtb2l6ZWAgZnVuY3Rpb24gcmVzcG9uc2libGUgZm9yIG1lbW9pemluZyB0aGUgYHJlc3VsdEZ1bmNgIGluc2lkZSBgY3JlYXRlU2VsZWN0b3JgIChlLmcuLCBgbHJ1TWVtb2l6ZWAgb3IgYHdlYWtNYXBNZW1vaXplYCkuXHJcbiAqIEBwYXJhbSBtZW1vaXplT3B0aW9uc0Zyb21BcmdzIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgbWVtb2l6YXRpb24gZnVuY3Rpb24uIFRoZXNlIG9wdGlvbnMgYXJlIHRoZW4gcGFzc2VkIHRvIHRoZSBtZW1vaXplIGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgb253YXJkcy5cclxuICogQHJldHVybnMgQSBjdXN0b21pemVkIGBjcmVhdGVTZWxlY3RvcmAgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHRzXHJcbiAqIGNvbnN0IGN1c3RvbUNyZWF0ZVNlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKGN1c3RvbU1lbW9pemUsIC8vIEZ1bmN0aW9uIHRvIGJlIHVzZWQgdG8gbWVtb2l6ZSBgcmVzdWx0RnVuY2BcclxuICogICBvcHRpb24xLCAvLyBXaWxsIGJlIHBhc3NlZCBhcyBzZWNvbmQgYXJndW1lbnQgdG8gYGN1c3RvbU1lbW9pemVgXHJcbiAqICAgb3B0aW9uMiwgLy8gV2lsbCBiZSBwYXNzZWQgYXMgdGhpcmQgYXJndW1lbnQgdG8gYGN1c3RvbU1lbW9pemVgXHJcbiAqICAgb3B0aW9uMyAvLyBXaWxsIGJlIHBhc3NlZCBhcyBmb3VydGggYXJndW1lbnQgdG8gYGN1c3RvbU1lbW9pemVgXHJcbiAqIClcclxuICpcclxuICogY29uc3QgY3VzdG9tU2VsZWN0b3IgPSBjdXN0b21DcmVhdGVTZWxlY3RvcihcclxuICogICBbaW5wdXRTZWxlY3RvcjEsIGlucHV0U2VsZWN0b3IyXSxcclxuICogICByZXN1bHRGdW5jIC8vIGByZXN1bHRGdW5jYCB3aWxsIGJlIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYGN1c3RvbU1lbW9pemVgXHJcbiAqIClcclxuICogYGBgXHJcbiAqXHJcbiAqIEB0ZW1wbGF0ZSBNZW1vaXplRnVuY3Rpb24gLSBUaGUgdHlwZSBvZiB0aGUgbWVtb2l6ZSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gbWVtb2l6ZSB0aGUgYHJlc3VsdEZ1bmNgIGluc2lkZSBgY3JlYXRlU2VsZWN0b3JgIChlLmcuLCBgbHJ1TWVtb2l6ZWAgb3IgYHdlYWtNYXBNZW1vaXplYCkuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVzZWxlY3QuanMub3JnL2FwaS9jcmVhdGVTZWxlY3RvckNyZWF0b3IjdXNpbmctbWVtb2l6ZS1hbmQtbWVtb2l6ZW9wdGlvbnMgYGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcmB9XHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWxlY3RvckNyZWF0b3I8TWVtb2l6ZUZ1bmN0aW9uIGV4dGVuZHMgVW5rbm93bk1lbW9pemVyPihcclxuICBtZW1vaXplOiBNZW1vaXplRnVuY3Rpb24sXHJcbiAgLi4ubWVtb2l6ZU9wdGlvbnNGcm9tQXJnczogRHJvcEZpcnN0UGFyYW1ldGVyPE1lbW9pemVGdW5jdGlvbj5cclxuKTogQ3JlYXRlU2VsZWN0b3JGdW5jdGlvbjxNZW1vaXplRnVuY3Rpb24+XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHNlbGVjdG9yIGNyZWF0b3IgZnVuY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIG1lbW9pemF0aW9uXHJcbiAqIGZ1bmN0aW9uIGFuZCBvcHRpb25zIGZvciBjdXN0b21pemluZyBtZW1vaXphdGlvbiBiZWhhdmlvci5cclxuICpcclxuICogQHBhcmFtIG1lbW9pemVPck9wdGlvbnMgLSBFaXRoZXIgQSBgbWVtb2l6ZWAgZnVuY3Rpb24gb3IgYW4gYG9wdGlvbnNgIG9iamVjdCBjb250YWluaW5nIHRoZSBgbWVtb2l6ZWAgZnVuY3Rpb24uXHJcbiAqIEBwYXJhbSBtZW1vaXplT3B0aW9uc0Zyb21BcmdzIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgbWVtb2l6YXRpb24gZnVuY3Rpb24uIFRoZXNlIG9wdGlvbnMgYXJlIHRoZW4gcGFzc2VkIHRvIHRoZSBtZW1vaXplIGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgb253YXJkcy5cclxuICogQHJldHVybnMgQSBjdXN0b21pemVkIGBjcmVhdGVTZWxlY3RvcmAgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEB0ZW1wbGF0ZSBNZW1vaXplRnVuY3Rpb24gLSBUaGUgdHlwZSBvZiB0aGUgbWVtb2l6ZSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gbWVtb2l6ZSB0aGUgYHJlc3VsdEZ1bmNgIGluc2lkZSBgY3JlYXRlU2VsZWN0b3JgIChlLmcuLCBgbHJ1TWVtb2l6ZWAgb3IgYHdlYWtNYXBNZW1vaXplYCkuXHJcbiAqIEB0ZW1wbGF0ZSBBcmdzTWVtb2l6ZUZ1bmN0aW9uIC0gVGhlIHR5cGUgb2YgdGhlIG9wdGlvbmFsIG1lbW9pemUgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIG1lbW9pemUgdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgb3V0cHV0IHNlbGVjdG9yIGdlbmVyYXRlZCBieSBgY3JlYXRlU2VsZWN0b3JgIChlLmcuLCBgbHJ1TWVtb2l6ZWAgb3IgYHdlYWtNYXBNZW1vaXplYCkuIElmIG5vbmUgaXMgZXhwbGljaXRseSBwcm92aWRlZCwgYHdlYWtNYXBNZW1vaXplYCB3aWxsIGJlIHVzZWQuXHJcbiAqIEB0ZW1wbGF0ZSBNZW1vaXplT3JPcHRpb25zIC0gVGhlIHR5cGUgb2YgdGhlIGZpcnN0IGFyZ3VtZW50LiBJdCBjYW4gZWl0aGVyIGJlIGEgYG1lbW9pemVgIGZ1bmN0aW9uIG9yIGFuIGBvcHRpb25zYCBvYmplY3QgY29udGFpbmluZyB0aGUgYG1lbW9pemVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcjxcclxuICBNZW1vaXplRnVuY3Rpb24gZXh0ZW5kcyBVbmtub3duTWVtb2l6ZXIsXHJcbiAgQXJnc01lbW9pemVGdW5jdGlvbiBleHRlbmRzIFVua25vd25NZW1vaXplcixcclxuICBNZW1vaXplT3JPcHRpb25zIGV4dGVuZHNcclxuICAgIHwgTWVtb2l6ZUZ1bmN0aW9uXHJcbiAgICB8IFNldFJlcXVpcmVkPFxyXG4gICAgICAgIENyZWF0ZVNlbGVjdG9yT3B0aW9uczxNZW1vaXplRnVuY3Rpb24sIEFyZ3NNZW1vaXplRnVuY3Rpb24+LFxyXG4gICAgICAgICdtZW1vaXplJ1xyXG4gICAgICA+XHJcbj4oXHJcbiAgbWVtb2l6ZU9yT3B0aW9uczogTWVtb2l6ZU9yT3B0aW9ucyxcclxuICAuLi5tZW1vaXplT3B0aW9uc0Zyb21BcmdzOiBNZW1vaXplT3JPcHRpb25zIGV4dGVuZHMgU2V0UmVxdWlyZWQ8XHJcbiAgICBDcmVhdGVTZWxlY3Rvck9wdGlvbnM8TWVtb2l6ZUZ1bmN0aW9uLCBBcmdzTWVtb2l6ZUZ1bmN0aW9uPixcclxuICAgICdtZW1vaXplJ1xyXG4gID5cclxuICAgID8gbmV2ZXJcclxuICAgIDogRHJvcEZpcnN0UGFyYW1ldGVyPE1lbW9pemVGdW5jdGlvbj5cclxuKSB7XHJcbiAgLyoqIG9wdGlvbnMgaW5pdGlhbGx5IHBhc3NlZCBpbnRvIGBjcmVhdGVTZWxlY3RvckNyZWF0b3JgLiAqL1xyXG4gIGNvbnN0IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvck9wdGlvbnM6IFNldFJlcXVpcmVkPFxyXG4gICAgQ3JlYXRlU2VsZWN0b3JPcHRpb25zPE1lbW9pemVGdW5jdGlvbiwgQXJnc01lbW9pemVGdW5jdGlvbj4sXHJcbiAgICAnbWVtb2l6ZSdcclxuICA+ID0gdHlwZW9mIG1lbW9pemVPck9wdGlvbnMgPT09ICdmdW5jdGlvbidcclxuICAgID8ge1xyXG4gICAgICAgIG1lbW9pemU6IG1lbW9pemVPck9wdGlvbnMgYXMgTWVtb2l6ZUZ1bmN0aW9uLFxyXG4gICAgICAgIG1lbW9pemVPcHRpb25zOiBtZW1vaXplT3B0aW9uc0Zyb21BcmdzXHJcbiAgICAgIH1cclxuICAgIDogbWVtb2l6ZU9yT3B0aW9uc1xyXG5cclxuICBjb25zdCBjcmVhdGVTZWxlY3RvciA9IDxcclxuICAgIElucHV0U2VsZWN0b3JzIGV4dGVuZHMgU2VsZWN0b3JBcnJheSxcclxuICAgIFJlc3VsdCxcclxuICAgIE92ZXJyaWRlTWVtb2l6ZUZ1bmN0aW9uIGV4dGVuZHMgVW5rbm93bk1lbW9pemVyID0gTWVtb2l6ZUZ1bmN0aW9uLFxyXG4gICAgT3ZlcnJpZGVBcmdzTWVtb2l6ZUZ1bmN0aW9uIGV4dGVuZHMgVW5rbm93bk1lbW9pemVyID0gQXJnc01lbW9pemVGdW5jdGlvblxyXG4gID4oXHJcbiAgICAuLi5jcmVhdGVTZWxlY3RvckFyZ3M6IFtcclxuICAgICAgLi4uaW5wdXRTZWxlY3RvcnM6IFsuLi5JbnB1dFNlbGVjdG9yc10sXHJcbiAgICAgIGNvbWJpbmVyOiBDb21iaW5lcjxJbnB1dFNlbGVjdG9ycywgUmVzdWx0PixcclxuICAgICAgY3JlYXRlU2VsZWN0b3JPcHRpb25zPzogQ3JlYXRlU2VsZWN0b3JPcHRpb25zPFxyXG4gICAgICAgIE1lbW9pemVGdW5jdGlvbixcclxuICAgICAgICBBcmdzTWVtb2l6ZUZ1bmN0aW9uLFxyXG4gICAgICAgIE92ZXJyaWRlTWVtb2l6ZUZ1bmN0aW9uLFxyXG4gICAgICAgIE92ZXJyaWRlQXJnc01lbW9pemVGdW5jdGlvblxyXG4gICAgICA+XHJcbiAgICBdXHJcbiAgKSA9PiB7XHJcbiAgICBsZXQgcmVjb21wdXRhdGlvbnMgPSAwXHJcbiAgICBsZXQgZGVwZW5kZW5jeVJlY29tcHV0YXRpb25zID0gMFxyXG4gICAgbGV0IGxhc3RSZXN1bHQ6IFJlc3VsdFxyXG5cclxuICAgIC8vIER1ZSB0byB0aGUgaW50cmljYWNpZXMgb2YgcmVzdCBwYXJhbXMsIHdlIGNhbid0IGRvIGFuIG9wdGlvbmFsIGFyZyBhZnRlciBgLi4uY3JlYXRlU2VsZWN0b3JBcmdzYC5cclxuICAgIC8vIFNvLCBzdGFydCBieSBkZWNsYXJpbmcgdGhlIGRlZmF1bHQgdmFsdWUgaGVyZS5cclxuICAgIC8vIChBbmQgeWVzLCB0aGUgd29yZHMgJ21lbW9pemUnIGFuZCAnb3B0aW9ucycgYXBwZWFyIHRvbyBtYW55IHRpbWVzIGluIHRoaXMgbmV4dCBzZXF1ZW5jZS4pXHJcbiAgICBsZXQgZGlyZWN0bHlQYXNzZWRPcHRpb25zOiBDcmVhdGVTZWxlY3Rvck9wdGlvbnM8XHJcbiAgICAgIE1lbW9pemVGdW5jdGlvbixcclxuICAgICAgQXJnc01lbW9pemVGdW5jdGlvbixcclxuICAgICAgT3ZlcnJpZGVNZW1vaXplRnVuY3Rpb24sXHJcbiAgICAgIE92ZXJyaWRlQXJnc01lbW9pemVGdW5jdGlvblxyXG4gICAgPiA9IHt9XHJcblxyXG4gICAgLy8gTm9ybWFsbHksIHRoZSByZXN1bHQgZnVuYyBvciBcImNvbWJpbmVyXCIgaXMgdGhlIGxhc3QgYXJnXHJcbiAgICBsZXQgcmVzdWx0RnVuYyA9IGNyZWF0ZVNlbGVjdG9yQXJncy5wb3AoKSBhc1xyXG4gICAgICB8IENvbWJpbmVyPElucHV0U2VsZWN0b3JzLCBSZXN1bHQ+XHJcbiAgICAgIHwgQ3JlYXRlU2VsZWN0b3JPcHRpb25zPFxyXG4gICAgICAgICAgTWVtb2l6ZUZ1bmN0aW9uLFxyXG4gICAgICAgICAgQXJnc01lbW9pemVGdW5jdGlvbixcclxuICAgICAgICAgIE92ZXJyaWRlTWVtb2l6ZUZ1bmN0aW9uLFxyXG4gICAgICAgICAgT3ZlcnJpZGVBcmdzTWVtb2l6ZUZ1bmN0aW9uXHJcbiAgICAgICAgPlxyXG5cclxuICAgIC8vIElmIHRoZSByZXN1bHQgZnVuYyBpcyBhY3R1YWxseSBhbiBfb2JqZWN0XywgYXNzdW1lIGl0J3Mgb3VyIG9wdGlvbnMgb2JqZWN0XHJcbiAgICBpZiAodHlwZW9mIHJlc3VsdEZ1bmMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGRpcmVjdGx5UGFzc2VkT3B0aW9ucyA9IHJlc3VsdEZ1bmNcclxuICAgICAgLy8gYW5kIHBvcCB0aGUgcmVhbCByZXN1bHQgZnVuYyBvZmZcclxuICAgICAgcmVzdWx0RnVuYyA9IGNyZWF0ZVNlbGVjdG9yQXJncy5wb3AoKSBhcyBDb21iaW5lcjxJbnB1dFNlbGVjdG9ycywgUmVzdWx0PlxyXG4gICAgfVxyXG5cclxuICAgIGFzc2VydElzRnVuY3Rpb24oXHJcbiAgICAgIHJlc3VsdEZ1bmMsXHJcbiAgICAgIGBjcmVhdGVTZWxlY3RvciBleHBlY3RzIGFuIG91dHB1dCBmdW5jdGlvbiBhZnRlciB0aGUgaW5wdXRzLCBidXQgcmVjZWl2ZWQ6IFske3R5cGVvZiByZXN1bHRGdW5jfV1gXHJcbiAgICApXHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNldCBvZiBvcHRpb25zIHdlJ3JlIHVzaW5nLiBQcmVmZXIgb3B0aW9ucyBwYXNzZWQgZGlyZWN0bHksXHJcbiAgICAvLyBidXQgZmFsbCBiYWNrIHRvIG9wdGlvbnMgZ2l2ZW4gdG8gYGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcmAuXHJcbiAgICBjb25zdCBjb21iaW5lZE9wdGlvbnMgPSB7XHJcbiAgICAgIC4uLmNyZWF0ZVNlbGVjdG9yQ3JlYXRvck9wdGlvbnMsXHJcbiAgICAgIC4uLmRpcmVjdGx5UGFzc2VkT3B0aW9uc1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgbWVtb2l6ZSxcclxuICAgICAgbWVtb2l6ZU9wdGlvbnMgPSBbXSxcclxuICAgICAgYXJnc01lbW9pemUgPSB3ZWFrTWFwTWVtb2l6ZSxcclxuICAgICAgYXJnc01lbW9pemVPcHRpb25zID0gW10sXHJcbiAgICAgIGRldk1vZGVDaGVja3MgPSB7fVxyXG4gICAgfSA9IGNvbWJpbmVkT3B0aW9uc1xyXG5cclxuICAgIC8vIFNpbXBsaWZ5aW5nIGFzc3VtcHRpb246IGl0J3MgdW5saWtlbHkgdGhhdCB0aGUgZmlyc3Qgb3B0aW9ucyBhcmcgb2YgdGhlIHByb3ZpZGVkIG1lbW9pemVyXHJcbiAgICAvLyBpcyBhbiBhcnJheS4gSW4gbW9zdCBsaWJzIEkndmUgbG9va2VkIGF0LCBpdCdzIGFuIGVxdWFsaXR5IGZ1bmN0aW9uIG9yIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAgLy8gQmFzZWQgb24gdGhhdCwgaWYgYG1lbW9pemVPcHRpb25zYCBfaXNfIGFuIGFycmF5LCB3ZSBhc3N1bWUgaXQncyBhIGZ1bGxcclxuICAgIC8vIHVzZXItcHJvdmlkZWQgYXJyYXkgb2Ygb3B0aW9ucy4gT3RoZXJ3aXNlLCBpdCBtdXN0IGJlIGp1c3QgdGhlIF9maXJzdF8gYXJnLCBhbmQgc29cclxuICAgIC8vIHdlIHdyYXAgaXQgaW4gYW4gYXJyYXkgc28gd2UgY2FuIGFwcGx5IGl0LlxyXG4gICAgY29uc3QgZmluYWxNZW1vaXplT3B0aW9ucyA9IGVuc3VyZUlzQXJyYXkobWVtb2l6ZU9wdGlvbnMpXHJcbiAgICBjb25zdCBmaW5hbEFyZ3NNZW1vaXplT3B0aW9ucyA9IGVuc3VyZUlzQXJyYXkoYXJnc01lbW9pemVPcHRpb25zKVxyXG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gZ2V0RGVwZW5kZW5jaWVzKGNyZWF0ZVNlbGVjdG9yQXJncykgYXMgSW5wdXRTZWxlY3RvcnNcclxuXHJcbiAgICBjb25zdCBtZW1vaXplZFJlc3VsdEZ1bmMgPSBtZW1vaXplKGZ1bmN0aW9uIHJlY29tcHV0YXRpb25XcmFwcGVyKCkge1xyXG4gICAgICByZWNvbXB1dGF0aW9ucysrXHJcbiAgICAgIC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXHJcbiAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgcmV0dXJuIChyZXN1bHRGdW5jIGFzIENvbWJpbmVyPElucHV0U2VsZWN0b3JzLCBSZXN1bHQ+KS5hcHBseShcclxuICAgICAgICBudWxsLFxyXG4gICAgICAgIGFyZ3VtZW50cyBhcyB1bmtub3duIGFzIFBhcmFtZXRlcnM8Q29tYmluZXI8SW5wdXRTZWxlY3RvcnMsIFJlc3VsdD4+XHJcbiAgICAgIClcclxuICAgIH0sIC4uLmZpbmFsTWVtb2l6ZU9wdGlvbnMpIGFzIENvbWJpbmVyPElucHV0U2VsZWN0b3JzLCBSZXN1bHQ+ICZcclxuICAgICAgRXh0cmFjdE1lbW9pemVyRmllbGRzPE92ZXJyaWRlTWVtb2l6ZUZ1bmN0aW9uPlxyXG5cclxuICAgIGxldCBmaXJzdFJ1biA9IHRydWVcclxuXHJcbiAgICAvLyBJZiBhIHNlbGVjdG9yIGlzIGNhbGxlZCB3aXRoIHRoZSBleGFjdCBzYW1lIGFyZ3VtZW50cyB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIG91ciBkZXBlbmRlbmNpZXMgYWdhaW4uXHJcbiAgICBjb25zdCBzZWxlY3RvciA9IGFyZ3NNZW1vaXplKGZ1bmN0aW9uIGRlcGVuZGVuY2llc0NoZWNrZXIoKSB7XHJcbiAgICAgIGRlcGVuZGVuY3lSZWNvbXB1dGF0aW9ucysrXHJcbiAgICAgIC8qKiBSZXR1cm4gdmFsdWVzIG9mIGlucHV0IHNlbGVjdG9ycyB3aGljaCB0aGUgYHJlc3VsdEZ1bmNgIHRha2VzIGFzIGFyZ3VtZW50cy4gKi9cclxuICAgICAgY29uc3QgaW5wdXRTZWxlY3RvclJlc3VsdHMgPSBjb2xsZWN0SW5wdXRTZWxlY3RvclJlc3VsdHMoXHJcbiAgICAgICAgZGVwZW5kZW5jaWVzLFxyXG4gICAgICAgIGFyZ3VtZW50c1xyXG4gICAgICApXHJcblxyXG4gICAgICAvLyBhcHBseSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgZm9yIHBlcmZvcm1hbmNlLlxyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgIGxhc3RSZXN1bHQgPSBtZW1vaXplZFJlc3VsdEZ1bmMuYXBwbHkobnVsbCwgaW5wdXRTZWxlY3RvclJlc3VsdHMpXHJcblxyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGNvbnN0IHsgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLCBpbnB1dFN0YWJpbGl0eUNoZWNrIH0gPVxyXG4gICAgICAgICAgZ2V0RGV2TW9kZUNoZWNrc0V4ZWN1dGlvbkluZm8oZmlyc3RSdW4sIGRldk1vZGVDaGVja3MpXHJcbiAgICAgICAgaWYgKGlkZW50aXR5RnVuY3Rpb25DaGVjay5zaG91bGRSdW4pIHtcclxuICAgICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjay5ydW4oXHJcbiAgICAgICAgICAgIHJlc3VsdEZ1bmMgYXMgQ29tYmluZXI8SW5wdXRTZWxlY3RvcnMsIFJlc3VsdD4sXHJcbiAgICAgICAgICAgIGlucHV0U2VsZWN0b3JSZXN1bHRzLFxyXG4gICAgICAgICAgICBsYXN0UmVzdWx0XHJcbiAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaW5wdXRTdGFiaWxpdHlDaGVjay5zaG91bGRSdW4pIHtcclxuICAgICAgICAgIC8vIG1ha2UgYSBzZWNvbmQgY29weSBvZiB0aGUgcGFyYW1zLCB0byBjaGVjayBpZiB3ZSBnb3QgdGhlIHNhbWUgcmVzdWx0c1xyXG4gICAgICAgICAgY29uc3QgaW5wdXRTZWxlY3RvclJlc3VsdHNDb3B5ID0gY29sbGVjdElucHV0U2VsZWN0b3JSZXN1bHRzKFxyXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMsXHJcbiAgICAgICAgICAgIGFyZ3VtZW50c1xyXG4gICAgICAgICAgKVxyXG5cclxuICAgICAgICAgIGlucHV0U3RhYmlsaXR5Q2hlY2sucnVuKFxyXG4gICAgICAgICAgICB7IGlucHV0U2VsZWN0b3JSZXN1bHRzLCBpbnB1dFNlbGVjdG9yUmVzdWx0c0NvcHkgfSxcclxuICAgICAgICAgICAgeyBtZW1vaXplLCBtZW1vaXplT3B0aW9uczogZmluYWxNZW1vaXplT3B0aW9ucyB9LFxyXG4gICAgICAgICAgICBhcmd1bWVudHNcclxuICAgICAgICAgIClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChmaXJzdFJ1bikgZmlyc3RSdW4gPSBmYWxzZVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbGFzdFJlc3VsdFxyXG4gICAgfSwgLi4uZmluYWxBcmdzTWVtb2l6ZU9wdGlvbnMpIGFzIHVua25vd24gYXMgU2VsZWN0b3I8XHJcbiAgICAgIEdldFN0YXRlRnJvbVNlbGVjdG9yczxJbnB1dFNlbGVjdG9ycz4sXHJcbiAgICAgIFJlc3VsdCxcclxuICAgICAgR2V0UGFyYW1zRnJvbVNlbGVjdG9yczxJbnB1dFNlbGVjdG9ycz5cclxuICAgID4gJlxyXG4gICAgICBFeHRyYWN0TWVtb2l6ZXJGaWVsZHM8T3ZlcnJpZGVBcmdzTWVtb2l6ZUZ1bmN0aW9uPlxyXG5cclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHNlbGVjdG9yLCB7XHJcbiAgICAgIHJlc3VsdEZ1bmMsXHJcbiAgICAgIG1lbW9pemVkUmVzdWx0RnVuYyxcclxuICAgICAgZGVwZW5kZW5jaWVzLFxyXG4gICAgICBkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnM6ICgpID0+IGRlcGVuZGVuY3lSZWNvbXB1dGF0aW9ucyxcclxuICAgICAgcmVzZXREZXBlbmRlbmN5UmVjb21wdXRhdGlvbnM6ICgpID0+IHtcclxuICAgICAgICBkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnMgPSAwXHJcbiAgICAgIH0sXHJcbiAgICAgIGxhc3RSZXN1bHQ6ICgpID0+IGxhc3RSZXN1bHQsXHJcbiAgICAgIHJlY29tcHV0YXRpb25zOiAoKSA9PiByZWNvbXB1dGF0aW9ucyxcclxuICAgICAgcmVzZXRSZWNvbXB1dGF0aW9uczogKCkgPT4ge1xyXG4gICAgICAgIHJlY29tcHV0YXRpb25zID0gMFxyXG4gICAgICB9LFxyXG4gICAgICBtZW1vaXplLFxyXG4gICAgICBhcmdzTWVtb2l6ZVxyXG4gICAgfSkgYXMgT3V0cHV0U2VsZWN0b3I8XHJcbiAgICAgIElucHV0U2VsZWN0b3JzLFxyXG4gICAgICBSZXN1bHQsXHJcbiAgICAgIE92ZXJyaWRlTWVtb2l6ZUZ1bmN0aW9uLFxyXG4gICAgICBPdmVycmlkZUFyZ3NNZW1vaXplRnVuY3Rpb25cclxuICAgID5cclxuICB9XHJcblxyXG4gIE9iamVjdC5hc3NpZ24oY3JlYXRlU2VsZWN0b3IsIHtcclxuICAgIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlU2VsZWN0b3JcclxuICB9KVxyXG5cclxuICByZXR1cm4gY3JlYXRlU2VsZWN0b3IgYXMgQ3JlYXRlU2VsZWN0b3JGdW5jdGlvbjxcclxuICAgIE1lbW9pemVGdW5jdGlvbixcclxuICAgIEFyZ3NNZW1vaXplRnVuY3Rpb25cclxuICA+XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBY2NlcHRzIG9uZSBvciBtb3JlIFwiaW5wdXQgc2VsZWN0b3JzXCIgKGVpdGhlciBhcyBzZXBhcmF0ZSBhcmd1bWVudHMgb3IgYSBzaW5nbGUgYXJyYXkpLFxyXG4gKiBhIHNpbmdsZSBcInJlc3VsdCBmdW5jdGlvblwiIC8gXCJjb21iaW5lclwiLCBhbmQgYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QsIGFuZFxyXG4gKiBnZW5lcmF0ZXMgYSBtZW1vaXplZCBzZWxlY3RvciBmdW5jdGlvbi5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZXNlbGVjdC5qcy5vcmcvYXBpL2NyZWF0ZVNlbGVjdG9yIGBjcmVhdGVTZWxlY3RvcmB9XHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVTZWxlY3RvciA9XHJcbiAgLyogI19fUFVSRV9fICovIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcih3ZWFrTWFwTWVtb2l6ZSlcclxuIiwiaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgfSBmcm9tICcuL2NyZWF0ZVNlbGVjdG9yQ3JlYXRvcidcclxuXHJcbmltcG9ydCB0eXBlIHsgQ3JlYXRlU2VsZWN0b3JGdW5jdGlvbiB9IGZyb20gJy4vY3JlYXRlU2VsZWN0b3JDcmVhdG9yJ1xyXG5pbXBvcnQgdHlwZSB7XHJcbiAgSW50ZXJydXB0UmVjdXJzaW9uLFxyXG4gIE9iamVjdFZhbHVlc1RvVHVwbGUsXHJcbiAgT3V0cHV0U2VsZWN0b3IsXHJcbiAgU2VsZWN0b3IsXHJcbiAgU2ltcGxpZnksXHJcbiAgVW5rbm93bk1lbW9pemVyXHJcbn0gZnJvbSAnLi90eXBlcydcclxuaW1wb3J0IHsgYXNzZXJ0SXNPYmplY3QgfSBmcm9tICcuL3V0aWxzJ1xyXG5pbXBvcnQgdHlwZSB7IHdlYWtNYXBNZW1vaXplIH0gZnJvbSAnLi93ZWFrTWFwTWVtb2l6ZSdcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgbWFwcGluZyBvZiBzZWxlY3RvcnMgdG8gdGhlaXIgcmV0dXJuIHR5cGVzLlxyXG4gKlxyXG4gKiBAdGVtcGxhdGUgVE9iamVjdCAtIEFuIG9iamVjdCB0eXBlIHdoZXJlIGVhY2ggcHJvcGVydHkgaXMgYSBzZWxlY3RvciBmdW5jdGlvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgU2VsZWN0b3JSZXN1bHRzTWFwPFRPYmplY3QgZXh0ZW5kcyBTZWxlY3RvcnNPYmplY3Q+ID0ge1xyXG4gIFtLZXkgaW4ga2V5b2YgVE9iamVjdF06IFJldHVyblR5cGU8VE9iamVjdFtLZXldPlxyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIG1hcHBpbmcgb2Ygc2VsZWN0b3JzIGZvciBlYWNoIGtleSBpbiBhIGdpdmVuIHJvb3Qgc3RhdGUuXHJcbiAqXHJcbiAqIFRoaXMgdHlwZSBpcyBhIHV0aWxpdHkgdGhhdCB0YWtlcyBhIHJvb3Qgc3RhdGUgb2JqZWN0IHR5cGUgYW5kXHJcbiAqIGdlbmVyYXRlcyBhIGNvcnJlc3BvbmRpbmcgc2V0IG9mIHNlbGVjdG9ycy4gRWFjaCBzZWxlY3RvciBpcyBhc3NvY2lhdGVkXHJcbiAqIHdpdGggYSBrZXkgaW4gdGhlIHJvb3Qgc3RhdGUsIGFsbG93aW5nIGZvciB0aGUgc2VsZWN0aW9uXHJcbiAqIG9mIHNwZWNpZmljIHBhcnRzIG9mIHRoZSBzdGF0ZS5cclxuICpcclxuICogQHRlbXBsYXRlIFJvb3RTdGF0ZSAtIFRoZSB0eXBlIG9mIHRoZSByb290IHN0YXRlIG9iamVjdC5cclxuICpcclxuICogQHNpbmNlIDUuMC4wXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCB0eXBlIFJvb3RTdGF0ZVNlbGVjdG9yczxSb290U3RhdGUgPSBhbnk+ID0ge1xyXG4gIFtLZXkgaW4ga2V5b2YgUm9vdFN0YXRlXTogU2VsZWN0b3I8Um9vdFN0YXRlLCBSb290U3RhdGVbS2V5XSwgW10+XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIHtAbGlua2NvZGUgU3RydWN0dXJlZFNlbGVjdG9yQ3JlYXRvci53aXRoVHlwZXMgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yLndpdGhUeXBlczxSb290U3RhdGU+KCl9IGluc3RlYWQuIFRoaXMgdHlwZSB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cclxuICogQHRlbXBsYXRlIFJvb3RTdGF0ZSAtIFRoZSB0eXBlIG9mIHRoZSByb290IHN0YXRlIG9iamVjdC5cclxuICpcclxuICogQHNpbmNlIDUuMC4wXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCB0eXBlIFR5cGVkU3RydWN0dXJlZFNlbGVjdG9yQ3JlYXRvcjxSb290U3RhdGUgPSBhbnk+ID1cclxuICAvKipcclxuICAgKiBBIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRoYXQgc2ltcGxpZmllcyByZXR1cm5pbmcgYW4gb2JqZWN0XHJcbiAgICogbWFkZSB1cCBvZiBzZWxlY3RvciByZXN1bHRzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGlucHV0U2VsZWN0b3JzT2JqZWN0IC0gQSBrZXkgdmFsdWUgcGFpciBjb25zaXN0aW5nIG9mIGlucHV0IHNlbGVjdG9ycy5cclxuICAgKiBAcGFyYW0gc2VsZWN0b3JDcmVhdG9yIC0gQSBjdXN0b20gc2VsZWN0b3IgY3JlYXRvciBmdW5jdGlvbi4gSXQgZGVmYXVsdHMgdG8gYGNyZWF0ZVNlbGVjdG9yYC5cclxuICAgKiBAcmV0dXJucyBBIG1lbW9pemVkIHN0cnVjdHVyZWQgc2VsZWN0b3IuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIDxjYXB0aW9uPk1vZGVybiBVc2UgQ2FzZTwvY2FwdGlvbj5cclxuICAgKiBgYGB0c1xyXG4gICAqIGltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgfSBmcm9tICdyZXNlbGVjdCdcclxuICAgKlxyXG4gICAqIGludGVyZmFjZSBSb290U3RhdGUge1xyXG4gICAqICAgdG9kb3M6IHtcclxuICAgKiAgICAgaWQ6IG51bWJlclxyXG4gICAqICAgICBjb21wbGV0ZWQ6IGJvb2xlYW5cclxuICAgKiAgICAgdGl0bGU6IHN0cmluZ1xyXG4gICAqICAgICBkZXNjcmlwdGlvbjogc3RyaW5nXHJcbiAgICogICB9W11cclxuICAgKiAgIGFsZXJ0czogeyBpZDogbnVtYmVyOyByZWFkOiBib29sZWFuIH1bXVxyXG4gICAqIH1cclxuICAgKlxyXG4gICAqIC8vIFRoaXM6XHJcbiAgICogY29uc3Qgc3RydWN0dXJlZFNlbGVjdG9yID0gY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yKFxyXG4gICAqICAge1xyXG4gICAqICAgICB0b2RvczogKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLnRvZG9zLFxyXG4gICAqICAgICBhbGVydHM6IChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZS5hbGVydHMsXHJcbiAgICogICAgIHRvZG9CeUlkOiAoc3RhdGU6IFJvb3RTdGF0ZSwgaWQ6IG51bWJlcikgPT4gc3RhdGUudG9kb3NbaWRdXHJcbiAgICogICB9LFxyXG4gICAqICAgY3JlYXRlU2VsZWN0b3JcclxuICAgKiApXHJcbiAgICpcclxuICAgKiAvLyBJcyBlc3NlbnRpYWxseSB0aGUgc2FtZSBhcyB0aGlzOlxyXG4gICAqIGNvbnN0IHNlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3IoXHJcbiAgICogICBbXHJcbiAgICogICAgIChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZS50b2RvcyxcclxuICAgKiAgICAgKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLmFsZXJ0cyxcclxuICAgKiAgICAgKHN0YXRlOiBSb290U3RhdGUsIGlkOiBudW1iZXIpID0+IHN0YXRlLnRvZG9zW2lkXVxyXG4gICAqICAgXSxcclxuICAgKiAgICh0b2RvcywgYWxlcnRzLCB0b2RvQnlJZCkgPT4ge1xyXG4gICAqICAgICByZXR1cm4ge1xyXG4gICAqICAgICAgIHRvZG9zLFxyXG4gICAqICAgICAgIGFsZXJ0cyxcclxuICAgKiAgICAgICB0b2RvQnlJZFxyXG4gICAqICAgICB9XHJcbiAgICogICB9XHJcbiAgICogKVxyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiA8Y2FwdGlvbj5JbiB5b3VyIGNvbXBvbmVudDo8L2NhcHRpb24+XHJcbiAgICogYGBgdHN4XHJcbiAgICogaW1wb3J0IHR5cGUgeyBSb290U3RhdGUgfSBmcm9tICdjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IvbW9kZXJuVXNlQ2FzZSdcclxuICAgKiBpbXBvcnQgeyBzdHJ1Y3R1cmVkU2VsZWN0b3IgfSBmcm9tICdjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IvbW9kZXJuVXNlQ2FzZSdcclxuICAgKiBpbXBvcnQgdHlwZSB7IEZDIH0gZnJvbSAncmVhY3QnXHJcbiAgICogaW1wb3J0IHsgdXNlU2VsZWN0b3IgfSBmcm9tICdyZWFjdC1yZWR1eCdcclxuICAgKlxyXG4gICAqIGludGVyZmFjZSBQcm9wcyB7XHJcbiAgICogICBpZDogbnVtYmVyXHJcbiAgICogfVxyXG4gICAqXHJcbiAgICogY29uc3QgTXlDb21wb25lbnQ6IEZDPFByb3BzPiA9ICh7IGlkIH0pID0+IHtcclxuICAgKiAgIGNvbnN0IHsgdG9kb3MsIGFsZXJ0cywgdG9kb0J5SWQgfSA9IHVzZVNlbGVjdG9yKChzdGF0ZTogUm9vdFN0YXRlKSA9PlxyXG4gICAqICAgICBzdHJ1Y3R1cmVkU2VsZWN0b3Ioc3RhdGUsIGlkKVxyXG4gICAqICAgKVxyXG4gICAqXHJcbiAgICogICByZXR1cm4gKFxyXG4gICAqICAgICA8ZGl2PlxyXG4gICAqICAgICAgIE5leHQgdG8gZG8gaXM6XHJcbiAgICogICAgICAgPGgyPnt0b2RvQnlJZC50aXRsZX08L2gyPlxyXG4gICAqICAgICAgIDxwPkRlc2NyaXB0aW9uOiB7dG9kb0J5SWQuZGVzY3JpcHRpb259PC9wPlxyXG4gICAqICAgICAgIDx1bD5cclxuICAgKiAgICAgICAgIDxoMz5BbGwgb3RoZXIgdG8gZG9zOjwvaDM+XHJcbiAgICogICAgICAgICB7dG9kb3MubWFwKHRvZG8gPT4gKFxyXG4gICAqICAgICAgICAgICA8bGkga2V5PXt0b2RvLmlkfT57dG9kby50aXRsZX08L2xpPlxyXG4gICAqICAgICAgICAgKSl9XHJcbiAgICogICAgICAgPC91bD5cclxuICAgKiAgICAgPC9kaXY+XHJcbiAgICogICApXHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiA8Y2FwdGlvbj5TaW1wbGUgVXNlIENhc2U8L2NhcHRpb24+XHJcbiAgICogYGBgdHNcclxuICAgKiBjb25zdCBzZWxlY3RBID0gc3RhdGUgPT4gc3RhdGUuYVxyXG4gICAqIGNvbnN0IHNlbGVjdEIgPSBzdGF0ZSA9PiBzdGF0ZS5iXHJcbiAgICpcclxuICAgKiAvLyBUaGUgcmVzdWx0IGZ1bmN0aW9uIGluIHRoZSBmb2xsb3dpbmcgc2VsZWN0b3JcclxuICAgKiAvLyBpcyBzaW1wbHkgYnVpbGRpbmcgYW4gb2JqZWN0IGZyb20gdGhlIGlucHV0IHNlbGVjdG9yc1xyXG4gICAqIGNvbnN0IHN0cnVjdHVyZWRTZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yKHNlbGVjdEEsIHNlbGVjdEIsIChhLCBiKSA9PiAoe1xyXG4gICAqICAgYSxcclxuICAgKiAgIGJcclxuICAgKiB9KSlcclxuICAgKlxyXG4gICAqIGNvbnN0IHJlc3VsdCA9IHN0cnVjdHVyZWRTZWxlY3Rvcih7IGE6IDEsIGI6IDIgfSkgLy8gd2lsbCBwcm9kdWNlIHsgeDogMSwgeTogMiB9XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAdGVtcGxhdGUgSW5wdXRTZWxlY3RvcnNPYmplY3QgLSBUaGUgc2hhcGUgb2YgdGhlIGlucHV0IHNlbGVjdG9ycyBvYmplY3QuXHJcbiAgICogQHRlbXBsYXRlIE1lbW9pemVGdW5jdGlvbiAtIFRoZSB0eXBlIG9mIHRoZSBtZW1vaXplIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBjcmVhdGUgdGhlIHN0cnVjdHVyZWQgc2VsZWN0b3IuIEl0IGRlZmF1bHRzIHRvIGB3ZWFrTWFwTWVtb2l6ZWAuXHJcbiAgICogQHRlbXBsYXRlIEFyZ3NNZW1vaXplRnVuY3Rpb24gLSBUaGUgdHlwZSBvZiB0aGUgb2YgdGhlIG1lbW9pemUgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIG1lbW9pemUgdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgZ2VuZXJhdGVkIHN0cnVjdHVyZWQgc2VsZWN0b3IuIEl0IGRlZmF1bHRzIHRvIGB3ZWFrTWFwTWVtb2l6ZWAuXHJcbiAgICpcclxuICAgKiBAc2VlIHtAbGluayBodHRwczovL3Jlc2VsZWN0LmpzLm9yZy9hcGkvY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIGBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3JgfVxyXG4gICAqL1xyXG4gIDxcclxuICAgIElucHV0U2VsZWN0b3JzT2JqZWN0IGV4dGVuZHMgUm9vdFN0YXRlU2VsZWN0b3JzPFJvb3RTdGF0ZT4gPSBSb290U3RhdGVTZWxlY3RvcnM8Um9vdFN0YXRlPixcclxuICAgIE1lbW9pemVGdW5jdGlvbiBleHRlbmRzIFVua25vd25NZW1vaXplciA9IHR5cGVvZiB3ZWFrTWFwTWVtb2l6ZSxcclxuICAgIEFyZ3NNZW1vaXplRnVuY3Rpb24gZXh0ZW5kcyBVbmtub3duTWVtb2l6ZXIgPSB0eXBlb2Ygd2Vha01hcE1lbW9pemVcclxuICA+KFxyXG4gICAgaW5wdXRTZWxlY3RvcnNPYmplY3Q6IElucHV0U2VsZWN0b3JzT2JqZWN0LFxyXG4gICAgc2VsZWN0b3JDcmVhdG9yPzogQ3JlYXRlU2VsZWN0b3JGdW5jdGlvbjxcclxuICAgICAgTWVtb2l6ZUZ1bmN0aW9uLFxyXG4gICAgICBBcmdzTWVtb2l6ZUZ1bmN0aW9uXHJcbiAgICA+XHJcbiAgKSA9PiBPdXRwdXRTZWxlY3RvcjxcclxuICAgIE9iamVjdFZhbHVlc1RvVHVwbGU8SW5wdXRTZWxlY3RvcnNPYmplY3Q+LFxyXG4gICAgU2ltcGxpZnk8U2VsZWN0b3JSZXN1bHRzTWFwPElucHV0U2VsZWN0b3JzT2JqZWN0Pj4sXHJcbiAgICBNZW1vaXplRnVuY3Rpb24sXHJcbiAgICBBcmdzTWVtb2l6ZUZ1bmN0aW9uXHJcbiAgPiAmXHJcbiAgICBJbnRlcnJ1cHRSZWN1cnNpb25cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIG9iamVjdCB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIGEgc2VsZWN0b3IgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEB0ZW1wbGF0ZSBTdGF0ZVR5cGUgLSBUaGUgdHlwZSBvZiBzdGF0ZSB0aGF0IGFsbCB0aGUgc2VsZWN0b3JzIG9wZXJhdGUgb24uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCB0eXBlIFNlbGVjdG9yc09iamVjdDxTdGF0ZVR5cGUgPSBhbnk+ID0gUmVjb3JkPFxyXG4gIHN0cmluZyxcclxuICBTZWxlY3RvcjxTdGF0ZVR5cGU+XHJcbj5cclxuXHJcbi8qKlxyXG4gKiBJdCBwcm92aWRlcyBhIHdheSB0byBjcmVhdGUgc3RydWN0dXJlZCBzZWxlY3RvcnMuXHJcbiAqIFRoZSBzdHJ1Y3R1cmVkIHNlbGVjdG9yIGNhbiB0YWtlIG11bHRpcGxlIGlucHV0IHNlbGVjdG9yc1xyXG4gKiBhbmQgbWFwIHRoZWlyIG91dHB1dCB0byBhbiBvYmplY3Qgd2l0aCBzcGVjaWZpYyBrZXlzLlxyXG4gKlxyXG4gKiBAdGVtcGxhdGUgU3RhdGVUeXBlIC0gVGhlIHR5cGUgb2Ygc3RhdGUgdGhhdCB0aGUgc3RydWN0dXJlZCBzZWxlY3RvcnMgY3JlYXRlZCB3aXRoIHRoaXMgc3RydWN0dXJlZCBzZWxlY3RvciBjcmVhdG9yIHdpbGwgb3BlcmF0ZSBvbi5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yZXNlbGVjdC5qcy5vcmcvYXBpL2NyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciBgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yYH1cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBTdHJ1Y3R1cmVkU2VsZWN0b3JDcmVhdG9yPFN0YXRlVHlwZSA9IGFueT4ge1xyXG4gIC8qKlxyXG4gICAqIEEgY29udmVuaWVuY2UgZnVuY3Rpb24gdGhhdCBzaW1wbGlmaWVzIHJldHVybmluZyBhbiBvYmplY3RcclxuICAgKiBtYWRlIHVwIG9mIHNlbGVjdG9yIHJlc3VsdHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaW5wdXRTZWxlY3RvcnNPYmplY3QgLSBBIGtleSB2YWx1ZSBwYWlyIGNvbnNpc3Rpbmcgb2YgaW5wdXQgc2VsZWN0b3JzLlxyXG4gICAqIEBwYXJhbSBzZWxlY3RvckNyZWF0b3IgLSBBIGN1c3RvbSBzZWxlY3RvciBjcmVhdG9yIGZ1bmN0aW9uLiBJdCBkZWZhdWx0cyB0byBgY3JlYXRlU2VsZWN0b3JgLlxyXG4gICAqIEByZXR1cm5zIEEgbWVtb2l6ZWQgc3RydWN0dXJlZCBzZWxlY3Rvci5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogPGNhcHRpb24+TW9kZXJuIFVzZSBDYXNlPC9jYXB0aW9uPlxyXG4gICAqIGBgYHRzXHJcbiAgICogaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IsIGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciB9IGZyb20gJ3Jlc2VsZWN0J1xyXG4gICAqXHJcbiAgICogaW50ZXJmYWNlIFJvb3RTdGF0ZSB7XHJcbiAgICogICB0b2Rvczoge1xyXG4gICAqICAgICBpZDogbnVtYmVyXHJcbiAgICogICAgIGNvbXBsZXRlZDogYm9vbGVhblxyXG4gICAqICAgICB0aXRsZTogc3RyaW5nXHJcbiAgICogICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdcclxuICAgKiAgIH1bXVxyXG4gICAqICAgYWxlcnRzOiB7IGlkOiBudW1iZXI7IHJlYWQ6IGJvb2xlYW4gfVtdXHJcbiAgICogfVxyXG4gICAqXHJcbiAgICogLy8gVGhpczpcclxuICAgKiBjb25zdCBzdHJ1Y3R1cmVkU2VsZWN0b3IgPSBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IoXHJcbiAgICogICB7XHJcbiAgICogICAgIHRvZG9zOiAoc3RhdGU6IFJvb3RTdGF0ZSkgPT4gc3RhdGUudG9kb3MsXHJcbiAgICogICAgIGFsZXJ0czogKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLmFsZXJ0cyxcclxuICAgKiAgICAgdG9kb0J5SWQ6IChzdGF0ZTogUm9vdFN0YXRlLCBpZDogbnVtYmVyKSA9PiBzdGF0ZS50b2Rvc1tpZF1cclxuICAgKiAgIH0sXHJcbiAgICogICBjcmVhdGVTZWxlY3RvclxyXG4gICAqIClcclxuICAgKlxyXG4gICAqIC8vIElzIGVzc2VudGlhbGx5IHRoZSBzYW1lIGFzIHRoaXM6XHJcbiAgICogY29uc3Qgc2VsZWN0b3IgPSBjcmVhdGVTZWxlY3RvcihcclxuICAgKiAgIFtcclxuICAgKiAgICAgKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLnRvZG9zLFxyXG4gICAqICAgICAoc3RhdGU6IFJvb3RTdGF0ZSkgPT4gc3RhdGUuYWxlcnRzLFxyXG4gICAqICAgICAoc3RhdGU6IFJvb3RTdGF0ZSwgaWQ6IG51bWJlcikgPT4gc3RhdGUudG9kb3NbaWRdXHJcbiAgICogICBdLFxyXG4gICAqICAgKHRvZG9zLCBhbGVydHMsIHRvZG9CeUlkKSA9PiB7XHJcbiAgICogICAgIHJldHVybiB7XHJcbiAgICogICAgICAgdG9kb3MsXHJcbiAgICogICAgICAgYWxlcnRzLFxyXG4gICAqICAgICAgIHRvZG9CeUlkXHJcbiAgICogICAgIH1cclxuICAgKiAgIH1cclxuICAgKiApXHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIDxjYXB0aW9uPkluIHlvdXIgY29tcG9uZW50OjwvY2FwdGlvbj5cclxuICAgKiBgYGB0c3hcclxuICAgKiBpbXBvcnQgdHlwZSB7IFJvb3RTdGF0ZSB9IGZyb20gJ2NyZWF0ZVN0cnVjdHVyZWRTZWxlY3Rvci9tb2Rlcm5Vc2VDYXNlJ1xyXG4gICAqIGltcG9ydCB7IHN0cnVjdHVyZWRTZWxlY3RvciB9IGZyb20gJ2NyZWF0ZVN0cnVjdHVyZWRTZWxlY3Rvci9tb2Rlcm5Vc2VDYXNlJ1xyXG4gICAqIGltcG9ydCB0eXBlIHsgRkMgfSBmcm9tICdyZWFjdCdcclxuICAgKiBpbXBvcnQgeyB1c2VTZWxlY3RvciB9IGZyb20gJ3JlYWN0LXJlZHV4J1xyXG4gICAqXHJcbiAgICogaW50ZXJmYWNlIFByb3BzIHtcclxuICAgKiAgIGlkOiBudW1iZXJcclxuICAgKiB9XHJcbiAgICpcclxuICAgKiBjb25zdCBNeUNvbXBvbmVudDogRkM8UHJvcHM+ID0gKHsgaWQgfSkgPT4ge1xyXG4gICAqICAgY29uc3QgeyB0b2RvcywgYWxlcnRzLCB0b2RvQnlJZCB9ID0gdXNlU2VsZWN0b3IoKHN0YXRlOiBSb290U3RhdGUpID0+XHJcbiAgICogICAgIHN0cnVjdHVyZWRTZWxlY3RvcihzdGF0ZSwgaWQpXHJcbiAgICogICApXHJcbiAgICpcclxuICAgKiAgIHJldHVybiAoXHJcbiAgICogICAgIDxkaXY+XHJcbiAgICogICAgICAgTmV4dCB0byBkbyBpczpcclxuICAgKiAgICAgICA8aDI+e3RvZG9CeUlkLnRpdGxlfTwvaDI+XHJcbiAgICogICAgICAgPHA+RGVzY3JpcHRpb246IHt0b2RvQnlJZC5kZXNjcmlwdGlvbn08L3A+XHJcbiAgICogICAgICAgPHVsPlxyXG4gICAqICAgICAgICAgPGgzPkFsbCBvdGhlciB0byBkb3M6PC9oMz5cclxuICAgKiAgICAgICAgIHt0b2Rvcy5tYXAodG9kbyA9PiAoXHJcbiAgICogICAgICAgICAgIDxsaSBrZXk9e3RvZG8uaWR9Pnt0b2RvLnRpdGxlfTwvbGk+XHJcbiAgICogICAgICAgICApKX1cclxuICAgKiAgICAgICA8L3VsPlxyXG4gICAqICAgICA8L2Rpdj5cclxuICAgKiAgIClcclxuICAgKiB9XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIDxjYXB0aW9uPlNpbXBsZSBVc2UgQ2FzZTwvY2FwdGlvbj5cclxuICAgKiBgYGB0c1xyXG4gICAqIGNvbnN0IHNlbGVjdEEgPSBzdGF0ZSA9PiBzdGF0ZS5hXHJcbiAgICogY29uc3Qgc2VsZWN0QiA9IHN0YXRlID0+IHN0YXRlLmJcclxuICAgKlxyXG4gICAqIC8vIFRoZSByZXN1bHQgZnVuY3Rpb24gaW4gdGhlIGZvbGxvd2luZyBzZWxlY3RvclxyXG4gICAqIC8vIGlzIHNpbXBseSBidWlsZGluZyBhbiBvYmplY3QgZnJvbSB0aGUgaW5wdXQgc2VsZWN0b3JzXHJcbiAgICogY29uc3Qgc3RydWN0dXJlZFNlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3Ioc2VsZWN0QSwgc2VsZWN0QiwgKGEsIGIpID0+ICh7XHJcbiAgICogICBhLFxyXG4gICAqICAgYlxyXG4gICAqIH0pKVxyXG4gICAqXHJcbiAgICogY29uc3QgcmVzdWx0ID0gc3RydWN0dXJlZFNlbGVjdG9yKHsgYTogMSwgYjogMiB9KSAvLyB3aWxsIHByb2R1Y2UgeyB4OiAxLCB5OiAyIH1cclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEB0ZW1wbGF0ZSBJbnB1dFNlbGVjdG9yc09iamVjdCAtIFRoZSBzaGFwZSBvZiB0aGUgaW5wdXQgc2VsZWN0b3JzIG9iamVjdC5cclxuICAgKiBAdGVtcGxhdGUgTWVtb2l6ZUZ1bmN0aW9uIC0gVGhlIHR5cGUgb2YgdGhlIG1lbW9pemUgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RydWN0dXJlZCBzZWxlY3Rvci4gSXQgZGVmYXVsdHMgdG8gYHdlYWtNYXBNZW1vaXplYC5cclxuICAgKiBAdGVtcGxhdGUgQXJnc01lbW9pemVGdW5jdGlvbiAtIFRoZSB0eXBlIG9mIHRoZSBvZiB0aGUgbWVtb2l6ZSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gbWVtb2l6ZSB0aGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBnZW5lcmF0ZWQgc3RydWN0dXJlZCBzZWxlY3Rvci4gSXQgZGVmYXVsdHMgdG8gYHdlYWtNYXBNZW1vaXplYC5cclxuICAgKlxyXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVzZWxlY3QuanMub3JnL2FwaS9jcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgYGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvcmB9XHJcbiAgICovXHJcbiAgPFxyXG4gICAgSW5wdXRTZWxlY3RvcnNPYmplY3QgZXh0ZW5kcyBTZWxlY3RvcnNPYmplY3Q8U3RhdGVUeXBlPixcclxuICAgIE1lbW9pemVGdW5jdGlvbiBleHRlbmRzIFVua25vd25NZW1vaXplciA9IHR5cGVvZiB3ZWFrTWFwTWVtb2l6ZSxcclxuICAgIEFyZ3NNZW1vaXplRnVuY3Rpb24gZXh0ZW5kcyBVbmtub3duTWVtb2l6ZXIgPSB0eXBlb2Ygd2Vha01hcE1lbW9pemVcclxuICA+KFxyXG4gICAgaW5wdXRTZWxlY3RvcnNPYmplY3Q6IElucHV0U2VsZWN0b3JzT2JqZWN0LFxyXG4gICAgc2VsZWN0b3JDcmVhdG9yPzogQ3JlYXRlU2VsZWN0b3JGdW5jdGlvbjxcclxuICAgICAgTWVtb2l6ZUZ1bmN0aW9uLFxyXG4gICAgICBBcmdzTWVtb2l6ZUZ1bmN0aW9uXHJcbiAgICA+XHJcbiAgKTogT3V0cHV0U2VsZWN0b3I8XHJcbiAgICBPYmplY3RWYWx1ZXNUb1R1cGxlPElucHV0U2VsZWN0b3JzT2JqZWN0PixcclxuICAgIFNpbXBsaWZ5PFNlbGVjdG9yUmVzdWx0c01hcDxJbnB1dFNlbGVjdG9yc09iamVjdD4+LFxyXG4gICAgTWVtb2l6ZUZ1bmN0aW9uLFxyXG4gICAgQXJnc01lbW9pemVGdW5jdGlvblxyXG4gID4gJlxyXG4gICAgSW50ZXJydXB0UmVjdXJzaW9uXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBcInByZS10eXBlZFwiIHZlcnNpb24gb2ZcclxuICAgKiB7QGxpbmtjb2RlIGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3J9XHJcbiAgICogd2hlcmUgdGhlIGBzdGF0ZWAgdHlwZSBpcyBwcmVkZWZpbmVkLlxyXG4gICAqXHJcbiAgICogVGhpcyBhbGxvd3MgeW91IHRvIHNldCB0aGUgYHN0YXRlYCB0eXBlIG9uY2UsIGVsaW1pbmF0aW5nIHRoZSBuZWVkIHRvXHJcbiAgICogc3BlY2lmeSBpdCB3aXRoIGV2ZXJ5XHJcbiAgICoge0BsaW5rY29kZSBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yfSBjYWxsLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgQSBwcmUtdHlwZWQgYGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvcmAgd2l0aCB0aGUgc3RhdGUgdHlwZSBhbHJlYWR5IGRlZmluZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHRzXHJcbiAgICogaW1wb3J0IHsgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnXHJcbiAgICpcclxuICAgKiBleHBvcnQgaW50ZXJmYWNlIFJvb3RTdGF0ZSB7XHJcbiAgICogICB0b2RvczogeyBpZDogbnVtYmVyOyBjb21wbGV0ZWQ6IGJvb2xlYW4gfVtdXHJcbiAgICogICBhbGVydHM6IHsgaWQ6IG51bWJlcjsgcmVhZDogYm9vbGVhbiB9W11cclxuICAgKiB9XHJcbiAgICpcclxuICAgKiBleHBvcnQgY29uc3QgY3JlYXRlU3RydWN0dXJlZEFwcFNlbGVjdG9yID1cclxuICAgKiAgIGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3Rvci53aXRoVHlwZXM8Um9vdFN0YXRlPigpXHJcbiAgICpcclxuICAgKiBjb25zdCBzdHJ1Y3R1cmVkQXBwU2VsZWN0b3IgPSBjcmVhdGVTdHJ1Y3R1cmVkQXBwU2VsZWN0b3Ioe1xyXG4gICAqICAgLy8gVHlwZSBvZiBgc3RhdGVgIGlzIHNldCB0byBgUm9vdFN0YXRlYCwgbm8gbmVlZCB0byBtYW51YWxseSBzZXQgdGhlIHR5cGVcclxuICAgKiAgIHRvZG9zOiBzdGF0ZSA9PiBzdGF0ZS50b2RvcyxcclxuICAgKiAgIGFsZXJ0czogc3RhdGUgPT4gc3RhdGUuYWxlcnRzLFxyXG4gICAqICAgdG9kb0J5SWQ6IChzdGF0ZSwgaWQ6IG51bWJlcikgPT4gc3RhdGUudG9kb3NbaWRdXHJcbiAgICogfSlcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqIEB0ZW1wbGF0ZSBPdmVycmlkZVN0YXRlVHlwZSAtIFRoZSBzcGVjaWZpYyB0eXBlIG9mIHN0YXRlIHVzZWQgYnkgYWxsIHN0cnVjdHVyZWQgc2VsZWN0b3JzIGNyZWF0ZWQgd2l0aCB0aGlzIHN0cnVjdHVyZWQgc2VsZWN0b3IgY3JlYXRvci5cclxuICAgKlxyXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcmVzZWxlY3QuanMub3JnL2FwaS9jcmVhdGVzdHJ1Y3R1cmVkc2VsZWN0b3IjZGVmaW5pbmctYS1wcmUtdHlwZWQtY3JlYXRlc3RydWN0dXJlZHNlbGVjdG9yIGBjcmVhdGVTZWxlY3Rvci53aXRoVHlwZXNgfVxyXG4gICAqXHJcbiAgICogQHNpbmNlIDUuMS4wXHJcbiAgICovXHJcbiAgd2l0aFR5cGVzOiA8XHJcbiAgICBPdmVycmlkZVN0YXRlVHlwZSBleHRlbmRzIFN0YXRlVHlwZVxyXG4gID4oKSA9PiBTdHJ1Y3R1cmVkU2VsZWN0b3JDcmVhdG9yPE92ZXJyaWRlU3RhdGVUeXBlPlxyXG59XHJcblxyXG4vKipcclxuICogQSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0aGF0IHNpbXBsaWZpZXMgcmV0dXJuaW5nIGFuIG9iamVjdFxyXG4gKiBtYWRlIHVwIG9mIHNlbGVjdG9yIHJlc3VsdHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnB1dFNlbGVjdG9yc09iamVjdCAtIEEga2V5IHZhbHVlIHBhaXIgY29uc2lzdGluZyBvZiBpbnB1dCBzZWxlY3RvcnMuXHJcbiAqIEBwYXJhbSBzZWxlY3RvckNyZWF0b3IgLSBBIGN1c3RvbSBzZWxlY3RvciBjcmVhdG9yIGZ1bmN0aW9uLiBJdCBkZWZhdWx0cyB0byBgY3JlYXRlU2VsZWN0b3JgLlxyXG4gKiBAcmV0dXJucyBBIG1lbW9pemVkIHN0cnVjdHVyZWQgc2VsZWN0b3IuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIDxjYXB0aW9uPk1vZGVybiBVc2UgQ2FzZTwvY2FwdGlvbj5cclxuICogYGBgdHNcclxuICogaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IsIGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciB9IGZyb20gJ3Jlc2VsZWN0J1xyXG4gKlxyXG4gKiBpbnRlcmZhY2UgUm9vdFN0YXRlIHtcclxuICogICB0b2Rvczoge1xyXG4gKiAgICAgaWQ6IG51bWJlclxyXG4gKiAgICAgY29tcGxldGVkOiBib29sZWFuXHJcbiAqICAgICB0aXRsZTogc3RyaW5nXHJcbiAqICAgICBkZXNjcmlwdGlvbjogc3RyaW5nXHJcbiAqICAgfVtdXHJcbiAqICAgYWxlcnRzOiB7IGlkOiBudW1iZXI7IHJlYWQ6IGJvb2xlYW4gfVtdXHJcbiAqIH1cclxuICpcclxuICogLy8gVGhpczpcclxuICogY29uc3Qgc3RydWN0dXJlZFNlbGVjdG9yID0gY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yKFxyXG4gKiAgIHtcclxuICogICAgIHRvZG9zOiAoc3RhdGU6IFJvb3RTdGF0ZSkgPT4gc3RhdGUudG9kb3MsXHJcbiAqICAgICBhbGVydHM6IChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZS5hbGVydHMsXHJcbiAqICAgICB0b2RvQnlJZDogKHN0YXRlOiBSb290U3RhdGUsIGlkOiBudW1iZXIpID0+IHN0YXRlLnRvZG9zW2lkXVxyXG4gKiAgIH0sXHJcbiAqICAgY3JlYXRlU2VsZWN0b3JcclxuICogKVxyXG4gKlxyXG4gKiAvLyBJcyBlc3NlbnRpYWxseSB0aGUgc2FtZSBhcyB0aGlzOlxyXG4gKiBjb25zdCBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yKFxyXG4gKiAgIFtcclxuICogICAgIChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZS50b2RvcyxcclxuICogICAgIChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZS5hbGVydHMsXHJcbiAqICAgICAoc3RhdGU6IFJvb3RTdGF0ZSwgaWQ6IG51bWJlcikgPT4gc3RhdGUudG9kb3NbaWRdXHJcbiAqICAgXSxcclxuICogICAodG9kb3MsIGFsZXJ0cywgdG9kb0J5SWQpID0+IHtcclxuICogICAgIHJldHVybiB7XHJcbiAqICAgICAgIHRvZG9zLFxyXG4gKiAgICAgICBhbGVydHMsXHJcbiAqICAgICAgIHRvZG9CeUlkXHJcbiAqICAgICB9XHJcbiAqICAgfVxyXG4gKiApXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3Jlc2VsZWN0LmpzLm9yZy9hcGkvY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIGBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3JgfVxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yOiBTdHJ1Y3R1cmVkU2VsZWN0b3JDcmVhdG9yID1cclxuICBPYmplY3QuYXNzaWduKFxyXG4gICAgPFxyXG4gICAgICBJbnB1dFNlbGVjdG9yc09iamVjdCBleHRlbmRzIFNlbGVjdG9yc09iamVjdCxcclxuICAgICAgTWVtb2l6ZUZ1bmN0aW9uIGV4dGVuZHMgVW5rbm93bk1lbW9pemVyID0gdHlwZW9mIHdlYWtNYXBNZW1vaXplLFxyXG4gICAgICBBcmdzTWVtb2l6ZUZ1bmN0aW9uIGV4dGVuZHMgVW5rbm93bk1lbW9pemVyID0gdHlwZW9mIHdlYWtNYXBNZW1vaXplXHJcbiAgICA+KFxyXG4gICAgICBpbnB1dFNlbGVjdG9yc09iamVjdDogSW5wdXRTZWxlY3RvcnNPYmplY3QsXHJcbiAgICAgIHNlbGVjdG9yQ3JlYXRvcjogQ3JlYXRlU2VsZWN0b3JGdW5jdGlvbjxcclxuICAgICAgICBNZW1vaXplRnVuY3Rpb24sXHJcbiAgICAgICAgQXJnc01lbW9pemVGdW5jdGlvblxyXG4gICAgICA+ID0gY3JlYXRlU2VsZWN0b3IgYXMgQ3JlYXRlU2VsZWN0b3JGdW5jdGlvbjxcclxuICAgICAgICBNZW1vaXplRnVuY3Rpb24sXHJcbiAgICAgICAgQXJnc01lbW9pemVGdW5jdGlvblxyXG4gICAgICA+XHJcbiAgICApID0+IHtcclxuICAgICAgYXNzZXJ0SXNPYmplY3QoXHJcbiAgICAgICAgaW5wdXRTZWxlY3RvcnNPYmplY3QsXHJcbiAgICAgICAgJ2NyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciBleHBlY3RzIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCAnICtcclxuICAgICAgICAgIGB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIGEgc2VsZWN0b3IsIGluc3RlYWQgcmVjZWl2ZWQgYSAke3R5cGVvZiBpbnB1dFNlbGVjdG9yc09iamVjdH1gXHJcbiAgICAgIClcclxuICAgICAgY29uc3QgaW5wdXRTZWxlY3RvcktleXMgPSBPYmplY3Qua2V5cyhpbnB1dFNlbGVjdG9yc09iamVjdClcclxuICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gaW5wdXRTZWxlY3RvcktleXMubWFwKFxyXG4gICAgICAgIGtleSA9PiBpbnB1dFNlbGVjdG9yc09iamVjdFtrZXldXHJcbiAgICAgIClcclxuICAgICAgY29uc3Qgc3RydWN0dXJlZFNlbGVjdG9yID0gc2VsZWN0b3JDcmVhdG9yKFxyXG4gICAgICAgIGRlcGVuZGVuY2llcyxcclxuICAgICAgICAoLi4uaW5wdXRTZWxlY3RvclJlc3VsdHM6IGFueVtdKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gaW5wdXRTZWxlY3RvclJlc3VsdHMucmVkdWNlKChjb21wb3NpdGlvbiwgdmFsdWUsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbXBvc2l0aW9uW2lucHV0U2VsZWN0b3JLZXlzW2luZGV4XV0gPSB2YWx1ZVxyXG4gICAgICAgICAgICByZXR1cm4gY29tcG9zaXRpb25cclxuICAgICAgICAgIH0sIHt9KVxyXG4gICAgICAgIH1cclxuICAgICAgKVxyXG4gICAgICByZXR1cm4gc3RydWN0dXJlZFNlbGVjdG9yXHJcbiAgICB9LFxyXG4gICAgeyB3aXRoVHlwZXM6ICgpID0+IGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciB9XHJcbiAgKSBhcyBTdHJ1Y3R1cmVkU2VsZWN0b3JDcmVhdG9yXHJcbiJdLCJuYW1lcyI6WyJjcmVhdGVTZWxlY3RvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QVU2WlUsUUFB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QUEwQixJQUFNO1lBQ2hDLCtCQUErQixNQUFNO2dCQUNuQywyQkFBMkI7WUFDN0I7WUFDQSxZQUFZLElBQU07WUFDbEIsZ0JBQWdCLElBQU07WUFDdEIscUJBQXFCLE1BQU07Z0JBQ3pCLGlCQUFpQjtZQUNuQjtZQUNBO1lBQ0E7UUFDRixDQUFDO0lBTUg7SUFFQSxPQUFPLE1BQUEsQ0FBT0EsaUJBQWdCO1FBQzVCLFdBQVcsSUFBTUE7SUFDbkIsQ0FBQztJQUVELE9BQU9BO0FBSVQ7QUFXTyxJQUFNLGlCQUNLLGFBQUEsR0FBQSxzQkFBc0IsY0FBYzs7QUM1RS9DLElBQU0sMkJBQ1gsT0FBTyxNQUFBLENBQ0wsU0FLRTtRQUNBLG1GQUdJLG1CQUlEO0lBQ0gsZUFDRSxzQkFDQSx5SEFDa0UsT0FBUCxPQUFPO0lBRXBFLE1BQU0sb0JBQW9CLE9BQU8sSUFBQSxDQUFLLG9CQUFvQjtJQUMxRCxNQUFNLGVBQWUsa0JBQWtCLEdBQUEsQ0FDckMsQ0FBQSxNQUFPLG9CQUFBLENBQXFCLEdBQUcsQ0FBQTtJQUVqQyxNQUFNLHFCQUFxQixnQkFDekIsY0FDQTs7WUFBSSx5QkFBZ0M7O1FBQ2xDLE9BQU8scUJBQXFCLE1BQUEsQ0FBTyxDQUFDLGFBQWEsT0FBTyxVQUFVO1lBQ2hFLFdBQUEsQ0FBWSxpQkFBQSxDQUFrQixLQUFLLENBQUMsQ0FBQSxHQUFJO1lBQ3hDLE9BQU87UUFDVCxHQUFHLENBQUMsQ0FBQztJQUNQO0lBRUYsT0FBTztBQUNULEdBQ0E7SUFBRSxXQUFXLElBQU07QUFBeUIiLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEwMTU5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3JlZHV4L3NyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3JlZHV4L3NyYy91dGlscy9zeW1ib2wtb2JzZXJ2YWJsZS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWR1eC9zcmMvdXRpbHMvYWN0aW9uVHlwZXMudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVkdXgvc3JjL3V0aWxzL2lzUGxhaW5PYmplY3QudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVkdXgvc3JjL3V0aWxzL2tpbmRPZi50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWR1eC9zcmMvY3JlYXRlU3RvcmUudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVkdXgvc3JjL3V0aWxzL3dhcm5pbmcudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVkdXgvc3JjL2NvbWJpbmVSZWR1Y2Vycy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWR1eC9zcmMvYmluZEFjdGlvbkNyZWF0b3JzLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3JlZHV4L3NyYy9jb21wb3NlLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3JlZHV4L3NyYy9hcHBseU1pZGRsZXdhcmUudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVkdXgvc3JjL3V0aWxzL2lzQWN0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQWRhcHRlZCBmcm9tIFJlYWN0OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc2hhcmVkL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UuanNcbiAqXG4gKiBEbyBub3QgcmVxdWlyZSB0aGlzIG1vZHVsZSBkaXJlY3RseSEgVXNlIG5vcm1hbCB0aHJvdyBlcnJvciBjYWxscy4gVGhlc2UgbWVzc2FnZXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGVycm9yIGNvZGVzXG4gKiBkdXJpbmcgYnVpbGQuXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlOiBudW1iZXIpIHtcbiAgcmV0dXJuIGBNaW5pZmllZCBSZWR1eCBlcnJvciAjJHtjb2RlfTsgdmlzaXQgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvRXJyb3JzP2NvZGU9JHtjb2RlfSBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciBgICsgJ3VzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMuICc7XG59IiwiZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgU3ltYm9sQ29uc3RydWN0b3Ige1xuICAgIHJlYWRvbmx5IG9ic2VydmFibGU6IHN5bWJvbDtcbiAgfVxufVxuY29uc3QgJCRvYnNlcnZhYmxlID0gLyogI19fUFVSRV9fICovKCgpID0+IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLm9ic2VydmFibGUgfHwgJ0BAb2JzZXJ2YWJsZScpKCk7XG5leHBvcnQgZGVmYXVsdCAkJG9ic2VydmFibGU7IiwiLyoqXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICogSWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXG4gKi9cblxuY29uc3QgcmFuZG9tU3RyaW5nID0gKCkgPT4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpLnNwbGl0KCcnKS5qb2luKCcuJyk7XG5jb25zdCBBY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogYEBAcmVkdXgvSU5JVCR7LyogI19fUFVSRV9fICovcmFuZG9tU3RyaW5nKCl9YCxcbiAgUkVQTEFDRTogYEBAcmVkdXgvUkVQTEFDRSR7LyogI19fUFVSRV9fICovcmFuZG9tU3RyaW5nKCl9YCxcbiAgUFJPQkVfVU5LTk9XTl9BQ1RJT046ICgpID0+IGBAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OJHtyYW5kb21TdHJpbmcoKX1gXG59O1xuZXhwb3J0IGRlZmF1bHQgQWN0aW9uVHlwZXM7IiwiLyoqXG4gKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGFyZ3VtZW50IGFwcGVhcnMgdG8gYmUgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqOiBhbnkpOiBvYmogaXMgb2JqZWN0IHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBsZXQgcHJvdG8gPSBvYmo7XG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gcHJvdG8gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IG51bGw7XG59IiwiLy8gSW5saW5lZCAvIHNob3J0ZW5lZCB2ZXJzaW9uIG9mIGBraW5kT2ZgIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQva2luZC1vZlxuZXhwb3J0IGZ1bmN0aW9uIG1pbmlLaW5kT2YodmFsOiBhbnkpOiBzdHJpbmcge1xuICBpZiAodmFsID09PSB2b2lkIDApIHJldHVybiAndW5kZWZpbmVkJztcbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkgcmV0dXJuICdhcnJheSc7XG4gIGlmIChpc0RhdGUodmFsKSkgcmV0dXJuICdkYXRlJztcbiAgaWYgKGlzRXJyb3IodmFsKSkgcmV0dXJuICdlcnJvcic7XG4gIGNvbnN0IGNvbnN0cnVjdG9yTmFtZSA9IGN0b3JOYW1lKHZhbCk7XG4gIHN3aXRjaCAoY29uc3RydWN0b3JOYW1lKSB7XG4gICAgY2FzZSAnU3ltYm9sJzpcbiAgICBjYXNlICdQcm9taXNlJzpcbiAgICBjYXNlICdXZWFrTWFwJzpcbiAgICBjYXNlICdXZWFrU2V0JzpcbiAgICBjYXNlICdNYXAnOlxuICAgIGNhc2UgJ1NldCc6XG4gICAgICByZXR1cm4gY29uc3RydWN0b3JOYW1lO1xuICB9XG5cbiAgLy8gb3RoZXJcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccy9nLCAnJyk7XG59XG5mdW5jdGlvbiBjdG9yTmFtZSh2YWw6IGFueSk6IHN0cmluZyB8IG51bGwge1xuICByZXR1cm4gdHlwZW9mIHZhbC5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyA/IHZhbC5jb25zdHJ1Y3Rvci5uYW1lIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGlzRXJyb3IodmFsOiBhbnkpIHtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiB2YWwubWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgdmFsLmNvbnN0cnVjdG9yICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3Iuc3RhY2tUcmFjZUxpbWl0ID09PSAnbnVtYmVyJztcbn1cbmZ1bmN0aW9uIGlzRGF0ZSh2YWw6IGFueSkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0eXBlb2YgdmFsLnRvRGF0ZVN0cmluZyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsLmdldERhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbC5zZXREYXRlID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGtpbmRPZih2YWw6IGFueSkge1xuICBsZXQgdHlwZU9mVmFsOiBzdHJpbmcgPSB0eXBlb2YgdmFsO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHR5cGVPZlZhbCA9IG1pbmlLaW5kT2YodmFsKTtcbiAgfVxuICByZXR1cm4gdHlwZU9mVmFsO1xufSIsImltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UxMyB9IGZyb20gXCJzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZVwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTEyIH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMTEgfSBmcm9tIFwic3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2VcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UxMCB9IGZyb20gXCJzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZVwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTkgfSBmcm9tIFwic3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2VcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U4IH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNyB9IGZyb20gXCJzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZVwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTYgfSBmcm9tIFwic3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2VcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U1IH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCB9IGZyb20gXCJzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZVwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMgfSBmcm9tIFwic3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2VcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyIH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgJCRvYnNlcnZhYmxlIGZyb20gJy4vdXRpbHMvc3ltYm9sLW9ic2VydmFibGUnO1xuaW1wb3J0IHsgU3RvcmUsIFN0b3JlRW5oYW5jZXIsIERpc3BhdGNoLCBPYnNlcnZlciwgTGlzdGVuZXJDYWxsYmFjaywgVW5rbm93bklmTm9uU3BlY2lmaWMgfSBmcm9tICcuL3R5cGVzL3N0b3JlJztcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4vdHlwZXMvYWN0aW9ucyc7XG5pbXBvcnQgeyBSZWR1Y2VyIH0gZnJvbSAnLi90eXBlcy9yZWR1Y2Vycyc7XG5pbXBvcnQgQWN0aW9uVHlwZXMgZnJvbSAnLi91dGlscy9hY3Rpb25UeXBlcyc7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL3V0aWxzL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0IHsga2luZE9mIH0gZnJvbSAnLi91dGlscy9raW5kT2YnO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogKipXZSByZWNvbW1lbmQgdXNpbmcgdGhlIGBjb25maWd1cmVTdG9yZWAgbWV0aG9kXG4gKiBvZiB0aGUgYEByZWR1eGpzL3Rvb2xraXRgIHBhY2thZ2UqKiwgd2hpY2ggcmVwbGFjZXMgYGNyZWF0ZVN0b3JlYC5cbiAqXG4gKiBSZWR1eCBUb29sa2l0IGlzIG91ciByZWNvbW1lbmRlZCBhcHByb2FjaCBmb3Igd3JpdGluZyBSZWR1eCBsb2dpYyB0b2RheSxcbiAqIGluY2x1ZGluZyBzdG9yZSBzZXR1cCwgcmVkdWNlcnMsIGRhdGEgZmV0Y2hpbmcsIGFuZCBtb3JlLlxuICpcbiAqICoqRm9yIG1vcmUgZGV0YWlscywgcGxlYXNlIHJlYWQgdGhpcyBSZWR1eCBkb2NzIHBhZ2U6KipcbiAqICoqaHR0cHM6Ly9yZWR1eC5qcy5vcmcvaW50cm9kdWN0aW9uL3doeS1ydGstaXMtcmVkdXgtdG9kYXkqKlxuICpcbiAqIGBjb25maWd1cmVTdG9yZWAgZnJvbSBSZWR1eCBUb29sa2l0IGlzIGFuIGltcHJvdmVkIHZlcnNpb24gb2YgYGNyZWF0ZVN0b3JlYCB0aGF0XG4gKiBzaW1wbGlmaWVzIHNldHVwIGFuZCBoZWxwcyBhdm9pZCBjb21tb24gYnVncy5cbiAqXG4gKiBZb3Ugc2hvdWxkIG5vdCBiZSB1c2luZyB0aGUgYHJlZHV4YCBjb3JlIHBhY2thZ2UgYnkgaXRzZWxmIHRvZGF5LCBleGNlcHQgZm9yIGxlYXJuaW5nIHB1cnBvc2VzLlxuICogVGhlIGBjcmVhdGVTdG9yZWAgbWV0aG9kIGZyb20gdGhlIGNvcmUgYHJlZHV4YCBwYWNrYWdlIHdpbGwgbm90IGJlIHJlbW92ZWQsIGJ1dCB3ZSBlbmNvdXJhZ2VcbiAqIGFsbCB1c2VycyB0byBtaWdyYXRlIHRvIHVzaW5nIFJlZHV4IFRvb2xraXQgZm9yIGFsbCBSZWR1eCBjb2RlLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIHVzZSBgY3JlYXRlU3RvcmVgIHdpdGhvdXQgdGhpcyB2aXN1YWwgZGVwcmVjYXRpb24gd2FybmluZywgdXNlXG4gKiB0aGUgYGxlZ2FjeV9jcmVhdGVTdG9yZWAgaW1wb3J0IGluc3RlYWQ6XG4gKlxuICogYGltcG9ydCB7IGxlZ2FjeV9jcmVhdGVTdG9yZSBhcyBjcmVhdGVTdG9yZX0gZnJvbSAncmVkdXgnYFxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0b3JlPFMsIEEgZXh0ZW5kcyBBY3Rpb24sIEV4dCBleHRlbmRzIHt9ID0ge30sIFN0YXRlRXh0IGV4dGVuZHMge30gPSB7fT4ocmVkdWNlcjogUmVkdWNlcjxTLCBBPiwgZW5oYW5jZXI/OiBTdG9yZUVuaGFuY2VyPEV4dCwgU3RhdGVFeHQ+KTogU3RvcmU8UywgQSwgVW5rbm93bklmTm9uU3BlY2lmaWM8U3RhdGVFeHQ+PiAmIEV4dDtcbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqXG4gKiAqKldlIHJlY29tbWVuZCB1c2luZyB0aGUgYGNvbmZpZ3VyZVN0b3JlYCBtZXRob2RcbiAqIG9mIHRoZSBgQHJlZHV4anMvdG9vbGtpdGAgcGFja2FnZSoqLCB3aGljaCByZXBsYWNlcyBgY3JlYXRlU3RvcmVgLlxuICpcbiAqIFJlZHV4IFRvb2xraXQgaXMgb3VyIHJlY29tbWVuZGVkIGFwcHJvYWNoIGZvciB3cml0aW5nIFJlZHV4IGxvZ2ljIHRvZGF5LFxuICogaW5jbHVkaW5nIHN0b3JlIHNldHVwLCByZWR1Y2VycywgZGF0YSBmZXRjaGluZywgYW5kIG1vcmUuXG4gKlxuICogKipGb3IgbW9yZSBkZXRhaWxzLCBwbGVhc2UgcmVhZCB0aGlzIFJlZHV4IGRvY3MgcGFnZToqKlxuICogKipodHRwczovL3JlZHV4LmpzLm9yZy9pbnRyb2R1Y3Rpb24vd2h5LXJ0ay1pcy1yZWR1eC10b2RheSoqXG4gKlxuICogYGNvbmZpZ3VyZVN0b3JlYCBmcm9tIFJlZHV4IFRvb2xraXQgaXMgYW4gaW1wcm92ZWQgdmVyc2lvbiBvZiBgY3JlYXRlU3RvcmVgIHRoYXRcbiAqIHNpbXBsaWZpZXMgc2V0dXAgYW5kIGhlbHBzIGF2b2lkIGNvbW1vbiBidWdzLlxuICpcbiAqIFlvdSBzaG91bGQgbm90IGJlIHVzaW5nIHRoZSBgcmVkdXhgIGNvcmUgcGFja2FnZSBieSBpdHNlbGYgdG9kYXksIGV4Y2VwdCBmb3IgbGVhcm5pbmcgcHVycG9zZXMuXG4gKiBUaGUgYGNyZWF0ZVN0b3JlYCBtZXRob2QgZnJvbSB0aGUgY29yZSBgcmVkdXhgIHBhY2thZ2Ugd2lsbCBub3QgYmUgcmVtb3ZlZCwgYnV0IHdlIGVuY291cmFnZVxuICogYWxsIHVzZXJzIHRvIG1pZ3JhdGUgdG8gdXNpbmcgUmVkdXggVG9vbGtpdCBmb3IgYWxsIFJlZHV4IGNvZGUuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gdXNlIGBjcmVhdGVTdG9yZWAgd2l0aG91dCB0aGlzIHZpc3VhbCBkZXByZWNhdGlvbiB3YXJuaW5nLCB1c2VcbiAqIHRoZSBgbGVnYWN5X2NyZWF0ZVN0b3JlYCBpbXBvcnQgaW5zdGVhZDpcbiAqXG4gKiBgaW1wb3J0IHsgbGVnYWN5X2NyZWF0ZVN0b3JlIGFzIGNyZWF0ZVN0b3JlfSBmcm9tICdyZWR1eCdgXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RvcmU8UywgQSBleHRlbmRzIEFjdGlvbiwgRXh0IGV4dGVuZHMge30gPSB7fSwgU3RhdGVFeHQgZXh0ZW5kcyB7fSA9IHt9LCBQcmVsb2FkZWRTdGF0ZSA9IFM+KHJlZHVjZXI6IFJlZHVjZXI8UywgQSwgUHJlbG9hZGVkU3RhdGU+LCBwcmVsb2FkZWRTdGF0ZT86IFByZWxvYWRlZFN0YXRlIHwgdW5kZWZpbmVkLCBlbmhhbmNlcj86IFN0b3JlRW5oYW5jZXI8RXh0LCBTdGF0ZUV4dD4pOiBTdG9yZTxTLCBBLCBVbmtub3duSWZOb25TcGVjaWZpYzxTdGF0ZUV4dD4+ICYgRXh0O1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0b3JlPFMsIEEgZXh0ZW5kcyBBY3Rpb24sIEV4dCBleHRlbmRzIHt9ID0ge30sIFN0YXRlRXh0IGV4dGVuZHMge30gPSB7fSwgUHJlbG9hZGVkU3RhdGUgPSBTPihyZWR1Y2VyOiBSZWR1Y2VyPFMsIEEsIFByZWxvYWRlZFN0YXRlPiwgcHJlbG9hZGVkU3RhdGU/OiBQcmVsb2FkZWRTdGF0ZSB8IFN0b3JlRW5oYW5jZXI8RXh0LCBTdGF0ZUV4dD4gfCB1bmRlZmluZWQsIGVuaGFuY2VyPzogU3RvcmVFbmhhbmNlcjxFeHQsIFN0YXRlRXh0Pik6IFN0b3JlPFMsIEEsIFVua25vd25JZk5vblNwZWNpZmljPFN0YXRlRXh0Pj4gJiBFeHQge1xuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMikgOiBgRXhwZWN0ZWQgdGhlIHJvb3QgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJyR7a2luZE9mKHJlZHVjZXIpfSdgKTtcbiAgfVxuICBpZiAodHlwZW9mIHByZWxvYWRlZFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZW5oYW5jZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIoMCkgOiAnSXQgbG9va3MgbGlrZSB5b3UgYXJlIHBhc3Npbmcgc2V2ZXJhbCBzdG9yZSBlbmhhbmNlcnMgdG8gJyArICdjcmVhdGVTdG9yZSgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIEluc3RlYWQsIGNvbXBvc2UgdGhlbSAnICsgJ3RvZ2V0aGVyIHRvIGEgc2luZ2xlIGZ1bmN0aW9uLiBTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wYXJ0LTQtc3RvcmUjY3JlYXRpbmctYS1zdG9yZS13aXRoLWVuaGFuY2VycyBmb3IgYW4gZXhhbXBsZS4nKTtcbiAgfVxuICBpZiAodHlwZW9mIHByZWxvYWRlZFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbmhhbmNlciA9IChwcmVsb2FkZWRTdGF0ZSBhcyBTdG9yZUVuaGFuY2VyPEV4dCwgU3RhdGVFeHQ+KTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMoMSkgOiBgRXhwZWN0ZWQgdGhlIGVuaGFuY2VyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnJHtraW5kT2YoZW5oYW5jZXIpfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCAocHJlbG9hZGVkU3RhdGUgYXMgUHJlbG9hZGVkU3RhdGUgfCB1bmRlZmluZWQpKTtcbiAgfVxuICBsZXQgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICBsZXQgY3VycmVudFN0YXRlOiBTIHwgUHJlbG9hZGVkU3RhdGUgfCB1bmRlZmluZWQgPSAocHJlbG9hZGVkU3RhdGUgYXMgUHJlbG9hZGVkU3RhdGUgfCB1bmRlZmluZWQpO1xuICBsZXQgY3VycmVudExpc3RlbmVyczogTWFwPG51bWJlciwgTGlzdGVuZXJDYWxsYmFjaz4gfCBudWxsID0gbmV3IE1hcCgpO1xuICBsZXQgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIGxldCBsaXN0ZW5lcklkQ291bnRlciA9IDA7XG4gIGxldCBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWFrZXMgYSBzaGFsbG93IGNvcHkgb2YgY3VycmVudExpc3RlbmVycyBzbyB3ZSBjYW4gdXNlXG4gICAqIG5leHRMaXN0ZW5lcnMgYXMgYSB0ZW1wb3JhcnkgbGlzdCB3aGlsZSBkaXNwYXRjaGluZy5cbiAgICpcbiAgICogVGhpcyBwcmV2ZW50cyBhbnkgYnVncyBhcm91bmQgY29uc3VtZXJzIGNhbGxpbmdcbiAgICogc3Vic2NyaWJlL3Vuc3Vic2NyaWJlIGluIHRoZSBtaWRkbGUgb2YgYSBkaXNwYXRjaC5cbiAgICovXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgICBjdXJyZW50TGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyLCBrZXkpID0+IHtcbiAgICAgICAgbmV4dExpc3RlbmVycy5zZXQoa2V5LCBsaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIHN0YXRlIHRyZWUgbWFuYWdlZCBieSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHN0YXRlIHRyZWUgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCk6IFMge1xuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U0KDMpIDogJ1lvdSBtYXkgbm90IGNhbGwgc3RvcmUuZ2V0U3RhdGUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuICcgKyAnVGhlIHJlZHVjZXIgaGFzIGFscmVhZHkgcmVjZWl2ZWQgdGhlIHN0YXRlIGFzIGFuIGFyZ3VtZW50LiAnICsgJ1Bhc3MgaXQgZG93biBmcm9tIHRoZSB0b3AgcmVkdWNlciBpbnN0ZWFkIG9mIHJlYWRpbmcgaXQgZnJvbSB0aGUgc3RvcmUuJyk7XG4gICAgfVxuICAgIHJldHVybiAoY3VycmVudFN0YXRlIGFzIFMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIGxpc3RlbmVyIEEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbiBldmVyeSBkaXNwYXRjaC5cbiAgICogQHJldHVybnMgQSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyBjaGFuZ2UgbGlzdGVuZXIuXG4gICAqL1xuICBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXI6ICgpID0+IHZvaWQpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U1KDQpIDogYEV4cGVjdGVkIHRoZSBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJyR7a2luZE9mKGxpc3RlbmVyKX0nYCk7XG4gICAgfVxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U2KDUpIDogJ1lvdSBtYXkgbm90IGNhbGwgc3RvcmUuc3Vic2NyaWJlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ0lmIHlvdSB3b3VsZCBsaWtlIHRvIGJlIG5vdGlmaWVkIGFmdGVyIHRoZSBzdG9yZSBoYXMgYmVlbiB1cGRhdGVkLCBzdWJzY3JpYmUgZnJvbSBhICcgKyAnY29tcG9uZW50IGFuZCBpbnZva2Ugc3RvcmUuZ2V0U3RhdGUoKSBpbiB0aGUgY2FsbGJhY2sgdG8gYWNjZXNzIHRoZSBsYXRlc3Qgc3RhdGUuICcgKyAnU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS9zdG9yZSNzdWJzY3JpYmVsaXN0ZW5lciBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICAgIH1cbiAgICBsZXQgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgY29uc3QgbGlzdGVuZXJJZCA9IGxpc3RlbmVySWRDb3VudGVyKys7XG4gICAgbmV4dExpc3RlbmVycy5zZXQobGlzdGVuZXJJZCwgbGlzdGVuZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTcoNikgOiAnWW91IG1heSBub3QgdW5zdWJzY3JpYmUgZnJvbSBhIHN0b3JlIGxpc3RlbmVyIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gJyArICdTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpL3N0b3JlI3N1YnNjcmliZWxpc3RlbmVyIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgICB9XG4gICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICAgIG5leHRMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVySWQpO1xuICAgICAgY3VycmVudExpc3RlbmVycyA9IG51bGw7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFuIGFjdGlvbi4gSXQgaXMgdGhlIG9ubHkgd2F5IHRvIHRyaWdnZXIgYSBzdGF0ZSBjaGFuZ2UuXG4gICAqXG4gICAqIFRoZSBgcmVkdWNlcmAgZnVuY3Rpb24sIHVzZWQgdG8gY3JlYXRlIHRoZSBzdG9yZSwgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGVcbiAgICogY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgZ2l2ZW4gYGFjdGlvbmAuIEl0cyByZXR1cm4gdmFsdWUgd2lsbFxuICAgKiBiZSBjb25zaWRlcmVkIHRoZSAqKm5leHQqKiBzdGF0ZSBvZiB0aGUgdHJlZSwgYW5kIHRoZSBjaGFuZ2UgbGlzdGVuZXJzXG4gICAqIHdpbGwgYmUgbm90aWZpZWQuXG4gICAqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgcGxhaW4gb2JqZWN0IGFjdGlvbnMuIElmIHlvdSB3YW50IHRvXG4gICAqIGRpc3BhdGNoIGEgUHJvbWlzZSwgYW4gT2JzZXJ2YWJsZSwgYSB0aHVuaywgb3Igc29tZXRoaW5nIGVsc2UsIHlvdSBuZWVkIHRvXG4gICAqIHdyYXAgeW91ciBzdG9yZSBjcmVhdGluZyBmdW5jdGlvbiBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIG1pZGRsZXdhcmUuIEZvclxuICAgKiBleGFtcGxlLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UuIEV2ZW4gdGhlXG4gICAqIG1pZGRsZXdhcmUgd2lsbCBldmVudHVhbGx5IGRpc3BhdGNoIHBsYWluIG9iamVjdCBhY3Rpb25zIHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0gYWN0aW9uIEEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGluZyDigJx3aGF0IGNoYW5nZWTigJ0uIEl0IGlzXG4gICAqIGEgZ29vZCBpZGVhIHRvIGtlZXAgYWN0aW9ucyBzZXJpYWxpemFibGUgc28geW91IGNhbiByZWNvcmQgYW5kIHJlcGxheSB1c2VyXG4gICAqIHNlc3Npb25zLCBvciB1c2UgdGhlIHRpbWUgdHJhdmVsbGluZyBgcmVkdXgtZGV2dG9vbHNgLiBBbiBhY3Rpb24gbXVzdCBoYXZlXG4gICAqIGEgYHR5cGVgIHByb3BlcnR5IHdoaWNoIG1heSBub3QgYmUgYHVuZGVmaW5lZGAuIEl0IGlzIGEgZ29vZCBpZGVhIHRvIHVzZVxuICAgKiBzdHJpbmcgY29uc3RhbnRzIGZvciBhY3Rpb24gdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIEZvciBjb252ZW5pZW5jZSwgdGhlIHNhbWUgYWN0aW9uIG9iamVjdCB5b3UgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0LCBpZiB5b3UgdXNlIGEgY3VzdG9tIG1pZGRsZXdhcmUsIGl0IG1heSB3cmFwIGBkaXNwYXRjaCgpYCB0b1xuICAgKiByZXR1cm4gc29tZXRoaW5nIGVsc2UgKGZvciBleGFtcGxlLCBhIFByb21pc2UgeW91IGNhbiBhd2FpdCkuXG4gICAqL1xuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb246IEEpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlOCg3KSA6IGBBY3Rpb25zIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gSW5zdGVhZCwgdGhlIGFjdHVhbCB0eXBlIHdhczogJyR7a2luZE9mKGFjdGlvbil9Jy4gWW91IG1heSBuZWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRvIHlvdXIgc3RvcmUgc2V0dXAgdG8gaGFuZGxlIGRpc3BhdGNoaW5nIG90aGVyIHZhbHVlcywgc3VjaCBhcyAncmVkdXgtdGh1bmsnIHRvIGhhbmRsZSBkaXNwYXRjaGluZyBmdW5jdGlvbnMuIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNtaWRkbGV3YXJlIGFuZCBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNi1hc3luYy1sb2dpYyN1c2luZy10aGUtcmVkdXgtdGh1bmstbWlkZGxld2FyZSBmb3IgZXhhbXBsZXMuYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U5KDgpIDogJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYW4gYWN0aW9uIHR5cGUgc3RyaW5nIGNvbnN0YW50LicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMTAoMTcpIDogYEFjdGlvbiBcInR5cGVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nLiBJbnN0ZWFkLCB0aGUgYWN0dWFsIHR5cGUgd2FzOiAnJHtraW5kT2YoYWN0aW9uLnR5cGUpfScuIFZhbHVlIHdhczogJyR7YWN0aW9uLnR5cGV9JyAoc3RyaW5naWZpZWQpYCk7XG4gICAgfVxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UxMSg5KSA6ICdSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIFlvdSBtaWdodCBuZWVkIHRoaXMgaWYgeW91ciBhcHAgaW1wbGVtZW50cyBjb2RlIHNwbGl0dGluZyBhbmQgeW91IHdhbnQgdG9cbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXG4gICAqXG4gICAqIEBwYXJhbSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXI6IFJlZHVjZXI8UywgQT4pOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UxMigxMCkgOiBgRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnJHtraW5kT2YobmV4dFJlZHVjZXIpfWApO1xuICAgIH1cbiAgICBjdXJyZW50UmVkdWNlciA9ICgobmV4dFJlZHVjZXIgYXMgdW5rbm93bikgYXMgUmVkdWNlcjxTLCBBLCBQcmVsb2FkZWRTdGF0ZT4pO1xuXG4gICAgLy8gVGhpcyBhY3Rpb24gaGFzIGEgc2ltaWxhciBlZmZlY3QgdG8gQWN0aW9uVHlwZXMuSU5JVC5cbiAgICAvLyBBbnkgcmVkdWNlcnMgdGhhdCBleGlzdGVkIGluIGJvdGggdGhlIG5ldyBhbmQgb2xkIHJvb3RSZWR1Y2VyXG4gICAgLy8gd2lsbCByZWNlaXZlIHRoZSBwcmV2aW91cyBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgICAvLyB0aGUgbmV3IHN0YXRlIHRyZWUgd2l0aCBhbnkgcmVsZXZhbnQgZGF0YSBmcm9tIHRoZSBvbGQgb25lLlxuICAgIGRpc3BhdGNoKCh7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlcy5SRVBMQUNFXG4gICAgfSBhcyBBKSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJvcGVyYWJpbGl0eSBwb2ludCBmb3Igb2JzZXJ2YWJsZS9yZWFjdGl2ZSBsaWJyYXJpZXMuXG4gICAqIEByZXR1cm5zIEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgY29uc3Qgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG1pbmltYWwgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gbWV0aG9kLlxuICAgICAgICogQHBhcmFtIG9ic2VydmVyIEFueSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBvYnNlcnZlci5cbiAgICAgICAqIFRoZSBvYnNlcnZlciBvYmplY3Qgc2hvdWxkIGhhdmUgYSBgbmV4dGAgbWV0aG9kLlxuICAgICAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYW4gYHVuc3Vic2NyaWJlYCBtZXRob2QgdGhhdCBjYW5cbiAgICAgICAqIGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmFibGUgZnJvbSB0aGUgc3RvcmUsIGFuZCBwcmV2ZW50IGZ1cnRoZXJcbiAgICAgICAqIGVtaXNzaW9uIG9mIHZhbHVlcyBmcm9tIHRoZSBvYnNlcnZhYmxlLlxuICAgICAgICovXG4gICAgICBzdWJzY3JpYmUob2JzZXJ2ZXI6IHVua25vd24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcgfHwgb2JzZXJ2ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UxMygxMSkgOiBgRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihvYnNlcnZlcil9J2ApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBjb25zdCBvYnNlcnZlckFzT2JzZXJ2ZXIgPSAob2JzZXJ2ZXIgYXMgT2JzZXJ2ZXI8Uz4pO1xuICAgICAgICAgIGlmIChvYnNlcnZlckFzT2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXJBc09ic2VydmVyLm5leHQoZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IG91dGVyU3Vic2NyaWJlKG9ic2VydmVTdGF0ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBbJCRvYnNlcnZhYmxlXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuICBkaXNwYXRjaCgoe1xuICAgIHR5cGU6IEFjdGlvblR5cGVzLklOSVRcbiAgfSBhcyBBKSk7XG4gIGNvbnN0IHN0b3JlID0gKCh7XG4gICAgZGlzcGF0Y2g6IChkaXNwYXRjaCBhcyBEaXNwYXRjaDxBPiksXG4gICAgc3Vic2NyaWJlLFxuICAgIGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyLFxuICAgIFskJG9ic2VydmFibGVdOiBvYnNlcnZhYmxlXG4gIH0gYXMgdW5rbm93bikgYXMgU3RvcmU8UywgQSwgU3RhdGVFeHQ+ICYgRXh0KTtcbiAgcmV0dXJuIHN0b3JlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBSZWR1eCBzdG9yZSB0aGF0IGhvbGRzIHRoZSBzdGF0ZSB0cmVlLlxuICpcbiAqICoqV2UgcmVjb21tZW5kIHVzaW5nIGBjb25maWd1cmVTdG9yZWAgZnJvbSB0aGVcbiAqIGBAcmVkdXhqcy90b29sa2l0YCBwYWNrYWdlKiosIHdoaWNoIHJlcGxhY2VzIGBjcmVhdGVTdG9yZWA6XG4gKiAqKmh0dHBzOi8vcmVkdXguanMub3JnL2ludHJvZHVjdGlvbi93aHktcnRrLWlzLXJlZHV4LXRvZGF5KipcbiAqXG4gKiBUaGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZSBkYXRhIGluIHRoZSBzdG9yZSBpcyB0byBjYWxsIGBkaXNwYXRjaCgpYCBvbiBpdC5cbiAqXG4gKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gKiBwYXJ0cyBvZiB0aGUgc3RhdGUgdHJlZSByZXNwb25kIHRvIGFjdGlvbnMsIHlvdSBtYXkgY29tYmluZSBzZXZlcmFsIHJlZHVjZXJzXG4gKiBpbnRvIGEgc2luZ2xlIHJlZHVjZXIgZnVuY3Rpb24gYnkgdXNpbmcgYGNvbWJpbmVSZWR1Y2Vyc2AuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVkdWNlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSB0cmVlLCBnaXZlblxuICogdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGFjdGlvbiB0byBoYW5kbGUuXG4gKlxuICogQHBhcmFtIHthbnl9IFtwcmVsb2FkZWRTdGF0ZV0gVGhlIGluaXRpYWwgc3RhdGUuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBoeWRyYXRlIHRoZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYVxuICogcHJldmlvdXNseSBzZXJpYWxpemVkIHVzZXIgc2Vzc2lvbi5cbiAqIElmIHlvdSB1c2UgYGNvbWJpbmVSZWR1Y2Vyc2AgdG8gcHJvZHVjZSB0aGUgcm9vdCByZWR1Y2VyIGZ1bmN0aW9uLCB0aGlzIG11c3QgYmVcbiAqIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGBjb21iaW5lUmVkdWNlcnNgIGtleXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2VuaGFuY2VyXSBUaGUgc3RvcmUgZW5oYW5jZXIuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXG4gKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gKiBpcyBgYXBwbHlNaWRkbGV3YXJlKClgLlxuICpcbiAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gKiBhbmQgc3Vic2NyaWJlIHRvIGNoYW5nZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZWdhY3lfY3JlYXRlU3RvcmU8UywgQSBleHRlbmRzIEFjdGlvbiwgRXh0IGV4dGVuZHMge30gPSB7fSwgU3RhdGVFeHQgZXh0ZW5kcyB7fSA9IHt9PihyZWR1Y2VyOiBSZWR1Y2VyPFMsIEE+LCBlbmhhbmNlcj86IFN0b3JlRW5oYW5jZXI8RXh0LCBTdGF0ZUV4dD4pOiBTdG9yZTxTLCBBLCBVbmtub3duSWZOb25TcGVjaWZpYzxTdGF0ZUV4dD4+ICYgRXh0O1xuLyoqXG4gKiBDcmVhdGVzIGEgUmVkdXggc3RvcmUgdGhhdCBob2xkcyB0aGUgc3RhdGUgdHJlZS5cbiAqXG4gKiAqKldlIHJlY29tbWVuZCB1c2luZyBgY29uZmlndXJlU3RvcmVgIGZyb20gdGhlXG4gKiBgQHJlZHV4anMvdG9vbGtpdGAgcGFja2FnZSoqLCB3aGljaCByZXBsYWNlcyBgY3JlYXRlU3RvcmVgOlxuICogKipodHRwczovL3JlZHV4LmpzLm9yZy9pbnRyb2R1Y3Rpb24vd2h5LXJ0ay1pcy1yZWR1eC10b2RheSoqXG4gKlxuICogVGhlIG9ubHkgd2F5IHRvIGNoYW5nZSB0aGUgZGF0YSBpbiB0aGUgc3RvcmUgaXMgdG8gY2FsbCBgZGlzcGF0Y2goKWAgb24gaXQuXG4gKlxuICogVGhlcmUgc2hvdWxkIG9ubHkgYmUgYSBzaW5nbGUgc3RvcmUgaW4geW91ciBhcHAuIFRvIHNwZWNpZnkgaG93IGRpZmZlcmVudFxuICogcGFydHMgb2YgdGhlIHN0YXRlIHRyZWUgcmVzcG9uZCB0byBhY3Rpb25zLCB5b3UgbWF5IGNvbWJpbmUgc2V2ZXJhbCByZWR1Y2Vyc1xuICogaW50byBhIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIGJ5IHVzaW5nIGBjb21iaW5lUmVkdWNlcnNgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZHVjZXIgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5leHQgc3RhdGUgdHJlZSwgZ2l2ZW5cbiAqIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBhY3Rpb24gdG8gaGFuZGxlLlxuICpcbiAqIEBwYXJhbSB7YW55fSBbcHJlbG9hZGVkU3RhdGVdIFRoZSBpbml0aWFsIHN0YXRlLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gaHlkcmF0ZSB0aGUgc3RhdGUgZnJvbSB0aGUgc2VydmVyIGluIHVuaXZlcnNhbCBhcHBzLCBvciB0byByZXN0b3JlIGFcbiAqIHByZXZpb3VzbHkgc2VyaWFsaXplZCB1c2VyIHNlc3Npb24uXG4gKiBJZiB5b3UgdXNlIGBjb21iaW5lUmVkdWNlcnNgIHRvIHByb2R1Y2UgdGhlIHJvb3QgcmVkdWNlciBmdW5jdGlvbiwgdGhpcyBtdXN0IGJlXG4gKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBgY29tYmluZVJlZHVjZXJzYCBrZXlzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtlbmhhbmNlcl0gVGhlIHN0b3JlIGVuaGFuY2VyLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gZW5oYW5jZSB0aGUgc3RvcmUgd2l0aCB0aGlyZC1wYXJ0eSBjYXBhYmlsaXRpZXMgc3VjaCBhcyBtaWRkbGV3YXJlLFxuICogdGltZSB0cmF2ZWwsIHBlcnNpc3RlbmNlLCBldGMuIFRoZSBvbmx5IHN0b3JlIGVuaGFuY2VyIHRoYXQgc2hpcHMgd2l0aCBSZWR1eFxuICogaXMgYGFwcGx5TWlkZGxld2FyZSgpYC5cbiAqXG4gKiBAcmV0dXJucyB7U3RvcmV9IEEgUmVkdXggc3RvcmUgdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBzdGF0ZSwgZGlzcGF0Y2ggYWN0aW9uc1xuICogYW5kIHN1YnNjcmliZSB0byBjaGFuZ2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X2NyZWF0ZVN0b3JlPFMsIEEgZXh0ZW5kcyBBY3Rpb24sIEV4dCBleHRlbmRzIHt9ID0ge30sIFN0YXRlRXh0IGV4dGVuZHMge30gPSB7fSwgUHJlbG9hZGVkU3RhdGUgPSBTPihyZWR1Y2VyOiBSZWR1Y2VyPFMsIEEsIFByZWxvYWRlZFN0YXRlPiwgcHJlbG9hZGVkU3RhdGU/OiBQcmVsb2FkZWRTdGF0ZSB8IHVuZGVmaW5lZCwgZW5oYW5jZXI/OiBTdG9yZUVuaGFuY2VyPEV4dCwgU3RhdGVFeHQ+KTogU3RvcmU8UywgQSwgVW5rbm93bklmTm9uU3BlY2lmaWM8U3RhdGVFeHQ+PiAmIEV4dDtcbmV4cG9ydCBmdW5jdGlvbiBsZWdhY3lfY3JlYXRlU3RvcmU8UywgQSBleHRlbmRzIEFjdGlvbiwgRXh0IGV4dGVuZHMge30gPSB7fSwgU3RhdGVFeHQgZXh0ZW5kcyB7fSA9IHt9LCBQcmVsb2FkZWRTdGF0ZSA9IFM+KHJlZHVjZXI6IFJlZHVjZXI8UywgQT4sIHByZWxvYWRlZFN0YXRlPzogUHJlbG9hZGVkU3RhdGUgfCBTdG9yZUVuaGFuY2VyPEV4dCwgU3RhdGVFeHQ+IHwgdW5kZWZpbmVkLCBlbmhhbmNlcj86IFN0b3JlRW5oYW5jZXI8RXh0LCBTdGF0ZUV4dD4pOiBTdG9yZTxTLCBBLCBVbmtub3duSWZOb25TcGVjaWZpYzxTdGF0ZUV4dD4+ICYgRXh0IHtcbiAgcmV0dXJuIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIChwcmVsb2FkZWRTdGF0ZSBhcyBhbnkpLCBlbmhhbmNlcik7XG59IiwiLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG59IiwiaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMgfSBmcm9tIFwic3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2VcIjtcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyIH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL3R5cGVzL2FjdGlvbnMnO1xuaW1wb3J0IHsgQWN0aW9uRnJvbVJlZHVjZXJzTWFwT2JqZWN0LCBQcmVsb2FkZWRTdGF0ZVNoYXBlRnJvbVJlZHVjZXJzTWFwT2JqZWN0LCBSZWR1Y2VyLCBTdGF0ZUZyb21SZWR1Y2Vyc01hcE9iamVjdCB9IGZyb20gJy4vdHlwZXMvcmVkdWNlcnMnO1xuaW1wb3J0IEFjdGlvblR5cGVzIGZyb20gJy4vdXRpbHMvYWN0aW9uVHlwZXMnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi91dGlscy9pc1BsYWluT2JqZWN0JztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4vdXRpbHMvd2FybmluZyc7XG5pbXBvcnQgeyBraW5kT2YgfSBmcm9tICcuL3V0aWxzL2tpbmRPZic7XG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGU6IG9iamVjdCwgcmVkdWNlcnM6IHtcbiAgW2tleTogc3RyaW5nXTogUmVkdWNlcjxhbnksIGFueSwgYW55Pjtcbn0sIGFjdGlvbjogQWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGU6IHtcbiAgW2tleTogc3RyaW5nXTogdHJ1ZTtcbn0pIHtcbiAgY29uc3QgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIGNvbnN0IGFyZ3VtZW50TmFtZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gQWN0aW9uVHlwZXMuSU5JVCA/ICdwcmVsb2FkZWRTdGF0ZSBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU3RvcmUnIDogJ3ByZXZpb3VzIHN0YXRlIHJlY2VpdmVkIGJ5IHRoZSByZWR1Y2VyJztcbiAgaWYgKHJlZHVjZXJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnU3RvcmUgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHJlZHVjZXIuIE1ha2Ugc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkICcgKyAndG8gY29tYmluZVJlZHVjZXJzIGlzIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIHJlZHVjZXJzLic7XG4gIH1cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuIGBUaGUgJHthcmd1bWVudE5hbWV9IGhhcyB1bmV4cGVjdGVkIHR5cGUgb2YgXCIke2tpbmRPZihpbnB1dFN0YXRlKX1cIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBgICsgYGtleXM6IFwiJHtyZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKX1cImA7XG4gIH1cbiAgY29uc3QgdW5leHBlY3RlZEtleXMgPSBPYmplY3Qua2V5cyhpbnB1dFN0YXRlKS5maWx0ZXIoa2V5ID0+ICFyZWR1Y2Vycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICF1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSk7XG4gIHVuZXhwZWN0ZWRLZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICB1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSA9IHRydWU7XG4gIH0pO1xuICBpZiAoYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBBY3Rpb25UeXBlcy5SRVBMQUNFKSByZXR1cm47XG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGBVbmV4cGVjdGVkICR7dW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/ICdrZXlzJyA6ICdrZXknfSBgICsgYFwiJHt1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKX1cIiBmb3VuZCBpbiAke2FyZ3VtZW50TmFtZX0uIGAgKyBgRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiBgICsgYFwiJHtyZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKX1cIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC5gO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRSZWR1Y2VyU2hhcGUocmVkdWNlcnM6IHtcbiAgW2tleTogc3RyaW5nXTogUmVkdWNlcjxhbnksIGFueSwgYW55Pjtcbn0pIHtcbiAgT2JqZWN0LmtleXMocmVkdWNlcnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCByZWR1Y2VyID0gcmVkdWNlcnNba2V5XTtcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSByZWR1Y2VyKHVuZGVmaW5lZCwge1xuICAgICAgdHlwZTogQWN0aW9uVHlwZXMuSU5JVFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEyKSA6IGBUaGUgc2xpY2UgcmVkdWNlciBmb3Iga2V5IFwiJHtrZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gYCArIGBJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgYCArIGBleHBsaWNpdGx5IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IGAgKyBgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgYCArIGB5b3UgY2FuIHVzZSBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLmApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlZHVjZXIodW5kZWZpbmVkLCB7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlcy5QUk9CRV9VTktOT1dOX0FDVElPTigpXG4gICAgfSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDEzKSA6IGBUaGUgc2xpY2UgcmVkdWNlciBmb3Iga2V5IFwiJHtrZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gYCArIGBEb24ndCB0cnkgdG8gaGFuZGxlICcke0FjdGlvblR5cGVzLklOSVR9JyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiIGAgKyBgbmFtZXNwYWNlLiBUaGV5IGFyZSBjb25zaWRlcmVkIHByaXZhdGUuIEluc3RlYWQsIHlvdSBtdXN0IHJldHVybiB0aGUgYCArIGBjdXJyZW50IHN0YXRlIGZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCBgICsgYGluIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSBgICsgYGFjdGlvbiB0eXBlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZCwgYnV0IGNhbiBiZSBudWxsLmApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgZGlmZmVyZW50IHJlZHVjZXIgZnVuY3Rpb25zLCBpbnRvIGEgc2luZ2xlXG4gKiByZWR1Y2VyIGZ1bmN0aW9uLiBJdCB3aWxsIGNhbGwgZXZlcnkgY2hpbGQgcmVkdWNlciwgYW5kIGdhdGhlciB0aGVpciByZXN1bHRzXG4gKiBpbnRvIGEgc2luZ2xlIHN0YXRlIG9iamVjdCwgd2hvc2Uga2V5cyBjb3JyZXNwb25kIHRvIHRoZSBrZXlzIG9mIHRoZSBwYXNzZWRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zLlxuICpcbiAqIEB0ZW1wbGF0ZSBTIENvbWJpbmVkIHN0YXRlIG9iamVjdCB0eXBlLlxuICpcbiAqIEBwYXJhbSByZWR1Y2VycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGNvcnJlc3BvbmQgdG8gZGlmZmVyZW50IHJlZHVjZXJcbiAqICAgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXRcbiAqICAgaXMgdG8gdXNlIGBpbXBvcnQgKiBhcyByZWR1Y2Vyc2Agc3ludGF4LiBUaGUgcmVkdWNlcnMgbWF5IG5ldmVyXG4gKiAgIHJldHVybiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpclxuICogICBpbml0aWFsIHN0YXRlIGlmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlbSB3YXMgdW5kZWZpbmVkLCBhbmQgdGhlIGN1cnJlbnRcbiAqICAgc3RhdGUgZm9yIGFueSB1bnJlY29nbml6ZWQgYWN0aW9uLlxuICpcbiAqIEByZXR1cm5zIEEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgZXZlcnkgcmVkdWNlciBpbnNpZGUgdGhlIHBhc3NlZFxuICogICBvYmplY3QsIGFuZCBidWlsZHMgYSBzdGF0ZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tYmluZVJlZHVjZXJzPE0+KHJlZHVjZXJzOiBNKTogTVtrZXlvZiBNXSBleHRlbmRzIFJlZHVjZXI8YW55LCBhbnksIGFueT4gfCB1bmRlZmluZWQgPyBSZWR1Y2VyPFN0YXRlRnJvbVJlZHVjZXJzTWFwT2JqZWN0PE0+LCBBY3Rpb25Gcm9tUmVkdWNlcnNNYXBPYmplY3Q8TT4sIFBhcnRpYWw8UHJlbG9hZGVkU3RhdGVTaGFwZUZyb21SZWR1Y2Vyc01hcE9iamVjdDxNPj4+IDogbmV2ZXI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnM6IHtcbiAgW2tleTogc3RyaW5nXTogUmVkdWNlcjxhbnksIGFueSwgYW55Pjtcbn0pIHtcbiAgY29uc3QgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIGNvbnN0IGZpbmFsUmVkdWNlcnM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBSZWR1Y2VyPGFueSwgYW55LCBhbnk+O1xuICB9ID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSByZWR1Y2VyS2V5c1tpXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKGBObyByZWR1Y2VyIHByb3ZpZGVkIGZvciBrZXkgXCIke2tleX1cImApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZpbmFsUmVkdWNlcnNba2V5XSA9IHJlZHVjZXJzW2tleV07XG4gICAgfVxuICB9XG4gIGNvbnN0IGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcblxuICAvLyBUaGlzIGlzIHVzZWQgdG8gbWFrZSBzdXJlIHdlIGRvbid0IHdhcm4gYWJvdXQgdGhlIHNhbWVcbiAgLy8ga2V5cyBtdWx0aXBsZSB0aW1lcy5cbiAgbGV0IHVuZXhwZWN0ZWRLZXlDYWNoZToge1xuICAgIFtrZXk6IHN0cmluZ106IHRydWU7XG4gIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlID0ge307XG4gIH1cbiAgbGV0IHNoYXBlQXNzZXJ0aW9uRXJyb3I6IHVua25vd247XG4gIHRyeSB7XG4gICAgYXNzZXJ0UmVkdWNlclNoYXBlKGZpbmFsUmVkdWNlcnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2hhcGVBc3NlcnRpb25FcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uKHN0YXRlOiBTdGF0ZUZyb21SZWR1Y2Vyc01hcE9iamVjdDx0eXBlb2YgcmVkdWNlcnM+ID0ge30sIGFjdGlvbjogQWN0aW9uKSB7XG4gICAgaWYgKHNoYXBlQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zdCB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICB3YXJuaW5nKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBjb25zdCBuZXh0U3RhdGU6IFN0YXRlRnJvbVJlZHVjZXJzTWFwT2JqZWN0PHR5cGVvZiByZWR1Y2Vycz4gPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGZpbmFsUmVkdWNlcktleXNbaV07XG4gICAgICBjb25zdCByZWR1Y2VyID0gZmluYWxSZWR1Y2Vyc1trZXldO1xuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW2tleV07XG4gICAgICBjb25zdCBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG4gICAgICBpZiAodHlwZW9mIG5leHRTdGF0ZUZvcktleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMygxNCkgOiBgV2hlbiBjYWxsZWQgd2l0aCBhbiBhY3Rpb24gb2YgdHlwZSAke2FjdGlvblR5cGUgPyBgXCIke1N0cmluZyhhY3Rpb25UeXBlKX1cImAgOiAnKHVua25vd24gdHlwZSknfSwgdGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7a2V5fVwiIHJldHVybmVkIHVuZGVmaW5lZC4gYCArIGBUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuIGAgKyBgSWYgeW91IHdhbnQgdGhpcyByZWR1Y2VyIHRvIGhvbGQgbm8gdmFsdWUsIHlvdSBjYW4gcmV0dXJuIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuYCk7XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGVba2V5XSA9IG5leHRTdGF0ZUZvcktleTtcbiAgICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZUZvcktleSAhPT0gcHJldmlvdXNTdGF0ZUZvcktleTtcbiAgICB9XG4gICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKHN0YXRlKS5sZW5ndGg7XG4gICAgcmV0dXJuIGhhc0NoYW5nZWQgPyBuZXh0U3RhdGUgOiBzdGF0ZTtcbiAgfTtcbn0iLCJpbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIH0gZnJvbSBcInNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBEaXNwYXRjaCB9IGZyb20gJy4vdHlwZXMvc3RvcmUnO1xuaW1wb3J0IHsgQWN0aW9uQ3JlYXRvciwgQWN0aW9uQ3JlYXRvcnNNYXBPYmplY3QsIEFjdGlvbiB9IGZyb20gJy4vdHlwZXMvYWN0aW9ucyc7XG5pbXBvcnQgeyBraW5kT2YgfSBmcm9tICcuL3V0aWxzL2tpbmRPZic7XG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcjxBIGV4dGVuZHMgQWN0aW9uPihhY3Rpb25DcmVhdG9yOiBBY3Rpb25DcmVhdG9yPEE+LCBkaXNwYXRjaDogRGlzcGF0Y2g8QT4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGlzOiBhbnksIC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodGhpcywgYXJncykpO1xuICB9O1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvbiBjcmVhdG9ycywgaW50byBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqIHNhbWUga2V5cywgYnV0IHdpdGggZXZlcnkgZnVuY3Rpb24gd3JhcHBlZCBpbnRvIGEgYGRpc3BhdGNoYCBjYWxsIHNvIHRoZXlcbiAqIG1heSBiZSBpbnZva2VkIGRpcmVjdGx5LiBUaGlzIGlzIGp1c3QgYSBjb252ZW5pZW5jZSBtZXRob2QsIGFzIHlvdSBjYW4gY2FsbFxuICogYHN0b3JlLmRpc3BhdGNoKE15QWN0aW9uQ3JlYXRvcnMuZG9Tb21ldGhpbmcoKSlgIHlvdXJzZWxmIGp1c3QgZmluZS5cbiAqXG4gKiBGb3IgY29udmVuaWVuY2UsIHlvdSBjYW4gYWxzbyBwYXNzIGFuIGFjdGlvbiBjcmVhdG9yIGFzIHRoZSBmaXJzdCBhcmd1bWVudCxcbiAqIGFuZCBnZXQgYSBkaXNwYXRjaCB3cmFwcGVkIGZ1bmN0aW9uIGluIHJldHVybi5cbiAqXG4gKiBAcGFyYW0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXG4gKiBjcmVhdG9yIGZ1bmN0aW9ucy4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXQgaXMgdG8gdXNlIGBpbXBvcnQgKiBhc2BcbiAqIHN5bnRheC4gWW91IG1heSBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGRpc3BhdGNoIFRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiB5b3VyIFJlZHV4XG4gKiBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyBUaGUgb2JqZWN0IG1pbWlja2luZyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBidXQgd2l0aFxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnM8QSwgQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8QT4+KGFjdGlvbkNyZWF0b3I6IEMsIGRpc3BhdGNoOiBEaXNwYXRjaCk6IEM7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnM8QSBleHRlbmRzIEFjdGlvbkNyZWF0b3I8YW55PiwgQiBleHRlbmRzIEFjdGlvbkNyZWF0b3I8YW55Pj4oYWN0aW9uQ3JlYXRvcjogQSwgZGlzcGF0Y2g6IERpc3BhdGNoKTogQjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yczxBLCBNIGV4dGVuZHMgQWN0aW9uQ3JlYXRvcnNNYXBPYmplY3Q8QT4+KGFjdGlvbkNyZWF0b3JzOiBNLCBkaXNwYXRjaDogRGlzcGF0Y2gpOiBNO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzPE0gZXh0ZW5kcyBBY3Rpb25DcmVhdG9yc01hcE9iamVjdCwgTiBleHRlbmRzIEFjdGlvbkNyZWF0b3JzTWFwT2JqZWN0PihhY3Rpb25DcmVhdG9yczogTSwgZGlzcGF0Y2g6IERpc3BhdGNoKTogTjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9yczogQWN0aW9uQ3JlYXRvcjxhbnk+IHwgQWN0aW9uQ3JlYXRvcnNNYXBPYmplY3QsIGRpc3BhdGNoOiBEaXNwYXRjaCkge1xuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gJ29iamVjdCcgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTYpIDogYGJpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgYnV0IGluc3RlYWQgcmVjZWl2ZWQ6ICcke2tpbmRPZihhY3Rpb25DcmVhdG9ycyl9Jy4gYCArIGBEaWQgeW91IHdyaXRlIFwiaW1wb3J0IEFjdGlvbkNyZWF0b3JzIGZyb21cIiBpbnN0ZWFkIG9mIFwiaW1wb3J0ICogYXMgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiP2ApO1xuICB9XG4gIGNvbnN0IGJvdW5kQWN0aW9uQ3JlYXRvcnM6IEFjdGlvbkNyZWF0b3JzTWFwT2JqZWN0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGFjdGlvbkNyZWF0b3JzKSB7XG4gICAgY29uc3QgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufSIsInR5cGUgRnVuYzxUIGV4dGVuZHMgYW55W10sIFI+ID0gKC4uLmE6IFQpID0+IFI7XG5cbi8qKlxuICogQ29tcG9zZXMgc2luZ2xlLWFyZ3VtZW50IGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuIFRoZSByaWdodG1vc3RcbiAqIGZ1bmN0aW9uIGNhbiB0YWtlIG11bHRpcGxlIGFyZ3VtZW50cyBhcyBpdCBwcm92aWRlcyB0aGUgc2lnbmF0dXJlIGZvciB0aGVcbiAqIHJlc3VsdGluZyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gb2J0YWluZWQgYnkgY29tcG9zaW5nIHRoZSBhcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodFxuICogICB0byBsZWZ0LiBGb3IgZXhhbXBsZSwgYGNvbXBvc2UoZiwgZywgaClgIGlzIGlkZW50aWNhbCB0byBkb2luZ1xuICogICBgKC4uLmFyZ3MpID0+IGYoZyhoKC4uLmFyZ3MpKSlgLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlKCk6IDxSPihhOiBSKSA9PiBSO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcG9zZTxGIGV4dGVuZHMgRnVuY3Rpb24+KGY6IEYpOiBGO1xuXG4vKiB0d28gZnVuY3Rpb25zICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlPEEsIFQgZXh0ZW5kcyBhbnlbXSwgUj4oZjE6IChhOiBBKSA9PiBSLCBmMjogRnVuYzxULCBBPik6IEZ1bmM8VCwgUj47XG5cbi8qIHRocmVlIGZ1bmN0aW9ucyAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcG9zZTxBLCBCLCBUIGV4dGVuZHMgYW55W10sIFI+KGYxOiAoYjogQikgPT4gUiwgZjI6IChhOiBBKSA9PiBCLCBmMzogRnVuYzxULCBBPik6IEZ1bmM8VCwgUj47XG5cbi8qIGZvdXIgZnVuY3Rpb25zICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlPEEsIEIsIEMsIFQgZXh0ZW5kcyBhbnlbXSwgUj4oZjE6IChjOiBDKSA9PiBSLCBmMjogKGI6IEIpID0+IEMsIGYzOiAoYTogQSkgPT4gQiwgZjQ6IEZ1bmM8VCwgQT4pOiBGdW5jPFQsIFI+O1xuXG4vKiByZXN0ICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlPFI+KGYxOiAoYTogYW55KSA9PiBSLCAuLi5mdW5jczogRnVuY3Rpb25bXSk6ICguLi5hcmdzOiBhbnlbXSkgPT4gUjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBvc2U8Uj4oLi4uZnVuY3M6IEZ1bmN0aW9uW10pOiAoLi4uYXJnczogYW55W10pID0+IFI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlKC4uLmZ1bmNzOiBGdW5jdGlvbltdKSB7XG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBpbmZlciB0aGUgYXJndW1lbnQgdHlwZSBzbyBpdCBpcyB1c2FibGUgaW4gaW5mZXJlbmNlIGRvd24gdGhlIGxpbmVcbiAgICByZXR1cm4gPFQsPihhcmc6IFQpID0+IGFyZztcbiAgfVxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmNzWzBdO1xuICB9XG4gIHJldHVybiBmdW5jcy5yZWR1Y2UoKGEsIGIpID0+ICguLi5hcmdzOiBhbnkpID0+IGEoYiguLi5hcmdzKSkpO1xufSIsImltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UgfSBmcm9tIFwic3JjL3V0aWxzL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2VcIjtcbmltcG9ydCBjb21wb3NlIGZyb20gJy4vY29tcG9zZSc7XG5pbXBvcnQgeyBNaWRkbGV3YXJlLCBNaWRkbGV3YXJlQVBJIH0gZnJvbSAnLi90eXBlcy9taWRkbGV3YXJlJztcbmltcG9ydCB7IFN0b3JlRW5oYW5jZXIsIERpc3BhdGNoIH0gZnJvbSAnLi90eXBlcy9zdG9yZSc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0b3JlIGVuaGFuY2VyIHRoYXQgYXBwbGllcyBtaWRkbGV3YXJlIHRvIHRoZSBkaXNwYXRjaCBtZXRob2RcbiAqIG9mIHRoZSBSZWR1eCBzdG9yZS4gVGhpcyBpcyBoYW5keSBmb3IgYSB2YXJpZXR5IG9mIHRhc2tzLCBzdWNoIGFzIGV4cHJlc3NpbmdcbiAqIGFzeW5jaHJvbm91cyBhY3Rpb25zIGluIGEgY29uY2lzZSBtYW5uZXIsIG9yIGxvZ2dpbmcgZXZlcnkgYWN0aW9uIHBheWxvYWQuXG4gKlxuICogU2VlIGByZWR1eC10aHVua2AgcGFja2FnZSBhcyBhbiBleGFtcGxlIG9mIHRoZSBSZWR1eCBtaWRkbGV3YXJlLlxuICpcbiAqIEJlY2F1c2UgbWlkZGxld2FyZSBpcyBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMsIHRoaXMgc2hvdWxkIGJlIHRoZSBmaXJzdFxuICogc3RvcmUgZW5oYW5jZXIgaW4gdGhlIGNvbXBvc2l0aW9uIGNoYWluLlxuICpcbiAqIE5vdGUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgd2lsbCBiZSBnaXZlbiB0aGUgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBmdW5jdGlvbnNcbiAqIGFzIG5hbWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gbWlkZGxld2FyZXMgVGhlIG1pZGRsZXdhcmUgY2hhaW4gdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm5zIEEgc3RvcmUgZW5oYW5jZXIgYXBwbHlpbmcgdGhlIG1pZGRsZXdhcmUuXG4gKlxuICogQHRlbXBsYXRlIEV4dCBEaXNwYXRjaCBzaWduYXR1cmUgYWRkZWQgYnkgYSBtaWRkbGV3YXJlLlxuICogQHRlbXBsYXRlIFMgVGhlIHR5cGUgb2YgdGhlIHN0YXRlIHN1cHBvcnRlZCBieSBhIG1pZGRsZXdhcmUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSgpOiBTdG9yZUVuaGFuY2VyO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlPEV4dDEsIFM+KG1pZGRsZXdhcmUxOiBNaWRkbGV3YXJlPEV4dDEsIFMsIGFueT4pOiBTdG9yZUVuaGFuY2VyPHtcbiAgZGlzcGF0Y2g6IEV4dDE7XG59PjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZTxFeHQxLCBFeHQyLCBTPihtaWRkbGV3YXJlMTogTWlkZGxld2FyZTxFeHQxLCBTLCBhbnk+LCBtaWRkbGV3YXJlMjogTWlkZGxld2FyZTxFeHQyLCBTLCBhbnk+KTogU3RvcmVFbmhhbmNlcjx7XG4gIGRpc3BhdGNoOiBFeHQxICYgRXh0Mjtcbn0+O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlPEV4dDEsIEV4dDIsIEV4dDMsIFM+KG1pZGRsZXdhcmUxOiBNaWRkbGV3YXJlPEV4dDEsIFMsIGFueT4sIG1pZGRsZXdhcmUyOiBNaWRkbGV3YXJlPEV4dDIsIFMsIGFueT4sIG1pZGRsZXdhcmUzOiBNaWRkbGV3YXJlPEV4dDMsIFMsIGFueT4pOiBTdG9yZUVuaGFuY2VyPHtcbiAgZGlzcGF0Y2g6IEV4dDEgJiBFeHQyICYgRXh0Mztcbn0+O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlPEV4dDEsIEV4dDIsIEV4dDMsIEV4dDQsIFM+KG1pZGRsZXdhcmUxOiBNaWRkbGV3YXJlPEV4dDEsIFMsIGFueT4sIG1pZGRsZXdhcmUyOiBNaWRkbGV3YXJlPEV4dDIsIFMsIGFueT4sIG1pZGRsZXdhcmUzOiBNaWRkbGV3YXJlPEV4dDMsIFMsIGFueT4sIG1pZGRsZXdhcmU0OiBNaWRkbGV3YXJlPEV4dDQsIFMsIGFueT4pOiBTdG9yZUVuaGFuY2VyPHtcbiAgZGlzcGF0Y2g6IEV4dDEgJiBFeHQyICYgRXh0MyAmIEV4dDQ7XG59PjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZTxFeHQxLCBFeHQyLCBFeHQzLCBFeHQ0LCBFeHQ1LCBTPihtaWRkbGV3YXJlMTogTWlkZGxld2FyZTxFeHQxLCBTLCBhbnk+LCBtaWRkbGV3YXJlMjogTWlkZGxld2FyZTxFeHQyLCBTLCBhbnk+LCBtaWRkbGV3YXJlMzogTWlkZGxld2FyZTxFeHQzLCBTLCBhbnk+LCBtaWRkbGV3YXJlNDogTWlkZGxld2FyZTxFeHQ0LCBTLCBhbnk+LCBtaWRkbGV3YXJlNTogTWlkZGxld2FyZTxFeHQ1LCBTLCBhbnk+KTogU3RvcmVFbmhhbmNlcjx7XG4gIGRpc3BhdGNoOiBFeHQxICYgRXh0MiAmIEV4dDMgJiBFeHQ0ICYgRXh0NTtcbn0+O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlPEV4dCwgUyA9IGFueT4oLi4ubWlkZGxld2FyZXM6IE1pZGRsZXdhcmU8YW55LCBTLCBhbnk+W10pOiBTdG9yZUVuaGFuY2VyPHtcbiAgZGlzcGF0Y2g6IEV4dDtcbn0+O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzOiBNaWRkbGV3YXJlW10pOiBTdG9yZUVuaGFuY2VyPGFueT4ge1xuICByZXR1cm4gY3JlYXRlU3RvcmUgPT4gKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSk7XG4gICAgbGV0IGRpc3BhdGNoOiBEaXNwYXRjaCA9ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNSkgOiAnRGlzcGF0Y2hpbmcgd2hpbGUgY29uc3RydWN0aW5nIHlvdXIgbWlkZGxld2FyZSBpcyBub3QgYWxsb3dlZC4gJyArICdPdGhlciBtaWRkbGV3YXJlIHdvdWxkIG5vdCBiZSBhcHBsaWVkIHRvIHRoaXMgZGlzcGF0Y2guJyk7XG4gICAgfTtcbiAgICBjb25zdCBtaWRkbGV3YXJlQVBJOiBNaWRkbGV3YXJlQVBJID0ge1xuICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgZGlzcGF0Y2g6IChhY3Rpb24sIC4uLmFyZ3MpID0+IGRpc3BhdGNoKGFjdGlvbiwgLi4uYXJncylcbiAgICB9O1xuICAgIGNvbnN0IGNoYWluID0gbWlkZGxld2FyZXMubWFwKG1pZGRsZXdhcmUgPT4gbWlkZGxld2FyZShtaWRkbGV3YXJlQVBJKSk7XG4gICAgZGlzcGF0Y2ggPSBjb21wb3NlPHR5cGVvZiBkaXNwYXRjaD4oLi4uY2hhaW4pKHN0b3JlLmRpc3BhdGNoKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RvcmUsXG4gICAgICBkaXNwYXRjaFxuICAgIH07XG4gIH07XG59IiwiaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi4vdHlwZXMvYWN0aW9ucyc7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL2lzUGxhaW5PYmplY3QnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNBY3Rpb24oYWN0aW9uOiB1bmtub3duKTogYWN0aW9uIGlzIEFjdGlvbjxzdHJpbmc+IHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoYWN0aW9uKSAmJiAndHlwZScgaW4gYWN0aW9uICYmIHR5cGVvZiAoYWN0aW9uIGFzIFJlY29yZDwndHlwZScsIHVua25vd24+KS50eXBlID09PSAnc3RyaW5nJztcbn0iXSwibmFtZXMiOlsiY3JlYXRlU3RvcmUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBSTRDTSxRQUFRLElBQUksYUFBYTtBSnJDeEIsU0FBUyx1QkFBdUIsSUFBQSxFQUFjO0lBQ25ELE9BQU8sZ0NBQXlCLElBQUksRUFBQSw2Q0FBZ0QsT0FBSixJQUFJLEVBQUE7QUFDdEY7O0FDSkEsSUFBTSxlQUErQixhQUFBLEdBQUEsQ0FBQSxJQUFNLE9BQU8sV0FBVyxjQUFjLE9BQU8sVUFBQSxJQUFjLGNBQUEsRUFBZ0I7QUFDaEgsSUFBTyw0QkFBUTs7QUNDZixJQUFNLGVBQWUsSUFBTSxLQUFLLE1BQUEsQ0FBTyxFQUFFLFFBQUEsQ0FBUyxFQUFFLEVBQUUsU0FBQSxDQUFVLENBQUMsRUFBRSxLQUFBLENBQU0sRUFBRSxFQUFFLElBQUEsQ0FBSyxHQUFHO0FBQ3JGLElBQU0sY0FBYztJQUNsQixNQUFNLGVBQTRDLE9BQWQsYUFBQSxHQUFBLGFBQWEsQ0FBQztJQUNsRCxTQUFTLGtCQUErQyxPQUFkLGFBQUEsR0FBQSxhQUFhLENBQUM7SUFDeEQs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LE1BQU0sTUFBQSxLQUFXLEdBQUc7UUFDdEIsT0FBTyxLQUFBLENBQU0sQ0FBQyxDQUFBO0lBQ2hCO0lBQ0EsT0FBTyxNQUFNLE1BQUEsQ0FBTyxDQUFDLEdBQUcsSUFBTTs7Z0JBQUk7O21CQUFjLEVBQUUsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDOztBQUMvRDs7QUNPZSxTQUFSO0lBQUEsSUFBQSxJQUFBLE9BQUEsVUFBQSxRQUFBLEFBQW9DLGNBQXBDLFVBQUEsT0FBQSxPQUFBLEdBQUEsT0FBQSxNQUFBO29CQUFBLFFBQUEsU0FBQSxDQUFBLEtBQW9DLEVBQStDOztJQUN4RixPQUFPLENBQUFBLGVBQWUsQ0FBQyxTQUFTLG1CQUFtQjtZQUNqRCxNQUFNLFFBQVFBLGFBQVksU0FBUyxjQUFjO1lBQ2pELElBQUksV0FBcUIsTUFBTTtnQkFDN0IsTUFBTSxJQUFJLE1BQU0sUUFBUSxJQUFJLGFBQWEsYUFBZSx1QkFBd0IsRUFBRSxDQUFJLHdIQUE2SDtZQUNyTjtZQUNBLE1BQU0sZ0JBQStCO2dCQUNuQyxVQUFVLE1BQU0sUUFBQTtnQkFDaEIsVUFBVSxTQUFDOzt3QkFBVzs7MkJBQVMsU0FBUyxRQUFRLEdBQUcsSUFBSTs7WUFDekQ7WUFDQSxNQUFNLFFBQVEsWUFBWSxHQUFBLENBQUksQ0FBQSxhQUFjLFdBQVcsYUFBYSxDQUFDO1lBQ3JFLFdBQVcsUUFBeUIsR0FBRyxLQUFLLEVBQUUsTUFBTSxRQUFRO1lBQzVELE9BQU87Z0JBQ0wsR0FBRyxLQUFBO2dCQUNIO1lBQ0Y7UUFDRjtBQUNGOztBQzFEZSxTQUFSLFNBQTBCLE1BQUEsRUFBMkM7SUFDMUUsT0FBTyxjQUFjLE1BQU0sS0FBSyxVQUFVLFVBQVUsT0FBUSxPQUFtQyxJQUFBLEtBQVM7QUFDMUciLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEwNTYyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3JlZHV4LXRodW5rL2Rpc3QvcmVkdXgtdGh1bmsubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmRleC50c1xuZnVuY3Rpb24gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKGV4dHJhQXJndW1lbnQpIHtcbiAgY29uc3QgbWlkZGxld2FyZSA9ICh7IGRpc3BhdGNoLCBnZXRTdGF0ZSB9KSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhY3Rpb24oZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYUFyZ3VtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgfTtcbiAgcmV0dXJuIG1pZGRsZXdhcmU7XG59XG52YXIgdGh1bmsgPSBjcmVhdGVUaHVua01pZGRsZXdhcmUoKTtcbnZhciB3aXRoRXh0cmFBcmd1bWVudCA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZTtcbmV4cG9ydCB7XG4gIHRodW5rLFxuICB3aXRoRXh0cmFBcmd1bWVudFxufTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxlQUFlOzs7OztBQUNmLFNBQVMsc0JBQXNCLGFBQWE7SUFDMUMsTUFBTSxhQUFhO1lBQUMsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFO2VBQUssQ0FBQyxPQUFTLENBQUM7Z0JBQ3hELElBQUksT0FBTyxXQUFXLFlBQVk7b0JBQ2hDLE9BQU8sT0FBTyxVQUFVLFVBQVU7Z0JBQ3BDO2dCQUNBLE9BQU8sS0FBSztZQUNkOztJQUNBLE9BQU87QUFDVDtBQUNBLElBQUksUUFBUTtBQUNaLElBQUksb0JBQW9CIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEwNTg2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvaW5kZXgudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9jcmVhdGVEcmFmdFNhZmVTZWxlY3Rvci50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL2NvbmZpZ3VyZVN0b3JlLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvZGV2dG9vbHNFeHRlbnNpb24udHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL2NyZWF0ZUFjdGlvbi50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL3RzSGVscGVycy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL2FjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvdXRpbHMudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9hdXRvQmF0Y2hFbmhhbmNlci50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL2dldERlZmF1bHRFbmhhbmNlcnMudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9jcmVhdGVSZWR1Y2VyLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvbWFwQnVpbGRlcnMudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9tYXRjaGVycy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL25hbm9pZC50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL2NyZWF0ZUFzeW5jVGh1bmsudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9jcmVhdGVTbGljZS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL2VudGl0aWVzL2VudGl0eV9zdGF0ZS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL2VudGl0aWVzL3N0YXRlX3NlbGVjdG9ycy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL2VudGl0aWVzL3N0YXRlX2FkYXB0ZXIudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9lbnRpdGllcy91dGlscy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL2VudGl0aWVzL3Vuc29ydGVkX3N0YXRlX2FkYXB0ZXIudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9lbnRpdGllcy9zb3J0ZWRfc3RhdGVfYWRhcHRlci50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL2VudGl0aWVzL2NyZWF0ZV9hZGFwdGVyLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2luZGV4LnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2V4Y2VwdGlvbnMudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9saXN0ZW5lck1pZGRsZXdhcmUvdXRpbHMudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9saXN0ZW5lck1pZGRsZXdhcmUvdGFzay50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL2R5bmFtaWNNaWRkbGV3YXJlL2luZGV4LnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvY29tYmluZVNsaWNlcy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBtdXN0IHJlbWFpbiBoZXJlIHNvIHRoYXQgdGhlIGBtYW5nbGVFcnJvcnMuY2pzYCBidWlsZCBzY3JpcHRcbi8vIGRvZXMgbm90IGhhdmUgdG8gaW1wb3J0IHRoaXMgaW50byBlYWNoIHNvdXJjZSBmaWxlIGl0IHJld3JpdGVzLlxuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gJy4vZm9ybWF0UHJvZEVycm9yTWVzc2FnZSc7XG5leHBvcnQgKiBmcm9tICdyZWR1eCc7XG5leHBvcnQgeyBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZSwgY3VycmVudCwgZnJlZXplLCBvcmlnaW5hbCwgaXNEcmFmdCB9IGZyb20gJ2ltbWVyJztcbmV4cG9ydCB0eXBlIHsgRHJhZnQgfSBmcm9tICdpbW1lcic7XG5leHBvcnQgeyBjcmVhdGVTZWxlY3RvciwgY3JlYXRlU2VsZWN0b3JDcmVhdG9yLCBscnVNZW1vaXplLCB3ZWFrTWFwTWVtb2l6ZSB9IGZyb20gJ3Jlc2VsZWN0JztcbmV4cG9ydCB0eXBlIHsgU2VsZWN0b3IsIE91dHB1dFNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnO1xuZXhwb3J0IHsgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IsIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvciB9IGZyb20gJy4vY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3InO1xuZXhwb3J0IHR5cGUgeyBUaHVua0FjdGlvbiwgVGh1bmtEaXNwYXRjaCwgVGh1bmtNaWRkbGV3YXJlIH0gZnJvbSAncmVkdXgtdGh1bmsnO1xuZXhwb3J0IHtcbi8vIGpzXG5jb25maWd1cmVTdG9yZSB9IGZyb20gJy4vY29uZmlndXJlU3RvcmUnO1xuZXhwb3J0IHR5cGUge1xuLy8gdHlwZXNcbkNvbmZpZ3VyZVN0b3JlT3B0aW9ucywgRW5oYW5jZWRTdG9yZSB9IGZyb20gJy4vY29uZmlndXJlU3RvcmUnO1xuZXhwb3J0IHR5cGUgeyBEZXZUb29sc0VuaGFuY2VyT3B0aW9ucyB9IGZyb20gJy4vZGV2dG9vbHNFeHRlbnNpb24nO1xuZXhwb3J0IHtcbi8vIGpzXG5jcmVhdGVBY3Rpb24sIGlzQWN0aW9uQ3JlYXRvciwgaXNGU0EgYXMgaXNGbHV4U3RhbmRhcmRBY3Rpb24gfSBmcm9tICcuL2NyZWF0ZUFjdGlvbic7XG5leHBvcnQgdHlwZSB7XG4vLyB0eXBlc1xuUGF5bG9hZEFjdGlvbiwgUGF5bG9hZEFjdGlvbkNyZWF0b3IsIEFjdGlvbkNyZWF0b3JXaXRoTm9uSW5mZXJyYWJsZVBheWxvYWQsIEFjdGlvbkNyZWF0b3JXaXRoT3B0aW9uYWxQYXlsb2FkLCBBY3Rpb25DcmVhdG9yV2l0aFBheWxvYWQsIEFjdGlvbkNyZWF0b3JXaXRob3V0UGF5bG9hZCwgQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQsIFByZXBhcmVBY3Rpb24gfSBmcm9tICcuL2NyZWF0ZUFjdGlvbic7XG5leHBvcnQge1xuLy8ganNcbmNyZWF0ZVJlZHVjZXIgfSBmcm9tICcuL2NyZWF0ZVJlZHVjZXInO1xuZXhwb3J0IHR5cGUge1xuLy8gdHlwZXNcbkFjdGlvbnMsIENhc2VSZWR1Y2VyLCBDYXNlUmVkdWNlcnMgfSBmcm9tICcuL2NyZWF0ZVJlZHVjZXInO1xuZXhwb3J0IHtcbi8vIGpzXG5jcmVhdGVTbGljZSwgYnVpbGRDcmVhdGVTbGljZSwgYXN5bmNUaHVua0NyZWF0b3IsIFJlZHVjZXJUeXBlIH0gZnJvbSAnLi9jcmVhdGVTbGljZSc7XG5leHBvcnQgdHlwZSB7XG4vLyB0eXBlc1xuQ3JlYXRlU2xpY2VPcHRpb25zLCBTbGljZSwgQ2FzZVJlZHVjZXJBY3Rpb25zLCBTbGljZUNhc2VSZWR1Y2VycywgVmFsaWRhdGVTbGljZUNhc2VSZWR1Y2VycywgQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZSwgUmVkdWNlckNyZWF0b3JzLCBTbGljZVNlbGVjdG9ycyB9IGZyb20gJy4vY3JlYXRlU2xpY2UnO1xuZXhwb3J0IHR5cGUgeyBBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMgfSBmcm9tICcuL2FjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlJztcbmV4cG9ydCB7IGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlIH0gZnJvbSAnLi9hY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZSc7XG5leHBvcnQge1xuLy8ganNcbmNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSwgaXNJbW11dGFibGVEZWZhdWx0IH0gZnJvbSAnLi9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUnO1xuZXhwb3J0IHR5cGUge1xuLy8gdHlwZXNcbkltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMgfSBmcm9tICcuL2ltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSc7XG5leHBvcnQge1xuLy8ganNcbmNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSwgZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlLCBpc1BsYWluIH0gZnJvbSAnLi9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUnO1xuZXhwb3J0IHR5cGUge1xuLy8gdHlwZXNcblNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMgfSBmcm9tICcuL3NlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSc7XG5leHBvcnQgdHlwZSB7XG4vLyB0eXBlc1xuQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXIgfSBmcm9tICcuL21hcEJ1aWxkZXJzJztcbmV4cG9ydCB7IFR1cGxlIH0gZnJvbSAnLi91dGlscyc7XG5leHBvcnQgeyBjcmVhdGVFbnRpdHlBZGFwdGVyIH0gZnJvbSAnLi9lbnRpdGllcy9jcmVhdGVfYWRhcHRlcic7XG5leHBvcnQgdHlwZSB7IEVudGl0eVN0YXRlLCBFbnRpdHlBZGFwdGVyLCBFbnRpdHlTZWxlY3RvcnMsIEVudGl0eVN0YXRlQWRhcHRlciwgRW50aXR5SWQsIFVwZGF0ZSwgSWRTZWxlY3RvciwgQ29tcGFyZXIgfSBmcm9tICcuL2VudGl0aWVzL21vZGVscyc7XG5leHBvcnQgeyBjcmVhdGVBc3luY1RodW5rLCB1bndyYXBSZXN1bHQsIG1pbmlTZXJpYWxpemVFcnJvciB9IGZyb20gJy4vY3JlYXRlQXN5bmNUaHVuayc7XG5leHBvcnQgdHlwZSB7IEFzeW5jVGh1bmssIEFzeW5jVGh1bmtPcHRpb25zLCBBc3luY1RodW5rQWN0aW9uLCBBc3luY1RodW5rUGF5bG9hZENyZWF0b3JSZXR1cm5WYWx1ZSwgQXN5bmNUaHVua1BheWxvYWRDcmVhdG9yLCBHZXRTdGF0ZSwgR2V0VGh1bmtBUEksIFNlcmlhbGl6ZWRFcnJvciwgQ3JlYXRlQXN5bmNUaHVua0Z1bmN0aW9uIH0gZnJvbSAnLi9jcmVhdGVBc3luY1RodW5rJztcbmV4cG9ydCB7XG4vLyBqc1xuaXNBbGxPZiwgaXNBbnlPZiwgaXNQZW5kaW5nLCBpc1JlamVjdGVkLCBpc0Z1bGZpbGxlZCwgaXNBc3luY1RodW5rQWN0aW9uLCBpc1JlamVjdGVkV2l0aFZhbHVlIH0gZnJvbSAnLi9tYXRjaGVycyc7XG5leHBvcnQgdHlwZSB7XG4vLyB0eXBlc1xuQWN0aW9uTWF0Y2hpbmdBbGxPZiwgQWN0aW9uTWF0Y2hpbmdBbnlPZiB9IGZyb20gJy4vbWF0Y2hlcnMnO1xuZXhwb3J0IHsgbmFub2lkIH0gZnJvbSAnLi9uYW5vaWQnO1xuZXhwb3J0IHR5cGUgeyBMaXN0ZW5lckVmZmVjdCwgTGlzdGVuZXJNaWRkbGV3YXJlLCBMaXN0ZW5lckVmZmVjdEFQSSwgTGlzdGVuZXJNaWRkbGV3YXJlSW5zdGFuY2UsIENyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZU9wdGlvbnMsIExpc3RlbmVyRXJyb3JIYW5kbGVyLCBUeXBlZFN0YXJ0TGlzdGVuaW5nLCBUeXBlZEFkZExpc3RlbmVyLCBUeXBlZFN0b3BMaXN0ZW5pbmcsIFR5cGVkUmVtb3ZlTGlzdGVuZXIsIFVuc3Vic2NyaWJlTGlzdGVuZXIsIFVuc3Vic2NyaWJlTGlzdGVuZXJPcHRpb25zLCBGb3JrZWRUYXNrRXhlY3V0b3IsIEZvcmtlZFRhc2ssIEZvcmtlZFRhc2tBUEksIEFzeW5jVGFza0V4ZWN1dG9yLCBTeW5jVGFza0V4ZWN1dG9yLCBUYXNrQ2FuY2VsbGVkLCBUYXNrUmVqZWN0ZWQsIFRhc2tSZXNvbHZlZCwgVGFza1Jlc3VsdCB9IGZyb20gJy4vbGlzdGVuZXJNaWRkbGV3YXJlL2luZGV4JztcbmV4cG9ydCB0eXBlIHsgQW55TGlzdGVuZXJQcmVkaWNhdGUgfSBmcm9tICcuL2xpc3RlbmVyTWlkZGxld2FyZS90eXBlcyc7XG5leHBvcnQgeyBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUsIGFkZExpc3RlbmVyLCByZW1vdmVMaXN0ZW5lciwgY2xlYXJBbGxMaXN0ZW5lcnMsIFRhc2tBYm9ydEVycm9yIH0gZnJvbSAnLi9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgnO1xuZXhwb3J0IHR5cGUgeyBBZGRNaWRkbGV3YXJlLCBEeW5hbWljRGlzcGF0Y2gsIER5bmFtaWNNaWRkbGV3YXJlSW5zdGFuY2UsIEdldERpc3BhdGNoVHlwZSBhcyBHZXREaXNwYXRjaCwgTWlkZGxld2FyZUFwaUNvbmZpZyB9IGZyb20gJy4vZHluYW1pY01pZGRsZXdhcmUvdHlwZXMnO1xuZXhwb3J0IHsgY3JlYXRlRHluYW1pY01pZGRsZXdhcmUgfSBmcm9tICcuL2R5bmFtaWNNaWRkbGV3YXJlL2luZGV4JztcbmV4cG9ydCB7IFNIT1VMRF9BVVRPQkFUQ0gsIHByZXBhcmVBdXRvQmF0Y2hlZCwgYXV0b0JhdGNoRW5oYW5jZXIgfSBmcm9tICcuL2F1dG9CYXRjaEVuaGFuY2VyJztcbmV4cG9ydCB0eXBlIHsgQXV0b0JhdGNoT3B0aW9ucyB9IGZyb20gJy4vYXV0b0JhdGNoRW5oYW5jZXInO1xuZXhwb3J0IHsgY29tYmluZVNsaWNlcyB9IGZyb20gJy4vY29tYmluZVNsaWNlcyc7XG5leHBvcnQgdHlwZSB7IENvbWJpbmVkU2xpY2VSZWR1Y2VyLCBXaXRoU2xpY2UgfSBmcm9tICcuL2NvbWJpbmVTbGljZXMnO1xuZXhwb3J0IHR5cGUgeyBFeHRyYWN0RGlzcGF0Y2hFeHRlbnNpb25zIGFzIFRTSGVscGVyc0V4dHJhY3REaXNwYXRjaEV4dGVuc2lvbnMsIFNhZmVQcm9taXNlIH0gZnJvbSAnLi90c0hlbHBlcnMnO1xuZXhwb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gJy4vZm9ybWF0UHJvZEVycm9yTWVzc2FnZSc7IiwiaW1wb3J0IHsgY3VycmVudCwgaXNEcmFmdCB9IGZyb20gJ2ltbWVyJztcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvciwgd2Vha01hcE1lbW9pemUgfSBmcm9tICdyZXNlbGVjdCc7XG5leHBvcnQgY29uc3QgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JDcmVhdG9yOiB0eXBlb2YgY3JlYXRlU2VsZWN0b3JDcmVhdG9yID0gKC4uLmFyZ3M6IHVua25vd25bXSkgPT4ge1xuICBjb25zdCBjcmVhdGVTZWxlY3RvciA9IChjcmVhdGVTZWxlY3RvckNyZWF0b3IgYXMgYW55KSguLi5hcmdzKTtcbiAgY29uc3QgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IgPSBPYmplY3QuYXNzaWduKCguLi5hcmdzOiB1bmtub3duW10pID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yKC4uLmFyZ3MpO1xuICAgIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9ICh2YWx1ZTogdW5rbm93biwgLi4ucmVzdDogdW5rbm93bltdKSA9PiBzZWxlY3Rvcihpc0RyYWZ0KHZhbHVlKSA/IGN1cnJlbnQodmFsdWUpIDogdmFsdWUsIC4uLnJlc3QpO1xuICAgIE9iamVjdC5hc3NpZ24od3JhcHBlZFNlbGVjdG9yLCBzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHdyYXBwZWRTZWxlY3RvciBhcyBhbnk7XG4gIH0sIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yXG4gIH0pO1xuICByZXR1cm4gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3I7XG59O1xuXG4vKipcbiAqIFwiRHJhZnQtU2FmZVwiIHZlcnNpb24gb2YgYHJlc2VsZWN0YCdzIGBjcmVhdGVTZWxlY3RvcmA6XG4gKiBJZiBhbiBgaW1tZXJgLWRyYWZ0ZWQgb2JqZWN0IGlzIHBhc3NlZCBpbnRvIHRoZSByZXN1bHRpbmcgc2VsZWN0b3IncyBmaXJzdCBhcmd1bWVudCxcbiAqIHRoZSBzZWxlY3RvciB3aWxsIGFjdCBvbiB0aGUgY3VycmVudCBkcmFmdCB2YWx1ZSwgaW5zdGVhZCBvZiByZXR1cm5pbmcgYSBjYWNoZWQgdmFsdWVcbiAqIHRoYXQgbWlnaHQgYmUgcG9zc2libHkgb3V0ZGF0ZWQgaWYgdGhlIGRyYWZ0IGhhcyBiZWVuIG1vZGlmaWVkIHNpbmNlLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IgPSAvKiBAX19QVVJFX18gKi9cbmNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvcih3ZWFrTWFwTWVtb2l6ZSk7IiwiaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSwgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIsIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzLCBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCwgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTUsIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U2LCBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNywgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTggfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHR5cGUgeyBSZWR1Y2VyLCBSZWR1Y2Vyc01hcE9iamVjdCwgTWlkZGxld2FyZSwgQWN0aW9uLCBTdG9yZUVuaGFuY2VyLCBTdG9yZSwgVW5rbm93bkFjdGlvbiB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IGFwcGx5TWlkZGxld2FyZSwgY3JlYXRlU3RvcmUsIGNvbXBvc2UsIGNvbWJpbmVSZWR1Y2VycywgaXNQbGFpbk9iamVjdCB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB0eXBlIHsgRGV2VG9vbHNFbmhhbmNlck9wdGlvbnMgYXMgRGV2VG9vbHNPcHRpb25zIH0gZnJvbSAnLi9kZXZ0b29sc0V4dGVuc2lvbic7XG5pbXBvcnQgeyBjb21wb3NlV2l0aERldlRvb2xzIH0gZnJvbSAnLi9kZXZ0b29sc0V4dGVuc2lvbic7XG5pbXBvcnQgdHlwZSB7IFRodW5rTWlkZGxld2FyZUZvciwgR2V0RGVmYXVsdE1pZGRsZXdhcmUgfSBmcm9tICcuL2dldERlZmF1bHRNaWRkbGV3YXJlJztcbmltcG9ydCB7IGJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUgfSBmcm9tICcuL2dldERlZmF1bHRNaWRkbGV3YXJlJztcbmltcG9ydCB0eXBlIHsgRXh0cmFjdERpc3BhdGNoRXh0ZW5zaW9ucywgRXh0cmFjdFN0b3JlRXh0ZW5zaW9ucywgRXh0cmFjdFN0YXRlRXh0ZW5zaW9ucywgVW5rbm93bklmTm9uU3BlY2lmaWMgfSBmcm9tICcuL3RzSGVscGVycyc7XG5pbXBvcnQgdHlwZSB7IFR1cGxlIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IEdldERlZmF1bHRFbmhhbmNlcnMgfSBmcm9tICcuL2dldERlZmF1bHRFbmhhbmNlcnMnO1xuaW1wb3J0IHsgYnVpbGRHZXREZWZhdWx0RW5oYW5jZXJzIH0gZnJvbSAnLi9nZXREZWZhdWx0RW5oYW5jZXJzJztcblxuLyoqXG4gKiBPcHRpb25zIGZvciBgY29uZmlndXJlU3RvcmUoKWAuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbmZpZ3VyZVN0b3JlT3B0aW9uczxTID0gYW55LCBBIGV4dGVuZHMgQWN0aW9uID0gVW5rbm93bkFjdGlvbiwgTSBleHRlbmRzIFR1cGxlPE1pZGRsZXdhcmVzPFM+PiA9IFR1cGxlPE1pZGRsZXdhcmVzPFM+PiwgRSBleHRlbmRzIFR1cGxlPEVuaGFuY2Vycz4gPSBUdXBsZTxFbmhhbmNlcnM+LCBQID0gUz4ge1xuICAvKipcbiAgICogQSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGUgcm9vdCByZWR1Y2VyLCBvciBhblxuICAgKiBvYmplY3Qgb2Ygc2xpY2UgcmVkdWNlcnMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byBgY29tYmluZVJlZHVjZXJzKClgLlxuICAgKi9cbiAgcmVkdWNlcjogUmVkdWNlcjxTLCBBLCBQPiB8IFJlZHVjZXJzTWFwT2JqZWN0PFMsIEEsIFA+O1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBSZWR1eCBtaWRkbGV3YXJlIHRvIGluc3RhbGwsIG9yIGEgY2FsbGJhY2sgcmVjZWl2aW5nIGBnZXREZWZhdWx0TWlkZGxld2FyZWAgYW5kIHJldHVybmluZyBhIFR1cGxlIG9mIG1pZGRsZXdhcmUuXG4gICAqIElmIG5vdCBzdXBwbGllZCwgZGVmYXVsdHMgdG8gdGhlIHNldCBvZiBtaWRkbGV3YXJlIHJldHVybmVkIGJ5IGBnZXREZWZhdWx0TWlkZGxld2FyZSgpYC5cbiAgICpcbiAgICogQGV4YW1wbGUgYG1pZGRsZXdhcmU6IChnRE0pID0+IGdETSgpLmNvbmNhdChsb2dnZXIsIGFwaU1pZGRsZXdhcmUsIHlvdXJDdXN0b21NaWRkbGV3YXJlKWBcbiAgICogQHNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9nZXREZWZhdWx0TWlkZGxld2FyZSNpbnRlbmRlZC11c2FnZVxuICAgKi9cbiAgbWlkZGxld2FyZT86IChnZXREZWZhdWx0TWlkZGxld2FyZTogR2V0RGVmYXVsdE1pZGRsZXdhcmU8Uz4pID0+IE07XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIFJlZHV4IERldlRvb2xzIGludGVncmF0aW9uLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqXG4gICAqIEFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBjYW4gYmUgZG9uZSBieSBwYXNzaW5nIFJlZHV4IERldlRvb2xzIG9wdGlvbnNcbiAgICovXG4gIGRldlRvb2xzPzogYm9vbGVhbiB8IERldlRvb2xzT3B0aW9ucztcblxuICAvKipcbiAgICogV2hldGhlciB0byBjaGVjayBmb3IgZHVwbGljYXRlIG1pZGRsZXdhcmUgaW5zdGFuY2VzLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqL1xuICBkdXBsaWNhdGVNaWRkbGV3YXJlQ2hlY2s/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5pdGlhbCBzdGF0ZSwgc2FtZSBhcyBSZWR1eCdzIGNyZWF0ZVN0b3JlLlxuICAgKiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdCB0byBoeWRyYXRlIHRoZSBzdGF0ZVxuICAgKiBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYSBwcmV2aW91c2x5IHNlcmlhbGl6ZWRcbiAgICogdXNlciBzZXNzaW9uLiBJZiB5b3UgdXNlIGBjb21iaW5lUmVkdWNlcnMoKWAgdG8gcHJvZHVjZSB0aGUgcm9vdCByZWR1Y2VyXG4gICAqIGZ1bmN0aW9uIChlaXRoZXIgZGlyZWN0bHkgb3IgaW5kaXJlY3RseSBieSBwYXNzaW5nIGFuIG9iamVjdCBhcyBgcmVkdWNlcmApLFxuICAgKiB0aGlzIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgdGhlIHJlZHVjZXIgbWFwIGtleXMuXG4gICAqL1xuICAvLyB3ZSBpbmZlciBoZXJlLCBhbmQgaW5zdGVhZCBjb21wbGFpbiBpZiB0aGUgcmVkdWNlciBkb2Vzbid0IG1hdGNoXG4gIHByZWxvYWRlZFN0YXRlPzogUDtcblxuICAvKipcbiAgICogVGhlIHN0b3JlIGVuaGFuY2VycyB0byBhcHBseS4gU2VlIFJlZHV4J3MgYGNyZWF0ZVN0b3JlKClgLlxuICAgKiBBbGwgZW5oYW5jZXJzIHdpbGwgYmUgaW5jbHVkZWQgYmVmb3JlIHRoZSBEZXZUb29scyBFeHRlbnNpb24gZW5oYW5jZXIuXG4gICAqIElmIHlvdSBuZWVkIHRvIGN1c3RvbWl6ZSB0aGUgb3JkZXIgb2YgZW5oYW5jZXJzLCBzdXBwbHkgYSBjYWxsYmFja1xuICAgKiBmdW5jdGlvbiB0aGF0IHdpbGwgcmVjZWl2ZSBhIGBnZXREZWZhdWx0RW5oYW5jZXJzYCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBUdXBsZSxcbiAgICogYW5kIHNob3VsZCByZXR1cm4gYSBUdXBsZSBvZiBlbmhhbmNlcnMgKHN1Y2ggYXMgYGdldERlZmF1bHRFbmhhbmNlcnMoKS5jb25jYXQob2ZmbGluZSlgKS5cbiAgICogSWYgeW91IG9ubHkgbmVlZCB0byBhZGQgbWlkZGxld2FyZSwgeW91IGNhbiB1c2UgdGhlIGBtaWRkbGV3YXJlYCBwYXJhbWV0ZXIgaW5zdGVhZC5cbiAgICovXG4gIGVuaGFuY2Vycz86IChnZXREZWZhdWx0RW5oYW5jZXJzOiBHZXREZWZhdWx0RW5oYW5jZXJzPE0+KSA9PiBFO1xufVxuZXhwb3J0IHR5cGUgTWlkZGxld2FyZXM8Uz4gPSBSZWFkb25seUFycmF5PE1pZGRsZXdhcmU8e30sIFM+PjtcbnR5cGUgRW5oYW5jZXJzID0gUmVhZG9ubHlBcnJheTxTdG9yZUVuaGFuY2VyPjtcblxuLyoqXG4gKiBBIFJlZHV4IHN0b3JlIHJldHVybmVkIGJ5IGBjb25maWd1cmVTdG9yZSgpYC4gU3VwcG9ydHMgZGlzcGF0Y2hpbmdcbiAqIHNpZGUtZWZmZWN0ZnVsIF90aHVua3NfIGluIGFkZGl0aW9uIHRvIHBsYWluIGFjdGlvbnMuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBFbmhhbmNlZFN0b3JlPFMgPSBhbnksIEEgZXh0ZW5kcyBBY3Rpb24gPSBVbmtub3duQWN0aW9uLCBFIGV4dGVuZHMgRW5oYW5jZXJzID0gRW5oYW5jZXJzPiA9IEV4dHJhY3RTdG9yZUV4dGVuc2lvbnM8RT4gJiBTdG9yZTxTLCBBLCBVbmtub3duSWZOb25TcGVjaWZpYzxFeHRyYWN0U3RhdGVFeHRlbnNpb25zPEU+Pj47XG5cbi8qKlxuICogQSBmcmllbmRseSBhYnN0cmFjdGlvbiBvdmVyIHRoZSBzdGFuZGFyZCBSZWR1eCBgY3JlYXRlU3RvcmUoKWAgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgVGhlIHN0b3JlIGNvbmZpZ3VyYXRpb24uXG4gKiBAcmV0dXJucyBBIGNvbmZpZ3VyZWQgUmVkdXggc3RvcmUuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29uZmlndXJlU3RvcmU8UyA9IGFueSwgQSBleHRlbmRzIEFjdGlvbiA9IFVua25vd25BY3Rpb24sIE0gZXh0ZW5kcyBUdXBsZTxNaWRkbGV3YXJlczxTPj4gPSBUdXBsZTxbVGh1bmtNaWRkbGV3YXJlRm9yPFM+XT4sIEUgZXh0ZW5kcyBUdXBsZTxFbmhhbmNlcnM+ID0gVHVwbGU8W1N0b3JlRW5oYW5jZXI8e1xuICBkaXNwYXRjaDogRXh0cmFjdERpc3BhdGNoRXh0ZW5zaW9uczxNPjtcbn0+LCBTdG9yZUVuaGFuY2VyXT4sIFAgPSBTPihvcHRpb25zOiBDb25maWd1cmVTdG9yZU9wdGlvbnM8UywgQSwgTSwgRSwgUD4pOiBFbmhhbmNlZFN0b3JlPFMsIEEsIEU+IHtcbiAgY29uc3QgZ2V0RGVmYXVsdE1pZGRsZXdhcmUgPSBidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlPFM+KCk7XG4gIGNvbnN0IHtcbiAgICByZWR1Y2VyID0gdW5kZWZpbmVkLFxuICAgIG1pZGRsZXdhcmUsXG4gICAgZGV2VG9vbHMgPSB0cnVlLFxuICAgIGR1cGxpY2F0ZU1pZGRsZXdhcmVDaGVjayA9IHRydWUsXG4gICAgcHJlbG9hZGVkU3RhdGUgPSB1bmRlZmluZWQsXG4gICAgZW5oYW5jZXJzID0gdW5kZWZpbmVkXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgcm9vdFJlZHVjZXI6IFJlZHVjZXI8UywgQSwgUD47XG4gIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJvb3RSZWR1Y2VyID0gcmVkdWNlcjtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHJlZHVjZXIpKSB7XG4gICAgcm9vdFJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMocmVkdWNlcikgYXMgdW5rbm93biBhcyBSZWR1Y2VyPFMsIEEsIFA+O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxKSA6ICdgcmVkdWNlcmAgaXMgYSByZXF1aXJlZCBhcmd1bWVudCwgYW5kIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgb2YgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBjb21iaW5lUmVkdWNlcnMnKTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBtaWRkbGV3YXJlICYmIHR5cGVvZiBtaWRkbGV3YXJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMigyKSA6ICdgbWlkZGxld2FyZWAgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgbGV0IGZpbmFsTWlkZGxld2FyZTogVHVwbGU8TWlkZGxld2FyZXM8Uz4+O1xuICBpZiAodHlwZW9mIG1pZGRsZXdhcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmaW5hbE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlKGdldERlZmF1bHRNaWRkbGV3YXJlKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhQXJyYXkuaXNBcnJheShmaW5hbE1pZGRsZXdhcmUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzKDMpIDogJ3doZW4gdXNpbmcgYSBtaWRkbGV3YXJlIGJ1aWxkZXIgZnVuY3Rpb24sIGFuIGFycmF5IG9mIG1pZGRsZXdhcmUgbXVzdCBiZSByZXR1cm5lZCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmaW5hbE1pZGRsZXdhcmUgPSBnZXREZWZhdWx0TWlkZGxld2FyZSgpO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGZpbmFsTWlkZGxld2FyZS5zb21lKChpdGVtOiBhbnkpID0+IHR5cGVvZiBpdGVtICE9PSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTQoNCkgOiAnZWFjaCBtaWRkbGV3YXJlIHByb3ZpZGVkIHRvIGNvbmZpZ3VyZVN0b3JlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGR1cGxpY2F0ZU1pZGRsZXdhcmVDaGVjaykge1xuICAgIGxldCBtaWRkbGV3YXJlUmVmZXJlbmNlcyA9IG5ldyBTZXQ8TWlkZGxld2FyZTxhbnksIFM+PigpO1xuICAgIGZpbmFsTWlkZGxld2FyZS5mb3JFYWNoKG1pZGRsZXdhcmUgPT4ge1xuICAgICAgaWYgKG1pZGRsZXdhcmVSZWZlcmVuY2VzLmhhcyhtaWRkbGV3YXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U1KDQyKSA6ICdEdXBsaWNhdGUgbWlkZGxld2FyZSByZWZlcmVuY2VzIGZvdW5kIHdoZW4gY3JlYXRpbmcgdGhlIHN0b3JlLiBFbnN1cmUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgaXMgb25seSBpbmNsdWRlZCBvbmNlLicpO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZVJlZmVyZW5jZXMuYWRkKG1pZGRsZXdhcmUpO1xuICAgIH0pO1xuICB9XG4gIGxldCBmaW5hbENvbXBvc2UgPSBjb21wb3NlO1xuICBpZiAoZGV2VG9vbHMpIHtcbiAgICBmaW5hbENvbXBvc2UgPSBjb21wb3NlV2l0aERldlRvb2xzKHtcbiAgICAgIC8vIEVuYWJsZSBjYXB0dXJlIG9mIHN0YWNrIHRyYWNlcyBmb3IgZGlzcGF0Y2hlZCBSZWR1eCBhY3Rpb25zXG4gICAgICB0cmFjZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcbiAgICAgIC4uLih0eXBlb2YgZGV2VG9vbHMgPT09ICdvYmplY3QnICYmIGRldlRvb2xzKVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IG1pZGRsZXdhcmVFbmhhbmNlciA9IGFwcGx5TWlkZGxld2FyZSguLi5maW5hbE1pZGRsZXdhcmUpO1xuICBjb25zdCBnZXREZWZhdWx0RW5oYW5jZXJzID0gYnVpbGRHZXREZWZhdWx0RW5oYW5jZXJzPE0+KG1pZGRsZXdhcmVFbmhhbmNlcik7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVuaGFuY2VycyAmJiB0eXBlb2YgZW5oYW5jZXJzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNig1KSA6ICdgZW5oYW5jZXJzYCBmaWVsZCBtdXN0IGJlIGEgY2FsbGJhY2snKTtcbiAgfVxuICBsZXQgc3RvcmVFbmhhbmNlcnMgPSB0eXBlb2YgZW5oYW5jZXJzID09PSAnZnVuY3Rpb24nID8gZW5oYW5jZXJzKGdldERlZmF1bHRFbmhhbmNlcnMpIDogZ2V0RGVmYXVsdEVuaGFuY2VycygpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhQXJyYXkuaXNBcnJheShzdG9yZUVuaGFuY2VycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U3KDYpIDogJ2BlbmhhbmNlcnNgIGNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5Jyk7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RvcmVFbmhhbmNlcnMuc29tZSgoaXRlbTogYW55KSA9PiB0eXBlb2YgaXRlbSAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U4KDcpIDogJ2VhY2ggZW5oYW5jZXIgcHJvdmlkZWQgdG8gY29uZmlndXJlU3RvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZmluYWxNaWRkbGV3YXJlLmxlbmd0aCAmJiAhc3RvcmVFbmhhbmNlcnMuaW5jbHVkZXMobWlkZGxld2FyZUVuaGFuY2VyKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ21pZGRsZXdhcmVzIHdlcmUgcHJvdmlkZWQsIGJ1dCBtaWRkbGV3YXJlIGVuaGFuY2VyIHdhcyBub3QgaW5jbHVkZWQgaW4gZmluYWwgZW5oYW5jZXJzIC0gbWFrZSBzdXJlIHRvIGNhbGwgYGdldERlZmF1bHRFbmhhbmNlcnNgJyk7XG4gIH1cbiAgY29uc3QgY29tcG9zZWRFbmhhbmNlcjogU3RvcmVFbmhhbmNlcjxhbnk+ID0gZmluYWxDb21wb3NlKC4uLnN0b3JlRW5oYW5jZXJzKTtcbiAgcmV0dXJuIGNyZWF0ZVN0b3JlKHJvb3RSZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSBhcyBQLCBjb21wb3NlZEVuaGFuY2VyKTtcbn0iLCJpbXBvcnQgdHlwZSB7IEFjdGlvbiwgQWN0aW9uQ3JlYXRvciwgU3RvcmVFbmhhbmNlciB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IGNvbXBvc2UgfSBmcm9tICdyZWR1eCc7XG5cbi8qKlxyXG4gKiBAcHVibGljXHJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZXZUb29sc0VuaGFuY2VyT3B0aW9ucyB7XG4gIC8qKlxyXG4gICAqIHRoZSBpbnN0YW5jZSBuYW1lIHRvIGJlIHNob3dlZCBvbiB0aGUgbW9uaXRvciBwYWdlLiBEZWZhdWx0IHZhbHVlIGlzIGBkb2N1bWVudC50aXRsZWAuXHJcbiAgICogSWYgbm90IHNwZWNpZmllZCBhbmQgdGhlcmUncyBubyBkb2N1bWVudCB0aXRsZSwgaXQgd2lsbCBjb25zaXN0IG9mIGB0YWJJZGAgYW5kIGBpbnN0YW5jZUlkYC5cclxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbiAgLyoqXHJcbiAgICogYWN0aW9uIGNyZWF0b3JzIGZ1bmN0aW9ucyB0byBiZSBhdmFpbGFibGUgaW4gdGhlIERpc3BhdGNoZXIuXHJcbiAgICovXG4gIGFjdGlvbkNyZWF0b3JzPzogQWN0aW9uQ3JlYXRvcjxhbnk+W10gfCB7XG4gICAgW2tleTogc3RyaW5nXTogQWN0aW9uQ3JlYXRvcjxhbnk+O1xuICB9O1xuICAvKipcclxuICAgKiBpZiBtb3JlIHRoYW4gb25lIGFjdGlvbiBpcyBkaXNwYXRjaGVkIGluIHRoZSBpbmRpY2F0ZWQgaW50ZXJ2YWwsIGFsbCBuZXcgYWN0aW9ucyB3aWxsIGJlIGNvbGxlY3RlZCBhbmQgc2VudCBhdCBvbmNlLlxyXG4gICAqIEl0IGlzIHRoZSBqb2ludCBiZXR3ZWVuIHBlcmZvcm1hbmNlIGFuZCBzcGVlZC4gV2hlbiBzZXQgdG8gYDBgLCBhbGwgYWN0aW9ucyB3aWxsIGJlIHNlbnQgaW5zdGFudGx5LlxyXG4gICAqIFNldCBpdCB0byBhIGhpZ2hlciB2YWx1ZSB3aGVuIGV4cGVyaWVuY2luZyBwZXJmIGlzc3VlcyAoYWxzbyBgbWF4QWdlYCB0byBhIGxvd2VyIHZhbHVlKS5cclxuICAgKlxyXG4gICAqIEBkZWZhdWx0IDUwMCBtcy5cclxuICAgKi9cbiAgbGF0ZW5jeT86IG51bWJlcjtcbiAgLyoqXHJcbiAgICogKD4gMSkgLSBtYXhpbXVtIGFsbG93ZWQgYWN0aW9ucyB0byBiZSBzdG9yZWQgaW4gdGhlIGhpc3RvcnkgdHJlZS4gVGhlIG9sZGVzdCBhY3Rpb25zIGFyZSByZW1vdmVkIG9uY2UgbWF4QWdlIGlzIHJlYWNoZWQuIEl0J3MgY3JpdGljYWwgZm9yIHBlcmZvcm1hbmNlLlxyXG4gICAqXHJcbiAgICogQGRlZmF1bHQgNTBcclxuICAgKi9cbiAgbWF4QWdlPzogbnVtYmVyO1xuICAvKipcclxuICAgKiBDdXN0b21pemVzIGhvdyBhY3Rpb25zIGFuZCBzdGF0ZSBhcmUgc2VyaWFsaXplZCBhbmQgZGVzZXJpYWxpemVkLiBDYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdC4gSWYgZ2l2ZW4gYSBib29sZWFuLCB0aGUgYmVoYXZpb3IgaXMgdGhlIHNhbWUgYXMgaWYgeW91XHJcbiAgICogd2VyZSB0byBwYXNzIGFuIG9iamVjdCBhbmQgc3BlY2lmeSBgb3B0aW9uc2AgYXMgYSBib29sZWFuLiBHaXZpbmcgYW4gb2JqZWN0IGFsbG93cyBmaW5lLWdyYWluZWQgY3VzdG9taXphdGlvbiB1c2luZyB0aGUgYHJlcGxhY2VyYCBhbmQgYHJldml2ZXJgXHJcbiAgICogZnVuY3Rpb25zLlxyXG4gICAqL1xuICBzZXJpYWxpemU/OiBib29sZWFuIHwge1xuICAgIC8qKlxyXG4gICAgICogLSBgdW5kZWZpbmVkYCAtIHdpbGwgdXNlIHJlZ3VsYXIgYEpTT04uc3RyaW5naWZ5YCB0byBzZW5kIGRhdGEgKGl0J3MgdGhlIGZhc3QgbW9kZSkuXHJcbiAgICAgKiAtIGBmYWxzZWAgLSB3aWxsIGhhbmRsZSBhbHNvIGNpcmN1bGFyIHJlZmVyZW5jZXMuXHJcbiAgICAgKiAtIGB0cnVlYCAtIHdpbGwgaGFuZGxlIGFsc28gZGF0ZSwgcmVnZXgsIHVuZGVmaW5lZCwgZXJyb3Igb2JqZWN0cywgc3ltYm9scywgbWFwcywgc2V0cyBhbmQgZnVuY3Rpb25zLlxyXG4gICAgICogLSBvYmplY3QsIHdoaWNoIGNvbnRhaW5zIGBkYXRlYCwgYHJlZ2V4YCwgYHVuZGVmaW5lZGAsIGBlcnJvcmAsIGBzeW1ib2xgLCBgbWFwYCwgYHNldGAgYW5kIGBmdW5jdGlvbmAga2V5cy5cclxuICAgICAqICAgRm9yIGVhY2ggb2YgdGhlbSB5b3UgY2FuIGluZGljYXRlIGlmIHRvIGluY2x1ZGUgKGJ5IHNldHRpbmcgYXMgYHRydWVgKS5cclxuICAgICAqICAgRm9yIGBmdW5jdGlvbmAga2V5IHlvdSBjYW4gYWxzbyBzcGVjaWZ5IGEgY3VzdG9tIGZ1bmN0aW9uIHdoaWNoIGhhbmRsZXMgc2VyaWFsaXphdGlvbi5cclxuICAgICAqICAgU2VlIFtganNhbmBdKGh0dHBzOi8vZ2l0aHViLmNvbS9rb2xvZG55L2pzYW4pIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICAgKi9cbiAgICBvcHRpb25zPzogdW5kZWZpbmVkIHwgYm9vbGVhbiB8IHtcbiAgICAgIGRhdGU/OiB0cnVlO1xuICAgICAgcmVnZXg/OiB0cnVlO1xuICAgICAgdW5kZWZpbmVkPzogdHJ1ZTtcbiAgICAgIGVycm9yPzogdHJ1ZTtcbiAgICAgIHN5bWJvbD86IHRydWU7XG4gICAgICBtYXA/OiB0cnVlO1xuICAgICAgc2V0PzogdHJ1ZTtcbiAgICAgIGZ1bmN0aW9uPzogdHJ1ZSB8ICgoZm46ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA9PiBzdHJpbmcpO1xuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBbSlNPTiByZXBsYWNlciBmdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSlNPTi9zdHJpbmdpZnkjVGhlX3JlcGxhY2VyX3BhcmFtZXRlcikgdXNlZCBmb3IgYm90aCBhY3Rpb25zIGFuZCBzdGF0ZXMgc3RyaW5naWZ5LlxyXG4gICAgICogSW4gYWRkaXRpb24sIHlvdSBjYW4gc3BlY2lmeSBhIGRhdGEgdHlwZSBieSBhZGRpbmcgYSBbYF9fc2VyaWFsaXplZFR5cGVfX2BdKGh0dHBzOi8vZ2l0aHViLmNvbS96YWxtb3hpc3VzL3JlbW90ZWRldi1zZXJpYWxpemUvYmxvYi9tYXN0ZXIvaGVscGVycy9pbmRleC5qcyNMNClcclxuICAgICAqIGtleS4gU28geW91IGNhbiBkZXNlcmlhbGl6ZSBpdCBiYWNrIHdoaWxlIGltcG9ydGluZyBvciBwZXJzaXN0aW5nIGRhdGEuXHJcbiAgICAgKiBNb3Jlb3ZlciwgaXQgd2lsbCBhbHNvIFtzaG93IGEgbmljZSBwcmV2aWV3IHNob3dpbmcgdGhlIHByb3ZpZGVkIGN1c3RvbSB0eXBlXShodHRwczovL2Nsb3VkLmdpdGh1YnVzZXJjb250ZW50LmNvbS9hc3NldHMvNzk1Nzg1OS8yMTgxNDMzMC9hMTdkNTU2YS1kNzYxLTExZTYtODVlZi0xNTlkZDEyZjM2YzUucG5nKTpcclxuICAgICAqL1xuICAgIHJlcGxhY2VyPzogKGtleTogc3RyaW5nLCB2YWx1ZTogdW5rbm93bikgPT4gYW55O1xuICAgIC8qKlxyXG4gICAgICogW0pTT04gYHJldml2ZXJgIGZ1bmN0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9KU09OL3BhcnNlI1VzaW5nX3RoZV9yZXZpdmVyX3BhcmFtZXRlcilcclxuICAgICAqIHVzZWQgZm9yIHBhcnNpbmcgdGhlIGltcG9ydGVkIGFjdGlvbnMgYW5kIHN0YXRlcy4gU2VlIFtgcmVtb3RlZGV2LXNlcmlhbGl6ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS96YWxtb3hpc3VzL3JlbW90ZWRldi1zZXJpYWxpemUvYmxvYi9tYXN0ZXIvaW1tdXRhYmxlL3NlcmlhbGl6ZS5qcyNMOC1MNDEpXHJcbiAgICAgKiBhcyBhbiBleGFtcGxlIG9uIGhvdyB0byBzZXJpYWxpemUgc3BlY2lhbCBkYXRhIHR5cGVzIGFuZCBnZXQgdGhlbSBiYWNrLlxyXG4gICAgICovXG4gICAgcmV2aXZlcj86IChrZXk6IHN0cmluZywgdmFsdWU6IHVua25vd24pID0+IGFueTtcbiAgICAvKipcclxuICAgICAqIEF1dG9tYXRpY2FsbHkgc2VyaWFsaXplL2Rlc2VyaWFsaXplIGltbXV0YWJsZWpzIHZpYSBbcmVtb3RlZGV2LXNlcmlhbGl6ZV0oaHR0cHM6Ly9naXRodWIuY29tL3phbG1veGlzdXMvcmVtb3RlZGV2LXNlcmlhbGl6ZSkuXHJcbiAgICAgKiBKdXN0IHBhc3MgdGhlIEltbXV0YWJsZSBsaWJyYXJ5LiBJdCB3aWxsIHN1cHBvcnQgYWxsIEltbXV0YWJsZUpTIHN0cnVjdHVyZXMuIFlvdSBjYW4gZXZlbiBleHBvcnQgdGhlbSBpbnRvIGEgZmlsZSBhbmQgZ2V0IHRoZW0gYmFjay5cclxuICAgICAqIFRoZSBvbmx5IGV4Y2VwdGlvbiBpcyBgUmVjb3JkYCBjbGFzcywgZm9yIHdoaWNoIHlvdSBzaG91bGQgcGFzcyB0aGlzIGluIGFkZGl0aW9uIHRoZSByZWZlcmVuY2VzIHRvIHlvdXIgY2xhc3NlcyBpbiBgcmVmc2AuXHJcbiAgICAgKi9cbiAgICBpbW11dGFibGU/OiBhbnk7XG4gICAgLyoqXHJcbiAgICAgKiBJbW11dGFibGVKUyBgUmVjb3JkYCBjbGFzc2VzIHVzZWQgdG8gbWFrZSBwb3NzaWJsZSByZXN0b3JlIGl0cyBpbnN0YW5jZXMgYmFjayB3aGVuIGltcG9ydGluZywgcGVyc2lzdGluZy4uLlxyXG4gICAgICovXG4gICAgcmVmcz86IGFueTtcbiAgfTtcbiAgLyoqXHJcbiAgICogZnVuY3Rpb24gd2hpY2ggdGFrZXMgYGFjdGlvbmAgb2JqZWN0IGFuZCBpZCBudW1iZXIgYXMgYXJndW1lbnRzLCBhbmQgc2hvdWxkIHJldHVybiBgYWN0aW9uYCBvYmplY3QgYmFjay5cclxuICAgKi9cbiAgYWN0aW9uU2FuaXRpemVyPzogPEEgZXh0ZW5kcyBBY3Rpb24+KGFjdGlvbjogQSwgaWQ6IG51bWJlcikgPT4gQTtcbiAgLyoqXHJcbiAgICogZnVuY3Rpb24gd2hpY2ggdGFrZXMgYHN0YXRlYCBvYmplY3QgYW5kIGluZGV4IGFzIGFyZ3VtZW50cywgYW5kIHNob3VsZCByZXR1cm4gYHN0YXRlYCBvYmplY3QgYmFjay5cclxuICAgKi9cbiAgc3RhdGVTYW5pdGl6ZXI/OiA8Uz4oc3RhdGU6IFMsIGluZGV4OiBudW1iZXIpID0+IFM7XG4gIC8qKlxyXG4gICAqICpzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyBhcyByZWdleCogLSBhY3Rpb25zIHR5cGVzIHRvIGJlIGhpZGRlbiAvIHNob3duIGluIHRoZSBtb25pdG9ycyAod2hpbGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VycykuXHJcbiAgICogSWYgYGFjdGlvbnNBbGxvd2xpc3RgIHNwZWNpZmllZCwgYGFjdGlvbnNEZW55bGlzdGAgaXMgaWdub3JlZC5cclxuICAgKi9cbiAgYWN0aW9uc0RlbnlsaXN0Pzogc3RyaW5nIHwgc3RyaW5nW107XG4gIC8qKlxyXG4gICAqICpzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyBhcyByZWdleCogLSBhY3Rpb25zIHR5cGVzIHRvIGJlIGhpZGRlbiAvIHNob3duIGluIHRoZSBtb25pdG9ycyAod2hpbGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VycykuXHJcbiAgICogSWYgYGFjdGlvbnNBbGxvd2xpc3RgIHNwZWNpZmllZCwgYGFjdGlvbnNEZW55bGlzdGAgaXMgaWdub3JlZC5cclxuICAgKi9cbiAgYWN0aW9uc0FsbG93bGlzdD86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAvKipcclxuICAgKiBjYWxsZWQgZm9yIGV2ZXJ5IGFjdGlvbiBiZWZvcmUgc2VuZGluZywgdGFrZXMgYHN0YXRlYCBhbmQgYGFjdGlvbmAgb2JqZWN0LCBhbmQgcmV0dXJucyBgdHJ1ZWAgaW4gY2FzZSBpdCBhbGxvd3Mgc2VuZGluZyB0aGUgY3VycmVudCBkYXRhIHRvIHRoZSBtb25pdG9yLlxyXG4gICAqIFVzZSBpdCBhcyBhIG1vcmUgYWR2YW5jZWQgdmVyc2lvbiBvZiBgYWN0aW9uc0RlbnlsaXN0YC9gYWN0aW9uc0FsbG93bGlzdGAgcGFyYW1ldGVycy5cclxuICAgKi9cbiAgcHJlZGljYXRlPzogPFMsIEEgZXh0ZW5kcyBBY3Rpb24+KHN0YXRlOiBTLCBhY3Rpb246IEEpID0+IGJvb2xlYW47XG4gIC8qKlxyXG4gICAqIGlmIHNwZWNpZmllZCBhcyBgZmFsc2VgLCBpdCB3aWxsIG5vdCByZWNvcmQgdGhlIGNoYW5nZXMgdGlsbCBjbGlja2luZyBvbiBgU3RhcnQgcmVjb3JkaW5nYCBidXR0b24uXHJcbiAgICogQXZhaWxhYmxlIG9ubHkgZm9yIFJlZHV4IGVuaGFuY2VyLCBmb3Igb3RoZXJzIHVzZSBgYXV0b1BhdXNlYC5cclxuICAgKlxyXG4gICAqIEBkZWZhdWx0IHRydWVcclxuICAgKi9cbiAgc2hvdWxkUmVjb3JkQ2hhbmdlcz86IGJvb2xlYW47XG4gIC8qKlxyXG4gICAqIGlmIHNwZWNpZmllZCwgd2hlbmV2ZXIgY2xpY2tpbmcgb24gYFBhdXNlIHJlY29yZGluZ2AgYnV0dG9uIGFuZCB0aGVyZSBhcmUgYWN0aW9ucyBpbiB0aGUgaGlzdG9yeSBsb2csIHdpbGwgYWRkIHRoaXMgYWN0aW9uIHR5cGUuXHJcbiAgICogSWYgbm90IHNwZWNpZmllZCwgd2lsbCBjb21taXQgd2hlbiBwYXVzZWQuIEF2YWlsYWJsZSBvbmx5IGZvciBSZWR1eCBlbmhhbmNlci5cclxuICAgKlxyXG4gICAqIEBkZWZhdWx0IFwiQEBQQVVTRURcIlwiXHJcbiAgICovXG4gIHBhdXNlQWN0aW9uVHlwZT86IHN0cmluZztcbiAgLyoqXHJcbiAgICogYXV0byBwYXVzZXMgd2hlbiB0aGUgZXh0ZW5zaW9u4oCZcyB3aW5kb3cgaXMgbm90IG9wZW5lZCwgYW5kIHNvIGhhcyB6ZXJvIGltcGFjdCBvbiB5b3VyIGFwcCB3aGVuIG5vdCBpbiB1c2UuXHJcbiAgICogTm90IGF2YWlsYWJsZSBmb3IgUmVkdXggZW5oYW5jZXIgKGFzIGl0IGFscmVhZHkgZG9lcyBpdCBidXQgc3RvcmluZyB0aGUgZGF0YSB0byBiZSBzZW50KS5cclxuICAgKlxyXG4gICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICovXG4gIGF1dG9QYXVzZT86IGJvb2xlYW47XG4gIC8qKlxyXG4gICAqIGlmIHNwZWNpZmllZCBhcyBgdHJ1ZWAsIGl0IHdpbGwgbm90IGFsbG93IGFueSBub24tbW9uaXRvciBhY3Rpb25zIHRvIGJlIGRpc3BhdGNoZWQgdGlsbCBjbGlja2luZyBvbiBgVW5sb2NrIGNoYW5nZXNgIGJ1dHRvbi5cclxuICAgKiBBdmFpbGFibGUgb25seSBmb3IgUmVkdXggZW5oYW5jZXIuXHJcbiAgICpcclxuICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAqL1xuICBzaG91bGRTdGFydExvY2tlZD86IGJvb2xlYW47XG4gIC8qKlxyXG4gICAqIGlmIHNldCB0byBgZmFsc2VgLCB3aWxsIG5vdCByZWNvbXB1dGUgdGhlIHN0YXRlcyBvbiBob3QgcmVsb2FkaW5nIChvciBvbiByZXBsYWNpbmcgdGhlIHJlZHVjZXJzKS4gQXZhaWxhYmxlIG9ubHkgZm9yIFJlZHV4IGVuaGFuY2VyLlxyXG4gICAqXHJcbiAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAqL1xuICBzaG91bGRIb3RSZWxvYWQ/OiBib29sZWFuO1xuICAvKipcclxuICAgKiBpZiBzcGVjaWZpZWQgYXMgYHRydWVgLCB3aGVuZXZlciB0aGVyZSdzIGFuIGV4Y2VwdGlvbiBpbiByZWR1Y2VycywgdGhlIG1vbml0b3JzIHdpbGwgc2hvdyB0aGUgZXJyb3IgbWVzc2FnZSwgYW5kIG5leHQgYWN0aW9ucyB3aWxsIG5vdCBiZSBkaXNwYXRjaGVkLlxyXG4gICAqXHJcbiAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgKi9cbiAgc2hvdWxkQ2F0Y2hFcnJvcnM/OiBib29sZWFuO1xuICAvKipcclxuICAgKiBJZiB5b3Ugd2FudCB0byByZXN0cmljdCB0aGUgZXh0ZW5zaW9uLCBzcGVjaWZ5IHRoZSBmZWF0dXJlcyB5b3UgYWxsb3cuXHJcbiAgICogSWYgbm90IHNwZWNpZmllZCwgYWxsIG9mIHRoZSBmZWF0dXJlcyBhcmUgZW5hYmxlZC4gV2hlbiBzZXQgYXMgYW4gb2JqZWN0LCBvbmx5IHRob3NlIGluY2x1ZGVkIGFzIGB0cnVlYCB3aWxsIGJlIGFsbG93ZWQuXHJcbiAgICogTm90ZSB0aGF0IGV4Y2VwdCBgdHJ1ZWAvYGZhbHNlYCwgYGltcG9ydGAgYW5kIGBleHBvcnRgIGNhbiBiZSBzZXQgYXMgYGN1c3RvbWAgKHdoaWNoIGlzIGJ5IGRlZmF1bHQgZm9yIFJlZHV4IGVuaGFuY2VyKSwgbWVhbmluZyB0aGF0IHRoZSBpbXBvcnRpbmcvZXhwb3J0aW5nIG9jY3VycyBvbiB0aGUgY2xpZW50IHNpZGUuXHJcbiAgICogT3RoZXJ3aXNlLCB5b3UnbGwgZ2V0L3NldCB0aGUgZGF0YSByaWdodCBmcm9tIHRoZSBtb25pdG9yIHBhcnQuXHJcbiAgICovXG4gIGZlYXR1cmVzPzoge1xuICAgIC8qKlxyXG4gICAgICogc3RhcnQvcGF1c2UgcmVjb3JkaW5nIG9mIGRpc3BhdGNoZWQgYWN0aW9uc1xyXG4gICAgICovXG4gICAgcGF1c2U/OiBib29sZWFuO1xuICAgIC8qKlxyXG4gICAgICogbG9jay91bmxvY2sgZGlzcGF0Y2hpbmcgYWN0aW9ucyBhbmQgc2lkZSBlZmZlY3RzXHJcbiAgICAgKi9cbiAgICBsb2NrPzogYm9vbGVhbjtcbiAgICAvKipcclxuICAgICAqIHBlcnNpc3Qgc3RhdGVzIG9uIHBhZ2UgcmVsb2FkaW5nXHJcbiAgICAgKi9cbiAgICBwZXJzaXN0PzogYm9vbGVhbjtcbiAgICAvKipcclxuICAgICAqIGV4cG9ydCBoaXN0b3J5IG9mIGFjdGlvbnMgaW4gYSBmaWxlXHJcbiAgICAgKi9cbiAgICBleHBvcnQ/OiBib29sZWFuIHwgJ2N1c3RvbSc7XG4gICAgLyoqXHJcbiAgICAgKiBpbXBvcnQgaGlzdG9yeSBvZiBhY3Rpb25zIGZyb20gYSBmaWxlXHJcbiAgICAgKi9cbiAgICBpbXBvcnQ/OiBib29sZWFuIHwgJ2N1c3RvbSc7XG4gICAgLyoqXHJcbiAgICAgKiBqdW1wIGJhY2sgYW5kIGZvcnRoICh0aW1lIHRyYXZlbGxpbmcpXHJcbiAgICAgKi9cbiAgICBqdW1wPzogYm9vbGVhbjtcbiAgICAvKipcclxuICAgICAqIHNraXAgKGNhbmNlbCkgYWN0aW9uc1xyXG4gICAgICovXG4gICAgc2tpcD86IGJvb2xlYW47XG4gICAgLyoqXHJcbiAgICAgKiBkcmFnIGFuZCBkcm9wIGFjdGlvbnMgaW4gdGhlIGhpc3RvcnkgbGlzdFxyXG4gICAgICovXG4gICAgcmVvcmRlcj86IGJvb2xlYW47XG4gICAgLyoqXHJcbiAgICAgKiBkaXNwYXRjaCBjdXN0b20gYWN0aW9ucyBvciBhY3Rpb24gY3JlYXRvcnNcclxuICAgICAqL1xuICAgIGRpc3BhdGNoPzogYm9vbGVhbjtcbiAgICAvKipcclxuICAgICAqIGdlbmVyYXRlIHRlc3RzIGZvciB0aGUgc2VsZWN0ZWQgYWN0aW9uc1xyXG4gICAgICovXG4gICAgdGVzdD86IGJvb2xlYW47XG4gIH07XG4gIC8qKlxyXG4gICAqIFNldCB0byB0cnVlIG9yIGEgc3RhY2t0cmFjZS1yZXR1cm5pbmcgZnVuY3Rpb24gdG8gcmVjb3JkIGNhbGwgc3RhY2sgdHJhY2VzIGZvciBkaXNwYXRjaGVkIGFjdGlvbnMuXHJcbiAgICogRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICovXG4gIHRyYWNlPzogYm9vbGVhbiB8ICg8QSBleHRlbmRzIEFjdGlvbj4oYWN0aW9uOiBBKSA9PiBzdHJpbmcpO1xuICAvKipcclxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc3RhY2sgdHJhY2UgZW50cmllcyB0byByZWNvcmQgcGVyIGFjdGlvbi4gRGVmYXVsdHMgdG8gMTAuXHJcbiAgICovXG4gIHRyYWNlTGltaXQ/OiBudW1iZXI7XG59XG50eXBlIENvbXBvc2UgPSB0eXBlb2YgY29tcG9zZTtcbmludGVyZmFjZSBDb21wb3NlV2l0aERldlRvb2xzIHtcbiAgKG9wdGlvbnM6IERldlRvb2xzRW5oYW5jZXJPcHRpb25zKTogQ29tcG9zZTtcbiAgPFN0b3JlRXh0IGV4dGVuZHMge30+KC4uLmZ1bmNzOiBTdG9yZUVuaGFuY2VyPFN0b3JlRXh0PltdKTogU3RvcmVFbmhhbmNlcjxTdG9yZUV4dD47XG59XG5cbi8qKlxyXG4gKiBAcHVibGljXHJcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbXBvc2VXaXRoRGV2VG9vbHM6IENvbXBvc2VXaXRoRGV2VG9vbHMgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93IGFzIGFueSkuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fID8gKHdpbmRvdyBhcyBhbnkpLl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA6IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0JykgcmV0dXJuIGNvbXBvc2U7XG4gIHJldHVybiBjb21wb3NlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyBhcyBhbnkgYXMgRnVuY3Rpb25bXSk7XG59O1xuXG4vKipcclxuICogQHB1YmxpY1xyXG4gKi9cbmV4cG9ydCBjb25zdCBkZXZUb29sc0VuaGFuY2VyOiB7XG4gIChvcHRpb25zOiBEZXZUb29sc0VuaGFuY2VyT3B0aW9ucyk6IFN0b3JlRW5oYW5jZXI8YW55Pjtcbn0gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93IGFzIGFueSkuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA/ICh3aW5kb3cgYXMgYW55KS5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG5vb3ApIHtcbiAgICByZXR1cm4gbm9vcDtcbiAgfTtcbn07IiwiaW1wb3J0IHR5cGUgeyBNaWRkbGV3YXJlLCBVbmtub3duQWN0aW9uIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHR5cGUgeyBUaHVua01pZGRsZXdhcmUgfSBmcm9tICdyZWR1eC10aHVuayc7XG5pbXBvcnQgeyB0aHVuayBhcyB0aHVua01pZGRsZXdhcmUsIHdpdGhFeHRyYUFyZ3VtZW50IH0gZnJvbSAncmVkdXgtdGh1bmsnO1xuaW1wb3J0IHR5cGUgeyBBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMgfSBmcm9tICcuL2FjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlJztcbmltcG9ydCB7IGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlIH0gZnJvbSAnLi9hY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZSc7XG5pbXBvcnQgdHlwZSB7IEltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMgfSBmcm9tICcuL2ltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSc7XG4vKiBQUk9EX1NUQVJUX1JFTU9WRV9VTUQgKi9cbmltcG9ydCB7IGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSB9IGZyb20gJy4vaW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlJztcbi8qIFBST0RfU1RPUF9SRU1PVkVfVU1EICovXG5cbmltcG9ydCB0eXBlIHsgU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9ucyB9IGZyb20gJy4vc2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlJztcbmltcG9ydCB7IGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSB9IGZyb20gJy4vc2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlJztcbmltcG9ydCB0eXBlIHsgRXhjbHVkZUZyb21UdXBsZSB9IGZyb20gJy4vdHNIZWxwZXJzJztcbmltcG9ydCB7IFR1cGxlIH0gZnJvbSAnLi91dGlscyc7XG5mdW5jdGlvbiBpc0Jvb2xlYW4oeDogYW55KTogeCBpcyBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnYm9vbGVhbic7XG59XG5pbnRlcmZhY2UgVGh1bmtPcHRpb25zPEUgPSBhbnk+IHtcbiAgZXh0cmFBcmd1bWVudDogRTtcbn1cbmludGVyZmFjZSBHZXREZWZhdWx0TWlkZGxld2FyZU9wdGlvbnMge1xuICB0aHVuaz86IGJvb2xlYW4gfCBUaHVua09wdGlvbnM7XG4gIGltbXV0YWJsZUNoZWNrPzogYm9vbGVhbiB8IEltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnM7XG4gIHNlcmlhbGl6YWJsZUNoZWNrPzogYm9vbGVhbiB8IFNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnM7XG4gIGFjdGlvbkNyZWF0b3JDaGVjaz86IGJvb2xlYW4gfCBBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnM7XG59XG5leHBvcnQgdHlwZSBUaHVua01pZGRsZXdhcmVGb3I8UywgTyBleHRlbmRzIEdldERlZmF1bHRNaWRkbGV3YXJlT3B0aW9ucyA9IHt9PiA9IE8gZXh0ZW5kcyB7XG4gIHRodW5rOiBmYWxzZTtcbn0gPyBuZXZlciA6IE8gZXh0ZW5kcyB7XG4gIHRodW5rOiB7XG4gICAgZXh0cmFBcmd1bWVudDogaW5mZXIgRTtcbiAgfTtcbn0gPyBUaHVua01pZGRsZXdhcmU8UywgVW5rbm93bkFjdGlvbiwgRT4gOiBUaHVua01pZGRsZXdhcmU8UywgVW5rbm93bkFjdGlvbj47XG5leHBvcnQgdHlwZSBHZXREZWZhdWx0TWlkZGxld2FyZTxTID0gYW55PiA9IDxPIGV4dGVuZHMgR2V0RGVmYXVsdE1pZGRsZXdhcmVPcHRpb25zID0ge1xuICB0aHVuazogdHJ1ZTtcbiAgaW1tdXRhYmxlQ2hlY2s6IHRydWU7XG4gIHNlcmlhbGl6YWJsZUNoZWNrOiB0cnVlO1xuICBhY3Rpb25DcmVhdG9yQ2hlY2s6IHRydWU7XG59PihvcHRpb25zPzogTykgPT4gVHVwbGU8RXhjbHVkZUZyb21UdXBsZTxbVGh1bmtNaWRkbGV3YXJlRm9yPFMsIE8+XSwgbmV2ZXI+PjtcbmV4cG9ydCBjb25zdCBidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlID0gPFMgPSBhbnksPigpOiBHZXREZWZhdWx0TWlkZGxld2FyZTxTPiA9PiBmdW5jdGlvbiBnZXREZWZhdWx0TWlkZGxld2FyZShvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB0aHVuayA9IHRydWUsXG4gICAgaW1tdXRhYmxlQ2hlY2sgPSB0cnVlLFxuICAgIHNlcmlhbGl6YWJsZUNoZWNrID0gdHJ1ZSxcbiAgICBhY3Rpb25DcmVhdG9yQ2hlY2sgPSB0cnVlXG4gIH0gPSBvcHRpb25zID8/IHt9O1xuICBsZXQgbWlkZGxld2FyZUFycmF5ID0gbmV3IFR1cGxlPE1pZGRsZXdhcmVbXT4oKTtcbiAgaWYgKHRodW5rKSB7XG4gICAgaWYgKGlzQm9vbGVhbih0aHVuaykpIHtcbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKHRodW5rTWlkZGxld2FyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKHdpdGhFeHRyYUFyZ3VtZW50KHRodW5rLmV4dHJhQXJndW1lbnQpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaW1tdXRhYmxlQ2hlY2spIHtcbiAgICAgIC8qIFBST0RfU1RBUlRfUkVNT1ZFX1VNRCAqL1xuICAgICAgbGV0IGltbXV0YWJsZU9wdGlvbnM6IEltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICghaXNCb29sZWFuKGltbXV0YWJsZUNoZWNrKSkge1xuICAgICAgICBpbW11dGFibGVPcHRpb25zID0gaW1tdXRhYmxlQ2hlY2s7XG4gICAgICB9XG4gICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoaW1tdXRhYmxlT3B0aW9ucykpO1xuICAgICAgLyogUFJPRF9TVE9QX1JFTU9WRV9VTUQgKi9cbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6YWJsZUNoZWNrKSB7XG4gICAgICBsZXQgc2VyaWFsaXphYmxlT3B0aW9uczogU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oc2VyaWFsaXphYmxlQ2hlY2spKSB7XG4gICAgICAgIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSBzZXJpYWxpemFibGVDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShzZXJpYWxpemFibGVPcHRpb25zKSk7XG4gICAgfVxuICAgIGlmIChhY3Rpb25DcmVhdG9yQ2hlY2spIHtcbiAgICAgIGxldCBhY3Rpb25DcmVhdG9yT3B0aW9uczogQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmVPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihhY3Rpb25DcmVhdG9yQ2hlY2spKSB7XG4gICAgICAgIGFjdGlvbkNyZWF0b3JPcHRpb25zID0gYWN0aW9uQ3JlYXRvckNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnVuc2hpZnQoY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUoYWN0aW9uQ3JlYXRvck9wdGlvbnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pZGRsZXdhcmVBcnJheSBhcyBhbnk7XG59OyIsImltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgaXNBY3Rpb24gfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgdHlwZSB7IElzVW5rbm93bk9yTm9uSW5mZXJyYWJsZSwgSWZNYXliZVVuZGVmaW5lZCwgSWZWb2lkLCBJc0FueSB9IGZyb20gJy4vdHNIZWxwZXJzJztcbmltcG9ydCB7IGhhc01hdGNoRnVuY3Rpb24gfSBmcm9tICcuL3RzSGVscGVycyc7XG5cbi8qKlxuICogQW4gYWN0aW9uIHdpdGggYSBzdHJpbmcgdHlwZSBhbmQgYW4gYXNzb2NpYXRlZCBwYXlsb2FkLiBUaGlzIGlzIHRoZVxuICogdHlwZSBvZiBhY3Rpb24gcmV0dXJuZWQgYnkgYGNyZWF0ZUFjdGlvbigpYCBhY3Rpb24gY3JlYXRvcnMuXG4gKlxuICogQHRlbXBsYXRlIFAgVGhlIHR5cGUgb2YgdGhlIGFjdGlvbidzIHBheWxvYWQuXG4gKiBAdGVtcGxhdGUgVCB0aGUgdHlwZSB1c2VkIGZvciB0aGUgYWN0aW9uIHR5cGUuXG4gKiBAdGVtcGxhdGUgTSBUaGUgdHlwZSBvZiB0aGUgYWN0aW9uJ3MgbWV0YSAob3B0aW9uYWwpXG4gKiBAdGVtcGxhdGUgRSBUaGUgdHlwZSBvZiB0aGUgYWN0aW9uJ3MgZXJyb3IgKG9wdGlvbmFsKVxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgUGF5bG9hZEFjdGlvbjxQID0gdm9pZCwgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZywgTSA9IG5ldmVyLCBFID0gbmV2ZXI+ID0ge1xuICBwYXlsb2FkOiBQO1xuICB0eXBlOiBUO1xufSAmIChbTV0gZXh0ZW5kcyBbbmV2ZXJdID8ge30gOiB7XG4gIG1ldGE6IE07XG59KSAmIChbRV0gZXh0ZW5kcyBbbmV2ZXJdID8ge30gOiB7XG4gIGVycm9yOiBFO1xufSk7XG5cbi8qKlxuICogQSBcInByZXBhcmVcIiBtZXRob2QgdG8gYmUgdXNlZCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciBvZiBgY3JlYXRlQWN0aW9uYC5cbiAqIFRha2VzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCByZXR1cm5zIGEgRmx1eCBTdGFuZGFyZCBBY3Rpb24gd2l0aG91dFxuICogdHlwZSAod2lsbCBiZSBhZGRlZCBsYXRlcikgdGhhdCAqbXVzdCogY29udGFpbiBhIHBheWxvYWQgKG1pZ2h0IGJlIHVuZGVmaW5lZCkuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBQcmVwYXJlQWN0aW9uPFA+ID0gKCguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICBwYXlsb2FkOiBQO1xufSkgfCAoKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gIHBheWxvYWQ6IFA7XG4gIG1ldGE6IGFueTtcbn0pIHwgKCguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICBwYXlsb2FkOiBQO1xuICBlcnJvcjogYW55O1xufSkgfCAoKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gIHBheWxvYWQ6IFA7XG4gIG1ldGE6IGFueTtcbiAgZXJyb3I6IGFueTtcbn0pO1xuXG4vKipcbiAqIEludGVybmFsIHZlcnNpb24gb2YgYEFjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkYC4gTm90IHRvIGJlIHVzZWQgZXh0ZXJuYWxseS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgX0FjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkPFBBIGV4dGVuZHMgUHJlcGFyZUFjdGlvbjxhbnk+IHwgdm9pZCwgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gPSBQQSBleHRlbmRzIFByZXBhcmVBY3Rpb248aW5mZXIgUD4gPyBBY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZDxQYXJhbWV0ZXJzPFBBPiwgUCwgVCwgUmV0dXJuVHlwZTxQQT4gZXh0ZW5kcyB7XG4gIGVycm9yOiBpbmZlciBFO1xufSA/IEUgOiBuZXZlciwgUmV0dXJuVHlwZTxQQT4gZXh0ZW5kcyB7XG4gIG1ldGE6IGluZmVyIE07XG59ID8gTSA6IG5ldmVyPiA6IHZvaWQ7XG5cbi8qKlxuICogQmFzaWMgdHlwZSBmb3IgYWxsIGFjdGlvbiBjcmVhdG9ycy5cbiAqXG4gKiBAaW5oZXJpdGRvYyB7cmVkdXgjQWN0aW9uQ3JlYXRvcn1cbiAqL1xuZXhwb3J0IHR5cGUgQmFzZUFjdGlvbkNyZWF0b3I8UCwgVCBleHRlbmRzIHN0cmluZywgTSA9IG5ldmVyLCBFID0gbmV2ZXI+ID0ge1xuICB0eXBlOiBUO1xuICBtYXRjaDogKGFjdGlvbjogdW5rbm93bikgPT4gYWN0aW9uIGlzIFBheWxvYWRBY3Rpb248UCwgVCwgTSwgRT47XG59O1xuXG4vKipcbiAqIEFuIGFjdGlvbiBjcmVhdG9yIHRoYXQgdGFrZXMgbXVsdGlwbGUgYXJndW1lbnRzIHRoYXQgYXJlIHBhc3NlZFxuICogdG8gYSBgUHJlcGFyZUFjdGlvbmAgbWV0aG9kIHRvIGNyZWF0ZSB0aGUgZmluYWwgQWN0aW9uLlxuICogQHR5cGVQYXJhbSBBcmdzIGFyZ3VtZW50cyBmb3IgdGhlIGFjdGlvbiBjcmVhdG9yIGZ1bmN0aW9uXG4gKiBAdHlwZVBhcmFtIFAgYHBheWxvYWRgIHR5cGVcbiAqIEB0eXBlUGFyYW0gVCBgdHlwZWAgbmFtZVxuICogQHR5cGVQYXJhbSBFIG9wdGlvbmFsIGBlcnJvcmAgdHlwZVxuICogQHR5cGVQYXJhbSBNIG9wdGlvbmFsIGBtZXRhYCB0eXBlXG4gKlxuICogQGluaGVyaXRkb2Mge3JlZHV4I0FjdGlvbkNyZWF0b3J9XG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkPEFyZ3MgZXh0ZW5kcyB1bmtub3duW10sIFAsIFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsIEUgPSBuZXZlciwgTSA9IG5ldmVyPiBleHRlbmRzIEJhc2VBY3Rpb25DcmVhdG9yPFAsIFQsIE0sIEU+IHtcbiAgLyoqXG4gICAqIENhbGxpbmcgdGhpcyB7QGxpbmsgcmVkdXgjQWN0aW9uQ3JlYXRvcn0gd2l0aCBgQXJnc2Agd2lsbCByZXR1cm5cbiAgICogYW4gQWN0aW9uIHdpdGggYSBwYXlsb2FkIG9mIHR5cGUgYFBgIGFuZCAoZGVwZW5kaW5nIG9uIHRoZSBgUHJlcGFyZUFjdGlvbmBcbiAgICogbWV0aG9kIHVzZWQpIGEgYG1ldGFgLSBhbmQgYGVycm9yYCBwcm9wZXJ0eSBvZiB0eXBlcyBgTWAgYW5kIGBFYCByZXNwZWN0aXZlbHkuXG4gICAqL1xuICAoLi4uYXJnczogQXJncyk6IFBheWxvYWRBY3Rpb248UCwgVCwgTSwgRT47XG59XG5cbi8qKlxuICogQW4gYWN0aW9uIGNyZWF0b3Igb2YgdHlwZSBgVGAgdGhhdCB0YWtlcyBhbiBvcHRpb25hbCBwYXlsb2FkIG9mIHR5cGUgYFBgLlxuICpcbiAqIEBpbmhlcml0ZG9jIHtyZWR1eCNBY3Rpb25DcmVhdG9yfVxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25DcmVhdG9yV2l0aE9wdGlvbmFsUGF5bG9hZDxQLCBUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiBleHRlbmRzIEJhc2VBY3Rpb25DcmVhdG9yPFAsIFQ+IHtcbiAgLyoqXG4gICAqIENhbGxpbmcgdGhpcyB7QGxpbmsgcmVkdXgjQWN0aW9uQ3JlYXRvcn0gd2l0aCBhbiBhcmd1bWVudCB3aWxsXG4gICAqIHJldHVybiBhIHtAbGluayBQYXlsb2FkQWN0aW9ufSBvZiB0eXBlIGBUYCB3aXRoIGEgcGF5bG9hZCBvZiBgUGAuXG4gICAqIENhbGxpbmcgaXQgd2l0aG91dCBhbiBhcmd1bWVudCB3aWxsIHJldHVybiBhIFBheWxvYWRBY3Rpb24gd2l0aCBhIHBheWxvYWQgb2YgYHVuZGVmaW5lZGAuXG4gICAqL1xuICAocGF5bG9hZD86IFApOiBQYXlsb2FkQWN0aW9uPFAsIFQ+O1xufVxuXG4vKipcbiAqIEFuIGFjdGlvbiBjcmVhdG9yIG9mIHR5cGUgYFRgIHRoYXQgdGFrZXMgbm8gcGF5bG9hZC5cbiAqXG4gKiBAaW5oZXJpdGRvYyB7cmVkdXgjQWN0aW9uQ3JlYXRvcn1cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uQ3JlYXRvcldpdGhvdXRQYXlsb2FkPFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IGV4dGVuZHMgQmFzZUFjdGlvbkNyZWF0b3I8dW5kZWZpbmVkLCBUPiB7XG4gIC8qKlxuICAgKiBDYWxsaW5nIHRoaXMge0BsaW5rIHJlZHV4I0FjdGlvbkNyZWF0b3J9IHdpbGxcbiAgICogcmV0dXJuIGEge0BsaW5rIFBheWxvYWRBY3Rpb259IG9mIHR5cGUgYFRgIHdpdGggYSBwYXlsb2FkIG9mIGB1bmRlZmluZWRgXG4gICAqL1xuICAobm9Bcmd1bWVudDogdm9pZCk6IFBheWxvYWRBY3Rpb248dW5kZWZpbmVkLCBUPjtcbn1cblxuLyoqXG4gKiBBbiBhY3Rpb24gY3JlYXRvciBvZiB0eXBlIGBUYCB0aGF0IHJlcXVpcmVzIGEgcGF5bG9hZCBvZiB0eXBlIFAuXG4gKlxuICogQGluaGVyaXRkb2Mge3JlZHV4I0FjdGlvbkNyZWF0b3J9XG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkNyZWF0b3JXaXRoUGF5bG9hZDxQLCBUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiBleHRlbmRzIEJhc2VBY3Rpb25DcmVhdG9yPFAsIFQ+IHtcbiAgLyoqXG4gICAqIENhbGxpbmcgdGhpcyB7QGxpbmsgcmVkdXgjQWN0aW9uQ3JlYXRvcn0gd2l0aCBhbiBhcmd1bWVudCB3aWxsXG4gICAqIHJldHVybiBhIHtAbGluayBQYXlsb2FkQWN0aW9ufSBvZiB0eXBlIGBUYCB3aXRoIGEgcGF5bG9hZCBvZiBgUGBcbiAgICovXG4gIChwYXlsb2FkOiBQKTogUGF5bG9hZEFjdGlvbjxQLCBUPjtcbn1cblxuLyoqXG4gKiBBbiBhY3Rpb24gY3JlYXRvciBvZiB0eXBlIGBUYCB3aG9zZSBgcGF5bG9hZGAgdHlwZSBjb3VsZCBub3QgYmUgaW5mZXJyZWQuIEFjY2VwdHMgZXZlcnl0aGluZyBhcyBgcGF5bG9hZGAuXG4gKlxuICogQGluaGVyaXRkb2Mge3JlZHV4I0FjdGlvbkNyZWF0b3J9XG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkNyZWF0b3JXaXRoTm9uSW5mZXJyYWJsZVBheWxvYWQ8VCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gZXh0ZW5kcyBCYXNlQWN0aW9uQ3JlYXRvcjx1bmtub3duLCBUPiB7XG4gIC8qKlxuICAgKiBDYWxsaW5nIHRoaXMge0BsaW5rIHJlZHV4I0FjdGlvbkNyZWF0b3J9IHdpdGggYW4gYXJndW1lbnQgd2lsbFxuICAgKiByZXR1cm4gYSB7QGxpbmsgUGF5bG9hZEFjdGlvbn0gb2YgdHlwZSBgVGAgd2l0aCBhIHBheWxvYWRcbiAgICogb2YgZXhhY3RseSB0aGUgdHlwZSBvZiB0aGUgYXJndW1lbnQuXG4gICAqL1xuICA8UFQgZXh0ZW5kcyB1bmtub3duPihwYXlsb2FkOiBQVCk6IFBheWxvYWRBY3Rpb248UFQsIFQ+O1xufVxuXG4vKipcbiAqIEFuIGFjdGlvbiBjcmVhdG9yIHRoYXQgcHJvZHVjZXMgYWN0aW9ucyB3aXRoIGEgYHBheWxvYWRgIGF0dHJpYnV0ZS5cbiAqXG4gKiBAdHlwZVBhcmFtIFAgdGhlIGBwYXlsb2FkYCB0eXBlXG4gKiBAdHlwZVBhcmFtIFQgdGhlIGB0eXBlYCBvZiB0aGUgcmVzdWx0aW5nIGFjdGlvblxuICogQHR5cGVQYXJhbSBQQSBpZiB0aGUgcmVzdWx0aW5nIGFjdGlvbiBpcyBwcmVwcm9jZXNzZWQgYnkgYSBgcHJlcGFyZWAgbWV0aG9kLCB0aGUgc2lnbmF0dXJlIG9mIHNhaWQgbWV0aG9kLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgUGF5bG9hZEFjdGlvbkNyZWF0b3I8UCA9IHZvaWQsIFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsIFBBIGV4dGVuZHMgUHJlcGFyZUFjdGlvbjxQPiB8IHZvaWQgPSB2b2lkPiA9IElmUHJlcGFyZUFjdGlvbk1ldGhvZFByb3ZpZGVkPFBBLCBfQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQ8UEEsIFQ+LFxuLy8gZWxzZVxuSXNBbnk8UCwgQWN0aW9uQ3JlYXRvcldpdGhQYXlsb2FkPGFueSwgVD4sIElzVW5rbm93bk9yTm9uSW5mZXJyYWJsZTxQLCBBY3Rpb25DcmVhdG9yV2l0aE5vbkluZmVycmFibGVQYXlsb2FkPFQ+LFxuLy8gZWxzZVxuSWZWb2lkPFAsIEFjdGlvbkNyZWF0b3JXaXRob3V0UGF5bG9hZDxUPixcbi8vIGVsc2VcbklmTWF5YmVVbmRlZmluZWQ8UCwgQWN0aW9uQ3JlYXRvcldpdGhPcHRpb25hbFBheWxvYWQ8UCwgVD4sXG4vLyBlbHNlXG5BY3Rpb25DcmVhdG9yV2l0aFBheWxvYWQ8UCwgVD4+Pj4+PjtcblxuLyoqXG4gKiBBIHV0aWxpdHkgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIGFjdGlvbiBjcmVhdG9yIGZvciB0aGUgZ2l2ZW4gYWN0aW9uIHR5cGVcbiAqIHN0cmluZy4gVGhlIGFjdGlvbiBjcmVhdG9yIGFjY2VwdHMgYSBzaW5nbGUgYXJndW1lbnQsIHdoaWNoIHdpbGwgYmUgaW5jbHVkZWRcbiAqIGluIHRoZSBhY3Rpb24gb2JqZWN0IGFzIGEgZmllbGQgY2FsbGVkIHBheWxvYWQuIFRoZSBhY3Rpb24gY3JlYXRvciBmdW5jdGlvblxuICogd2lsbCBhbHNvIGhhdmUgaXRzIHRvU3RyaW5nKCkgb3ZlcnJpZGRlbiBzbyB0aGF0IGl0IHJldHVybnMgdGhlIGFjdGlvbiB0eXBlLlxuICpcbiAqIEBwYXJhbSB0eXBlIFRoZSBhY3Rpb24gdHlwZSB0byB1c2UgZm9yIGNyZWF0ZWQgYWN0aW9ucy5cbiAqIEBwYXJhbSBwcmVwYXJlIChvcHRpb25hbCkgYSBtZXRob2QgdGhhdCB0YWtlcyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgcmV0dXJucyB7IHBheWxvYWQgfSBvciB7IHBheWxvYWQsIG1ldGEgfS5cbiAqICAgICAgICAgICAgICAgIElmIHRoaXMgaXMgZ2l2ZW4sIHRoZSByZXN1bHRpbmcgYWN0aW9uIGNyZWF0b3Igd2lsbCBwYXNzIGl0cyBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2QgdG8gY2FsY3VsYXRlIHBheWxvYWQgJiBtZXRhLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFjdGlvbjxQID0gdm9pZCwgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4odHlwZTogVCk6IFBheWxvYWRBY3Rpb25DcmVhdG9yPFAsIFQ+O1xuXG4vKipcbiAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0byBjcmVhdGUgYW4gYWN0aW9uIGNyZWF0b3IgZm9yIHRoZSBnaXZlbiBhY3Rpb24gdHlwZVxuICogc3RyaW5nLiBUaGUgYWN0aW9uIGNyZWF0b3IgYWNjZXB0cyBhIHNpbmdsZSBhcmd1bWVudCwgd2hpY2ggd2lsbCBiZSBpbmNsdWRlZFxuICogaW4gdGhlIGFjdGlvbiBvYmplY3QgYXMgYSBmaWVsZCBjYWxsZWQgcGF5bG9hZC4gVGhlIGFjdGlvbiBjcmVhdG9yIGZ1bmN0aW9uXG4gKiB3aWxsIGFsc28gaGF2ZSBpdHMgdG9TdHJpbmcoKSBvdmVycmlkZGVuIHNvIHRoYXQgaXQgcmV0dXJucyB0aGUgYWN0aW9uIHR5cGUuXG4gKlxuICogQHBhcmFtIHR5cGUgVGhlIGFjdGlvbiB0eXBlIHRvIHVzZSBmb3IgY3JlYXRlZCBhY3Rpb25zLlxuICogQHBhcmFtIHByZXBhcmUgKG9wdGlvbmFsKSBhIG1ldGhvZCB0aGF0IHRha2VzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCByZXR1cm5zIHsgcGF5bG9hZCB9IG9yIHsgcGF5bG9hZCwgbWV0YSB9LlxuICogICAgICAgICAgICAgICAgSWYgdGhpcyBpcyBnaXZlbiwgdGhlIHJlc3VsdGluZyBhY3Rpb24gY3JlYXRvciB3aWxsIHBhc3MgaXRzIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCB0byBjYWxjdWxhdGUgcGF5bG9hZCAmIG1ldGEuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWN0aW9uPFBBIGV4dGVuZHMgUHJlcGFyZUFjdGlvbjxhbnk+LCBUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPih0eXBlOiBULCBwcmVwYXJlQWN0aW9uOiBQQSk6IFBheWxvYWRBY3Rpb25DcmVhdG9yPFJldHVyblR5cGU8UEE+WydwYXlsb2FkJ10sIFQsIFBBPjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBY3Rpb24odHlwZTogc3RyaW5nLCBwcmVwYXJlQWN0aW9uPzogRnVuY3Rpb24pOiBhbnkge1xuICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgaWYgKHByZXBhcmVBY3Rpb24pIHtcbiAgICAgIGxldCBwcmVwYXJlZCA9IHByZXBhcmVBY3Rpb24oLi4uYXJncyk7XG4gICAgICBpZiAoIXByZXBhcmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgwKSA6ICdwcmVwYXJlQWN0aW9uIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcGF5bG9hZDogcHJlcGFyZWQucGF5bG9hZCxcbiAgICAgICAgLi4uKCdtZXRhJyBpbiBwcmVwYXJlZCAmJiB7XG4gICAgICAgICAgbWV0YTogcHJlcGFyZWQubWV0YVxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKCdlcnJvcicgaW4gcHJlcGFyZWQgJiYge1xuICAgICAgICAgIGVycm9yOiBwcmVwYXJlZC5lcnJvclxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICBwYXlsb2FkOiBhcmdzWzBdXG4gICAgfTtcbiAgfVxuICBhY3Rpb25DcmVhdG9yLnRvU3RyaW5nID0gKCkgPT4gYCR7dHlwZX1gO1xuICBhY3Rpb25DcmVhdG9yLnR5cGUgPSB0eXBlO1xuICBhY3Rpb25DcmVhdG9yLm1hdGNoID0gKGFjdGlvbjogdW5rbm93bik6IGFjdGlvbiBpcyBQYXlsb2FkQWN0aW9uID0+IGlzQWN0aW9uKGFjdGlvbikgJiYgYWN0aW9uLnR5cGUgPT09IHR5cGU7XG4gIHJldHVybiBhY3Rpb25DcmVhdG9yO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhbiBSVEstbGlrZSBhY3Rpb24gY3JlYXRvciwgd2l0aCBhIHN0YXRpYyB0eXBlIHByb3BlcnR5IGFuZCBtYXRjaCBtZXRob2QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FjdGlvbkNyZWF0b3IoYWN0aW9uOiB1bmtub3duKTogYWN0aW9uIGlzIEJhc2VBY3Rpb25DcmVhdG9yPHVua25vd24sIHN0cmluZz4gJiBGdW5jdGlvbiB7XG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nICYmICd0eXBlJyBpbiBhY3Rpb24gJiZcbiAgLy8gaGFzTWF0Y2hGdW5jdGlvbiBvbmx5IHdhbnRzIE1hdGNoZXJzIGJ1dCBJIGRvbid0IHNlZSB0aGUgcG9pbnQgaW4gcmV3cml0aW5nIGl0XG4gIGhhc01hdGNoRnVuY3Rpb24oYWN0aW9uIGFzIGFueSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGFuIGFjdGlvbiB3aXRoIGEgc3RyaW5nIHR5cGUgYW5kIHZhbGlkIEZsdXggU3RhbmRhcmQgQWN0aW9uIGtleXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ZTQShhY3Rpb246IHVua25vd24pOiBhY3Rpb24gaXMge1xuICB0eXBlOiBzdHJpbmc7XG4gIHBheWxvYWQ/OiB1bmtub3duO1xuICBlcnJvcj86IHVua25vd247XG4gIG1ldGE/OiB1bmtub3duO1xufSB7XG4gIHJldHVybiBpc0FjdGlvbihhY3Rpb24pICYmIE9iamVjdC5rZXlzKGFjdGlvbikuZXZlcnkoaXNWYWxpZEtleSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleTogc3RyaW5nKSB7XG4gIHJldHVybiBbJ3R5cGUnLCAncGF5bG9hZCcsICdlcnJvcicsICdtZXRhJ10uaW5kZXhPZihrZXkpID4gLTE7XG59XG5cbi8vIGhlbHBlciB0eXBlcyBmb3IgbW9yZSByZWFkYWJsZSB0eXBpbmdzXG5cbnR5cGUgSWZQcmVwYXJlQWN0aW9uTWV0aG9kUHJvdmlkZWQ8UEEgZXh0ZW5kcyBQcmVwYXJlQWN0aW9uPGFueT4gfCB2b2lkLCBUcnVlLCBGYWxzZT4gPSBQQSBleHRlbmRzICgoLi4uYXJnczogYW55W10pID0+IGFueSkgPyBUcnVlIDogRmFsc2U7IiwiaW1wb3J0IHR5cGUgeyBNaWRkbGV3YXJlLCBTdG9yZUVuaGFuY2VyIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHR5cGUgeyBUdXBsZSB9IGZyb20gJy4vdXRpbHMnO1xuZXhwb3J0IGZ1bmN0aW9uIHNhZmVBc3NpZ248VCBleHRlbmRzIG9iamVjdD4odGFyZ2V0OiBULCAuLi5hcmdzOiBBcnJheTxQYXJ0aWFsPE5vSW5mZXI8VD4+Pikge1xuICBPYmplY3QuYXNzaWduKHRhcmdldCwgLi4uYXJncyk7XG59XG5cbi8qKlxuICogcmV0dXJuIFRydWUgaWYgVCBpcyBgYW55YCwgb3RoZXJ3aXNlIHJldHVybiBGYWxzZVxuICogdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vam9vbmhvY2hvL3RzZGVmXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCB0eXBlIElzQW55PFQsIFRydWUsIEZhbHNlID0gbmV2ZXI+ID1cbi8vIHRlc3QgaWYgd2UgYXJlIGdvaW5nIHRoZSBsZWZ0IEFORCByaWdodCBwYXRoIGluIHRoZSBjb25kaXRpb25cbnRydWUgfCBmYWxzZSBleHRlbmRzIChUIGV4dGVuZHMgbmV2ZXIgPyB0cnVlIDogZmFsc2UpID8gVHJ1ZSA6IEZhbHNlO1xuZXhwb3J0IHR5cGUgQ2FzdEFueTxULCBDYXN0VG8+ID0gSXNBbnk8VCwgQ2FzdFRvLCBUPjtcblxuLyoqXG4gKiByZXR1cm4gVHJ1ZSBpZiBUIGlzIGB1bmtub3duYCwgb3RoZXJ3aXNlIHJldHVybiBGYWxzZVxuICogdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vam9vbmhvY2hvL3RzZGVmXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCB0eXBlIElzVW5rbm93bjxULCBUcnVlLCBGYWxzZSA9IG5ldmVyPiA9IHVua25vd24gZXh0ZW5kcyBUID8gSXNBbnk8VCwgRmFsc2UsIFRydWU+IDogRmFsc2U7XG5leHBvcnQgdHlwZSBGYWxsYmFja0lmVW5rbm93bjxULCBGYWxsYmFjaz4gPSBJc1Vua25vd248VCwgRmFsbGJhY2ssIFQ+O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdHlwZSBJZk1heWJlVW5kZWZpbmVkPFAsIFRydWUsIEZhbHNlPiA9IFt1bmRlZmluZWRdIGV4dGVuZHMgW1BdID8gVHJ1ZSA6IEZhbHNlO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdHlwZSBJZlZvaWQ8UCwgVHJ1ZSwgRmFsc2U+ID0gW3ZvaWRdIGV4dGVuZHMgW1BdID8gVHJ1ZSA6IEZhbHNlO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdHlwZSBJc0VtcHR5T2JqPFQsIFRydWUsIEZhbHNlID0gbmV2ZXI+ID0gVCBleHRlbmRzIGFueSA/IGtleW9mIFQgZXh0ZW5kcyBuZXZlciA/IElzVW5rbm93bjxULCBGYWxzZSwgSWZNYXliZVVuZGVmaW5lZDxULCBGYWxzZSwgSWZWb2lkPFQsIEZhbHNlLCBUcnVlPj4+IDogRmFsc2UgOiBuZXZlcjtcblxuLyoqXG4gKiByZXR1cm5zIFRydWUgaWYgVFMgdmVyc2lvbiBpcyBhYm92ZSAzLjUsIEZhbHNlIGlmIGJlbG93LlxuICogdXNlcyBmZWF0dXJlIGRldGVjdGlvbiB0byBkZXRlY3QgVFMgdmVyc2lvbiA+PSAzLjVcbiAqICogdmVyc2lvbnMgYmVsb3cgMy41IHdpbGwgcmV0dXJuIGB7fWAgZm9yIHVucmVzb2x2YWJsZSBpbnRlcmZlcmVuY2VcbiAqICogdmVyc2lvbnMgYWJvdmUgd2lsbCByZXR1cm4gYHVua25vd25gXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCB0eXBlIEF0TGVhc3RUUzM1PFRydWUsIEZhbHNlPiA9IFtUcnVlLCBGYWxzZV1bSXNVbmtub3duPFJldHVyblR5cGU8PFQ+KCkgPT4gVD4sIDAsIDE+XTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgSXNVbmtub3duT3JOb25JbmZlcnJhYmxlPFQsIFRydWUsIEZhbHNlPiA9IEF0TGVhc3RUUzM1PElzVW5rbm93bjxULCBUcnVlLCBGYWxzZT4sIElzRW1wdHlPYmo8VCwgVHJ1ZSwgSXNVbmtub3duPFQsIFRydWUsIEZhbHNlPj4+O1xuXG4vKipcbiAqIENvbnZlcnQgYSBVbmlvbiB0eXBlIGAoQXxCKWAgdG8gYW4gaW50ZXJzZWN0aW9uIHR5cGUgYChBJkIpYFxuICovXG5leHBvcnQgdHlwZSBVbmlvblRvSW50ZXJzZWN0aW9uPFU+ID0gKFUgZXh0ZW5kcyBhbnkgPyAoazogVSkgPT4gdm9pZCA6IG5ldmVyKSBleHRlbmRzICgoazogaW5mZXIgSSkgPT4gdm9pZCkgPyBJIDogbmV2ZXI7XG5cbi8vIEFwcGVhcnMgdG8gaGF2ZSBhIGNvbnZlbmllbnQgc2lkZSBlZmZlY3Qgb2YgaWdub3JpbmcgYG5ldmVyYCBldmVuIGlmIHRoYXQncyBub3Qgd2hhdCB5b3Ugc3BlY2lmaWVkXG5leHBvcnQgdHlwZSBFeGNsdWRlRnJvbVR1cGxlPFQsIEUsIEFjYyBleHRlbmRzIHVua25vd25bXSA9IFtdPiA9IFQgZXh0ZW5kcyBbaW5mZXIgSGVhZCwgLi4uaW5mZXIgVGFpbF0gPyBFeGNsdWRlRnJvbVR1cGxlPFRhaWwsIEUsIFsuLi5BY2MsIC4uLihbSGVhZF0gZXh0ZW5kcyBbRV0gPyBbXSA6IFtIZWFkXSldPiA6IEFjYztcbnR5cGUgRXh0cmFjdERpc3BhdGNoRnJvbU1pZGRsZXdhcmVUdXBsZTxNaWRkbGV3YXJlVHVwbGUgZXh0ZW5kcyByZWFkb25seSBhbnlbXSwgQWNjIGV4dGVuZHMge30+ID0gTWlkZGxld2FyZVR1cGxlIGV4dGVuZHMgW2luZmVyIEhlYWQsIC4uLmluZmVyIFRhaWxdID8gRXh0cmFjdERpc3BhdGNoRnJvbU1pZGRsZXdhcmVUdXBsZTxUYWlsLCBBY2MgJiAoSGVhZCBleHRlbmRzIE1pZGRsZXdhcmU8aW5mZXIgRD4gPyBJc0FueTxELCB7fSwgRD4gOiB7fSk+IDogQWNjO1xuZXhwb3J0IHR5cGUgRXh0cmFjdERpc3BhdGNoRXh0ZW5zaW9uczxNPiA9IE0gZXh0ZW5kcyBUdXBsZTxpbmZlciBNaWRkbGV3YXJlVHVwbGU+ID8gRXh0cmFjdERpc3BhdGNoRnJvbU1pZGRsZXdhcmVUdXBsZTxNaWRkbGV3YXJlVHVwbGUsIHt9PiA6IE0gZXh0ZW5kcyBSZWFkb25seUFycmF5PE1pZGRsZXdhcmU+ID8gRXh0cmFjdERpc3BhdGNoRnJvbU1pZGRsZXdhcmVUdXBsZTxbLi4uTV0sIHt9PiA6IG5ldmVyO1xudHlwZSBFeHRyYWN0U3RvcmVFeHRlbnNpb25zRnJvbUVuaGFuY2VyVHVwbGU8RW5oYW5jZXJUdXBsZSBleHRlbmRzIHJlYWRvbmx5IGFueVtdLCBBY2MgZXh0ZW5kcyB7fT4gPSBFbmhhbmNlclR1cGxlIGV4dGVuZHMgW2luZmVyIEhlYWQsIC4uLmluZmVyIFRhaWxdID8gRXh0cmFjdFN0b3JlRXh0ZW5zaW9uc0Zyb21FbmhhbmNlclR1cGxlPFRhaWwsIEFjYyAmIChIZWFkIGV4dGVuZHMgU3RvcmVFbmhhbmNlcjxpbmZlciBFeHQ+ID8gSXNBbnk8RXh0LCB7fSwgRXh0PiA6IHt9KT4gOiBBY2M7XG5leHBvcnQgdHlwZSBFeHRyYWN0U3RvcmVFeHRlbnNpb25zPEU+ID0gRSBleHRlbmRzIFR1cGxlPGluZmVyIEVuaGFuY2VyVHVwbGU+ID8gRXh0cmFjdFN0b3JlRXh0ZW5zaW9uc0Zyb21FbmhhbmNlclR1cGxlPEVuaGFuY2VyVHVwbGUsIHt9PiA6IEUgZXh0ZW5kcyBSZWFkb25seUFycmF5PFN0b3JlRW5oYW5jZXI+ID8gVW5pb25Ub0ludGVyc2VjdGlvbjxFW251bWJlcl0gZXh0ZW5kcyBTdG9yZUVuaGFuY2VyPGluZmVyIEV4dD4gPyBFeHQgZXh0ZW5kcyB7fSA/IElzQW55PEV4dCwge30sIEV4dD4gOiB7fSA6IHt9PiA6IG5ldmVyO1xudHlwZSBFeHRyYWN0U3RhdGVFeHRlbnNpb25zRnJvbUVuaGFuY2VyVHVwbGU8RW5oYW5jZXJUdXBsZSBleHRlbmRzIHJlYWRvbmx5IGFueVtdLCBBY2MgZXh0ZW5kcyB7fT4gPSBFbmhhbmNlclR1cGxlIGV4dGVuZHMgW2luZmVyIEhlYWQsIC4uLmluZmVyIFRhaWxdID8gRXh0cmFjdFN0YXRlRXh0ZW5zaW9uc0Zyb21FbmhhbmNlclR1cGxlPFRhaWwsIEFjYyAmIChIZWFkIGV4dGVuZHMgU3RvcmVFbmhhbmNlcjxhbnksIGluZmVyIFN0YXRlRXh0PiA/IElzQW55PFN0YXRlRXh0LCB7fSwgU3RhdGVFeHQ+IDoge30pPiA6IEFjYztcbmV4cG9ydCB0eXBlIEV4dHJhY3RTdGF0ZUV4dGVuc2lvbnM8RT4gPSBFIGV4dGVuZHMgVHVwbGU8aW5mZXIgRW5oYW5jZXJUdXBsZT4gPyBFeHRyYWN0U3RhdGVFeHRlbnNpb25zRnJvbUVuaGFuY2VyVHVwbGU8RW5oYW5jZXJUdXBsZSwge30+IDogRSBleHRlbmRzIFJlYWRvbmx5QXJyYXk8U3RvcmVFbmhhbmNlcj4gPyBVbmlvblRvSW50ZXJzZWN0aW9uPEVbbnVtYmVyXSBleHRlbmRzIFN0b3JlRW5oYW5jZXI8YW55LCBpbmZlciBTdGF0ZUV4dD4gPyBTdGF0ZUV4dCBleHRlbmRzIHt9ID8gSXNBbnk8U3RhdGVFeHQsIHt9LCBTdGF0ZUV4dD4gOiB7fSA6IHt9PiA6IG5ldmVyO1xuXG4vKipcbiAqIEhlbHBlciB0eXBlLiBQYXNzZXMgVCBvdXQgYWdhaW4sIGJ1dCBib3hlcyBpdCBpbiBhIHdheSB0aGF0IGl0IGNhbm5vdFxuICogXCJ3aWRlblwiIHRoZSB0eXBlIGJ5IGFjY2lkZW50IGlmIGl0IGlzIGEgZ2VuZXJpYyB0aGF0IHNob3VsZCBiZSBpbmZlcnJlZFxuICogZnJvbSBlbHNld2hlcmUuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCB0eXBlIE5vSW5mZXI8VD4gPSBbVF1bVCBleHRlbmRzIGFueSA/IDAgOiBuZXZlcl07XG5leHBvcnQgdHlwZSBOb25VbmRlZmluZWQ8VD4gPSBUIGV4dGVuZHMgdW5kZWZpbmVkID8gbmV2ZXIgOiBUO1xuZXhwb3J0IHR5cGUgV2l0aFJlcXVpcmVkUHJvcDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBPbWl0PFQsIEs+ICYgUmVxdWlyZWQ8UGljazxULCBLPj47XG5leHBvcnQgdHlwZSBXaXRoT3B0aW9uYWxQcm9wPFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IE9taXQ8VCwgSz4gJiBQYXJ0aWFsPFBpY2s8VCwgSz4+O1xuZXhwb3J0IGludGVyZmFjZSBUeXBlR3VhcmQ8VD4ge1xuICAodmFsdWU6IGFueSk6IHZhbHVlIGlzIFQ7XG59XG5leHBvcnQgaW50ZXJmYWNlIEhhc01hdGNoRnVuY3Rpb248VD4ge1xuICBtYXRjaDogVHlwZUd1YXJkPFQ+O1xufVxuZXhwb3J0IGNvbnN0IGhhc01hdGNoRnVuY3Rpb24gPSA8VCw+KHY6IE1hdGNoZXI8VD4pOiB2IGlzIEhhc01hdGNoRnVuY3Rpb248VD4gPT4ge1xuICByZXR1cm4gdiAmJiB0eXBlb2YgKHYgYXMgSGFzTWF0Y2hGdW5jdGlvbjxUPikubWF0Y2ggPT09ICdmdW5jdGlvbic7XG59O1xuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IHR5cGUgTWF0Y2hlcjxUPiA9IEhhc01hdGNoRnVuY3Rpb248VD4gfCBUeXBlR3VhcmQ8VD47XG5cbi8qKiBAcHVibGljICovXG5leHBvcnQgdHlwZSBBY3Rpb25Gcm9tTWF0Y2hlcjxNIGV4dGVuZHMgTWF0Y2hlcjxhbnk+PiA9IE0gZXh0ZW5kcyBNYXRjaGVyPGluZmVyIFQ+ID8gVCA6IG5ldmVyO1xuZXhwb3J0IHR5cGUgSWQ8VD4gPSB7IFtLIGluIGtleW9mIFRdOiBUW0tdIH0gJiB7fTtcbmV4cG9ydCB0eXBlIFRhaWw8VCBleHRlbmRzIGFueVtdPiA9IFQgZXh0ZW5kcyBbYW55LCAuLi5pbmZlciBUYWlsXSA/IFRhaWwgOiBuZXZlcjtcbmV4cG9ydCB0eXBlIFVua25vd25JZk5vblNwZWNpZmljPFQ+ID0ge30gZXh0ZW5kcyBUID8gdW5rbm93biA6IFQ7XG5cbi8qKlxuICogQSBQcm9taXNlIHRoYXQgd2lsbCBuZXZlciByZWplY3QuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWR1eGpzL3JlZHV4LXRvb2xraXQvaXNzdWVzLzQxMDFcbiAqL1xuZXhwb3J0IHR5cGUgU2FmZVByb21pc2U8VD4gPSBQcm9taXNlPFQ+ICYge1xuICBfX2xpbnRlckJyYW5kczogJ1NhZmVQcm9taXNlJztcbn07XG5cbi8qKlxuICogUHJvcGVybHkgd3JhcHMgYSBQcm9taXNlIGFzIGEge0BsaW5rIFNhZmVQcm9taXNlfSB3aXRoIC5jYXRjaChmYWxsYmFjaykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc1NhZmVQcm9taXNlPFJlc29sdmVkLCBSZWplY3RlZD4ocHJvbWlzZTogUHJvbWlzZTxSZXNvbHZlZD4sIGZhbGxiYWNrOiAoZXJyb3I6IHVua25vd24pID0+IFJlamVjdGVkKSB7XG4gIHJldHVybiBwcm9taXNlLmNhdGNoKGZhbGxiYWNrKSBhcyBTYWZlUHJvbWlzZTxSZXNvbHZlZCB8IFJlamVjdGVkPjtcbn0iLCJpbXBvcnQgdHlwZSB7IE1pZGRsZXdhcmUgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBpc0FjdGlvbkNyZWF0b3IgYXMgaXNSVEtBY3Rpb24gfSBmcm9tICcuL2NyZWF0ZUFjdGlvbic7XG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gdG8gaWRlbnRpZnkgd2hldGhlciBhIHZhbHVlIGlzIGFuIGFjdGlvbiBjcmVhdG9yLlxuICAgKiBUaGUgZGVmYXVsdCBjaGVja3MgZm9yIGEgZnVuY3Rpb24gd2l0aCBhIHN0YXRpYyB0eXBlIHByb3BlcnR5IGFuZCBtYXRjaCBtZXRob2QuXG4gICAqL1xuICBpc0FjdGlvbkNyZWF0b3I/OiAoYWN0aW9uOiB1bmtub3duKSA9PiBhY3Rpb24gaXMgRnVuY3Rpb24gJiB7XG4gICAgdHlwZT86IHVua25vd247XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVzc2FnZSh0eXBlPzogdW5rbm93bikge1xuICBjb25zdCBzcGxpdFR5cGUgPSB0eXBlID8gYCR7dHlwZX1gLnNwbGl0KCcvJykgOiBbXTtcbiAgY29uc3QgYWN0aW9uTmFtZSA9IHNwbGl0VHlwZVtzcGxpdFR5cGUubGVuZ3RoIC0gMV0gfHwgJ2FjdGlvbkNyZWF0b3InO1xuICByZXR1cm4gYERldGVjdGVkIGFuIGFjdGlvbiBjcmVhdG9yIHdpdGggdHlwZSBcIiR7dHlwZSB8fCAndW5rbm93bid9XCIgYmVpbmcgZGlzcGF0Y2hlZC4gXG5NYWtlIHN1cmUgeW91J3JlIGNhbGxpbmcgdGhlIGFjdGlvbiBjcmVhdG9yIGJlZm9yZSBkaXNwYXRjaGluZywgaS5lLiBcXGBkaXNwYXRjaCgke2FjdGlvbk5hbWV9KCkpXFxgIGluc3RlYWQgb2YgXFxgZGlzcGF0Y2goJHthY3Rpb25OYW1lfSlcXGAuIFRoaXMgaXMgbmVjZXNzYXJ5IGV2ZW4gaWYgdGhlIGFjdGlvbiBoYXMgbm8gcGF5bG9hZC5gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnM6IEFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9ucyA9IHt9KTogTWlkZGxld2FyZSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcmV0dXJuICgpID0+IG5leHQgPT4gYWN0aW9uID0+IG5leHQoYWN0aW9uKTtcbiAgfVxuICBjb25zdCB7XG4gICAgaXNBY3Rpb25DcmVhdG9yID0gaXNSVEtBY3Rpb25cbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiAoKSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKGlzQWN0aW9uQ3JlYXRvcihhY3Rpb24pKSB7XG4gICAgICBjb25zb2xlLndhcm4oZ2V0TWVzc2FnZShhY3Rpb24udHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICB9O1xufSIsImltcG9ydCB7IHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlLCBpc0RyYWZ0YWJsZSB9IGZyb20gJ2ltbWVyJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRUaW1lTWVhc3VyZVV0aWxzKG1heERlbGF5OiBudW1iZXIsIGZuTmFtZTogc3RyaW5nKSB7XG4gIGxldCBlbGFwc2VkID0gMDtcbiAgcmV0dXJuIHtcbiAgICBtZWFzdXJlVGltZTxUPihmbjogKCkgPT4gVCk6IFQge1xuICAgICAgY29uc3Qgc3RhcnRlZCA9IERhdGUubm93KCk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnN0IGZpbmlzaGVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgZWxhcHNlZCArPSBmaW5pc2hlZCAtIHN0YXJ0ZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXJuSWZFeGNlZWRlZCgpIHtcbiAgICAgIGlmIChlbGFwc2VkID4gbWF4RGVsYXkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGAke2ZuTmFtZX0gdG9vayAke2VsYXBzZWR9bXMsIHdoaWNoIGlzIG1vcmUgdGhhbiB0aGUgd2FybmluZyB0aHJlc2hvbGQgb2YgJHttYXhEZWxheX1tcy4gXG5JZiB5b3VyIHN0YXRlIG9yIGFjdGlvbnMgYXJlIHZlcnkgbGFyZ2UsIHlvdSBtYXkgd2FudCB0byBkaXNhYmxlIHRoZSBtaWRkbGV3YXJlIGFzIGl0IG1pZ2h0IGNhdXNlIHRvbyBtdWNoIG9mIGEgc2xvd2Rvd24gaW4gZGV2ZWxvcG1lbnQgbW9kZS4gU2VlIGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2dldERlZmF1bHRNaWRkbGV3YXJlIGZvciBpbnN0cnVjdGlvbnMuXG5JdCBpcyBkaXNhYmxlZCBpbiBwcm9kdWN0aW9uIGJ1aWxkcywgc28geW91IGRvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhhdC5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZGVsYXkobXM6IG51bWJlcikge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5leHBvcnQgY2xhc3MgVHVwbGU8SXRlbXMgZXh0ZW5kcyBSZWFkb25seUFycmF5PHVua25vd24+ID0gW10+IGV4dGVuZHMgQXJyYXk8SXRlbXNbbnVtYmVyXT4ge1xuICBjb25zdHJ1Y3RvcihsZW5ndGg6IG51bWJlcik7XG4gIGNvbnN0cnVjdG9yKC4uLml0ZW1zOiBJdGVtcyk7XG4gIGNvbnN0cnVjdG9yKC4uLml0ZW1zOiBhbnlbXSkge1xuICAgIHN1cGVyKC4uLml0ZW1zKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVHVwbGUucHJvdG90eXBlKTtcbiAgfVxuICBzdGF0aWMgb3ZlcnJpZGUgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7XG4gICAgcmV0dXJuIFR1cGxlIGFzIGFueTtcbiAgfVxuICBvdmVycmlkZSBjb25jYXQ8QWRkaXRpb25hbEl0ZW1zIGV4dGVuZHMgUmVhZG9ubHlBcnJheTx1bmtub3duPj4oaXRlbXM6IFR1cGxlPEFkZGl0aW9uYWxJdGVtcz4pOiBUdXBsZTxbLi4uSXRlbXMsIC4uLkFkZGl0aW9uYWxJdGVtc10+O1xuICBvdmVycmlkZSBjb25jYXQ8QWRkaXRpb25hbEl0ZW1zIGV4dGVuZHMgUmVhZG9ubHlBcnJheTx1bmtub3duPj4oaXRlbXM6IEFkZGl0aW9uYWxJdGVtcyk6IFR1cGxlPFsuLi5JdGVtcywgLi4uQWRkaXRpb25hbEl0ZW1zXT47XG4gIG92ZXJyaWRlIGNvbmNhdDxBZGRpdGlvbmFsSXRlbXMgZXh0ZW5kcyBSZWFkb25seUFycmF5PHVua25vd24+PiguLi5pdGVtczogQWRkaXRpb25hbEl0ZW1zKTogVHVwbGU8Wy4uLkl0ZW1zLCAuLi5BZGRpdGlvbmFsSXRlbXNdPjtcbiAgb3ZlcnJpZGUgY29uY2F0KC4uLmFycjogYW55W10pIHtcbiAgICByZXR1cm4gc3VwZXIuY29uY2F0LmFwcGx5KHRoaXMsIGFycik7XG4gIH1cbiAgcHJlcGVuZDxBZGRpdGlvbmFsSXRlbXMgZXh0ZW5kcyBSZWFkb25seUFycmF5PHVua25vd24+PihpdGVtczogVHVwbGU8QWRkaXRpb25hbEl0ZW1zPik6IFR1cGxlPFsuLi5BZGRpdGlvbmFsSXRlbXMsIC4uLkl0ZW1zXT47XG4gIHByZXBlbmQ8QWRkaXRpb25hbEl0ZW1zIGV4dGVuZHMgUmVhZG9ubHlBcnJheTx1bmtub3duPj4oaXRlbXM6IEFkZGl0aW9uYWxJdGVtcyk6IFR1cGxlPFsuLi5BZGRpdGlvbmFsSXRlbXMsIC4uLkl0ZW1zXT47XG4gIHByZXBlbmQ8QWRkaXRpb25hbEl0ZW1zIGV4dGVuZHMgUmVhZG9ubHlBcnJheTx1bmtub3duPj4oLi4uaXRlbXM6IEFkZGl0aW9uYWxJdGVtcyk6IFR1cGxlPFsuLi5BZGRpdGlvbmFsSXRlbXMsIC4uLkl0ZW1zXT47XG4gIHByZXBlbmQoLi4uYXJyOiBhbnlbXSkge1xuICAgIGlmIChhcnIubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJyWzBdKSkge1xuICAgICAgcmV0dXJuIG5ldyBUdXBsZSguLi5hcnJbMF0uY29uY2F0KHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUdXBsZSguLi5hcnIuY29uY2F0KHRoaXMpKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGZyZWV6ZURyYWZ0YWJsZTxUPih2YWw6IFQpIHtcbiAgcmV0dXJuIGlzRHJhZnRhYmxlKHZhbCkgPyBjcmVhdGVOZXh0U3RhdGUodmFsLCAoKSA9PiB7fSkgOiB2YWw7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0T3JJbnNlcnQ8SyBleHRlbmRzIG9iamVjdCwgVj4obWFwOiBXZWFrTWFwPEssIFY+LCBrZXk6IEssIHZhbHVlOiBWKTogVjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRPckluc2VydDxLLCBWPihtYXA6IE1hcDxLLCBWPiwga2V5OiBLLCB2YWx1ZTogVik6IFY7XG5leHBvcnQgZnVuY3Rpb24gZ2V0T3JJbnNlcnQ8SyBleHRlbmRzIG9iamVjdCwgVj4obWFwOiBNYXA8SywgVj4gfCBXZWFrTWFwPEssIFY+LCBrZXk6IEssIHZhbHVlOiBWKTogViB7XG4gIGlmIChtYXAuaGFzKGtleSkpIHJldHVybiBtYXAuZ2V0KGtleSkgYXMgVjtcbiAgcmV0dXJuIG1hcC5zZXQoa2V5LCB2YWx1ZSkuZ2V0KGtleSkgYXMgVjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRPckluc2VydENvbXB1dGVkPEsgZXh0ZW5kcyBvYmplY3QsIFY+KG1hcDogV2Vha01hcDxLLCBWPiwga2V5OiBLLCBjb21wdXRlOiAoa2V5OiBLKSA9PiBWKTogVjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRPckluc2VydENvbXB1dGVkPEssIFY+KG1hcDogTWFwPEssIFY+LCBrZXk6IEssIGNvbXB1dGU6IChrZXk6IEspID0+IFYpOiBWO1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9ySW5zZXJ0Q29tcHV0ZWQ8SyBleHRlbmRzIG9iamVjdCwgVj4obWFwOiBNYXA8SywgVj4gfCBXZWFrTWFwPEssIFY+LCBrZXk6IEssIGNvbXB1dGU6IChrZXk6IEspID0+IFYpOiBWIHtcbiAgaWYgKG1hcC5oYXMoa2V5KSkgcmV0dXJuIG1hcC5nZXQoa2V5KSBhcyBWO1xuICByZXR1cm4gbWFwLnNldChrZXksIGNvbXB1dGUoa2V5KSkuZ2V0KGtleSkgYXMgVjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcm9taXNlV2l0aFJlc29sdmVyczxUPigpOiB7XG4gIHByb21pc2U6IFByb21pc2U8VD47XG4gIHJlc29sdmU6ICh2YWx1ZTogVCB8IFByb21pc2VMaWtlPFQ+KSA9PiB2b2lkO1xuICByZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWQ7XG59IHtcbiAgbGV0IHJlc29sdmU6IGFueTtcbiAgbGV0IHJlamVjdDogYW55O1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8VD4oKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgcmVzb2x2ZSxcbiAgICByZWplY3RcbiAgfTtcbn0iLCJpbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLCBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgdHlwZSB7IE1pZGRsZXdhcmUgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgdHlwZSB7IElnbm9yZVBhdGhzIH0gZnJvbSAnLi9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUnO1xuaW1wb3J0IHsgZ2V0VGltZU1lYXN1cmVVdGlscyB9IGZyb20gJy4vdXRpbHMnO1xudHlwZSBFbnRyeVByb2Nlc3NvciA9IChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gYW55O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGBpc0ltbXV0YWJsZWAgZnVuY3Rpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlOiB1bmtub3duKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09IG51bGwgfHwgT2JqZWN0LmlzRnJvemVuKHZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmFja0Zvck11dGF0aW9ucyhpc0ltbXV0YWJsZTogSXNJbW11dGFibGVGdW5jLCBpZ25vcmVQYXRoczogSWdub3JlUGF0aHMgfCB1bmRlZmluZWQsIG9iajogYW55KSB7XG4gIGNvbnN0IHRyYWNrZWRQcm9wZXJ0aWVzID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKTtcbiAgcmV0dXJuIHtcbiAgICBkZXRlY3RNdXRhdGlvbnMoKSB7XG4gICAgICByZXR1cm4gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgdHJhY2tlZFByb3BlcnRpZXMsIG9iaik7XG4gICAgfVxuICB9O1xufVxuaW50ZXJmYWNlIFRyYWNrZWRQcm9wZXJ0eSB7XG4gIHZhbHVlOiBhbnk7XG4gIGNoaWxkcmVuOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufVxuZnVuY3Rpb24gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlOiBJc0ltbXV0YWJsZUZ1bmMsIGlnbm9yZVBhdGhzOiBJZ25vcmVQYXRocyA9IFtdLCBvYmo6IFJlY29yZDxzdHJpbmcsIGFueT4sIHBhdGg6IHN0cmluZyA9ICcnLCBjaGVja2VkT2JqZWN0czogU2V0PFJlY29yZDxzdHJpbmcsIGFueT4+ID0gbmV3IFNldCgpKSB7XG4gIGNvbnN0IHRyYWNrZWQ6IFBhcnRpYWw8VHJhY2tlZFByb3BlcnR5PiA9IHtcbiAgICB2YWx1ZTogb2JqXG4gIH07XG4gIGlmICghaXNJbW11dGFibGUob2JqKSAmJiAhY2hlY2tlZE9iamVjdHMuaGFzKG9iaikpIHtcbiAgICBjaGVja2VkT2JqZWN0cy5hZGQob2JqKTtcbiAgICB0cmFja2VkLmNoaWxkcmVuID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoID8gcGF0aCArICcuJyArIGtleSA6IGtleTtcbiAgICAgIGlmIChpZ25vcmVQYXRocy5sZW5ndGggJiYgaWdub3JlUGF0aHMuaW5kZXhPZihjaGlsZFBhdGgpICE9PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRyYWNrZWQuY2hpbGRyZW5ba2V5XSA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9ialtrZXldLCBjaGlsZFBhdGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhY2tlZCBhcyBUcmFja2VkUHJvcGVydHk7XG59XG5mdW5jdGlvbiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGU6IElzSW1tdXRhYmxlRnVuYywgaWdub3JlZFBhdGhzOiBJZ25vcmVQYXRocyA9IFtdLCB0cmFja2VkUHJvcGVydHk6IFRyYWNrZWRQcm9wZXJ0eSwgb2JqOiBhbnksIHNhbWVQYXJlbnRSZWY6IGJvb2xlYW4gPSBmYWxzZSwgcGF0aDogc3RyaW5nID0gJycpOiB7XG4gIHdhc011dGF0ZWQ6IGJvb2xlYW47XG4gIHBhdGg/OiBzdHJpbmc7XG59IHtcbiAgY29uc3QgcHJldk9iaiA9IHRyYWNrZWRQcm9wZXJ0eSA/IHRyYWNrZWRQcm9wZXJ0eS52YWx1ZSA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgc2FtZVJlZiA9IHByZXZPYmogPT09IG9iajtcbiAgaWYgKHNhbWVQYXJlbnRSZWYgJiYgIXNhbWVSZWYgJiYgIU51bWJlci5pc05hTihvYmopKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhc011dGF0ZWQ6IHRydWUsXG4gICAgICBwYXRoXG4gICAgfTtcbiAgfVxuICBpZiAoaXNJbW11dGFibGUocHJldk9iaikgfHwgaXNJbW11dGFibGUob2JqKSkge1xuICAgIHJldHVybiB7XG4gICAgICB3YXNNdXRhdGVkOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICAvLyBHYXRoZXIgYWxsIGtleXMgZnJvbSBwcmV2ICh0cmFja2VkKSBhbmQgYWZ0ZXIgb2Jqc1xuICBjb25zdCBrZXlzVG9EZXRlY3Q6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+ID0ge307XG4gIGZvciAobGV0IGtleSBpbiB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW4pIHtcbiAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XG4gIH1cbiAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgIGtleXNUb0RldGVjdFtrZXldID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBoYXNJZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMubGVuZ3RoID4gMDtcbiAgZm9yIChsZXQga2V5IGluIGtleXNUb0RldGVjdCkge1xuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArICcuJyArIGtleSA6IGtleTtcbiAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XG4gICAgICBjb25zdCBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoaWdub3JlZCA9PiB7XG4gICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgcmV0dXJuIGlnbm9yZWQudGVzdChuZXN0ZWRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVzdGVkUGF0aCA9PT0gaWdub3JlZDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc01hdGNoZXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzLCB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW5ba2V5XSwgb2JqW2tleV0sIHNhbWVSZWYsIG5lc3RlZFBhdGgpO1xuICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3YXNNdXRhdGVkOiBmYWxzZVxuICB9O1xufVxudHlwZSBJc0ltbXV0YWJsZUZ1bmMgPSAodmFsdWU6IGFueSkgPT4gYm9vbGVhbjtcblxuLyoqXG4gKiBPcHRpb25zIGZvciBgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKClgLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVPcHRpb25zIHtcbiAgLyoqXG4gICAgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBjb25zaWRlcmVkIHRvIGJlIGltbXV0YWJsZS5cbiAgICBUaGlzIGZ1bmN0aW9uIGlzIGFwcGxpZWQgcmVjdXJzaXZlbHkgdG8gZXZlcnkgdmFsdWUgY29udGFpbmVkIGluIHRoZSBzdGF0ZS5cbiAgICBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsIHJldHVybiB0cnVlIGZvciBwcmltaXRpdmUgdHlwZXNcbiAgICAobGlrZSBudW1iZXJzLCBzdHJpbmdzLCBib29sZWFucywgbnVsbCBhbmQgdW5kZWZpbmVkKS5cbiAgICovXG4gIGlzSW1tdXRhYmxlPzogSXNJbW11dGFibGVGdW5jO1xuICAvKipcbiAgICBBbiBhcnJheSBvZiBkb3Qtc2VwYXJhdGVkIHBhdGggc3RyaW5ncyB0aGF0IG1hdGNoIG5hbWVkIG5vZGVzIGZyb21cbiAgICB0aGUgcm9vdCBzdGF0ZSB0byBpZ25vcmUgd2hlbiBjaGVja2luZyBmb3IgaW1tdXRhYmlsaXR5LlxuICAgIERlZmF1bHRzIHRvIHVuZGVmaW5lZFxuICAgKi9cbiAgaWdub3JlZFBhdGhzPzogSWdub3JlUGF0aHM7XG4gIC8qKiBQcmludCBhIHdhcm5pbmcgaWYgY2hlY2tzIHRha2UgbG9uZ2VyIHRoYW4gTiBtcy4gRGVmYXVsdDogMzJtcyAqL1xuICB3YXJuQWZ0ZXI/OiBudW1iZXI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1pZGRsZXdhcmUgdGhhdCBjaGVja3Mgd2hldGhlciBhbnkgc3RhdGUgd2FzIG11dGF0ZWQgaW4gYmV0d2VlblxuICogZGlzcGF0Y2hlcyBvciBkdXJpbmcgYSBkaXNwYXRjaC4gSWYgYW55IG11dGF0aW9ucyBhcmUgZGV0ZWN0ZWQsIGFuIGVycm9yIGlzXG4gKiB0aHJvd24uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgTWlkZGxld2FyZSBvcHRpb25zLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zOiBJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVPcHRpb25zID0ge30pOiBNaWRkbGV3YXJlIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gKCkgPT4gbmV4dCA9PiBhY3Rpb24gPT4gbmV4dChhY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShvYmo6IGFueSwgc2VyaWFsaXplcj86IEVudHJ5UHJvY2Vzc29yLCBpbmRlbnQ/OiBzdHJpbmcgfCBudW1iZXIsIGRlY3ljbGVyPzogRW50cnlQcm9jZXNzb3IpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgZ2V0U2VyaWFsaXplKHNlcmlhbGl6ZXIsIGRlY3ljbGVyKSwgaW5kZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U2VyaWFsaXplKHNlcmlhbGl6ZXI/OiBFbnRyeVByb2Nlc3NvciwgZGVjeWNsZXI/OiBFbnRyeVByb2Nlc3Nvcik6IEVudHJ5UHJvY2Vzc29yIHtcbiAgICAgIGxldCBzdGFjazogYW55W10gPSBbXSxcbiAgICAgICAga2V5czogYW55W10gPSBbXTtcbiAgICAgIGlmICghZGVjeWNsZXIpIGRlY3ljbGVyID0gZnVuY3Rpb24gKF86IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgICAgICBpZiAoc3RhY2tbMF0gPT09IHZhbHVlKSByZXR1cm4gJ1tDaXJjdWxhciB+XSc7XG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyIH4uJyArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oJy4nKSArICddJztcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRoaXM6IGFueSwga2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdGhpc1BvcyA9IHN0YWNrLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcbiAgICAgICAgICB+dGhpc1BvcyA/IGtleXMuc3BsaWNlKHRoaXNQb3MsIEluZmluaXR5LCBrZXkpIDoga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSkgdmFsdWUgPSBkZWN5Y2xlciEuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplciA9PSBudWxsID8gdmFsdWUgOiBzZXJpYWxpemVyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQge1xuICAgICAgaXNJbW11dGFibGUgPSBpc0ltbXV0YWJsZURlZmF1bHQsXG4gICAgICBpZ25vcmVkUGF0aHMsXG4gICAgICB3YXJuQWZ0ZXIgPSAzMlxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHRyYWNrID0gdHJhY2tGb3JNdXRhdGlvbnMuYmluZChudWxsLCBpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzKTtcbiAgICByZXR1cm4gKHtcbiAgICAgIGdldFN0YXRlXG4gICAgfSkgPT4ge1xuICAgICAgbGV0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgIGxldCB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIHJldHVybiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVVdGlscyA9IGdldFRpbWVNZWFzdXJlVXRpbHMod2FybkFmdGVyLCAnSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlJyk7XG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XG4gICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlc3VsdCA9IHRyYWNrZXIuZGV0ZWN0TXV0YXRpb25zKCk7XG4gICAgICAgICAgLy8gVHJhY2sgYmVmb3JlIHBvdGVudGlhbGx5IG5vdCBtZWV0aW5nIHRoZSBpbnZhcmlhbnRcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE5KSA6IGBBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBiZXR3ZWVuIGRpc3BhdGNoZXMsIGluIHRoZSBwYXRoICcke3Jlc3VsdC5wYXRoIHx8ICcnfScuICBUaGlzIG1heSBjYXVzZSBpbmNvcnJlY3QgYmVoYXZpb3IuIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoZWRBY3Rpb24gPSBuZXh0KGFjdGlvbik7XG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XG4gICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlc3VsdCA9IHRyYWNrZXIuZGV0ZWN0TXV0YXRpb25zKCk7XG4gICAgICAgICAgLy8gVHJhY2sgYmVmb3JlIHBvdGVudGlhbGx5IG5vdCBtZWV0aW5nIHRoZSBpbnZhcmlhbnRcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMigyMCkgOiBgQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgaW5zaWRlIGEgZGlzcGF0Y2gsIGluIHRoZSBwYXRoOiAke3Jlc3VsdC5wYXRoIHx8ICcnfS4gVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhlIGFjdGlvbiAke3N0cmluZ2lmeShhY3Rpb24pfS4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVkQWN0aW9uO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59IiwiaW1wb3J0IHR5cGUgeyBNaWRkbGV3YXJlIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgaXNBY3Rpb24sIGlzUGxhaW5PYmplY3QgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBnZXRUaW1lTWVhc3VyZVV0aWxzIH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgXCJwbGFpblwiLCBpLmUuIGEgdmFsdWUgdGhhdCBpcyBlaXRoZXJcbiAqIGRpcmVjdGx5IEpTT04tc2VyaWFsaXphYmxlIChib29sZWFuLCBudW1iZXIsIHN0cmluZywgYXJyYXksIHBsYWluIG9iamVjdClcbiAqIG9yIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW4odmFsOiBhbnkpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnYm9vbGVhbicgfHwgdHlwZSA9PT0gJ251bWJlcicgfHwgQXJyYXkuaXNBcnJheSh2YWwpIHx8IGlzUGxhaW5PYmplY3QodmFsKTtcbn1cbmludGVyZmFjZSBOb25TZXJpYWxpemFibGVWYWx1ZSB7XG4gIGtleVBhdGg6IHN0cmluZztcbiAgdmFsdWU6IHVua25vd247XG59XG5leHBvcnQgdHlwZSBJZ25vcmVQYXRocyA9IHJlYWRvbmx5IChzdHJpbmcgfCBSZWdFeHApW107XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHZhbHVlOiB1bmtub3duLCBwYXRoOiBzdHJpbmcgPSAnJywgaXNTZXJpYWxpemFibGU6ICh2YWx1ZTogdW5rbm93bikgPT4gYm9vbGVhbiA9IGlzUGxhaW4sIGdldEVudHJpZXM/OiAodmFsdWU6IHVua25vd24pID0+IFtzdHJpbmcsIGFueV1bXSwgaWdub3JlZFBhdGhzOiBJZ25vcmVQYXRocyA9IFtdLCBjYWNoZT86IFdlYWtTZXQ8b2JqZWN0Pik6IE5vblNlcmlhbGl6YWJsZVZhbHVlIHwgZmFsc2Uge1xuICBsZXQgZm91bmROZXN0ZWRTZXJpYWxpemFibGU6IE5vblNlcmlhbGl6YWJsZVZhbHVlIHwgZmFsc2U7XG4gIGlmICghaXNTZXJpYWxpemFibGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleVBhdGg6IHBhdGggfHwgJzxyb290PicsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjYWNoZT8uaGFzKHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBlbnRyaWVzID0gZ2V0RW50cmllcyAhPSBudWxsID8gZ2V0RW50cmllcyh2YWx1ZSkgOiBPYmplY3QuZW50cmllcyh2YWx1ZSk7XG4gIGNvbnN0IGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xuICBmb3IgKGNvbnN0IFtrZXksIG5lc3RlZFZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgJy4nICsga2V5IDoga2V5O1xuICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcbiAgICAgIGNvbnN0IGhhc01hdGNoZXMgPSBpZ25vcmVkUGF0aHMuc29tZShpZ25vcmVkID0+IHtcbiAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1NlcmlhbGl6YWJsZShuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleVBhdGg6IG5lc3RlZFBhdGgsXG4gICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5lc3RlZFZhbHVlLCBuZXN0ZWRQYXRoLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XG4gICAgICBpZiAoZm91bmROZXN0ZWRTZXJpYWxpemFibGUpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoY2FjaGUgJiYgaXNOZXN0ZWRGcm96ZW4odmFsdWUpKSBjYWNoZS5hZGQodmFsdWUpO1xuICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNOZXN0ZWRGcm96ZW4odmFsdWU6IG9iamVjdCkge1xuICBpZiAoIU9iamVjdC5pc0Zyb3plbih2YWx1ZSkpIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBuZXN0ZWRWYWx1ZSBvZiBPYmplY3QudmFsdWVzKHZhbHVlKSkge1xuICAgIGlmICh0eXBlb2YgbmVzdGVkVmFsdWUgIT09ICdvYmplY3QnIHx8IG5lc3RlZFZhbHVlID09PSBudWxsKSBjb250aW51ZTtcbiAgICBpZiAoIWlzTmVzdGVkRnJvemVuKG5lc3RlZFZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoKWAuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIGEgdmFsdWUgaXMgY29uc2lkZXJlZCBzZXJpYWxpemFibGUuIFRoaXNcbiAgICogZnVuY3Rpb24gaXMgYXBwbGllZCByZWN1cnNpdmVseSB0byBldmVyeSB2YWx1ZSBjb250YWluZWQgaW4gdGhlXG4gICAqIHN0YXRlLiBEZWZhdWx0cyB0byBgaXNQbGFpbigpYC5cbiAgICovXG4gIGlzU2VyaWFsaXphYmxlPzogKHZhbHVlOiBhbnkpID0+IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmV0cmlldmUgZW50cmllcyBmcm9tIGVhY2hcbiAgICogdmFsdWUuICBJZiB1bnNwZWNpZmllZCwgYE9iamVjdC5lbnRyaWVzYCB3aWxsIGJlIHVzZWQuIERlZmF1bHRzXG4gICAqIHRvIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgZ2V0RW50cmllcz86ICh2YWx1ZTogYW55KSA9PiBbc3RyaW5nLCBhbnldW107XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIGFjdGlvbiB0eXBlcyB0byBpZ25vcmUgd2hlbiBjaGVja2luZyBmb3Igc2VyaWFsaXphYmlsaXR5LlxuICAgKiBEZWZhdWx0cyB0byBbXVxuICAgKi9cbiAgaWdub3JlZEFjdGlvbnM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgZG90LXNlcGFyYXRlZCBwYXRoIHN0cmluZ3Mgb3IgcmVndWxhciBleHByZXNzaW9ucyB0byBpZ25vcmVcbiAgICogd2hlbiBjaGVja2luZyBmb3Igc2VyaWFsaXphYmlsaXR5LCBEZWZhdWx0cyB0b1xuICAgKiBbJ21ldGEuYXJnJywgJ21ldGEuYmFzZVF1ZXJ5TWV0YSddXG4gICAqL1xuICBpZ25vcmVkQWN0aW9uUGF0aHM/OiAoc3RyaW5nIHwgUmVnRXhwKVtdO1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBkb3Qtc2VwYXJhdGVkIHBhdGggc3RyaW5ncyBvciByZWd1bGFyIGV4cHJlc3Npb25zIHRvIGlnbm9yZVxuICAgKiB3aGVuIGNoZWNraW5nIGZvciBzZXJpYWxpemFiaWxpdHksIERlZmF1bHRzIHRvIFtdXG4gICAqL1xuICBpZ25vcmVkUGF0aHM/OiAoc3RyaW5nIHwgUmVnRXhwKVtdO1xuICAvKipcbiAgICogRXhlY3V0aW9uIHRpbWUgd2FybmluZyB0aHJlc2hvbGQuIElmIHRoZSBtaWRkbGV3YXJlIHRha2VzIGxvbmdlclxuICAgKiB0aGFuIGB3YXJuQWZ0ZXJgIG1zLCBhIHdhcm5pbmcgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gdGhlIGNvbnNvbGUuXG4gICAqIERlZmF1bHRzIHRvIDMybXMuXG4gICAqL1xuICB3YXJuQWZ0ZXI/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE9wdCBvdXQgb2YgY2hlY2tpbmcgc3RhdGUuIFdoZW4gc2V0IHRvIGB0cnVlYCwgb3RoZXIgc3RhdGUtcmVsYXRlZCBwYXJhbXMgd2lsbCBiZSBpZ25vcmVkLlxuICAgKi9cbiAgaWdub3JlU3RhdGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBPcHQgb3V0IG9mIGNoZWNraW5nIGFjdGlvbnMuIFdoZW4gc2V0IHRvIGB0cnVlYCwgb3RoZXIgYWN0aW9uLXJlbGF0ZWQgcGFyYW1zIHdpbGwgYmUgaWdub3JlZC5cbiAgICovXG4gIGlnbm9yZUFjdGlvbnM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBPcHQgb3V0IG9mIGNhY2hpbmcgdGhlIHJlc3VsdHMuIFRoZSBjYWNoZSB1c2VzIGEgV2Vha1NldCBhbmQgc3BlZWRzIHVwIHJlcGVhdGVkIGNoZWNraW5nIHByb2Nlc3Nlcy5cbiAgICogVGhlIGNhY2hlIGlzIGF1dG9tYXRpY2FsbHkgZGlzYWJsZWQgaWYgbm8gYnJvd3NlciBzdXBwb3J0IGZvciBXZWFrU2V0IGlzIHByZXNlbnQuXG4gICAqL1xuICBkaXNhYmxlQ2FjaGU/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtaWRkbGV3YXJlIHRoYXQsIGFmdGVyIGV2ZXJ5IHN0YXRlIGNoYW5nZSwgY2hlY2tzIGlmIHRoZSBuZXdcbiAqIHN0YXRlIGlzIHNlcmlhbGl6YWJsZS4gSWYgYSBub24tc2VyaWFsaXphYmxlIHZhbHVlIGlzIGZvdW5kIHdpdGhpbiB0aGVcbiAqIHN0YXRlLCBhbiBlcnJvciBpcyBwcmludGVkIHRvIHRoZSBjb25zb2xlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIE1pZGRsZXdhcmUgb3B0aW9ucy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUob3B0aW9uczogU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9ucyA9IHt9KTogTWlkZGxld2FyZSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcmV0dXJuICgpID0+IG5leHQgPT4gYWN0aW9uID0+IG5leHQoYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7XG4gICAgICBpc1NlcmlhbGl6YWJsZSA9IGlzUGxhaW4sXG4gICAgICBnZXRFbnRyaWVzLFxuICAgICAgaWdub3JlZEFjdGlvbnMgPSBbXSxcbiAgICAgIGlnbm9yZWRBY3Rpb25QYXRocyA9IFsnbWV0YS5hcmcnLCAnbWV0YS5iYXNlUXVlcnlNZXRhJ10sXG4gICAgICBpZ25vcmVkUGF0aHMgPSBbXSxcbiAgICAgIHdhcm5BZnRlciA9IDMyLFxuICAgICAgaWdub3JlU3RhdGUgPSBmYWxzZSxcbiAgICAgIGlnbm9yZUFjdGlvbnMgPSBmYWxzZSxcbiAgICAgIGRpc2FibGVDYWNoZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY2FjaGU6IFdlYWtTZXQ8b2JqZWN0PiB8IHVuZGVmaW5lZCA9ICFkaXNhYmxlQ2FjaGUgJiYgV2Vha1NldCA/IG5ldyBXZWFrU2V0KCkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0b3JlQVBJID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgICAgIGlmICghaXNBY3Rpb24oYWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xuICAgICAgY29uc3QgbWVhc3VyZVV0aWxzID0gZ2V0VGltZU1lYXN1cmVVdGlscyh3YXJuQWZ0ZXIsICdTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUnKTtcbiAgICAgIGlmICghaWdub3JlQWN0aW9ucyAmJiAhKGlnbm9yZWRBY3Rpb25zLmxlbmd0aCAmJiBpZ25vcmVkQWN0aW9ucy5pbmRleE9mKGFjdGlvbi50eXBlIGFzIGFueSkgIT09IC0xKSkge1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoYWN0aW9uLCAnJywgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocywgY2FjaGUpO1xuICAgICAgICAgIGlmIChmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gYW4gYWN0aW9uLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsICdcXG5UYWtlIGEgbG9vayBhdCB0aGUgbG9naWMgdGhhdCBkaXNwYXRjaGVkIHRoaXMgYWN0aW9uOiAnLCBhY3Rpb24sICdcXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9hY3Rpb25zI3doeS1zaG91bGQtdHlwZS1iZS1hLXN0cmluZy1vci1hdC1sZWFzdC1zZXJpYWxpemFibGUtd2h5LXNob3VsZC1teS1hY3Rpb24tdHlwZXMtYmUtY29uc3RhbnRzKScsICdcXG4oVG8gYWxsb3cgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZXMgc2VlOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL3VzYWdlL3VzYWdlLWd1aWRlI3dvcmtpbmctd2l0aC1ub24tc2VyaWFsaXphYmxlLWRhdGEpJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghaWdub3JlU3RhdGUpIHtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlQVBJLmdldFN0YXRlKCk7XG4gICAgICAgICAgY29uc3QgZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHN0YXRlLCAnJywgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocywgY2FjaGUpO1xuICAgICAgICAgIGlmIChmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0gPSBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWU7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBBIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgd2FzIGRldGVjdGVkIGluIHRoZSBzdGF0ZSwgaW4gdGhlIHBhdGg6IFxcYCR7a2V5UGF0aH1cXGAuIFZhbHVlOmAsIHZhbHVlLCBgXG5UYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGlzIGFjdGlvbiB0eXBlOiAke2FjdGlvbi50eXBlfS5cbihTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvZmFxL29yZ2FuaXppbmctc3RhdGUjY2FuLWktcHV0LWZ1bmN0aW9ucy1wcm9taXNlcy1vci1vdGhlci1ub24tc2VyaWFsaXphYmxlLWl0ZW1zLWluLW15LXN0b3JlLXN0YXRlKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lYXN1cmVVdGlscy53YXJuSWZFeGNlZWRlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG59IiwiaW1wb3J0IHR5cGUgeyBTdG9yZUVuaGFuY2VyIH0gZnJvbSAncmVkdXgnO1xuZXhwb3J0IGNvbnN0IFNIT1VMRF9BVVRPQkFUQ0ggPSAnUlRLX2F1dG9CYXRjaCc7XG5leHBvcnQgY29uc3QgcHJlcGFyZUF1dG9CYXRjaGVkID0gPFQsPigpID0+IChwYXlsb2FkOiBUKToge1xuICBwYXlsb2FkOiBUO1xuICBtZXRhOiB1bmtub3duO1xufSA9PiAoe1xuICBwYXlsb2FkLFxuICBtZXRhOiB7XG4gICAgW1NIT1VMRF9BVVRPQkFUQ0hdOiB0cnVlXG4gIH1cbn0pO1xuY29uc3QgY3JlYXRlUXVldWVXaXRoVGltZXIgPSAodGltZW91dDogbnVtYmVyKSA9PiB7XG4gIHJldHVybiAobm90aWZ5OiAoKSA9PiB2b2lkKSA9PiB7XG4gICAgc2V0VGltZW91dChub3RpZnksIHRpbWVvdXQpO1xuICB9O1xufTtcbmV4cG9ydCB0eXBlIEF1dG9CYXRjaE9wdGlvbnMgPSB7XG4gIHR5cGU6ICd0aWNrJztcbn0gfCB7XG4gIHR5cGU6ICd0aW1lcic7XG4gIHRpbWVvdXQ6IG51bWJlcjtcbn0gfCB7XG4gIHR5cGU6ICdyYWYnO1xufSB8IHtcbiAgdHlwZTogJ2NhbGxiYWNrJztcbiAgcXVldWVOb3RpZmljYXRpb246IChub3RpZnk6ICgpID0+IHZvaWQpID0+IHZvaWQ7XG59O1xuXG4vKipcbiAqIEEgUmVkdXggc3RvcmUgZW5oYW5jZXIgdGhhdCB3YXRjaGVzIGZvciBcImxvdy1wcmlvcml0eVwiIGFjdGlvbnMsIGFuZCBkZWxheXNcbiAqIG5vdGlmeWluZyBzdWJzY3JpYmVycyB1bnRpbCBlaXRoZXIgdGhlIHF1ZXVlZCBjYWxsYmFjayBleGVjdXRlcyBvciB0aGVcbiAqIG5leHQgXCJzdGFuZGFyZC1wcmlvcml0eVwiIGFjdGlvbiBpcyBkaXNwYXRjaGVkLlxuICpcbiAqIFRoaXMgYWxsb3dzIGRpc3BhdGNoaW5nIG11bHRpcGxlIFwibG93LXByaW9yaXR5XCIgYWN0aW9ucyBpbiBhIHJvdyB3aXRoIG9ubHlcbiAqIGEgc2luZ2xlIHN1YnNjcmliZXIgbm90aWZpY2F0aW9uIHRvIHRoZSBVSSBhZnRlciB0aGUgc2VxdWVuY2Ugb2YgYWN0aW9uc1xuICogaXMgZmluaXNoZWQsIHRodXMgaW1wcm92aW5nIFVJIHJlLXJlbmRlciBwZXJmb3JtYW5jZS5cbiAqXG4gKiBXYXRjaGVzIGZvciBhY3Rpb25zIHdpdGggdGhlIGBhY3Rpb24ubWV0YVtTSE9VTERfQVVUT0JBVENIXWAgYXR0cmlidXRlLlxuICogVGhpcyBjYW4gYmUgYWRkZWQgdG8gYGFjdGlvbi5tZXRhYCBtYW51YWxseSwgb3IgYnkgdXNpbmcgdGhlXG4gKiBgcHJlcGFyZUF1dG9CYXRjaGVkYCBoZWxwZXIuXG4gKlxuICogQnkgZGVmYXVsdCwgaXQgd2lsbCBxdWV1ZSBhIG5vdGlmaWNhdGlvbiBmb3IgdGhlIGVuZCBvZiB0aGUgZXZlbnQgbG9vcCB0aWNrLlxuICogSG93ZXZlciwgeW91IGNhbiBwYXNzIHNldmVyYWwgb3RoZXIgb3B0aW9ucyB0byBjb25maWd1cmUgdGhlIGJlaGF2aW9yOlxuICogLSBge3R5cGU6ICd0aWNrJ31gOiBxdWV1ZXMgdXNpbmcgYHF1ZXVlTWljcm90YXNrYFxuICogLSBge3R5cGU6ICd0aW1lcicsIHRpbWVvdXQ6IG51bWJlcn1gOiBxdWV1ZXMgdXNpbmcgYHNldFRpbWVvdXRgXG4gKiAtIGB7dHlwZTogJ3JhZid9YDogcXVldWVzIHVzaW5nIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIChkZWZhdWx0KVxuICogLSBge3R5cGU6ICdjYWxsYmFjaycsIHF1ZXVlTm90aWZpY2F0aW9uOiAobm90aWZ5OiAoKSA9PiB2b2lkKSA9PiB2b2lkfWA6IGxldHMgeW91IHByb3ZpZGUgeW91ciBvd24gY2FsbGJhY2tcbiAqXG4gKlxuICovXG5leHBvcnQgY29uc3QgYXV0b0JhdGNoRW5oYW5jZXIgPSAob3B0aW9uczogQXV0b0JhdGNoT3B0aW9ucyA9IHtcbiAgdHlwZTogJ3JhZidcbn0pOiBTdG9yZUVuaGFuY2VyID0+IG5leHQgPT4gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3Qgc3RvcmUgPSBuZXh0KC4uLmFyZ3MpO1xuICBsZXQgbm90aWZ5aW5nID0gdHJ1ZTtcbiAgbGV0IHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gZmFsc2U7XG4gIGxldCBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcbiAgY29uc3QgbGlzdGVuZXJzID0gbmV3IFNldDwoKSA9PiB2b2lkPigpO1xuICBjb25zdCBxdWV1ZUNhbGxiYWNrID0gb3B0aW9ucy50eXBlID09PSAndGljaycgPyBxdWV1ZU1pY3JvdGFzayA6IG9wdGlvbnMudHlwZSA9PT0gJ3JhZicgP1xuICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd29uJ3QgZXhpc3QgaW4gU1NSIGVudmlyb25tZW50cy4gRmFsbCBiYWNrIHRvIGEgdmFndWUgYXBwcm94aW1hdGlvbiBqdXN0IHRvIGtlZXAgZnJvbSBlcnJvcmluZy5cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBjcmVhdGVRdWV1ZVdpdGhUaW1lcigxMCkgOiBvcHRpb25zLnR5cGUgPT09ICdjYWxsYmFjaycgPyBvcHRpb25zLnF1ZXVlTm90aWZpY2F0aW9uIDogY3JlYXRlUXVldWVXaXRoVGltZXIob3B0aW9ucy50aW1lb3V0KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXJzID0gKCkgPT4ge1xuICAgIC8vIFdlJ3JlIHJ1bm5pbmcgYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgbG9vcCB0aWNrLlxuICAgIC8vIFJ1biB0aGUgcmVhbCBsaXN0ZW5lciBjYWxsYmFja3MgdG8gYWN0dWFsbHkgdXBkYXRlIHRoZSBVSS5cbiAgICBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcbiAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcbiAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gZmFsc2U7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaChsID0+IGwoKSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RvcmUsIHtcbiAgICAvLyBPdmVycmlkZSB0aGUgYmFzZSBgc3RvcmUuc3Vic2NyaWJlYCBtZXRob2QgdG8ga2VlcCBvcmlnaW5hbCBsaXN0ZW5lcnNcbiAgICAvLyBmcm9tIHJ1bm5pbmcgaWYgd2UncmUgZGVsYXlpbmcgbm90aWZpY2F0aW9uc1xuICAgIHN1YnNjcmliZShsaXN0ZW5lcjogKCkgPT4gdm9pZCkge1xuICAgICAgLy8gRWFjaCB3cmFwcGVkIGxpc3RlbmVyIHdpbGwgb25seSBjYWxsIHRoZSByZWFsIGxpc3RlbmVyIGlmXG4gICAgICAvLyB0aGUgYG5vdGlmeWluZ2AgZmxhZyBpcyBjdXJyZW50bHkgYWN0aXZlIHdoZW4gaXQncyBjYWxsZWQuXG4gICAgICAvLyBUaGlzIGxldHMgdGhlIGJhc2Ugc3RvcmUgd29yayBhcyBub3JtYWwsIHdoaWxlIHRoZSBhY3R1YWwgVUlcbiAgICAgIC8vIHVwZGF0ZSBiZWNvbWVzIGNvbnRyb2xsZWQgYnkgdGhpcyBlbmhhbmNlci5cbiAgICAgIGNvbnN0IHdyYXBwZWRMaXN0ZW5lcjogdHlwZW9mIGxpc3RlbmVyID0gKCkgPT4gbm90aWZ5aW5nICYmIGxpc3RlbmVyKCk7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZSh3cmFwcGVkTGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBPdmVycmlkZSB0aGUgYmFzZSBgc3RvcmUuZGlzcGF0Y2hgIG1ldGhvZCBzbyB0aGF0IHdlIGNhbiBjaGVjayBhY3Rpb25zXG4gICAgLy8gZm9yIHRoZSBgc2hvdWxkQXV0b0JhdGNoYCBmbGFnIGFuZCBkZXRlcm1pbmUgaWYgYmF0Y2hpbmcgaXMgYWN0aXZlXG4gICAgZGlzcGF0Y2goYWN0aW9uOiBhbnkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIElmIHRoZSBhY3Rpb24gZG9lcyBfbm90XyBoYXZlIHRoZSBgc2hvdWxkQXV0b0JhdGNoYCBmbGFnLFxuICAgICAgICAvLyB3ZSByZXN1bWUvY29udGludWUgbm9ybWFsIG5vdGlmeS1hZnRlci1lYWNoLWRpc3BhdGNoIGJlaGF2aW9yXG4gICAgICAgIG5vdGlmeWluZyA9ICFhY3Rpb24/Lm1ldGE/LltTSE9VTERfQVVUT0JBVENIXTtcbiAgICAgICAgLy8gSWYgYSBgbm90aWZ5TGlzdGVuZXJzYCBtaWNyb3Rhc2sgd2FzIHF1ZXVlZCwgeW91IGNhbid0IGNhbmNlbCBpdC5cbiAgICAgICAgLy8gSW5zdGVhZCwgd2Ugc2V0IGEgZmxhZyBzbyB0aGF0IGl0J3MgYSBuby1vcCB3aGVuIGl0IGRvZXMgcnVuXG4gICAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gIW5vdGlmeWluZztcbiAgICAgICAgaWYgKHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrKSB7XG4gICAgICAgICAgLy8gV2UndmUgc2VlbiBhdCBsZWFzdCAxIGFjdGlvbiB3aXRoIGBTSE9VTERfQVVUT0JBVENIYC4gVHJ5IHRvIHF1ZXVlXG4gICAgICAgICAgLy8gYSBtaWNyb3Rhc2sgdG8gbm90aWZ5IGxpc3RlbmVycyBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHRpY2suXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIG9ubHkgZW5xdWV1ZSB0aGlzIF9vbmNlXyBwZXIgdGljay5cbiAgICAgICAgICBpZiAoIW5vdGlmaWNhdGlvblF1ZXVlZCkge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uUXVldWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHF1ZXVlQ2FsbGJhY2sobm90aWZ5TGlzdGVuZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gR28gYWhlYWQgYW5kIHByb2Nlc3MgdGhlIGFjdGlvbiBhcyB1c3VhbCwgaW5jbHVkaW5nIHJlZHVjZXJzLlxuICAgICAgICAvLyBJZiBub3JtYWwgbm90aWZpY2F0aW9uIGJlaGF2aW9yIGlzIGVuYWJsZWQsIHRoZSBzdG9yZSB3aWxsIG5vdGlmeVxuICAgICAgICAvLyBhbGwgb2YgaXRzIG93biBsaXN0ZW5lcnMsIGFuZCB0aGUgd3JhcHBlciBjYWxsYmFja3MgYWJvdmUgd2lsbFxuICAgICAgICAvLyBzZWUgYG5vdGlmeWluZ2AgaXMgdHJ1ZSBhbmQgcGFzcyBvbiB0byB0aGUgcmVhbCBsaXN0ZW5lciBjYWxsYmFja3MuXG4gICAgICAgIC8vIElmIHdlJ3JlIFwiYmF0Y2hpbmdcIiBiZWhhdmlvciwgdGhlbiB0aGUgd3JhcHBlZCBjYWxsYmFja3Mgd2lsbFxuICAgICAgICAvLyBiYWlsIG91dCwgY2F1c2luZyB0aGUgYmFzZSBzdG9yZSBub3RpZmljYXRpb24gYmVoYXZpb3IgdG8gYmUgbm8tb3BzLlxuICAgICAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2goYWN0aW9uKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIEFzc3VtZSB3ZSdyZSBiYWNrIHRvIG5vcm1hbCBiZWhhdmlvciBhZnRlciBlYWNoIGFjdGlvblxuICAgICAgICBub3RpZnlpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59OyIsImltcG9ydCB0eXBlIHsgU3RvcmVFbmhhbmNlciB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB0eXBlIHsgQXV0b0JhdGNoT3B0aW9ucyB9IGZyb20gJy4vYXV0b0JhdGNoRW5oYW5jZXInO1xuaW1wb3J0IHsgYXV0b0JhdGNoRW5oYW5jZXIgfSBmcm9tICcuL2F1dG9CYXRjaEVuaGFuY2VyJztcbmltcG9ydCB7IFR1cGxlIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IE1pZGRsZXdhcmVzIH0gZnJvbSAnLi9jb25maWd1cmVTdG9yZSc7XG5pbXBvcnQgdHlwZSB7IEV4dHJhY3REaXNwYXRjaEV4dGVuc2lvbnMgfSBmcm9tICcuL3RzSGVscGVycyc7XG50eXBlIEdldERlZmF1bHRFbmhhbmNlcnNPcHRpb25zID0ge1xuICBhdXRvQmF0Y2g/OiBib29sZWFuIHwgQXV0b0JhdGNoT3B0aW9ucztcbn07XG5leHBvcnQgdHlwZSBHZXREZWZhdWx0RW5oYW5jZXJzPE0gZXh0ZW5kcyBNaWRkbGV3YXJlczxhbnk+PiA9IChvcHRpb25zPzogR2V0RGVmYXVsdEVuaGFuY2Vyc09wdGlvbnMpID0+IFR1cGxlPFtTdG9yZUVuaGFuY2VyPHtcbiAgZGlzcGF0Y2g6IEV4dHJhY3REaXNwYXRjaEV4dGVuc2lvbnM8TT47XG59Pl0+O1xuZXhwb3J0IGNvbnN0IGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyA9IDxNIGV4dGVuZHMgTWlkZGxld2FyZXM8YW55Piw+KG1pZGRsZXdhcmVFbmhhbmNlcjogU3RvcmVFbmhhbmNlcjx7XG4gIGRpc3BhdGNoOiBFeHRyYWN0RGlzcGF0Y2hFeHRlbnNpb25zPE0+O1xufT4pOiBHZXREZWZhdWx0RW5oYW5jZXJzPE0+ID0+IGZ1bmN0aW9uIGdldERlZmF1bHRFbmhhbmNlcnMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYXV0b0JhdGNoID0gdHJ1ZVxuICB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgbGV0IGVuaGFuY2VyQXJyYXkgPSBuZXcgVHVwbGU8U3RvcmVFbmhhbmNlcltdPihtaWRkbGV3YXJlRW5oYW5jZXIpO1xuICBpZiAoYXV0b0JhdGNoKSB7XG4gICAgZW5oYW5jZXJBcnJheS5wdXNoKGF1dG9CYXRjaEVuaGFuY2VyKHR5cGVvZiBhdXRvQmF0Y2ggPT09ICdvYmplY3QnID8gYXV0b0JhdGNoIDogdW5kZWZpbmVkKSk7XG4gIH1cbiAgcmV0dXJuIGVuaGFuY2VyQXJyYXkgYXMgYW55O1xufTsiLCJpbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB0eXBlIHsgRHJhZnQgfSBmcm9tICdpbW1lcic7XG5pbXBvcnQgeyBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZSwgaXNEcmFmdCwgaXNEcmFmdGFibGUgfSBmcm9tICdpbW1lcic7XG5pbXBvcnQgdHlwZSB7IEFjdGlvbiwgUmVkdWNlciwgVW5rbm93bkFjdGlvbiB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB0eXBlIHsgQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXIgfSBmcm9tICcuL21hcEJ1aWxkZXJzJztcbmltcG9ydCB7IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrIH0gZnJvbSAnLi9tYXBCdWlsZGVycyc7XG5pbXBvcnQgdHlwZSB7IE5vSW5mZXIsIFR5cGVHdWFyZCB9IGZyb20gJy4vdHNIZWxwZXJzJztcbmltcG9ydCB7IGZyZWV6ZURyYWZ0YWJsZSB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIERlZmluZXMgYSBtYXBwaW5nIGZyb20gYWN0aW9uIHR5cGVzIHRvIGNvcnJlc3BvbmRpbmcgYWN0aW9uIG9iamVjdCBzaGFwZXMuXG4gKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBzaG91bGQgbm90IGJlIHVzZWQgbWFudWFsbHkgLSBpdCBpcyBvbmx5IHVzZWQgZm9yIGludGVybmFsXG4gKiAgICAgICAgICAgICBpbmZlcmVuY2UgcHVycG9zZXMgYW5kIHNob3VsZCBub3QgaGF2ZSBhbnkgZnVydGhlciB2YWx1ZS5cbiAqICAgICAgICAgICAgIEl0IG1pZ2h0IGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgQWN0aW9uczxUIGV4dGVuZHMga2V5b2YgYW55ID0gc3RyaW5nPiA9IFJlY29yZDxULCBBY3Rpb24+O1xuZXhwb3J0IHR5cGUgQWN0aW9uTWF0Y2hlckRlc2NyaXB0aW9uPFMsIEEgZXh0ZW5kcyBBY3Rpb24+ID0ge1xuICBtYXRjaGVyOiBUeXBlR3VhcmQ8QT47XG4gIHJlZHVjZXI6IENhc2VSZWR1Y2VyPFMsIE5vSW5mZXI8QT4+O1xufTtcbmV4cG9ydCB0eXBlIFJlYWRvbmx5QWN0aW9uTWF0Y2hlckRlc2NyaXB0aW9uQ29sbGVjdGlvbjxTPiA9IFJlYWRvbmx5QXJyYXk8QWN0aW9uTWF0Y2hlckRlc2NyaXB0aW9uPFMsIGFueT4+O1xuZXhwb3J0IHR5cGUgQWN0aW9uTWF0Y2hlckRlc2NyaXB0aW9uQ29sbGVjdGlvbjxTPiA9IEFycmF5PEFjdGlvbk1hdGNoZXJEZXNjcmlwdGlvbjxTLCBhbnk+PjtcblxuLyoqXG4gKiBBICpjYXNlIHJlZHVjZXIqIGlzIGEgcmVkdWNlciBmdW5jdGlvbiBmb3IgYSBzcGVjaWZpYyBhY3Rpb24gdHlwZS4gQ2FzZVxuICogcmVkdWNlcnMgY2FuIGJlIGNvbXBvc2VkIHRvIGZ1bGwgcmVkdWNlcnMgdXNpbmcgYGNyZWF0ZVJlZHVjZXIoKWAuXG4gKlxuICogVW5saWtlIGEgbm9ybWFsIFJlZHV4IHJlZHVjZXIsIGEgY2FzZSByZWR1Y2VyIGlzIG5ldmVyIGNhbGxlZCB3aXRoIGFuXG4gKiBgdW5kZWZpbmVkYCBzdGF0ZSB0byBkZXRlcm1pbmUgdGhlIGluaXRpYWwgc3RhdGUuIEluc3RlYWQsIHRoZSBpbml0aWFsXG4gKiBzdGF0ZSBpcyBleHBsaWNpdGx5IHNwZWNpZmllZCBhcyBhbiBhcmd1bWVudCB0byBgY3JlYXRlUmVkdWNlcigpYC5cbiAqXG4gKiBJbiBhZGRpdGlvbiwgYSBjYXNlIHJlZHVjZXIgY2FuIGNob29zZSB0byBtdXRhdGUgdGhlIHBhc3NlZC1pbiBgc3RhdGVgXG4gKiB2YWx1ZSBkaXJlY3RseSBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG5ldyBzdGF0ZS4gVGhpcyBkb2VzIG5vdCBhY3R1YWxseVxuICogY2F1c2UgdGhlIHN0b3JlIHN0YXRlIHRvIGJlIG11dGF0ZWQgZGlyZWN0bHk7IGluc3RlYWQsIHRoYW5rcyB0b1xuICogW2ltbWVyXShodHRwczovL2dpdGh1Yi5jb20vbXdlc3RzdHJhdGUvaW1tZXIpLCB0aGUgbXV0YXRpb25zIGFyZVxuICogdHJhbnNsYXRlZCB0byBjb3B5IG9wZXJhdGlvbnMgdGhhdCByZXN1bHQgaW4gYSBuZXcgc3RhdGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBDYXNlUmVkdWNlcjxTID0gYW55LCBBIGV4dGVuZHMgQWN0aW9uID0gVW5rbm93bkFjdGlvbj4gPSAoc3RhdGU6IERyYWZ0PFM+LCBhY3Rpb246IEEpID0+IE5vSW5mZXI8Uz4gfCB2b2lkIHwgRHJhZnQ8Tm9JbmZlcjxTPj47XG5cbi8qKlxuICogQSBtYXBwaW5nIGZyb20gYWN0aW9uIHR5cGVzIHRvIGNhc2UgcmVkdWNlcnMgZm9yIGBjcmVhdGVSZWR1Y2VyKClgLlxuICpcbiAqIEBkZXByZWNhdGVkIFRoaXMgc2hvdWxkIG5vdCBiZSB1c2VkIG1hbnVhbGx5IC0gaXQgaXMgb25seSB1c2VkXG4gKiAgICAgICAgICAgICBmb3IgaW50ZXJuYWwgaW5mZXJlbmNlIHB1cnBvc2VzIGFuZCB1c2luZyBpdCBtYW51YWxseVxuICogICAgICAgICAgICAgd291bGQgbGVhZCB0byB0eXBlIGVyYXN1cmUuXG4gKiAgICAgICAgICAgICBJdCBtaWdodCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIENhc2VSZWR1Y2VyczxTLCBBUyBleHRlbmRzIEFjdGlvbnM+ID0geyBbVCBpbiBrZXlvZiBBU106IEFTW1RdIGV4dGVuZHMgQWN0aW9uID8gQ2FzZVJlZHVjZXI8UywgQVNbVF0+IDogdm9pZCB9O1xuZXhwb3J0IHR5cGUgTm90RnVuY3Rpb248VD4gPSBUIGV4dGVuZHMgRnVuY3Rpb24gPyBuZXZlciA6IFQ7XG5mdW5jdGlvbiBpc1N0YXRlRnVuY3Rpb248Uz4oeDogdW5rbm93bik6IHggaXMgKCkgPT4gUyB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydCB0eXBlIFJlZHVjZXJXaXRoSW5pdGlhbFN0YXRlPFMgZXh0ZW5kcyBOb3RGdW5jdGlvbjxhbnk+PiA9IFJlZHVjZXI8Uz4gJiB7XG4gIGdldEluaXRpYWxTdGF0ZTogKCkgPT4gUztcbn07XG5cbi8qKlxuICogQSB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgYWxsb3dzIGRlZmluaW5nIGEgcmVkdWNlciBhcyBhIG1hcHBpbmcgZnJvbSBhY3Rpb25cbiAqIHR5cGUgdG8gKmNhc2UgcmVkdWNlciogZnVuY3Rpb25zIHRoYXQgaGFuZGxlIHRoZXNlIGFjdGlvbiB0eXBlcy4gVGhlXG4gKiByZWR1Y2VyJ3MgaW5pdGlhbCBzdGF0ZSBpcyBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgYm9keSBvZiBldmVyeSBjYXNlIHJlZHVjZXIgaXMgaW1wbGljaXRseSB3cmFwcGVkIHdpdGggYSBjYWxsIHRvXG4gKiBgcHJvZHVjZSgpYCBmcm9tIHRoZSBbaW1tZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9td2VzdHN0cmF0ZS9pbW1lcikgbGlicmFyeS5cbiAqIFRoaXMgbWVhbnMgdGhhdCByYXRoZXIgdGhhbiByZXR1cm5pbmcgYSBuZXcgc3RhdGUgb2JqZWN0LCB5b3UgY2FuIGFsc29cbiAqIG11dGF0ZSB0aGUgcGFzc2VkLWluIHN0YXRlIG9iamVjdCBkaXJlY3RseTsgdGhlc2UgbXV0YXRpb25zIHdpbGwgdGhlbiBiZVxuICogYXV0b21hdGljYWxseSBhbmQgZWZmaWNpZW50bHkgdHJhbnNsYXRlZCBpbnRvIGNvcGllcywgZ2l2aW5nIHlvdSBib3RoXG4gKiBjb252ZW5pZW5jZSBhbmQgaW1tdXRhYmlsaXR5LlxuICpcbiAqIEBvdmVybG9hZFN1bW1hcnlcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgYSBgYnVpbGRlcmAgb2JqZWN0IGFzIGl0cyBhcmd1bWVudC5cbiAqIFRoYXQgYnVpbGRlciBwcm92aWRlcyBgYWRkQ2FzZWAsIGBhZGRNYXRjaGVyYCBhbmQgYGFkZERlZmF1bHRDYXNlYCBmdW5jdGlvbnMgdGhhdCBtYXkgYmVcbiAqIGNhbGxlZCB0byBkZWZpbmUgd2hhdCBhY3Rpb25zIHRoaXMgcmVkdWNlciB3aWxsIGhhbmRsZS5cbiAqXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIC0gYFN0YXRlIHwgKCgpID0+IFN0YXRlKWA6IFRoZSBpbml0aWFsIHN0YXRlIHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgcmVkdWNlciBpcyBjYWxsZWQgdGhlIGZpcnN0IHRpbWUuIFRoaXMgbWF5IGFsc28gYmUgYSBcImxhenkgaW5pdGlhbGl6ZXJcIiBmdW5jdGlvbiwgd2hpY2ggc2hvdWxkIHJldHVybiBhbiBpbml0aWFsIHN0YXRlIHZhbHVlIHdoZW4gY2FsbGVkLiBUaGlzIHdpbGwgYmUgdXNlZCB3aGVuZXZlciB0aGUgcmVkdWNlciBpcyBjYWxsZWQgd2l0aCBgdW5kZWZpbmVkYCBhcyBpdHMgc3RhdGUgdmFsdWUsIGFuZCBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBjYXNlcyBsaWtlIHJlYWRpbmcgaW5pdGlhbCBzdGF0ZSBmcm9tIGBsb2NhbFN0b3JhZ2VgLlxuICogQHBhcmFtIGJ1aWxkZXJDYWxsYmFjayAtIGAoYnVpbGRlcjogQnVpbGRlcikgPT4gdm9pZGAgQSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIGEgKmJ1aWxkZXIqIG9iamVjdCB0byBkZWZpbmVcbiAqICAgY2FzZSByZWR1Y2VycyB2aWEgY2FsbHMgdG8gYGJ1aWxkZXIuYWRkQ2FzZShhY3Rpb25DcmVhdG9yT3JUeXBlLCByZWR1Y2VyKWAuXG4gKiBAZXhhbXBsZVxuYGBgdHNcbmltcG9ydCB7XG4gIGNyZWF0ZUFjdGlvbixcbiAgY3JlYXRlUmVkdWNlcixcbiAgVW5rbm93bkFjdGlvbixcbiAgUGF5bG9hZEFjdGlvbixcbn0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcblxuY29uc3QgaW5jcmVtZW50ID0gY3JlYXRlQWN0aW9uPG51bWJlcj4oXCJpbmNyZW1lbnRcIik7XG5jb25zdCBkZWNyZW1lbnQgPSBjcmVhdGVBY3Rpb248bnVtYmVyPihcImRlY3JlbWVudFwiKTtcblxuZnVuY3Rpb24gaXNBY3Rpb25XaXRoTnVtYmVyUGF5bG9hZChcbiAgYWN0aW9uOiBVbmtub3duQWN0aW9uXG4pOiBhY3Rpb24gaXMgUGF5bG9hZEFjdGlvbjxudW1iZXI+IHtcbiAgcmV0dXJuIHR5cGVvZiBhY3Rpb24ucGF5bG9hZCA9PT0gXCJudW1iZXJcIjtcbn1cblxuY29uc3QgcmVkdWNlciA9IGNyZWF0ZVJlZHVjZXIoXG4gIHtcbiAgICBjb3VudGVyOiAwLFxuICAgIHN1bU9mTnVtYmVyUGF5bG9hZHM6IDAsXG4gICAgdW5oYW5kbGVkQWN0aW9uczogMCxcbiAgfSxcbiAgKGJ1aWxkZXIpID0+IHtcbiAgICBidWlsZGVyXG4gICAgICAuYWRkQ2FzZShpbmNyZW1lbnQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgIC8vIGFjdGlvbiBpcyBpbmZlcnJlZCBjb3JyZWN0bHkgaGVyZVxuICAgICAgICBzdGF0ZS5jb3VudGVyICs9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgfSlcbiAgICAgIC8vIFlvdSBjYW4gY2hhaW4gY2FsbHMsIG9yIGhhdmUgc2VwYXJhdGUgYGJ1aWxkZXIuYWRkQ2FzZSgpYCBsaW5lcyBlYWNoIHRpbWVcbiAgICAgIC5hZGRDYXNlKGRlY3JlbWVudCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgc3RhdGUuY291bnRlciAtPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgIH0pXG4gICAgICAvLyBZb3UgY2FuIGFwcGx5IGEgXCJtYXRjaGVyIGZ1bmN0aW9uXCIgdG8gaW5jb21pbmcgYWN0aW9uc1xuICAgICAgLmFkZE1hdGNoZXIoaXNBY3Rpb25XaXRoTnVtYmVyUGF5bG9hZCwgKHN0YXRlLCBhY3Rpb24pID0+IHt9KVxuICAgICAgLy8gYW5kIHByb3ZpZGUgYSBkZWZhdWx0IGNhc2UgaWYgbm8gb3RoZXIgaGFuZGxlcnMgbWF0Y2hlZFxuICAgICAgLmFkZERlZmF1bHRDYXNlKChzdGF0ZSwgYWN0aW9uKSA9PiB7fSk7XG4gIH1cbik7XG5gYGBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZXI8UyBleHRlbmRzIE5vdEZ1bmN0aW9uPGFueT4+KGluaXRpYWxTdGF0ZTogUyB8ICgoKSA9PiBTKSwgbWFwT3JCdWlsZGVyQ2FsbGJhY2s6IChidWlsZGVyOiBBY3Rpb25SZWR1Y2VyTWFwQnVpbGRlcjxTPikgPT4gdm9pZCk6IFJlZHVjZXJXaXRoSW5pdGlhbFN0YXRlPFM+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIG1hcE9yQnVpbGRlckNhbGxiYWNrID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDgpIDogXCJUaGUgb2JqZWN0IG5vdGF0aW9uIGZvciBgY3JlYXRlUmVkdWNlcmAgaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHVzZSB0aGUgJ2J1aWxkZXIgY2FsbGJhY2snIG5vdGF0aW9uIGluc3RlYWQ6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2NyZWF0ZVJlZHVjZXJcIik7XG4gICAgfVxuICB9XG4gIGxldCBbYWN0aW9uc01hcCwgZmluYWxBY3Rpb25NYXRjaGVycywgZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXJdID0gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sobWFwT3JCdWlsZGVyQ2FsbGJhY2spO1xuXG4gIC8vIEVuc3VyZSB0aGUgaW5pdGlhbCBzdGF0ZSBnZXRzIGZyb3plbiBlaXRoZXIgd2F5IChpZiBkcmFmdGFibGUpXG4gIGxldCBnZXRJbml0aWFsU3RhdGU6ICgpID0+IFM7XG4gIGlmIChpc1N0YXRlRnVuY3Rpb24oaW5pdGlhbFN0YXRlKSkge1xuICAgIGdldEluaXRpYWxTdGF0ZSA9ICgpID0+IGZyZWV6ZURyYWZ0YWJsZShpbml0aWFsU3RhdGUoKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZnJvemVuSW5pdGlhbFN0YXRlID0gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSk7XG4gICAgZ2V0SW5pdGlhbFN0YXRlID0gKCkgPT4gZnJvemVuSW5pdGlhbFN0YXRlO1xuICB9XG4gIGZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKSwgYWN0aW9uOiBhbnkpOiBTIHtcbiAgICBsZXQgY2FzZVJlZHVjZXJzID0gW2FjdGlvbnNNYXBbYWN0aW9uLnR5cGVdLCAuLi5maW5hbEFjdGlvbk1hdGNoZXJzLmZpbHRlcigoe1xuICAgICAgbWF0Y2hlclxuICAgIH0pID0+IG1hdGNoZXIoYWN0aW9uKSkubWFwKCh7XG4gICAgICByZWR1Y2VyXG4gICAgfSkgPT4gcmVkdWNlcildO1xuICAgIGlmIChjYXNlUmVkdWNlcnMuZmlsdGVyKGNyID0+ICEhY3IpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FzZVJlZHVjZXJzID0gW2ZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXTtcbiAgICB9XG4gICAgcmV0dXJuIGNhc2VSZWR1Y2Vycy5yZWR1Y2UoKHByZXZpb3VzU3RhdGUsIGNhc2VSZWR1Y2VyKTogUyA9PiB7XG4gICAgICBpZiAoY2FzZVJlZHVjZXIpIHtcbiAgICAgICAgaWYgKGlzRHJhZnQocHJldmlvdXNTdGF0ZSkpIHtcbiAgICAgICAgICAvLyBJZiBpdCdzIGFscmVhZHkgYSBkcmFmdCwgd2UgbXVzdCBhbHJlYWR5IGJlIGluc2lkZSBhIGBjcmVhdGVOZXh0U3RhdGVgIGNhbGwsXG4gICAgICAgICAgLy8gbGlrZWx5IGJlY2F1c2UgdGhpcyBpcyBiZWluZyB3cmFwcGVkIGluIGBjcmVhdGVSZWR1Y2VyYCwgYGNyZWF0ZVNsaWNlYCwgb3IgbmVzdGVkXG4gICAgICAgICAgLy8gaW5zaWRlIGFuIGV4aXN0aW5nIGRyYWZ0LiBJdCdzIHNhZmUgdG8ganVzdCBwYXNzIHRoZSBkcmFmdCB0byB0aGUgbXV0YXRvci5cbiAgICAgICAgICBjb25zdCBkcmFmdCA9IHByZXZpb3VzU3RhdGUgYXMgRHJhZnQ8Uz47IC8vIFdlIGNhbiBhc3N1bWUgdGhpcyBpcyBhbHJlYWR5IGEgZHJhZnRcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0IGFzIFM7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRHJhZnRhYmxlKHByZXZpb3VzU3RhdGUpKSB7XG4gICAgICAgICAgLy8gSWYgc3RhdGUgaXMgbm90IGRyYWZ0YWJsZSAoZXg6IGEgcHJpbWl0aXZlLCBzdWNoIGFzIDApLCB3ZSB3YW50IHRvIGRpcmVjdGx5XG4gICAgICAgICAgLy8gcmV0dXJuIHRoZSBjYXNlUmVkdWNlciBmdW5jIGFuZCBub3Qgd3JhcCBpdCB3aXRoIHByb2R1Y2UuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FzZVJlZHVjZXIocHJldmlvdXNTdGF0ZSBhcyBhbnksIGFjdGlvbik7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IEVycm9yKCdBIGNhc2UgcmVkdWNlciBvbiBhIG5vbi1kcmFmdGFibGUgdmFsdWUgbXVzdCBub3QgcmV0dXJuIHVuZGVmaW5lZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0IGFzIFM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSBjcmVhdGVOZXh0U3RhdGUoKSBwcm9kdWNlcyBhbiBJbW11dGFibGU8RHJhZnQ8Uz4+IHJhdGhlclxuICAgICAgICAgIC8vIHRoYW4gYW4gSW1tdXRhYmxlPFM+LCBhbmQgVHlwZVNjcmlwdCBjYW5ub3QgZmluZCBvdXQgaG93IHRvIHJlY29uY2lsZVxuICAgICAgICAgIC8vIHRoZXNlIHR3byB0eXBlcy5cbiAgICAgICAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlKHByZXZpb3VzU3RhdGUsIChkcmFmdDogRHJhZnQ8Uz4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgfSwgc3RhdGUpO1xuICB9XG4gIHJlZHVjZXIuZ2V0SW5pdGlhbFN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlO1xuICByZXR1cm4gcmVkdWNlciBhcyBSZWR1Y2VyV2l0aEluaXRpYWxTdGF0ZTxTPjtcbn0iLCJpbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLCBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiwgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMsIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U0LCBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNSwgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTYgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHR5cGUgeyBBY3Rpb24gfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgdHlwZSB7IENhc2VSZWR1Y2VyLCBDYXNlUmVkdWNlcnMsIEFjdGlvbk1hdGNoZXJEZXNjcmlwdGlvbkNvbGxlY3Rpb24gfSBmcm9tICcuL2NyZWF0ZVJlZHVjZXInO1xuaW1wb3J0IHR5cGUgeyBUeXBlR3VhcmQgfSBmcm9tICcuL3RzSGVscGVycyc7XG5leHBvcnQgdHlwZSBUeXBlZEFjdGlvbkNyZWF0b3I8VHlwZSBleHRlbmRzIHN0cmluZz4gPSB7XG4gICguLi5hcmdzOiBhbnlbXSk6IEFjdGlvbjxUeXBlPjtcbiAgdHlwZTogVHlwZTtcbn07XG5cbi8qKlxuICogQSBidWlsZGVyIGZvciBhbiBhY3Rpb24gPC0+IHJlZHVjZXIgbWFwLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25SZWR1Y2VyTWFwQnVpbGRlcjxTdGF0ZT4ge1xuICAvKipcbiAgICogQWRkcyBhIGNhc2UgcmVkdWNlciB0byBoYW5kbGUgYSBzaW5nbGUgZXhhY3QgYWN0aW9uIHR5cGUuXG4gICAqIEByZW1hcmtzXG4gICAqIEFsbCBjYWxscyB0byBgYnVpbGRlci5hZGRDYXNlYCBtdXN0IGNvbWUgYmVmb3JlIGFueSBjYWxscyB0byBgYnVpbGRlci5hZGRNYXRjaGVyYCBvciBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAuXG4gICAqIEBwYXJhbSBhY3Rpb25DcmVhdG9yIC0gRWl0aGVyIGEgcGxhaW4gYWN0aW9uIHR5cGUgc3RyaW5nLCBvciBhbiBhY3Rpb24gY3JlYXRvciBnZW5lcmF0ZWQgYnkgW2BjcmVhdGVBY3Rpb25gXSguL2NyZWF0ZUFjdGlvbikgdGhhdCBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGFjdGlvbiB0eXBlLlxuICAgKiBAcGFyYW0gcmVkdWNlciAtIFRoZSBhY3R1YWwgY2FzZSByZWR1Y2VyIGZ1bmN0aW9uLlxuICAgKi9cbiAgYWRkQ2FzZTxBY3Rpb25DcmVhdG9yIGV4dGVuZHMgVHlwZWRBY3Rpb25DcmVhdG9yPHN0cmluZz4+KGFjdGlvbkNyZWF0b3I6IEFjdGlvbkNyZWF0b3IsIHJlZHVjZXI6IENhc2VSZWR1Y2VyPFN0YXRlLCBSZXR1cm5UeXBlPEFjdGlvbkNyZWF0b3I+Pik6IEFjdGlvblJlZHVjZXJNYXBCdWlsZGVyPFN0YXRlPjtcbiAgLyoqXG4gICAqIEFkZHMgYSBjYXNlIHJlZHVjZXIgdG8gaGFuZGxlIGEgc2luZ2xlIGV4YWN0IGFjdGlvbiB0eXBlLlxuICAgKiBAcmVtYXJrc1xuICAgKiBBbGwgY2FsbHMgdG8gYGJ1aWxkZXIuYWRkQ2FzZWAgbXVzdCBjb21lIGJlZm9yZSBhbnkgY2FsbHMgdG8gYGJ1aWxkZXIuYWRkTWF0Y2hlcmAgb3IgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgLlxuICAgKiBAcGFyYW0gYWN0aW9uQ3JlYXRvciAtIEVpdGhlciBhIHBsYWluIGFjdGlvbiB0eXBlIHN0cmluZywgb3IgYW4gYWN0aW9uIGNyZWF0b3IgZ2VuZXJhdGVkIGJ5IFtgY3JlYXRlQWN0aW9uYF0oLi9jcmVhdGVBY3Rpb24pIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBhY3Rpb24gdHlwZS5cbiAgICogQHBhcmFtIHJlZHVjZXIgLSBUaGUgYWN0dWFsIGNhc2UgcmVkdWNlciBmdW5jdGlvbi5cbiAgICovXG4gIGFkZENhc2U8VHlwZSBleHRlbmRzIHN0cmluZywgQSBleHRlbmRzIEFjdGlvbjxUeXBlPj4odHlwZTogVHlwZSwgcmVkdWNlcjogQ2FzZVJlZHVjZXI8U3RhdGUsIEE+KTogQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXI8U3RhdGU+O1xuXG4gIC8qKlxuICAgKiBBbGxvd3MgeW91IHRvIG1hdGNoIHlvdXIgaW5jb21pbmcgYWN0aW9ucyBhZ2FpbnN0IHlvdXIgb3duIGZpbHRlciBmdW5jdGlvbiBpbnN0ZWFkIG9mIG9ubHkgdGhlIGBhY3Rpb24udHlwZWAgcHJvcGVydHkuXG4gICAqIEByZW1hcmtzXG4gICAqIElmIG11bHRpcGxlIG1hdGNoZXIgcmVkdWNlcnMgbWF0Y2gsIGFsbCBvZiB0aGVtIHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIG9yZGVyXG4gICAqIHRoZXkgd2VyZSBkZWZpbmVkIGluIC0gZXZlbiBpZiBhIGNhc2UgcmVkdWNlciBhbHJlYWR5IG1hdGNoZWQuXG4gICAqIEFsbCBjYWxscyB0byBgYnVpbGRlci5hZGRNYXRjaGVyYCBtdXN0IGNvbWUgYWZ0ZXIgYW55IGNhbGxzIHRvIGBidWlsZGVyLmFkZENhc2VgIGFuZCBiZWZvcmUgYW55IGNhbGxzIHRvIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYC5cbiAgICogQHBhcmFtIG1hdGNoZXIgLSBBIG1hdGNoZXIgZnVuY3Rpb24uIEluIFR5cGVTY3JpcHQsIHRoaXMgc2hvdWxkIGJlIGEgW3R5cGUgcHJlZGljYXRlXShodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay8yL25hcnJvd2luZy5odG1sI3VzaW5nLXR5cGUtcHJlZGljYXRlcylcbiAgICogICBmdW5jdGlvblxuICAgKiBAcGFyYW0gcmVkdWNlciAtIFRoZSBhY3R1YWwgY2FzZSByZWR1Y2VyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICBgYGB0c1xuICBpbXBvcnQge1xuICBjcmVhdGVBY3Rpb24sXG4gIGNyZWF0ZVJlZHVjZXIsXG4gIEFzeW5jVGh1bmssXG4gIFVua25vd25BY3Rpb24sXG4gIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbiAgdHlwZSBHZW5lcmljQXN5bmNUaHVuayA9IEFzeW5jVGh1bms8dW5rbm93biwgdW5rbm93biwgYW55PjtcbiAgdHlwZSBQZW5kaW5nQWN0aW9uID0gUmV0dXJuVHlwZTxHZW5lcmljQXN5bmNUaHVua1tcInBlbmRpbmdcIl0+O1xuICB0eXBlIFJlamVjdGVkQWN0aW9uID0gUmV0dXJuVHlwZTxHZW5lcmljQXN5bmNUaHVua1tcInJlamVjdGVkXCJdPjtcbiAgdHlwZSBGdWxmaWxsZWRBY3Rpb24gPSBSZXR1cm5UeXBlPEdlbmVyaWNBc3luY1RodW5rW1wiZnVsZmlsbGVkXCJdPjtcbiAgY29uc3QgaW5pdGlhbFN0YXRlOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIGNvbnN0IHJlc2V0QWN0aW9uID0gY3JlYXRlQWN0aW9uKFwicmVzZXQtdHJhY2tlZC1sb2FkaW5nLXN0YXRlXCIpO1xuICBmdW5jdGlvbiBpc1BlbmRpbmdBY3Rpb24oYWN0aW9uOiBVbmtub3duQWN0aW9uKTogYWN0aW9uIGlzIFBlbmRpbmdBY3Rpb24ge1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbi50eXBlID09PSBcInN0cmluZ1wiICYmIGFjdGlvbi50eXBlLmVuZHNXaXRoKFwiL3BlbmRpbmdcIik7XG4gIH1cbiAgY29uc3QgcmVkdWNlciA9IGNyZWF0ZVJlZHVjZXIoaW5pdGlhbFN0YXRlLCAoYnVpbGRlcikgPT4ge1xuICBidWlsZGVyXG4gICAgLmFkZENhc2UocmVzZXRBY3Rpb24sICgpID0+IGluaXRpYWxTdGF0ZSlcbiAgICAvLyBtYXRjaGVyIGNhbiBiZSBkZWZpbmVkIG91dHNpZGUgYXMgYSB0eXBlIHByZWRpY2F0ZSBmdW5jdGlvblxuICAgIC5hZGRNYXRjaGVyKGlzUGVuZGluZ0FjdGlvbiwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlW2FjdGlvbi5tZXRhLnJlcXVlc3RJZF0gPSBcInBlbmRpbmdcIjtcbiAgICB9KVxuICAgIC5hZGRNYXRjaGVyKFxuICAgICAgLy8gbWF0Y2hlciBjYW4gYmUgZGVmaW5lZCBpbmxpbmUgYXMgYSB0eXBlIHByZWRpY2F0ZSBmdW5jdGlvblxuICAgICAgKGFjdGlvbik6IGFjdGlvbiBpcyBSZWplY3RlZEFjdGlvbiA9PiBhY3Rpb24udHlwZS5lbmRzV2l0aChcIi9yZWplY3RlZFwiKSxcbiAgICAgIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgIHN0YXRlW2FjdGlvbi5tZXRhLnJlcXVlc3RJZF0gPSBcInJlamVjdGVkXCI7XG4gICAgICB9XG4gICAgKVxuICAgIC8vIG1hdGNoZXIgY2FuIGp1c3QgcmV0dXJuIGJvb2xlYW4gYW5kIHRoZSBtYXRjaGVyIGNhbiByZWNlaXZlIGEgZ2VuZXJpYyBhcmd1bWVudFxuICAgIC5hZGRNYXRjaGVyPEZ1bGZpbGxlZEFjdGlvbj4oXG4gICAgICAoYWN0aW9uKSA9PiBhY3Rpb24udHlwZS5lbmRzV2l0aChcIi9mdWxmaWxsZWRcIiksXG4gICAgICAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICBzdGF0ZVthY3Rpb24ubWV0YS5yZXF1ZXN0SWRdID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgIH1cbiAgICApO1xuICB9KTtcbiAgYGBgXG4gICAqL1xuICBhZGRNYXRjaGVyPEE+KG1hdGNoZXI6IFR5cGVHdWFyZDxBPiB8ICgoYWN0aW9uOiBhbnkpID0+IGJvb2xlYW4pLCByZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgQSBleHRlbmRzIEFjdGlvbiA/IEEgOiBBICYgQWN0aW9uPik6IE9taXQ8QWN0aW9uUmVkdWNlck1hcEJ1aWxkZXI8U3RhdGU+LCAnYWRkQ2FzZSc+O1xuXG4gIC8qKlxuICAgKiBBZGRzIGEgXCJkZWZhdWx0IGNhc2VcIiByZWR1Y2VyIHRoYXQgaXMgZXhlY3V0ZWQgaWYgbm8gY2FzZSByZWR1Y2VyIGFuZCBubyBtYXRjaGVyXG4gICAqIHJlZHVjZXIgd2FzIGV4ZWN1dGVkIGZvciB0aGlzIGFjdGlvbi5cbiAgICogQHBhcmFtIHJlZHVjZXIgLSBUaGUgZmFsbGJhY2sgXCJkZWZhdWx0IGNhc2VcIiByZWR1Y2VyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICBgYGB0c1xuICBpbXBvcnQgeyBjcmVhdGVSZWR1Y2VyIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCdcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0geyBvdGhlckFjdGlvbnM6IDAgfVxuICBjb25zdCByZWR1Y2VyID0gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdGUsIGJ1aWxkZXIgPT4ge1xuICBidWlsZGVyXG4gICAgLy8gLmFkZENhc2UoLi4uKVxuICAgIC8vIC5hZGRNYXRjaGVyKC4uLilcbiAgICAuYWRkRGVmYXVsdENhc2UoKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLm90aGVyQWN0aW9ucysrXG4gICAgfSlcbiAgfSlcbiAgYGBgXG4gICAqL1xuICBhZGREZWZhdWx0Q2FzZShyZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgQWN0aW9uPik6IHt9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrPFM+KGJ1aWxkZXJDYWxsYmFjazogKGJ1aWxkZXI6IEFjdGlvblJlZHVjZXJNYXBCdWlsZGVyPFM+KSA9PiB2b2lkKTogW0Nhc2VSZWR1Y2VyczxTLCBhbnk+LCBBY3Rpb25NYXRjaGVyRGVzY3JpcHRpb25Db2xsZWN0aW9uPFM+LCBDYXNlUmVkdWNlcjxTLCBBY3Rpb24+IHwgdW5kZWZpbmVkXSB7XG4gIGNvbnN0IGFjdGlvbnNNYXA6IENhc2VSZWR1Y2VyczxTLCBhbnk+ID0ge307XG4gIGNvbnN0IGFjdGlvbk1hdGNoZXJzOiBBY3Rpb25NYXRjaGVyRGVzY3JpcHRpb25Db2xsZWN0aW9uPFM+ID0gW107XG4gIGxldCBkZWZhdWx0Q2FzZVJlZHVjZXI6IENhc2VSZWR1Y2VyPFMsIEFjdGlvbj4gfCB1bmRlZmluZWQ7XG4gIGNvbnN0IGJ1aWxkZXIgPSB7XG4gICAgYWRkQ2FzZSh0eXBlT3JBY3Rpb25DcmVhdG9yOiBzdHJpbmcgfCBUeXBlZEFjdGlvbkNyZWF0b3I8YW55PiwgcmVkdWNlcjogQ2FzZVJlZHVjZXI8Uz4pIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8qXG4gICAgICAgICB0byBrZWVwIHRoZSBkZWZpbml0aW9uIGJ5IHRoZSB1c2VyIGluIGxpbmUgd2l0aCBhY3R1YWwgYmVoYXZpb3IsXG4gICAgICAgICB3ZSBlbmZvcmNlIGBhZGRDYXNlYCB0byBhbHdheXMgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBhZGRNYXRjaGVyYFxuICAgICAgICAgYXMgbWF0Y2hpbmcgY2FzZXMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgbWF0Y2hlcnNcbiAgICAgICAgICovXG4gICAgICAgIGlmIChhY3Rpb25NYXRjaGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI2KSA6ICdgYnVpbGRlci5hZGRDYXNlYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkTWF0Y2hlcmAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMigyNykgOiAnYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHR5cGVPckFjdGlvbkNyZWF0b3IgPT09ICdzdHJpbmcnID8gdHlwZU9yQWN0aW9uQ3JlYXRvciA6IHR5cGVPckFjdGlvbkNyZWF0b3IudHlwZTtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzKDI4KSA6ICdgYnVpbGRlci5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggYW4gZW1wdHkgYWN0aW9uIHR5cGUnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlIGluIGFjdGlvbnNNYXApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCgyOSkgOiAnYGJ1aWxkZXIuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIHR3byByZWR1Y2VycyBmb3IgdGhlIHNhbWUgYWN0aW9uIHR5cGUgJyArIGAnJHt0eXBlfSdgKTtcbiAgICAgIH1cbiAgICAgIGFjdGlvbnNNYXBbdHlwZV0gPSByZWR1Y2VyO1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfSxcbiAgICBhZGRNYXRjaGVyPEE+KG1hdGNoZXI6IFR5cGVHdWFyZDxBPiwgcmVkdWNlcjogQ2FzZVJlZHVjZXI8UywgQSBleHRlbmRzIEFjdGlvbiA/IEEgOiBBICYgQWN0aW9uPikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTUoMzApIDogJ2BidWlsZGVyLmFkZE1hdGNoZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWN0aW9uTWF0Y2hlcnMucHVzaCh7XG4gICAgICAgIG1hdGNoZXIsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfSxcbiAgICBhZGREZWZhdWx0Q2FzZShyZWR1Y2VyOiBDYXNlUmVkdWNlcjxTLCBBY3Rpb24+KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNigzMSkgOiAnYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlZmF1bHRDYXNlUmVkdWNlciA9IHJlZHVjZXI7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG4gIH07XG4gIGJ1aWxkZXJDYWxsYmFjayhidWlsZGVyKTtcbiAgcmV0dXJuIFthY3Rpb25zTWFwLCBhY3Rpb25NYXRjaGVycywgZGVmYXVsdENhc2VSZWR1Y2VyXTtcbn0iLCJpbXBvcnQgdHlwZSB7IEFjdGlvbkZyb21NYXRjaGVyLCBNYXRjaGVyLCBVbmlvblRvSW50ZXJzZWN0aW9uIH0gZnJvbSAnLi90c0hlbHBlcnMnO1xuaW1wb3J0IHsgaGFzTWF0Y2hGdW5jdGlvbiB9IGZyb20gJy4vdHNIZWxwZXJzJztcbmltcG9ydCB0eXBlIHsgQXN5bmNUaHVuaywgQXN5bmNUaHVua0Z1bGZpbGxlZEFjdGlvbkNyZWF0b3IsIEFzeW5jVGh1bmtQZW5kaW5nQWN0aW9uQ3JlYXRvciwgQXN5bmNUaHVua1JlamVjdGVkQWN0aW9uQ3JlYXRvciB9IGZyb20gJy4vY3JlYXRlQXN5bmNUaHVuayc7XG5cbi8qKiBAcHVibGljICovXG5leHBvcnQgdHlwZSBBY3Rpb25NYXRjaGluZ0FueU9mPE1hdGNoZXJzIGV4dGVuZHMgTWF0Y2hlcjxhbnk+W10+ID0gQWN0aW9uRnJvbU1hdGNoZXI8TWF0Y2hlcnNbbnVtYmVyXT47XG5cbi8qKiBAcHVibGljICovXG5leHBvcnQgdHlwZSBBY3Rpb25NYXRjaGluZ0FsbE9mPE1hdGNoZXJzIGV4dGVuZHMgTWF0Y2hlcjxhbnk+W10+ID0gVW5pb25Ub0ludGVyc2VjdGlvbjxBY3Rpb25NYXRjaGluZ0FueU9mPE1hdGNoZXJzPj47XG5jb25zdCBtYXRjaGVzID0gKG1hdGNoZXI6IE1hdGNoZXI8YW55PiwgYWN0aW9uOiBhbnkpID0+IHtcbiAgaWYgKGhhc01hdGNoRnVuY3Rpb24obWF0Y2hlcikpIHtcbiAgICByZXR1cm4gbWF0Y2hlci5tYXRjaChhY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYXRjaGVyKGFjdGlvbik7XG4gIH1cbn07XG5cbi8qKlxuICogQSBoaWdoZXItb3JkZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBjaGVja1xuICogd2hldGhlciBhbiBhY3Rpb24gbWF0Y2hlcyBhbnkgb25lIG9mIHRoZSBzdXBwbGllZCB0eXBlIGd1YXJkcyBvciBhY3Rpb25cbiAqIGNyZWF0b3JzLlxuICpcbiAqIEBwYXJhbSBtYXRjaGVycyBUaGUgdHlwZSBndWFyZHMgb3IgYWN0aW9uIGNyZWF0b3JzIHRvIG1hdGNoIGFnYWluc3QuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBbnlPZjxNYXRjaGVycyBleHRlbmRzIE1hdGNoZXI8YW55PltdPiguLi5tYXRjaGVyczogTWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb246IGFueSk6IGFjdGlvbiBpcyBBY3Rpb25NYXRjaGluZ0FueU9mPE1hdGNoZXJzPiA9PiB7XG4gICAgcmV0dXJuIG1hdGNoZXJzLnNvbWUobWF0Y2hlciA9PiBtYXRjaGVzKG1hdGNoZXIsIGFjdGlvbikpO1xuICB9O1xufVxuXG4vKipcbiAqIEEgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2hlY2tcbiAqIHdoZXRoZXIgYW4gYWN0aW9uIG1hdGNoZXMgYWxsIG9mIHRoZSBzdXBwbGllZCB0eXBlIGd1YXJkcyBvciBhY3Rpb25cbiAqIGNyZWF0b3JzLlxuICpcbiAqIEBwYXJhbSBtYXRjaGVycyBUaGUgdHlwZSBndWFyZHMgb3IgYWN0aW9uIGNyZWF0b3JzIHRvIG1hdGNoIGFnYWluc3QuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBbGxPZjxNYXRjaGVycyBleHRlbmRzIE1hdGNoZXI8YW55PltdPiguLi5tYXRjaGVyczogTWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb246IGFueSk6IGFjdGlvbiBpcyBBY3Rpb25NYXRjaGluZ0FsbE9mPE1hdGNoZXJzPiA9PiB7XG4gICAgcmV0dXJuIG1hdGNoZXJzLmV2ZXJ5KG1hdGNoZXIgPT4gbWF0Y2hlcyhtYXRjaGVyLCBhY3Rpb24pKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gYWN0aW9uIEEgcmVkdXggYWN0aW9uXG4gKiBAcGFyYW0gdmFsaWRTdGF0dXMgQW4gYXJyYXkgb2YgdmFsaWQgbWV0YS5yZXF1ZXN0U3RhdHVzIHZhbHVlc1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uOiBhbnksIHZhbGlkU3RhdHVzOiByZWFkb25seSBzdHJpbmdbXSkge1xuICBpZiAoIWFjdGlvbiB8fCAhYWN0aW9uLm1ldGEpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgaGFzVmFsaWRSZXF1ZXN0SWQgPSB0eXBlb2YgYWN0aW9uLm1ldGEucmVxdWVzdElkID09PSAnc3RyaW5nJztcbiAgY29uc3QgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzID0gdmFsaWRTdGF0dXMuaW5kZXhPZihhY3Rpb24ubWV0YS5yZXF1ZXN0U3RhdHVzKSA+IC0xO1xuICByZXR1cm4gaGFzVmFsaWRSZXF1ZXN0SWQgJiYgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzO1xufVxuZnVuY3Rpb24gaXNBc3luY1RodW5rQXJyYXkoYTogW2FueV0gfCBBbnlBc3luY1RodW5rW10pOiBhIGlzIEFueUFzeW5jVGh1bmtbXSB7XG4gIHJldHVybiB0eXBlb2YgYVswXSA9PT0gJ2Z1bmN0aW9uJyAmJiAncGVuZGluZycgaW4gYVswXSAmJiAnZnVsZmlsbGVkJyBpbiBhWzBdICYmICdyZWplY3RlZCcgaW4gYVswXTtcbn1cbmV4cG9ydCB0eXBlIFVua25vd25Bc3luY1RodW5rUGVuZGluZ0FjdGlvbiA9IFJldHVyblR5cGU8QXN5bmNUaHVua1BlbmRpbmdBY3Rpb25DcmVhdG9yPHVua25vd24+PjtcbmV4cG9ydCB0eXBlIFBlbmRpbmdBY3Rpb25Gcm9tQXN5bmNUaHVuazxUIGV4dGVuZHMgQW55QXN5bmNUaHVuaz4gPSBBY3Rpb25Gcm9tTWF0Y2hlcjxUWydwZW5kaW5nJ10+O1xuXG4vKipcbiAqIEEgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2hlY2tcbiAqIHdoZXRoZXIgYW4gYWN0aW9uIHdhcyBjcmVhdGVkIGJ5IGFuIGFzeW5jIHRodW5rIGFjdGlvbiBjcmVhdG9yLCBhbmQgdGhhdFxuICogdGhlIGFjdGlvbiBpcyBwZW5kaW5nLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGVuZGluZygpOiAoYWN0aW9uOiBhbnkpID0+IGFjdGlvbiBpcyBVbmtub3duQXN5bmNUaHVua1BlbmRpbmdBY3Rpb247XG4vKipcbiAqIEEgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2hlY2tcbiAqIHdoZXRoZXIgYW4gYWN0aW9uIGJlbG9uZ3MgdG8gb25lIG9mIHRoZSBwcm92aWRlZCBhc3luYyB0aHVuayBhY3Rpb24gY3JlYXRvcnMsXG4gKiBhbmQgdGhhdCB0aGUgYWN0aW9uIGlzIHBlbmRpbmcuXG4gKlxuICogQHBhcmFtIGFzeW5jVGh1bmtzIChvcHRpb25hbCkgVGhlIGFzeW5jIHRodW5rIGFjdGlvbiBjcmVhdG9ycyB0byBtYXRjaCBhZ2FpbnN0LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGVuZGluZzxBc3luY1RodW5rcyBleHRlbmRzIFtBbnlBc3luY1RodW5rLCAuLi5BbnlBc3luY1RodW5rW11dPiguLi5hc3luY1RodW5rczogQXN5bmNUaHVua3MpOiAoYWN0aW9uOiBhbnkpID0+IGFjdGlvbiBpcyBQZW5kaW5nQWN0aW9uRnJvbUFzeW5jVGh1bms8QXN5bmNUaHVua3NbbnVtYmVyXT47XG4vKipcbiAqIFRlc3RzIGlmIGBhY3Rpb25gIGlzIGEgcGVuZGluZyB0aHVuayBhY3Rpb25cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGVuZGluZyhhY3Rpb246IGFueSk6IGFjdGlvbiBpcyBVbmtub3duQXN5bmNUaHVua1BlbmRpbmdBY3Rpb247XG5leHBvcnQgZnVuY3Rpb24gaXNQZW5kaW5nPEFzeW5jVGh1bmtzIGV4dGVuZHMgW0FueUFzeW5jVGh1bmssIC4uLkFueUFzeW5jVGh1bmtbXV0+KC4uLmFzeW5jVGh1bmtzOiBBc3luY1RodW5rcyB8IFthbnldKSB7XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbjogYW55KSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFsncGVuZGluZyddKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc1BlbmRpbmcoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIGlzQW55T2YoLi4uYXN5bmNUaHVua3MubWFwKGFzeW5jVGh1bmsgPT4gYXN5bmNUaHVuay5wZW5kaW5nKSk7XG59XG5leHBvcnQgdHlwZSBVbmtub3duQXN5bmNUaHVua1JlamVjdGVkQWN0aW9uID0gUmV0dXJuVHlwZTxBc3luY1RodW5rUmVqZWN0ZWRBY3Rpb25DcmVhdG9yPHVua25vd24sIHVua25vd24+PjtcbmV4cG9ydCB0eXBlIFJlamVjdGVkQWN0aW9uRnJvbUFzeW5jVGh1bms8VCBleHRlbmRzIEFueUFzeW5jVGh1bms+ID0gQWN0aW9uRnJvbU1hdGNoZXI8VFsncmVqZWN0ZWQnXT47XG5cbi8qKlxuICogQSBoaWdoZXItb3JkZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBjaGVja1xuICogd2hldGhlciBhbiBhY3Rpb24gd2FzIGNyZWF0ZWQgYnkgYW4gYXN5bmMgdGh1bmsgYWN0aW9uIGNyZWF0b3IsIGFuZCB0aGF0XG4gKiB0aGUgYWN0aW9uIGlzIHJlamVjdGVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVqZWN0ZWQoKTogKGFjdGlvbjogYW55KSA9PiBhY3Rpb24gaXMgVW5rbm93bkFzeW5jVGh1bmtSZWplY3RlZEFjdGlvbjtcbi8qKlxuICogQSBoaWdoZXItb3JkZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBjaGVja1xuICogd2hldGhlciBhbiBhY3Rpb24gYmVsb25ncyB0byBvbmUgb2YgdGhlIHByb3ZpZGVkIGFzeW5jIHRodW5rIGFjdGlvbiBjcmVhdG9ycyxcbiAqIGFuZCB0aGF0IHRoZSBhY3Rpb24gaXMgcmVqZWN0ZWQuXG4gKlxuICogQHBhcmFtIGFzeW5jVGh1bmtzIChvcHRpb25hbCkgVGhlIGFzeW5jIHRodW5rIGFjdGlvbiBjcmVhdG9ycyB0byBtYXRjaCBhZ2FpbnN0LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVqZWN0ZWQ8QXN5bmNUaHVua3MgZXh0ZW5kcyBbQW55QXN5bmNUaHVuaywgLi4uQW55QXN5bmNUaHVua1tdXT4oLi4uYXN5bmNUaHVua3M6IEFzeW5jVGh1bmtzKTogKGFjdGlvbjogYW55KSA9PiBhY3Rpb24gaXMgUmVqZWN0ZWRBY3Rpb25Gcm9tQXN5bmNUaHVuazxBc3luY1RodW5rc1tudW1iZXJdPjtcbi8qKlxuICogVGVzdHMgaWYgYGFjdGlvbmAgaXMgYSByZWplY3RlZCB0aHVuayBhY3Rpb25cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVqZWN0ZWQoYWN0aW9uOiBhbnkpOiBhY3Rpb24gaXMgVW5rbm93bkFzeW5jVGh1bmtSZWplY3RlZEFjdGlvbjtcbmV4cG9ydCBmdW5jdGlvbiBpc1JlamVjdGVkPEFzeW5jVGh1bmtzIGV4dGVuZHMgW0FueUFzeW5jVGh1bmssIC4uLkFueUFzeW5jVGh1bmtbXV0+KC4uLmFzeW5jVGh1bmtzOiBBc3luY1RodW5rcyB8IFthbnldKSB7XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbjogYW55KSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFsncmVqZWN0ZWQnXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNSZWplY3RlZCgpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gaXNBbnlPZiguLi5hc3luY1RodW5rcy5tYXAoYXN5bmNUaHVuayA9PiBhc3luY1RodW5rLnJlamVjdGVkKSk7XG59XG5leHBvcnQgdHlwZSBVbmtub3duQXN5bmNUaHVua1JlamVjdGVkV2l0aFZhbHVlQWN0aW9uID0gUmV0dXJuVHlwZTxBc3luY1RodW5rUmVqZWN0ZWRBY3Rpb25DcmVhdG9yPHVua25vd24sIHVua25vd24+PjtcbmV4cG9ydCB0eXBlIFJlamVjdGVkV2l0aFZhbHVlQWN0aW9uRnJvbUFzeW5jVGh1bms8VCBleHRlbmRzIEFueUFzeW5jVGh1bms+ID0gQWN0aW9uRnJvbU1hdGNoZXI8VFsncmVqZWN0ZWQnXT4gJiAoVCBleHRlbmRzIEFzeW5jVGh1bms8YW55LCBhbnksIHtcbiAgcmVqZWN0VmFsdWU6IGluZmVyIFJlamVjdGVkVmFsdWU7XG59PiA/IHtcbiAgcGF5bG9hZDogUmVqZWN0ZWRWYWx1ZTtcbn0gOiB1bmtub3duKTtcblxuLyoqXG4gKiBBIGhpZ2hlci1vcmRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIGNoZWNrXG4gKiB3aGV0aGVyIGFuIGFjdGlvbiB3YXMgY3JlYXRlZCBieSBhbiBhc3luYyB0aHVuayBhY3Rpb24gY3JlYXRvciwgYW5kIHRoYXRcbiAqIHRoZSBhY3Rpb24gaXMgcmVqZWN0ZWQgd2l0aCB2YWx1ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JlamVjdGVkV2l0aFZhbHVlKCk6IChhY3Rpb246IGFueSkgPT4gYWN0aW9uIGlzIFVua25vd25Bc3luY1RodW5rUmVqZWN0ZWRBY3Rpb247XG4vKipcbiAqIEEgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2hlY2tcbiAqIHdoZXRoZXIgYW4gYWN0aW9uIGJlbG9uZ3MgdG8gb25lIG9mIHRoZSBwcm92aWRlZCBhc3luYyB0aHVuayBhY3Rpb24gY3JlYXRvcnMsXG4gKiBhbmQgdGhhdCB0aGUgYWN0aW9uIGlzIHJlamVjdGVkIHdpdGggdmFsdWUuXG4gKlxuICogQHBhcmFtIGFzeW5jVGh1bmtzIChvcHRpb25hbCkgVGhlIGFzeW5jIHRodW5rIGFjdGlvbiBjcmVhdG9ycyB0byBtYXRjaCBhZ2FpbnN0LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVqZWN0ZWRXaXRoVmFsdWU8QXN5bmNUaHVua3MgZXh0ZW5kcyBbQW55QXN5bmNUaHVuaywgLi4uQW55QXN5bmNUaHVua1tdXT4oLi4uYXN5bmNUaHVua3M6IEFzeW5jVGh1bmtzKTogKGFjdGlvbjogYW55KSA9PiBhY3Rpb24gaXMgUmVqZWN0ZWRXaXRoVmFsdWVBY3Rpb25Gcm9tQXN5bmNUaHVuazxBc3luY1RodW5rc1tudW1iZXJdPjtcbi8qKlxuICogVGVzdHMgaWYgYGFjdGlvbmAgaXMgYSByZWplY3RlZCB0aHVuayBhY3Rpb24gd2l0aCB2YWx1ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNSZWplY3RlZFdpdGhWYWx1ZShhY3Rpb246IGFueSk6IGFjdGlvbiBpcyBVbmtub3duQXN5bmNUaHVua1JlamVjdGVkQWN0aW9uO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVqZWN0ZWRXaXRoVmFsdWU8QXN5bmNUaHVua3MgZXh0ZW5kcyBbQW55QXN5bmNUaHVuaywgLi4uQW55QXN5bmNUaHVua1tdXT4oLi4uYXN5bmNUaHVua3M6IEFzeW5jVGh1bmtzIHwgW2FueV0pIHtcbiAgY29uc3QgaGFzRmxhZyA9IChhY3Rpb246IGFueSk6IGFjdGlvbiBpcyBhbnkgPT4ge1xuICAgIHJldHVybiBhY3Rpb24gJiYgYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWU7XG4gIH07XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaXNBbGxPZihpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNSZWplY3RlZFdpdGhWYWx1ZSgpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gaXNBbGxPZihpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XG59XG5leHBvcnQgdHlwZSBVbmtub3duQXN5bmNUaHVua0Z1bGZpbGxlZEFjdGlvbiA9IFJldHVyblR5cGU8QXN5bmNUaHVua0Z1bGZpbGxlZEFjdGlvbkNyZWF0b3I8dW5rbm93biwgdW5rbm93bj4+O1xuZXhwb3J0IHR5cGUgRnVsZmlsbGVkQWN0aW9uRnJvbUFzeW5jVGh1bms8VCBleHRlbmRzIEFueUFzeW5jVGh1bms+ID0gQWN0aW9uRnJvbU1hdGNoZXI8VFsnZnVsZmlsbGVkJ10+O1xuXG4vKipcbiAqIEEgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2hlY2tcbiAqIHdoZXRoZXIgYW4gYWN0aW9uIHdhcyBjcmVhdGVkIGJ5IGFuIGFzeW5jIHRodW5rIGFjdGlvbiBjcmVhdG9yLCBhbmQgdGhhdFxuICogdGhlIGFjdGlvbiBpcyBmdWxmaWxsZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdWxmaWxsZWQoKTogKGFjdGlvbjogYW55KSA9PiBhY3Rpb24gaXMgVW5rbm93bkFzeW5jVGh1bmtGdWxmaWxsZWRBY3Rpb247XG4vKipcbiAqIEEgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2hlY2tcbiAqIHdoZXRoZXIgYW4gYWN0aW9uIGJlbG9uZ3MgdG8gb25lIG9mIHRoZSBwcm92aWRlZCBhc3luYyB0aHVuayBhY3Rpb24gY3JlYXRvcnMsXG4gKiBhbmQgdGhhdCB0aGUgYWN0aW9uIGlzIGZ1bGZpbGxlZC5cbiAqXG4gKiBAcGFyYW0gYXN5bmNUaHVua3MgKG9wdGlvbmFsKSBUaGUgYXN5bmMgdGh1bmsgYWN0aW9uIGNyZWF0b3JzIHRvIG1hdGNoIGFnYWluc3QuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdWxmaWxsZWQ8QXN5bmNUaHVua3MgZXh0ZW5kcyBbQW55QXN5bmNUaHVuaywgLi4uQW55QXN5bmNUaHVua1tdXT4oLi4uYXN5bmNUaHVua3M6IEFzeW5jVGh1bmtzKTogKGFjdGlvbjogYW55KSA9PiBhY3Rpb24gaXMgRnVsZmlsbGVkQWN0aW9uRnJvbUFzeW5jVGh1bms8QXN5bmNUaHVua3NbbnVtYmVyXT47XG4vKipcbiAqIFRlc3RzIGlmIGBhY3Rpb25gIGlzIGEgZnVsZmlsbGVkIHRodW5rIGFjdGlvblxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdWxmaWxsZWQoYWN0aW9uOiBhbnkpOiBhY3Rpb24gaXMgVW5rbm93bkFzeW5jVGh1bmtGdWxmaWxsZWRBY3Rpb247XG5leHBvcnQgZnVuY3Rpb24gaXNGdWxmaWxsZWQ8QXN5bmNUaHVua3MgZXh0ZW5kcyBbQW55QXN5bmNUaHVuaywgLi4uQW55QXN5bmNUaHVua1tdXT4oLi4uYXN5bmNUaHVua3M6IEFzeW5jVGh1bmtzIHwgW2FueV0pIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uOiBhbnkpID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgWydmdWxmaWxsZWQnXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNGdWxmaWxsZWQoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIGlzQW55T2YoLi4uYXN5bmNUaHVua3MubWFwKGFzeW5jVGh1bmsgPT4gYXN5bmNUaHVuay5mdWxmaWxsZWQpKTtcbn1cbmV4cG9ydCB0eXBlIFVua25vd25Bc3luY1RodW5rQWN0aW9uID0gVW5rbm93bkFzeW5jVGh1bmtQZW5kaW5nQWN0aW9uIHwgVW5rbm93bkFzeW5jVGh1bmtSZWplY3RlZEFjdGlvbiB8IFVua25vd25Bc3luY1RodW5rRnVsZmlsbGVkQWN0aW9uO1xuZXhwb3J0IHR5cGUgQW55QXN5bmNUaHVuayA9IHtcbiAgcGVuZGluZzoge1xuICAgIG1hdGNoOiAoYWN0aW9uOiBhbnkpID0+IGFjdGlvbiBpcyBhbnk7XG4gIH07XG4gIGZ1bGZpbGxlZDoge1xuICAgIG1hdGNoOiAoYWN0aW9uOiBhbnkpID0+IGFjdGlvbiBpcyBhbnk7XG4gIH07XG4gIHJlamVjdGVkOiB7XG4gICAgbWF0Y2g6IChhY3Rpb246IGFueSkgPT4gYWN0aW9uIGlzIGFueTtcbiAgfTtcbn07XG5leHBvcnQgdHlwZSBBY3Rpb25zRnJvbUFzeW5jVGh1bms8VCBleHRlbmRzIEFueUFzeW5jVGh1bms+ID0gQWN0aW9uRnJvbU1hdGNoZXI8VFsncGVuZGluZyddPiB8IEFjdGlvbkZyb21NYXRjaGVyPFRbJ2Z1bGZpbGxlZCddPiB8IEFjdGlvbkZyb21NYXRjaGVyPFRbJ3JlamVjdGVkJ10+O1xuXG4vKipcbiAqIEEgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2hlY2tcbiAqIHdoZXRoZXIgYW4gYWN0aW9uIHdhcyBjcmVhdGVkIGJ5IGFuIGFzeW5jIHRodW5rIGFjdGlvbiBjcmVhdG9yLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXN5bmNUaHVua0FjdGlvbigpOiAoYWN0aW9uOiBhbnkpID0+IGFjdGlvbiBpcyBVbmtub3duQXN5bmNUaHVua0FjdGlvbjtcbi8qKlxuICogQSBoaWdoZXItb3JkZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBjaGVja1xuICogd2hldGhlciBhbiBhY3Rpb24gYmVsb25ncyB0byBvbmUgb2YgdGhlIHByb3ZpZGVkIGFzeW5jIHRodW5rIGFjdGlvbiBjcmVhdG9ycy5cbiAqXG4gKiBAcGFyYW0gYXN5bmNUaHVua3MgKG9wdGlvbmFsKSBUaGUgYXN5bmMgdGh1bmsgYWN0aW9uIGNyZWF0b3JzIHRvIG1hdGNoIGFnYWluc3QuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBc3luY1RodW5rQWN0aW9uPEFzeW5jVGh1bmtzIGV4dGVuZHMgW0FueUFzeW5jVGh1bmssIC4uLkFueUFzeW5jVGh1bmtbXV0+KC4uLmFzeW5jVGh1bmtzOiBBc3luY1RodW5rcyk6IChhY3Rpb246IGFueSkgPT4gYWN0aW9uIGlzIEFjdGlvbnNGcm9tQXN5bmNUaHVuazxBc3luY1RodW5rc1tudW1iZXJdPjtcbi8qKlxuICogVGVzdHMgaWYgYGFjdGlvbmAgaXMgYSB0aHVuayBhY3Rpb25cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXN5bmNUaHVua0FjdGlvbihhY3Rpb246IGFueSk6IGFjdGlvbiBpcyBVbmtub3duQXN5bmNUaHVua0FjdGlvbjtcbmV4cG9ydCBmdW5jdGlvbiBpc0FzeW5jVGh1bmtBY3Rpb248QXN5bmNUaHVua3MgZXh0ZW5kcyBbQW55QXN5bmNUaHVuaywgLi4uQW55QXN5bmNUaHVua1tdXT4oLi4uYXN5bmNUaHVua3M6IEFzeW5jVGh1bmtzIHwgW2FueV0pIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uOiBhbnkpID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgWydwZW5kaW5nJywgJ2Z1bGZpbGxlZCcsICdyZWplY3RlZCddKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc0FzeW5jVGh1bmtBY3Rpb24oKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIGlzQW55T2YoLi4uYXN5bmNUaHVua3MuZmxhdE1hcChhc3luY1RodW5rID0+IFthc3luY1RodW5rLnBlbmRpbmcsIGFzeW5jVGh1bmsucmVqZWN0ZWQsIGFzeW5jVGh1bmsuZnVsZmlsbGVkXSkpO1xufSIsIi8vIEJvcnJvd2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FpL25hbm9pZC9ibG9iLzMuMC4yL25vbi1zZWN1cmUvaW5kZXguanNcbi8vIFRoaXMgYWxwaGFiZXQgdXNlcyBgQS1aYS16MC05Xy1gIHN5bWJvbHMuIEEgZ2VuZXRpYyBhbGdvcml0aG0gaGVscGVkXG4vLyBvcHRpbWl6ZSB0aGUgZ3ppcCBjb21wcmVzc2lvbiBmb3IgdGhpcyBhbHBoYWJldC5cbmxldCB1cmxBbHBoYWJldCA9ICdNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXJztcblxuLyoqXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXG5leHBvcnQgbGV0IG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gJyc7XG4gIC8vIEEgY29tcGFjdCBhbHRlcm5hdGl2ZSBmb3IgYGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcDsgaSsrKWAuXG4gIGxldCBpID0gc2l6ZTtcbiAgd2hpbGUgKGktLSkge1xuICAgIC8vIGB8IDBgIGlzIG1vcmUgY29tcGFjdCBhbmQgZmFzdGVyIHRoYW4gYE1hdGguZmxvb3IoKWAuXG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XG4gIH1cbiAgcmV0dXJuIGlkO1xufTsiLCJpbXBvcnQgdHlwZSB7IERpc3BhdGNoLCBVbmtub3duQWN0aW9uIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHR5cGUgeyBUaHVua0Rpc3BhdGNoIH0gZnJvbSAncmVkdXgtdGh1bmsnO1xuaW1wb3J0IHR5cGUgeyBBY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZCB9IGZyb20gJy4vY3JlYXRlQWN0aW9uJztcbmltcG9ydCB7IGNyZWF0ZUFjdGlvbiB9IGZyb20gJy4vY3JlYXRlQWN0aW9uJztcbmltcG9ydCB7IGlzQW55T2YgfSBmcm9tICcuL21hdGNoZXJzJztcbmltcG9ydCB7IG5hbm9pZCB9IGZyb20gJy4vbmFub2lkJztcbmltcG9ydCB0eXBlIHsgRmFsbGJhY2tJZlVua25vd24sIElkLCBJc0FueSwgSXNVbmtub3duLCBTYWZlUHJvbWlzZSB9IGZyb20gJy4vdHNIZWxwZXJzJztcbmV4cG9ydCB0eXBlIEJhc2VUaHVua0FQSTxTLCBFLCBEIGV4dGVuZHMgRGlzcGF0Y2ggPSBEaXNwYXRjaCwgUmVqZWN0ZWRWYWx1ZSA9IHVua25vd24sIFJlamVjdGVkTWV0YSA9IHVua25vd24sIEZ1bGZpbGxlZE1ldGEgPSB1bmtub3duPiA9IHtcbiAgZGlzcGF0Y2g6IEQ7XG4gIGdldFN0YXRlOiAoKSA9PiBTO1xuICBleHRyYTogRTtcbiAgcmVxdWVzdElkOiBzdHJpbmc7XG4gIHNpZ25hbDogQWJvcnRTaWduYWw7XG4gIGFib3J0OiAocmVhc29uPzogc3RyaW5nKSA9PiB2b2lkO1xuICByZWplY3RXaXRoVmFsdWU6IElzVW5rbm93bjxSZWplY3RlZE1ldGEsICh2YWx1ZTogUmVqZWN0ZWRWYWx1ZSkgPT4gUmVqZWN0V2l0aFZhbHVlPFJlamVjdGVkVmFsdWUsIFJlamVjdGVkTWV0YT4sICh2YWx1ZTogUmVqZWN0ZWRWYWx1ZSwgbWV0YTogUmVqZWN0ZWRNZXRhKSA9PiBSZWplY3RXaXRoVmFsdWU8UmVqZWN0ZWRWYWx1ZSwgUmVqZWN0ZWRNZXRhPj47XG4gIGZ1bGZpbGxXaXRoVmFsdWU6IElzVW5rbm93bjxGdWxmaWxsZWRNZXRhLCA8RnVsZmlsbGVkVmFsdWU+KHZhbHVlOiBGdWxmaWxsZWRWYWx1ZSkgPT4gRnVsZmlsbGVkVmFsdWUsIDxGdWxmaWxsZWRWYWx1ZT4odmFsdWU6IEZ1bGZpbGxlZFZhbHVlLCBtZXRhOiBGdWxmaWxsZWRNZXRhKSA9PiBGdWxmaWxsV2l0aE1ldGE8RnVsZmlsbGVkVmFsdWUsIEZ1bGZpbGxlZE1ldGE+Pjtcbn07XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6ZWRFcnJvciB7XG4gIG5hbWU/OiBzdHJpbmc7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIHN0YWNrPzogc3RyaW5nO1xuICBjb2RlPzogc3RyaW5nO1xufVxuY29uc3QgY29tbW9uUHJvcGVydGllczogQXJyYXk8a2V5b2YgU2VyaWFsaXplZEVycm9yPiA9IFsnbmFtZScsICdtZXNzYWdlJywgJ3N0YWNrJywgJ2NvZGUnXTtcbmNsYXNzIFJlamVjdFdpdGhWYWx1ZTxQYXlsb2FkLCBSZWplY3RlZE1ldGE+IHtcbiAgLypcbiAgdHlwZS1vbmx5IHByb3BlcnR5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gUmVqZWN0V2l0aFZhbHVlIGFuZCBGdWxmaWxsV2l0aE1ldGFcbiAgZG9lcyBub3QgZXhpc3QgYXQgcnVudGltZVxuICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IF90eXBlITogJ1JlamVjdFdpdGhWYWx1ZSc7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBwYXlsb2FkOiBQYXlsb2FkLCBwdWJsaWMgcmVhZG9ubHkgbWV0YTogUmVqZWN0ZWRNZXRhKSB7fVxufVxuY2xhc3MgRnVsZmlsbFdpdGhNZXRhPFBheWxvYWQsIEZ1bGZpbGxlZE1ldGE+IHtcbiAgLypcbiAgdHlwZS1vbmx5IHByb3BlcnR5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gUmVqZWN0V2l0aFZhbHVlIGFuZCBGdWxmaWxsV2l0aE1ldGFcbiAgZG9lcyBub3QgZXhpc3QgYXQgcnVudGltZVxuICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IF90eXBlITogJ0Z1bGZpbGxXaXRoTWV0YSc7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBwYXlsb2FkOiBQYXlsb2FkLCBwdWJsaWMgcmVhZG9ubHkgbWV0YTogRnVsZmlsbGVkTWV0YSkge31cbn1cblxuLyoqXG4gKiBTZXJpYWxpemVzIGFuIGVycm9yIGludG8gYSBwbGFpbiBvYmplY3QuXG4gKiBSZXdvcmtlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvc2VyaWFsaXplLWVycm9yXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgbWluaVNlcmlhbGl6ZUVycm9yID0gKHZhbHVlOiBhbnkpOiBTZXJpYWxpemVkRXJyb3IgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNpbXBsZUVycm9yOiBTZXJpYWxpemVkRXJyb3IgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGNvbW1vblByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbcHJvcGVydHldID09PSAnc3RyaW5nJykge1xuICAgICAgICBzaW1wbGVFcnJvcltwcm9wZXJ0eV0gPSB2YWx1ZVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaW1wbGVFcnJvcjtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2U6IFN0cmluZyh2YWx1ZSlcbiAgfTtcbn07XG5leHBvcnQgdHlwZSBBc3luY1RodW5rQ29uZmlnID0ge1xuICBzdGF0ZT86IHVua25vd247XG4gIGRpc3BhdGNoPzogVGh1bmtEaXNwYXRjaDx1bmtub3duLCB1bmtub3duLCBVbmtub3duQWN0aW9uPjtcbiAgZXh0cmE/OiB1bmtub3duO1xuICByZWplY3RWYWx1ZT86IHVua25vd247XG4gIHNlcmlhbGl6ZWRFcnJvclR5cGU/OiB1bmtub3duO1xuICBwZW5kaW5nTWV0YT86IHVua25vd247XG4gIGZ1bGZpbGxlZE1ldGE/OiB1bmtub3duO1xuICByZWplY3RlZE1ldGE/OiB1bmtub3duO1xufTtcbmV4cG9ydCB0eXBlIEdldFN0YXRlPFRodW5rQXBpQ29uZmlnPiA9IFRodW5rQXBpQ29uZmlnIGV4dGVuZHMge1xuICBzdGF0ZTogaW5mZXIgU3RhdGU7XG59ID8gU3RhdGUgOiB1bmtub3duO1xudHlwZSBHZXRFeHRyYTxUaHVua0FwaUNvbmZpZz4gPSBUaHVua0FwaUNvbmZpZyBleHRlbmRzIHtcbiAgZXh0cmE6IGluZmVyIEV4dHJhO1xufSA/IEV4dHJhIDogdW5rbm93bjtcbnR5cGUgR2V0RGlzcGF0Y2g8VGh1bmtBcGlDb25maWc+ID0gVGh1bmtBcGlDb25maWcgZXh0ZW5kcyB7XG4gIGRpc3BhdGNoOiBpbmZlciBEaXNwYXRjaDtcbn0gPyBGYWxsYmFja0lmVW5rbm93bjxEaXNwYXRjaCwgVGh1bmtEaXNwYXRjaDxHZXRTdGF0ZTxUaHVua0FwaUNvbmZpZz4sIEdldEV4dHJhPFRodW5rQXBpQ29uZmlnPiwgVW5rbm93bkFjdGlvbj4+IDogVGh1bmtEaXNwYXRjaDxHZXRTdGF0ZTxUaHVua0FwaUNvbmZpZz4sIEdldEV4dHJhPFRodW5rQXBpQ29uZmlnPiwgVW5rbm93bkFjdGlvbj47XG5leHBvcnQgdHlwZSBHZXRUaHVua0FQSTxUaHVua0FwaUNvbmZpZz4gPSBCYXNlVGh1bmtBUEk8R2V0U3RhdGU8VGh1bmtBcGlDb25maWc+LCBHZXRFeHRyYTxUaHVua0FwaUNvbmZpZz4sIEdldERpc3BhdGNoPFRodW5rQXBpQ29uZmlnPiwgR2V0UmVqZWN0VmFsdWU8VGh1bmtBcGlDb25maWc+LCBHZXRSZWplY3RlZE1ldGE8VGh1bmtBcGlDb25maWc+LCBHZXRGdWxmaWxsZWRNZXRhPFRodW5rQXBpQ29uZmlnPj47XG50eXBlIEdldFJlamVjdFZhbHVlPFRodW5rQXBpQ29uZmlnPiA9IFRodW5rQXBpQ29uZmlnIGV4dGVuZHMge1xuICByZWplY3RWYWx1ZTogaW5mZXIgUmVqZWN0VmFsdWU7XG59ID8gUmVqZWN0VmFsdWUgOiB1bmtub3duO1xudHlwZSBHZXRQZW5kaW5nTWV0YTxUaHVua0FwaUNvbmZpZz4gPSBUaHVua0FwaUNvbmZpZyBleHRlbmRzIHtcbiAgcGVuZGluZ01ldGE6IGluZmVyIFBlbmRpbmdNZXRhO1xufSA/IFBlbmRpbmdNZXRhIDogdW5rbm93bjtcbnR5cGUgR2V0RnVsZmlsbGVkTWV0YTxUaHVua0FwaUNvbmZpZz4gPSBUaHVua0FwaUNvbmZpZyBleHRlbmRzIHtcbiAgZnVsZmlsbGVkTWV0YTogaW5mZXIgRnVsZmlsbGVkTWV0YTtcbn0gPyBGdWxmaWxsZWRNZXRhIDogdW5rbm93bjtcbnR5cGUgR2V0UmVqZWN0ZWRNZXRhPFRodW5rQXBpQ29uZmlnPiA9IFRodW5rQXBpQ29uZmlnIGV4dGVuZHMge1xuICByZWplY3RlZE1ldGE6IGluZmVyIFJlamVjdGVkTWV0YTtcbn0gPyBSZWplY3RlZE1ldGEgOiB1bmtub3duO1xudHlwZSBHZXRTZXJpYWxpemVkRXJyb3JUeXBlPFRodW5rQXBpQ29uZmlnPiA9IFRodW5rQXBpQ29uZmlnIGV4dGVuZHMge1xuICBzZXJpYWxpemVkRXJyb3JUeXBlOiBpbmZlciBHZXRTZXJpYWxpemVkRXJyb3JUeXBlO1xufSA/IEdldFNlcmlhbGl6ZWRFcnJvclR5cGUgOiBTZXJpYWxpemVkRXJyb3I7XG50eXBlIE1heWJlUHJvbWlzZTxUPiA9IFQgfCBQcm9taXNlPFQ+IHwgKFQgZXh0ZW5kcyBhbnkgPyBQcm9taXNlPFQ+IDogbmV2ZXIpO1xuXG4vKipcbiAqIEEgdHlwZSBkZXNjcmliaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGBwYXlsb2FkQ3JlYXRvcmAgYXJndW1lbnQgdG8gYGNyZWF0ZUFzeW5jVGh1bmtgLlxuICogTWlnaHQgYmUgdXNlZnVsIGZvciB3cmFwcGluZyBgY3JlYXRlQXN5bmNUaHVua2AgaW4gY3VzdG9tIGFic3RyYWN0aW9ucy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIEFzeW5jVGh1bmtQYXlsb2FkQ3JlYXRvclJldHVyblZhbHVlPFJldHVybmVkLCBUaHVua0FwaUNvbmZpZyBleHRlbmRzIEFzeW5jVGh1bmtDb25maWc+ID0gTWF5YmVQcm9taXNlPElzVW5rbm93bjxHZXRGdWxmaWxsZWRNZXRhPFRodW5rQXBpQ29uZmlnPiwgUmV0dXJuZWQsIEZ1bGZpbGxXaXRoTWV0YTxSZXR1cm5lZCwgR2V0RnVsZmlsbGVkTWV0YTxUaHVua0FwaUNvbmZpZz4+PiB8IFJlamVjdFdpdGhWYWx1ZTxHZXRSZWplY3RWYWx1ZTxUaHVua0FwaUNvbmZpZz4sIEdldFJlamVjdGVkTWV0YTxUaHVua0FwaUNvbmZpZz4+Pjtcbi8qKlxuICogQSB0eXBlIGRlc2NyaWJpbmcgdGhlIGBwYXlsb2FkQ3JlYXRvcmAgYXJndW1lbnQgdG8gYGNyZWF0ZUFzeW5jVGh1bmtgLlxuICogTWlnaHQgYmUgdXNlZnVsIGZvciB3cmFwcGluZyBgY3JlYXRlQXN5bmNUaHVua2AgaW4gY3VzdG9tIGFic3RyYWN0aW9ucy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIEFzeW5jVGh1bmtQYXlsb2FkQ3JlYXRvcjxSZXR1cm5lZCwgVGh1bmtBcmcgPSB2b2lkLCBUaHVua0FwaUNvbmZpZyBleHRlbmRzIEFzeW5jVGh1bmtDb25maWcgPSB7fT4gPSAoYXJnOiBUaHVua0FyZywgdGh1bmtBUEk6IEdldFRodW5rQVBJPFRodW5rQXBpQ29uZmlnPikgPT4gQXN5bmNUaHVua1BheWxvYWRDcmVhdG9yUmV0dXJuVmFsdWU8UmV0dXJuZWQsIFRodW5rQXBpQ29uZmlnPjtcblxuLyoqXG4gKiBBIFRodW5rQWN0aW9uIGNyZWF0ZWQgYnkgYGNyZWF0ZUFzeW5jVGh1bmtgLlxuICogRGlzcGF0Y2hpbmcgaXQgcmV0dXJucyBhIFByb21pc2UgZm9yIGVpdGhlciBhXG4gKiBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQgYWN0aW9uLlxuICogQWxzbywgdGhlIHJldHVybmVkIHZhbHVlIGNvbnRhaW5zIGFuIGBhYm9ydCgpYCBtZXRob2RcbiAqIHRoYXQgYWxsb3dzIHRoZSBhc3luY0FjdGlvbiB0byBiZSBjYW5jZWxsZWQgZnJvbSB0aGUgb3V0c2lkZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIEFzeW5jVGh1bmtBY3Rpb248UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZyBleHRlbmRzIEFzeW5jVGh1bmtDb25maWc+ID0gKGRpc3BhdGNoOiBOb25OdWxsYWJsZTxHZXREaXNwYXRjaDxUaHVua0FwaUNvbmZpZz4+LCBnZXRTdGF0ZTogKCkgPT4gR2V0U3RhdGU8VGh1bmtBcGlDb25maWc+LCBleHRyYTogR2V0RXh0cmE8VGh1bmtBcGlDb25maWc+KSA9PiBTYWZlUHJvbWlzZTxSZXR1cm5UeXBlPEFzeW5jVGh1bmtGdWxmaWxsZWRBY3Rpb25DcmVhdG9yPFJldHVybmVkLCBUaHVua0FyZz4+IHwgUmV0dXJuVHlwZTxBc3luY1RodW5rUmVqZWN0ZWRBY3Rpb25DcmVhdG9yPFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4+PiAmIHtcbiAgYWJvcnQ6IChyZWFzb24/OiBzdHJpbmcpID0+IHZvaWQ7XG4gIHJlcXVlc3RJZDogc3RyaW5nO1xuICBhcmc6IFRodW5rQXJnO1xuICB1bndyYXA6ICgpID0+IFByb21pc2U8UmV0dXJuZWQ+O1xufTtcblxuLyoqXG4gKiBDb25maWcgcHJvdmlkZWQgd2hlbiBjYWxsaW5nIHRoZSBhc3luYyB0aHVuayBhY3Rpb24gY3JlYXRvci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBc3luY1RodW5rRGlzcGF0Y2hDb25maWcge1xuICAvKipcbiAgICogQW4gZXh0ZXJuYWwgYEFib3J0U2lnbmFsYCB0aGF0IHdpbGwgYmUgdHJhY2tlZCBieSB0aGUgaW50ZXJuYWwgYEFib3J0U2lnbmFsYC5cbiAgICovXG4gIHNpZ25hbD86IEFib3J0U2lnbmFsO1xufVxudHlwZSBBc3luY1RodW5rQWN0aW9uQ3JlYXRvcjxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnIGV4dGVuZHMgQXN5bmNUaHVua0NvbmZpZz4gPSBJc0FueTxUaHVua0FyZyxcbi8vIGFueSBoYW5kbGluZ1xuKGFyZzogVGh1bmtBcmcsIGNvbmZpZz86IEFzeW5jVGh1bmtEaXNwYXRjaENvbmZpZykgPT4gQXN5bmNUaHVua0FjdGlvbjxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPixcbi8vIHVua25vd24gaGFuZGxpbmdcbnVua25vd24gZXh0ZW5kcyBUaHVua0FyZyA/IChhcmc6IFRodW5rQXJnLCBjb25maWc/OiBBc3luY1RodW5rRGlzcGF0Y2hDb25maWcpID0+IEFzeW5jVGh1bmtBY3Rpb248UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4gLy8gYXJndW1lbnQgbm90IHNwZWNpZmllZCBvciBzcGVjaWZpZWQgYXMgdm9pZCBvciB1bmRlZmluZWRcbjogW1RodW5rQXJnXSBleHRlbmRzIFt2b2lkXSB8IFt1bmRlZmluZWRdID8gKGFyZz86IHVuZGVmaW5lZCwgY29uZmlnPzogQXN5bmNUaHVua0Rpc3BhdGNoQ29uZmlnKSA9PiBBc3luY1RodW5rQWN0aW9uPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+IC8vIGFyZ3VtZW50IGNvbnRhaW5zIHZvaWRcbjogW3ZvaWRdIGV4dGVuZHMgW1RodW5rQXJnXSAvLyBtYWtlIG9wdGlvbmFsXG4/IChhcmc/OiBUaHVua0FyZywgY29uZmlnPzogQXN5bmNUaHVua0Rpc3BhdGNoQ29uZmlnKSA9PiBBc3luY1RodW5rQWN0aW9uPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+IC8vIGFyZ3VtZW50IGNvbnRhaW5zIHVuZGVmaW5lZFxuOiBbdW5kZWZpbmVkXSBleHRlbmRzIFtUaHVua0FyZ10gPyBXaXRoU3RyaWN0TnVsbENoZWNrczxcbi8vIHdpdGggc3RyaWN0IG51bGxDaGVja3M6IG1ha2Ugb3B0aW9uYWxcbihhcmc/OiBUaHVua0FyZywgY29uZmlnPzogQXN5bmNUaHVua0Rpc3BhdGNoQ29uZmlnKSA9PiBBc3luY1RodW5rQWN0aW9uPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+LFxuLy8gd2l0aG91dCBzdHJpY3QgbnVsbCBjaGVja3MgdGhpcyB3aWxsIG1hdGNoIGV2ZXJ5dGhpbmcsIHNvIGRvbid0IG1ha2UgaXQgb3B0aW9uYWxcbihhcmc6IFRodW5rQXJnLCBjb25maWc/OiBBc3luY1RodW5rRGlzcGF0Y2hDb25maWcpID0+IEFzeW5jVGh1bmtBY3Rpb248UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4+IC8vIGRlZmF1bHQgY2FzZTogbm9ybWFsIGFyZ3VtZW50XG46IChhcmc6IFRodW5rQXJnLCBjb25maWc/OiBBc3luY1RodW5rRGlzcGF0Y2hDb25maWcpID0+IEFzeW5jVGh1bmtBY3Rpb248UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4+O1xuXG4vKipcbiAqIE9wdGlvbnMgb2JqZWN0IGZvciBgY3JlYXRlQXN5bmNUaHVua2AuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBBc3luY1RodW5rT3B0aW9uczxUaHVua0FyZyA9IHZvaWQsIFRodW5rQXBpQ29uZmlnIGV4dGVuZHMgQXN5bmNUaHVua0NvbmZpZyA9IHt9PiA9IHtcbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRvIGNvbnRyb2wgd2hldGhlciB0aGUgYXN5bmNUaHVuayBzaG91bGQgYmUgZXhlY3V0ZWQuIEhhcyBhY2Nlc3MgdG8gdGhlXG4gICAqIGBhcmdgLCBgYXBpLmdldFN0YXRlKClgIGFuZCBgYXBpLmV4dHJhYCBhcmd1bWVudHMuXG4gICAqXG4gICAqIEByZXR1cm5zIGBmYWxzZWAgaWYgaXQgc2hvdWxkIGJlIHNraXBwZWRcbiAgICovXG4gIGNvbmRpdGlvbj8oYXJnOiBUaHVua0FyZywgYXBpOiBQaWNrPEdldFRodW5rQVBJPFRodW5rQXBpQ29uZmlnPiwgJ2dldFN0YXRlJyB8ICdleHRyYSc+KTogTWF5YmVQcm9taXNlPGJvb2xlYW4gfCB1bmRlZmluZWQ+O1xuICAvKipcbiAgICogSWYgYGNvbmRpdGlvbmAgcmV0dXJucyBgZmFsc2VgLCB0aGUgYXN5bmNUaHVuayB3aWxsIGJlIHNraXBwZWQuXG4gICAqIFRoaXMgb3B0aW9uIGFsbG93cyB5b3UgdG8gY29udHJvbCB3aGV0aGVyIGEgYHJlamVjdGVkYCBhY3Rpb24gd2l0aCBgbWV0YS5jb25kaXRpb24gPT0gZmFsc2VgXG4gICAqIHdpbGwgYmUgZGlzcGF0Y2hlZCBvciBub3QuXG4gICAqXG4gICAqIEBkZWZhdWx0IGBmYWxzZWBcbiAgICovXG4gIGRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uPzogYm9vbGVhbjtcbiAgc2VyaWFsaXplRXJyb3I/OiAoeDogdW5rbm93bikgPT4gR2V0U2VyaWFsaXplZEVycm9yVHlwZTxUaHVua0FwaUNvbmZpZz47XG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdG8gdXNlIHdoZW4gZ2VuZXJhdGluZyB0aGUgYHJlcXVlc3RJZGAgZm9yIHRoZSByZXF1ZXN0IHNlcXVlbmNlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgbmFub2lkYFxuICAgKi9cbiAgaWRHZW5lcmF0b3I/OiAoYXJnOiBUaHVua0FyZykgPT4gc3RyaW5nO1xufSAmIElzVW5rbm93bjxHZXRQZW5kaW5nTWV0YTxUaHVua0FwaUNvbmZpZz4sIHtcbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRvIGdlbmVyYXRlIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBiZSBhZGRlZCB0byBgbWV0YWAgb2YgdGhlIHBlbmRpbmcgYWN0aW9uLlxuICAgKlxuICAgKiBVc2luZyB0aGlzIG9wdGlvbmFsIG92ZXJsb2FkIHdpbGwgbm90IG1vZGlmeSB0aGUgdHlwZXMgY29ycmVjdGx5LCB0aGlzIG92ZXJsb2FkIGlzIG9ubHkgaW4gcGxhY2UgdG8gc3VwcG9ydCBKYXZhU2NyaXB0IHVzZXJzLlxuICAgKiBQbGVhc2UgdXNlIHRoZSBgVGh1bmtBcGlDb25maWdgIHBhcmFtZXRlciBgcGVuZGluZ01ldGFgIHRvIGdldCBhY2Nlc3MgdG8gYSBjb3JyZWN0bHkgdHlwZWQgb3ZlcmxvYWRcbiAgICovXG4gIGdldFBlbmRpbmdNZXRhPyhiYXNlOiB7XG4gICAgYXJnOiBUaHVua0FyZztcbiAgICByZXF1ZXN0SWQ6IHN0cmluZztcbiAgfSwgYXBpOiBQaWNrPEdldFRodW5rQVBJPFRodW5rQXBpQ29uZmlnPiwgJ2dldFN0YXRlJyB8ICdleHRyYSc+KTogR2V0UGVuZGluZ01ldGE8VGh1bmtBcGlDb25maWc+O1xufSwge1xuICAvKipcbiAgICogQSBtZXRob2QgdG8gZ2VuZXJhdGUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGJlIGFkZGVkIHRvIGBtZXRhYCBvZiB0aGUgcGVuZGluZyBhY3Rpb24uXG4gICAqL1xuICBnZXRQZW5kaW5nTWV0YShiYXNlOiB7XG4gICAgYXJnOiBUaHVua0FyZztcbiAgICByZXF1ZXN0SWQ6IHN0cmluZztcbiAgfSwgYXBpOiBQaWNrPEdldFRodW5rQVBJPFRodW5rQXBpQ29uZmlnPiwgJ2dldFN0YXRlJyB8ICdleHRyYSc+KTogR2V0UGVuZGluZ01ldGE8VGh1bmtBcGlDb25maWc+O1xufT47XG5leHBvcnQgdHlwZSBBc3luY1RodW5rUGVuZGluZ0FjdGlvbkNyZWF0b3I8VGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnID0ge30+ID0gQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQ8W3N0cmluZywgVGh1bmtBcmcsIEdldFBlbmRpbmdNZXRhPFRodW5rQXBpQ29uZmlnPj9dLCB1bmRlZmluZWQsIHN0cmluZywgbmV2ZXIsIHtcbiAgYXJnOiBUaHVua0FyZztcbiAgcmVxdWVzdElkOiBzdHJpbmc7XG4gIHJlcXVlc3RTdGF0dXM6ICdwZW5kaW5nJztcbn0gJiBHZXRQZW5kaW5nTWV0YTxUaHVua0FwaUNvbmZpZz4+O1xuZXhwb3J0IHR5cGUgQXN5bmNUaHVua1JlamVjdGVkQWN0aW9uQ3JlYXRvcjxUaHVua0FyZywgVGh1bmtBcGlDb25maWcgPSB7fT4gPSBBY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZDxbRXJyb3IgfCBudWxsLCBzdHJpbmcsIFRodW5rQXJnLCBHZXRSZWplY3RWYWx1ZTxUaHVua0FwaUNvbmZpZz4/LCBHZXRSZWplY3RlZE1ldGE8VGh1bmtBcGlDb25maWc+P10sIEdldFJlamVjdFZhbHVlPFRodW5rQXBpQ29uZmlnPiB8IHVuZGVmaW5lZCwgc3RyaW5nLCBHZXRTZXJpYWxpemVkRXJyb3JUeXBlPFRodW5rQXBpQ29uZmlnPiwge1xuICBhcmc6IFRodW5rQXJnO1xuICByZXF1ZXN0SWQ6IHN0cmluZztcbiAgcmVxdWVzdFN0YXR1czogJ3JlamVjdGVkJztcbiAgYWJvcnRlZDogYm9vbGVhbjtcbiAgY29uZGl0aW9uOiBib29sZWFuO1xufSAmICgoe1xuICByZWplY3RlZFdpdGhWYWx1ZTogZmFsc2U7XG59ICYgeyBbSyBpbiBrZXlvZiBHZXRSZWplY3RlZE1ldGE8VGh1bmtBcGlDb25maWc+XT86IHVuZGVmaW5lZCB9KSB8ICh7XG4gIHJlamVjdGVkV2l0aFZhbHVlOiB0cnVlO1xufSAmIEdldFJlamVjdGVkTWV0YTxUaHVua0FwaUNvbmZpZz4pKT47XG5leHBvcnQgdHlwZSBBc3luY1RodW5rRnVsZmlsbGVkQWN0aW9uQ3JlYXRvcjxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnID0ge30+ID0gQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQ8W1JldHVybmVkLCBzdHJpbmcsIFRodW5rQXJnLCBHZXRGdWxmaWxsZWRNZXRhPFRodW5rQXBpQ29uZmlnPj9dLCBSZXR1cm5lZCwgc3RyaW5nLCBuZXZlciwge1xuICBhcmc6IFRodW5rQXJnO1xuICByZXF1ZXN0SWQ6IHN0cmluZztcbiAgcmVxdWVzdFN0YXR1czogJ2Z1bGZpbGxlZCc7XG59ICYgR2V0RnVsZmlsbGVkTWV0YTxUaHVua0FwaUNvbmZpZz4+O1xuXG4vKipcbiAqIEEgdHlwZSBkZXNjcmliaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgYGNyZWF0ZUFzeW5jVGh1bmtgLlxuICogTWlnaHQgYmUgdXNlZnVsIGZvciB3cmFwcGluZyBgY3JlYXRlQXN5bmNUaHVua2AgaW4gY3VzdG9tIGFic3RyYWN0aW9ucy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIEFzeW5jVGh1bms8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZyBleHRlbmRzIEFzeW5jVGh1bmtDb25maWc+ID0gQXN5bmNUaHVua0FjdGlvbkNyZWF0b3I8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4gJiB7XG4gIHBlbmRpbmc6IEFzeW5jVGh1bmtQZW5kaW5nQWN0aW9uQ3JlYXRvcjxUaHVua0FyZywgVGh1bmtBcGlDb25maWc+O1xuICByZWplY3RlZDogQXN5bmNUaHVua1JlamVjdGVkQWN0aW9uQ3JlYXRvcjxUaHVua0FyZywgVGh1bmtBcGlDb25maWc+O1xuICBmdWxmaWxsZWQ6IEFzeW5jVGh1bmtGdWxmaWxsZWRBY3Rpb25DcmVhdG9yPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+O1xuICAvLyBtYXRjaFNldHRsZWQ/XG4gIHNldHRsZWQ6IChhY3Rpb246IGFueSkgPT4gYWN0aW9uIGlzIFJldHVyblR5cGU8QXN5bmNUaHVua1JlamVjdGVkQWN0aW9uQ3JlYXRvcjxUaHVua0FyZywgVGh1bmtBcGlDb25maWc+IHwgQXN5bmNUaHVua0Z1bGZpbGxlZEFjdGlvbkNyZWF0b3I8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4+O1xuICB0eXBlUHJlZml4OiBzdHJpbmc7XG59O1xuZXhwb3J0IHR5cGUgT3ZlcnJpZGVUaHVua0FwaUNvbmZpZ3M8T2xkQ29uZmlnLCBOZXdDb25maWc+ID0gSWQ8TmV3Q29uZmlnICYgT21pdDxPbGRDb25maWcsIGtleW9mIE5ld0NvbmZpZz4+O1xuZXhwb3J0IHR5cGUgQ3JlYXRlQXN5bmNUaHVua0Z1bmN0aW9uPEN1cnJpZWRUaHVua0FwaUNvbmZpZyBleHRlbmRzIEFzeW5jVGh1bmtDb25maWc+ID0ge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHR5cGVQcmVmaXhcbiAgICogQHBhcmFtIHBheWxvYWRDcmVhdG9yXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIC8vIHNlcGFyYXRlIHNpZ25hdHVyZSB3aXRob3V0IGBBc3luY1RodW5rQ29uZmlnYCBmb3IgYmV0dGVyIGluZmVyZW5jZVxuICA8UmV0dXJuZWQsIFRodW5rQXJnID0gdm9pZD4odHlwZVByZWZpeDogc3RyaW5nLCBwYXlsb2FkQ3JlYXRvcjogQXN5bmNUaHVua1BheWxvYWRDcmVhdG9yPFJldHVybmVkLCBUaHVua0FyZywgQ3VycmllZFRodW5rQXBpQ29uZmlnPiwgb3B0aW9ucz86IEFzeW5jVGh1bmtPcHRpb25zPFRodW5rQXJnLCBDdXJyaWVkVGh1bmtBcGlDb25maWc+KTogQXN5bmNUaHVuazxSZXR1cm5lZCwgVGh1bmtBcmcsIEN1cnJpZWRUaHVua0FwaUNvbmZpZz47XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlUHJlZml4XG4gICAqIEBwYXJhbSBwYXlsb2FkQ3JlYXRvclxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICA8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZyBleHRlbmRzIEFzeW5jVGh1bmtDb25maWc+KHR5cGVQcmVmaXg6IHN0cmluZywgcGF5bG9hZENyZWF0b3I6IEFzeW5jVGh1bmtQYXlsb2FkQ3JlYXRvcjxSZXR1cm5lZCwgVGh1bmtBcmcsIE92ZXJyaWRlVGh1bmtBcGlDb25maWdzPEN1cnJpZWRUaHVua0FwaUNvbmZpZywgVGh1bmtBcGlDb25maWc+Piwgb3B0aW9ucz86IEFzeW5jVGh1bmtPcHRpb25zPFRodW5rQXJnLCBPdmVycmlkZVRodW5rQXBpQ29uZmlnczxDdXJyaWVkVGh1bmtBcGlDb25maWcsIFRodW5rQXBpQ29uZmlnPj4pOiBBc3luY1RodW5rPFJldHVybmVkLCBUaHVua0FyZywgT3ZlcnJpZGVUaHVua0FwaUNvbmZpZ3M8Q3VycmllZFRodW5rQXBpQ29uZmlnLCBUaHVua0FwaUNvbmZpZz4+O1xufTtcbnR5cGUgQ3JlYXRlQXN5bmNUaHVuazxDdXJyaWVkVGh1bmtBcGlDb25maWcgZXh0ZW5kcyBBc3luY1RodW5rQ29uZmlnPiA9IENyZWF0ZUFzeW5jVGh1bmtGdW5jdGlvbjxDdXJyaWVkVGh1bmtBcGlDb25maWc+ICYge1xuICB3aXRoVHlwZXM8VGh1bmtBcGlDb25maWcgZXh0ZW5kcyBBc3luY1RodW5rQ29uZmlnPigpOiBDcmVhdGVBc3luY1RodW5rPE92ZXJyaWRlVGh1bmtBcGlDb25maWdzPEN1cnJpZWRUaHVua0FwaUNvbmZpZywgVGh1bmtBcGlDb25maWc+Pjtcbn07XG5jb25zdCBleHRlcm5hbEFib3J0TWVzc2FnZSA9ICdFeHRlcm5hbCBzaWduYWwgd2FzIGFib3J0ZWQnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUFzeW5jVGh1bmsgPSAvKiBAX19QVVJFX18gKi8oKCkgPT4ge1xuICBmdW5jdGlvbiBjcmVhdGVBc3luY1RodW5rPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWcgZXh0ZW5kcyBBc3luY1RodW5rQ29uZmlnPih0eXBlUHJlZml4OiBzdHJpbmcsIHBheWxvYWRDcmVhdG9yOiBBc3luY1RodW5rUGF5bG9hZENyZWF0b3I8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4sIG9wdGlvbnM/OiBBc3luY1RodW5rT3B0aW9uczxUaHVua0FyZywgVGh1bmtBcGlDb25maWc+KTogQXN5bmNUaHVuazxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPiB7XG4gICAgdHlwZSBSZWplY3RlZFZhbHVlID0gR2V0UmVqZWN0VmFsdWU8VGh1bmtBcGlDb25maWc+O1xuICAgIHR5cGUgUGVuZGluZ01ldGEgPSBHZXRQZW5kaW5nTWV0YTxUaHVua0FwaUNvbmZpZz47XG4gICAgdHlwZSBGdWxmaWxsZWRNZXRhID0gR2V0RnVsZmlsbGVkTWV0YTxUaHVua0FwaUNvbmZpZz47XG4gICAgdHlwZSBSZWplY3RlZE1ldGEgPSBHZXRSZWplY3RlZE1ldGE8VGh1bmtBcGlDb25maWc+O1xuICAgIGNvbnN0IGZ1bGZpbGxlZDogQXN5bmNUaHVua0Z1bGZpbGxlZEFjdGlvbkNyZWF0b3I8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4gPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArICcvZnVsZmlsbGVkJywgKHBheWxvYWQ6IFJldHVybmVkLCByZXF1ZXN0SWQ6IHN0cmluZywgYXJnOiBUaHVua0FyZywgbWV0YT86IEZ1bGZpbGxlZE1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi4obWV0YSBhcyBhbnkgfHwge30pLFxuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogJ2Z1bGZpbGxlZCcgYXMgY29uc3RcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcGVuZGluZzogQXN5bmNUaHVua1BlbmRpbmdBY3Rpb25DcmVhdG9yPFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4gPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArICcvcGVuZGluZycsIChyZXF1ZXN0SWQ6IHN0cmluZywgYXJnOiBUaHVua0FyZywgbWV0YT86IFBlbmRpbmdNZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZDogdW5kZWZpbmVkLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi4obWV0YSBhcyBhbnkgfHwge30pLFxuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogJ3BlbmRpbmcnIGFzIGNvbnN0XG4gICAgICB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHJlamVjdGVkOiBBc3luY1RodW5rUmVqZWN0ZWRBY3Rpb25DcmVhdG9yPFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4gPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArICcvcmVqZWN0ZWQnLCAoZXJyb3I6IEVycm9yIHwgbnVsbCwgcmVxdWVzdElkOiBzdHJpbmcsIGFyZzogVGh1bmtBcmcsIHBheWxvYWQ/OiBSZWplY3RlZFZhbHVlLCBtZXRhPzogUmVqZWN0ZWRNZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZCxcbiAgICAgIGVycm9yOiAob3B0aW9ucyAmJiBvcHRpb25zLnNlcmlhbGl6ZUVycm9yIHx8IG1pbmlTZXJpYWxpemVFcnJvcikoZXJyb3IgfHwgJ1JlamVjdGVkJykgYXMgR2V0U2VyaWFsaXplZEVycm9yVHlwZTxUaHVua0FwaUNvbmZpZz4sXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLihtZXRhIGFzIGFueSB8fCB7fSksXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZWplY3RlZFdpdGhWYWx1ZTogISFwYXlsb2FkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiAncmVqZWN0ZWQnIGFzIGNvbnN0LFxuICAgICAgICBhYm9ydGVkOiBlcnJvcj8ubmFtZSA9PT0gJ0Fib3J0RXJyb3InLFxuICAgICAgICBjb25kaXRpb246IGVycm9yPy5uYW1lID09PSAnQ29uZGl0aW9uRXJyb3InXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoYXJnOiBUaHVua0FyZywge1xuICAgICAgc2lnbmFsXG4gICAgfTogQXN5bmNUaHVua0Rpc3BhdGNoQ29uZmlnID0ge30pOiBBc3luY1RodW5rQWN0aW9uPFJldHVybmVkLCBUaHVua0FyZywgUmVxdWlyZWQ8VGh1bmtBcGlDb25maWc+PiB7XG4gICAgICByZXR1cm4gKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmEpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gb3B0aW9ucz8uaWRHZW5lcmF0b3IgPyBvcHRpb25zLmlkR2VuZXJhdG9yKGFyZykgOiBuYW5vaWQoKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBsZXQgYWJvcnRIYW5kbGVyOiAoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBhYm9ydFJlYXNvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgICBmdW5jdGlvbiBhYm9ydChyZWFzb24/OiBzdHJpbmcpIHtcbiAgICAgICAgICBhYm9ydFJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBhYm9ydChleHRlcm5hbEFib3J0TWVzc2FnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IGFib3J0KGV4dGVybmFsQWJvcnRNZXNzYWdlKSwge1xuICAgICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBsZXQgZmluYWxBY3Rpb246IFJldHVyblR5cGU8dHlwZW9mIGZ1bGZpbGxlZCB8IHR5cGVvZiByZWplY3RlZD47XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjb25kaXRpb25SZXN1bHQgPSBvcHRpb25zPy5jb25kaXRpb24/LihhcmcsIHtcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc1RoZW5hYmxlKGNvbmRpdGlvblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gYXdhaXQgY29uZGl0aW9uUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJlc3VsdCA9PT0gZmFsc2UgfHwgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnQ29uZGl0aW9uRXJyb3InLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdBYm9ydGVkIGR1ZSB0byBjb25kaXRpb24gY2FsbGJhY2sgcmV0dXJuaW5nIGZhbHNlLidcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFib3J0ZWRQcm9taXNlID0gbmV3IFByb21pc2U8bmV2ZXI+KChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiAnQWJvcnRFcnJvcicsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBhYm9ydFJlYXNvbiB8fCAnQWJvcnRlZCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHBlbmRpbmcocmVxdWVzdElkLCBhcmcsIG9wdGlvbnM/LmdldFBlbmRpbmdNZXRhPy4oe1xuICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgZXh0cmFcbiAgICAgICAgICAgIH0pKSBhcyBhbnkpO1xuICAgICAgICAgICAgZmluYWxBY3Rpb24gPSBhd2FpdCBQcm9taXNlLnJhY2UoW2Fib3J0ZWRQcm9taXNlLCBQcm9taXNlLnJlc29sdmUocGF5bG9hZENyZWF0b3IoYXJnLCB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoLFxuICAgICAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICAgICAgcmVqZWN0V2l0aFZhbHVlOiAoKHZhbHVlOiBSZWplY3RlZFZhbHVlLCBtZXRhPzogUmVqZWN0ZWRNZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWplY3RXaXRoVmFsdWUodmFsdWUsIG1ldGEpO1xuICAgICAgICAgICAgICB9KSBhcyBhbnksXG4gICAgICAgICAgICAgIGZ1bGZpbGxXaXRoVmFsdWU6ICgodmFsdWU6IHVua25vd24sIG1ldGE/OiBGdWxmaWxsZWRNZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdWxmaWxsV2l0aE1ldGEodmFsdWUsIG1ldGEpO1xuICAgICAgICAgICAgICB9KSBhcyBhbnlcbiAgICAgICAgICAgIH0pKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZ1bGZpbGxXaXRoTWV0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LnBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCByZXN1bHQubWV0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZChyZXN1bHQgYXMgYW55LCByZXF1ZXN0SWQsIGFyZyk7XG4gICAgICAgICAgICB9KV0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZmluYWxBY3Rpb24gPSBlcnIgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUgPyByZWplY3RlZChudWxsLCByZXF1ZXN0SWQsIGFyZywgZXJyLnBheWxvYWQsIGVyci5tZXRhKSA6IHJlamVjdGVkKGVyciBhcyBhbnksIHJlcXVlc3RJZCwgYXJnKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGFib3J0SGFuZGxlcikge1xuICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gV2UgZGlzcGF0Y2ggdGhlIHJlc3VsdCBhY3Rpb24gX2FmdGVyXyB0aGUgY2F0Y2gsIHRvIGF2b2lkIGhhdmluZyBhbnkgZXJyb3JzXG4gICAgICAgICAgLy8gaGVyZSBnZXQgc3dhbGxvd2VkIGJ5IHRoZSB0cnkvY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gcGVyIGh0dHBzOi8vdHdpdHRlci5jb20vZGFuX2FicmFtb3Yvc3RhdHVzLzc3MDkxNDIyMTYzODk0MjcyMFxuICAgICAgICAgIC8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vcmVkdXhqcy9yZWR1eC10b29sa2l0L2Jsb2IvZTg1ZWIxN2IzOWEyMTE4ZDg1OWY3Yjc3NDZlMGYzZmVlNTIzZTA4OS9kb2NzL3R1dG9yaWFscy9hZHZhbmNlZC10dXRvcmlhbC5tZCNhc3luYy1lcnJvci1oYW5kbGluZy1sb2dpYy1pbi10aHVua3NcblxuICAgICAgICAgIGNvbnN0IHNraXBEaXNwYXRjaCA9IG9wdGlvbnMgJiYgIW9wdGlvbnMuZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24gJiYgcmVqZWN0ZWQubWF0Y2goZmluYWxBY3Rpb24pICYmIChmaW5hbEFjdGlvbiBhcyBhbnkpLm1ldGEuY29uZGl0aW9uO1xuICAgICAgICAgIGlmICghc2tpcERpc3BhdGNoKSB7XG4gICAgICAgICAgICBkaXNwYXRjaChmaW5hbEFjdGlvbiBhcyBhbnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmluYWxBY3Rpb247XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvbWlzZSBhcyBTYWZlUHJvbWlzZTxhbnk+LCB7XG4gICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIGFyZyxcbiAgICAgICAgICB1bndyYXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuPGFueT4odW53cmFwUmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWN0aW9uQ3JlYXRvciBhcyBBc3luY1RodW5rQWN0aW9uQ3JlYXRvcjxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPiwge1xuICAgICAgcGVuZGluZyxcbiAgICAgIHJlamVjdGVkLFxuICAgICAgZnVsZmlsbGVkLFxuICAgICAgc2V0dGxlZDogaXNBbnlPZihyZWplY3RlZCwgZnVsZmlsbGVkKSxcbiAgICAgIHR5cGVQcmVmaXhcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVBc3luY1RodW5rLndpdGhUeXBlcyA9ICgpID0+IGNyZWF0ZUFzeW5jVGh1bms7XG4gIHJldHVybiBjcmVhdGVBc3luY1RodW5rIGFzIENyZWF0ZUFzeW5jVGh1bms8QXN5bmNUaHVua0NvbmZpZz47XG59KSgpO1xuaW50ZXJmYWNlIFVud3JhcHBhYmxlQWN0aW9uIHtcbiAgcGF5bG9hZDogYW55O1xuICBtZXRhPzogYW55O1xuICBlcnJvcj86IGFueTtcbn1cbnR5cGUgVW53cmFwcGVkQWN0aW9uUGF5bG9hZDxUIGV4dGVuZHMgVW53cmFwcGFibGVBY3Rpb24+ID0gRXhjbHVkZTxULCB7XG4gIGVycm9yOiBhbnk7XG59PlsncGF5bG9hZCddO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcFJlc3VsdDxSIGV4dGVuZHMgVW53cmFwcGFibGVBY3Rpb24+KGFjdGlvbjogUik6IFVud3JhcHBlZEFjdGlvblBheWxvYWQ8Uj4ge1xuICBpZiAoYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWUpIHtcbiAgICB0aHJvdyBhY3Rpb24ucGF5bG9hZDtcbiAgfVxuICBpZiAoYWN0aW9uLmVycm9yKSB7XG4gICAgdGhyb3cgYWN0aW9uLmVycm9yO1xuICB9XG4gIHJldHVybiBhY3Rpb24ucGF5bG9hZDtcbn1cbnR5cGUgV2l0aFN0cmljdE51bGxDaGVja3M8VHJ1ZSwgRmFsc2U+ID0gdW5kZWZpbmVkIGV4dGVuZHMgYm9vbGVhbiA/IEZhbHNlIDogVHJ1ZTtcbmZ1bmN0aW9uIGlzVGhlbmFibGUodmFsdWU6IGFueSk6IHZhbHVlIGlzIFByb21pc2VMaWtlPGFueT4ge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn0iLCJpbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLCBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiwgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMsIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U0LCBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNSwgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTYsIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U3LCBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlOCB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgdHlwZSB7IEFjdGlvbiwgUmVkdWNlciwgVW5rbm93bkFjdGlvbiB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB0eXBlIHsgU2VsZWN0b3IgfSBmcm9tICdyZXNlbGVjdCc7XG5pbXBvcnQgdHlwZSB7IEluamVjdENvbmZpZyB9IGZyb20gJy4vY29tYmluZVNsaWNlcyc7XG5pbXBvcnQgdHlwZSB7IEFjdGlvbkNyZWF0b3JXaXRob3V0UGF5bG9hZCwgUGF5bG9hZEFjdGlvbiwgUGF5bG9hZEFjdGlvbkNyZWF0b3IsIFByZXBhcmVBY3Rpb24sIF9BY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZCB9IGZyb20gJy4vY3JlYXRlQWN0aW9uJztcbmltcG9ydCB7IGNyZWF0ZUFjdGlvbiB9IGZyb20gJy4vY3JlYXRlQWN0aW9uJztcbmltcG9ydCB0eXBlIHsgQXN5bmNUaHVuaywgQXN5bmNUaHVua0NvbmZpZywgQXN5bmNUaHVua09wdGlvbnMsIEFzeW5jVGh1bmtQYXlsb2FkQ3JlYXRvciwgT3ZlcnJpZGVUaHVua0FwaUNvbmZpZ3MgfSBmcm9tICcuL2NyZWF0ZUFzeW5jVGh1bmsnO1xuaW1wb3J0IHsgY3JlYXRlQXN5bmNUaHVuayBhcyBfY3JlYXRlQXN5bmNUaHVuayB9IGZyb20gJy4vY3JlYXRlQXN5bmNUaHVuayc7XG5pbXBvcnQgdHlwZSB7IEFjdGlvbk1hdGNoZXJEZXNjcmlwdGlvbkNvbGxlY3Rpb24sIENhc2VSZWR1Y2VyLCBSZWR1Y2VyV2l0aEluaXRpYWxTdGF0ZSB9IGZyb20gJy4vY3JlYXRlUmVkdWNlcic7XG5pbXBvcnQgeyBjcmVhdGVSZWR1Y2VyIH0gZnJvbSAnLi9jcmVhdGVSZWR1Y2VyJztcbmltcG9ydCB0eXBlIHsgQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXIsIFR5cGVkQWN0aW9uQ3JlYXRvciB9IGZyb20gJy4vbWFwQnVpbGRlcnMnO1xuaW1wb3J0IHsgZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sgfSBmcm9tICcuL21hcEJ1aWxkZXJzJztcbmltcG9ydCB0eXBlIHsgSWQsIFR5cGVHdWFyZCB9IGZyb20gJy4vdHNIZWxwZXJzJztcbmltcG9ydCB7IGdldE9ySW5zZXJ0Q29tcHV0ZWQgfSBmcm9tICcuL3V0aWxzJztcbmNvbnN0IGFzeW5jVGh1bmtTeW1ib2wgPSAvKiBAX19QVVJFX18gKi9TeW1ib2wuZm9yKCdydGstc2xpY2UtY3JlYXRlYXN5bmN0aHVuaycpO1xuLy8gdHlwZSBpcyBhbm5vdGF0ZWQgYmVjYXVzZSBpdCdzIHRvbyBsb25nIHRvIGluZmVyXG5leHBvcnQgY29uc3QgYXN5bmNUaHVua0NyZWF0b3I6IHtcbiAgW2FzeW5jVGh1bmtTeW1ib2xdOiB0eXBlb2YgX2NyZWF0ZUFzeW5jVGh1bms7XG59ID0ge1xuICBbYXN5bmNUaHVua1N5bWJvbF06IF9jcmVhdGVBc3luY1RodW5rXG59O1xudHlwZSBJbmplY3RJbnRvQ29uZmlnPE5ld1JlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nPiA9IEluamVjdENvbmZpZyAmIHtcbiAgcmVkdWNlclBhdGg/OiBOZXdSZWR1Y2VyUGF0aDtcbn07XG5cbi8qKlxuICogVGhlIHJldHVybiB2YWx1ZSBvZiBgY3JlYXRlU2xpY2VgXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFNsaWNlPFN0YXRlID0gYW55LCBDYXNlUmVkdWNlcnMgZXh0ZW5kcyBTbGljZUNhc2VSZWR1Y2VyczxTdGF0ZT4gPSBTbGljZUNhc2VSZWR1Y2VyczxTdGF0ZT4sIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gTmFtZSwgU2VsZWN0b3JzIGV4dGVuZHMgU2xpY2VTZWxlY3RvcnM8U3RhdGU+ID0gU2xpY2VTZWxlY3RvcnM8U3RhdGU+PiB7XG4gIC8qKlxuICAgKiBUaGUgc2xpY2UgbmFtZS5cbiAgICovXG4gIG5hbWU6IE5hbWU7XG5cbiAgLyoqXG4gICAqICBUaGUgc2xpY2UgcmVkdWNlciBwYXRoLlxuICAgKi9cbiAgcmVkdWNlclBhdGg6IFJlZHVjZXJQYXRoO1xuXG4gIC8qKlxuICAgKiBUaGUgc2xpY2UncyByZWR1Y2VyLlxuICAgKi9cbiAgcmVkdWNlcjogUmVkdWNlcjxTdGF0ZT47XG5cbiAgLyoqXG4gICAqIEFjdGlvbiBjcmVhdG9ycyBmb3IgdGhlIHR5cGVzIG9mIGFjdGlvbnMgdGhhdCBhcmUgaGFuZGxlZCBieSB0aGUgc2xpY2VcbiAgICogcmVkdWNlci5cbiAgICovXG4gIGFjdGlvbnM6IENhc2VSZWR1Y2VyQWN0aW9uczxDYXNlUmVkdWNlcnMsIE5hbWU+O1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kaXZpZHVhbCBjYXNlIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgd2VyZSBwYXNzZWQgaW4gdGhlIGByZWR1Y2Vyc2AgcGFyYW1ldGVyLlxuICAgKiBUaGlzIGVuYWJsZXMgcmV1c2UgYW5kIHRlc3RpbmcgaWYgdGhleSB3ZXJlIGRlZmluZWQgaW5saW5lIHdoZW4gY2FsbGluZyBgY3JlYXRlU2xpY2VgLlxuICAgKi9cbiAgY2FzZVJlZHVjZXJzOiBTbGljZURlZmluZWRDYXNlUmVkdWNlcnM8Q2FzZVJlZHVjZXJzPjtcblxuICAvKipcbiAgICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBpbml0aWFsIHN0YXRlIHZhbHVlIGdpdmVuIHRvIHRoZSBzbGljZS5cbiAgICogSWYgYSBsYXp5IHN0YXRlIGluaXRpYWxpemVyIHdhcyBwcm92aWRlZCwgaXQgd2lsbCBiZSBjYWxsZWQgYW5kIGEgZnJlc2ggdmFsdWUgcmV0dXJuZWQuXG4gICAqL1xuICBnZXRJbml0aWFsU3RhdGU6ICgpID0+IFN0YXRlO1xuXG4gIC8qKlxuICAgKiBHZXQgbG9jYWxpc2VkIHNsaWNlIHNlbGVjdG9ycyAoZXhwZWN0cyB0byBiZSBjYWxsZWQgd2l0aCAqanVzdCogdGhlIHNsaWNlJ3Mgc3RhdGUgYXMgdGhlIGZpcnN0IHBhcmFtZXRlcilcbiAgICovXG4gIGdldFNlbGVjdG9ycygpOiBJZDxTbGljZURlZmluZWRTZWxlY3RvcnM8U3RhdGUsIFNlbGVjdG9ycywgU3RhdGU+PjtcblxuICAvKipcbiAgICogR2V0IGdsb2JhbGlzZWQgc2xpY2Ugc2VsZWN0b3JzIChgc2VsZWN0U3RhdGVgIGNhbGxiYWNrIGlzIGV4cGVjdGVkIHRvIHJlY2VpdmUgZmlyc3QgcGFyYW1ldGVyIGFuZCByZXR1cm4gc2xpY2Ugc3RhdGUpXG4gICAqL1xuICBnZXRTZWxlY3RvcnM8Um9vdFN0YXRlPihzZWxlY3RTdGF0ZTogKHJvb3RTdGF0ZTogUm9vdFN0YXRlKSA9PiBTdGF0ZSk6IElkPFNsaWNlRGVmaW5lZFNlbGVjdG9yczxTdGF0ZSwgU2VsZWN0b3JzLCBSb290U3RhdGU+PjtcblxuICAvKipcbiAgICogU2VsZWN0b3JzIHRoYXQgYXNzdW1lIHRoZSBzbGljZSdzIHN0YXRlIGlzIGByb290U3RhdGVbc2xpY2UucmVkdWNlclBhdGhdYCAod2hpY2ggaXMgdXN1YWxseSB0aGUgY2FzZSlcbiAgICpcbiAgICogRXF1aXZhbGVudCB0byBgc2xpY2UuZ2V0U2VsZWN0b3JzKChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZVtzbGljZS5yZWR1Y2VyUGF0aF0pYC5cbiAgICovXG4gIGdldCBzZWxlY3RvcnMoKTogSWQ8U2xpY2VEZWZpbmVkU2VsZWN0b3JzPFN0YXRlLCBTZWxlY3RvcnMsIHsgW0sgaW4gUmVkdWNlclBhdGhdOiBTdGF0ZSB9Pj47XG5cbiAgLyoqXG4gICAqIEluamVjdCBzbGljZSBpbnRvIHByb3ZpZGVkIHJlZHVjZXIgKHJldHVybiB2YWx1ZSBmcm9tIGBjb21iaW5lU2xpY2VzYCksIGFuZCByZXR1cm4gaW5qZWN0ZWQgc2xpY2UuXG4gICAqL1xuICBpbmplY3RJbnRvPE5ld1JlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gUmVkdWNlclBhdGg+KHRoaXM6IHRoaXMsIGluamVjdGFibGU6IHtcbiAgICBpbmplY3Q6IChzbGljZToge1xuICAgICAgcmVkdWNlclBhdGg6IHN0cmluZztcbiAgICAgIHJlZHVjZXI6IFJlZHVjZXI7XG4gICAgfSwgY29uZmlnPzogSW5qZWN0Q29uZmlnKSA9PiB2b2lkO1xuICB9LCBjb25maWc/OiBJbmplY3RJbnRvQ29uZmlnPE5ld1JlZHVjZXJQYXRoPik6IEluamVjdGVkU2xpY2U8U3RhdGUsIENhc2VSZWR1Y2VycywgTmFtZSwgTmV3UmVkdWNlclBhdGgsIFNlbGVjdG9ycz47XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB0aGUgc2xpY2Ugc3RhdGUsIHVzaW5nIHRoZSBzbGljZSdzIGN1cnJlbnQgcmVkdWNlclBhdGguXG4gICAqXG4gICAqIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgc2xpY2UgaXMgbm90IGZvdW5kLlxuICAgKi9cbiAgc2VsZWN0U2xpY2Uoc3RhdGU6IHsgW0sgaW4gUmVkdWNlclBhdGhdOiBTdGF0ZSB9KTogU3RhdGU7XG59XG5cbi8qKlxuICogQSBzbGljZSBhZnRlciBiZWluZyBjYWxsZWQgd2l0aCBgaW5qZWN0SW50byhyZWR1Y2VyKWAuXG4gKlxuICogU2VsZWN0b3JzIGNhbiBub3cgYmUgY2FsbGVkIHdpdGggYW4gYHVuZGVmaW5lZGAgdmFsdWUsIGluIHdoaWNoIGNhc2UgdGhleSB1c2UgdGhlIHNsaWNlJ3MgaW5pdGlhbCBzdGF0ZS5cbiAqL1xudHlwZSBJbmplY3RlZFNsaWNlPFN0YXRlID0gYW55LCBDYXNlUmVkdWNlcnMgZXh0ZW5kcyBTbGljZUNhc2VSZWR1Y2VyczxTdGF0ZT4gPSBTbGljZUNhc2VSZWR1Y2VyczxTdGF0ZT4sIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gTmFtZSwgU2VsZWN0b3JzIGV4dGVuZHMgU2xpY2VTZWxlY3RvcnM8U3RhdGU+ID0gU2xpY2VTZWxlY3RvcnM8U3RhdGU+PiA9IE9taXQ8U2xpY2U8U3RhdGUsIENhc2VSZWR1Y2VycywgTmFtZSwgUmVkdWNlclBhdGgsIFNlbGVjdG9ycz4sICdnZXRTZWxlY3RvcnMnIHwgJ3NlbGVjdG9ycyc+ICYge1xuICAvKipcbiAgICogR2V0IGxvY2FsaXNlZCBzbGljZSBzZWxlY3RvcnMgKGV4cGVjdHMgdG8gYmUgY2FsbGVkIHdpdGggKmp1c3QqIHRoZSBzbGljZSdzIHN0YXRlIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIpXG4gICAqL1xuICBnZXRTZWxlY3RvcnMoKTogSWQ8U2xpY2VEZWZpbmVkU2VsZWN0b3JzPFN0YXRlLCBTZWxlY3RvcnMsIFN0YXRlIHwgdW5kZWZpbmVkPj47XG5cbiAgLyoqXG4gICAqIEdldCBnbG9iYWxpc2VkIHNsaWNlIHNlbGVjdG9ycyAoYHNlbGVjdFN0YXRlYCBjYWxsYmFjayBpcyBleHBlY3RlZCB0byByZWNlaXZlIGZpcnN0IHBhcmFtZXRlciBhbmQgcmV0dXJuIHNsaWNlIHN0YXRlKVxuICAgKi9cbiAgZ2V0U2VsZWN0b3JzPFJvb3RTdGF0ZT4oc2VsZWN0U3RhdGU6IChyb290U3RhdGU6IFJvb3RTdGF0ZSkgPT4gU3RhdGUgfCB1bmRlZmluZWQpOiBJZDxTbGljZURlZmluZWRTZWxlY3RvcnM8U3RhdGUsIFNlbGVjdG9ycywgUm9vdFN0YXRlPj47XG5cbiAgLyoqXG4gICAqIFNlbGVjdG9ycyB0aGF0IGFzc3VtZSB0aGUgc2xpY2UncyBzdGF0ZSBpcyBgcm9vdFN0YXRlW3NsaWNlLm5hbWVdYCAod2hpY2ggaXMgdXN1YWxseSB0aGUgY2FzZSlcbiAgICpcbiAgICogRXF1aXZhbGVudCB0byBgc2xpY2UuZ2V0U2VsZWN0b3JzKChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZVtzbGljZS5uYW1lXSlgLlxuICAgKi9cbiAgZ2V0IHNlbGVjdG9ycygpOiBJZDxTbGljZURlZmluZWRTZWxlY3RvcnM8U3RhdGUsIFNlbGVjdG9ycywgeyBbSyBpbiBSZWR1Y2VyUGF0aF0/OiBTdGF0ZSB8IHVuZGVmaW5lZCB9Pj47XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB0aGUgc2xpY2Ugc3RhdGUsIHVzaW5nIHRoZSBzbGljZSdzIGN1cnJlbnQgcmVkdWNlclBhdGguXG4gICAqXG4gICAqIFJldHVybnMgaW5pdGlhbCBzdGF0ZSBpZiBzbGljZSBpcyBub3QgZm91bmQuXG4gICAqL1xuICBzZWxlY3RTbGljZShzdGF0ZTogeyBbSyBpbiBSZWR1Y2VyUGF0aF0/OiBTdGF0ZSB8IHVuZGVmaW5lZCB9KTogU3RhdGU7XG59O1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGBjcmVhdGVTbGljZSgpYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlU2xpY2VPcHRpb25zPFN0YXRlID0gYW55LCBDUiBleHRlbmRzIFNsaWNlQ2FzZVJlZHVjZXJzPFN0YXRlPiA9IFNsaWNlQ2FzZVJlZHVjZXJzPFN0YXRlPiwgTmFtZSBleHRlbmRzIHN0cmluZyA9IHN0cmluZywgUmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcgPSBOYW1lLCBTZWxlY3RvcnMgZXh0ZW5kcyBTbGljZVNlbGVjdG9yczxTdGF0ZT4gPSBTbGljZVNlbGVjdG9yczxTdGF0ZT4+IHtcbiAgLyoqXG4gICAqIFRoZSBzbGljZSdzIG5hbWUuIFVzZWQgdG8gbmFtZXNwYWNlIHRoZSBnZW5lcmF0ZWQgYWN0aW9uIHR5cGVzLlxuICAgKi9cbiAgbmFtZTogTmFtZTtcblxuICAvKipcbiAgICogVGhlIHNsaWNlJ3MgcmVkdWNlciBwYXRoLiBVc2VkIHdoZW4gaW5qZWN0aW5nIGludG8gYSBjb21iaW5lZCBzbGljZSByZWR1Y2VyLlxuICAgKi9cbiAgcmVkdWNlclBhdGg/OiBSZWR1Y2VyUGF0aDtcblxuICAvKipcbiAgICogVGhlIGluaXRpYWwgc3RhdGUgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSByZWR1Y2VyIGlzIGNhbGxlZCB0aGUgZmlyc3QgdGltZS4gVGhpcyBtYXkgYWxzbyBiZSBhIFwibGF6eSBpbml0aWFsaXplclwiIGZ1bmN0aW9uLCB3aGljaCBzaG91bGQgcmV0dXJuIGFuIGluaXRpYWwgc3RhdGUgdmFsdWUgd2hlbiBjYWxsZWQuIFRoaXMgd2lsbCBiZSB1c2VkIHdoZW5ldmVyIHRoZSByZWR1Y2VyIGlzIGNhbGxlZCB3aXRoIGB1bmRlZmluZWRgIGFzIGl0cyBzdGF0ZSB2YWx1ZSwgYW5kIGlzIHByaW1hcmlseSB1c2VmdWwgZm9yIGNhc2VzIGxpa2UgcmVhZGluZyBpbml0aWFsIHN0YXRlIGZyb20gYGxvY2FsU3RvcmFnZWAuXG4gICAqL1xuICBpbml0aWFsU3RhdGU6IFN0YXRlIHwgKCgpID0+IFN0YXRlKTtcblxuICAvKipcbiAgICogQSBtYXBwaW5nIGZyb20gYWN0aW9uIHR5cGVzIHRvIGFjdGlvbi10eXBlLXNwZWNpZmljICpjYXNlIHJlZHVjZXIqXG4gICAqIGZ1bmN0aW9ucy4gRm9yIGV2ZXJ5IGFjdGlvbiB0eXBlLCBhIG1hdGNoaW5nIGFjdGlvbiBjcmVhdG9yIHdpbGwgYmVcbiAgICogZ2VuZXJhdGVkIHVzaW5nIGBjcmVhdGVBY3Rpb24oKWAuXG4gICAqL1xuICByZWR1Y2VyczogVmFsaWRhdGVTbGljZUNhc2VSZWR1Y2VyczxTdGF0ZSwgQ1I+IHwgKChjcmVhdG9yczogUmVkdWNlckNyZWF0b3JzPFN0YXRlPikgPT4gQ1IpO1xuXG4gIC8qKlxuICAgKiBBIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgYSAqYnVpbGRlciogb2JqZWN0IHRvIGRlZmluZVxuICAgKiBjYXNlIHJlZHVjZXJzIHZpYSBjYWxscyB0byBgYnVpbGRlci5hZGRDYXNlKGFjdGlvbkNyZWF0b3JPclR5cGUsIHJlZHVjZXIpYC5cbiAgICpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgYGBgdHNcbiAgaW1wb3J0IHsgY3JlYXRlQWN0aW9uLCBjcmVhdGVTbGljZSwgQWN0aW9uIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCdcbiAgY29uc3QgaW5jcmVtZW50QnkgPSBjcmVhdGVBY3Rpb248bnVtYmVyPignaW5jcmVtZW50QnknKVxuICBjb25zdCBkZWNyZW1lbnQgPSBjcmVhdGVBY3Rpb24oJ2RlY3JlbWVudCcpXG4gIGludGVyZmFjZSBSZWplY3RlZEFjdGlvbiBleHRlbmRzIEFjdGlvbiB7XG4gIGVycm9yOiBFcnJvclxuICB9XG4gIGZ1bmN0aW9uIGlzUmVqZWN0ZWRBY3Rpb24oYWN0aW9uOiBBY3Rpb24pOiBhY3Rpb24gaXMgUmVqZWN0ZWRBY3Rpb24ge1xuICByZXR1cm4gYWN0aW9uLnR5cGUuZW5kc1dpdGgoJ3JlamVjdGVkJylcbiAgfVxuICBjcmVhdGVTbGljZSh7XG4gIG5hbWU6ICdjb3VudGVyJyxcbiAgaW5pdGlhbFN0YXRlOiAwLFxuICByZWR1Y2Vyczoge30sXG4gIGV4dHJhUmVkdWNlcnM6IGJ1aWxkZXIgPT4ge1xuICAgIGJ1aWxkZXJcbiAgICAgIC5hZGRDYXNlKGluY3JlbWVudEJ5LCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICAvLyBhY3Rpb24gaXMgaW5mZXJyZWQgY29ycmVjdGx5IGhlcmUgaWYgdXNpbmcgVFNcbiAgICAgIH0pXG4gICAgICAvLyBZb3UgY2FuIGNoYWluIGNhbGxzLCBvciBoYXZlIHNlcGFyYXRlIGBidWlsZGVyLmFkZENhc2UoKWAgbGluZXMgZWFjaCB0aW1lXG4gICAgICAuYWRkQ2FzZShkZWNyZW1lbnQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7fSlcbiAgICAgIC8vIFlvdSBjYW4gbWF0Y2ggYSByYW5nZSBvZiBhY3Rpb24gdHlwZXNcbiAgICAgIC5hZGRNYXRjaGVyKFxuICAgICAgICBpc1JlamVjdGVkQWN0aW9uLFxuICAgICAgICAvLyBgYWN0aW9uYCB3aWxsIGJlIGluZmVycmVkIGFzIGEgUmVqZWN0ZWRBY3Rpb24gZHVlIHRvIGlzUmVqZWN0ZWRBY3Rpb24gYmVpbmcgZGVmaW5lZCBhcyBhIHR5cGUgZ3VhcmRcbiAgICAgICAgKHN0YXRlLCBhY3Rpb24pID0+IHt9XG4gICAgICApXG4gICAgICAvLyBhbmQgcHJvdmlkZSBhIGRlZmF1bHQgY2FzZSBpZiBubyBvdGhlciBoYW5kbGVycyBtYXRjaGVkXG4gICAgICAuYWRkRGVmYXVsdENhc2UoKHN0YXRlLCBhY3Rpb24pID0+IHt9KVxuICAgIH1cbiAgfSlcbiAgYGBgXG4gICAqL1xuICBleHRyYVJlZHVjZXJzPzogKGJ1aWxkZXI6IEFjdGlvblJlZHVjZXJNYXBCdWlsZGVyPFN0YXRlPikgPT4gdm9pZDtcblxuICAvKipcbiAgICogQSBtYXAgb2Ygc2VsZWN0b3JzIHRoYXQgcmVjZWl2ZSB0aGUgc2xpY2UncyBzdGF0ZSBhbmQgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzLCBhbmQgcmV0dXJuIGEgcmVzdWx0LlxuICAgKi9cbiAgc2VsZWN0b3JzPzogU2VsZWN0b3JzO1xufVxuZXhwb3J0IGVudW0gUmVkdWNlclR5cGUge1xuICByZWR1Y2VyID0gJ3JlZHVjZXInLFxuICByZWR1Y2VyV2l0aFByZXBhcmUgPSAncmVkdWNlcldpdGhQcmVwYXJlJyxcbiAgYXN5bmNUaHVuayA9ICdhc3luY1RodW5rJyxcbn1cbnR5cGUgUmVkdWNlckRlZmluaXRpb248VCBleHRlbmRzIFJlZHVjZXJUeXBlID0gUmVkdWNlclR5cGU+ID0ge1xuICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBUO1xufTtcbmV4cG9ydCB0eXBlIENhc2VSZWR1Y2VyRGVmaW5pdGlvbjxTID0gYW55LCBBIGV4dGVuZHMgQWN0aW9uID0gVW5rbm93bkFjdGlvbj4gPSBDYXNlUmVkdWNlcjxTLCBBPiAmIFJlZHVjZXJEZWZpbml0aW9uPFJlZHVjZXJUeXBlLnJlZHVjZXI+O1xuXG4vKipcbiAqIEEgQ2FzZVJlZHVjZXIgd2l0aCBhIGBwcmVwYXJlYCBtZXRob2QuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBDYXNlUmVkdWNlcldpdGhQcmVwYXJlPFN0YXRlLCBBY3Rpb24gZXh0ZW5kcyBQYXlsb2FkQWN0aW9uPiA9IHtcbiAgcmVkdWNlcjogQ2FzZVJlZHVjZXI8U3RhdGUsIEFjdGlvbj47XG4gIHByZXBhcmU6IFByZXBhcmVBY3Rpb248QWN0aW9uWydwYXlsb2FkJ10+O1xufTtcbmV4cG9ydCBpbnRlcmZhY2UgQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZURlZmluaXRpb248U3RhdGUsIEFjdGlvbiBleHRlbmRzIFBheWxvYWRBY3Rpb24+IGV4dGVuZHMgQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZTxTdGF0ZSwgQWN0aW9uPiwgUmVkdWNlckRlZmluaXRpb248UmVkdWNlclR5cGUucmVkdWNlcldpdGhQcmVwYXJlPiB7fVxudHlwZSBBc3luY1RodW5rU2xpY2VSZWR1Y2VyQ29uZmlnPFN0YXRlLCBUaHVua0FyZyBleHRlbmRzIGFueSwgUmV0dXJuZWQgPSB1bmtub3duLCBUaHVua0FwaUNvbmZpZyBleHRlbmRzIEFzeW5jVGh1bmtDb25maWcgPSB7fT4gPSB7XG4gIHBlbmRpbmc/OiBDYXNlUmVkdWNlcjxTdGF0ZSwgUmV0dXJuVHlwZTxBc3luY1RodW5rPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+WydwZW5kaW5nJ10+PjtcbiAgcmVqZWN0ZWQ/OiBDYXNlUmVkdWNlcjxTdGF0ZSwgUmV0dXJuVHlwZTxBc3luY1RodW5rPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+WydyZWplY3RlZCddPj47XG4gIGZ1bGZpbGxlZD86IENhc2VSZWR1Y2VyPFN0YXRlLCBSZXR1cm5UeXBlPEFzeW5jVGh1bms8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz5bJ2Z1bGZpbGxlZCddPj47XG4gIHNldHRsZWQ/OiBDYXNlUmVkdWNlcjxTdGF0ZSwgUmV0dXJuVHlwZTxBc3luY1RodW5rPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+WydyZWplY3RlZCcgfCAnZnVsZmlsbGVkJ10+PjtcbiAgb3B0aW9ucz86IEFzeW5jVGh1bmtPcHRpb25zPFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz47XG59O1xudHlwZSBBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbjxTdGF0ZSwgVGh1bmtBcmcgZXh0ZW5kcyBhbnksIFJldHVybmVkID0gdW5rbm93biwgVGh1bmtBcGlDb25maWcgZXh0ZW5kcyBBc3luY1RodW5rQ29uZmlnID0ge30+ID0gQXN5bmNUaHVua1NsaWNlUmVkdWNlckNvbmZpZzxTdGF0ZSwgVGh1bmtBcmcsIFJldHVybmVkLCBUaHVua0FwaUNvbmZpZz4gJiBSZWR1Y2VyRGVmaW5pdGlvbjxSZWR1Y2VyVHlwZS5hc3luY1RodW5rPiAmIHtcbiAgcGF5bG9hZENyZWF0b3I6IEFzeW5jVGh1bmtQYXlsb2FkQ3JlYXRvcjxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPjtcbn07XG5cbi8qKlxuICogUHJvdmlkaW5nIHRoZXNlIGFzIHBhcnQgb2YgdGhlIGNvbmZpZyB3b3VsZCBjYXVzZSBjaXJjdWxhciB0eXBlcywgc28gd2UgZGlzYWxsb3cgcGFzc2luZyB0aGVtXG4gKi9cbnR5cGUgUHJldmVudENpcmN1bGFyPFRodW5rQXBpQ29uZmlnPiA9IHsgW0sgaW4ga2V5b2YgVGh1bmtBcGlDb25maWddOiBLIGV4dGVuZHMgJ3N0YXRlJyB8ICdkaXNwYXRjaCcgPyBuZXZlciA6IFRodW5rQXBpQ29uZmlnW0tdIH07XG5pbnRlcmZhY2UgQXN5bmNUaHVua0NyZWF0b3I8U3RhdGUsIEN1cnJpZWRUaHVua0FwaUNvbmZpZyBleHRlbmRzIFByZXZlbnRDaXJjdWxhcjxBc3luY1RodW5rQ29uZmlnPiA9IFByZXZlbnRDaXJjdWxhcjxBc3luY1RodW5rQ29uZmlnPj4ge1xuICA8UmV0dXJuZWQsIFRodW5rQXJnID0gdm9pZD4ocGF5bG9hZENyZWF0b3I6IEFzeW5jVGh1bmtQYXlsb2FkQ3JlYXRvcjxSZXR1cm5lZCwgVGh1bmtBcmcsIEN1cnJpZWRUaHVua0FwaUNvbmZpZz4sIGNvbmZpZz86IEFzeW5jVGh1bmtTbGljZVJlZHVjZXJDb25maWc8U3RhdGUsIFRodW5rQXJnLCBSZXR1cm5lZCwgQ3VycmllZFRodW5rQXBpQ29uZmlnPik6IEFzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uPFN0YXRlLCBUaHVua0FyZywgUmV0dXJuZWQsIEN1cnJpZWRUaHVua0FwaUNvbmZpZz47XG4gIDxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnIGV4dGVuZHMgUHJldmVudENpcmN1bGFyPEFzeW5jVGh1bmtDb25maWc+ID0ge30+KHBheWxvYWRDcmVhdG9yOiBBc3luY1RodW5rUGF5bG9hZENyZWF0b3I8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4sIGNvbmZpZz86IEFzeW5jVGh1bmtTbGljZVJlZHVjZXJDb25maWc8U3RhdGUsIFRodW5rQXJnLCBSZXR1cm5lZCwgVGh1bmtBcGlDb25maWc+KTogQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb248U3RhdGUsIFRodW5rQXJnLCBSZXR1cm5lZCwgVGh1bmtBcGlDb25maWc+O1xuICB3aXRoVHlwZXM8VGh1bmtBcGlDb25maWcgZXh0ZW5kcyBQcmV2ZW50Q2lyY3VsYXI8QXN5bmNUaHVua0NvbmZpZz4+KCk6IEFzeW5jVGh1bmtDcmVhdG9yPFN0YXRlLCBPdmVycmlkZVRodW5rQXBpQ29uZmlnczxDdXJyaWVkVGh1bmtBcGlDb25maWcsIFRodW5rQXBpQ29uZmlnPj47XG59XG5leHBvcnQgaW50ZXJmYWNlIFJlZHVjZXJDcmVhdG9yczxTdGF0ZT4ge1xuICByZWR1Y2VyKGNhc2VSZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgUGF5bG9hZEFjdGlvbj4pOiBDYXNlUmVkdWNlckRlZmluaXRpb248U3RhdGUsIFBheWxvYWRBY3Rpb24+O1xuICByZWR1Y2VyPFBheWxvYWQ+KGNhc2VSZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgUGF5bG9hZEFjdGlvbjxQYXlsb2FkPj4pOiBDYXNlUmVkdWNlckRlZmluaXRpb248U3RhdGUsIFBheWxvYWRBY3Rpb248UGF5bG9hZD4+O1xuICBhc3luY1RodW5rOiBBc3luY1RodW5rQ3JlYXRvcjxTdGF0ZT47XG4gIHByZXBhcmVkUmVkdWNlcjxQcmVwYXJlIGV4dGVuZHMgUHJlcGFyZUFjdGlvbjxhbnk+PihwcmVwYXJlOiBQcmVwYXJlLCByZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgUmV0dXJuVHlwZTxfQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQ8UHJlcGFyZT4+Pik6IHtcbiAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBSZWR1Y2VyVHlwZS5yZWR1Y2VyV2l0aFByZXBhcmU7XG4gICAgcHJlcGFyZTogUHJlcGFyZTtcbiAgICByZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgUmV0dXJuVHlwZTxfQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQ8UHJlcGFyZT4+PjtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgdHlwZSBkZXNjcmliaW5nIGEgc2xpY2UncyBgcmVkdWNlcnNgIG9wdGlvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFNsaWNlQ2FzZVJlZHVjZXJzPFN0YXRlPiA9IFJlY29yZDxzdHJpbmcsIFJlZHVjZXJEZWZpbml0aW9uPiB8IFJlY29yZDxzdHJpbmcsIENhc2VSZWR1Y2VyPFN0YXRlLCBQYXlsb2FkQWN0aW9uPGFueT4+IHwgQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZTxTdGF0ZSwgUGF5bG9hZEFjdGlvbjxhbnksIHN0cmluZywgYW55LCBhbnk+Pj47XG5cbi8qKlxuICogVGhlIHR5cGUgZGVzY3JpYmluZyBhIHNsaWNlJ3MgYHNlbGVjdG9yc2Agb3B0aW9uLlxuICovXG5leHBvcnQgdHlwZSBTbGljZVNlbGVjdG9yczxTdGF0ZT4gPSB7XG4gIFtLOiBzdHJpbmddOiAoc2xpY2VTdGF0ZTogU3RhdGUsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk7XG59O1xudHlwZSBTbGljZUFjdGlvblR5cGU8U2xpY2VOYW1lIGV4dGVuZHMgc3RyaW5nLCBBY3Rpb25OYW1lIGV4dGVuZHMga2V5b2YgYW55PiA9IEFjdGlvbk5hbWUgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgPyBgJHtTbGljZU5hbWV9LyR7QWN0aW9uTmFtZX1gIDogc3RyaW5nO1xuXG4vKipcbiAqIERlcml2ZXMgdGhlIHNsaWNlJ3MgYGFjdGlvbnNgIHByb3BlcnR5IGZyb20gdGhlIGByZWR1Y2Vyc2Agb3B0aW9uc1xuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgQ2FzZVJlZHVjZXJBY3Rpb25zPENhc2VSZWR1Y2VycyBleHRlbmRzIFNsaWNlQ2FzZVJlZHVjZXJzPGFueT4sIFNsaWNlTmFtZSBleHRlbmRzIHN0cmluZz4gPSB7IFtUeXBlIGluIGtleW9mIENhc2VSZWR1Y2Vyc106IENhc2VSZWR1Y2Vyc1tUeXBlXSBleHRlbmRzIGluZmVyIERlZmluaXRpb24gPyBEZWZpbml0aW9uIGV4dGVuZHMge1xuICBwcmVwYXJlOiBhbnk7XG59ID8gQWN0aW9uQ3JlYXRvckZvckNhc2VSZWR1Y2VyV2l0aFByZXBhcmU8RGVmaW5pdGlvbiwgU2xpY2VBY3Rpb25UeXBlPFNsaWNlTmFtZSwgVHlwZT4+IDogRGVmaW5pdGlvbiBleHRlbmRzIEFzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uPGFueSwgaW5mZXIgVGh1bmtBcmcsIGluZmVyIFJldHVybmVkLCBpbmZlciBUaHVua0FwaUNvbmZpZz4gPyBBc3luY1RodW5rPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+IDogRGVmaW5pdGlvbiBleHRlbmRzIHtcbiAgcmVkdWNlcjogYW55O1xufSA/IEFjdGlvbkNyZWF0b3JGb3JDYXNlUmVkdWNlcjxEZWZpbml0aW9uWydyZWR1Y2VyJ10sIFNsaWNlQWN0aW9uVHlwZTxTbGljZU5hbWUsIFR5cGU+PiA6IEFjdGlvbkNyZWF0b3JGb3JDYXNlUmVkdWNlcjxEZWZpbml0aW9uLCBTbGljZUFjdGlvblR5cGU8U2xpY2VOYW1lLCBUeXBlPj4gOiBuZXZlciB9O1xuXG4vKipcbiAqIEdldCBhIGBQYXlsb2FkQWN0aW9uQ3JlYXRvcmAgdHlwZSBmb3IgYSBwYXNzZWQgYENhc2VSZWR1Y2VyV2l0aFByZXBhcmVgXG4gKlxuICogQGludGVybmFsXG4gKi9cbnR5cGUgQWN0aW9uQ3JlYXRvckZvckNhc2VSZWR1Y2VyV2l0aFByZXBhcmU8Q1IgZXh0ZW5kcyB7XG4gIHByZXBhcmU6IGFueTtcbn0sIFR5cGUgZXh0ZW5kcyBzdHJpbmc+ID0gX0FjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkPENSWydwcmVwYXJlJ10sIFR5cGU+O1xuXG4vKipcbiAqIEdldCBhIGBQYXlsb2FkQWN0aW9uQ3JlYXRvcmAgdHlwZSBmb3IgYSBwYXNzZWQgYENhc2VSZWR1Y2VyYFxuICpcbiAqIEBpbnRlcm5hbFxuICovXG50eXBlIEFjdGlvbkNyZWF0b3JGb3JDYXNlUmVkdWNlcjxDUiwgVHlwZSBleHRlbmRzIHN0cmluZz4gPSBDUiBleHRlbmRzICgoc3RhdGU6IGFueSwgYWN0aW9uOiBpbmZlciBBY3Rpb24pID0+IGFueSkgPyBBY3Rpb24gZXh0ZW5kcyB7XG4gIHBheWxvYWQ6IGluZmVyIFA7XG59ID8gUGF5bG9hZEFjdGlvbkNyZWF0b3I8UCwgVHlwZT4gOiBBY3Rpb25DcmVhdG9yV2l0aG91dFBheWxvYWQ8VHlwZT4gOiBBY3Rpb25DcmVhdG9yV2l0aG91dFBheWxvYWQ8VHlwZT47XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIENhc2VSZWR1Y2VycyBvdXQgb2YgYSBgcmVkdWNlcnNgIG9iamVjdCwgZXZlbiBpZiB0aGV5IGFyZVxuICogdGVzdGVkIGludG8gYSBgQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZWAuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnR5cGUgU2xpY2VEZWZpbmVkQ2FzZVJlZHVjZXJzPENhc2VSZWR1Y2VycyBleHRlbmRzIFNsaWNlQ2FzZVJlZHVjZXJzPGFueT4+ID0geyBbVHlwZSBpbiBrZXlvZiBDYXNlUmVkdWNlcnNdOiBDYXNlUmVkdWNlcnNbVHlwZV0gZXh0ZW5kcyBpbmZlciBEZWZpbml0aW9uID8gRGVmaW5pdGlvbiBleHRlbmRzIEFzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uPGFueSwgYW55LCBhbnk+ID8gSWQ8UGljazxSZXF1aXJlZDxEZWZpbml0aW9uPiwgJ2Z1bGZpbGxlZCcgfCAncmVqZWN0ZWQnIHwgJ3BlbmRpbmcnIHwgJ3NldHRsZWQnPj4gOiBEZWZpbml0aW9uIGV4dGVuZHMge1xuICByZWR1Y2VyOiBpbmZlciBSZWR1Y2VyO1xufSA/IFJlZHVjZXIgOiBEZWZpbml0aW9uIDogbmV2ZXIgfTtcbnR5cGUgUmVtYXBwZWRTZWxlY3RvcjxTIGV4dGVuZHMgU2VsZWN0b3IsIE5ld1N0YXRlPiA9IFMgZXh0ZW5kcyBTZWxlY3RvcjxhbnksIGluZmVyIFIsIGluZmVyIFA+ID8gU2VsZWN0b3I8TmV3U3RhdGUsIFIsIFA+ICYge1xuICB1bndyYXBwZWQ6IFM7XG59IDogbmV2ZXI7XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGZpbmFsIHNlbGVjdG9yIHR5cGUgZnJvbSB0aGUgYHNlbGVjdG9yc2Agb2JqZWN0LlxuICpcbiAqIFJlbW92ZXMgdGhlIGBzdHJpbmdgIGluZGV4IHNpZ25hdHVyZSBmcm9tIHRoZSBkZWZhdWx0IHZhbHVlLlxuICovXG50eXBlIFNsaWNlRGVmaW5lZFNlbGVjdG9yczxTdGF0ZSwgU2VsZWN0b3JzIGV4dGVuZHMgU2xpY2VTZWxlY3RvcnM8U3RhdGU+LCBSb290U3RhdGU+ID0geyBbSyBpbiBrZXlvZiBTZWxlY3RvcnMgYXMgc3RyaW5nIGV4dGVuZHMgSyA/IG5ldmVyIDogS106IFJlbWFwcGVkU2VsZWN0b3I8U2VsZWN0b3JzW0tdLCBSb290U3RhdGU+IH07XG5cbi8qKlxuICogVXNlZCBvbiBhIFNsaWNlQ2FzZVJlZHVjZXJzIG9iamVjdC5cbiAqIEVuc3VyZXMgdGhhdCBpZiBhIENhc2VSZWR1Y2VyIGlzIGEgYENhc2VSZWR1Y2VyV2l0aFByZXBhcmVgLCB0aGF0XG4gKiB0aGUgYHJlZHVjZXJgIGFuZCB0aGUgYHByZXBhcmVgIGZ1bmN0aW9uIHVzZSB0aGUgc2FtZSB0eXBlIG9mIGBwYXlsb2FkYC5cbiAqXG4gKiBNaWdodCBkbyBhZGRpdGlvbmFsIHN1Y2ggY2hlY2tzIGluIHRoZSBmdXR1cmUuXG4gKlxuICogVGhpcyB0eXBlIGlzIG9ubHkgZXZlciB1c2VmdWwgaWYgeW91IHdhbnQgdG8gd3JpdGUgeW91ciBvd24gd3JhcHBlciBhcm91bmRcbiAqIGBjcmVhdGVTbGljZWAuIFBsZWFzZSBkb24ndCB1c2UgaXQgb3RoZXJ3aXNlIVxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgVmFsaWRhdGVTbGljZUNhc2VSZWR1Y2VyczxTLCBBQ1IgZXh0ZW5kcyBTbGljZUNhc2VSZWR1Y2VyczxTPj4gPSBBQ1IgJiB7IFtUIGluIGtleW9mIEFDUl06IEFDUltUXSBleHRlbmRzIHtcbiAgcmVkdWNlcihzOiBTLCBhY3Rpb24/OiBpbmZlciBBKTogYW55O1xufSA/IHtcbiAgcHJlcGFyZSguLi5hOiBuZXZlcltdKTogT21pdDxBLCAndHlwZSc+O1xufSA6IHt9IH07XG5mdW5jdGlvbiBnZXRUeXBlKHNsaWNlOiBzdHJpbmcsIGFjdGlvbktleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke3NsaWNlfS8ke2FjdGlvbktleX1gO1xufVxuaW50ZXJmYWNlIEJ1aWxkQ3JlYXRlU2xpY2VDb25maWcge1xuICBjcmVhdG9ycz86IHtcbiAgICBhc3luY1RodW5rPzogdHlwZW9mIGFzeW5jVGh1bmtDcmVhdG9yO1xuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQ3JlYXRlU2xpY2Uoe1xuICBjcmVhdG9yc1xufTogQnVpbGRDcmVhdGVTbGljZUNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IGNBVCA9IGNyZWF0b3JzPy5hc3luY1RodW5rPy5bYXN5bmNUaHVua1N5bWJvbF07XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVTbGljZTxTdGF0ZSwgQ2FzZVJlZHVjZXJzIGV4dGVuZHMgU2xpY2VDYXNlUmVkdWNlcnM8U3RhdGU+LCBOYW1lIGV4dGVuZHMgc3RyaW5nLCBTZWxlY3RvcnMgZXh0ZW5kcyBTbGljZVNlbGVjdG9yczxTdGF0ZT4sIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gTmFtZT4ob3B0aW9uczogQ3JlYXRlU2xpY2VPcHRpb25zPFN0YXRlLCBDYXNlUmVkdWNlcnMsIE5hbWUsIFJlZHVjZXJQYXRoLCBTZWxlY3RvcnM+KTogU2xpY2U8U3RhdGUsIENhc2VSZWR1Y2VycywgTmFtZSwgUmVkdWNlclBhdGgsIFNlbGVjdG9ycz4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICByZWR1Y2VyUGF0aCA9IG5hbWUgYXMgdW5rbm93biBhcyBSZWR1Y2VyUGF0aFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDExKSA6ICdgbmFtZWAgaXMgYSByZXF1aXJlZCBvcHRpb24gZm9yIGNyZWF0ZVNsaWNlJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmIChvcHRpb25zLmluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYW4gYGluaXRpYWxTdGF0ZWAgdmFsdWUgdGhhdCBpcyBub3QgYHVuZGVmaW5lZGAuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGBpbml0aWFsU3RhdGVgJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlZHVjZXJzID0gKHR5cGVvZiBvcHRpb25zLnJlZHVjZXJzID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5yZWR1Y2VycyhidWlsZFJlZHVjZXJDcmVhdG9yczxTdGF0ZT4oKSkgOiBvcHRpb25zLnJlZHVjZXJzKSB8fCB7fTtcbiAgICBjb25zdCByZWR1Y2VyTmFtZXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gICAgY29uc3QgY29udGV4dDogUmVkdWNlckhhbmRsaW5nQ29udGV4dDxTdGF0ZT4gPSB7XG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZToge30sXG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZToge30sXG4gICAgICBhY3Rpb25DcmVhdG9yczoge30sXG4gICAgICBzbGljZU1hdGNoZXJzOiBbXVxuICAgIH07XG4gICAgY29uc3QgY29udGV4dE1ldGhvZHM6IFJlZHVjZXJIYW5kbGluZ0NvbnRleHRNZXRob2RzPFN0YXRlPiA9IHtcbiAgICAgIGFkZENhc2UodHlwZU9yQWN0aW9uQ3JlYXRvcjogc3RyaW5nIHwgVHlwZWRBY3Rpb25DcmVhdG9yPGFueT4sIHJlZHVjZXI6IENhc2VSZWR1Y2VyPFN0YXRlPikge1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHR5cGVPckFjdGlvbkNyZWF0b3IgPT09ICdzdHJpbmcnID8gdHlwZU9yQWN0aW9uQ3JlYXRvciA6IHR5cGVPckFjdGlvbkNyZWF0b3IudHlwZTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMigxMikgOiAnYGNvbnRleHQuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgaW4gY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMoMTMpIDogJ2Bjb250ZXh0LmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlOiAnICsgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZVt0eXBlXSA9IHJlZHVjZXI7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH0sXG4gICAgICBhZGRNYXRjaGVyKG1hdGNoZXIsIHJlZHVjZXIpIHtcbiAgICAgICAgY29udGV4dC5zbGljZU1hdGNoZXJzLnB1c2goe1xuICAgICAgICAgIG1hdGNoZXIsXG4gICAgICAgICAgcmVkdWNlclxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfSxcbiAgICAgIGV4cG9zZUFjdGlvbihuYW1lLCBhY3Rpb25DcmVhdG9yKSB7XG4gICAgICAgIGNvbnRleHQuYWN0aW9uQ3JlYXRvcnNbbmFtZV0gPSBhY3Rpb25DcmVhdG9yO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgZXhwb3NlQ2FzZVJlZHVjZXIobmFtZSwgcmVkdWNlcikge1xuICAgICAgICBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lW25hbWVdID0gcmVkdWNlcjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVkdWNlck5hbWVzLmZvckVhY2gocmVkdWNlck5hbWUgPT4ge1xuICAgICAgY29uc3QgcmVkdWNlckRlZmluaXRpb24gPSByZWR1Y2Vyc1tyZWR1Y2VyTmFtZV07XG4gICAgICBjb25zdCByZWR1Y2VyRGV0YWlsczogUmVkdWNlckRldGFpbHMgPSB7XG4gICAgICAgIHJlZHVjZXJOYW1lLFxuICAgICAgICB0eXBlOiBnZXRUeXBlKG5hbWUsIHJlZHVjZXJOYW1lKSxcbiAgICAgICAgY3JlYXRlTm90YXRpb246IHR5cGVvZiBvcHRpb25zLnJlZHVjZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICB9O1xuICAgICAgaWYgKGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb248U3RhdGU+KHJlZHVjZXJEZWZpbml0aW9uKSkge1xuICAgICAgICBoYW5kbGVUaHVua0Nhc2VSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGV0YWlscywgcmVkdWNlckRlZmluaXRpb24sIGNvbnRleHRNZXRob2RzLCBjQVQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlTm9ybWFsUmVkdWNlckRlZmluaXRpb248U3RhdGU+KHJlZHVjZXJEZXRhaWxzLCByZWR1Y2VyRGVmaW5pdGlvbiBhcyBhbnksIGNvbnRleHRNZXRob2RzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBidWlsZFJlZHVjZXIoKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZXh0cmFSZWR1Y2VycyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U0KDE0KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVNsaWNlLmV4dHJhUmVkdWNlcnNgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVTbGljZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgW2V4dHJhUmVkdWNlcnMgPSB7fSwgYWN0aW9uTWF0Y2hlcnMgPSBbXSwgZGVmYXVsdENhc2VSZWR1Y2VyID0gdW5kZWZpbmVkXSA9IHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09ICdmdW5jdGlvbicgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhvcHRpb25zLmV4dHJhUmVkdWNlcnMpIDogW29wdGlvbnMuZXh0cmFSZWR1Y2Vyc107XG4gICAgICBjb25zdCBmaW5hbENhc2VSZWR1Y2VycyA9IHtcbiAgICAgICAgLi4uZXh0cmFSZWR1Y2VycyxcbiAgICAgICAgLi4uY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBjcmVhdGVSZWR1Y2VyKG9wdGlvbnMuaW5pdGlhbFN0YXRlLCBidWlsZGVyID0+IHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGZpbmFsQ2FzZVJlZHVjZXJzKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGRDYXNlKGtleSwgZmluYWxDYXNlUmVkdWNlcnNba2V5XSBhcyBDYXNlUmVkdWNlcjxhbnk+KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzTSBvZiBjb250ZXh0LnNsaWNlTWF0Y2hlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZE1hdGNoZXIoc00ubWF0Y2hlciwgc00ucmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbSBvZiBhY3Rpb25NYXRjaGVycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkTWF0Y2hlcihtLm1hdGNoZXIsIG0ucmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkRGVmYXVsdENhc2UoZGVmYXVsdENhc2VSZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdFNlbGYgPSAoc3RhdGU6IFN0YXRlKSA9PiBzdGF0ZTtcbiAgICBjb25zdCBpbmplY3RlZFNlbGVjdG9yQ2FjaGUgPSBuZXcgTWFwPGJvb2xlYW4sIFdlYWtNYXA8KHJvb3RTdGF0ZTogYW55KSA9PiBTdGF0ZSB8IHVuZGVmaW5lZCwgUmVjb3JkPHN0cmluZywgKHJvb3RTdGF0ZTogYW55KSA9PiBhbnk+Pj4oKTtcbiAgICBjb25zdCBpbmplY3RlZFN0YXRlQ2FjaGUgPSBuZXcgV2Vha01hcDwocm9vdFN0YXRlOiBhbnkpID0+IFN0YXRlLCBTdGF0ZT4oKTtcbiAgICBsZXQgX3JlZHVjZXI6IFJlZHVjZXJXaXRoSW5pdGlhbFN0YXRlPFN0YXRlPjtcbiAgICBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlOiBTdGF0ZSB8IHVuZGVmaW5lZCwgYWN0aW9uOiBVbmtub3duQWN0aW9uKSB7XG4gICAgICBpZiAoIV9yZWR1Y2VyKSBfcmVkdWNlciA9IGJ1aWxkUmVkdWNlcigpO1xuICAgICAgcmV0dXJuIF9yZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICBpZiAoIV9yZWR1Y2VyKSBfcmVkdWNlciA9IGJ1aWxkUmVkdWNlcigpO1xuICAgICAgcmV0dXJuIF9yZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlU2VsZWN0b3JQcm9wczxDdXJyZW50UmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcgPSBSZWR1Y2VyUGF0aD4ocmVkdWNlclBhdGg6IEN1cnJlbnRSZWR1Y2VyUGF0aCwgaW5qZWN0ZWQgPSBmYWxzZSk6IFBpY2s8U2xpY2U8U3RhdGUsIENhc2VSZWR1Y2VycywgTmFtZSwgQ3VycmVudFJlZHVjZXJQYXRoLCBTZWxlY3RvcnM+LCAnZ2V0U2VsZWN0b3JzJyB8ICdzZWxlY3RvcnMnIHwgJ3NlbGVjdFNsaWNlJyB8ICdyZWR1Y2VyUGF0aCc+IHtcbiAgICAgIGZ1bmN0aW9uIHNlbGVjdFNsaWNlKHN0YXRlOiB7IFtLIGluIEN1cnJlbnRSZWR1Y2VyUGF0aF06IFN0YXRlIH0pIHtcbiAgICAgICAgbGV0IHNsaWNlU3RhdGUgPSBzdGF0ZVtyZWR1Y2VyUGF0aF07XG4gICAgICAgIGlmICh0eXBlb2Ygc2xpY2VTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgICAgICAgIHNsaWNlU3RhdGUgPSBnZXRPckluc2VydENvbXB1dGVkKGluamVjdGVkU3RhdGVDYWNoZSwgc2VsZWN0U2xpY2UsIGdldEluaXRpYWxTdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U1KDE1KSA6ICdzZWxlY3RTbGljZSByZXR1cm5lZCB1bmRlZmluZWQgZm9yIGFuIHVuaW5qZWN0ZWQgc2xpY2UgcmVkdWNlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2xpY2VTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhzZWxlY3RTdGF0ZTogKHJvb3RTdGF0ZTogYW55KSA9PiBTdGF0ZSA9IHNlbGVjdFNlbGYpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3JDYWNoZSA9IGdldE9ySW5zZXJ0Q29tcHV0ZWQoaW5qZWN0ZWRTZWxlY3RvckNhY2hlLCBpbmplY3RlZCwgKCkgPT4gbmV3IFdlYWtNYXAoKSk7XG4gICAgICAgIHJldHVybiBnZXRPckluc2VydENvbXB1dGVkKHNlbGVjdG9yQ2FjaGUsIHNlbGVjdFN0YXRlLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWFwOiBSZWNvcmQ8c3RyaW5nLCBTZWxlY3RvcjxhbnksIGFueT4+ID0ge307XG4gICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgc2VsZWN0b3JdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuc2VsZWN0b3JzID8/IHt9KSkge1xuICAgICAgICAgICAgbWFwW25hbWVdID0gd3JhcFNlbGVjdG9yKHNlbGVjdG9yLCBzZWxlY3RTdGF0ZSwgKCkgPT4gZ2V0T3JJbnNlcnRDb21wdXRlZChpbmplY3RlZFN0YXRlQ2FjaGUsIHNlbGVjdFN0YXRlLCBnZXRJbml0aWFsU3RhdGUpLCBpbmplY3RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH0pIGFzIGFueTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgICBnZXRTZWxlY3RvcnMsXG4gICAgICAgIGdldCBzZWxlY3RvcnMoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFNlbGVjdG9ycyhzZWxlY3RTbGljZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdFNsaWNlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzbGljZTogU2xpY2U8U3RhdGUsIENhc2VSZWR1Y2VycywgTmFtZSwgUmVkdWNlclBhdGgsIFNlbGVjdG9ycz4gPSB7XG4gICAgICBuYW1lLFxuICAgICAgcmVkdWNlcixcbiAgICAgIGFjdGlvbnM6IGNvbnRleHQuYWN0aW9uQ3JlYXRvcnMgYXMgYW55LFxuICAgICAgY2FzZVJlZHVjZXJzOiBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lIGFzIGFueSxcbiAgICAgIGdldEluaXRpYWxTdGF0ZSxcbiAgICAgIC4uLm1ha2VTZWxlY3RvclByb3BzKHJlZHVjZXJQYXRoKSxcbiAgICAgIGluamVjdEludG8oaW5qZWN0YWJsZSwge1xuICAgICAgICByZWR1Y2VyUGF0aDogcGF0aE9wdCxcbiAgICAgICAgLi4uY29uZmlnXG4gICAgICB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgbmV3UmVkdWNlclBhdGggPSBwYXRoT3B0ID8/IHJlZHVjZXJQYXRoO1xuICAgICAgICBpbmplY3RhYmxlLmluamVjdCh7XG4gICAgICAgICAgcmVkdWNlclBhdGg6IG5ld1JlZHVjZXJQYXRoLFxuICAgICAgICAgIHJlZHVjZXJcbiAgICAgICAgfSwgY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zbGljZSxcbiAgICAgICAgICAuLi5tYWtlU2VsZWN0b3JQcm9wcyhuZXdSZWR1Y2VyUGF0aCwgdHJ1ZSlcbiAgICAgICAgfSBhcyBhbnk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gc2xpY2U7XG4gIH07XG59XG5mdW5jdGlvbiB3cmFwU2VsZWN0b3I8U3RhdGUsIE5ld1N0YXRlLCBTIGV4dGVuZHMgU2VsZWN0b3I8U3RhdGU+PihzZWxlY3RvcjogUywgc2VsZWN0U3RhdGU6IFNlbGVjdG9yPE5ld1N0YXRlLCBTdGF0ZT4sIGdldEluaXRpYWxTdGF0ZTogKCkgPT4gU3RhdGUsIGluamVjdGVkPzogYm9vbGVhbikge1xuICBmdW5jdGlvbiB3cmFwcGVyKHJvb3RTdGF0ZTogTmV3U3RhdGUsIC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgbGV0IHNsaWNlU3RhdGUgPSBzZWxlY3RTdGF0ZShyb290U3RhdGUpO1xuICAgIGlmICh0eXBlb2Ygc2xpY2VTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgICBzbGljZVN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNigxNikgOiAnc2VsZWN0U3RhdGUgcmV0dXJuZWQgdW5kZWZpbmVkIGZvciBhbiB1bmluamVjdGVkIHNsaWNlIHJlZHVjZXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9yKHNsaWNlU3RhdGUsIC4uLmFyZ3MpO1xuICB9XG4gIHdyYXBwZXIudW53cmFwcGVkID0gc2VsZWN0b3I7XG4gIHJldHVybiB3cmFwcGVyIGFzIFJlbWFwcGVkU2VsZWN0b3I8UywgTmV3U3RhdGU+O1xufVxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFuIGluaXRpYWwgc3RhdGUsIGFuIG9iamVjdCBmdWxsIG9mIHJlZHVjZXJcbiAqIGZ1bmN0aW9ucywgYW5kIGEgXCJzbGljZSBuYW1lXCIsIGFuZCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlc1xuICogYWN0aW9uIGNyZWF0b3JzIGFuZCBhY3Rpb24gdHlwZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZVxuICogcmVkdWNlcnMgYW5kIHN0YXRlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVNsaWNlID0gLyogQF9fUFVSRV9fICovYnVpbGRDcmVhdGVTbGljZSgpO1xuaW50ZXJmYWNlIFJlZHVjZXJIYW5kbGluZ0NvbnRleHQ8U3RhdGU+IHtcbiAgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWU6IFJlY29yZDxzdHJpbmcsIENhc2VSZWR1Y2VyPFN0YXRlLCBhbnk+IHwgUGljazxBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbjxTdGF0ZSwgYW55LCBhbnksIGFueT4sICdmdWxmaWxsZWQnIHwgJ3JlamVjdGVkJyB8ICdwZW5kaW5nJyB8ICdzZXR0bGVkJz4+O1xuICBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZTogUmVjb3JkPHN0cmluZywgQ2FzZVJlZHVjZXI8U3RhdGUsIGFueT4+O1xuICBzbGljZU1hdGNoZXJzOiBBY3Rpb25NYXRjaGVyRGVzY3JpcHRpb25Db2xsZWN0aW9uPFN0YXRlPjtcbiAgYWN0aW9uQ3JlYXRvcnM6IFJlY29yZDxzdHJpbmcsIEZ1bmN0aW9uPjtcbn1cbmludGVyZmFjZSBSZWR1Y2VySGFuZGxpbmdDb250ZXh0TWV0aG9kczxTdGF0ZT4ge1xuICAvKipcbiAgICogQWRkcyBhIGNhc2UgcmVkdWNlciB0byBoYW5kbGUgYSBzaW5nbGUgYWN0aW9uIHR5cGUuXG4gICAqIEBwYXJhbSBhY3Rpb25DcmVhdG9yIC0gRWl0aGVyIGEgcGxhaW4gYWN0aW9uIHR5cGUgc3RyaW5nLCBvciBhbiBhY3Rpb24gY3JlYXRvciBnZW5lcmF0ZWQgYnkgW2BjcmVhdGVBY3Rpb25gXSguL2NyZWF0ZUFjdGlvbikgdGhhdCBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGFjdGlvbiB0eXBlLlxuICAgKiBAcGFyYW0gcmVkdWNlciAtIFRoZSBhY3R1YWwgY2FzZSByZWR1Y2VyIGZ1bmN0aW9uLlxuICAgKi9cbiAgYWRkQ2FzZTxBY3Rpb25DcmVhdG9yIGV4dGVuZHMgVHlwZWRBY3Rpb25DcmVhdG9yPHN0cmluZz4+KGFjdGlvbkNyZWF0b3I6IEFjdGlvbkNyZWF0b3IsIHJlZHVjZXI6IENhc2VSZWR1Y2VyPFN0YXRlLCBSZXR1cm5UeXBlPEFjdGlvbkNyZWF0b3I+Pik6IFJlZHVjZXJIYW5kbGluZ0NvbnRleHRNZXRob2RzPFN0YXRlPjtcbiAgLyoqXG4gICAqIEFkZHMgYSBjYXNlIHJlZHVjZXIgdG8gaGFuZGxlIGEgc2luZ2xlIGFjdGlvbiB0eXBlLlxuICAgKiBAcGFyYW0gYWN0aW9uQ3JlYXRvciAtIEVpdGhlciBhIHBsYWluIGFjdGlvbiB0eXBlIHN0cmluZywgb3IgYW4gYWN0aW9uIGNyZWF0b3IgZ2VuZXJhdGVkIGJ5IFtgY3JlYXRlQWN0aW9uYF0oLi9jcmVhdGVBY3Rpb24pIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBhY3Rpb24gdHlwZS5cbiAgICogQHBhcmFtIHJlZHVjZXIgLSBUaGUgYWN0dWFsIGNhc2UgcmVkdWNlciBmdW5jdGlvbi5cbiAgICovXG4gIGFkZENhc2U8VHlwZSBleHRlbmRzIHN0cmluZywgQSBleHRlbmRzIEFjdGlvbjxUeXBlPj4odHlwZTogVHlwZSwgcmVkdWNlcjogQ2FzZVJlZHVjZXI8U3RhdGUsIEE+KTogUmVkdWNlckhhbmRsaW5nQ29udGV4dE1ldGhvZHM8U3RhdGU+O1xuXG4gIC8qKlxuICAgKiBBbGxvd3MgeW91IHRvIG1hdGNoIGluY29taW5nIGFjdGlvbnMgYWdhaW5zdCB5b3VyIG93biBmaWx0ZXIgZnVuY3Rpb24gaW5zdGVhZCBvZiBvbmx5IHRoZSBgYWN0aW9uLnR5cGVgIHByb3BlcnR5LlxuICAgKiBAcmVtYXJrc1xuICAgKiBJZiBtdWx0aXBsZSBtYXRjaGVyIHJlZHVjZXJzIG1hdGNoLCBhbGwgb2YgdGhlbSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlclxuICAgKiB0aGV5IHdlcmUgZGVmaW5lZCBpbiAtIGV2ZW4gaWYgYSBjYXNlIHJlZHVjZXIgYWxyZWFkeSBtYXRjaGVkLlxuICAgKiBBbGwgY2FsbHMgdG8gYGJ1aWxkZXIuYWRkTWF0Y2hlcmAgbXVzdCBjb21lIGFmdGVyIGFueSBjYWxscyB0byBgYnVpbGRlci5hZGRDYXNlYCBhbmQgYmVmb3JlIGFueSBjYWxscyB0byBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAuXG4gICAqIEBwYXJhbSBtYXRjaGVyIC0gQSBtYXRjaGVyIGZ1bmN0aW9uLiBJbiBUeXBlU2NyaXB0LCB0aGlzIHNob3VsZCBiZSBhIFt0eXBlIHByZWRpY2F0ZV0oaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svMi9uYXJyb3dpbmcuaHRtbCN1c2luZy10eXBlLXByZWRpY2F0ZXMpXG4gICAqICAgZnVuY3Rpb25cbiAgICogQHBhcmFtIHJlZHVjZXIgLSBUaGUgYWN0dWFsIGNhc2UgcmVkdWNlciBmdW5jdGlvbi5cbiAgICpcbiAgICovXG4gIGFkZE1hdGNoZXI8QT4obWF0Y2hlcjogVHlwZUd1YXJkPEE+LCByZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgQSBleHRlbmRzIEFjdGlvbiA/IEEgOiBBICYgQWN0aW9uPik6IFJlZHVjZXJIYW5kbGluZ0NvbnRleHRNZXRob2RzPFN0YXRlPjtcbiAgLyoqXG4gICAqIEFkZCBhbiBhY3Rpb24gdG8gYmUgZXhwb3NlZCB1bmRlciB0aGUgZmluYWwgYHNsaWNlLmFjdGlvbnNgIGtleS5cbiAgICogQHBhcmFtIG5hbWUgVGhlIGtleSB0byBiZSBleHBvc2VkIGFzLlxuICAgKiBAcGFyYW0gYWN0aW9uQ3JlYXRvciBUaGUgYWN0aW9uIHRvIGV4cG9zZS5cbiAgICogQGV4YW1wbGVcbiAgICogY29udGV4dC5leHBvc2VBY3Rpb24oXCJhZGRQb3N0XCIsIGNyZWF0ZUFjdGlvbjxQb3N0PihcImFkZFBvc3RcIikpO1xuICAgKlxuICAgKiBleHBvcnQgY29uc3QgeyBhZGRQb3N0IH0gPSBzbGljZS5hY3Rpb25zXG4gICAqXG4gICAqIGRpc3BhdGNoKGFkZFBvc3QocG9zdCkpXG4gICAqL1xuICBleHBvc2VBY3Rpb24obmFtZTogc3RyaW5nLCBhY3Rpb25DcmVhdG9yOiBGdW5jdGlvbik6IFJlZHVjZXJIYW5kbGluZ0NvbnRleHRNZXRob2RzPFN0YXRlPjtcbiAgLyoqXG4gICAqIEFkZCBhIGNhc2UgcmVkdWNlciB0byBiZSBleHBvc2VkIHVuZGVyIHRoZSBmaW5hbCBgc2xpY2UuY2FzZVJlZHVjZXJzYCBrZXkuXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBrZXkgdG8gYmUgZXhwb3NlZCBhcy5cbiAgICogQHBhcmFtIHJlZHVjZXIgVGhlIHJlZHVjZXIgdG8gZXhwb3NlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb250ZXh0LmV4cG9zZUNhc2VSZWR1Y2VyKFwiYWRkUG9zdFwiLCAoc3RhdGUsIGFjdGlvbjogUGF5bG9hZEFjdGlvbjxQb3N0PikgPT4ge1xuICAgKiAgIHN0YXRlLnB1c2goYWN0aW9uLnBheWxvYWQpXG4gICAqIH0pXG4gICAqXG4gICAqIHNsaWNlLmNhc2VSZWR1Y2Vycy5hZGRQb3N0KFtdLCBhZGRQb3N0KHBvc3QpKVxuICAgKi9cbiAgZXhwb3NlQ2FzZVJlZHVjZXIobmFtZTogc3RyaW5nLCByZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgYW55PiB8IFBpY2s8QXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb248U3RhdGUsIGFueSwgYW55LCBhbnk+LCAnZnVsZmlsbGVkJyB8ICdyZWplY3RlZCcgfCAncGVuZGluZycgfCAnc2V0dGxlZCc+KTogUmVkdWNlckhhbmRsaW5nQ29udGV4dE1ldGhvZHM8U3RhdGU+O1xufVxuaW50ZXJmYWNlIFJlZHVjZXJEZXRhaWxzIHtcbiAgLyoqIFRoZSBrZXkgdGhlIHJlZHVjZXIgd2FzIGRlZmluZWQgdW5kZXIgKi9cbiAgcmVkdWNlck5hbWU6IHN0cmluZztcbiAgLyoqIFRoZSBwcmVkZWZpbmVkIGFjdGlvbiB0eXBlLCBpLmUuIGAke3NsaWNlLm5hbWV9LyR7cmVkdWNlck5hbWV9YCAqL1xuICB0eXBlOiBzdHJpbmc7XG4gIC8qKiBXaGV0aGVyIGNyZWF0ZS4gbm90YXRpb24gd2FzIHVzZWQgd2hlbiBkZWZpbmluZyByZWR1Y2VycyAqL1xuICBjcmVhdGVOb3RhdGlvbjogYm9vbGVhbjtcbn1cbmZ1bmN0aW9uIGJ1aWxkUmVkdWNlckNyZWF0b3JzPFN0YXRlPigpOiBSZWR1Y2VyQ3JlYXRvcnM8U3RhdGU+IHtcbiAgZnVuY3Rpb24gYXN5bmNUaHVuayhwYXlsb2FkQ3JlYXRvcjogQXN5bmNUaHVua1BheWxvYWRDcmVhdG9yPGFueSwgYW55PiwgY29uZmlnOiBBc3luY1RodW5rU2xpY2VSZWR1Y2VyQ29uZmlnPFN0YXRlLCBhbnk+KTogQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb248U3RhdGUsIGFueT4ge1xuICAgIHJldHVybiB7XG4gICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBSZWR1Y2VyVHlwZS5hc3luY1RodW5rLFxuICAgICAgcGF5bG9hZENyZWF0b3IsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuICB9XG4gIGFzeW5jVGh1bmsud2l0aFR5cGVzID0gKCkgPT4gYXN5bmNUaHVuaztcbiAgcmV0dXJuIHtcbiAgICByZWR1Y2VyKGNhc2VSZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgYW55Pikge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAvLyBoYWNrIHNvIHRoZSB3cmFwcGluZyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgbmFtZSBhcyB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gd2UgbmVlZCB0byBjcmVhdGUgYSB3cmFwcGVyIHNvIHRoZSBgcmVkdWNlckRlZmluaXRpb25UeXBlYCBpcyBub3QgYXNzaWduZWQgdG8gdGhlIG9yaWdpbmFsXG4gICAgICAgIFtjYXNlUmVkdWNlci5uYW1lXSguLi5hcmdzOiBQYXJhbWV0ZXJzPHR5cGVvZiBjYXNlUmVkdWNlcj4pIHtcbiAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1bY2FzZVJlZHVjZXIubmFtZV0sIHtcbiAgICAgICAgX3JlZHVjZXJEZWZpbml0aW9uVHlwZTogUmVkdWNlclR5cGUucmVkdWNlclxuICAgICAgfSBhcyBjb25zdCk7XG4gICAgfSxcbiAgICBwcmVwYXJlZFJlZHVjZXIocHJlcGFyZSwgcmVkdWNlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3JlZHVjZXJEZWZpbml0aW9uVHlwZTogUmVkdWNlclR5cGUucmVkdWNlcldpdGhQcmVwYXJlLFxuICAgICAgICBwcmVwYXJlLFxuICAgICAgICByZWR1Y2VyXG4gICAgICB9O1xuICAgIH0sXG4gICAgYXN5bmNUaHVuazogYXN5bmNUaHVuayBhcyBhbnlcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uPFN0YXRlPih7XG4gIHR5cGUsXG4gIHJlZHVjZXJOYW1lLFxuICBjcmVhdGVOb3RhdGlvblxufTogUmVkdWNlckRldGFpbHMsIG1heWJlUmVkdWNlcldpdGhQcmVwYXJlOiBDYXNlUmVkdWNlcjxTdGF0ZSwge1xuICBwYXlsb2FkOiBhbnk7XG4gIHR5cGU6IHN0cmluZztcbn0+IHwgQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZTxTdGF0ZSwgUGF5bG9hZEFjdGlvbjxhbnksIHN0cmluZywgYW55LCBhbnk+PiwgY29udGV4dDogUmVkdWNlckhhbmRsaW5nQ29udGV4dE1ldGhvZHM8U3RhdGU+KSB7XG4gIGxldCBjYXNlUmVkdWNlcjogQ2FzZVJlZHVjZXI8U3RhdGUsIGFueT47XG4gIGxldCBwcmVwYXJlQ2FsbGJhY2s6IFByZXBhcmVBY3Rpb248YW55PiB8IHVuZGVmaW5lZDtcbiAgaWYgKCdyZWR1Y2VyJyBpbiBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkge1xuICAgIGlmIChjcmVhdGVOb3RhdGlvbiAmJiAhaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbihtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTcoMTcpIDogJ1BsZWFzZSB1c2UgdGhlIGBjcmVhdGUucHJlcGFyZWRSZWR1Y2VyYCBub3RhdGlvbiBmb3IgcHJlcGFyZWQgYWN0aW9uIGNyZWF0b3JzIHdpdGggdGhlIGBjcmVhdGVgIG5vdGF0aW9uLicpO1xuICAgIH1cbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnJlZHVjZXI7XG4gICAgcHJlcGFyZUNhbGxiYWNrID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucHJlcGFyZTtcbiAgfSBlbHNlIHtcbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlO1xuICB9XG4gIGNvbnRleHQuYWRkQ2FzZSh0eXBlLCBjYXNlUmVkdWNlcikuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIGNhc2VSZWR1Y2VyKS5leHBvc2VBY3Rpb24ocmVkdWNlck5hbWUsIHByZXBhcmVDYWxsYmFjayA/IGNyZWF0ZUFjdGlvbih0eXBlLCBwcmVwYXJlQ2FsbGJhY2spIDogY3JlYXRlQWN0aW9uKHR5cGUpKTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb248U3RhdGU+KHJlZHVjZXJEZWZpbml0aW9uOiBhbnkpOiByZWR1Y2VyRGVmaW5pdGlvbiBpcyBBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbjxTdGF0ZSwgYW55LCBhbnksIGFueT4ge1xuICByZXR1cm4gcmVkdWNlckRlZmluaXRpb24uX3JlZHVjZXJEZWZpbml0aW9uVHlwZSA9PT0gUmVkdWNlclR5cGUuYXN5bmNUaHVuaztcbn1cbmZ1bmN0aW9uIGlzQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZURlZmluaXRpb248U3RhdGU+KHJlZHVjZXJEZWZpbml0aW9uOiBhbnkpOiByZWR1Y2VyRGVmaW5pdGlvbiBpcyBDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbjxTdGF0ZSwgYW55PiB7XG4gIHJldHVybiByZWR1Y2VyRGVmaW5pdGlvbi5fcmVkdWNlckRlZmluaXRpb25UeXBlID09PSBSZWR1Y2VyVHlwZS5yZWR1Y2VyV2l0aFByZXBhcmU7XG59XG5mdW5jdGlvbiBoYW5kbGVUaHVua0Nhc2VSZWR1Y2VyRGVmaW5pdGlvbjxTdGF0ZT4oe1xuICB0eXBlLFxuICByZWR1Y2VyTmFtZVxufTogUmVkdWNlckRldGFpbHMsIHJlZHVjZXJEZWZpbml0aW9uOiBBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbjxTdGF0ZSwgYW55LCBhbnksIGFueT4sIGNvbnRleHQ6IFJlZHVjZXJIYW5kbGluZ0NvbnRleHRNZXRob2RzPFN0YXRlPiwgY0FUOiB0eXBlb2YgX2NyZWF0ZUFzeW5jVGh1bmsgfCB1bmRlZmluZWQpIHtcbiAgaWYgKCFjQVQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U4KDE4KSA6ICdDYW5ub3QgdXNlIGBjcmVhdGUuYXN5bmNUaHVua2AgaW4gdGhlIGJ1aWx0LWluIGBjcmVhdGVTbGljZWAuICcgKyAnVXNlIGBidWlsZENyZWF0ZVNsaWNlKHsgY3JlYXRvcnM6IHsgYXN5bmNUaHVuazogYXN5bmNUaHVua0NyZWF0b3IgfSB9KWAgdG8gY3JlYXRlIGEgY3VzdG9taXNlZCB2ZXJzaW9uIG9mIGBjcmVhdGVTbGljZWAuJyk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHBheWxvYWRDcmVhdG9yLFxuICAgIGZ1bGZpbGxlZCxcbiAgICBwZW5kaW5nLFxuICAgIHJlamVjdGVkLFxuICAgIHNldHRsZWQsXG4gICAgb3B0aW9uc1xuICB9ID0gcmVkdWNlckRlZmluaXRpb247XG4gIGNvbnN0IHRodW5rID0gY0FUKHR5cGUsIHBheWxvYWRDcmVhdG9yLCBvcHRpb25zIGFzIGFueSk7XG4gIGNvbnRleHQuZXhwb3NlQWN0aW9uKHJlZHVjZXJOYW1lLCB0aHVuayk7XG4gIGlmIChmdWxmaWxsZWQpIHtcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsuZnVsZmlsbGVkLCBmdWxmaWxsZWQpO1xuICB9XG4gIGlmIChwZW5kaW5nKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLnBlbmRpbmcsIHBlbmRpbmcpO1xuICB9XG4gIGlmIChyZWplY3RlZCkge1xuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5yZWplY3RlZCwgcmVqZWN0ZWQpO1xuICB9XG4gIGlmIChzZXR0bGVkKSB7XG4gICAgY29udGV4dC5hZGRNYXRjaGVyKHRodW5rLnNldHRsZWQsIHNldHRsZWQpO1xuICB9XG4gIGNvbnRleHQuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCB8fCBub29wLFxuICAgIHBlbmRpbmc6IHBlbmRpbmcgfHwgbm9vcCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQgfHwgbm9vcCxcbiAgICBzZXR0bGVkOiBzZXR0bGVkIHx8IG5vb3BcbiAgfSk7XG59XG5mdW5jdGlvbiBub29wKCkge30iLCJpbXBvcnQgdHlwZSB7IEVudGl0eUlkLCBFbnRpdHlTdGF0ZSwgRW50aXR5U3RhdGVBZGFwdGVyLCBFbnRpdHlTdGF0ZUZhY3RvcnkgfSBmcm9tICcuL21vZGVscyc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5pdGlhbEVudGl0eVN0YXRlPFQsIElkIGV4dGVuZHMgRW50aXR5SWQ+KCk6IEVudGl0eVN0YXRlPFQsIElkPiB7XG4gIHJldHVybiB7XG4gICAgaWRzOiBbXSxcbiAgICBlbnRpdGllczoge30gYXMgUmVjb3JkPElkLCBUPlxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3Rvcnk8VCwgSWQgZXh0ZW5kcyBFbnRpdHlJZD4oc3RhdGVBZGFwdGVyOiBFbnRpdHlTdGF0ZUFkYXB0ZXI8VCwgSWQ+KTogRW50aXR5U3RhdGVGYWN0b3J5PFQsIElkPiB7XG4gIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZShzdGF0ZT86IHVuZGVmaW5lZCwgZW50aXRpZXM/OiByZWFkb25seSBUW10gfCBSZWNvcmQ8SWQsIFQ+KTogRW50aXR5U3RhdGU8VCwgSWQ+O1xuICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGU8UyBleHRlbmRzIG9iamVjdD4oYWRkaXRpb25hbFN0YXRlOiBTLCBlbnRpdGllcz86IHJlYWRvbmx5IFRbXSB8IFJlY29yZDxJZCwgVD4pOiBFbnRpdHlTdGF0ZTxULCBJZD4gJiBTO1xuICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoYWRkaXRpb25hbFN0YXRlOiBhbnkgPSB7fSwgZW50aXRpZXM/OiByZWFkb25seSBUW10gfCBSZWNvcmQ8SWQsIFQ+KTogYW55IHtcbiAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCksIGFkZGl0aW9uYWxTdGF0ZSk7XG4gICAgcmV0dXJuIGVudGl0aWVzID8gc3RhdGVBZGFwdGVyLnNldEFsbChzdGF0ZSwgZW50aXRpZXMpIDogc3RhdGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRJbml0aWFsU3RhdGVcbiAgfTtcbn0iLCJpbXBvcnQgdHlwZSB7IENyZWF0ZVNlbGVjdG9yRnVuY3Rpb24sIFNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnO1xuaW1wb3J0IHsgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IgfSBmcm9tICcuLi9jcmVhdGVEcmFmdFNhZmVTZWxlY3Rvcic7XG5pbXBvcnQgdHlwZSB7IEVudGl0eUlkLCBFbnRpdHlTZWxlY3RvcnMsIEVudGl0eVN0YXRlIH0gZnJvbSAnLi9tb2RlbHMnO1xudHlwZSBBbnlGdW5jdGlvbiA9ICguLi5hcmdzOiBhbnkpID0+IGFueTtcbnR5cGUgQW55Q3JlYXRlU2VsZWN0b3JGdW5jdGlvbiA9IENyZWF0ZVNlbGVjdG9yRnVuY3Rpb248PEYgZXh0ZW5kcyBBbnlGdW5jdGlvbj4oZjogRikgPT4gRiwgPEYgZXh0ZW5kcyBBbnlGdW5jdGlvbj4oZjogRikgPT4gRj47XG5leHBvcnQgdHlwZSBHZXRTZWxlY3RvcnNPcHRpb25zID0ge1xuICBjcmVhdGVTZWxlY3Rvcj86IEFueUNyZWF0ZVNlbGVjdG9yRnVuY3Rpb247XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yc0ZhY3Rvcnk8VCwgSWQgZXh0ZW5kcyBFbnRpdHlJZD4oKSB7XG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhzZWxlY3RTdGF0ZT86IHVuZGVmaW5lZCwgb3B0aW9ucz86IEdldFNlbGVjdG9yc09wdGlvbnMpOiBFbnRpdHlTZWxlY3RvcnM8VCwgRW50aXR5U3RhdGU8VCwgSWQ+LCBJZD47XG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9yczxWPihzZWxlY3RTdGF0ZTogKHN0YXRlOiBWKSA9PiBFbnRpdHlTdGF0ZTxULCBJZD4sIG9wdGlvbnM/OiBHZXRTZWxlY3RvcnNPcHRpb25zKTogRW50aXR5U2VsZWN0b3JzPFQsIFYsIElkPjtcbiAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JzPFY+KHNlbGVjdFN0YXRlPzogKHN0YXRlOiBWKSA9PiBFbnRpdHlTdGF0ZTxULCBJZD4sIG9wdGlvbnM6IEdldFNlbGVjdG9yc09wdGlvbnMgPSB7fSk6IEVudGl0eVNlbGVjdG9yczxULCBhbnksIElkPiB7XG4gICAgY29uc3Qge1xuICAgICAgY3JlYXRlU2VsZWN0b3IgPSBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciBhcyBBbnlDcmVhdGVTZWxlY3RvckZ1bmN0aW9uXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2VsZWN0SWRzID0gKHN0YXRlOiBFbnRpdHlTdGF0ZTxULCBJZD4pID0+IHN0YXRlLmlkcztcbiAgICBjb25zdCBzZWxlY3RFbnRpdGllcyA9IChzdGF0ZTogRW50aXR5U3RhdGU8VCwgSWQ+KSA9PiBzdGF0ZS5lbnRpdGllcztcbiAgICBjb25zdCBzZWxlY3RBbGwgPSBjcmVhdGVTZWxlY3RvcihzZWxlY3RJZHMsIHNlbGVjdEVudGl0aWVzLCAoaWRzLCBlbnRpdGllcyk6IFRbXSA9PiBpZHMubWFwKGlkID0+IGVudGl0aWVzW2lkXSEpKTtcbiAgICBjb25zdCBzZWxlY3RJZCA9IChfOiB1bmtub3duLCBpZDogSWQpID0+IGlkO1xuICAgIGNvbnN0IHNlbGVjdEJ5SWQgPSAoZW50aXRpZXM6IFJlY29yZDxJZCwgVD4sIGlkOiBJZCkgPT4gZW50aXRpZXNbaWRdO1xuICAgIGNvbnN0IHNlbGVjdFRvdGFsID0gY3JlYXRlU2VsZWN0b3Ioc2VsZWN0SWRzLCBpZHMgPT4gaWRzLmxlbmd0aCk7XG4gICAgaWYgKCFzZWxlY3RTdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0SWRzLFxuICAgICAgICBzZWxlY3RFbnRpdGllcyxcbiAgICAgICAgc2VsZWN0QWxsLFxuICAgICAgICBzZWxlY3RUb3RhbCxcbiAgICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3Ioc2VsZWN0RW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0R2xvYmFsaXplZEVudGl0aWVzID0gY3JlYXRlU2VsZWN0b3Ioc2VsZWN0U3RhdGUgYXMgU2VsZWN0b3I8ViwgRW50aXR5U3RhdGU8VCwgSWQ+Piwgc2VsZWN0RW50aXRpZXMpO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RJZHM6IGNyZWF0ZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RJZHMpLFxuICAgICAgc2VsZWN0RW50aXRpZXM6IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyxcbiAgICAgIHNlbGVjdEFsbDogY3JlYXRlU2VsZWN0b3Ioc2VsZWN0U3RhdGUsIHNlbGVjdEFsbCksXG4gICAgICBzZWxlY3RUb3RhbDogY3JlYXRlU2VsZWN0b3Ioc2VsZWN0U3RhdGUsIHNlbGVjdFRvdGFsKSxcbiAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZVNlbGVjdG9yKHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFNlbGVjdG9yc1xuICB9O1xufSIsImltcG9ydCB7IHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlLCBpc0RyYWZ0IH0gZnJvbSAnaW1tZXInO1xuaW1wb3J0IHR5cGUgeyBEcmFmdCB9IGZyb20gJ2ltbWVyJztcbmltcG9ydCB0eXBlIHsgRW50aXR5SWQsIERyYWZ0YWJsZUVudGl0eVN0YXRlLCBQcmV2ZW50QW55IH0gZnJvbSAnLi9tb2RlbHMnO1xuaW1wb3J0IHR5cGUgeyBQYXlsb2FkQWN0aW9uIH0gZnJvbSAnLi4vY3JlYXRlQWN0aW9uJztcbmltcG9ydCB7IGlzRlNBIH0gZnJvbSAnLi4vY3JlYXRlQWN0aW9uJztcbmV4cG9ydCBjb25zdCBpc0RyYWZ0VHlwZWQgPSBpc0RyYWZ0IGFzIDxUPih2YWx1ZTogVCB8IERyYWZ0PFQ+KSA9PiB2YWx1ZSBpcyBEcmFmdDxUPjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3I8VCwgSWQgZXh0ZW5kcyBFbnRpdHlJZD4obXV0YXRvcjogKHN0YXRlOiBEcmFmdGFibGVFbnRpdHlTdGF0ZTxULCBJZD4pID0+IHZvaWQpIHtcbiAgY29uc3Qgb3BlcmF0b3IgPSBjcmVhdGVTdGF0ZU9wZXJhdG9yKChfOiB1bmRlZmluZWQsIHN0YXRlOiBEcmFmdGFibGVFbnRpdHlTdGF0ZTxULCBJZD4pID0+IG11dGF0b3Ioc3RhdGUpKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbjxTIGV4dGVuZHMgRHJhZnRhYmxlRW50aXR5U3RhdGU8VCwgSWQ+PihzdGF0ZTogUHJldmVudEFueTxTLCBULCBJZD4pOiBTIHtcbiAgICByZXR1cm4gb3BlcmF0b3Ioc3RhdGUgYXMgUywgdW5kZWZpbmVkKTtcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdGF0ZU9wZXJhdG9yPFQsIElkIGV4dGVuZHMgRW50aXR5SWQsIFI+KG11dGF0b3I6IChhcmc6IFIsIHN0YXRlOiBEcmFmdGFibGVFbnRpdHlTdGF0ZTxULCBJZD4pID0+IHZvaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbjxTIGV4dGVuZHMgRHJhZnRhYmxlRW50aXR5U3RhdGU8VCwgSWQ+PihzdGF0ZTogUywgYXJnOiBSIHwgUGF5bG9hZEFjdGlvbjxSPik6IFMge1xuICAgIGZ1bmN0aW9uIGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZzogUiB8IFBheWxvYWRBY3Rpb248Uj4pOiBhcmcgaXMgUGF5bG9hZEFjdGlvbjxSPiB7XG4gICAgICByZXR1cm4gaXNGU0EoYXJnKTtcbiAgICB9XG4gICAgY29uc3QgcnVuTXV0YXRvciA9IChkcmFmdDogRHJhZnRhYmxlRW50aXR5U3RhdGU8VCwgSWQ+KSA9PiB7XG4gICAgICBpZiAoaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnKSkge1xuICAgICAgICBtdXRhdG9yKGFyZy5wYXlsb2FkLCBkcmFmdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdXRhdG9yKGFyZywgZHJhZnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzRHJhZnRUeXBlZDxEcmFmdGFibGVFbnRpdHlTdGF0ZTxULCBJZD4+KHN0YXRlKSkge1xuICAgICAgLy8gd2UgbXVzdCBhbHJlYWR5IGJlIGluc2lkZSBhIGBjcmVhdGVOZXh0U3RhdGVgIGNhbGwsIGxpa2VseSBiZWNhdXNlXG4gICAgICAvLyB0aGlzIGlzIGJlaW5nIHdyYXBwZWQgaW4gYGNyZWF0ZVJlZHVjZXJgIG9yIGBjcmVhdGVTbGljZWAuXG4gICAgICAvLyBJdCdzIHNhZmUgdG8ganVzdCBwYXNzIHRoZSBkcmFmdCB0byB0aGUgbXV0YXRvci5cbiAgICAgIHJ1bk11dGF0b3Ioc3RhdGUpO1xuXG4gICAgICAvLyBzaW5jZSBpdCdzIGEgZHJhZnQsIHdlJ2xsIGp1c3QgcmV0dXJuIGl0XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVOZXh0U3RhdGUoc3RhdGUsIHJ1bk11dGF0b3IpO1xuICB9O1xufSIsImltcG9ydCB0eXBlIHsgRHJhZnQgfSBmcm9tICdpbW1lcic7XG5pbXBvcnQgeyBjdXJyZW50LCBpc0RyYWZ0IH0gZnJvbSAnaW1tZXInO1xuaW1wb3J0IHR5cGUgeyBEcmFmdGFibGVFbnRpdHlTdGF0ZSwgRW50aXR5SWQsIElkU2VsZWN0b3IsIFVwZGF0ZSB9IGZyb20gJy4vbW9kZWxzJztcbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RJZFZhbHVlPFQsIElkIGV4dGVuZHMgRW50aXR5SWQ+KGVudGl0eTogVCwgc2VsZWN0SWQ6IElkU2VsZWN0b3I8VCwgSWQ+KSB7XG4gIGNvbnN0IGtleSA9IHNlbGVjdElkKGVudGl0eSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKCdUaGUgZW50aXR5IHBhc3NlZCB0byB0aGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCB1bmRlZmluZWQuJywgJ1lvdSBzaG91bGQgcHJvYmFibHkgcHJvdmlkZSB5b3VyIG93biBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uLicsICdUaGUgZW50aXR5IHRoYXQgd2FzIHBhc3NlZDonLCBlbnRpdHksICdUaGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbjonLCBzZWxlY3RJZC50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUVudGl0aWVzQXJyYXk8VCwgSWQgZXh0ZW5kcyBFbnRpdHlJZD4oZW50aXRpZXM6IHJlYWRvbmx5IFRbXSB8IFJlY29yZDxJZCwgVD4pOiByZWFkb25seSBUW10ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZW50aXRpZXMpKSB7XG4gICAgZW50aXRpZXMgPSBPYmplY3QudmFsdWVzKGVudGl0aWVzKTtcbiAgfVxuICByZXR1cm4gZW50aXRpZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudDxUPih2YWx1ZTogVCB8IERyYWZ0PFQ+KTogVCB7XG4gIHJldHVybiAoaXNEcmFmdCh2YWx1ZSkgPyBjdXJyZW50KHZhbHVlKSA6IHZhbHVlKSBhcyBUO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXM8VCwgSWQgZXh0ZW5kcyBFbnRpdHlJZD4obmV3RW50aXRpZXM6IHJlYWRvbmx5IFRbXSB8IFJlY29yZDxJZCwgVD4sIHNlbGVjdElkOiBJZFNlbGVjdG9yPFQsIElkPiwgc3RhdGU6IERyYWZ0YWJsZUVudGl0eVN0YXRlPFQsIElkPik6IFtUW10sIFVwZGF0ZTxULCBJZD5bXSwgSWRbXV0ge1xuICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICBjb25zdCBleGlzdGluZ0lkc0FycmF5ID0gZ2V0Q3VycmVudChzdGF0ZS5pZHMpO1xuICBjb25zdCBleGlzdGluZ0lkcyA9IG5ldyBTZXQ8SWQ+KGV4aXN0aW5nSWRzQXJyYXkpO1xuICBjb25zdCBhZGRlZDogVFtdID0gW107XG4gIGNvbnN0IGFkZGVkSWRzID0gbmV3IFNldDxJZD4oW10pO1xuICBjb25zdCB1cGRhdGVkOiBVcGRhdGU8VCwgSWQ+W10gPSBbXTtcbiAgZm9yIChjb25zdCBlbnRpdHkgb2YgbmV3RW50aXRpZXMpIHtcbiAgICBjb25zdCBpZCA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKGV4aXN0aW5nSWRzLmhhcyhpZCkgfHwgYWRkZWRJZHMuaGFzKGlkKSkge1xuICAgICAgdXBkYXRlZC5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGNoYW5nZXM6IGVudGl0eVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZGVkSWRzLmFkZChpZCk7XG4gICAgICBhZGRlZC5wdXNoKGVudGl0eSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbYWRkZWQsIHVwZGF0ZWQsIGV4aXN0aW5nSWRzQXJyYXldO1xufSIsImltcG9ydCB0eXBlIHsgRHJhZnQgfSBmcm9tICdpbW1lcic7XG5pbXBvcnQgdHlwZSB7IEVudGl0eVN0YXRlQWRhcHRlciwgSWRTZWxlY3RvciwgVXBkYXRlLCBFbnRpdHlJZCwgRHJhZnRhYmxlRW50aXR5U3RhdGUgfSBmcm9tICcuL21vZGVscyc7XG5pbXBvcnQgeyBjcmVhdGVTdGF0ZU9wZXJhdG9yLCBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IgfSBmcm9tICcuL3N0YXRlX2FkYXB0ZXInO1xuaW1wb3J0IHsgc2VsZWN0SWRWYWx1ZSwgZW5zdXJlRW50aXRpZXNBcnJheSwgc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyB9IGZyb20gJy4vdXRpbHMnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyPFQsIElkIGV4dGVuZHMgRW50aXR5SWQ+KHNlbGVjdElkOiBJZFNlbGVjdG9yPFQsIElkPik6IEVudGl0eVN0YXRlQWRhcHRlcjxULCBJZD4ge1xuICB0eXBlIFIgPSBEcmFmdGFibGVFbnRpdHlTdGF0ZTxULCBJZD47XG4gIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5OiBULCBzdGF0ZTogUik6IHZvaWQge1xuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGF0ZS5pZHMucHVzaChrZXkgYXMgSWQgJiBEcmFmdDxJZD4pO1xuICAgIChzdGF0ZS5lbnRpdGllcyBhcyBSZWNvcmQ8SWQsIFQ+KVtrZXldID0gZW50aXR5O1xuICB9XG4gIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzOiByZWFkb25seSBUW10gfCBSZWNvcmQ8SWQsIFQ+LCBzdGF0ZTogUik6IHZvaWQge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgbmV3RW50aXRpZXMpIHtcbiAgICAgIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldE9uZU11dGFibHkoZW50aXR5OiBULCBzdGF0ZTogUik6IHZvaWQge1xuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKCEoa2V5IGluIHN0YXRlLmVudGl0aWVzKSkge1xuICAgICAgc3RhdGUuaWRzLnB1c2goa2V5IGFzIElkICYgRHJhZnQ8SWQ+KTtcbiAgICB9XG4gICAgO1xuICAgIChzdGF0ZS5lbnRpdGllcyBhcyBSZWNvcmQ8SWQsIFQ+KVtrZXldID0gZW50aXR5O1xuICB9XG4gIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzOiByZWFkb25seSBUW10gfCBSZWNvcmQ8SWQsIFQ+LCBzdGF0ZTogUik6IHZvaWQge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgbmV3RW50aXRpZXMpIHtcbiAgICAgIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXM6IHJlYWRvbmx5IFRbXSB8IFJlY29yZDxJZCwgVD4sIHN0YXRlOiBSKTogdm9pZCB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBzdGF0ZS5pZHMgPSBbXTtcbiAgICBzdGF0ZS5lbnRpdGllcyA9IHt9IGFzIFJlY29yZDxJZCwgVD47XG4gICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVPbmVNdXRhYmx5KGtleTogSWQsIHN0YXRlOiBSKTogdm9pZCB7XG4gICAgcmV0dXJuIHJlbW92ZU1hbnlNdXRhYmx5KFtrZXldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlTWFueU11dGFibHkoa2V5czogcmVhZG9ubHkgSWRbXSwgc3RhdGU6IFIpOiB2b2lkIHtcbiAgICBsZXQgZGlkTXV0YXRlID0gZmFsc2U7XG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICAgIGRlbGV0ZSAoc3RhdGUuZW50aXRpZXMgYXMgUmVjb3JkPElkLCBUPilba2V5XTtcbiAgICAgICAgZGlkTXV0YXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZGlkTXV0YXRlKSB7XG4gICAgICBzdGF0ZS5pZHMgPSAoc3RhdGUuaWRzIGFzIElkW10pLmZpbHRlcihpZCA9PiBpZCBpbiBzdGF0ZS5lbnRpdGllcykgYXMgSWRbXSB8IERyYWZ0PElkW10+O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVBbGxNdXRhYmx5KHN0YXRlOiBSKTogdm9pZCB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZSwge1xuICAgICAgaWRzOiBbXSxcbiAgICAgIGVudGl0aWVzOiB7fVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRha2VOZXdLZXkoa2V5czoge1xuICAgIFtpZDogc3RyaW5nXTogSWQ7XG4gIH0sIHVwZGF0ZTogVXBkYXRlPFQsIElkPiwgc3RhdGU6IFIpOiBib29sZWFuIHtcbiAgICBjb25zdCBvcmlnaW5hbDogVCB8IHVuZGVmaW5lZCA9IChzdGF0ZS5lbnRpdGllcyBhcyBSZWNvcmQ8SWQsIFQ+KVt1cGRhdGUuaWRdO1xuICAgIGlmIChvcmlnaW5hbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZWQ6IFQgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbCwgdXBkYXRlLmNoYW5nZXMpO1xuICAgIGNvbnN0IG5ld0tleSA9IHNlbGVjdElkVmFsdWUodXBkYXRlZCwgc2VsZWN0SWQpO1xuICAgIGNvbnN0IGhhc05ld0tleSA9IG5ld0tleSAhPT0gdXBkYXRlLmlkO1xuICAgIGlmIChoYXNOZXdLZXkpIHtcbiAgICAgIGtleXNbdXBkYXRlLmlkXSA9IG5ld0tleTtcbiAgICAgIGRlbGV0ZSAoc3RhdGUuZW50aXRpZXMgYXMgUmVjb3JkPElkLCBUPilbdXBkYXRlLmlkXTtcbiAgICB9XG4gICAgO1xuICAgIChzdGF0ZS5lbnRpdGllcyBhcyBSZWNvcmQ8SWQsIFQ+KVtuZXdLZXldID0gdXBkYXRlZDtcbiAgICByZXR1cm4gaGFzTmV3S2V5O1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU9uZU11dGFibHkodXBkYXRlOiBVcGRhdGU8VCwgSWQ+LCBzdGF0ZTogUik6IHZvaWQge1xuICAgIHJldHVybiB1cGRhdGVNYW55TXV0YWJseShbdXBkYXRlXSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXM6IFJlYWRvbmx5QXJyYXk8VXBkYXRlPFQsIElkPj4sIHN0YXRlOiBSKTogdm9pZCB7XG4gICAgY29uc3QgbmV3S2V5czoge1xuICAgICAgW2lkOiBzdHJpbmddOiBJZDtcbiAgICB9ID0ge307XG4gICAgY29uc3QgdXBkYXRlc1BlckVudGl0eToge1xuICAgICAgW2lkOiBzdHJpbmddOiBVcGRhdGU8VCwgSWQ+O1xuICAgIH0gPSB7fTtcbiAgICB1cGRhdGVzLmZvckVhY2godXBkYXRlID0+IHtcbiAgICAgIC8vIE9ubHkgYXBwbHkgdXBkYXRlcyB0byBlbnRpdGllcyB0aGF0IGN1cnJlbnRseSBleGlzdFxuICAgICAgaWYgKHVwZGF0ZS5pZCBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgdXBkYXRlcyB0byBvbmUgZW50aXR5LCBtZXJnZSB0aGVtIHRvZ2V0aGVyXG4gICAgICAgIHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA9IHtcbiAgICAgICAgICBpZDogdXBkYXRlLmlkLFxuICAgICAgICAgIC8vIFNwcmVhZHMgaWdub3JlIGZhbHN5IHZhbHVlcywgc28gdGhpcyB3b3JrcyBldmVuIGlmIHRoZXJlIGlzbid0XG4gICAgICAgICAgLy8gYW4gZXhpc3RpbmcgdXBkYXRlIGFscmVhZHkgYXQgdGhpcyBrZXlcbiAgICAgICAgICBjaGFuZ2VzOiB7XG4gICAgICAgICAgICAuLi51cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0/LmNoYW5nZXMsXG4gICAgICAgICAgICAuLi51cGRhdGUuY2hhbmdlc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1cGRhdGVzID0gT2JqZWN0LnZhbHVlcyh1cGRhdGVzUGVyRW50aXR5KTtcbiAgICBjb25zdCBkaWRNdXRhdGVFbnRpdGllcyA9IHVwZGF0ZXMubGVuZ3RoID4gMDtcbiAgICBpZiAoZGlkTXV0YXRlRW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IGRpZE11dGF0ZUlkcyA9IHVwZGF0ZXMuZmlsdGVyKHVwZGF0ZSA9PiB0YWtlTmV3S2V5KG5ld0tleXMsIHVwZGF0ZSwgc3RhdGUpKS5sZW5ndGggPiAwO1xuICAgICAgaWYgKGRpZE11dGF0ZUlkcykge1xuICAgICAgICBzdGF0ZS5pZHMgPSBPYmplY3QudmFsdWVzKHN0YXRlLmVudGl0aWVzKS5tYXAoZSA9PiBzZWxlY3RJZFZhbHVlKGUgYXMgVCwgc2VsZWN0SWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0T25lTXV0YWJseShlbnRpdHk6IFQsIHN0YXRlOiBSKTogdm9pZCB7XG4gICAgcmV0dXJuIHVwc2VydE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXM6IHJlYWRvbmx5IFRbXSB8IFJlY29yZDxJZCwgVD4sIHN0YXRlOiBSKTogdm9pZCB7XG4gICAgY29uc3QgW2FkZGVkLCB1cGRhdGVkXSA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXM8VCwgSWQ+KG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpO1xuICAgIGFkZE1hbnlNdXRhYmx5KGFkZGVkLCBzdGF0ZSk7XG4gICAgdXBkYXRlTWFueU11dGFibHkodXBkYXRlZCwgc3RhdGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlQWxsOiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IocmVtb3ZlQWxsTXV0YWJseSksXG4gICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxuICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcbiAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcbiAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KSxcbiAgICByZW1vdmVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlT25lTXV0YWJseSksXG4gICAgcmVtb3ZlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVNYW55TXV0YWJseSlcbiAgfTtcbn0iLCJpbXBvcnQgdHlwZSB7IElkU2VsZWN0b3IsIENvbXBhcmVyLCBFbnRpdHlTdGF0ZUFkYXB0ZXIsIFVwZGF0ZSwgRW50aXR5SWQsIERyYWZ0YWJsZUVudGl0eVN0YXRlIH0gZnJvbSAnLi9tb2RlbHMnO1xuaW1wb3J0IHsgY3JlYXRlU3RhdGVPcGVyYXRvciB9IGZyb20gJy4vc3RhdGVfYWRhcHRlcic7XG5pbXBvcnQgeyBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlciB9IGZyb20gJy4vdW5zb3J0ZWRfc3RhdGVfYWRhcHRlcic7XG5pbXBvcnQgeyBzZWxlY3RJZFZhbHVlLCBlbnN1cmVFbnRpdGllc0FycmF5LCBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzLCBnZXRDdXJyZW50IH0gZnJvbSAnLi91dGlscyc7XG5cbi8vIEJvcnJvd2VkIGZyb20gUmVwbGF5XG5leHBvcnQgZnVuY3Rpb24gZmluZEluc2VydEluZGV4PFQ+KHNvcnRlZEl0ZW1zOiBUW10sIGl0ZW06IFQsIGNvbXBhcmlzb25GdW5jdGlvbjogQ29tcGFyZXI8VD4pOiBudW1iZXIge1xuICBsZXQgbG93SW5kZXggPSAwO1xuICBsZXQgaGlnaEluZGV4ID0gc29ydGVkSXRlbXMubGVuZ3RoO1xuICB3aGlsZSAobG93SW5kZXggPCBoaWdoSW5kZXgpIHtcbiAgICBsZXQgbWlkZGxlSW5kZXggPSBsb3dJbmRleCArIGhpZ2hJbmRleCA+Pj4gMTtcbiAgICBjb25zdCBjdXJyZW50SXRlbSA9IHNvcnRlZEl0ZW1zW21pZGRsZUluZGV4XTtcbiAgICBjb25zdCByZXMgPSBjb21wYXJpc29uRnVuY3Rpb24oaXRlbSwgY3VycmVudEl0ZW0pO1xuICAgIGlmIChyZXMgPj0gMCkge1xuICAgICAgbG93SW5kZXggPSBtaWRkbGVJbmRleCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZ2hJbmRleCA9IG1pZGRsZUluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbG93SW5kZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0PFQ+KHNvcnRlZEl0ZW1zOiBUW10sIGl0ZW06IFQsIGNvbXBhcmlzb25GdW5jdGlvbjogQ29tcGFyZXI8VD4pOiBUW10ge1xuICBjb25zdCBpbnNlcnRBdEluZGV4ID0gZmluZEluc2VydEluZGV4KHNvcnRlZEl0ZW1zLCBpdGVtLCBjb21wYXJpc29uRnVuY3Rpb24pO1xuICBzb3J0ZWRJdGVtcy5zcGxpY2UoaW5zZXJ0QXRJbmRleCwgMCwgaXRlbSk7XG4gIHJldHVybiBzb3J0ZWRJdGVtcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXI8VCwgSWQgZXh0ZW5kcyBFbnRpdHlJZD4oc2VsZWN0SWQ6IElkU2VsZWN0b3I8VCwgSWQ+LCBjb21wYXJlcjogQ29tcGFyZXI8VD4pOiBFbnRpdHlTdGF0ZUFkYXB0ZXI8VCwgSWQ+IHtcbiAgdHlwZSBSID0gRHJhZnRhYmxlRW50aXR5U3RhdGU8VCwgSWQ+O1xuICBjb25zdCB7XG4gICAgcmVtb3ZlT25lLFxuICAgIHJlbW92ZU1hbnksXG4gICAgcmVtb3ZlQWxsXG4gIH0gPSBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCk7XG4gIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5OiBULCBzdGF0ZTogUik6IHZvaWQge1xuICAgIHJldHVybiBhZGRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzOiByZWFkb25seSBUW10gfCBSZWNvcmQ8SWQsIFQ+LCBzdGF0ZTogUiwgZXhpc3RpbmdJZHM/OiBJZFtdKTogdm9pZCB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBjb25zdCBleGlzdGluZ0tleXMgPSBuZXcgU2V0PElkPihleGlzdGluZ0lkcyA/PyBnZXRDdXJyZW50KHN0YXRlLmlkcykpO1xuICAgIGNvbnN0IG1vZGVscyA9IG5ld0VudGl0aWVzLmZpbHRlcihtb2RlbCA9PiAhZXhpc3RpbmdLZXlzLmhhcyhzZWxlY3RJZFZhbHVlKG1vZGVsLCBzZWxlY3RJZCkpKTtcbiAgICBpZiAobW9kZWxzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgbWVyZ2VGdW5jdGlvbihzdGF0ZSwgbW9kZWxzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0T25lTXV0YWJseShlbnRpdHk6IFQsIHN0YXRlOiBSKTogdm9pZCB7XG4gICAgcmV0dXJuIHNldE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0TWFueU11dGFibHkobmV3RW50aXRpZXM6IHJlYWRvbmx5IFRbXSB8IFJlY29yZDxJZCwgVD4sIHN0YXRlOiBSKTogdm9pZCB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBpZiAobmV3RW50aXRpZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgbmV3RW50aXRpZXMpIHtcbiAgICAgICAgZGVsZXRlIChzdGF0ZS5lbnRpdGllcyBhcyBSZWNvcmQ8SWQsIFQ+KVtzZWxlY3RJZChpdGVtKV07XG4gICAgICB9XG4gICAgICBtZXJnZUZ1bmN0aW9uKHN0YXRlLCBuZXdFbnRpdGllcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXM6IHJlYWRvbmx5IFRbXSB8IFJlY29yZDxJZCwgVD4sIHN0YXRlOiBSKTogdm9pZCB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBzdGF0ZS5lbnRpdGllcyA9IHt9IGFzIFJlY29yZDxJZCwgVD47XG4gICAgc3RhdGUuaWRzID0gW107XG4gICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlLCBbXSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGU6IFVwZGF0ZTxULCBJZD4sIHN0YXRlOiBSKTogdm9pZCB7XG4gICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlczogUmVhZG9ubHlBcnJheTxVcGRhdGU8VCwgSWQ+Piwgc3RhdGU6IFIpOiB2b2lkIHtcbiAgICBsZXQgYXBwbGllZFVwZGF0ZXMgPSBmYWxzZTtcbiAgICBsZXQgcmVwbGFjZWRJZHMgPSBmYWxzZTtcbiAgICBmb3IgKGxldCB1cGRhdGUgb2YgdXBkYXRlcykge1xuICAgICAgY29uc3QgZW50aXR5OiBUIHwgdW5kZWZpbmVkID0gKHN0YXRlLmVudGl0aWVzIGFzIFJlY29yZDxJZCwgVD4pW3VwZGF0ZS5pZF07XG4gICAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGFwcGxpZWRVcGRhdGVzID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5hc3NpZ24oZW50aXR5LCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICBjb25zdCBuZXdJZCA9IHNlbGVjdElkKGVudGl0eSk7XG4gICAgICBpZiAodXBkYXRlLmlkICE9PSBuZXdJZCkge1xuICAgICAgICAvLyBXZSBkbyBzdXBwb3J0IHRoZSBjYXNlIHdoZXJlIHVwZGF0ZXMgY2FuIGNoYW5nZSBhbiBpdGVtJ3MgSUQuXG4gICAgICAgIC8vIFRoaXMgbWFrZXMgdGhpbmdzIHRyaWNraWVyIC0gZ28gYWhlYWQgYW5kIHN3YXAgdGhlIElEcyBpbiBzdGF0ZSBub3cuXG4gICAgICAgIHJlcGxhY2VkSWRzID0gdHJ1ZTtcbiAgICAgICAgZGVsZXRlIChzdGF0ZS5lbnRpdGllcyBhcyBSZWNvcmQ8SWQsIFQ+KVt1cGRhdGUuaWRdO1xuICAgICAgICBjb25zdCBvbGRJbmRleCA9IChzdGF0ZS5pZHMgYXMgSWRbXSkuaW5kZXhPZih1cGRhdGUuaWQpO1xuICAgICAgICBzdGF0ZS5pZHNbb2xkSW5kZXhdID0gbmV3SWQ7XG4gICAgICAgIChzdGF0ZS5lbnRpdGllcyBhcyBSZWNvcmQ8SWQsIFQ+KVtuZXdJZF0gPSBlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhcHBsaWVkVXBkYXRlcykge1xuICAgICAgbWVyZ2VGdW5jdGlvbihzdGF0ZSwgW10sIGFwcGxpZWRVcGRhdGVzLCByZXBsYWNlZElkcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5OiBULCBzdGF0ZTogUik6IHZvaWQge1xuICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzOiByZWFkb25seSBUW10gfCBSZWNvcmQ8SWQsIFQ+LCBzdGF0ZTogUik6IHZvaWQge1xuICAgIGNvbnN0IFthZGRlZCwgdXBkYXRlZCwgZXhpc3RpbmdJZHNBcnJheV0gPSBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzPFQsIElkPihuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKTtcbiAgICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUsIGV4aXN0aW5nSWRzQXJyYXkpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlZC5sZW5ndGgpIHtcbiAgICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYTogcmVhZG9ubHkgdW5rbm93bltdLCBiOiByZWFkb25seSB1bmtub3duW10pIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gPT09IGJbaV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHR5cGUgTWVyZ2VGdW5jdGlvbiA9IChzdGF0ZTogUiwgYWRkZWRJdGVtczogcmVhZG9ubHkgVFtdLCBhcHBsaWVkVXBkYXRlcz86IGJvb2xlYW4sIHJlcGxhY2VkSWRzPzogYm9vbGVhbikgPT4gdm9pZDtcbiAgY29uc3QgbWVyZ2VGdW5jdGlvbjogTWVyZ2VGdW5jdGlvbiA9IChzdGF0ZSwgYWRkZWRJdGVtcywgYXBwbGllZFVwZGF0ZXMsIHJlcGxhY2VkSWRzKSA9PiB7XG4gICAgY29uc3QgY3VycmVudEVudGl0aWVzID0gZ2V0Q3VycmVudChzdGF0ZS5lbnRpdGllcyk7XG4gICAgY29uc3QgY3VycmVudElkcyA9IGdldEN1cnJlbnQoc3RhdGUuaWRzKTtcbiAgICBjb25zdCBzdGF0ZUVudGl0aWVzID0gc3RhdGUuZW50aXRpZXMgYXMgUmVjb3JkPElkLCBUPjtcbiAgICBsZXQgaWRzOiBJdGVyYWJsZTxJZD4gPSBjdXJyZW50SWRzO1xuICAgIGlmIChyZXBsYWNlZElkcykge1xuICAgICAgaWRzID0gbmV3IFNldChjdXJyZW50SWRzKTtcbiAgICB9XG4gICAgbGV0IHNvcnRlZEVudGl0aWVzOiBUW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgY29uc3QgZW50aXR5ID0gY3VycmVudEVudGl0aWVzW2lkXTtcbiAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgc29ydGVkRW50aXRpZXMucHVzaChlbnRpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3YXNQcmV2aW91c2x5RW1wdHkgPSBzb3J0ZWRFbnRpdGllcy5sZW5ndGggPT09IDA7XG5cbiAgICAvLyBJbnNlcnQvb3ZlcndyaXRlIGFsbCBuZXcvdXBkYXRlZFxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhZGRlZEl0ZW1zKSB7XG4gICAgICBzdGF0ZUVudGl0aWVzW3NlbGVjdElkKGl0ZW0pXSA9IGl0ZW07XG4gICAgICBpZiAoIXdhc1ByZXZpb3VzbHlFbXB0eSkge1xuICAgICAgICAvLyBCaW5hcnkgc2VhcmNoIGluc2VydGlvbiBnZW5lcmFsbHkgcmVxdWlyZXMgZmV3ZXIgY29tcGFyaXNvbnNcbiAgICAgICAgaW5zZXJ0KHNvcnRlZEVudGl0aWVzLCBpdGVtLCBjb21wYXJlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh3YXNQcmV2aW91c2x5RW1wdHkpIHtcbiAgICAgIC8vIEFsbCB3ZSBoYXZlIGlzIHRoZSBpbmNvbWluZyB2YWx1ZXMsIHNvcnQgdGhlbVxuICAgICAgc29ydGVkRW50aXRpZXMgPSBhZGRlZEl0ZW1zLnNsaWNlKCkuc29ydChjb21wYXJlcik7XG4gICAgfSBlbHNlIGlmIChhcHBsaWVkVXBkYXRlcykge1xuICAgICAgLy8gV2Ugc2hvdWxkIGhhdmUgYSBfbW9zdGx5Xy1zb3J0ZWQgYXJyYXkgYWxyZWFkeVxuICAgICAgc29ydGVkRW50aXRpZXMuc29ydChjb21wYXJlcik7XG4gICAgfVxuICAgIGNvbnN0IG5ld1NvcnRlZElkcyA9IHNvcnRlZEVudGl0aWVzLm1hcChzZWxlY3RJZCk7XG4gICAgaWYgKCFhcmVBcnJheXNFcXVhbChjdXJyZW50SWRzLCBuZXdTb3J0ZWRJZHMpKSB7XG4gICAgICBzdGF0ZS5pZHMgPSBuZXdTb3J0ZWRJZHM7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55LFxuICAgIHJlbW92ZUFsbCxcbiAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcbiAgICBzZXRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0T25lTXV0YWJseSksXG4gICAgc2V0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRNYW55TXV0YWJseSksXG4gICAgc2V0QWxsOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldEFsbE11dGFibHkpLFxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxuICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpXG4gIH07XG59IiwiaW1wb3J0IHR5cGUgeyBFbnRpdHlBZGFwdGVyLCBFbnRpdHlJZCwgRW50aXR5QWRhcHRlck9wdGlvbnMgfSBmcm9tICcuL21vZGVscyc7XG5pbXBvcnQgeyBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5IH0gZnJvbSAnLi9lbnRpdHlfc3RhdGUnO1xuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSB9IGZyb20gJy4vc3RhdGVfc2VsZWN0b3JzJztcbmltcG9ydCB7IGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlciB9IGZyb20gJy4vc29ydGVkX3N0YXRlX2FkYXB0ZXInO1xuaW1wb3J0IHsgY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIgfSBmcm9tICcuL3Vuc29ydGVkX3N0YXRlX2FkYXB0ZXInO1xuaW1wb3J0IHR5cGUgeyBXaXRoUmVxdWlyZWRQcm9wIH0gZnJvbSAnLi4vdHNIZWxwZXJzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbnRpdHlBZGFwdGVyPFQsIElkIGV4dGVuZHMgRW50aXR5SWQ+KG9wdGlvbnM6IFdpdGhSZXF1aXJlZFByb3A8RW50aXR5QWRhcHRlck9wdGlvbnM8VCwgSWQ+LCAnc2VsZWN0SWQnPik6IEVudGl0eUFkYXB0ZXI8VCwgSWQ+O1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVudGl0eUFkYXB0ZXI8VCBleHRlbmRzIHtcbiAgaWQ6IEVudGl0eUlkO1xufT4ob3B0aW9ucz86IE9taXQ8RW50aXR5QWRhcHRlck9wdGlvbnM8VCwgVFsnaWQnXT4sICdzZWxlY3RJZCc+KTogRW50aXR5QWRhcHRlcjxULCBUWydpZCddPjtcblxuLyoqXG4gKlxuICogQHBhcmFtIG9wdGlvbnNcbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbnRpdHlBZGFwdGVyPFQ+KG9wdGlvbnM6IEVudGl0eUFkYXB0ZXJPcHRpb25zPFQsIEVudGl0eUlkPiA9IHt9KTogRW50aXR5QWRhcHRlcjxULCBFbnRpdHlJZD4ge1xuICBjb25zdCB7XG4gICAgc2VsZWN0SWQsXG4gICAgc29ydENvbXBhcmVyXG4gIH06IFJlcXVpcmVkPEVudGl0eUFkYXB0ZXJPcHRpb25zPFQsIEVudGl0eUlkPj4gPSB7XG4gICAgc29ydENvbXBhcmVyOiBmYWxzZSxcbiAgICBzZWxlY3RJZDogKGluc3RhbmNlOiBhbnkpID0+IGluc3RhbmNlLmlkLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3Qgc3RhdGVBZGFwdGVyID0gc29ydENvbXBhcmVyID8gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0Q29tcGFyZXIpIDogY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xuICBjb25zdCBzdGF0ZUZhY3RvcnkgPSBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5KHN0YXRlQWRhcHRlcik7XG4gIGNvbnN0IHNlbGVjdG9yc0ZhY3RvcnkgPSBjcmVhdGVTZWxlY3RvcnNGYWN0b3J5PFQsIEVudGl0eUlkPigpO1xuICByZXR1cm4ge1xuICAgIHNlbGVjdElkLFxuICAgIHNvcnRDb21wYXJlcixcbiAgICAuLi5zdGF0ZUZhY3RvcnksXG4gICAgLi4uc2VsZWN0b3JzRmFjdG9yeSxcbiAgICAuLi5zdGF0ZUFkYXB0ZXJcbiAgfTtcbn0iLCJpbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLCBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiwgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHR5cGUgeyBBY3Rpb24sIERpc3BhdGNoLCBNaWRkbGV3YXJlQVBJLCBVbmtub3duQWN0aW9uIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgaXNBY3Rpb24gfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgdHlwZSB7IFRodW5rRGlzcGF0Y2ggfSBmcm9tICdyZWR1eC10aHVuayc7XG5pbXBvcnQgeyBjcmVhdGVBY3Rpb24gfSBmcm9tICcuLi9jcmVhdGVBY3Rpb24nO1xuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSAnLi4vbmFub2lkJztcbmltcG9ydCB7IFRhc2tBYm9ydEVycm9yLCBsaXN0ZW5lckNhbmNlbGxlZCwgbGlzdGVuZXJDb21wbGV0ZWQsIHRhc2tDYW5jZWxsZWQsIHRhc2tDb21wbGV0ZWQgfSBmcm9tICcuL2V4Y2VwdGlvbnMnO1xuaW1wb3J0IHsgY3JlYXRlRGVsYXksIGNyZWF0ZVBhdXNlLCByYWNlV2l0aFNpZ25hbCwgcnVuVGFzaywgdmFsaWRhdGVBY3RpdmUgfSBmcm9tICcuL3Rhc2snO1xuaW1wb3J0IHR5cGUgeyBBYm9ydFNpZ25hbFdpdGhSZWFzb24sIEFkZExpc3RlbmVyT3ZlcmxvYWRzLCBBbnlMaXN0ZW5lclByZWRpY2F0ZSwgQ3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlT3B0aW9ucywgRmFsbGJhY2tBZGRMaXN0ZW5lck9wdGlvbnMsIEZvcmtPcHRpb25zLCBGb3JrZWRUYXNrLCBGb3JrZWRUYXNrRXhlY3V0b3IsIExpc3RlbmVyRW50cnksIExpc3RlbmVyRXJyb3JIYW5kbGVyLCBMaXN0ZW5lckVycm9ySW5mbywgTGlzdGVuZXJNaWRkbGV3YXJlLCBMaXN0ZW5lck1pZGRsZXdhcmVJbnN0YW5jZSwgVGFrZVBhdHRlcm4sIFRhc2tSZXN1bHQsIFR5cGVkQWRkTGlzdGVuZXIsIFR5cGVkQ3JlYXRlTGlzdGVuZXJFbnRyeSwgVHlwZWRSZW1vdmVMaXN0ZW5lciwgVW5zdWJzY3JpYmVMaXN0ZW5lciwgVW5zdWJzY3JpYmVMaXN0ZW5lck9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24sIGFkZEFib3J0U2lnbmFsTGlzdGVuZXIsIGFzc2VydEZ1bmN0aW9uLCBjYXRjaFJlamVjdGlvbiwgbm9vcCB9IGZyb20gJy4vdXRpbHMnO1xuZXhwb3J0IHsgVGFza0Fib3J0RXJyb3IgfSBmcm9tICcuL2V4Y2VwdGlvbnMnO1xuZXhwb3J0IHR5cGUgeyBBc3luY1Rhc2tFeGVjdXRvciwgQ3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlT3B0aW9ucywgRm9ya2VkVGFzaywgRm9ya2VkVGFza0FQSSwgRm9ya2VkVGFza0V4ZWN1dG9yLCBMaXN0ZW5lckVmZmVjdCwgTGlzdGVuZXJFZmZlY3RBUEksIExpc3RlbmVyRXJyb3JIYW5kbGVyLCBMaXN0ZW5lck1pZGRsZXdhcmUsIExpc3RlbmVyTWlkZGxld2FyZUluc3RhbmNlLCBTeW5jVGFza0V4ZWN1dG9yLCBUYXNrQ2FuY2VsbGVkLCBUYXNrUmVqZWN0ZWQsIFRhc2tSZXNvbHZlZCwgVGFza1Jlc3VsdCwgVHlwZWRBZGRMaXN0ZW5lciwgVHlwZWRSZW1vdmVMaXN0ZW5lciwgVHlwZWRTdGFydExpc3RlbmluZywgVHlwZWRTdG9wTGlzdGVuaW5nLCBVbnN1YnNjcmliZUxpc3RlbmVyLCBVbnN1YnNjcmliZUxpc3RlbmVyT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG4vL092ZXJseS1hZ2dyZXNzaXZlIGJ5dGUtc2hhdmluZ1xuY29uc3Qge1xuICBhc3NpZ25cbn0gPSBPYmplY3Q7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBJTlRFUk5BTF9OSUxfVE9LRU4gPSB7fSBhcyBjb25zdDtcbmNvbnN0IGFsbSA9ICdsaXN0ZW5lck1pZGRsZXdhcmUnIGFzIGNvbnN0O1xuY29uc3QgY3JlYXRlRm9yayA9IChwYXJlbnRBYm9ydFNpZ25hbDogQWJvcnRTaWduYWxXaXRoUmVhc29uPHVua25vd24+LCBwYXJlbnRCbG9ja2luZ1Byb21pc2VzOiBQcm9taXNlPGFueT5bXSkgPT4ge1xuICBjb25zdCBsaW5rQ29udHJvbGxlcnMgPSAoY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyKSA9PiBhZGRBYm9ydFNpZ25hbExpc3RlbmVyKHBhcmVudEFib3J0U2lnbmFsLCAoKSA9PiBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIHBhcmVudEFib3J0U2lnbmFsLnJlYXNvbikpO1xuICByZXR1cm4gPFQsPih0YXNrRXhlY3V0b3I6IEZvcmtlZFRhc2tFeGVjdXRvcjxUPiwgb3B0cz86IEZvcmtPcHRpb25zKTogRm9ya2VkVGFzazxUPiA9PiB7XG4gICAgYXNzZXJ0RnVuY3Rpb24odGFza0V4ZWN1dG9yLCAndGFza0V4ZWN1dG9yJyk7XG4gICAgY29uc3QgY2hpbGRBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGlua0NvbnRyb2xsZXJzKGNoaWxkQWJvcnRDb250cm9sbGVyKTtcbiAgICBjb25zdCByZXN1bHQgPSBydW5UYXNrPFQ+KGFzeW5jICgpOiBQcm9taXNlPFQ+ID0+IHtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHBhcmVudEFib3J0U2lnbmFsKTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICBjb25zdCByZXN1bHQgPSAoYXdhaXQgdGFza0V4ZWN1dG9yKHtcbiAgICAgICAgcGF1c2U6IGNyZWF0ZVBhdXNlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgIGRlbGF5OiBjcmVhdGVEZWxheShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICBzaWduYWw6IGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICAgfSkpIGFzIFQ7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCAoKSA9PiBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ29tcGxldGVkKSk7XG4gICAgaWYgKG9wdHM/LmF1dG9Kb2luKSB7XG4gICAgICBwYXJlbnRCbG9ja2luZ1Byb21pc2VzLnB1c2gocmVzdWx0LmNhdGNoKG5vb3ApKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogY3JlYXRlUGF1c2U8VGFza1Jlc3VsdDxUPj4ocGFyZW50QWJvcnRTaWduYWwpKHJlc3VsdCksXG4gICAgICBjYW5jZWwoKSB7XG4gICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDYW5jZWxsZWQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xuY29uc3QgY3JlYXRlVGFrZVBhdHRlcm4gPSA8Uyw+KHN0YXJ0TGlzdGVuaW5nOiBBZGRMaXN0ZW5lck92ZXJsb2FkczxVbnN1YnNjcmliZUxpc3RlbmVyLCBTLCBEaXNwYXRjaD4sIHNpZ25hbDogQWJvcnRTaWduYWwpOiBUYWtlUGF0dGVybjxTPiA9PiB7XG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBMaXN0ZW5lclByZWRpY2F0ZSBhbmQgYW4gb3B0aW9uYWwgdGltZW91dCxcbiAgICogYW5kIHJlc29sdmVzIHdoZW4gZWl0aGVyIHRoZSBwcmVkaWNhdGUgcmV0dXJucyBgdHJ1ZWAgYmFzZWQgb24gYW4gYWN0aW9uXG4gICAqIHN0YXRlIGNvbWJpbmF0aW9uIG9yIHdoZW4gdGhlIHRpbWVvdXQgZXhwaXJlcy5cbiAgICogSWYgdGhlIHBhcmVudCBsaXN0ZW5lciBpcyBjYW5jZWxlZCB3aGlsZSB3YWl0aW5nLCB0aGlzIHdpbGwgdGhyb3cgYVxuICAgKiBUYXNrQWJvcnRFcnJvci5cbiAgICovXG4gIGNvbnN0IHRha2UgPSBhc3luYyA8UCBleHRlbmRzIEFueUxpc3RlbmVyUHJlZGljYXRlPFM+LD4ocHJlZGljYXRlOiBQLCB0aW1lb3V0OiBudW1iZXIgfCB1bmRlZmluZWQpID0+IHtcbiAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuXG4gICAgLy8gUGxhY2Vob2xkZXIgdW5zdWJzY3JpYmUgZnVuY3Rpb24gdW50aWwgdGhlIGxpc3RlbmVyIGlzIGFkZGVkXG4gICAgbGV0IHVuc3Vic2NyaWJlOiBVbnN1YnNjcmliZUxpc3RlbmVyID0gKCkgPT4ge307XG4gICAgY29uc3QgdHVwbGVQcm9taXNlID0gbmV3IFByb21pc2U8W0FjdGlvbiwgUywgU10+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIEluc2lkZSB0aGUgUHJvbWlzZSwgd2Ugc3luY2hyb25vdXNseSBhZGQgdGhlIGxpc3RlbmVyLlxuICAgICAgbGV0IHN0b3BMaXN0ZW5pbmcgPSBzdGFydExpc3RlbmluZyh7XG4gICAgICAgIHByZWRpY2F0ZTogcHJlZGljYXRlIGFzIGFueSxcbiAgICAgICAgZWZmZWN0OiAoYWN0aW9uLCBsaXN0ZW5lckFwaSk6IHZvaWQgPT4ge1xuICAgICAgICAgIC8vIE9uZS1zaG90IGxpc3RlbmVyIHRoYXQgY2xlYW5zIHVwIGFzIHNvb24gYXMgdGhlIHByZWRpY2F0ZSBwYXNzZXNcbiAgICAgICAgICBsaXN0ZW5lckFwaS51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIC8vIFJlc29sdmUgdGhlIHByb21pc2Ugd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMgdGhlIHByZWRpY2F0ZSBzYXdcbiAgICAgICAgICByZXNvbHZlKFthY3Rpb24sIGxpc3RlbmVyQXBpLmdldFN0YXRlKCksIGxpc3RlbmVyQXBpLmdldE9yaWdpbmFsU3RhdGUoKV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgICBzdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBwcm9taXNlczogKFByb21pc2U8bnVsbD4gfCBQcm9taXNlPFtBY3Rpb24sIFMsIFNdPilbXSA9IFt0dXBsZVByb21pc2VdO1xuICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2U8bnVsbD4ocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQsIG51bGwpKSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCByYWNlV2l0aFNpZ25hbChzaWduYWwsIFByb21pc2UucmFjZShwcm9taXNlcykpO1xuICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIEFsd2F5cyBjbGVhbiB1cCB0aGUgbGlzdGVuZXJcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gKChwcmVkaWNhdGU6IEFueUxpc3RlbmVyUHJlZGljYXRlPFM+LCB0aW1lb3V0OiBudW1iZXIgfCB1bmRlZmluZWQpID0+IGNhdGNoUmVqZWN0aW9uKHRha2UocHJlZGljYXRlLCB0aW1lb3V0KSkpIGFzIFRha2VQYXR0ZXJuPFM+O1xufTtcbmNvbnN0IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20gPSAob3B0aW9uczogRmFsbGJhY2tBZGRMaXN0ZW5lck9wdGlvbnMpID0+IHtcbiAgbGV0IHtcbiAgICB0eXBlLFxuICAgIGFjdGlvbkNyZWF0b3IsXG4gICAgbWF0Y2hlcixcbiAgICBwcmVkaWNhdGUsXG4gICAgZWZmZWN0XG4gIH0gPSBvcHRpb25zO1xuICBpZiAodHlwZSkge1xuICAgIHByZWRpY2F0ZSA9IGNyZWF0ZUFjdGlvbih0eXBlKS5tYXRjaDtcbiAgfSBlbHNlIGlmIChhY3Rpb25DcmVhdG9yKSB7XG4gICAgdHlwZSA9IGFjdGlvbkNyZWF0b3IhLnR5cGU7XG4gICAgcHJlZGljYXRlID0gYWN0aW9uQ3JlYXRvci5tYXRjaDtcbiAgfSBlbHNlIGlmIChtYXRjaGVyKSB7XG4gICAgcHJlZGljYXRlID0gbWF0Y2hlcjtcbiAgfSBlbHNlIGlmIChwcmVkaWNhdGUpIHtcbiAgICAvLyBwYXNzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIxKSA6ICdDcmVhdGluZyBvciByZW1vdmluZyBhIGxpc3RlbmVyIHJlcXVpcmVzIG9uZSBvZiB0aGUga25vd24gZmllbGRzIGZvciBtYXRjaGluZyBhbiBhY3Rpb24nKTtcbiAgfVxuICBhc3NlcnRGdW5jdGlvbihlZmZlY3QsICdvcHRpb25zLmxpc3RlbmVyJyk7XG4gIHJldHVybiB7XG4gICAgcHJlZGljYXRlLFxuICAgIHR5cGUsXG4gICAgZWZmZWN0XG4gIH07XG59O1xuXG4vKiogQWNjZXB0cyB0aGUgcG9zc2libGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgYSBsaXN0ZW5lciwgYW5kIHJldHVybnMgYSBmb3JtYXR0ZWQgbGlzdGVuZXIgZW50cnkgKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVMaXN0ZW5lckVudHJ5OiBUeXBlZENyZWF0ZUxpc3RlbmVyRW50cnk8dW5rbm93bj4gPSAvKiBAX19QVVJFX18gKi9hc3NpZ24oKG9wdGlvbnM6IEZhbGxiYWNrQWRkTGlzdGVuZXJPcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIHByZWRpY2F0ZSxcbiAgICBlZmZlY3RcbiAgfSA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyk7XG4gIGNvbnN0IGVudHJ5OiBMaXN0ZW5lckVudHJ5PHVua25vd24+ID0ge1xuICAgIGlkOiBuYW5vaWQoKSxcbiAgICBlZmZlY3QsXG4gICAgdHlwZSxcbiAgICBwcmVkaWNhdGUsXG4gICAgcGVuZGluZzogbmV3IFNldDxBYm9ydENvbnRyb2xsZXI+KCksXG4gICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIoMjIpIDogJ1Vuc3Vic2NyaWJlIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVudHJ5O1xufSwge1xuICB3aXRoVHlwZXM6ICgpID0+IGNyZWF0ZUxpc3RlbmVyRW50cnlcbn0pIGFzIHVua25vd24gYXMgVHlwZWRDcmVhdGVMaXN0ZW5lckVudHJ5PHVua25vd24+O1xuY29uc3QgZmluZExpc3RlbmVyRW50cnkgPSAobGlzdGVuZXJNYXA6IE1hcDxzdHJpbmcsIExpc3RlbmVyRW50cnk+LCBvcHRpb25zOiBGYWxsYmFja0FkZExpc3RlbmVyT3B0aW9ucykgPT4ge1xuICBjb25zdCB7XG4gICAgdHlwZSxcbiAgICBlZmZlY3QsXG4gICAgcHJlZGljYXRlXG4gIH0gPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpO1xuICByZXR1cm4gQXJyYXkuZnJvbShsaXN0ZW5lck1hcC52YWx1ZXMoKSkuZmluZChlbnRyeSA9PiB7XG4gICAgY29uc3QgbWF0Y2hQcmVkaWNhdGVPclR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyBlbnRyeS50eXBlID09PSB0eXBlIDogZW50cnkucHJlZGljYXRlID09PSBwcmVkaWNhdGU7XG4gICAgcmV0dXJuIG1hdGNoUHJlZGljYXRlT3JUeXBlICYmIGVudHJ5LmVmZmVjdCA9PT0gZWZmZWN0O1xuICB9KTtcbn07XG5jb25zdCBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMgPSAoZW50cnk6IExpc3RlbmVyRW50cnk8dW5rbm93biwgRGlzcGF0Y2g8VW5rbm93bkFjdGlvbj4+KSA9PiB7XG4gIGVudHJ5LnBlbmRpbmcuZm9yRWFjaChjb250cm9sbGVyID0+IHtcbiAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcbiAgfSk7XG59O1xuY29uc3QgY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSAobGlzdGVuZXJNYXA6IE1hcDxzdHJpbmcsIExpc3RlbmVyRW50cnk+KSA9PiB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGlzdGVuZXJNYXAuZm9yRWFjaChjYW5jZWxBY3RpdmVMaXN0ZW5lcnMpO1xuICAgIGxpc3RlbmVyTWFwLmNsZWFyKCk7XG4gIH07XG59O1xuXG4vKipcbiAqIFNhZmVseSByZXBvcnRzIGVycm9ycyB0byB0aGUgYGVycm9ySGFuZGxlcmAgcHJvdmlkZWQuXG4gKiBFcnJvcnMgdGhhdCBvY2N1ciBpbnNpZGUgYGVycm9ySGFuZGxlcmAgYXJlIG5vdGlmaWVkIGluIGEgbmV3IHRhc2suXG4gKiBJbnNwaXJlZCBieSBbcnhqcyByZXBvcnRVbmhhbmRsZWRFcnJvcl0oaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9yeGpzL2Jsb2IvNmZhZmNmNTNkYzllNTU3NDM5YjI1ZGViYWVhZGZkMjI0YjI0NWE2Ni9zcmMvaW50ZXJuYWwvdXRpbC9yZXBvcnRVbmhhbmRsZWRFcnJvci50cylcbiAqIEBwYXJhbSBlcnJvckhhbmRsZXJcbiAqIEBwYXJhbSBlcnJvclRvTm90aWZ5XG4gKi9cbmNvbnN0IHNhZmVseU5vdGlmeUVycm9yID0gKGVycm9ySGFuZGxlcjogTGlzdGVuZXJFcnJvckhhbmRsZXIsIGVycm9yVG9Ob3RpZnk6IHVua25vd24sIGVycm9ySW5mbzogTGlzdGVuZXJFcnJvckluZm8pOiB2b2lkID0+IHtcbiAgdHJ5IHtcbiAgICBlcnJvckhhbmRsZXIoZXJyb3JUb05vdGlmeSwgZXJyb3JJbmZvKTtcbiAgfSBjYXRjaCAoZXJyb3JIYW5kbGVyRXJyb3IpIHtcbiAgICAvLyBXZSBjYW5ub3QgbGV0IGFuIGVycm9yIHJhaXNlZCBoZXJlIGJsb2NrIHRoZSBsaXN0ZW5lciBxdWV1ZS5cbiAgICAvLyBUaGUgZXJyb3IgcmFpc2VkIGhlcmUgd2lsbCBiZSBwaWNrZWQgdXAgYnkgYHdpbmRvdy5vbmVycm9yYCwgYHByb2Nlc3Mub24oJ2Vycm9yJylgIGV0Yy4uLlxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyb3JIYW5kbGVyRXJyb3I7XG4gICAgfSwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgYWRkTGlzdGVuZXIgPSAvKiBAX19QVVJFX18gKi9hc3NpZ24oLyogQF9fUFVSRV9fICovY3JlYXRlQWN0aW9uKGAke2FsbX0vYWRkYCksIHtcbiAgd2l0aFR5cGVzOiAoKSA9PiBhZGRMaXN0ZW5lclxufSkgYXMgdW5rbm93biBhcyBUeXBlZEFkZExpc3RlbmVyPHVua25vd24+O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGNsZWFyQWxsTGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlQWxsYCk7XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSAvKiBAX19QVVJFX18gKi9hc3NpZ24oLyogQF9fUFVSRV9fICovY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlYCksIHtcbiAgd2l0aFR5cGVzOiAoKSA9PiByZW1vdmVMaXN0ZW5lclxufSkgYXMgdW5rbm93biBhcyBUeXBlZFJlbW92ZUxpc3RlbmVyPHVua25vd24+O1xuY29uc3QgZGVmYXVsdEVycm9ySGFuZGxlcjogTGlzdGVuZXJFcnJvckhhbmRsZXIgPSAoLi4uYXJnczogdW5rbm93bltdKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoYCR7YWxtfS9lcnJvcmAsIC4uLmFyZ3MpO1xufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUgPSA8U3RhdGVUeXBlID0gdW5rbm93biwgRGlzcGF0Y2hUeXBlIGV4dGVuZHMgRGlzcGF0Y2g8QWN0aW9uPiA9IFRodW5rRGlzcGF0Y2g8U3RhdGVUeXBlLCB1bmtub3duLCBVbmtub3duQWN0aW9uPiwgRXh0cmFBcmd1bWVudCA9IHVua25vd24+KG1pZGRsZXdhcmVPcHRpb25zOiBDcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmVPcHRpb25zPEV4dHJhQXJndW1lbnQ+ID0ge30pID0+IHtcbiAgY29uc3QgbGlzdGVuZXJNYXAgPSBuZXcgTWFwPHN0cmluZywgTGlzdGVuZXJFbnRyeT4oKTtcbiAgY29uc3Qge1xuICAgIGV4dHJhLFxuICAgIG9uRXJyb3IgPSBkZWZhdWx0RXJyb3JIYW5kbGVyXG4gIH0gPSBtaWRkbGV3YXJlT3B0aW9ucztcbiAgYXNzZXJ0RnVuY3Rpb24ob25FcnJvciwgJ29uRXJyb3InKTtcbiAgY29uc3QgaW5zZXJ0RW50cnkgPSAoZW50cnk6IExpc3RlbmVyRW50cnkpID0+IHtcbiAgICBlbnRyeS51bnN1YnNjcmliZSA9ICgpID0+IGxpc3RlbmVyTWFwLmRlbGV0ZShlbnRyeS5pZCk7XG4gICAgbGlzdGVuZXJNYXAuc2V0KGVudHJ5LmlkLCBlbnRyeSk7XG4gICAgcmV0dXJuIChjYW5jZWxPcHRpb25zPzogVW5zdWJzY3JpYmVMaXN0ZW5lck9wdGlvbnMpID0+IHtcbiAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAoY2FuY2VsT3B0aW9ucz8uY2FuY2VsQWN0aXZlKSB7XG4gICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgY29uc3Qgc3RhcnRMaXN0ZW5pbmcgPSAoKG9wdGlvbnM6IEZhbGxiYWNrQWRkTGlzdGVuZXJPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBmaW5kTGlzdGVuZXJFbnRyeShsaXN0ZW5lck1hcCwgb3B0aW9ucykgPz8gY3JlYXRlTGlzdGVuZXJFbnRyeShvcHRpb25zIGFzIGFueSk7XG4gICAgcmV0dXJuIGluc2VydEVudHJ5KGVudHJ5KTtcbiAgfSkgYXMgQWRkTGlzdGVuZXJPdmVybG9hZHM8YW55PjtcbiAgYXNzaWduKHN0YXJ0TGlzdGVuaW5nLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBzdGFydExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgc3RvcExpc3RlbmluZyA9IChvcHRpb25zOiBGYWxsYmFja0FkZExpc3RlbmVyT3B0aW9ucyAmIFVuc3Vic2NyaWJlTGlzdGVuZXJPcHRpb25zKTogYm9vbGVhbiA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBmaW5kTGlzdGVuZXJFbnRyeShsaXN0ZW5lck1hcCwgb3B0aW9ucyk7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS51bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKG9wdGlvbnMuY2FuY2VsQWN0aXZlKSB7XG4gICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhIWVudHJ5O1xuICB9O1xuICBhc3NpZ24oc3RvcExpc3RlbmluZywge1xuICAgIHdpdGhUeXBlczogKCkgPT4gc3RvcExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXIgPSBhc3luYyAoZW50cnk6IExpc3RlbmVyRW50cnk8dW5rbm93biwgRGlzcGF0Y2g8VW5rbm93bkFjdGlvbj4+LCBhY3Rpb246IHVua25vd24sIGFwaTogTWlkZGxld2FyZUFQSSwgZ2V0T3JpZ2luYWxTdGF0ZTogKCkgPT4gU3RhdGVUeXBlKSA9PiB7XG4gICAgY29uc3QgaW50ZXJuYWxUYXNrQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB0YWtlID0gY3JlYXRlVGFrZVBhdHRlcm4oc3RhcnRMaXN0ZW5pbmcgYXMgQWRkTGlzdGVuZXJPdmVybG9hZHM8YW55PiwgaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpO1xuICAgIGNvbnN0IGF1dG9Kb2luUHJvbWlzZXM6IFByb21pc2U8YW55PltdID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGVudHJ5LnBlbmRpbmcuYWRkKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGVudHJ5LmVmZmVjdChhY3Rpb24sXG4gICAgICAvLyBVc2UgYXNzaWduKCkgcmF0aGVyIHRoYW4gLi4uIHRvIGF2b2lkIGV4dHJhIGhlbHBlciBmdW5jdGlvbnMgYWRkZWQgdG8gYnVuZGxlXG4gICAgICBhc3NpZ24oe30sIGFwaSwge1xuICAgICAgICBnZXRPcmlnaW5hbFN0YXRlLFxuICAgICAgICBjb25kaXRpb246IChwcmVkaWNhdGU6IEFueUxpc3RlbmVyUHJlZGljYXRlPGFueT4sIHRpbWVvdXQ/OiBudW1iZXIpID0+IHRha2UocHJlZGljYXRlLCB0aW1lb3V0KS50aGVuKEJvb2xlYW4pLFxuICAgICAgICB0YWtlLFxuICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2U8YW55PihpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgIGV4dHJhLFxuICAgICAgICBzaWduYWw6IGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICBmb3JrOiBjcmVhdGVGb3JrKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsLCBhdXRvSm9pblByb21pc2VzKSxcbiAgICAgICAgdW5zdWJzY3JpYmU6IGVudHJ5LnVuc3Vic2NyaWJlLFxuICAgICAgICBzdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzOiAoKSA9PiB7XG4gICAgICAgICAgZW50cnkucGVuZGluZy5mb3JFYWNoKChjb250cm9sbGVyLCBfLCBzZXQpID0+IHtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSBpbnRlcm5hbFRhc2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICAgICAgICAgICAgICBzZXQuZGVsZXRlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGludGVybmFsVGFza0NvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcbiAgICAgICAgICBlbnRyeS5wZW5kaW5nLmRlbGV0ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGhyb3dJZkNhbmNlbGxlZDogKCkgPT4ge1xuICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgICAgfVxuICAgICAgfSkpKTtcbiAgICB9IGNhdGNoIChsaXN0ZW5lckVycm9yKSB7XG4gICAgICBpZiAoIShsaXN0ZW5lckVycm9yIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IpKSB7XG4gICAgICAgIHNhZmVseU5vdGlmeUVycm9yKG9uRXJyb3IsIGxpc3RlbmVyRXJyb3IsIHtcbiAgICAgICAgICByYWlzZWRCeTogJ2VmZmVjdCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGF1dG9Kb2luUHJvbWlzZXMpO1xuICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihpbnRlcm5hbFRhc2tDb250cm9sbGVyLCBsaXN0ZW5lckNvbXBsZXRlZCk7IC8vIE5vdGlmeSB0aGF0IHRoZSB0YXNrIGhhcyBjb21wbGV0ZWRcbiAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZShsaXN0ZW5lck1hcCk7XG4gIGNvbnN0IG1pZGRsZXdhcmU6IExpc3RlbmVyTWlkZGxld2FyZTxTdGF0ZVR5cGUsIERpc3BhdGNoVHlwZSwgRXh0cmFBcmd1bWVudD4gPSBhcGkgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICAgIGlmICghaXNBY3Rpb24oYWN0aW9uKSkge1xuICAgICAgLy8gd2Ugb25seSB3YW50IHRvIG5vdGlmeSBsaXN0ZW5lcnMgZm9yIGFjdGlvbiBvYmplY3RzXG4gICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoYWRkTGlzdGVuZXIubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHN0YXJ0TGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkIGFzIGFueSk7XG4gICAgfVxuICAgIGlmIChjbGVhckFsbExpc3RlbmVycy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjbGVhckxpc3RlbmVyTWlkZGxld2FyZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVtb3ZlTGlzdGVuZXIubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHN0b3BMaXN0ZW5pbmcoYWN0aW9uLnBheWxvYWQpO1xuICAgIH1cblxuICAgIC8vIE5lZWQgdG8gZ2V0IHRoaXMgc3RhdGUgX2JlZm9yZV8gdGhlIHJlZHVjZXIgcHJvY2Vzc2VzIHRoZSBhY3Rpb25cbiAgICBsZXQgb3JpZ2luYWxTdGF0ZTogU3RhdGVUeXBlIHwgdHlwZW9mIElOVEVSTkFMX05JTF9UT0tFTiA9IGFwaS5nZXRTdGF0ZSgpO1xuXG4gICAgLy8gYGdldE9yaWdpbmFsU3RhdGVgIGNhbiBvbmx5IGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5LlxuICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlZHV4anMvcmVkdXgtdG9vbGtpdC9kaXNjdXNzaW9ucy8xNjQ4I2Rpc2N1c3Npb25jb21tZW50LTE5MzI4MjBcbiAgICBjb25zdCBnZXRPcmlnaW5hbFN0YXRlID0gKCk6IFN0YXRlVHlwZSA9PiB7XG4gICAgICBpZiAob3JpZ2luYWxTdGF0ZSA9PT0gSU5URVJOQUxfTklMX1RPS0VOKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMoMjMpIDogYCR7YWxtfTogZ2V0T3JpZ2luYWxTdGF0ZSBjYW4gb25seSBiZSBjYWxsZWQgc3luY2hyb25vdXNseWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsU3RhdGUgYXMgU3RhdGVUeXBlO1xuICAgIH07XG4gICAgbGV0IHJlc3VsdDogdW5rbm93bjtcbiAgICB0cnkge1xuICAgICAgLy8gQWN0dWFsbHkgZm9yd2FyZCB0aGUgYWN0aW9uIHRvIHRoZSByZWR1Y2VyIGJlZm9yZSB3ZSBoYW5kbGUgbGlzdGVuZXJzXG4gICAgICByZXN1bHQgPSBuZXh0KGFjdGlvbik7XG4gICAgICBpZiAobGlzdGVuZXJNYXAuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgICAgIC8vIFdvcmsgYXJvdW5kIEVTQnVpbGQrVFMgdHJhbnNwaWxhdGlvbiBpc3N1ZVxuICAgICAgICBjb25zdCBsaXN0ZW5lckVudHJpZXMgPSBBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBsaXN0ZW5lckVudHJpZXMpIHtcbiAgICAgICAgICBsZXQgcnVuTGlzdGVuZXIgPSBmYWxzZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcnVuTGlzdGVuZXIgPSBlbnRyeS5wcmVkaWNhdGUoYWN0aW9uLCBjdXJyZW50U3RhdGUsIG9yaWdpbmFsU3RhdGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKHByZWRpY2F0ZUVycm9yKSB7XG4gICAgICAgICAgICBydW5MaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgcHJlZGljYXRlRXJyb3IsIHtcbiAgICAgICAgICAgICAgcmFpc2VkQnk6ICdwcmVkaWNhdGUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFydW5MaXN0ZW5lcikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vdGlmeUxpc3RlbmVyKGVudHJ5LCBhY3Rpb24sIGFwaSwgZ2V0T3JpZ2luYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gUmVtb3ZlIGBvcmlnaW5hbFN0YXRlYCBzdG9yZSBmcm9tIHRoaXMgc2NvcGUuXG4gICAgICBvcmlnaW5hbFN0YXRlID0gSU5URVJOQUxfTklMX1RPS0VOO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgc3RhcnRMaXN0ZW5pbmcsXG4gICAgc3RvcExpc3RlbmluZyxcbiAgICBjbGVhckxpc3RlbmVyczogY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmVcbiAgfSBhcyBMaXN0ZW5lck1pZGRsZXdhcmVJbnN0YW5jZTxTdGF0ZVR5cGUsIERpc3BhdGNoVHlwZSwgRXh0cmFBcmd1bWVudD47XG59OyIsImltcG9ydCB0eXBlIHsgU2VyaWFsaXplZEVycm9yIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XG5jb25zdCB0YXNrID0gJ3Rhc2snO1xuY29uc3QgbGlzdGVuZXIgPSAnbGlzdGVuZXInO1xuY29uc3QgY29tcGxldGVkID0gJ2NvbXBsZXRlZCc7XG5jb25zdCBjYW5jZWxsZWQgPSAnY2FuY2VsbGVkJztcblxuLyogVGFza0Fib3J0RXJyb3IgZXJyb3IgY29kZXMgICovXG5leHBvcnQgY29uc3QgdGFza0NhbmNlbGxlZCA9IGB0YXNrLSR7Y2FuY2VsbGVkfWAgYXMgY29uc3Q7XG5leHBvcnQgY29uc3QgdGFza0NvbXBsZXRlZCA9IGB0YXNrLSR7Y29tcGxldGVkfWAgYXMgY29uc3Q7XG5leHBvcnQgY29uc3QgbGlzdGVuZXJDYW5jZWxsZWQgPSBgJHtsaXN0ZW5lcn0tJHtjYW5jZWxsZWR9YCBhcyBjb25zdDtcbmV4cG9ydCBjb25zdCBsaXN0ZW5lckNvbXBsZXRlZCA9IGAke2xpc3RlbmVyfS0ke2NvbXBsZXRlZH1gIGFzIGNvbnN0O1xuZXhwb3J0IGNsYXNzIFRhc2tBYm9ydEVycm9yIGltcGxlbWVudHMgU2VyaWFsaXplZEVycm9yIHtcbiAgbmFtZSA9ICdUYXNrQWJvcnRFcnJvcic7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgY29uc3RydWN0b3IocHVibGljIGNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMubWVzc2FnZSA9IGAke3Rhc2t9ICR7Y2FuY2VsbGVkfSAocmVhc29uOiAke2NvZGV9KWA7XG4gIH1cbn0iLCJpbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB0eXBlIHsgQWJvcnRTaWduYWxXaXRoUmVhc29uIH0gZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgY29uc3QgYXNzZXJ0RnVuY3Rpb246IChmdW5jOiB1bmtub3duLCBleHBlY3RlZDogc3RyaW5nKSA9PiBhc3NlcnRzIGZ1bmMgaXMgKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdW5rbm93biA9IChmdW5jOiB1bmtub3duLCBleHBlY3RlZDogc3RyaW5nKSA9PiB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzIpIDogYCR7ZXhwZWN0ZWR9IGlzIG5vdCBhIGZ1bmN0aW9uYCk7XG4gIH1cbn07XG5leHBvcnQgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuZXhwb3J0IGNvbnN0IGNhdGNoUmVqZWN0aW9uID0gPFQsPihwcm9taXNlOiBQcm9taXNlPFQ+LCBvbkVycm9yID0gbm9vcCk6IFByb21pc2U8VD4gPT4ge1xuICBwcm9taXNlLmNhdGNoKG9uRXJyb3IpO1xuICByZXR1cm4gcHJvbWlzZTtcbn07XG5leHBvcnQgY29uc3QgYWRkQWJvcnRTaWduYWxMaXN0ZW5lciA9IChhYm9ydFNpZ25hbDogQWJvcnRTaWduYWwsIGNhbGxiYWNrOiAoZXZ0OiBFdmVudCkgPT4gdm9pZCkgPT4ge1xuICBhYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGNhbGxiYWNrLCB7XG4gICAgb25jZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuICgpID0+IGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDYWxscyBgYWJvcnRDb250cm9sbGVyLmFib3J0KHJlYXNvbilgIGFuZCBwYXRjaGVzIGBzaWduYWwucmVhc29uYC5cbiAqIGlmIGl0IGlzIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogQXQgdGhlIHRpbWUgb2Ygd3JpdGluZyBgc2lnbmFsLnJlYXNvbmAgaXMgYXZhaWxhYmxlIGluIEZGIGNocm9tZSwgZWRnZSBub2RlIDE3IGFuZCBkZW5vLlxuICogQHBhcmFtIGFib3J0Q29udHJvbGxlclxuICogQHBhcmFtIHJlYXNvblxuICogQHJldHVybnNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0U2lnbmFsL3JlYXNvblxuICovXG5leHBvcnQgY29uc3QgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbiA9IDxULD4oYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIsIHJlYXNvbjogVCk6IHZvaWQgPT4ge1xuICB0eXBlIENvbnN1bWVyPFQ+ID0gKHZhbDogVCkgPT4gdm9pZDtcbiAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbCBhcyBBYm9ydFNpZ25hbFdpdGhSZWFzb248VD47XG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFBhdGNoIGByZWFzb25gIGlmIG5lY2Vzc2FyeS5cbiAgLy8gLSBXZSB1c2UgZGVmaW5lUHJvcGVydHkgaGVyZSBiZWNhdXNlIHJlYXNvbiBpcyBhIGdldHRlciBvZiBgQWJvcnRTaWduYWwuX19wcm90b19fYC5cbiAgLy8gLSBXZSBuZWVkIHRvIHBhdGNoICdyZWFzb24nIGJlZm9yZSBjYWxsaW5nIGAuYWJvcnQoKWAgYmVjYXVzZSBsaXN0ZW5lcnMgdG8gdGhlICdhYm9ydCdcbiAgLy8gZXZlbnQgYXJlIGFyZSBub3RpZmllZCBpbW1lZGlhdGVseS5cbiAgaWYgKCEoJ3JlYXNvbicgaW4gc2lnbmFsKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWduYWwsICdyZWFzb24nLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHJlYXNvbixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgO1xuICAoYWJvcnRDb250cm9sbGVyLmFib3J0IGFzIENvbnN1bWVyPHR5cGVvZiByZWFzb24+KShyZWFzb24pO1xufTsiLCJpbXBvcnQgeyBUYXNrQWJvcnRFcnJvciB9IGZyb20gJy4vZXhjZXB0aW9ucyc7XG5pbXBvcnQgdHlwZSB7IEFib3J0U2lnbmFsV2l0aFJlYXNvbiwgVGFza1Jlc3VsdCB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgYWRkQWJvcnRTaWduYWxMaXN0ZW5lciwgY2F0Y2hSZWplY3Rpb24sIG5vb3AgfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IHJhaXNlcyB7QGxpbmsgVGFza0Fib3J0RXJyb3J9IGlmIHRoZSB0YXNrIHRpZWQgdG8gdGhlIGlucHV0IGBzaWduYWxgIGhhcyBiZWVuIGNhbmNlbGxlZC5cbiAqIEBwYXJhbSBzaWduYWxcbiAqIEBwYXJhbSByZWFzb25cbiAqIEBzZWUge1Rhc2tBYm9ydEVycm9yfVxuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGVBY3RpdmUgPSAoc2lnbmFsOiBBYm9ydFNpZ25hbCk6IHZvaWQgPT4ge1xuICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICByZWFzb25cbiAgICB9ID0gc2lnbmFsIGFzIEFib3J0U2lnbmFsV2l0aFJlYXNvbjxzdHJpbmc+O1xuICAgIHRocm93IG5ldyBUYXNrQWJvcnRFcnJvcihyZWFzb24pO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhY2UgYmV0d2VlbiB0aGUgcHJvbWlzZShzKSBhbmQgdGhlIEFib3J0U2lnbmFsXG4gKiBUaGlzIGF2b2lkcyBgUHJvbWlzZS5yYWNlKClgLXJlbGF0ZWQgbWVtb3J5IGxlYWtzOlxuICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8xNzQ2OSNpc3N1ZWNvbW1lbnQtMzQ5Nzk0OTA5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYWNlV2l0aFNpZ25hbDxUPihzaWduYWw6IEFib3J0U2lnbmFsV2l0aFJlYXNvbjxzdHJpbmc+LCBwcm9taXNlOiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gIGxldCBjbGVhbnVwID0gbm9vcDtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBub3RpZnlSZWplY3Rpb24gPSAoKSA9PiByZWplY3QobmV3IFRhc2tBYm9ydEVycm9yKHNpZ25hbC5yZWFzb24pKTtcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIG5vdGlmeVJlamVjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhbnVwID0gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihzaWduYWwsIG5vdGlmeVJlamVjdGlvbik7XG4gICAgcHJvbWlzZS5maW5hbGx5KCgpID0+IGNsZWFudXAoKSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAvLyBhZnRlciB0aGlzIHBvaW50LCByZXBsYWNlIGBjbGVhbnVwYCB3aXRoIGEgbm9vcCwgc28gdGhlcmUgaXMgbm8gcmVmZXJlbmNlIHRvIGBzaWduYWxgIGFueSBtb3JlXG4gICAgY2xlYW51cCA9IG5vb3A7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJ1bnMgYSB0YXNrIGFuZCByZXR1cm5zIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB7QGxpbmsgVGFza1Jlc3VsdH0uXG4gKiBTZWNvbmQgYXJndW1lbnQgaXMgYW4gb3B0aW9uYWwgYGNsZWFuVXBgIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJ1bnMgYWZ0ZXIgdGFzay5cbiAqXG4gKiAqKk5vdGU6KiogYHJ1blRhc2tgIHJ1bnMgdGhlIGV4ZWN1dG9yIGluIHRoZSBuZXh0IG1pY3JvdGFzay5cbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBjb25zdCBydW5UYXNrID0gYXN5bmMgPFQsPih0YXNrOiAoKSA9PiBQcm9taXNlPFQ+LCBjbGVhblVwPzogKCkgPT4gdm9pZCk6IFByb21pc2U8VGFza1Jlc3VsdDxUPj4gPT4ge1xuICB0cnkge1xuICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGFzaygpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6ICdvaycsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBlcnJvciBpbnN0YW5jZW9mIFRhc2tBYm9ydEVycm9yID8gJ2NhbmNlbGxlZCcgOiAncmVqZWN0ZWQnLFxuICAgICAgZXJyb3JcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIGNsZWFuVXA/LigpO1xuICB9XG59O1xuXG4vKipcbiAqIEdpdmVuIGFuIGlucHV0IGBBYm9ydFNpZ25hbGAgYW5kIGEgcHJvbWlzZSByZXR1cm5zIGFub3RoZXIgcHJvbWlzZSB0aGF0IHJlc29sdmVzXG4gKiBhcyBzb29uIHRoZSBpbnB1dCBwcm9taXNlIGlzIHByb3ZpZGVkIG9yIHJlamVjdHMgYXMgc29vbiBhc1xuICogYEFib3J0U2lnbmFsLmFib3J0YCBpcyBgdHJ1ZWAuXG4gKiBAcGFyYW0gc2lnbmFsXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlUGF1c2UgPSA8VCw+KHNpZ25hbDogQWJvcnRTaWduYWwpID0+IHtcbiAgcmV0dXJuIChwcm9taXNlOiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiA9PiB7XG4gICAgcmV0dXJuIGNhdGNoUmVqZWN0aW9uKHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgcHJvbWlzZSkudGhlbihvdXRwdXQgPT4ge1xuICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSkpO1xuICB9O1xufTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbnB1dCBgQWJvcnRTaWduYWxgIGFuZCBgdGltZW91dE1zYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzXG4gKiBhZnRlciBgdGltZW91dE1zYCBvciByZWplY3RzIGFzIHNvb24gYXMgYEFib3J0U2lnbmFsLmFib3J0YCBpcyBgdHJ1ZWAuXG4gKiBAcGFyYW0gc2lnbmFsXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRGVsYXkgPSAoc2lnbmFsOiBBYm9ydFNpZ25hbCkgPT4ge1xuICBjb25zdCBwYXVzZSA9IGNyZWF0ZVBhdXNlPHZvaWQ+KHNpZ25hbCk7XG4gIHJldHVybiAodGltZW91dE1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICByZXR1cm4gcGF1c2UobmV3IFByb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXRNcykpKTtcbiAgfTtcbn07IiwiaW1wb3J0IHR5cGUgeyBEaXNwYXRjaCwgTWlkZGxld2FyZSwgVW5rbm93bkFjdGlvbiB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IGNvbXBvc2UgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBjcmVhdGVBY3Rpb24gfSBmcm9tICcuLi9jcmVhdGVBY3Rpb24nO1xuaW1wb3J0IHsgaXNBbGxPZiB9IGZyb20gJy4uL21hdGNoZXJzJztcbmltcG9ydCB7IG5hbm9pZCB9IGZyb20gJy4uL25hbm9pZCc7XG5pbXBvcnQgeyBnZXRPckluc2VydENvbXB1dGVkIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBBZGRNaWRkbGV3YXJlLCBEeW5hbWljTWlkZGxld2FyZSwgRHluYW1pY01pZGRsZXdhcmVJbnN0YW5jZSwgTWlkZGxld2FyZUVudHJ5LCBXaXRoTWlkZGxld2FyZSB9IGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IHR5cGUgeyBEeW5hbWljTWlkZGxld2FyZUluc3RhbmNlLCBHZXREaXNwYXRjaFR5cGUgYXMgR2V0RGlzcGF0Y2gsIE1pZGRsZXdhcmVBcGlDb25maWcgfSBmcm9tICcuL3R5cGVzJztcbmNvbnN0IGNyZWF0ZU1pZGRsZXdhcmVFbnRyeSA9IDxTdGF0ZSA9IGFueSwgRGlzcGF0Y2hUeXBlIGV4dGVuZHMgRGlzcGF0Y2g8VW5rbm93bkFjdGlvbj4gPSBEaXNwYXRjaDxVbmtub3duQWN0aW9uPj4obWlkZGxld2FyZTogTWlkZGxld2FyZTxhbnksIFN0YXRlLCBEaXNwYXRjaFR5cGU+KTogTWlkZGxld2FyZUVudHJ5PFN0YXRlLCBEaXNwYXRjaFR5cGU+ID0+ICh7XG4gIG1pZGRsZXdhcmUsXG4gIGFwcGxpZWQ6IG5ldyBNYXAoKVxufSk7XG5jb25zdCBtYXRjaEluc3RhbmNlID0gKGluc3RhbmNlSWQ6IHN0cmluZykgPT4gKGFjdGlvbjogYW55KTogYWN0aW9uIGlzIHtcbiAgbWV0YToge1xuICAgIGluc3RhbmNlSWQ6IHN0cmluZztcbiAgfTtcbn0gPT4gYWN0aW9uPy5tZXRhPy5pbnN0YW5jZUlkID09PSBpbnN0YW5jZUlkO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUR5bmFtaWNNaWRkbGV3YXJlID0gPFN0YXRlID0gYW55LCBEaXNwYXRjaFR5cGUgZXh0ZW5kcyBEaXNwYXRjaDxVbmtub3duQWN0aW9uPiA9IERpc3BhdGNoPFVua25vd25BY3Rpb24+PigpOiBEeW5hbWljTWlkZGxld2FyZUluc3RhbmNlPFN0YXRlLCBEaXNwYXRjaFR5cGU+ID0+IHtcbiAgY29uc3QgaW5zdGFuY2VJZCA9IG5hbm9pZCgpO1xuICBjb25zdCBtaWRkbGV3YXJlTWFwID0gbmV3IE1hcDxNaWRkbGV3YXJlPGFueSwgU3RhdGUsIERpc3BhdGNoVHlwZT4sIE1pZGRsZXdhcmVFbnRyeTxTdGF0ZSwgRGlzcGF0Y2hUeXBlPj4oKTtcbiAgY29uc3Qgd2l0aE1pZGRsZXdhcmUgPSBPYmplY3QuYXNzaWduKGNyZWF0ZUFjdGlvbignZHluYW1pY01pZGRsZXdhcmUvYWRkJywgKC4uLm1pZGRsZXdhcmVzOiBNaWRkbGV3YXJlPGFueSwgU3RhdGUsIERpc3BhdGNoVHlwZT5bXSkgPT4gKHtcbiAgICBwYXlsb2FkOiBtaWRkbGV3YXJlcyxcbiAgICBtZXRhOiB7XG4gICAgICBpbnN0YW5jZUlkXG4gICAgfVxuICB9KSksIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHdpdGhNaWRkbGV3YXJlXG4gIH0pIGFzIFdpdGhNaWRkbGV3YXJlPFN0YXRlLCBEaXNwYXRjaFR5cGU+O1xuICBjb25zdCBhZGRNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiBhZGRNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzOiBNaWRkbGV3YXJlPGFueSwgU3RhdGUsIERpc3BhdGNoVHlwZT5bXSkge1xuICAgIG1pZGRsZXdhcmVzLmZvckVhY2gobWlkZGxld2FyZSA9PiB7XG4gICAgICBnZXRPckluc2VydENvbXB1dGVkKG1pZGRsZXdhcmVNYXAsIG1pZGRsZXdhcmUsIGNyZWF0ZU1pZGRsZXdhcmVFbnRyeSk7XG4gICAgfSk7XG4gIH0sIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IGFkZE1pZGRsZXdhcmVcbiAgfSkgYXMgQWRkTWlkZGxld2FyZTxTdGF0ZSwgRGlzcGF0Y2hUeXBlPjtcbiAgY29uc3QgZ2V0RmluYWxNaWRkbGV3YXJlOiBNaWRkbGV3YXJlPHt9LCBTdGF0ZSwgRGlzcGF0Y2hUeXBlPiA9IGFwaSA9PiB7XG4gICAgY29uc3QgYXBwbGllZE1pZGRsZXdhcmUgPSBBcnJheS5mcm9tKG1pZGRsZXdhcmVNYXAudmFsdWVzKCkpLm1hcChlbnRyeSA9PiBnZXRPckluc2VydENvbXB1dGVkKGVudHJ5LmFwcGxpZWQsIGFwaSwgZW50cnkubWlkZGxld2FyZSkpO1xuICAgIHJldHVybiBjb21wb3NlKC4uLmFwcGxpZWRNaWRkbGV3YXJlKTtcbiAgfTtcbiAgY29uc3QgaXNXaXRoTWlkZGxld2FyZSA9IGlzQWxsT2Yod2l0aE1pZGRsZXdhcmUsIG1hdGNoSW5zdGFuY2UoaW5zdGFuY2VJZCkpO1xuICBjb25zdCBtaWRkbGV3YXJlOiBEeW5hbWljTWlkZGxld2FyZTxTdGF0ZSwgRGlzcGF0Y2hUeXBlPiA9IGFwaSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKGlzV2l0aE1pZGRsZXdhcmUoYWN0aW9uKSkge1xuICAgICAgYWRkTWlkZGxld2FyZSguLi5hY3Rpb24ucGF5bG9hZCk7XG4gICAgICByZXR1cm4gYXBpLmRpc3BhdGNoO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RmluYWxNaWRkbGV3YXJlKGFwaSkobmV4dCkoYWN0aW9uKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtaWRkbGV3YXJlLFxuICAgIGFkZE1pZGRsZXdhcmUsXG4gICAgd2l0aE1pZGRsZXdhcmUsXG4gICAgaW5zdGFuY2VJZFxuICB9O1xufTsiLCJpbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLCBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgdHlwZSB7IFJlZHVjZXIsIFN0YXRlRnJvbVJlZHVjZXJzTWFwT2JqZWN0LCBVbmtub3duQWN0aW9uIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSAnLi9uYW5vaWQnO1xuaW1wb3J0IHR5cGUgeyBJZCwgTm9uVW5kZWZpbmVkLCBUYWlsLCBVbmlvblRvSW50ZXJzZWN0aW9uLCBXaXRoT3B0aW9uYWxQcm9wIH0gZnJvbSAnLi90c0hlbHBlcnMnO1xuaW1wb3J0IHsgZ2V0T3JJbnNlcnRDb21wdXRlZCB9IGZyb20gJy4vdXRpbHMnO1xudHlwZSBTbGljZUxpa2U8UmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcsIFN0YXRlPiA9IHtcbiAgcmVkdWNlclBhdGg6IFJlZHVjZXJQYXRoO1xuICByZWR1Y2VyOiBSZWR1Y2VyPFN0YXRlPjtcbn07XG50eXBlIEFueVNsaWNlTGlrZSA9IFNsaWNlTGlrZTxzdHJpbmcsIGFueT47XG50eXBlIFNsaWNlTGlrZVJlZHVjZXJQYXRoPEEgZXh0ZW5kcyBBbnlTbGljZUxpa2U+ID0gQSBleHRlbmRzIFNsaWNlTGlrZTxpbmZlciBSZWR1Y2VyUGF0aCwgYW55PiA/IFJlZHVjZXJQYXRoIDogbmV2ZXI7XG50eXBlIFNsaWNlTGlrZVN0YXRlPEEgZXh0ZW5kcyBBbnlTbGljZUxpa2U+ID0gQSBleHRlbmRzIFNsaWNlTGlrZTxhbnksIGluZmVyIFN0YXRlPiA/IFN0YXRlIDogbmV2ZXI7XG5leHBvcnQgdHlwZSBXaXRoU2xpY2U8QSBleHRlbmRzIEFueVNsaWNlTGlrZT4gPSB7IFtQYXRoIGluIFNsaWNlTGlrZVJlZHVjZXJQYXRoPEE+XTogU2xpY2VMaWtlU3RhdGU8QT4gfTtcbnR5cGUgUmVkdWNlck1hcCA9IFJlY29yZDxzdHJpbmcsIFJlZHVjZXI+O1xudHlwZSBFeGlzdGluZ1NsaWNlTGlrZTxEZWNsYXJlZFN0YXRlPiA9IHsgW1JlZHVjZXJQYXRoIGluIGtleW9mIERlY2xhcmVkU3RhdGVdOiBTbGljZUxpa2U8UmVkdWNlclBhdGggJiBzdHJpbmcsIE5vblVuZGVmaW5lZDxEZWNsYXJlZFN0YXRlW1JlZHVjZXJQYXRoXT4+IH1ba2V5b2YgRGVjbGFyZWRTdGF0ZV07XG5leHBvcnQgdHlwZSBJbmplY3RDb25maWcgPSB7XG4gIC8qKlxuICAgKiBBbGxvdyByZXBsYWNpbmcgcmVkdWNlciB3aXRoIGEgZGlmZmVyZW50IHJlZmVyZW5jZS4gTm9ybWFsbHksIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duIGlmIGEgZGlmZmVyZW50IHJlZHVjZXIgaW5zdGFuY2UgdG8gdGhlIG9uZSBhbHJlYWR5IGluamVjdGVkIGlzIHVzZWQuXG4gICAqL1xuICBvdmVycmlkZUV4aXN0aW5nPzogYm9vbGVhbjtcbn07XG5cbi8qKlxuICogQSByZWR1Y2VyIHRoYXQgYWxsb3dzIGZvciBzbGljZXMvcmVkdWNlcnMgdG8gYmUgaW5qZWN0ZWQgYWZ0ZXIgaW5pdGlhbGlzYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29tYmluZWRTbGljZVJlZHVjZXI8SW5pdGlhbFN0YXRlLCBEZWNsYXJlZFN0YXRlID0gSW5pdGlhbFN0YXRlPiBleHRlbmRzIFJlZHVjZXI8RGVjbGFyZWRTdGF0ZSwgVW5rbm93bkFjdGlvbiwgUGFydGlhbDxEZWNsYXJlZFN0YXRlPj4ge1xuICAvKipcbiAgICogUHJvdmlkZSBhIHR5cGUgZm9yIHNsaWNlcyB0aGF0IHdpbGwgYmUgaW5qZWN0ZWQgbGF6aWx5LlxuICAgKlxuICAgKiBPbmUgd2F5IHRvIGRvIHRoaXMgd291bGQgYmUgd2l0aCBpbnRlcmZhY2UgbWVyZ2luZzpcbiAgICogYGBgdHNcbiAgICpcbiAgICogZXhwb3J0IGludGVyZmFjZSBMYXp5TG9hZGVkU2xpY2VzIHt9XG4gICAqXG4gICAqIGV4cG9ydCBjb25zdCByb290UmVkdWNlciA9IGNvbWJpbmVTbGljZXMoc3RyaW5nU2xpY2UpLndpdGhMYXp5TG9hZGVkU2xpY2VzPExhenlMb2FkZWRTbGljZXM+KCk7XG4gICAqXG4gICAqIC8vIGVsc2V3aGVyZVxuICAgKlxuICAgKiBkZWNsYXJlIG1vZHVsZSAnLi9yZWR1Y2VyJyB7XG4gICAqICAgZXhwb3J0IGludGVyZmFjZSBMYXp5TG9hZGVkU2xpY2VzIGV4dGVuZHMgV2l0aFNsaWNlPHR5cGVvZiBib29sZWFuU2xpY2U+IHt9XG4gICAqIH1cbiAgICpcbiAgICogY29uc3Qgd2l0aEJvb2xlYW4gPSByb290UmVkdWNlci5pbmplY3QoYm9vbGVhblNsaWNlKTtcbiAgICpcbiAgICogLy8gZWxzZXdoZXJlIGFnYWluXG4gICAqXG4gICAqIGRlY2xhcmUgbW9kdWxlICcuL3JlZHVjZXInIHtcbiAgICogICBleHBvcnQgaW50ZXJmYWNlIExhenlMb2FkZWRTbGljZXMge1xuICAgKiAgICAgY3VzdG9tTmFtZTogQ3VzdG9tU3RhdGVcbiAgICogICB9XG4gICAqIH1cbiAgICpcbiAgICogY29uc3Qgd2l0aEN1c3RvbSA9IHJvb3RSZWR1Y2VyLmluamVjdCh7IHJlZHVjZXJQYXRoOiBcImN1c3RvbU5hbWVcIiwgcmVkdWNlcjogY3VzdG9tU2xpY2UucmVkdWNlciB9KVxuICAgKiBgYGBcbiAgICovXG4gIHdpdGhMYXp5TG9hZGVkU2xpY2VzPExhenkgPSB7fT4oKTogQ29tYmluZWRTbGljZVJlZHVjZXI8SW5pdGlhbFN0YXRlLCBJZDxEZWNsYXJlZFN0YXRlICYgUGFydGlhbDxMYXp5Pj4+O1xuXG4gIC8qKlxuICAgKiBJbmplY3QgYSBzbGljZS5cbiAgICpcbiAgICogQWNjZXB0cyBhbiBpbmRpdmlkdWFsIHNsaWNlLCBSVEtRIEFQSSBpbnN0YW5jZSwgb3IgYSBcInNsaWNlLWxpa2VcIiB7IHJlZHVjZXJQYXRoLCByZWR1Y2VyIH0gb2JqZWN0LlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiByb290UmVkdWNlci5pbmplY3QoYm9vbGVhblNsaWNlKVxuICAgKiByb290UmVkdWNlci5pbmplY3QoYmFzZUFwaSlcbiAgICogcm9vdFJlZHVjZXIuaW5qZWN0KHsgcmVkdWNlclBhdGg6ICdib29sZWFuJyBhcyBjb25zdCwgcmVkdWNlcjogbmV3UmVkdWNlciB9LCB7IG92ZXJyaWRlRXhpc3Rpbmc6IHRydWUgfSlcbiAgICogYGBgXG4gICAqXG4gICAqL1xuICBpbmplY3Q8U2wgZXh0ZW5kcyBJZDxFeGlzdGluZ1NsaWNlTGlrZTxEZWNsYXJlZFN0YXRlPj4+KHNsaWNlOiBTbCwgY29uZmlnPzogSW5qZWN0Q29uZmlnKTogQ29tYmluZWRTbGljZVJlZHVjZXI8SW5pdGlhbFN0YXRlLCBJZDxEZWNsYXJlZFN0YXRlICYgV2l0aFNsaWNlPFNsPj4+O1xuXG4gIC8qKlxuICAgKiBJbmplY3QgYSBzbGljZS5cbiAgICpcbiAgICogQWNjZXB0cyBhbiBpbmRpdmlkdWFsIHNsaWNlLCBSVEtRIEFQSSBpbnN0YW5jZSwgb3IgYSBcInNsaWNlLWxpa2VcIiB7IHJlZHVjZXJQYXRoLCByZWR1Y2VyIH0gb2JqZWN0LlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiByb290UmVkdWNlci5pbmplY3QoYm9vbGVhblNsaWNlKVxuICAgKiByb290UmVkdWNlci5pbmplY3QoYmFzZUFwaSlcbiAgICogcm9vdFJlZHVjZXIuaW5qZWN0KHsgcmVkdWNlclBhdGg6ICdib29sZWFuJyBhcyBjb25zdCwgcmVkdWNlcjogbmV3UmVkdWNlciB9LCB7IG92ZXJyaWRlRXhpc3Rpbmc6IHRydWUgfSlcbiAgICogYGBgXG4gICAqXG4gICAqL1xuICBpbmplY3Q8UmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcsIFN0YXRlPihzbGljZTogU2xpY2VMaWtlPFJlZHVjZXJQYXRoLCBTdGF0ZSAmIChSZWR1Y2VyUGF0aCBleHRlbmRzIGtleW9mIERlY2xhcmVkU3RhdGUgPyBuZXZlciA6IFN0YXRlKT4sIGNvbmZpZz86IEluamVjdENvbmZpZyk6IENvbWJpbmVkU2xpY2VSZWR1Y2VyPEluaXRpYWxTdGF0ZSwgSWQ8RGVjbGFyZWRTdGF0ZSAmIFdpdGhTbGljZTxTbGljZUxpa2U8UmVkdWNlclBhdGgsIFN0YXRlPj4+PjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgc2VsZWN0b3IgdGhhdCBndWFyYW50ZWVzIHRoYXQgdGhlIHNsaWNlcyBpbmplY3RlZCB3aWxsIGhhdmUgYSBkZWZpbmVkIHZhbHVlIHdoZW4gc2VsZWN0b3IgaXMgcnVuLlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBzZWxlY3RCb29sZWFuV2l0aG91dEluamVjdGlvbiA9IChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZS5ib29sZWFuO1xuICAgKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBePyBib29sZWFuIHwgdW5kZWZpbmVkXG4gICAqXG4gICAqIGNvbnN0IHNlbGVjdEJvb2xlYW4gPSByb290UmVkdWNlci5pbmplY3QoYm9vbGVhblNsaWNlKS5zZWxlY3Rvcigoc3RhdGUpID0+IHtcbiAgICogICAvLyBpZiBhY3Rpb24gaGFzbid0IGJlZW4gZGlzcGF0Y2hlZCBzaW5jZSBzbGljZSB3YXMgaW5qZWN0ZWQsIHRoaXMgd291bGQgdXN1YWxseSBiZSB1bmRlZmluZWRcbiAgICogICAvLyBob3dldmVyIHNlbGVjdG9yKCkgdXNlcyBhIFByb3h5IGFyb3VuZCB0aGUgZmlyc3QgcGFyYW1ldGVyIHRvIGVuc3VyZSB0aGF0IGl0IGV2YWx1YXRlcyB0byB0aGUgaW5pdGlhbCBzdGF0ZSBpbnN0ZWFkLCBpZiB1bmRlZmluZWRcbiAgICogICByZXR1cm4gc3RhdGUuYm9vbGVhbjtcbiAgICogICAvLyAgICAgICAgICAgXj8gYm9vbGVhblxuICAgKiB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogSWYgdGhlIHJlZHVjZXIgaXMgbmVzdGVkIGluc2lkZSB0aGUgcm9vdCBzdGF0ZSwgYSBzZWxlY3RTdGF0ZSBjYWxsYmFjayBjYW4gYmUgcGFzc2VkIHRvIHJldHJpZXZlIHRoZSByZWR1Y2VyJ3Mgc3RhdGUuXG4gICAqXG4gICAqIGBgYHRzXG4gICAqXG4gICAqIGV4cG9ydCBpbnRlcmZhY2UgTGF6eUxvYWRlZFNsaWNlcyB7fTtcbiAgICpcbiAgICogZXhwb3J0IGNvbnN0IGlubmVyUmVkdWNlciA9IGNvbWJpbmVTbGljZXMoc3RyaW5nU2xpY2UpLndpdGhMYXp5TG9hZGVkU2xpY2VzPExhenlMb2FkZWRTbGljZXM+KCk7XG4gICAqXG4gICAqIGV4cG9ydCBjb25zdCByb290UmVkdWNlciA9IGNvbWJpbmVTbGljZXMoeyBpbm5lcjogaW5uZXJSZWR1Y2VyIH0pO1xuICAgKlxuICAgKiBleHBvcnQgdHlwZSBSb290U3RhdGUgPSBSZXR1cm5UeXBlPHR5cGVvZiByb290UmVkdWNlcj47XG4gICAqXG4gICAqIC8vIGVsc2V3aGVyZVxuICAgKlxuICAgKiBkZWNsYXJlIG1vZHVsZSBcIi4vcmVkdWNlci50c1wiIHtcbiAgICogIGV4cG9ydCBpbnRlcmZhY2UgTGF6eUxvYWRlZFNsaWNlcyBleHRlbmRzIFdpdGhTbGljZTx0eXBlb2YgYm9vbGVhblNsaWNlPiB7fVxuICAgKiB9XG4gICAqXG4gICAqIGNvbnN0IHdpdGhCb29sID0gaW5uZXJSZWR1Y2VyLmluamVjdChib29sZWFuU2xpY2UpO1xuICAgKlxuICAgKiBjb25zdCBzZWxlY3RCb29sZWFuID0gd2l0aEJvb2wuc2VsZWN0b3IoXG4gICAqICAgKHN0YXRlKSA9PiBzdGF0ZS5ib29sZWFuLFxuICAgKiAgIChyb290U3RhdGU6IFJvb3RTdGF0ZSkgPT4gc3RhdGUuaW5uZXJcbiAgICogKTtcbiAgICogLy8gICAgbm93IGV4cGVjdHMgdG8gYmUgcGFzc2VkIFJvb3RTdGF0ZSBpbnN0ZWFkIG9mIGlubmVyUmVkdWNlciBzdGF0ZVxuICAgKlxuICAgKiBgYGBcbiAgICpcbiAgICogVmFsdWUgcGFzc2VkIHRvIHNlbGVjdG9yRm4gd2lsbCBiZSBhIFByb3h5IC0gdXNlIHNlbGVjdG9yLm9yaWdpbmFsKHByb3h5KSB0byBnZXQgb3JpZ2luYWwgc3RhdGUgdmFsdWUgKHVzZWZ1bCBmb3IgZGVidWdnaW5nKVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBpbmplY3RlZFJlZHVjZXIgPSByb290UmVkdWNlci5pbmplY3QoYm9vbGVhblNsaWNlKTtcbiAgICogY29uc3Qgc2VsZWN0Qm9vbGVhbiA9IGluamVjdGVkUmVkdWNlci5zZWxlY3Rvcigoc3RhdGUpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhpbmplY3RlZFJlZHVjZXIuc2VsZWN0b3Iub3JpZ2luYWwoc3RhdGUpLmJvb2xlYW4pIC8vIHBvc3NpYmx5IHVuZGVmaW5lZFxuICAgKiAgIHJldHVybiBzdGF0ZS5ib29sZWFuXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc2VsZWN0b3I6IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzZWxlY3RvciB0aGF0IGd1YXJhbnRlZXMgdGhhdCB0aGUgc2xpY2VzIGluamVjdGVkIHdpbGwgaGF2ZSBhIGRlZmluZWQgdmFsdWUgd2hlbiBzZWxlY3RvciBpcyBydW4uXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHNlbGVjdEJvb2xlYW5XaXRob3V0SW5qZWN0aW9uID0gKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLmJvb2xlYW47XG4gICAgICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXj8gYm9vbGVhbiB8IHVuZGVmaW5lZFxuICAgICAqXG4gICAgICogY29uc3Qgc2VsZWN0Qm9vbGVhbiA9IHJvb3RSZWR1Y2VyLmluamVjdChib29sZWFuU2xpY2UpLnNlbGVjdG9yKChzdGF0ZSkgPT4ge1xuICAgICAqICAgLy8gaWYgYWN0aW9uIGhhc24ndCBiZWVuIGRpc3BhdGNoZWQgc2luY2Ugc2xpY2Ugd2FzIGluamVjdGVkLCB0aGlzIHdvdWxkIHVzdWFsbHkgYmUgdW5kZWZpbmVkXG4gICAgICogICAvLyBob3dldmVyIHNlbGVjdG9yKCkgdXNlcyBhIFByb3h5IGFyb3VuZCB0aGUgZmlyc3QgcGFyYW1ldGVyIHRvIGVuc3VyZSB0aGF0IGl0IGV2YWx1YXRlcyB0byB0aGUgaW5pdGlhbCBzdGF0ZSBpbnN0ZWFkLCBpZiB1bmRlZmluZWRcbiAgICAgKiAgIHJldHVybiBzdGF0ZS5ib29sZWFuO1xuICAgICAqICAgLy8gICAgICAgICAgIF4/IGJvb2xlYW5cbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVmFsdWUgcGFzc2VkIHRvIHNlbGVjdG9yRm4gd2lsbCBiZSBhIFByb3h5IC0gdXNlIHNlbGVjdG9yLm9yaWdpbmFsKHByb3h5KSB0byBnZXQgb3JpZ2luYWwgc3RhdGUgdmFsdWUgKHVzZWZ1bCBmb3IgZGVidWdnaW5nKVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBpbmplY3RlZFJlZHVjZXIgPSByb290UmVkdWNlci5pbmplY3QoYm9vbGVhblNsaWNlKTtcbiAgICAgKiBjb25zdCBzZWxlY3RCb29sZWFuID0gaW5qZWN0ZWRSZWR1Y2VyLnNlbGVjdG9yKChzdGF0ZSkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coaW5qZWN0ZWRSZWR1Y2VyLnNlbGVjdG9yLm9yaWdpbmFsKHN0YXRlKS5ib29sZWFuKSAvLyB1bmRlZmluZWRcbiAgICAgKiAgIHJldHVybiBzdGF0ZS5ib29sZWFuXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICA8U2VsZWN0b3IgZXh0ZW5kcyAoc3RhdGU6IERlY2xhcmVkU3RhdGUsIC4uLmFyZ3M6IGFueVtdKSA9PiB1bmtub3duPihzZWxlY3RvckZuOiBTZWxlY3Rvcik6IChzdGF0ZTogV2l0aE9wdGlvbmFsUHJvcDxQYXJhbWV0ZXJzPFNlbGVjdG9yPlswXSwgRXhjbHVkZTxrZXlvZiBEZWNsYXJlZFN0YXRlLCBrZXlvZiBJbml0aWFsU3RhdGU+PiwgLi4uYXJnczogVGFpbDxQYXJhbWV0ZXJzPFNlbGVjdG9yPj4pID0+IFJldHVyblR5cGU8U2VsZWN0b3I+O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc2VsZWN0b3IgdGhhdCBndWFyYW50ZWVzIHRoYXQgdGhlIHNsaWNlcyBpbmplY3RlZCB3aWxsIGhhdmUgYSBkZWZpbmVkIHZhbHVlIHdoZW4gc2VsZWN0b3IgaXMgcnVuLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBzZWxlY3RCb29sZWFuV2l0aG91dEluamVjdGlvbiA9IChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZS5ib29sZWFuO1xuICAgICAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF4/IGJvb2xlYW4gfCB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqIGNvbnN0IHNlbGVjdEJvb2xlYW4gPSByb290UmVkdWNlci5pbmplY3QoYm9vbGVhblNsaWNlKS5zZWxlY3Rvcigoc3RhdGUpID0+IHtcbiAgICAgKiAgIC8vIGlmIGFjdGlvbiBoYXNuJ3QgYmVlbiBkaXNwYXRjaGVkIHNpbmNlIHNsaWNlIHdhcyBpbmplY3RlZCwgdGhpcyB3b3VsZCB1c3VhbGx5IGJlIHVuZGVmaW5lZFxuICAgICAqICAgLy8gaG93ZXZlciBzZWxlY3RvcigpIHVzZXMgYSBQcm94eSBhcm91bmQgdGhlIGZpcnN0IHBhcmFtZXRlciB0byBlbnN1cmUgdGhhdCBpdCBldmFsdWF0ZXMgdG8gdGhlIGluaXRpYWwgc3RhdGUgaW5zdGVhZCwgaWYgdW5kZWZpbmVkXG4gICAgICogICByZXR1cm4gc3RhdGUuYm9vbGVhbjtcbiAgICAgKiAgIC8vICAgICAgICAgICBePyBib29sZWFuXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIElmIHRoZSByZWR1Y2VyIGlzIG5lc3RlZCBpbnNpZGUgdGhlIHJvb3Qgc3RhdGUsIGEgc2VsZWN0U3RhdGUgY2FsbGJhY2sgY2FuIGJlIHBhc3NlZCB0byByZXRyaWV2ZSB0aGUgcmVkdWNlcidzIHN0YXRlLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIGludGVyZmFjZSBMYXp5TG9hZGVkU2xpY2VzIHt9O1xuICAgICAqXG4gICAgICogY29uc3QgaW5uZXJSZWR1Y2VyID0gY29tYmluZVNsaWNlcyhzdHJpbmdTbGljZSkud2l0aExhenlMb2FkZWRTbGljZXM8TGF6eUxvYWRlZFNsaWNlcz4oKTtcbiAgICAgKlxuICAgICAqIGNvbnN0IHJvb3RSZWR1Y2VyID0gY29tYmluZVNsaWNlcyh7IGlubmVyOiBpbm5lclJlZHVjZXIgfSk7XG4gICAgICpcbiAgICAgKiB0eXBlIFJvb3RTdGF0ZSA9IFJldHVyblR5cGU8dHlwZW9mIHJvb3RSZWR1Y2VyPjtcbiAgICAgKlxuICAgICAqIC8vIGVsc2V3aGVyZVxuICAgICAqXG4gICAgICogZGVjbGFyZSBtb2R1bGUgXCIuL3JlZHVjZXIudHNcIiB7XG4gICAgICogIGludGVyZmFjZSBMYXp5TG9hZGVkU2xpY2VzIGV4dGVuZHMgV2l0aFNsaWNlPHR5cGVvZiBib29sZWFuU2xpY2U+IHt9XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc3Qgd2l0aEJvb2wgPSBpbm5lclJlZHVjZXIuaW5qZWN0KGJvb2xlYW5TbGljZSk7XG4gICAgICpcbiAgICAgKiBjb25zdCBzZWxlY3RCb29sZWFuID0gd2l0aEJvb2wuc2VsZWN0b3IoXG4gICAgICogICAoc3RhdGUpID0+IHN0YXRlLmJvb2xlYW4sXG4gICAgICogICAocm9vdFN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLmlubmVyXG4gICAgICogKTtcbiAgICAgKiAvLyAgICBub3cgZXhwZWN0cyB0byBiZSBwYXNzZWQgUm9vdFN0YXRlIGluc3RlYWQgb2YgaW5uZXJSZWR1Y2VyIHN0YXRlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFZhbHVlIHBhc3NlZCB0byBzZWxlY3RvckZuIHdpbGwgYmUgYSBQcm94eSAtIHVzZSBzZWxlY3Rvci5vcmlnaW5hbChwcm94eSkgdG8gZ2V0IG9yaWdpbmFsIHN0YXRlIHZhbHVlICh1c2VmdWwgZm9yIGRlYnVnZ2luZylcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgaW5qZWN0ZWRSZWR1Y2VyID0gcm9vdFJlZHVjZXIuaW5qZWN0KGJvb2xlYW5TbGljZSk7XG4gICAgICogY29uc3Qgc2VsZWN0Qm9vbGVhbiA9IGluamVjdGVkUmVkdWNlci5zZWxlY3Rvcigoc3RhdGUpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGluamVjdGVkUmVkdWNlci5zZWxlY3Rvci5vcmlnaW5hbChzdGF0ZSkuYm9vbGVhbikgLy8gcG9zc2libHkgdW5kZWZpbmVkXG4gICAgICogICByZXR1cm4gc3RhdGUuYm9vbGVhblxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgPFNlbGVjdG9yIGV4dGVuZHMgKHN0YXRlOiBEZWNsYXJlZFN0YXRlLCAuLi5hcmdzOiBhbnlbXSkgPT4gdW5rbm93biwgUm9vdFN0YXRlPihzZWxlY3RvckZuOiBTZWxlY3Rvciwgc2VsZWN0U3RhdGU6IChyb290U3RhdGU6IFJvb3RTdGF0ZSwgLi4uYXJnczogVGFpbDxQYXJhbWV0ZXJzPFNlbGVjdG9yPj4pID0+IFdpdGhPcHRpb25hbFByb3A8UGFyYW1ldGVyczxTZWxlY3Rvcj5bMF0sIEV4Y2x1ZGU8a2V5b2YgRGVjbGFyZWRTdGF0ZSwga2V5b2YgSW5pdGlhbFN0YXRlPj4pOiAoc3RhdGU6IFJvb3RTdGF0ZSwgLi4uYXJnczogVGFpbDxQYXJhbWV0ZXJzPFNlbGVjdG9yPj4pID0+IFJldHVyblR5cGU8U2VsZWN0b3I+O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVucHJveGllZCBzdGF0ZS4gVXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG4gICAgICogQHBhcmFtIHN0YXRlIHN0YXRlIFByb3h5LCB0aGF0IGVuc3VyZXMgaW5qZWN0ZWQgcmVkdWNlcnMgaGF2ZSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIG9yaWdpbmFsLCB1bnByb3hpZWQgc3RhdGVcbiAgICAgKiBAdGhyb3dzIGlmIHZhbHVlIHBhc3NlZCBpcyBub3QgYSBzdGF0ZSBQcm94eVxuICAgICAqL1xuICAgIG9yaWdpbmFsOiAoc3RhdGU6IERlY2xhcmVkU3RhdGUpID0+IEluaXRpYWxTdGF0ZSAmIFBhcnRpYWw8RGVjbGFyZWRTdGF0ZT47XG4gIH07XG59XG50eXBlIEluaXRpYWxTdGF0ZTxTbGljZXMgZXh0ZW5kcyBBcnJheTxBbnlTbGljZUxpa2UgfCBSZWR1Y2VyTWFwPj4gPSBVbmlvblRvSW50ZXJzZWN0aW9uPFNsaWNlc1tudW1iZXJdIGV4dGVuZHMgaW5mZXIgU2xpY2UgPyBTbGljZSBleHRlbmRzIEFueVNsaWNlTGlrZSA/IFdpdGhTbGljZTxTbGljZT4gOiBTdGF0ZUZyb21SZWR1Y2Vyc01hcE9iamVjdDxTbGljZT4gOiBuZXZlcj47XG5jb25zdCBpc1NsaWNlTGlrZSA9IChtYXliZVNsaWNlTGlrZTogQW55U2xpY2VMaWtlIHwgUmVkdWNlck1hcCk6IG1heWJlU2xpY2VMaWtlIGlzIEFueVNsaWNlTGlrZSA9PiAncmVkdWNlclBhdGgnIGluIG1heWJlU2xpY2VMaWtlICYmIHR5cGVvZiBtYXliZVNsaWNlTGlrZS5yZWR1Y2VyUGF0aCA9PT0gJ3N0cmluZyc7XG5jb25zdCBnZXRSZWR1Y2VycyA9IChzbGljZXM6IEFycmF5PEFueVNsaWNlTGlrZSB8IFJlZHVjZXJNYXA+KSA9PiBzbGljZXMuZmxhdE1hcChzbGljZU9yTWFwID0+IGlzU2xpY2VMaWtlKHNsaWNlT3JNYXApID8gW1tzbGljZU9yTWFwLnJlZHVjZXJQYXRoLCBzbGljZU9yTWFwLnJlZHVjZXJdIGFzIGNvbnN0XSA6IE9iamVjdC5lbnRyaWVzKHNsaWNlT3JNYXApKTtcbmNvbnN0IE9SSUdJTkFMX1NUQVRFID0gU3ltYm9sLmZvcigncnRrLXN0YXRlLXByb3h5LW9yaWdpbmFsJyk7XG5jb25zdCBpc1N0YXRlUHJveHkgPSAodmFsdWU6IGFueSkgPT4gISF2YWx1ZSAmJiAhIXZhbHVlW09SSUdJTkFMX1NUQVRFXTtcbmNvbnN0IHN0YXRlUHJveHlNYXAgPSBuZXcgV2Vha01hcDxvYmplY3QsIG9iamVjdD4oKTtcbmNvbnN0IGNyZWF0ZVN0YXRlUHJveHkgPSA8U3RhdGUgZXh0ZW5kcyBvYmplY3QsPihzdGF0ZTogU3RhdGUsIHJlZHVjZXJNYXA6IFBhcnRpYWw8UmVjb3JkPFByb3BlcnR5S2V5LCBSZWR1Y2VyPj4sIGluaXRpYWxTdGF0ZUNhY2hlOiBSZWNvcmQ8UHJvcGVydHlLZXksIHVua25vd24+KSA9PiBnZXRPckluc2VydENvbXB1dGVkKHN0YXRlUHJveHlNYXAsIHN0YXRlLCAoKSA9PiBuZXcgUHJveHkoc3RhdGUsIHtcbiAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgIGlmIChwcm9wID09PSBPUklHSU5BTF9TVEFURSkgcmV0dXJuIHRhcmdldDtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGluaXRpYWxTdGF0ZUNhY2hlW3Byb3BdO1xuICAgICAgaWYgKHR5cGVvZiBjYWNoZWQgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gY2FjaGVkO1xuICAgICAgY29uc3QgcmVkdWNlciA9IHJlZHVjZXJNYXBbcHJvcF07XG4gICAgICBpZiAocmVkdWNlcikge1xuICAgICAgICAvLyBlbnN1cmUgYWN0aW9uIHR5cGUgaXMgcmFuZG9tLCB0byBwcmV2ZW50IHJlZHVjZXIgdHJlYXRpbmcgaXQgZGlmZmVyZW50bHlcbiAgICAgICAgY29uc3QgcmVkdWNlclJlc3VsdCA9IHJlZHVjZXIodW5kZWZpbmVkLCB7XG4gICAgICAgICAgdHlwZTogbmFub2lkKClcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVkdWNlclJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjQpIDogYFRoZSBzbGljZSByZWR1Y2VyIGZvciBrZXkgXCIke3Byb3AudG9TdHJpbmcoKX1cIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBjYWxsZWQgZm9yIHNlbGVjdG9yKCkuIGAgKyBgSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGAgKyBgZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBgICsgYG5vdCBiZSB1bmRlZmluZWQuIElmIHlvdSBkb24ndCB3YW50IHRvIHNldCBhIHZhbHVlIGZvciB0aGlzIHJlZHVjZXIsIGAgKyBgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpbml0aWFsU3RhdGVDYWNoZVtwcm9wXSA9IHJlZHVjZXJSZXN1bHQ7XG4gICAgICAgIHJldHVybiByZWR1Y2VyUmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KSkgYXMgU3RhdGU7XG5jb25zdCBvcmlnaW5hbCA9IChzdGF0ZTogYW55KSA9PiB7XG4gIGlmICghaXNTdGF0ZVByb3h5KHN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIoMjUpIDogJ29yaWdpbmFsIG11c3QgYmUgdXNlZCBvbiBzdGF0ZSBQcm94eScpO1xuICB9XG4gIHJldHVybiBzdGF0ZVtPUklHSU5BTF9TVEFURV07XG59O1xuY29uc3QgZW1wdHlPYmplY3QgPSB7fTtcbmNvbnN0IG5vb3BSZWR1Y2VyOiBSZWR1Y2VyPFJlY29yZDxzdHJpbmcsIGFueT4+ID0gKHN0YXRlID0gZW1wdHlPYmplY3QpID0+IHN0YXRlO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVTbGljZXM8U2xpY2VzIGV4dGVuZHMgQXJyYXk8QW55U2xpY2VMaWtlIHwgUmVkdWNlck1hcD4+KC4uLnNsaWNlczogU2xpY2VzKTogQ29tYmluZWRTbGljZVJlZHVjZXI8SWQ8SW5pdGlhbFN0YXRlPFNsaWNlcz4+PiB7XG4gIGNvbnN0IHJlZHVjZXJNYXAgPSBPYmplY3QuZnJvbUVudHJpZXM8UmVkdWNlcj4oZ2V0UmVkdWNlcnMoc2xpY2VzKSk7XG4gIGNvbnN0IGdldFJlZHVjZXIgPSAoKSA9PiBPYmplY3Qua2V5cyhyZWR1Y2VyTWFwKS5sZW5ndGggPyBjb21iaW5lUmVkdWNlcnMocmVkdWNlck1hcCkgOiBub29wUmVkdWNlcjtcbiAgbGV0IHJlZHVjZXIgPSBnZXRSZWR1Y2VyKCk7XG4gIGZ1bmN0aW9uIGNvbWJpbmVkUmVkdWNlcihzdGF0ZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIGFjdGlvbjogVW5rbm93bkFjdGlvbikge1xuICAgIHJldHVybiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICB9XG4gIGNvbWJpbmVkUmVkdWNlci53aXRoTGF6eUxvYWRlZFNsaWNlcyA9ICgpID0+IGNvbWJpbmVkUmVkdWNlcjtcbiAgY29uc3QgaW5pdGlhbFN0YXRlQ2FjaGU6IFJlY29yZDxQcm9wZXJ0eUtleSwgdW5rbm93bj4gPSB7fTtcbiAgY29uc3QgaW5qZWN0ID0gKHNsaWNlOiBBbnlTbGljZUxpa2UsIGNvbmZpZzogSW5qZWN0Q29uZmlnID0ge30pOiB0eXBlb2YgY29tYmluZWRSZWR1Y2VyID0+IHtcbiAgICBjb25zdCB7XG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIHJlZHVjZXI6IHJlZHVjZXJUb0luamVjdFxuICAgIH0gPSBzbGljZTtcbiAgICBjb25zdCBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXJNYXBbcmVkdWNlclBhdGhdO1xuICAgIGlmICghY29uZmlnLm92ZXJyaWRlRXhpc3RpbmcgJiYgY3VycmVudFJlZHVjZXIgJiYgY3VycmVudFJlZHVjZXIgIT09IHJlZHVjZXJUb0luamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBjYWxsZWQgXFxgaW5qZWN0XFxgIHRvIG92ZXJyaWRlIGFscmVhZHktZXhpc3RpbmcgcmVkdWNlciAke3JlZHVjZXJQYXRofSB3aXRob3V0IHNwZWNpZnlpbmcgXFxgb3ZlcnJpZGVFeGlzdGluZzogdHJ1ZVxcYGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbWJpbmVkUmVkdWNlcjtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5vdmVycmlkZUV4aXN0aW5nICYmIGN1cnJlbnRSZWR1Y2VyICE9PSByZWR1Y2VyVG9JbmplY3QpIHtcbiAgICAgIGRlbGV0ZSBpbml0aWFsU3RhdGVDYWNoZVtyZWR1Y2VyUGF0aF07XG4gICAgfVxuICAgIHJlZHVjZXJNYXBbcmVkdWNlclBhdGhdID0gcmVkdWNlclRvSW5qZWN0O1xuICAgIHJlZHVjZXIgPSBnZXRSZWR1Y2VyKCk7XG4gICAgcmV0dXJuIGNvbWJpbmVkUmVkdWNlcjtcbiAgfTtcbiAgY29uc3Qgc2VsZWN0b3IgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIG1ha2VTZWxlY3RvcjxTdGF0ZSBleHRlbmRzIG9iamVjdCwgUm9vdFN0YXRlLCBBcmdzIGV4dGVuZHMgYW55W10+KHNlbGVjdG9yRm46IChzdGF0ZTogU3RhdGUsIC4uLmFyZ3M6IEFyZ3MpID0+IGFueSwgc2VsZWN0U3RhdGU/OiAocm9vdFN0YXRlOiBSb290U3RhdGUsIC4uLmFyZ3M6IEFyZ3MpID0+IFN0YXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNlbGVjdG9yKHN0YXRlOiBTdGF0ZSwgLi4uYXJnczogQXJncykge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yRm4oY3JlYXRlU3RhdGVQcm94eShzZWxlY3RTdGF0ZSA/IHNlbGVjdFN0YXRlKHN0YXRlIGFzIGFueSwgLi4uYXJncykgOiBzdGF0ZSwgcmVkdWNlck1hcCwgaW5pdGlhbFN0YXRlQ2FjaGUpLCAuLi5hcmdzKTtcbiAgICB9O1xuICB9LCB7XG4gICAgb3JpZ2luYWxcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGNvbWJpbmVkUmVkdWNlciwge1xuICAgIGluamVjdCxcbiAgICBzZWxlY3RvclxuICB9KSBhcyBhbnk7XG59IiwiLyoqXHJcbiAqIEFkYXB0ZWQgZnJvbSBSZWFjdDogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3NoYXJlZC9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLmpzXHJcbiAqXHJcbiAqIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIHRocm93IGVycm9yIGNhbGxzLiBUaGVzZSBtZXNzYWdlcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggZXJyb3IgY29kZXNcclxuICogZHVyaW5nIGJ1aWxkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKGNvZGU6IG51bWJlcikge1xuICByZXR1cm4gYE1pbmlmaWVkIFJlZHV4IFRvb2xraXQgZXJyb3IgIyR7Y29kZX07IHZpc2l0IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvRXJyb3JzP2NvZGU9JHtjb2RlfSBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciBgICsgJ3VzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMuICc7XG59Il0sIm5hbWVzIjpbImN1cnJlbnQiLCJvcmlnaW5hbCIsImlzRHJhZnQiLCJjcmVhdGVTZWxlY3RvckNyZWF0b3IiLCJ3ZWFrTWFwTWVtb2l6ZSIsImNyZWF0ZVNlbGVjdG9yIiwiY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IiLCJhcmdzIiwiY29tcG9zZSIsImlzUGxhaW5PYmplY3QiLCJub29wIiwiaXNBY3Rpb25DcmVhdG9yIiwic3RyaW5naWZ5IiwiZ2V0U2VyaWFsaXplIiwiaXNBY3Rpb24iLCJpc0FjdGlvbiIsImxpc3RlbmVyIiwiaXNQbGFpbk9iamVjdCIsIm1pZGRsZXdhcmUiLCJjb21wb3NlIiwiY3JlYXRlTmV4dFN0YXRlIiwiaXNEcmFmdCIsImlzRHJhZnRhYmxlIiwicmVkdWNlciIsImlzRHJhZnQiLCJpc0RyYWZ0YWJsZSIsImNyZWF0ZU5leHRTdGF0ZSIsImNyZWF0ZUFzeW5jVGh1bmsiLCJSZWR1Y2VyVHlwZSIsImNyZWF0ZVNsaWNlIiwicmVkdWNlciIsIm5hbWUiLCJyZWR1Y2VyUGF0aCIsImNyZWF0ZVNlbGVjdG9yIiwiY3JlYXRlTmV4dFN0YXRlIiwiaXNEcmFmdCIsImlzRHJhZnQiLCJhcmciLCJjcmVhdGVOZXh0U3RhdGUiLCJjdXJyZW50IiwiaXNEcmFmdCIsIm9yaWdpbmFsIiwiaXNBY3Rpb24iLCJub29wIiwibm9vcCIsInRhc2siLCJyZXN1bHQiLCJub29wIiwiaXNBY3Rpb24iLCJjb21wb3NlIiwiYWRkTWlkZGxld2FyZSIsIm1pZGRsZXdhcmUiLCJjb21wb3NlIiwiY29tYmluZVJlZHVjZXJzIiwiY29tYmluZVJlZHVjZXJzIiwic2VsZWN0b3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQUEsU0FBUyxTQUFTLGVBQWU7QUFDakMsU0FBUyx1QkFBdUIsc0JBQXNCOztBQ0N0RCxTQUFTLGlCQUFpQixhQUFhLFdBQUFRLFVBQVMsaUJBQWlCLGlCQUFBQyxzQkFBcUI7O0FFQXRGLFNBQVMsU0FBUyxpQkFBaUIseUJB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dUJBQXVCLElBQUEsRUFBYztJQUNuRCxPQUFPLHdDQUFpQyxJQUFJLEVBQUEscURBQXdELE9BQUosSUFBSSxFQUFBO0FBQ3RHIiwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMjg5MSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWR1eC1wZXJzaXN0L2VzL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIEtFWV9QUkVGSVggPSAncGVyc2lzdDonO1xuZXhwb3J0IHZhciBGTFVTSCA9ICdwZXJzaXN0L0ZMVVNIJztcbmV4cG9ydCB2YXIgUkVIWURSQVRFID0gJ3BlcnNpc3QvUkVIWURSQVRFJztcbmV4cG9ydCB2YXIgUEFVU0UgPSAncGVyc2lzdC9QQVVTRSc7XG5leHBvcnQgdmFyIFBFUlNJU1QgPSAncGVyc2lzdC9QRVJTSVNUJztcbmV4cG9ydCB2YXIgUFVSR0UgPSAncGVyc2lzdC9QVVJHRSc7XG5leHBvcnQgdmFyIFJFR0lTVEVSID0gJ3BlcnNpc3QvUkVHSVNURVInO1xuZXhwb3J0IHZhciBERUZBVUxUX1ZFUlNJT04gPSAtMTsiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFPLElBQUksYUFBYTtBQUNqQixJQUFJLFFBQVE7QUFDWixJQUFJLFlBQVk7QUFDaEIsSUFBSSxRQUFRO0FBQ1osSUFBSSxVQUFVO0FBQ2QsSUFBSSxRQUFRO0FBQ1osSUFBSSxXQUFXO0FBQ2YsSUFBSSxrQkFBa0IsQ0FBQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMjkxMywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWR1eC1wZXJzaXN0L2VzL3N0YXRlUmVjb25jaWxlci9hdXRvTWVyZ2VMZXZlbDEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLypcbiAgYXV0b01lcmdlTGV2ZWwxOiBcbiAgICAtIG1lcmdlcyAxIGxldmVsIG9mIHN1YnN0YXRlXG4gICAgLSBza2lwcyBzdWJzdGF0ZSBpZiBhbHJlYWR5IG1vZGlmaWVkXG4qL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b01lcmdlTGV2ZWwxKGluYm91bmRTdGF0ZSwgb3JpZ2luYWxTdGF0ZSwgcmVkdWNlZFN0YXRlLCBfcmVmKSB7XG4gIHZhciBkZWJ1ZyA9IF9yZWYuZGVidWc7XG5cbiAgdmFyIG5ld1N0YXRlID0gX29iamVjdFNwcmVhZCh7fSwgcmVkdWNlZFN0YXRlKTsgLy8gb25seSByZWh5ZHJhdGUgaWYgaW5ib3VuZFN0YXRlIGV4aXN0cyBhbmQgaXMgYW4gb2JqZWN0XG5cblxuICBpZiAoaW5ib3VuZFN0YXRlICYmIF90eXBlb2YoaW5ib3VuZFN0YXRlKSA9PT0gJ29iamVjdCcpIHtcbiAgICBPYmplY3Qua2V5cyhpbmJvdW5kU3RhdGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgLy8gaWdub3JlIF9wZXJzaXN0IGRhdGFcbiAgICAgIGlmIChrZXkgPT09ICdfcGVyc2lzdCcpIHJldHVybjsgLy8gaWYgcmVkdWNlciBtb2RpZmllcyBzdWJzdGF0ZSwgc2tpcCBhdXRvIHJlaHlkcmF0aW9uXG5cbiAgICAgIGlmIChvcmlnaW5hbFN0YXRlW2tleV0gIT09IHJlZHVjZWRTdGF0ZVtrZXldKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRlYnVnKSBjb25zb2xlLmxvZygncmVkdXgtcGVyc2lzdC9zdGF0ZVJlY29uY2lsZXI6IHN1YiBzdGF0ZSBmb3Iga2V5IGAlc2AgbW9kaWZpZWQsIHNraXBwaW5nLicsIGtleSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gb3RoZXJ3aXNlIGhhcmQgc2V0IHRoZSBuZXcgdmFsdWVcblxuXG4gICAgICBuZXdTdGF0ZVtrZXldID0gaW5ib3VuZFN0YXRlW2tleV07XG4gICAgfSk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkZWJ1ZyAmJiBpbmJvdW5kU3RhdGUgJiYgX3R5cGVvZihpbmJvdW5kU3RhdGUpID09PSAnb2JqZWN0JykgY29uc29sZS5sb2coXCJyZWR1eC1wZXJzaXN0L3N0YXRlUmVjb25jaWxlcjogcmVoeWRyYXRlZCBrZXlzICdcIi5jb25jYXQoT2JqZWN0LmtleXMoaW5ib3VuZFN0YXRlKS5qb2luKCcsICcpLCBcIidcIikpO1xuICBy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MF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTI5OTEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVkdXgtcGVyc2lzdC9lcy9jcmVhdGVQZXJzaXN0b2lkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEtFWV9QUkVGSVgsIFJFSFlEUkFURSB9IGZyb20gJy4vY29uc3RhbnRzJztcbi8vIEBUT0RPIHJlbW92ZSBvbmNlIGZsb3cgPCAwLjYzIHN1cHBvcnQgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlUGVyc2lzdG9pZChjb25maWcpIHtcbiAgLy8gZGVmYXVsdHNcbiAgdmFyIGJsYWNrbGlzdCA9IGNvbmZpZy5ibGFja2xpc3QgfHwgbnVsbDtcbiAgdmFyIHdoaXRlbGlzdCA9IGNvbmZpZy53aGl0ZWxpc3QgfHwgbnVsbDtcbiAgdmFyIHRyYW5zZm9ybXMgPSBjb25maWcudHJhbnNmb3JtcyB8fCBbXTtcbiAgdmFyIHRocm90dGxlID0gY29uZmlnLnRocm90dGxlIHx8IDA7XG4gIHZhciBzdG9yYWdlS2V5ID0gXCJcIi5jb25jYXQoY29uZmlnLmtleVByZWZpeCAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmtleVByZWZpeCA6IEtFWV9QUkVGSVgpLmNvbmNhdChjb25maWcua2V5KTtcbiAgdmFyIHN0b3JhZ2UgPSBjb25maWcuc3RvcmFnZTtcbiAgdmFyIHNlcmlhbGl6ZTtcblxuICBpZiAoY29uZmlnLnNlcmlhbGl6ZSA9PT0gZmFsc2UpIHtcbiAgICBzZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29uZmlnLnNlcmlhbGl6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNlcmlhbGl6ZSA9IGNvbmZpZy5zZXJpYWxpemU7XG4gIH0gZWxzZSB7XG4gICAgc2VyaWFsaXplID0gZGVmYXVsdFNlcmlhbGl6ZTtcbiAgfVxuXG4gIHZhciB3cml0ZUZhaWxIYW5kbGVyID0gY29uZmlnLndyaXRlRmFpbEhhbmRsZXIgfHwgbnVsbDsgLy8gaW5pdGlhbGl6ZSBzdGF0ZWZ1bCB2YWx1ZXNcblxuICB2YXIgbGFzdFN0YXRlID0ge307XG4gIHZhciBzdGFnZWRTdGF0ZSA9IHt9O1xuICB2YXIga2V5c1RvUHJvY2VzcyA9IFtdO1xuICB2YXIgdGltZUl0ZXJhdG9yID0gbnVsbDtcbiAgdmFyIHdyaXRlUHJvbWlzZSA9IG51bGw7XG5cbiAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzdGF0ZSkge1xuICAgIC8vIGFkZCBhbnkgY2hhbmdlZCBrZXlzIHRvIHRoZSBxdWV1ZVxuICAgIE9iamVjdC5rZXlzKHN0YXRlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghcGFzc1doaXRlbGlzdEJsYWNrbGlzdChrZXkpKSByZXR1cm47IC8vIGlzIGtleXNwYWNlIGlnbm9yZWQ/IG5vb3BcblxuICAgICAgaWYgKGxhc3RTdGF0ZVtrZXldID09PSBzdGF0ZVtrZXldKSByZXR1cm47IC8vIHZhbHVlIHVuY2hhbmdlZD8gbm9vcFxuXG4gICAgICBpZiAoa2V5c1RvUHJvY2Vzcy5pbmRleE9mKGtleSkgIT09IC0xKSByZXR1cm47IC8vIGlzIGtleSBhbHJlYWR5IHF1ZXVlZD8gbm9vcFxuXG4gICAgICBrZXlzVG9Qcm9jZXNzLnB1c2goa2V5KTsgLy8gYWRkIGtleSB0byBxdWV1ZVxuICAgIH0pOyAvL2lmIGFueSBrZXkgaXMgbWlzc2luZyBpbiB0aGUgbmV3IHN0YXRlIHdoaWNoIHdhcyBwcmVzZW50IGluIHRoZSBsYXN0U3RhdGUsXG4gICAgLy9hZGQgaXQgZm9yIHByb2Nlc3NpbmcgdG9vXG5cbiAgICBPYmplY3Qua2V5cyhsYXN0U3RhdGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKHN0YXRlW2tleV0gPT09IHVuZGVmaW5lZCAmJiBwYXNzV2hpdGVsaXN0QmxhY2tsaXN0KGtleSkgJiYga2V5c1RvUHJvY2Vzcy5pbmRleE9mKGtleSkgPT09IC0xICYmIGxhc3RTdGF0ZVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5c1RvUHJvY2Vzcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7IC8vIHN0YXJ0IHRoZSB0aW1lIGl0ZXJhdG9yIGlmIG5vdCBydW5uaW5nIChyZWFkOiB0aHJvdHRsZSlcblxuICAgIGlmICh0aW1lSXRlcmF0b3IgPT09IG51bGwpIHtcbiAgICAgIHRpbWVJdGVyYXRvciA9IHNldEludGVydmFsKHByb2Nlc3NOZXh0S2V5LCB0aHJvdHRsZSk7XG4gICAgfVxuXG4gICAgbGFzdFN0YXRlID0gc3RhdGU7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc05leHRLZXkoKSB7XG4gICAgaWYgKGtleXNUb1Byb2Nlc3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGltZUl0ZXJhdG9yKSBjbGVhckludGVydmFsKHRpbWVJdGVyYXRvcik7XG4gICAgICB0aW1lSXRlcmF0b3IgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBrZXlzVG9Qcm9jZXNzLnNoaWZ0KCk7XG4gICAgdmFyIGVuZFN0YXRlID0gdHJhbnNmb3Jtcy5yZWR1Y2UoZnVuY3Rpb24gKHN1YlN0YXRlLCB0cmFuc2Zvcm1lcikge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLmluKHN1YlN0YXRlLCBrZXksIGxhc3RTdGF0ZSk7XG4gICAgfSwgbGFzdFN0YXRlW2tleV0pO1xuXG4gICAgaWYgKGVuZFN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YWdlZFN0YXRlW2tleV0gPSBzZXJpYWxpemUoZW5kU3RhdGUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ3JlZHV4LXBlcnNpc3QvY3JlYXRlUGVyc2lzdG9pZDogZXJyb3Igc2VyaWFsaXppbmcgc3RhdGUnLCBlcnIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL2lmIHRoZSBlbmRTdGF0ZSBpcyB1bmRlZmluZWQsIG5vIG5lZWQgdG8gcGVyc2lzdCB0aGUgZXhpc3Rpbmcgc2VyaWFsaXplZCBjb250ZW50XG4gICAgICBkZWxldGUgc3RhZ2VkU3RhdGVba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoa2V5c1RvUHJvY2Vzcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHdyaXRlU3RhZ2VkU3RhdGUoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZVN0YWdlZFN0YXRlKCkge1xuICAgIC8vIGNsZWFudXAgYW55IHJlbW92ZWQga2V5cyBqdXN0IGJlZm9yZSB3cml0ZS5cbiAgICBPYmplY3Qua2V5cyhzdGFnZWRTdGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAobGFzdFN0YXRlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgc3RhZ2VkU3RhdGVba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB3cml0ZVByb21pc2UgPSBzdG9yYWdlLnNldEl0ZW0oc3RvcmFnZUtleSwgc2VyaWFsaXplKHN0YWdlZFN0YXRlKSkuY2F0Y2gob25Xcml0ZUZhaWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFzc1doaXRlbGlzdEJsYWNrbGlzdChrZXkpIHtcbiAgICBpZiAod2hpdGVsaXN0ICYmIHdoaXRlbGlzdC5pbmRleE9mKGtleSkgPT09IC0xICYmIGtleSAhPT0gJ19wZXJzaXN0JykgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChibGFja2xpc3QgJiYgYmxhY2tsaXN0LmluZGV4T2Yoa2V5KSAhPT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uV3JpdGVGYWlsKGVycikge1xuICAgIC8vIEBUT0RPIGFkZCBmYWlsIGhhbmRsZXJzICh0eXBpY2FsbHkgc3RvcmFnZSBmdWxsKVxuICAgIGlmICh3cml0ZUZhaWxIYW5kbGVyKSB3cml0ZUZhaWxIYW5kbGVyKGVycik7XG5cbiAgICBpZiAoZXJyICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN0b3JpbmcgZGF0YScsIGVycik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgd2hpbGUgKGtleXNUb1Byb2Nlc3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICBwcm9jZXNzTmV4dEtleSgpO1xuICAgIH1cblxuICAgIHJldHVybiB3cml0ZVByb21pc2UgfHwgUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07IC8vIHJldHVybiBgcGVyc2lzdG9pZGBcblxuXG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiB1cGRhdGUsXG4gICAgZmx1c2g6IGZsdXNoXG4gIH07XG59IC8vIEBOT1RFIGluIHRoZSBmdXR1cmUgdGhpcyBtYXkgYmUgZXhwb3NlZCB2aWEgY29uZmlnXG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXJpYWxpemUoZGF0YSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG59Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQXdHZTtBQXhHZjs7QUFFZSxTQUFTLGlCQUFpQixNQUFNO0lBQzdDLFdBQVc7SUFDWCxJQUFJLFlBQVksT0FBTyxTQUFTLElBQUk7SUFDcEMsSUFBSSxZQUFZLE9BQU8sU0FBUyxJQUFJO0lBQ3BDLElBQUksYUFBYSxPQUFPLFVBQVUsSUFBSSxFQUFFO0lBQ3hDLElBQUksV0FBVyxPQUFPLFFBQVEsSUFBSTtJQUNsQyxJQUFJLGFBQWEsR0FBRyxNQUFNLENBQUMsT0FBTyxTQUFTLEtBQUssWUFBWSxPQUFPLFNBQVMsR0FBRyxzSkFBQSxDQUFBLGFBQVUs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QixjQUFjO1lBQ2hELFFBQVEsS0FBSyxDQUFDLHNCQUFzQjtRQUN0QztJQUNGO0lBRUEsSUFBSSxRQUFRLFNBQVM7UUFDbkIsTUFBTyxjQUFjLE1BQU0sS0FBSyxFQUFHO1lBQ2pDO1FBQ0Y7UUFFQSxPQUFPLGdCQUFnQixRQUFRLE9BQU87SUFDeEMsR0FBRyxzQkFBc0I7SUFHekIsT0FBTztRQUNMLFFBQVE7UUFDUixPQUFPO0lBQ1Q7QUFDRixFQUFFLHFEQUFxRDtBQUV2RCxTQUFTLGlCQUFpQixJQUFJO0lBQzVCLE9BQU8sS0FBSyxTQUFTLENBQUM7QUFDeEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTMxMDMsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVkdXgtcGVyc2lzdC9lcy9nZXRTdG9yZWRTdGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBLRVlfUFJFRklYIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U3RvcmVkU3RhdGUoY29uZmlnKSB7XG4gIHZhciB0cmFuc2Zvcm1zID0gY29uZmlnLnRyYW5zZm9ybXMgfHwgW107XG4gIHZhciBzdG9yYWdlS2V5ID0gXCJcIi5jb25jYXQoY29uZmlnLmtleVByZWZpeCAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmtleVByZWZpeCA6IEtFWV9QUkVGSVgpLmNvbmNhdChjb25maWcua2V5KTtcbiAgdmFyIHN0b3JhZ2UgPSBjb25maWcuc3RvcmFnZTtcbiAgdmFyIGRlYnVnID0gY29uZmlnLmRlYnVnO1xuICB2YXIgZGVzZXJpYWxpemU7XG5cbiAgaWYgKGNvbmZpZy5kZXNlcmlhbGl6ZSA9PT0gZmFsc2UpIHtcbiAgICBkZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIGRlc2VyaWFsaXplKHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbmZpZy5kZXNlcmlhbGl6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRlc2VyaWFsaXplID0gY29uZmlnLmRlc2VyaWFsaXplO1xuICB9IGVsc2Uge1xuICAgIGRlc2VyaWFsaXplID0gZGVmYXVsdERlc2VyaWFsaXplO1xuICB9XG5cbiAgcmV0dXJuIHN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KS50aGVuKGZ1bmN0aW9uIChzZXJpYWxpemVkKSB7XG4gICAgaWYgKCFzZXJpYWxpemVkKSByZXR1cm4gdW5kZWZpbmVkO2Vsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0YXRlID0ge307XG4gICAgICAgIHZhciByYXdTdGF0ZSA9IGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQpO1xuICAgICAgICBPYmplY3Qua2V5cyhyYXdTdGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgc3RhdGVba2V5XSA9IHRyYW5zZm9ybXMucmVkdWNlUmlnaHQoZnVuY3Rpb24gKHN1YlN0YXRlLCB0cmFuc2Zvcm1lcikge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLm91dChzdWJTdGF0ZSwga2V5LCByYXdTdGF0ZSk7XG4gICAgICAgICAgfSwgZGVzZXJpYWxpemUocmF3U3RhdGVba2V5XSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRlYnVnKSBjb25zb2xlLmxvZyhcInJlZHV4LXBlcnNpc3QvZ2V0U3RvcmVkU3RhdGU6IEVycm9yIHJlc3RvcmluZyBkYXRhIFwiLmNvbmNhdChzZXJpYWxpemVkKSwgZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHREZXNlcmlhbGl6ZShzZXJpYWwpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2Uoc2VyaWFsKTtcbn0iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBOEJZO0FBOUJaOztBQUNlLFNBQVMsZUFBZSxNQUFNO0lBQzNDLElBQUksYUFBYSxPQUFPLFVBQVUsSUFBSSxFQUFFO0lBQ3hDLElBQUksYUFBYSxHQUFHLE1BQU0sQ0FBQyxPQUFPLFNBQVMsS0FBSyxZQUFZLE9BQU8sU0FBUyxHQUFHLHNKQUFBLENBQUEsYUFBVSxFQUFFLE1BQU0sQ0FBQyxPQUFPLEdBQUc7SUFDNUcsSUFBSSxVQUFVLE9BQU8sT0FBTztJQUM1QixJQUFJLFFBQVEsT0FBTyxLQUFLO0lBQ3hCLElBQUk7SUFFSixJQUFJLE9BQU8sV0FBVyxLQUFLLE9BQU87UUFDaEMsY0FBYyxTQUFTLFlBQVksQ0FBQztZQUNsQyxPQUFPO1FBQ1Q7SUFDRixPQUFPLElBQUksT0FBTyxPQUFPLFdBQVcsS0FBSyxZQUFZO1FBQ25ELGNBQWMsT0FBTyxXQUFXO0lBQ2xDLE9BQU87UUFDTCxjQUFjO0lBQ2hCO0lBRUEsT0FBTyxRQUFRLE9BQU8sQ0FBQyxZQUFZLElBQUksQ0FBQyxTQUFVLFVBQVU7UUFDMUQsSUFBSSxDQUFDLFlBQVksT0FBTzthQUFlO1lBQ3JDLElBQUk7Z0JBQ0YsSUFBSSxRQUFRLENBQUM7Z0JBQ2IsSUFBSSxXQUFXLFlBQVk7Z0JBQzNCLE9BQU8sSUFBSSxDQUFDLFVBQVUsT0FBTyxDQUFDLFNBQVUsR0FBRztvQkFDekMsS0FBSyxDQUFDLElBQUksR0FBRyxXQUFXLFdBQVcsQ0FBQyxTQUFVLFFBQVEsRUFBRSxXQUFXO3dCQUNqRSxPQUFPLFlBQVksR0FBRyxDQUFDLFVBQVUsS0FBSztvQkFDeEMsR0FBRyxZQUFZLFFBQVEsQ0FBQyxJQUFJO2dCQUM5QjtnQkFDQSxPQUFPO1lBQ1QsRUFBRSxPQUFPLEtBQUs7Z0JBQ1osSUFBSSxvREFBeUIsZ0JBQWdCLE9BQU8sUUFBUSxHQUFHLENBQUMsc0RBQXNELE1BQU0sQ0FBQyxhQUFhO2dCQUMxSSxNQUFNO1lBQ1I7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTLG1CQUFtQixNQUFNO0lBQ2hDLE9BQU8sS0FBSyxLQUFLLENBQUM7QUFDcEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTMxNTAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVkdXgtcGVyc2lzdC9lcy9wdXJnZVN0b3JlZFN0YXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEtFWV9QUkVGSVggfSBmcm9tICcuL2NvbnN0YW50cyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwdXJnZVN0b3JlZFN0YXRlKGNvbmZpZykge1xuICB2YXIgc3RvcmFnZSA9IGNvbmZpZy5zdG9yYWdlO1xuICB2YXIgc3RvcmFnZUtleSA9IFwiXCIuY29uY2F0KGNvbmZpZy5rZXlQcmVmaXggIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5rZXlQcmVmaXggOiBLRVlfUFJFRklYKS5jb25jYXQoY29uZmlnLmtleSk7XG4gIHJldHVybiBzdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSwgd2FybklmUmVtb3ZlRXJyb3IpO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZSZW1vdmVFcnJvcihlcnIpIHtcbiAgaWYgKGVyciAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcigncmVkdXgtcGVyc2lzdC9wdXJnZVN0b3JlZFN0YXRlOiBFcnJvciBwdXJnaW5nIGRhdGEgc3RvcmVkIHN0YXRlJywgZXJyKTtcbiAgfVxufSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFRYTtBQVJiOztBQUNlLFNBQVMsaUJBQWlCLE1BQU07SUFDN0MsSUFBSSxVQUFVLE9BQU8sT0FBTztJQUM1QixJQUFJLGFBQWEsR0FBRyxNQUFNLENBQUMsT0FBTyxTQUFTLEtBQUssWUFBWSxPQUFPLFNBQVMsR0FBRyxzSkFBQSxDQUFBLGFBQVUsRUFBRSxNQUFNLENBQUMsT0FBTyxHQUFHO0lBQzVHLE9BQU8sUUFBUSxVQUFVLENBQUMsWUFBWTtBQUN4QztBQUVBLFNBQVMsa0JBQWtCLEdBQUc7SUFDNUIsSUFBSSxPQUFPLG9EQUF5QixjQUFjO1FBQ2hELFFBQVEsS0FBSyxDQUFDLG1FQUFtRTtJQUNuRjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEzMTcwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3JlZHV4LXBlcnNpc3QvZXMvcGVyc2lzdFJlZHVjZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IHsgRkxVU0gsIFBBVVNFLCBQRVJTSVNULCBQVVJHRSwgUkVIWURSQVRFLCBERUZBVUxUX1ZFUlNJT04gfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgYXV0b01lcmdlTGV2ZWwxIGZyb20gJy4vc3RhdGVSZWNvbmNpbGVyL2F1dG9NZXJnZUxldmVsMSc7XG5pbXBvcnQgY3JlYXRlUGVyc2lzdG9pZCBmcm9tICcuL2NyZWF0ZVBlcnNpc3RvaWQnO1xuaW1wb3J0IGRlZmF1bHRHZXRTdG9yZWRTdGF0ZSBmcm9tICcuL2dldFN0b3JlZFN0YXRlJztcbmltcG9ydCBwdXJnZVN0b3JlZFN0YXRlIGZyb20gJy4vcHVyZ2VTdG9yZWRTdGF0ZSc7XG52YXIgREVGQVVMVF9USU1FT1VUID0gNTAwMDtcbi8qXG4gIEBUT0RPIGFkZCB2YWxpZGF0aW9uIC8gaGFuZGxpbmcgZm9yOlxuICAtIHBlcnNpc3RpbmcgYSByZWR1Y2VyIHdoaWNoIGhhcyBuZXN0ZWQgX3BlcnNpc3RcbiAgLSBoYW5kbGluZyBhY3Rpb25zIHRoYXQgZmlyZSBiZWZvcmUgcmV5ZHJhdGUgaXMgY2FsbGVkXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwZXJzaXN0UmVkdWNlcihjb25maWcsIGJhc2VSZWR1Y2VyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKCFjb25maWcpIHRocm93IG5ldyBFcnJvcignY29uZmlnIGlzIHJlcXVpcmVkIGZvciBwZXJzaXN0UmVkdWNlcicpO1xuICAgIGlmICghY29uZmlnLmtleSkgdGhyb3cgbmV3IEVycm9yKCdrZXkgaXMgcmVxdWlyZWQgaW4gcGVyc2lzdG9yIGNvbmZpZycpO1xuICAgIGlmICghY29uZmlnLnN0b3JhZ2UpIHRocm93IG5ldyBFcnJvcihcInJlZHV4LXBlcnNpc3Q6IGNvbmZpZy5zdG9yYWdlIGlzIHJlcXVpcmVkLiBUcnkgdXNpbmcgb25lIG9mIHRoZSBwcm92aWRlZCBzdG9yYWdlIGVuZ2luZXMgYGltcG9ydCBzdG9yYWdlIGZyb20gJ3JlZHV4LXBlcnNpc3QvbGliL3N0b3JhZ2UnYFwiKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gY29uZmlnLnZlcnNpb24gIT09IHVuZGVmaW5lZCA/IGNvbmZpZy52ZXJzaW9uIDogREVGQVVMVF9WRVJTSU9OO1xuICB2YXIgZGVidWcgPSBjb25maWcuZGVidWcgfHwgZmFsc2U7XG4gIHZhciBzdGF0ZVJlY29uY2lsZXIgPSBjb25maWcuc3RhdGVSZWNvbmNpbGVyID09PSB1bmRlZmluZWQgPyBhdXRvTWVyZ2VMZXZlbDEgOiBjb25maWcuc3RhdGVSZWNvbmNpbGVyO1xuICB2YXIgZ2V0U3RvcmVkU3RhdGUgPSBjb25maWcuZ2V0U3RvcmVkU3RhdGUgfHwgZGVmYXVsdEdldFN0b3JlZFN0YXRlO1xuICB2YXIgdGltZW91dCA9IGNvbmZpZy50aW1lb3V0ICE9PSB1bmRlZmluZWQgPyBjb25maWcudGltZW91dCA6IERFRkFVTFRfVElNRU9VVDtcbiAgdmFyIF9wZXJzaXN0b2lkID0gbnVsbDtcbiAgdmFyIF9wdXJnZSA9IGZhbHNlO1xuICB2YXIgX3BhdXNlZCA9IHRydWU7XG5cbiAgdmFyIGNvbmRpdGlvbmFsVXBkYXRlID0gZnVuY3Rpb24gY29uZGl0aW9uYWxVcGRhdGUoc3RhdGUpIHtcbiAgICAvLyB1cGRhdGUgdGhlIHBlcnNpc3RvaWQgb25seSBpZiB3ZSBhcmUgcmVoeWRyYXRlZCBhbmQgbm90IHBhdXNlZFxuICAgIHN0YXRlLl9wZXJzaXN0LnJlaHlkcmF0ZWQgJiYgX3BlcnNpc3RvaWQgJiYgIV9wYXVzZWQgJiYgX3BlcnNpc3RvaWQudXBkYXRlKHN0YXRlKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgdmFyIF9yZWYgPSBzdGF0ZSB8fCB7fSxcbiAgICAgICAgX3BlcnNpc3QgPSBfcmVmLl9wZXJzaXN0LFxuICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcIl9wZXJzaXN0XCJdKTsgLy8gJEZsb3dJZ25vcmUgbmVlZCB0byB1cGRhdGUgU3RhdGUgdHlwZVxuXG5cbiAgICB2YXIgcmVzdFN0YXRlID0gcmVzdDtcblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gUEVSU0lTVCkge1xuICAgICAgdmFyIF9zZWFsZWQgPSBmYWxzZTtcblxuICAgICAgdmFyIF9yZWh5ZHJhdGUgPSBmdW5jdGlvbiBfcmVoeWRyYXRlKHBheWxvYWQsIGVycikge1xuICAgICAgICAvLyBkZXYgd2FybmluZyBpZiB3ZSBhcmUgYWxyZWFkeSBzZWFsZWRcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgX3NlYWxlZCkgY29uc29sZS5lcnJvcihcInJlZHV4LXBlcnNpc3Q6IHJlaHlkcmF0ZSBmb3IgXFxcIlwiLmNvbmNhdChjb25maWcua2V5LCBcIlxcXCIgY2FsbGVkIGFmdGVyIHRpbWVvdXQuXCIpLCBwYXlsb2FkLCBlcnIpOyAvLyBvbmx5IHJlaHlkcmF0ZSBpZiB3ZSBhcmUgbm90IGFscmVhZHkgc2VhbGVkXG5cbiAgICAgICAgaWYgKCFfc2VhbGVkKSB7XG4gICAgICAgICAgYWN0aW9uLnJlaHlkcmF0ZShjb25maWcua2V5LCBwYXlsb2FkLCBlcnIpO1xuICAgICAgICAgIF9zZWFsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aW1lb3V0ICYmIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAhX3NlYWxlZCAmJiBfcmVoeWRyYXRlKHVuZGVmaW5lZCwgbmV3IEVycm9yKFwicmVkdXgtcGVyc2lzdDogcGVyc2lzdCB0aW1lZCBvdXQgZm9yIHBlcnNpc3Qga2V5IFxcXCJcIi5jb25jYXQoY29uZmlnLmtleSwgXCJcXFwiXCIpKSk7XG4gICAgICB9LCB0aW1lb3V0KTsgLy8gQE5PVEUgUEVSU0lTVCByZXN1bWVzIGlmIHBhdXNlZC5cblxuICAgICAgX3BhdXNlZCA9IGZhbHNlOyAvLyBATk9URSBvbmx5IGV2ZXIgY3JlYXRlIHBlcnNpc3RvaWQgb25jZSwgZW5zdXJlIHdlIGNhbGwgaXQgYXQgbGVhc3Qgb25jZSwgZXZlbiBpZiBfcGVyc2lzdCBoYXMgYWxyZWFkeSBiZWVuIHNldFxuXG4gICAgICBpZiAoIV9wZXJzaXN0b2lkKSBfcGVyc2lzdG9pZCA9IGNyZWF0ZVBlcnNpc3RvaWQoY29uZmlnKTsgLy8gQE5PVEUgUEVSU0lTVCBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzLCBub29wIGFmdGVyIHRoZSBmaXJzdFxuXG4gICAgICBpZiAoX3BlcnNpc3QpIHtcbiAgICAgICAgLy8gV2Ugc3RpbGwgbmVlZCB0byBjYWxsIHRoZSBiYXNlIHJlZHVjZXIgYmVjYXVzZSB0aGVyZSBtaWdodCBiZSBuZXN0ZWRcbiAgICAgICAgLy8gdXNlcyBvZiBwZXJzaXN0UmVkdWNlciB3aGljaCBuZWVkIHRvIGJlIGF3YXJlIG9mIHRoZSBQRVJTSVNUIGFjdGlvblxuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgYmFzZVJlZHVjZXIocmVzdFN0YXRlLCBhY3Rpb24pLCB7XG4gICAgICAgICAgX3BlcnNpc3Q6IF9wZXJzaXN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGFjdGlvbi5yZWh5ZHJhdGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFjdGlvbi5yZWdpc3RlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdyZWR1eC1wZXJzaXN0OiBlaXRoZXIgcmVoeWRyYXRlIG9yIHJlZ2lzdGVyIGlzIG5vdCBhIGZ1bmN0aW9uIG9uIHRoZSBQRVJTSVNUIGFjdGlvbi4gVGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBhY3Rpb24gaXMgYmVpbmcgcmVwbGF5ZWQuIFRoaXMgaXMgYW4gdW5leHBsb3JlZCB1c2UgY2FzZSwgcGxlYXNlIG9wZW4gYW4gaXNzdWUgYW5kIHdlIHdpbGwgZmlndXJlIG91dCBhIHJlc29sdXRpb24uJyk7XG4gICAgICBhY3Rpb24ucmVnaXN0ZXIoY29uZmlnLmtleSk7XG4gICAgICBnZXRTdG9yZWRTdGF0ZShjb25maWcpLnRoZW4oZnVuY3Rpb24gKHJlc3RvcmVkU3RhdGUpIHtcbiAgICAgICAgdmFyIG1pZ3JhdGUgPSBjb25maWcubWlncmF0ZSB8fCBmdW5jdGlvbiAocywgdikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgbWlncmF0ZShyZXN0b3JlZFN0YXRlLCB2ZXJzaW9uKS50aGVuKGZ1bmN0aW9uIChtaWdyYXRlZFN0YXRlKSB7XG4gICAgICAgICAgX3JlaHlkcmF0ZShtaWdyYXRlZFN0YXRlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKG1pZ3JhdGVFcnIpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBtaWdyYXRlRXJyKSBjb25zb2xlLmVycm9yKCdyZWR1eC1wZXJzaXN0OiBtaWdyYXRpb24gZXJyb3InLCBtaWdyYXRlRXJyKTtcblxuICAgICAgICAgIF9yZWh5ZHJhdGUodW5kZWZpbmVkLCBtaWdyYXRlRXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF9yZWh5ZHJhdGUodW5kZWZpbmVkLCBlcnIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgYmFzZVJlZHVjZXIocmVzdFN0YXRlLCBhY3Rpb24pLCB7XG4gICAgICAgIF9wZXJzaXN0OiB7XG4gICAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgICByZWh5ZHJhdGVkOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGFjdGlvbi50eXBlID09PSBQVVJHRSkge1xuICAgICAgX3B1cmdlID0gdHJ1ZTtcbiAgICAgIGFjdGlvbi5yZXN1bHQocHVyZ2VTdG9yZWRTdGF0ZShjb25maWcpKTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBiYXNlUmVkdWNlcihyZXN0U3RhdGUsIGFjdGlvbiksIHtcbiAgICAgICAgX3BlcnNpc3Q6IF9wZXJzaXN0XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGFjdGlvbi50eXBlID09PSBGTFVTSCkge1xuICAgICAgYWN0aW9uLnJlc3VsdChfcGVyc2lzdG9pZCAmJiBfcGVyc2lzdG9pZC5mbHVzaCgpKTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBiYXNlUmVkdWNlcihyZXN0U3RhdGUsIGFjdGlvbiksIHtcbiAgICAgICAgX3BlcnNpc3Q6IF9wZXJzaXN0XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGFjdGlvbi50eXBlID09PSBQQVVTRSkge1xuICAgICAgX3BhdXNlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChhY3Rpb24udHlwZSA9PT0gUkVIWURSQVRFKSB7XG4gICAgICAvLyBub29wIG9uIHJlc3RTdGF0ZSBpZiBwdXJnaW5nXG4gICAgICBpZiAoX3B1cmdlKSByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgcmVzdFN0YXRlLCB7XG4gICAgICAgIF9wZXJzaXN0OiBfb2JqZWN0U3ByZWFkKHt9LCBfcGVyc2lzdCwge1xuICAgICAgICAgIHJlaHlkcmF0ZWQ6IHRydWVcbiAgICAgICAgfSkgLy8gQE5PVEUgaWYga2V5IGRvZXMgbm90IG1hdGNoLCB3aWxsIGNvbnRpbnVlIHRvIGRlZmF1bHQgZWxzZSBiZWxvd1xuXG4gICAgICB9KTtcblxuICAgICAgaWYgKGFjdGlvbi5rZXkgPT09IGNvbmZpZy5rZXkpIHtcbiAgICAgICAgdmFyIHJlZHVjZWRTdGF0ZSA9IGJhc2VSZWR1Y2VyKHJlc3RTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgdmFyIGluYm91bmRTdGF0ZSA9IGFjdGlvbi5wYXlsb2FkOyAvLyBvbmx5IHJlY29uY2lsZSBzdGF0ZSBpZiBzdGF0ZVJlY29uY2lsZXIgYW5kIGluYm91bmRTdGF0ZSBhcmUgYm90aCBkZWZpbmVkXG5cbiAgICAgICAgdmFyIHJlY29uY2lsZWRSZXN0ID0gc3RhdGVSZWNvbmNpbGVyICE9PSBmYWxzZSAmJiBpbmJvdW5kU3RhdGUgIT09IHVuZGVmaW5lZCA/IHN0YXRlUmVjb25jaWxlcihpbmJvdW5kU3RhdGUsIHN0YXRlLCByZWR1Y2VkU3RhdGUsIGNvbmZpZykgOiByZWR1Y2VkU3RhdGU7XG5cbiAgICAgICAgdmFyIF9uZXdTdGF0ZSA9IF9vYmplY3RTcHJlYWQoe30sIHJlY29uY2lsZWRSZXN0LCB7XG4gICAgICAgICAgX3BlcnNpc3Q6IF9vYmplY3RTcHJlYWQoe30sIF9wZXJzaXN0LCB7XG4gICAgICAgICAgICByZWh5ZHJhdGVkOiB0cnVlXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbmFsVXBkYXRlKF9uZXdTdGF0ZSk7XG4gICAgICB9XG4gICAgfSAvLyBpZiB3ZSBoYXZlIG5vdCBhbHJlYWR5IGhhbmRsZWQgUEVSU0lTVCwgc3RyYWlnaHQgcGFzc3Rocm91Z2hcblxuXG4gICAgaWYgKCFfcGVyc2lzdCkgcmV0dXJuIGJhc2VSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pOyAvLyBydW4gYmFzZSByZWR1Y2VyOlxuICAgIC8vIGlzIHN0YXRlIG1vZGlmaWVkID8gcmV0dXJuIG9yaWdpbmFsIDogcmV0dXJuIHVwZGF0ZWRcblxuICAgIHZhciBuZXdTdGF0ZSA9IGJhc2VSZWR1Y2VyKHJlc3RTdGF0ZSwgYWN0aW9uKTtcbiAgICBpZiAobmV3U3RhdGUgPT09IHJlc3RTdGF0ZSkgcmV0dXJuIHN0YXRlO1xuICAgIHJldHVybiBjb25kaXRpb25hbFVwZGF0ZShfb2JqZWN0U3ByZWFkKHt9LCBuZXdTdGF0ZSwge1xuICAgICAgX3BlcnNpc3Q6IF9wZXJzaXN0XG4gICAgfSkpO1xuICB9O1xufSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUF1Qk07QUFiTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEEsU0FBUyxRQUFRLE1BQU0sRUFBRSxjQUFjO0lBQUksSUFBSSxPQUFPLE9BQU8sSUFBSSxDQUFDO0lBQVMsSUFBSSxPQUFPLHFCQUFxQixFQUFFO1FBQUUsSUFBSSxVQUFVLE9BQU8scUJBQXFCLENBQUM7UUFBUyxJQUFJLGdCQUFnQixVQUFVLFFBQVEsTUFBTSxDQUFDLFNBQVUsR0FBRztZQUFJLE9BQU8sT0FBTyx3QkFBd0IsQ0FBQyxRQUFRLEtBQUssVUFBVTtRQUFFO1FBQUksS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU07SUFBVTtJQUFFLE9BQU87QUFBTTtBQUVwVixTQUFTLGNBQWMsTUFBTTtJQUFJLElBQUssSUFBSSxJQUFJLEdBQUcsSUFBSSxVQUFVLE1BQU0sRUFBRSxJQUFLO1FBQUUsSUFB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QjtZQUMvQixJQUFJLFFBQVEsT0FBTyxjQUFjLENBQUMsR0FBRyxXQUFXO2dCQUM5QyxVQUFVLGNBQWMsQ0FBQyxHQUFHLFVBQVU7b0JBQ3BDLFlBQVk7Z0JBQ2QsR0FBRyxtRUFBbUU7WUFFeEU7WUFFQSxJQUFJLE9BQU8sR0FBRyxLQUFLLE9BQU8sR0FBRyxFQUFFO2dCQUM3QixJQUFJLGVBQWUsWUFBWSxXQUFXO2dCQUMxQyxJQUFJLGVBQWUsT0FBTyxPQUFPLEVBQUUsNEVBQTRFO2dCQUUvRyxJQUFJLGlCQUFpQixvQkFBb0IsU0FBUyxpQkFBaUIsWUFBWSxnQkFBZ0IsY0FBYyxPQUFPLGNBQWMsVUFBVTtnQkFFNUksSUFBSSxZQUFZLGNBQWMsQ0FBQyxHQUFHLGdCQUFnQjtvQkFDaEQsVUFBVSxjQUFjLENBQUMsR0FBRyxVQUFVO3dCQUNwQyxZQUFZO29CQUNkO2dCQUNGO2dCQUVBLE9BQU8sa0JBQWtCO1lBQzNCO1FBQ0YsRUFBRSwrREFBK0Q7UUFHakUsSUFBSSxDQUFDLFVBQVUsT0FBTyxZQUFZLE9BQU8sU0FBUyxvQkFBb0I7UUFDdEUsdURBQXVEO1FBRXZELElBQUksV0FBVyxZQUFZLFdBQVc7UUFDdEMsSUFBSSxhQUFhLFdBQVcsT0FBTztRQUNuQyxPQUFPLGtCQUFrQixjQUFjLENBQUMsR0FBRyxVQUFVO1lBQ25ELFVBQVU7UUFDWjtJQUNGO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTMzNjUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVkdXgtcGVyc2lzdC9lcy9zdGF0ZVJlY29uY2lsZXIvYXV0b01lcmdlTGV2ZWwyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qXG4gIGF1dG9NZXJnZUxldmVsMjogXG4gICAgLSBtZXJnZXMgMiBsZXZlbCBvZiBzdWJzdGF0ZVxuICAgIC0gc2tpcHMgc3Vic3RhdGUgaWYgYWxyZWFkeSBtb2RpZmllZFxuICAgIC0gdGhpcyBpcyBlc3NlbnRpYWxseSByZWR1eC1wZXJpc3QgdjQgYmVoYXZpb3JcbiovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhdXRvTWVyZ2VMZXZlbDIoaW5ib3VuZFN0YXRlLCBvcmlnaW5hbFN0YXRlLCByZWR1Y2VkU3RhdGUsIF9yZWYpIHtcbiAgdmFyIGRlYnVnID0gX3JlZi5kZWJ1ZztcblxuICB2YXIgbmV3U3RhdGUgPSBfb2JqZWN0U3ByZWFkKHt9LCByZWR1Y2VkU3RhdGUpOyAvLyBvbmx5IHJlaHlkcmF0ZSBpZiBpbmJvdW5kU3RhdGUgZXhpc3RzIGFuZCBpcyBhbiBvYmplY3RcblxuXG4gIGlmIChpbmJvdW5kU3RhdGUgJiYgX3R5cGVvZihpbmJvdW5kU3RhdGUpID09PSAnb2JqZWN0Jykge1xuICAgIE9iamVjdC5rZXlzKGluYm91bmRTdGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvLyBpZ25vcmUgX3BlcnNpc3QgZGF0YVxuICAgICAgaWYgKGtleSA9PT0gJ19wZXJzaXN0JykgcmV0dXJuOyAvLyBpZiByZWR1Y2VyIG1vZGlmaWVzIHN1YnN0YXRlLCBza2lwIGF1dG8gcmVoeWRyYXRpb25cblxuICAgICAgaWYgKG9yaWdpbmFsU3RhdGVba2V5XSAhPT0gcmVkdWNlZFN0YXRlW2tleV0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGVidWcpIGNvbnNvbGUubG9nKCdyZWR1eC1wZXJzaXN0L3N0YXRlUmVjb25jaWxlcjogc3ViIHN0YXRlIGZvciBrZXkgYCVzYCBtb2RpZmllZCwgc2tpcHBpbmcuJywga2V5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNQbGFpbkVub3VnaE9iamVjdChyZWR1Y2VkU3RhdGVba2V5XSkpIHtcbiAgICAgICAgLy8gaWYgb2JqZWN0IGlzIHBsYWluIGVub3VnaCBzaGFsbG93IG1lcmdlIHRoZSBuZXcgdmFsdWVzIChoZW5jZSBcIkxldmVsMlwiKVxuICAgICAgICBuZXdTdGF0ZVtrZXldID0gX29iamVjdFNwcmVhZCh7fSwgbmV3U3RhdGVba2V5XSwge30sIGluYm91bmRTdGF0ZVtrZXldKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBvdGhlcndpc2UgaGFyZCBzZXRcblxuXG4gICAgICBuZXdTdGF0ZVtrZXldID0gaW5ib3VuZFN0YXRlW2tleV07XG4gICAgfSk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkZWJ1ZyAmJiBpbmJvdW5kU3RhdGUgJiYgX3R5cGVvZihpbmJvdW5kU3RhdGUpID09PSAnb2JqZWN0JykgY29uc29sZS5sb2coXCJyZWR1eC1wZXJzaXN0L3N0YXRlUmVjb25jaWxlcjogcmVoeWRyYXRlZCBrZXlzICdcIi5jb25jYXQoT2JqZWN0LmtleXMoaW5ib3VuZFN0YXRlKS5qb2luKCcsICcpLCBcIidcIikpO1xuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbmZ1bmN0aW9uIGlzUGxhaW5Fbm91Z2hPYmplY3Qobykge1xuICByZXR1cm4gbyAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShvKSAmJiBfdHlwZW9mKG8pID09PSAnb2JqZWN0Jztcbn0iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBMEJZO0FBMUJaLFNBQVMsUUFBUSxHQUFHO0lBQUksSUFBSSxPQUFPLFdBQVcsY0FBYyxPQUFPLE9BQU8sUUFBUSxLQUFLLFVBQVU7UUFBRSxVQUFVLFNBQVMsUUFBUSxHQUFHO1lBQUksT0FBTyxPQUFPO1FBQUs7SUFBRyxPQUFPO1FBQUUsVUFBVSxTQUFTLFFBQVEsR0FBRztZQUFJLE9BQU8sT0FBTyxPQUFPLFdBQVcsY0FBYyxJQUFJLFdBQVcsS0FBSyxVQUFVLFFBQVEsT0FBTyxTQUFTLEdBQUcsV0FBVyxPQUFPO1FBQUs7SUFBRztJQUFFLE9BQU8sUUFBUTtBQUFNO0FBRTlWLFNBQVMsUUFBUSxNQUFNLEVBQUUsY0FBYztJQUFJLElBQUksT0FBTyxPQUFPLElBQUksQ0FBQztJQUFTLElBQUksT0FBTyxxQkFBcUIsRUFBRTtRQUFFLElBQUksVUFBVSxPQUFPLHFCQUFxQixDQUFDO1FBQVMsSUFBSSxnQkFBZ0IsVUFBVSxRQUFRLE1BQU0sQ0FBQyxTQUFVLEdBQUc7WUFBSSxPQUFPLE9BQU8sd0JBQXdCLENBQUMsUUFBUSxLQUFLLFVBQVU7UUFBRTtRQUFJLEtBQUssSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNO0lBQVU7SUFBRSxPQUFPO0FBQU07QUFFcFYsU0FBUyxjQUFjLE1BQU07SUFBSSxJQUFLLElBQUksSUFBSSxHQUFHLElBQUksVUFBVSxNQUFNLEVBQUUsSUFBSztRQUFFLElBQUksU0FBUyxTQUFTLENBQUMsRUFBRSxJQUFJLE9BQU8sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQUcsSUFBSSxJQUFJLEdBQUc7WUFBRSxRQUFRLFFBQVEsTUFBTSxPQUFPLENBQUMsU0FBVSxHQUFHO2dCQUFJLGdCQUFnQixRQUFRLEtBQUssTUFBTSxDQUFDLElBQUk7WUFBRztRQUFJLE9BQU8sSUFBSSxPQUFPLHlCQUF5QixFQUFFO1lBQUUsT0FBTyxnQkFBZ0IsQ0FBQyxRQUFRLE9BQU8seUJBQXlCLENBQUM7UUFBVSxPQUFPO1lBQUUsUUFBUSxRQUFRLE9BQU8sQ0FBQyxTQUFVLEdBQUc7Z0JBQUksT0FBTyxjQUFjLENBQUMsUUFBUSxLQUFLLE9BQU8sd0JBQXdCLENBQUMsUUFBUTtZQUFPO1FBQUk7SUFBRTtJQUFFLE9BQU87QUFBUTtBQUVyZ0IsU0FBUyxnQkFBZ0IsR0FBRyxFQUFFLEdBQUcsRUFBRSxLQUFLO0lBQUksSUFBSSxPQUFPLEtBQUs7UUFBRSxPQUFPLGNBQWMsQ0FBQyxLQUFLLEtBQUs7WUFBRSxPQUFPO1lBQU8sWUFBWTtZQUFNLGNBQWM7WUFBTSxVQUFVO1FBQUs7SUFBSSxPQUFPO1FBQUUsR0FBRyxDQUFDLElBQUksR0FBRztJQUFPO0lBQUUsT0FBTztBQUFLO0FBUWpNLFNBQVMsZ0JBQWdCLFlBQVksRUFBRSxhQUFhLEVBQUUsWUFBWSxFQUFFLElBQUk7SUFDckYsSUFBSSxRQUFRLEtBQUssS0FBSztJQUV0QixJQUFJLFdBQVcsY0FBYyxDQUFDLEdBQUcsZUFBZSx5REFBeUQ7SUFHekcsSUFBSSxnQkFBZ0IsUUFBUSxrQkFBa0IsVUFBVTtRQUN0RCxPQUFPLElBQUksQ0FBQyxjQUFjLE9BQU8sQ0FBQyxTQUFVLEdBQUc7WUFDN0MsdUJBQXVCO1lBQ3ZCLElBQUksUUFBUSxZQUFZLFFBQVEsc0RBQXNEO1lBRXRGLElBQUksYUFBYSxDQUFDLElBQUksS0FBSyxZQUFZLENBQUMsSUFBSSxFQUFFO2dCQUM1QyxJQUFJLG9EQUF5QixnQkFBZ0IsT0FBTyxRQUFRLEdBQUcsQ0FBQyw2RUFBNkU7Z0JBQzdJO1lBQ0Y7WUFFQSxJQUFJLG9CQUFvQixZQUFZLENBQUMsSUFBSSxHQUFHO2dCQUMxQywwRUFBMEU7Z0JBQzFFLFFBQVEsQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDLEdBQUcsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDLEdBQUcsWUFBWSxDQUFDLElBQUk7Z0JBQ3RFO1lBQ0YsRUFBRSxxQkFBcUI7WUFHdkIsUUFBUSxDQUFDLElBQUksR0FBRyxZQUFZLENBQUMsSUFBSTtRQUNuQztJQUNGO0lBRUEsSUFBSSxvREFBeUIsZ0JBQWdCLFNBQVMsZ0JBQWdCLFFBQVEsa0JBQWtCLFVBQVUsUUFBUSxHQUFHLENBQUMsbURBQW1ELE1BQU0sQ0FBQyxPQUFPLElBQUksQ0FBQyxjQUFjLElBQUksQ0FBQyxPQUFPO0lBQ3ROLE9BQU87QUFDVDtBQUVBLFNBQVMsb0JBQW9CLENBQUM7SUFDNUIsT0FBTyxNQUFNLFFBQVEsQ0FBQyxNQUFNLE9BQU8sQ0FBQyxNQUFNLFFBQVEsT0FBTztBQUMzRCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMzQ1MSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWR1eC1wZXJzaXN0L2VzL3BlcnNpc3RDb21iaW5lUmVkdWNlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHBlcnNpc3RSZWR1Y2VyIGZyb20gJy4vcGVyc2lzdFJlZHVjZXInO1xuaW1wb3J0IGF1dG9NZXJnZUxldmVsMiBmcm9tICcuL3N0YXRlUmVjb25jaWxlci9hdXRvTWVyZ2VMZXZlbDInO1xuLy8gY29tYmluZVJlZHVjZXJzICsgcGVyc2lzdFJlZHVjZXIgd2l0aCBzdGF0ZVJlY29uY2lsZXIgZGVmYXVsdGVkIHRvIGF1dG9NZXJnZUxldmVsMlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGVyc2lzdENvbWJpbmVSZWR1Y2Vycyhjb25maWcsIHJlZHVjZXJzKSB7XG4gIGNvbmZpZy5zdGF0ZVJlY29uY2lsZXIgPSBjb25maWcuc3RhdGVSZWNvbmNpbGVyID09PSB1bmRlZmluZWQgPyBhdXRvTWVyZ2VMZXZlbDIgOiBjb25maWcuc3RhdGVSZWNvbmNpbGVyO1xuICByZXR1cm4gcGVyc2lzdFJlZHVjZXIoY29uZmlnLCBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpKTtcbn0iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBOzs7O0FBRWUsU0FBUyx1QkFBdUIsTUFBTSxFQUFFLFFBQVE7SUFDN0QsT0FBTyxlQUFlLEdBQUcsT0FBTyxlQUFlLEtBQUssWUFBWSwrS0FBQSxDQUFBLFVBQWUsR0FBRyxPQUFPLGVBQWU7SUFDeEcsT0FBTyxDQUFBLEdBQUEsMkpBQUEsQ0FBQSxVQUFjLEFBQUQsRUFBRSxRQUFRLENBQUEsR0FBQSwwSUFBQSxDQUFBLGtCQUFlLEFBQUQsRUFBRTtBQUNoRCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMzQ2OCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWR1eC1wZXJzaXN0L2VzL3BlcnNpc3RTdG9yZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgeyBjcmVhdGVTdG9yZSB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IEZMVVNILCBQQVVTRSwgUEVSU0lTVCwgUFVSR0UsIFJFR0lTVEVSLCBSRUhZRFJBVEUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG52YXIgaW5pdGlhbFN0YXRlID0ge1xuICByZWdpc3RyeTogW10sXG4gIGJvb3RzdHJhcHBlZDogZmFsc2Vcbn07XG5cbnZhciBwZXJzaXN0b3JSZWR1Y2VyID0gZnVuY3Rpb24gcGVyc2lzdG9yUmVkdWNlcigpIHtcbiAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBpbml0aWFsU3RhdGU7XG4gIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBSRUdJU1RFUjpcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBzdGF0ZSwge1xuICAgICAgICByZWdpc3RyeTogW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShzdGF0ZS5yZWdpc3RyeSksIFthY3Rpb24ua2V5XSlcbiAgICAgIH0pO1xuXG4gICAgY2FzZSBSRUhZRFJBVEU6XG4gICAgICB2YXIgZmlyc3RJbmRleCA9IHN0YXRlLnJlZ2lzdHJ5LmluZGV4T2YoYWN0aW9uLmtleSk7XG5cbiAgICAgIHZhciByZWdpc3RyeSA9IF90b0NvbnN1bWFibGVBcnJheShzdGF0ZS5yZWdpc3RyeSk7XG5cbiAgICAgIHJlZ2lzdHJ5LnNwbGljZShmaXJzdEluZGV4LCAxKTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBzdGF0ZSwge1xuICAgICAgICByZWdpc3RyeTogcmVnaXN0cnksXG4gICAgICAgIGJvb3RzdHJhcHBlZDogcmVnaXN0cnkubGVuZ3RoID09PSAwXG4gICAgICB9KTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBlcnNpc3RTdG9yZShzdG9yZSwgb3B0aW9ucywgY2IpIHtcbiAgLy8gaGVscCBjYXRjaCBpbmNvcnJlY3QgdXNhZ2Ugb2YgcGFzc2luZyBQZXJzaXN0Q29uZmlnIGluIGFzIFBlcnNpc3Rvck9wdGlvbnNcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgb3B0aW9uc1RvVGVzdCA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGJhbm5lZEtleXMgPSBbJ2JsYWNrbGlzdCcsICd3aGl0ZWxpc3QnLCAndHJhbnNmb3JtcycsICdzdG9yYWdlJywgJ2tleVByZWZpeCcsICdtaWdyYXRlJ107XG4gICAgYmFubmVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoISFvcHRpb25zVG9UZXN0W2tdKSBjb25zb2xlLmVycm9yKFwicmVkdXgtcGVyc2lzdDogaW52YWxpZCBvcHRpb24gcGFzc2VkIHRvIHBlcnNpc3RTdG9yZTogXFxcIlwiLmNvbmNhdChrLCBcIlxcXCIuIFlvdSBtYXkgYmUgaW5jb3JyZWN0bHkgcGFzc2luZyBwZXJzaXN0Q29uZmlnIGludG8gcGVyc2lzdFN0b3JlLCB3aGVyZWFzIGl0IHNob3VsZCBiZSBwYXNzZWQgaW50byBwZXJzaXN0UmVkdWNlci5cIikpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGJvb3N0cmFwcGVkQ2IgPSBjYiB8fCBmYWxzZTtcblxuICB2YXIgX3BTdG9yZSA9IGNyZWF0ZVN0b3JlKHBlcnNpc3RvclJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgb3B0aW9ucyAmJiBvcHRpb25zLmVuaGFuY2VyID8gb3B0aW9ucy5lbmhhbmNlciA6IHVuZGVmaW5lZCk7XG5cbiAgdmFyIHJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoa2V5KSB7XG4gICAgX3BTdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiBSRUdJU1RFUixcbiAgICAgIGtleToga2V5XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlaHlkcmF0ZSA9IGZ1bmN0aW9uIHJlaHlkcmF0ZShrZXksIHBheWxvYWQsIGVycikge1xuICAgIHZhciByZWh5ZHJhdGVBY3Rpb24gPSB7XG4gICAgICB0eXBlOiBSRUhZRFJBVEUsXG4gICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgZXJyOiBlcnIsXG4gICAgICBrZXk6IGtleSAvLyBkaXNwYXRjaCB0byBgc3RvcmVgIHRvIHJlaHlkcmF0ZSBhbmQgYHBlcnNpc3RvcmAgdG8gdHJhY2sgcmVzdWx0XG5cbiAgICB9O1xuICAgIHN0b3JlLmRpc3BhdGNoKHJlaHlkcmF0ZUFjdGlvbik7XG5cbiAgICBfcFN0b3JlLmRpc3BhdGNoKHJlaHlkcmF0ZUFjdGlvbik7XG5cbiAgICBpZiAoYm9vc3RyYXBwZWRDYiAmJiBwZXJzaXN0b3IuZ2V0U3RhdGUoKS5ib290c3RyYXBwZWQpIHtcbiAgICAgIGJvb3N0cmFwcGVkQ2IoKTtcbiAgICAgIGJvb3N0cmFwcGVkQ2IgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBlcnNpc3RvciA9IF9vYmplY3RTcHJlYWQoe30sIF9wU3RvcmUsIHtcbiAgICBwdXJnZTogZnVuY3Rpb24gcHVyZ2UoKSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBQVVJHRSxcbiAgICAgICAgcmVzdWx0OiBmdW5jdGlvbiByZXN1bHQocHVyZ2VSZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gocHVyZ2VSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZXN1bHRzKTtcbiAgICB9LFxuICAgIGZsdXNoOiBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICBzdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IEZMVVNILFxuICAgICAgICByZXN1bHQ6IGZ1bmN0aW9uIHJlc3VsdChmbHVzaFJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChmbHVzaFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc3VsdHMpO1xuICAgIH0sXG4gICAgcGF1c2U6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBQQVVTRVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBwZXJzaXN0OiBmdW5jdGlvbiBwZXJzaXN0KCkge1xuICAgICAgc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBQRVJTSVNULFxuICAgICAgICByZWdpc3RlcjogcmVnaXN0ZXIsXG4gICAgICAgIHJlaHlkcmF0ZTogcmVoeWRyYXRlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy5tYW51YWxQZXJzaXN0KSkge1xuICAgIHBlcnNpc3Rvci5wZXJzaXN0KCk7XG4gIH1cblxuICByZXR1cm4gcGVyc2lzdG9yO1xufSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFpRE07QUFuQ047QUFDQTtBQWZBLFNBQVMsbUJBQW1CLEdBQUc7SUFBSSxPQUFPLG1CQUFtQixRQUFRLGlCQUFpQixRQUFRO0FBQXNCO0FBRXBILFNBQVM7SUFBdUIsTUFBTSxJQUFJLFVBQVU7QUFBb0Q7QUFFeEcsU0FBUyxpQkFBaUIsSUFBSTtJQUFJLElBQUksT0FBTyxRQUFRLElBQUksT0FBTyxTQUFTLE9BQU8sU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxzQkFBc0IsT0FBTyxNQUFNLElBQUksQ0FBQztBQUFPO0FBRWpLLFNBQVMsbUJBQW1CLEdBQUc7SUFBSSxJQUFJLE1BQU0sT0FBTyxDQUFDLE1BQU07UUFBRSxJQUFLLElBQUksSUFBSSxHQUFHLE9BQU8sSUFBSSxNQUFNLElBQUksTUFBTSxHQUFHLElBQUksSUFBSSxNQUFNLEVBQUUsSUFBSztZQUFFLElBQUksQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLEVBQUU7UUFBRTtRQUFFLE9BQU87SUFBTTtBQUFFO0FBRXJLLFNBQVMsUUFBUSxNQUFNLEVBQUUsY0FBYztJQUFJLElBQUksT0FBTyxPQUFPLElBQUksQ0FBQztJQUFTLElBQUksT0FBTyxxQkFBcUIsRUFBRTtRQUFFLElBQUksVUFBVSxPQUFPLHFCQUFxQixDQUFDO1FBQVMsSUFBSSxnQkFBZ0IsVUFBVSxRQUFRLE1BQU0sQ0FBQyxTQUFVLEdBQUc7WUFBSSxPQUFPLE9BQU8sd0JBQXdCLENBQUMsUUFBUSxLQUFLLFVBQVU7UUFBRTtRQUFJLEtBQUssSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNO0lBQVU7SUFBRSxPQUFPO0FBQU07QUFFcFYsU0FBUyxjQUFjLE1BQU07SUFBSSxJQUFLLElBQUksSUFBSSxHQUFHLElBQUksVUFBVSxNQUFNLEVBQUUsSUFBSztRQUFFLElBQUksU0FBUyxTQUFTLENBQUMsRUFBRSxJQUFJLE9BQU8sU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQUcsSUFBSSxJQUFJLEdBQUc7WUFBRSxRQUFRLFFBQVEsTUFBTSxPQUFPLENBQUMsU0FBVSxHQUFHO2dCQUFJLGdCQUFnQixRQUFRLEtBQUssTUFBTSxDQUFDLElBQUk7WUFBRztRQUFJLE9BQU8sSUFBSSxPQUFPLHlCQUF5QixFQUFFO1lBQUUsT0FBTyxnQkFBZ0IsQ0FBQyxRQUFRLE9BQU8seUJBQXlCLENBQUM7UUFBVSxPQUFPO1lBQUUsUUFBUSxRQUFRLE9BQU8sQ0FBQyxTQUFVLEdBQUc7Z0JBQUksT0FBTyxjQUFjLENBQUMsUUFBUSxLQUFLLE9BQU8sd0JBQXdCLENBQUMsUUFBUTtZQUFPO1FBQUk7SUFBRTtJQUFFLE9BQU87QUFBUTtBQUVyZ0IsU0FBUyxnQkFBZ0IsR0FBRyxFQUFFLEdBQUcsRUFBRSxLQUFLO0lBQUksSUFBSSxPQUFPLEtBQUs7UUFBRSxPQUFPLGNBQWMsQ0FBQyxLQUFLLEtBQUs7WUFBRSxPQUFPO1lBQU8sWUFBWTtZQUFNLGNBQWM7WUFBTSxVQUFVO1FBQUs7SUFBSSxPQUFPO1FBQUUsR0FBRyxDQUFDLElBQUksR0FBRztJQUFPO0lBQUUsT0FBTztBQUFLOzs7QUFJaE4sSUFBSSxlQUFlO0lBQ2pCLFVBQVUsRUFBRTtJQUNaLGNBQWM7QUFDaEI7QUFFQSxJQUFJLG1CQUFtQixTQUFTO0lBQzlCLElBQUksUUFBUSxVQUFVLE1BQU0sR0FBRyxLQUFLLFNBQVMsQ0FBQyxFQUFFLEtBQUssWUFBWSxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQ2hGLElBQUksU0FBUyxVQUFVLE1BQU0sR0FBRyxJQUFJLFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFFbkQsT0FBUSxPQUFPLElBQUk7UUFDakIsS0FBSyxzSkFBQSxDQUFBLFdBQVE7WUFDWCxPQUFPLGNBQWMsQ0FBQyxHQUFHLE9BQU87Z0JBQzlCLFVBQVUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsTUFBTSxRQUFRLEdBQUc7b0JBQUMsT0FBTyxHQUFHO2lCQUFDO1lBQ3RFO1FBRUYsS0FBSyxzSkFBQSxDQUFBLFlBQVM7WUFDWixJQUFJLGFBQWEsTUFBTSxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sR0FBRztZQUVsRCxJQUFJLFdBQVcsbUJBQW1CLE1BQU0sUUFBUTtZQUVoRCxTQUFTLE1BQU0sQ0FBQyxZQUFZO1lBQzVCLE9BQU8sY0FBYyxDQUFDLEdBQUcsT0FBTztnQkFDOUIsVUFBVTtnQkFDVixjQUFjLFNBQVMsTUFBTSxLQUFLO1lBQ3BDO1FBRUY7WUFDRSxPQUFPO0lBQ1g7QUFDRjtBQUVlLFNBQVMsYUFBYSxLQUFLLEVBQUUsT0FBTyxFQUFFLEVBQUU7SUFDckQsNkVBQTZFO0lBQzdFLHdDQUEyQztRQUN6QyxJQUFJLGdCQUFnQixXQUFXLENBQUM7UUFDaEMsSUFBSSxhQUFhO1lBQUM7WUFBYTtZQUFhO1lBQWM7WUFBVztZQUFhO1NBQVU7UUFDNUYsV0FBVyxPQUFPLENBQUMsU0FBVSxDQUFDO1lBQzVCLElBQUksQ0FBQyxDQUFDLGFBQWEsQ0FBQyxFQUFFLEVBQUUsUUFBUSxLQUFLLENBQUMsMkRBQTJELE1BQU0sQ0FBQyxHQUFHO1FBQzdHO0lBQ0Y7SUFFQSxJQUFJLGdCQUFnQixNQUFNO0lBRTFCLElBQUksVUFBVSxDQUFBLEdBQUEsMElBQUEsQ0FBQSxjQUFXLEFBQUQsRUFBRSxrQkFBa0IsY0FBYyxXQUFXLFFBQVEsUUFBUSxHQUFHLFFBQVEsUUFBUSxHQUFHO0lBRTNHLElBQUksV0FBVyxTQUFTLFNBQVMsR0FBRztRQUNsQyxRQUFRLFFBQVEsQ0FBQztZQUNmLE1BQU0sc0pBQUEsQ0FBQSxXQUFRO1lBQ2QsS0FBSztRQUNQO0lBQ0Y7SUFFQSxJQUFJLFlBQVksU0FBUyxVQUFVLEdBQUcsRUFBRSxPQUFPLEVBQUUsR0FBRztRQUNsRCxJQUFJLGtCQUFrQjtZQUNwQixNQUFNLHNKQUFBLENBQUEsWUFBUztZQUNmLFNBQVM7WUFDVCxLQUFLO1lBQ0wsS0FBSyxJQUFJLG1FQUFtRTtRQUU5RTtRQUNBLE1BQU0sUUFBUSxDQUFDO1FBRWYsUUFBUSxRQUFRLENBQUM7UUFFakIsSUFBSSxpQkFBaUIsVUFBVSxRQUFRLEdBQUcsWUFBWSxFQUFFO1lBQ3REO1lBQ0EsZ0JBQWdCO1FBQ2xCO0lBQ0Y7SUFFQSxJQUFJLFlBQVksY0FBYyxDQUFDLEdBQUcsU0FBUztRQUN6QyxPQUFPLFNBQVM7WUFDZCxJQUFJLFVBQVUsRUFBRTtZQUNoQixNQUFNLFFBQVEsQ0FBQztnQkFDYixNQUFNLHNKQUFBLENBQUEsUUFBSztnQkFDWCxRQUFRLFNBQVMsT0FBTyxXQUFXO29CQUNqQyxRQUFRLElBQUksQ0FBQztnQkFDZjtZQUNGO1lBQ0EsT0FBTyxRQUFRLEdBQUcsQ0FBQztRQUNyQjtRQUNBLE9BQU8sU0FBUztZQUNkLElBQUksVUFBVSxFQUFFO1lBQ2hCLE1BQU0sUUFBUSxDQUFDO2dCQUNiLE1BQU0sc0pBQUEsQ0FBQSxRQUFLO2dCQUNYLFFBQVEsU0FBUyxPQUFPLFdBQVc7b0JBQ2pDLFFBQVEsSUFBSSxDQUFDO2dCQUNmO1lBQ0Y7WUFDQSxPQUFPLFFBQVEsR0FBRyxDQUFDO1FBQ3JCO1FBQ0EsT0FBTyxTQUFTO1lBQ2QsTUFBTSxRQUFRLENBQUM7Z0JBQ2IsTUFBTSxzSkFBQSxDQUFBLFFBQUs7WUFDYjtRQUNGO1FBQ0EsU0FBUyxTQUFTO1lBQ2hCLE1BQU0sUUFBUSxDQUFDO2dCQUNiLE1BQU0sc0pBQUEsQ0FBQSxVQUFPO2dCQUNiLFVBQVU7Z0JBQ1YsV0FBVztZQUNiO1FBQ0Y7SUFDRjtJQUVBLElBQUksQ0FBQyxDQUFDLFdBQVcsUUFBUSxhQUFhLEdBQUc7UUFDdkMsVUFBVSxPQUFPO0lBQ25CO0lBRUEsT0FBTztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEzNjQxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3JlZHV4LXBlcnNpc3QvZXMvY3JlYXRlTWlncmF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUZBVUxUX1ZFUlNJT04gfSBmcm9tICcuL2NvbnN0YW50cyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVNaWdyYXRlKG1pZ3JhdGlvbnMsIGNvbmZpZykge1xuICB2YXIgX3JlZiA9IGNvbmZpZyB8fCB7fSxcbiAgICAgIGRlYnVnID0gX3JlZi5kZWJ1ZztcblxuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBjdXJyZW50VmVyc2lvbikge1xuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRlYnVnKSBjb25zb2xlLmxvZygncmVkdXgtcGVyc2lzdDogbm8gaW5ib3VuZCBzdGF0ZSwgc2tpcHBpbmcgbWlncmF0aW9uJyk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgdmFyIGluYm91bmRWZXJzaW9uID0gc3RhdGUuX3BlcnNpc3QgJiYgc3RhdGUuX3BlcnNpc3QudmVyc2lvbiAhPT0gdW5kZWZpbmVkID8gc3RhdGUuX3BlcnNpc3QudmVyc2lvbiA6IERFRkFVTFRfVkVSU0lPTjtcblxuICAgIGlmIChpbmJvdW5kVmVyc2lvbiA9PT0gY3VycmVudFZlcnNpb24pIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRlYnVnKSBjb25zb2xlLmxvZygncmVkdXgtcGVyc2lzdDogdmVyc2lvbnMgbWF0Y2gsIG5vb3AgbWlncmF0aW9uJyk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoaW5ib3VuZFZlcnNpb24gPiBjdXJyZW50VmVyc2lvbikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIGNvbnNvbGUuZXJyb3IoJ3JlZHV4LXBlcnNpc3Q6IGRvd25ncmFkaW5nIHZlcnNpb24gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzdGF0ZSk7XG4gICAgfVxuXG4gICAgdmFyIG1pZ3JhdGlvbktleXMgPSBPYmplY3Qua2V5cyhtaWdyYXRpb25zKS5tYXAoZnVuY3Rpb24gKHZlcikge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHZlcik7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmVyc2lvbiA+PSBrZXkgJiYga2V5ID4gaW5ib3VuZFZlcnNpb247XG4gICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRlYnVnKSBjb25zb2xlLmxvZygncmVkdXgtcGVyc2lzdDogbWlncmF0aW9uS2V5cycsIG1pZ3JhdGlvbktleXMpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBtaWdyYXRlZFN0YXRlID0gbWlncmF0aW9uS2V5cy5yZWR1Y2UoZnVuY3Rpb24gKHN0YXRlLCB2ZXJzaW9uS2V5KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRlYnVnKSBjb25zb2xlLmxvZygncmVkdXgtcGVyc2lzdDogcnVubmluZyBtaWdyYXRpb24gZm9yIHZlcnNpb25LZXknLCB2ZXJzaW9uS2V5KTtcbiAgICAgICAgcmV0dXJuIG1pZ3JhdGlvbnNbdmVyc2lvbktleV0oc3RhdGUpO1xuICAgICAgfSwgc3RhdGUpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtaWdyYXRlZFN0YXRlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgfTtcbn0iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBbUJVO0FBbkJWOztBQUNlLFNBQVMsY0FBYyxVQUFVLEVBQUUsTUFBTTtJQUN0RCxJQUFJLE9BQU8sVUFBVSxDQUFDLEdBQ2xCLFFBQVEsS0FBSyxLQUFLO0lBRXRCLE9BQU8sU0FBVSxLQUFLLEVBQUUsY0FBYztRQUNwQyxJQUFJLENBQUMsT0FBTztZQUNWLElBQUksb0RBQXlCLGdCQUFnQixPQUFPLFFBQVEsR0FBRyxDQUFDO1lBQ2hFLE9BQU8sUUFBUSxPQUFPLENBQUM7UUFDekI7UUFFQSxJQUFJLGlCQUFpQixNQUFNLFFBQVEsSUFBSSxNQUFNLFFBQVEsQ0FBQyxPQUFPLEtBQUssWUFBWSxNQUFNLFFBQVEsQ0FBQyxPQUFPLEdBQUcsc0pBQUEsQ0FBQSxrQkFBZTtRQUV0SCxJQUFJLG1CQUFtQixnQkFBZ0I7WUFDckMsSUFBSSxvREFBeUIsZ0JBQWdCLE9BQU8sUUFBUSxHQUFHLENBQUM7WUFDaEUsT0FBTyxRQUFRLE9BQU8sQ0FBQztRQUN6QjtRQUVBLElBQUksaUJBQWlCLGdCQUFnQjtZQUNuQyx3Q0FBMkMsUUFBUSxLQUFLLENBQUM7WUFDekQsT0FBTyxRQUFRLE9BQU8sQ0FBQztRQUN6QjtRQUVBLElBQUksZ0JBQWdCLE9BQU8sSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLFNBQVUsR0FBRztZQUMzRCxPQUFPLFNBQVM7UUFDbEIsR0FBRyxNQUFNLENBQUMsU0FBVSxHQUFHO1lBQ3JCLE9BQU8sa0JBQWtCLE9BQU8sTUFBTTtRQUN4QyxHQUFHLElBQUksQ0FBQyxTQUFVLENBQUMsRUFBRSxDQUFDO1lBQ3BCLE9BQU8sSUFBSTtRQUNiO1FBQ0EsSUFBSSxvREFBeUIsZ0JBQWdCLE9BQU8sUUFBUSxHQUFHLENBQUMsZ0NBQWdDO1FBRWhHLElBQUk7WUFDRixJQUFJLGdCQUFnQixjQUFjLE1BQU0sQ0FBQyxTQUFVLEtBQUssRUFBRSxVQUFVO2dCQUNsRSxJQUFJLG9EQUF5QixnQkFBZ0IsT0FBTyxRQUFRLEdBQUcsQ0FBQyxtREFBbUQ7Z0JBQ25ILE9BQU8sVUFBVSxDQUFDLFdBQVcsQ0FBQztZQUNoQyxHQUFHO1lBQ0gsT0FBTyxRQUFRLE9BQU8sQ0FBQztRQUN6QixFQUFFLE9BQU8sS0FBSztZQUNaLE9BQU8sUUFBUSxNQUFNLENBQUM7UUFDeEI7SUFDRjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEzNjg2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3JlZHV4LXBlcnNpc3QvZXMvY3JlYXRlVHJhbnNmb3JtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybSggLy8gQE5PVEUgaW5ib3VuZDogdHJhbnNmb3JtIHN0YXRlIGNvbWluZyBmcm9tIHJlZHV4IG9uIGl0cyB3YXkgdG8gYmVpbmcgc2VyaWFsaXplZCBhbmQgc3RvcmVkXG5pbmJvdW5kLCAvLyBATk9URSBvdXRib3VuZDogdHJhbnNmb3JtIHN0YXRlIGNvbWluZyBmcm9tIHN0b3JhZ2UsIG9uIGl0cyB3YXkgdG8gYmUgcmVoeWRyYXRlZCBpbnRvIHJlZHV4XG5vdXRib3VuZCkge1xuICB2YXIgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHdoaXRlbGlzdCA9IGNvbmZpZy53aGl0ZWxpc3QgfHwgbnVsbDtcbiAgdmFyIGJsYWNrbGlzdCA9IGNvbmZpZy5ibGFja2xpc3QgfHwgbnVsbDtcblxuICBmdW5jdGlvbiB3aGl0ZWxpc3RCbGFja2xpc3RDaGVjayhrZXkpIHtcbiAgICBpZiAod2hpdGVsaXN0ICYmIHdoaXRlbGlzdC5pbmRleE9mKGtleSkgPT09IC0xKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYmxhY2tsaXN0ICYmIGJsYWNrbGlzdC5pbmRleE9mKGtleSkgIT09IC0xKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGluOiBmdW5jdGlvbiBfaW4oc3RhdGUsIGtleSwgZnVsbFN0YXRlKSB7XG4gICAgICByZXR1cm4gIXdoaXRlbGlzdEJsYWNrbGlzdENoZWNrKGtleSkgJiYgaW5ib3VuZCA/IGluYm91bmQoc3RhdGUsIGtleSwgZnVsbFN0YXRlKSA6IHN0YXRlO1xuICAgIH0sXG4gICAgb3V0OiBmdW5jdGlvbiBvdXQoc3RhdGUsIGtleSwgZnVsbFN0YXRlKSB7XG4gICAgICByZXR1cm4gIXdoaXRlbGlzdEJsYWNrbGlzdENoZWNrKGtleSkgJiYgb3V0Ym91bmQgPyBvdXRib3VuZChzdGF0ZSwga2V5LCBmdWxsU3RhdGUpIDogc3RhdGU7XG4gICAgfVxuICB9O1xufSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBZSxTQUFTLGdCQUN4QixPQUFPLEVBQ1AsUUFBUTtJQUNOLElBQUksU0FBUyxVQUFVLE1BQU0sR0FBRyxLQUFLLFNBQVMsQ0FBQyxFQUFFLEtBQUssWUFBWSxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7SUFDbEYsSUFBSSxZQUFZLE9BQU8sU0FBUyxJQUFJO0lBQ3BDLElBQUksWUFBWSxPQUFPLFNBQVMsSUFBSTtJQUVwQyxTQUFTLHdCQUF3QixHQUFHO1FBQ2xDLElBQUksYUFBYSxVQUFVLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxPQUFPO1FBQ3ZELElBQUksYUFBYSxVQUFVLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxPQUFPO1FBQ3ZELE9BQU87SUFDVDtJQUVBLE9BQU87UUFDTCxJQUFJLFNBQVMsSUFBSSxLQUFLLEVBQUUsR0FBRyxFQUFFLFNBQVM7WUFDcEMsT0FBTyxDQUFDLHdCQUF3QixRQUFRLFVBQVUsUUFBUSxPQUFPLEtBQUssYUFBYTtRQUNyRjtRQUNBLEtBQUssU0FBUyxJQUFJLEtBQUssRUFBRSxHQUFHLEVBQUUsU0FBUztZQUNyQyxPQUFPLENBQUMsd0JBQXdCLFFBQVEsV0FBVyxTQUFTLE9BQU8sS0FBSyxhQUFhO1FBQ3ZGO0lBQ0Y7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMzcxMSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWR1eC1wZXJzaXN0L2VzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgYXMgcGVyc2lzdFJlZHVjZXIgfSBmcm9tICcuL3BlcnNpc3RSZWR1Y2VyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGVyc2lzdENvbWJpbmVSZWR1Y2VycyB9IGZyb20gJy4vcGVyc2lzdENvbWJpbmVSZWR1Y2Vycyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBlcnNpc3RTdG9yZSB9IGZyb20gJy4vcGVyc2lzdFN0b3JlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY3JlYXRlTWlncmF0ZSB9IGZyb20gJy4vY3JlYXRlTWlncmF0ZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNyZWF0ZVRyYW5zZm9ybSB9IGZyb20gJy4vY3JlYXRlVHJhbnNmb3JtJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZ2V0U3RvcmVkU3RhdGUgfSBmcm9tICcuL2dldFN0b3JlZFN0YXRlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY3JlYXRlUGVyc2lzdG9pZCB9IGZyb20gJy4vY3JlYXRlUGVyc2lzdG9pZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHB1cmdlU3RvcmVkU3RhdGUgfSBmcm9tICcuL3B1cmdlU3RvcmVkU3RhdGUnO1xuZXhwb3J0ICogZnJvbSAnLi9jb25zdGFudHMnOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEzNzY3LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL3JlZHV4LXBlcnNpc3QvbGliL3N0b3JhZ2UvZ2V0U3RvcmFnZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdldFN0b3JhZ2U7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgbm9vcFN0b3JhZ2UgPSB7XG4gIGdldEl0ZW06IG5vb3AsXG4gIHNldEl0ZW06IG5vb3AsXG4gIHJlbW92ZUl0ZW06IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIGhhc1N0b3JhZ2Uoc3RvcmFnZVR5cGUpIHtcbiAgaWYgKCh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHNlbGYpKSAhPT0gJ29iamVjdCcgfHwgIShzdG9yYWdlVHlwZSBpbiBzZWxmKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIHN0b3JhZ2UgPSBzZWxmW3N0b3JhZ2VUeXBlXTtcbiAgICB2YXIgdGVzdEtleSA9IFwicmVkdXgtcGVyc2lzdCBcIi5jb25jYXQoc3RvcmFnZVR5cGUsIFwiIHRlc3RcIik7XG4gICAgc3RvcmFnZS5zZXRJdGVtKHRlc3RLZXksICd0ZXN0Jyk7XG4gICAgc3RvcmFnZS5nZXRJdGVtKHRlc3RLZXkpO1xuICAgIHN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0S2V5KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSBjb25zb2xlLndhcm4oXCJyZWR1eC1wZXJzaXN0IFwiLmNvbmNhdChzdG9yYWdlVHlwZSwgXCIgdGVzdCBmYWlsZWQsIHBlcnNpc3RlbmNlIHdpbGwgYmUgZGlzYWJsZWQuXCIpKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RvcmFnZSh0eXBlKSB7XG4gIHZhciBzdG9yYWdlVHlwZSA9IFwiXCIuY29uY2F0KHR5cGUsIFwiU3RvcmFnZVwiKTtcbiAgaWYgKGhhc1N0b3JhZ2Uoc3RvcmFnZVR5cGUpKSByZXR1cm4gc2VsZltzdG9yYWdlVHlwZV07ZWxzZSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJyZWR1eC1wZXJzaXN0IGZhaWxlZCB0byBjcmVhdGUgc3luYyBzdG9yYWdlLiBmYWxsaW5nIGJhY2sgdG8gbm9vcCBzdG9yYWdlLlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9vcFN0b3JhZ2U7XG4gIH1cbn0iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBMkJRO0FBM0JSO0FBRUEsUUFBUSxVQUFVLEdBQUc7QUFDckIsUUFBUSxPQUFPLEdBQUc7QUFFbEIsU0FBUyxRQUFRLEdBQUc7SUFBSSxJQUFJLE9BQU8sV0FBVyxjQUFjLE9BQU8sT0FBTyxRQUFRLEtBQUssVUFBVTtRQUFFLFVBQVUsU0FBUyxRQUFRLEdBQUc7WUFBSSxPQUFPLE9BQU87UUFBSztJQUFHLE9BQU87UUFBRSxVQUFVLFNBQVMsUUFBUSxHQUFHO1lBQUksT0FBTyxPQUFPLE9BQU8sV0FBVyxjQUFjLElBQUksV0FBVyxLQUFLLFVBQVUsUUFBUSxPQUFPLFNBQVMsR0FBRyxXQUFXLE9BQU87UUFBSztJQUFHO0lBQUUsT0FBTyxRQUFRO0FBQU07QUFFOVYsU0FBUyxRQUFRO0FBRWpCLElBQUksY0FBYztJQUNoQixTQUFTO0lBQ1QsU0FBUztJQUNULFlBQVk7QUFDZDtBQUVBLFNBQVMsV0FBVyxXQUFXO0lBQzdCLElBQUksQ0FBQyxPQUFPLFNBQVMsY0FBYyxjQUFjLFFBQVEsS0FBSyxNQUFNLFlBQVksQ0FBQyxDQUFDLGVBQWUsSUFBSSxHQUFHO1FBQ3RHLE9BQU87SUFDVDtJQUVBLElBQUk7UUFDRixJQUFJLFVBQVUsSUFBSSxDQUFDLFlBQVk7UUFDL0IsSUFBSSxVQUFVLGlCQUFpQixNQUFNLENBQUMsYUFBYTtRQUNuRCxRQUFRLE9BQU8sQ0FBQyxTQUFTO1FBQ3pCLFFBQVEsT0FBTyxDQUFDO1FBQ2hCLFFBQVEsVUFBVSxDQUFDO0lBQ3JCLEVBQUUsT0FBTyxHQUFHO1FBQ1Ysd0NBQTJDLFFBQVEsSUFBSSxDQUFDLGlCQUFpQixNQUFNLENBQUMsYUFBYTtRQUM3RixPQUFPO0lBQ1Q7SUFFQSxPQUFPO0FBQ1Q7QUFFQSxTQUFTLFdBQVcsSUFBSTtJQUN0QixJQUFJLGNBQWMsR0FBRyxNQUFNLENBQUMsTUFBTTtJQUNsQyxJQUFJLFdBQVcsY0FBYyxPQUFPLElBQUksQ0FBQyxZQUFZO1NBQU07UUFDekQsd0NBQTJDO1lBQ3pDLFFBQVEsS0FBSyxDQUFDO1FBQ2hCO1FBRUEsT0FBTztJQUNUO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTM4MjEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVkdXgtcGVyc2lzdC9saWIvc3RvcmFnZS9jcmVhdGVXZWJTdG9yYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlV2ViU3RvcmFnZTtcblxudmFyIF9nZXRTdG9yYWdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9nZXRTdG9yYWdlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlV2ViU3RvcmFnZSh0eXBlKSB7XG4gIHZhciBzdG9yYWdlID0gKDAsIF9nZXRTdG9yYWdlLmRlZmF1bHQpKHR5cGUpO1xuICByZXR1cm4ge1xuICAgIGdldEl0ZW06IGZ1bmN0aW9uIGdldEl0ZW0oa2V5KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXNvbHZlKHN0b3JhZ2UuZ2V0SXRlbShrZXkpKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2V0SXRlbTogZnVuY3Rpb24gc2V0SXRlbShrZXksIGl0ZW0pIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlc29sdmUoc3RvcmFnZS5zZXRJdGVtKGtleSwgaXRlbSkpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICByZW1vdmVJdGVtOiBmdW5jdGlvbiByZW1vdmVJdGVtKGtleSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcmVzb2x2ZShzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLFFBQVEsVUFBVSxHQUFHO0FBQ3JCLFFBQVEsT0FBTyxHQUFHO0FBRWxCLElBQUksY0FBYztBQUVsQixTQUFTLHVCQUF1QixHQUFHO0lBQUksT0FBTyxPQUFPLElBQUksVUFBVSxHQUFHLE1BQU07UUFBRSxTQUFTO0lBQUk7QUFBRztBQUU5RixTQUFTLGlCQUFpQixJQUFJO0lBQzVCLElBQUksVUFBVSxDQUFDLEdBQUcsWUFBWSxPQUFPLEVBQUU7SUFDdkMsT0FBTztRQUNMLFNBQVMsU0FBUyxRQUFRLEdBQUc7WUFDM0IsT0FBTyxJQUFJLFFBQVEsU0FBVSxPQUFPLEVBQUUsTUFBTTtnQkFDMUMsUUFBUSxRQUFRLE9BQU8sQ0FBQztZQUMxQjtRQUNGO1FBQ0EsU0FBUyxTQUFTLFFBQVEsR0FBRyxFQUFFLElBQUk7WUFDakMsT0FBTyxJQUFJLFFBQVEsU0FBVSxPQUFPLEVBQUUsTUFBTTtnQkFDMUMsUUFBUSxRQUFRLE9BQU8sQ0FBQyxLQUFLO1lBQy9CO1FBQ0Y7UUFDQSxZQUFZLFNBQVMsV0FBVyxHQUFHO1lBQ2pDLE9BQU8sSUFBSSxRQUFRLFNBQVUsT0FBTyxFQUFFLE1BQU07Z0JBQzFDLFFBQVEsUUFBUSxVQUFVLENBQUM7WUFDN0I7UUFDRjtJQUNGO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTM4NTUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvcmVkdXgtcGVyc2lzdC9saWIvc3RvcmFnZS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jcmVhdGVXZWJTdG9yYWdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jcmVhdGVXZWJTdG9yYWdlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIF9kZWZhdWx0ID0gKDAsIF9jcmVhdGVXZWJTdG9yYWdlLmRlZmF1bHQpKCdsb2NhbCcpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsUUFBUSxVQUFVLEdBQUc7QUFDckIsUUFBUSxPQUFPLEdBQUcsS0FBSztBQUV2QixJQUFJLG9CQUFvQjtBQUV4QixTQUFTLHVCQUF1QixHQUFHO0lBQUksT0FBTyxPQUFPLElBQUksVUFBVSxHQUFHLE1BQU07UUFBRSxTQUFTO0lBQUk7QUFBRztBQUU5RixJQUFJLFdBQVcsQ0FBQyxHQUFHLGtCQUFrQixPQUFPLEVBQUU7QUFFOUMsUUFBUSxPQUFPLEdBQUciLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTM4NzcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwc3RhbmRhcmQtc2NoZW1hL3V0aWxzL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2dldERvdFBhdGgvZ2V0RG90UGF0aC50c1xuZnVuY3Rpb24gZ2V0RG90UGF0aChpc3N1ZSkge1xuICBpZiAoaXNzdWUucGF0aD8ubGVuZ3RoKSB7XG4gICAgbGV0IGRvdFBhdGggPSBcIlwiO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpc3N1ZS5wYXRoKSB7XG4gICAgICBjb25zdCBrZXkgPSB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiA/IGl0ZW0ua2V5IDogaXRlbTtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBrZXkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKGRvdFBhdGgpIHtcbiAgICAgICAgICBkb3RQYXRoICs9IGAuJHtrZXl9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb3RQYXRoICs9IGtleTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkb3RQYXRoO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBzcmMvU2NoZW1hRXJyb3IvU2NoZW1hRXJyb3IudHNcbnZhciBTY2hlbWFFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogVGhlIHNjaGVtYSBpc3N1ZXMuXG4gICAqL1xuICBpc3N1ZXM7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2NoZW1hIGVycm9yIHdpdGggdXNlZnVsIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gaXNzdWVzIFRoZSBzY2hlbWEgaXNzdWVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoaXNzdWVzKSB7XG4gICAgc3VwZXIoaXNzdWVzWzBdLm1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiU2NoZW1hRXJyb3JcIjtcbiAgICB0aGlzLmlzc3VlcyA9IGlzc3VlcztcbiAgfVxufTtcbmV4cG9ydCB7XG4gIFNjaGVtYUVycm9yLFxuICBnZXREb3RQYXRoXG59O1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLCtCQUErQjs7Ozs7OztBQUMvQixTQUFTLFdBQVcsS0FBSztRQUNuQjtJQUFKLEtBQUksY0FBQSxNQUFNLElBQUksY0FBVixrQ0FBQSxZQUFZLE1BQU0sRUFBRTtRQUN0QixJQUFJLFVBQVU7UUFDZCxLQUFLLE1BQU0sUUFBUSxNQUFNLElBQUksQ0FBRTtZQUM3QixNQUFNLE1BQU0sT0FBTyxTQUFTLFdBQVcsS0FBSyxHQUFHLEdBQUc7WUFDbEQsSUFBSSxPQUFPLFFBQVEsWUFBWSxPQUFPLFFBQVEsVUFBVTtnQkFDdEQsSUFBSSxTQUFTO29CQUNYLFdBQVcsQUFBQyxJQUFPLE9BQUo7Z0JBQ2pCLE9BQU87b0JBQ0wsV0FBVztnQkFDYjtZQUNGLE9BQU87Z0JBQ0wsT0FBTztZQUNUO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxPQUFPO0FBQ1Q7QUFFQSxpQ0FBaUM7QUFDakMsSUFBSSxjQUFjLGNBQWM7SUFLOUI7Ozs7R0FJQyxHQUNELFlBQVksTUFBTSxDQUFFO1FBQ2xCLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sR0FWekI7O0dBRUMsR0FDRCwrS0FBQSxVQUFBLEtBQUE7UUFRRSxJQUFJLENBQUMsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDLE1BQU0sR0FBRztJQUNoQjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEzOTIzLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvcXVlcnkvY29yZS9hcGlTdGF0ZS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL3F1ZXJ5L2NvcmUvcnRrSW1wb3J0cy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL3F1ZXJ5L3V0aWxzL2NvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmcudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS91dGlscy9jb3VudE9iamVjdEtleXMudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS91dGlscy9mbGF0dGVuLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvcXVlcnkvdXRpbHMvaXNBYnNvbHV0ZVVybC50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL3F1ZXJ5L3V0aWxzL2lzRG9jdW1lbnRWaXNpYmxlLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvcXVlcnkvdXRpbHMvaXNOb3ROdWxsaXNoLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvcXVlcnkvdXRpbHMvaXNPbmxpbmUudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS91dGlscy9qb2luVXJscy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL3F1ZXJ5L3V0aWxzL2dldE9ySW5zZXJ0LnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvcXVlcnkvZmV0Y2hCYXNlUXVlcnkudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS9IYW5kbGVkRXJyb3IudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS9yZXRyeS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL3F1ZXJ5L2NvcmUvc2V0dXBMaXN0ZW5lcnMudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS9lbmRwb2ludERlZmluaXRpb25zLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvcXVlcnkvY29yZS9idWlsZFRodW5rcy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL3F1ZXJ5L2NvcmUvYnVpbGRJbml0aWF0ZS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL3RzSGVscGVycy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL3F1ZXJ5L3N0YW5kYXJkU2NoZW1hLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvcXVlcnkvY29yZS9idWlsZFNsaWNlLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvcXVlcnkvY29yZS9idWlsZFNlbGVjdG9ycy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL3F1ZXJ5L2NyZWF0ZUFwaS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL3F1ZXJ5L2RlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS9mYWtlQmFzZVF1ZXJ5LnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvcXVlcnkvY29yZS9tb2R1bGUudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS90c0hlbHBlcnMudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9iYXRjaEFjdGlvbnMudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9jYWNoZUNvbGxlY3Rpb24udHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9jYWNoZUxpZmVjeWNsZS50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2Rldk1pZGRsZXdhcmUudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9pbnZhbGlkYXRpb25CeVRhZ3MudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9wb2xsaW5nLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvcXVlcnkvY29yZS9idWlsZE1pZGRsZXdhcmUvcXVlcnlMaWZlY3ljbGUudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS93aW5kb3dFdmVudEhhbmRsaW5nLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvcXVlcnkvY29yZS9idWlsZE1pZGRsZXdhcmUvaW5kZXgudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS9jb3JlL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgU2VyaWFsaXplZEVycm9yIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XG5pbXBvcnQgdHlwZSB7IEJhc2VRdWVyeUVycm9yIH0gZnJvbSAnLi4vYmFzZVF1ZXJ5VHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBCYXNlRW5kcG9pbnREZWZpbml0aW9uLCBFbmRwb2ludERlZmluaXRpb25zLCBGdWxsVGFnRGVzY3JpcHRpb24sIEluZmluaXRlUXVlcnlEZWZpbml0aW9uLCBNdXRhdGlvbkRlZmluaXRpb24sIFBhZ2VQYXJhbUZyb20sIFF1ZXJ5QXJnRnJvbUFueVF1ZXJ5LCBRdWVyeURlZmluaXRpb24sIFJlc3VsdFR5cGVGcm9tIH0gZnJvbSAnLi4vZW5kcG9pbnREZWZpbml0aW9ucyc7XG5pbXBvcnQgdHlwZSB7IElkLCBXaXRoUmVxdWlyZWRQcm9wIH0gZnJvbSAnLi4vdHNIZWxwZXJzJztcbmV4cG9ydCB0eXBlIFF1ZXJ5Q2FjaGVLZXkgPSBzdHJpbmcgJiB7XG4gIF90eXBlOiAncXVlcnlDYWNoZUtleSc7XG59O1xuZXhwb3J0IHR5cGUgUXVlcnlTdWJzdGF0ZUlkZW50aWZpZXIgPSB7XG4gIHF1ZXJ5Q2FjaGVLZXk6IFF1ZXJ5Q2FjaGVLZXk7XG59O1xuZXhwb3J0IHR5cGUgTXV0YXRpb25TdWJzdGF0ZUlkZW50aWZpZXIgPSB7XG4gIHJlcXVlc3RJZDogc3RyaW5nO1xuICBmaXhlZENhY2hlS2V5Pzogc3RyaW5nO1xufSB8IHtcbiAgcmVxdWVzdElkPzogc3RyaW5nO1xuICBmaXhlZENhY2hlS2V5OiBzdHJpbmc7XG59O1xuZXhwb3J0IHR5cGUgUmVmZXRjaENvbmZpZ09wdGlvbnMgPSB7XG4gIHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2U6IGJvb2xlYW4gfCBudW1iZXI7XG4gIHJlZmV0Y2hPblJlY29ubmVjdDogYm9vbGVhbjtcbiAgcmVmZXRjaE9uRm9jdXM6IGJvb2xlYW47XG59O1xuZXhwb3J0IHR5cGUgSW5maW5pdGVRdWVyeUNvbmZpZ09wdGlvbnM8RGF0YVR5cGUsIFBhZ2VQYXJhbSwgUXVlcnlBcmc+ID0ge1xuICAvKipcbiAgICogVGhlIGluaXRpYWwgcGFnZSBwYXJhbWV0ZXIgdG8gdXNlIGZvciB0aGUgZmlyc3QgcGFnZSBmZXRjaC5cbiAgICovXG4gIGluaXRpYWxQYWdlUGFyYW06IFBhZ2VQYXJhbTtcbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgcmVxdWlyZWQgdG8gYXV0b21hdGljYWxseSBnZXQgdGhlIG5leHQgY3Vyc29yIGZvciBpbmZpbml0ZSBxdWVyaWVzLlxuICAgKiBUaGUgcmVzdWx0IHdpbGwgYWxzbyBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgYGhhc05leHRQYWdlYC5cbiAgICovXG4gIGdldE5leHRQYWdlUGFyYW06IChsYXN0UGFnZTogRGF0YVR5cGUsIGFsbFBhZ2VzOiBBcnJheTxEYXRhVHlwZT4sIGxhc3RQYWdlUGFyYW06IFBhZ2VQYXJhbSwgYWxsUGFnZVBhcmFtczogQXJyYXk8UGFnZVBhcmFtPiwgcXVlcnlBcmc6IFF1ZXJ5QXJnKSA9PiBQYWdlUGFyYW0gfCB1bmRlZmluZWQgfCBudWxsO1xuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgc2V0IHRvIGF1dG9tYXRpY2FsbHkgZ2V0IHRoZSBwcmV2aW91cyBjdXJzb3IgZm9yIGluZmluaXRlIHF1ZXJpZXMuXG4gICAqIFRoZSByZXN1bHQgd2lsbCBhbHNvIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiBgaGFzUHJldmlvdXNQYWdlYC5cbiAgICovXG4gIGdldFByZXZpb3VzUGFnZVBhcmFtPzogKGZpcnN0UGFnZTogRGF0YVR5cGUsIGFsbFBhZ2VzOiBBcnJheTxEYXRhVHlwZT4sIGZpcnN0UGFnZVBhcmFtOiBQYWdlUGFyYW0sIGFsbFBhZ2VQYXJhbXM6IEFycmF5PFBhZ2VQYXJhbT4sIHF1ZXJ5QXJnOiBRdWVyeUFyZykgPT4gUGFnZVBhcmFtIHwgdW5kZWZpbmVkIHwgbnVsbDtcbiAgLyoqXG4gICAqIElmIHNwZWNpZmllZCwgb25seSBrZWVwIHRoaXMgbWFueSBwYWdlcyBpbiBjYWNoZSBhdCBvbmNlLlxuICAgKiBJZiBhZGRpdGlvbmFsIHBhZ2VzIGFyZSBmZXRjaGVkLCBvbGRlciBwYWdlcyBpbiB0aGUgb3RoZXJcbiAgICogZGlyZWN0aW9uIHdpbGwgYmUgZHJvcHBlZCBmcm9tIHRoZSBjYWNoZS5cbiAgICovXG4gIG1heFBhZ2VzPzogbnVtYmVyO1xufTtcbmV4cG9ydCB0eXBlIEluZmluaXRlRGF0YTxEYXRhVHlwZSwgUGFnZVBhcmFtPiA9IHtcbiAgcGFnZXM6IEFycmF5PERhdGFUeXBlPjtcbiAgcGFnZVBhcmFtczogQXJyYXk8UGFnZVBhcmFtPjtcbn07XG5cbi8qKlxuICogU3RyaW5ncyBkZXNjcmliaW5nIHRoZSBxdWVyeSBzdGF0ZSBhdCBhbnkgZ2l2ZW4gdGltZS5cbiAqL1xuZXhwb3J0IGVudW0gUXVlcnlTdGF0dXMge1xuICB1bmluaXRpYWxpemVkID0gJ3VuaW5pdGlhbGl6ZWQnLFxuICBwZW5kaW5nID0gJ3BlbmRpbmcnLFxuICBmdWxmaWxsZWQgPSAnZnVsZmlsbGVkJyxcbiAgcmVqZWN0ZWQgPSAncmVqZWN0ZWQnLFxufVxuZXhwb3J0IHR5cGUgUmVxdWVzdFN0YXR1c0ZsYWdzID0ge1xuICBzdGF0dXM6IFF1ZXJ5U3RhdHVzLnVuaW5pdGlhbGl6ZWQ7XG4gIGlzVW5pbml0aWFsaXplZDogdHJ1ZTtcbiAgaXNMb2FkaW5nOiBmYWxzZTtcbiAgaXNTdWNjZXNzOiBmYWxzZTtcbiAgaXNFcnJvcjogZmFsc2U7XG59IHwge1xuICBzdGF0dXM6IFF1ZXJ5U3RhdHVzLnBlbmRpbmc7XG4gIGlzVW5pbml0aWFsaXplZDogZmFsc2U7XG4gIGlzTG9hZGluZzogdHJ1ZTtcbiAgaXNTdWNjZXNzOiBmYWxzZTtcbiAgaXNFcnJvcjogZmFsc2U7XG59IHwge1xuICBzdGF0dXM6IFF1ZXJ5U3RhdHVzLmZ1bGZpbGxlZDtcbiAgaXNVbmluaXRpYWxpemVkOiBmYWxzZTtcbiAgaXNMb2FkaW5nOiBmYWxzZTtcbiAgaXNTdWNjZXNzOiB0cnVlO1xuICBpc0Vycm9yOiBmYWxzZTtcbn0gfCB7XG4gIHN0YXR1czogUXVlcnlTdGF0dXMucmVqZWN0ZWQ7XG4gIGlzVW5pbml0aWFsaXplZDogZmFsc2U7XG4gIGlzTG9hZGluZzogZmFsc2U7XG4gIGlzU3VjY2VzczogZmFsc2U7XG4gIGlzRXJyb3I6IHRydWU7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlcXVlc3RTdGF0dXNGbGFncyhzdGF0dXM6IFF1ZXJ5U3RhdHVzKTogUmVxdWVzdFN0YXR1c0ZsYWdzIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXMsXG4gICAgaXNVbmluaXRpYWxpemVkOiBzdGF0dXMgPT09IFF1ZXJ5U3RhdHVzLnVuaW5pdGlhbGl6ZWQsXG4gICAgaXNMb2FkaW5nOiBzdGF0dXMgPT09IFF1ZXJ5U3RhdHVzLnBlbmRpbmcsXG4gICAgaXNTdWNjZXNzOiBzdGF0dXMgPT09IFF1ZXJ5U3RhdHVzLmZ1bGZpbGxlZCxcbiAgICBpc0Vycm9yOiBzdGF0dXMgPT09IFF1ZXJ5U3RhdHVzLnJlamVjdGVkXG4gIH0gYXMgYW55O1xufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgU3Vic2NyaXB0aW9uT3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIEhvdyBmcmVxdWVudGx5IHRvIGF1dG9tYXRpY2FsbHkgcmUtZmV0Y2ggZGF0YSAoaW4gbWlsbGlzZWNvbmRzKS4gRGVmYXVsdHMgdG8gYDBgIChvZmYpLlxuICAgKi9cbiAgcG9sbGluZ0ludGVydmFsPzogbnVtYmVyO1xuICAvKipcbiAgICogIERlZmF1bHRzIHRvICdmYWxzZScuIFRoaXMgc2V0dGluZyBhbGxvd3MgeW91IHRvIGNvbnRyb2wgd2hldGhlciBSVEsgUXVlcnkgd2lsbCBjb250aW51ZSBwb2xsaW5nIGlmIHRoZSB3aW5kb3cgaXMgbm90IGZvY3VzZWQuXG4gICAqXG4gICAqICBJZiBwb2xsaW5nSW50ZXJ2YWwgaXMgbm90IHNldCBvciBzZXQgdG8gMCwgdGhpcyAqKndpbGwgbm90IGJlIGV2YWx1YXRlZCoqIHVudGlsIHBvbGxpbmdJbnRlcnZhbCBpcyBncmVhdGVyIHRoYW4gMC5cbiAgICpcbiAgICogIE5vdGU6IHJlcXVpcmVzIFtgc2V0dXBMaXN0ZW5lcnNgXSguL3NldHVwTGlzdGVuZXJzKSB0byBoYXZlIGJlZW4gY2FsbGVkLlxuICAgKi9cbiAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLiBUaGlzIHNldHRpbmcgYWxsb3dzIHlvdSB0byBjb250cm9sIHdoZXRoZXIgUlRLIFF1ZXJ5IHdpbGwgdHJ5IHRvIHJlZmV0Y2ggYWxsIHN1YnNjcmliZWQgcXVlcmllcyBhZnRlciByZWdhaW5pbmcgYSBuZXR3b3JrIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIElmIHlvdSBzcGVjaWZ5IHRoaXMgb3B0aW9uIGFsb25nc2lkZSBgc2tpcDogdHJ1ZWAsIHRoaXMgKip3aWxsIG5vdCBiZSBldmFsdWF0ZWQqKiB1bnRpbCBgc2tpcGAgaXMgZmFsc2UuXG4gICAqXG4gICAqIE5vdGU6IHJlcXVpcmVzIFtgc2V0dXBMaXN0ZW5lcnNgXSguL3NldHVwTGlzdGVuZXJzKSB0byBoYXZlIGJlZW4gY2FsbGVkLlxuICAgKi9cbiAgcmVmZXRjaE9uUmVjb25uZWN0PzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuIFRoaXMgc2V0dGluZyBhbGxvd3MgeW91IHRvIGNvbnRyb2wgd2hldGhlciBSVEsgUXVlcnkgd2lsbCB0cnkgdG8gcmVmZXRjaCBhbGwgc3Vic2NyaWJlZCBxdWVyaWVzIGFmdGVyIHRoZSBhcHBsaWNhdGlvbiB3aW5kb3cgcmVnYWlucyBmb2N1cy5cbiAgICpcbiAgICogSWYgeW91IHNwZWNpZnkgdGhpcyBvcHRpb24gYWxvbmdzaWRlIGBza2lwOiB0cnVlYCwgdGhpcyAqKndpbGwgbm90IGJlIGV2YWx1YXRlZCoqIHVudGlsIGBza2lwYCBpcyBmYWxzZS5cbiAgICpcbiAgICogTm90ZTogcmVxdWlyZXMgW2BzZXR1cExpc3RlbmVyc2BdKC4vc2V0dXBMaXN0ZW5lcnMpIHRvIGhhdmUgYmVlbiBjYWxsZWQuXG4gICAqL1xuICByZWZldGNoT25Gb2N1cz86IGJvb2xlYW47XG59O1xuZXhwb3J0IHR5cGUgU3Vic2NyaWJlcnMgPSB7XG4gIFtyZXF1ZXN0SWQ6IHN0cmluZ106IFN1YnNjcmlwdGlvbk9wdGlvbnM7XG59O1xuZXhwb3J0IHR5cGUgUXVlcnlLZXlzPERlZmluaXRpb25zIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9ucz4gPSB7IFtLIGluIGtleW9mIERlZmluaXRpb25zXTogRGVmaW5pdGlvbnNbS10gZXh0ZW5kcyBRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55PiA/IEsgOiBuZXZlciB9W2tleW9mIERlZmluaXRpb25zXTtcbmV4cG9ydCB0eXBlIEluZmluaXRlUXVlcnlLZXlzPERlZmluaXRpb25zIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9ucz4gPSB7IFtLIGluIGtleW9mIERlZmluaXRpb25zXTogRGVmaW5pdGlvbnNbS10gZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4gPyBLIDogbmV2ZXIgfVtrZXlvZiBEZWZpbml0aW9uc107XG5leHBvcnQgdHlwZSBNdXRhdGlvbktleXM8RGVmaW5pdGlvbnMgZXh0ZW5kcyBFbmRwb2ludERlZmluaXRpb25zPiA9IHsgW0sgaW4ga2V5b2YgRGVmaW5pdGlvbnNdOiBEZWZpbml0aW9uc1tLXSBleHRlbmRzIE11dGF0aW9uRGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+ID8gSyA6IG5ldmVyIH1ba2V5b2YgRGVmaW5pdGlvbnNdO1xudHlwZSBCYXNlUXVlcnlTdWJTdGF0ZTxEIGV4dGVuZHMgQmFzZUVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+LCBEYXRhVHlwZSA9IFJlc3VsdFR5cGVGcm9tPEQ+PiA9IHtcbiAgLyoqXG4gICAqIFRoZSBhcmd1bWVudCBvcmlnaW5hbGx5IHBhc3NlZCBpbnRvIHRoZSBob29rIG9yIGBpbml0aWF0ZWAgYWN0aW9uIGNhbGxcbiAgICovXG4gIG9yaWdpbmFsQXJnczogUXVlcnlBcmdGcm9tQW55UXVlcnk8RD47XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBJRCBhc3NvY2lhdGVkIHdpdGggdGhlIHJlcXVlc3RcbiAgICovXG4gIHJlcXVlc3RJZDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHJlY2VpdmVkIGRhdGEgZnJvbSB0aGUgcXVlcnlcbiAgICovXG4gIGRhdGE/OiBEYXRhVHlwZTtcbiAgLyoqXG4gICAqIFRoZSByZWNlaXZlZCBlcnJvciBpZiBhcHBsaWNhYmxlXG4gICAqL1xuICBlcnJvcj86IFNlcmlhbGl6ZWRFcnJvciB8IChEIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGFueSwgaW5mZXIgQmFzZVF1ZXJ5LCBhbnksIGFueT4gPyBCYXNlUXVlcnlFcnJvcjxCYXNlUXVlcnk+IDogbmV2ZXIpO1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGVuZHBvaW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgcXVlcnlcbiAgICovXG4gIGVuZHBvaW50TmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGltZSB0aGF0IHRoZSBsYXRlc3QgcXVlcnkgc3RhcnRlZFxuICAgKi9cbiAgc3RhcnRlZFRpbWVTdGFtcDogbnVtYmVyO1xuICAvKipcbiAgICogVGltZSB0aGF0IHRoZSBsYXRlc3QgcXVlcnkgd2FzIGZ1bGZpbGxlZFxuICAgKi9cbiAgZnVsZmlsbGVkVGltZVN0YW1wPzogbnVtYmVyO1xufTtcbmV4cG9ydCB0eXBlIFF1ZXJ5U3ViU3RhdGU8RCBleHRlbmRzIEJhc2VFbmRwb2ludERlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55PiwgRGF0YVR5cGUgPSBSZXN1bHRUeXBlRnJvbTxEPj4gPSBJZDwoe1xuICBzdGF0dXM6IFF1ZXJ5U3RhdHVzLmZ1bGZpbGxlZDtcbn0gJiBXaXRoUmVxdWlyZWRQcm9wPEJhc2VRdWVyeVN1YlN0YXRlPEQsIERhdGFUeXBlPiwgJ2RhdGEnIHwgJ2Z1bGZpbGxlZFRpbWVTdGFtcCc+ICYge1xuICBlcnJvcjogdW5kZWZpbmVkO1xufSkgfCAoe1xuICBzdGF0dXM6IFF1ZXJ5U3RhdHVzLnBlbmRpbmc7XG59ICYgQmFzZVF1ZXJ5U3ViU3RhdGU8RCwgRGF0YVR5cGU+KSB8ICh7XG4gIHN0YXR1czogUXVlcnlTdGF0dXMucmVqZWN0ZWQ7XG59ICYgV2l0aFJlcXVpcmVkUHJvcDxCYXNlUXVlcnlTdWJTdGF0ZTxELCBEYXRhVHlwZT4sICdlcnJvcic+KSB8IHtcbiAgc3RhdHVzOiBRdWVyeVN0YXR1cy51bmluaXRpYWxpemVkO1xuICBvcmlnaW5hbEFyZ3M/OiB1bmRlZmluZWQ7XG4gIGRhdGE/OiB1bmRlZmluZWQ7XG4gIGVycm9yPzogdW5kZWZpbmVkO1xuICByZXF1ZXN0SWQ/OiB1bmRlZmluZWQ7XG4gIGVuZHBvaW50TmFtZT86IHN0cmluZztcbiAgc3RhcnRlZFRpbWVTdGFtcD86IHVuZGVmaW5lZDtcbiAgZnVsZmlsbGVkVGltZVN0YW1wPzogdW5kZWZpbmVkO1xufT47XG5leHBvcnQgdHlwZSBJbmZpbml0ZVF1ZXJ5RGlyZWN0aW9uID0gJ2ZvcndhcmQnIHwgJ2JhY2t3YXJkJztcbmV4cG9ydCB0eXBlIEluZmluaXRlUXVlcnlTdWJTdGF0ZTxEIGV4dGVuZHMgQmFzZUVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+PiA9IEQgZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4gPyBRdWVyeVN1YlN0YXRlPEQsIEluZmluaXRlRGF0YTxSZXN1bHRUeXBlRnJvbTxEPiwgUGFnZVBhcmFtRnJvbTxEPj4+ICYge1xuICBkaXJlY3Rpb24/OiBJbmZpbml0ZVF1ZXJ5RGlyZWN0aW9uO1xufSA6IG5ldmVyO1xudHlwZSBCYXNlTXV0YXRpb25TdWJTdGF0ZTxEIGV4dGVuZHMgQmFzZUVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+PiA9IHtcbiAgcmVxdWVzdElkOiBzdHJpbmc7XG4gIGRhdGE/OiBSZXN1bHRUeXBlRnJvbTxEPjtcbiAgZXJyb3I/OiBTZXJpYWxpemVkRXJyb3IgfCAoRCBleHRlbmRzIE11dGF0aW9uRGVmaW5pdGlvbjxhbnksIGluZmVyIEJhc2VRdWVyeSwgYW55LCBhbnk+ID8gQmFzZVF1ZXJ5RXJyb3I8QmFzZVF1ZXJ5PiA6IG5ldmVyKTtcbiAgZW5kcG9pbnROYW1lOiBzdHJpbmc7XG4gIHN0YXJ0ZWRUaW1lU3RhbXA6IG51bWJlcjtcbiAgZnVsZmlsbGVkVGltZVN0YW1wPzogbnVtYmVyO1xufTtcbmV4cG9ydCB0eXBlIE11dGF0aW9uU3ViU3RhdGU8RCBleHRlbmRzIEJhc2VFbmRwb2ludERlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55Pj4gPSAoKHtcbiAgc3RhdHVzOiBRdWVyeVN0YXR1cy5mdWxmaWxsZWQ7XG59ICYgV2l0aFJlcXVpcmVkUHJvcDxCYXNlTXV0YXRpb25TdWJTdGF0ZTxEPiwgJ2RhdGEnIHwgJ2Z1bGZpbGxlZFRpbWVTdGFtcCc+KSAmIHtcbiAgZXJyb3I6IHVuZGVmaW5lZDtcbn0pIHwgKCh7XG4gIHN0YXR1czogUXVlcnlTdGF0dXMucGVuZGluZztcbn0gJiBCYXNlTXV0YXRpb25TdWJTdGF0ZTxEPikgJiB7XG4gIGRhdGE/OiB1bmRlZmluZWQ7XG59KSB8ICh7XG4gIHN0YXR1czogUXVlcnlTdGF0dXMucmVqZWN0ZWQ7XG59ICYgV2l0aFJlcXVpcmVkUHJvcDxCYXNlTXV0YXRpb25TdWJTdGF0ZTxEPiwgJ2Vycm9yJz4pIHwge1xuICByZXF1ZXN0SWQ/OiB1bmRlZmluZWQ7XG4gIHN0YXR1czogUXVlcnlTdGF0dXMudW5pbml0aWFsaXplZDtcbiAgZGF0YT86IHVuZGVmaW5lZDtcbiAgZXJyb3I/OiB1bmRlZmluZWQ7XG4gIGVuZHBvaW50TmFtZT86IHN0cmluZztcbiAgc3RhcnRlZFRpbWVTdGFtcD86IHVuZGVmaW5lZDtcbiAgZnVsZmlsbGVkVGltZVN0YW1wPzogdW5kZWZpbmVkO1xufTtcbmV4cG9ydCB0eXBlIENvbWJpbmVkU3RhdGU8RCBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbnMsIEUgZXh0ZW5kcyBzdHJpbmcsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nPiA9IHtcbiAgcXVlcmllczogUXVlcnlTdGF0ZTxEPjtcbiAgbXV0YXRpb25zOiBNdXRhdGlvblN0YXRlPEQ+O1xuICBwcm92aWRlZDogSW52YWxpZGF0aW9uU3RhdGU8RT47XG4gIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvblN0YXRlO1xuICBjb25maWc6IENvbmZpZ1N0YXRlPFJlZHVjZXJQYXRoPjtcbn07XG5leHBvcnQgdHlwZSBJbnZhbGlkYXRpb25TdGF0ZTxUYWdUeXBlcyBleHRlbmRzIHN0cmluZz4gPSB7XG4gIHRhZ3M6IHsgW18gaW4gVGFnVHlwZXNdOiB7XG4gICAgW2lkOiBzdHJpbmddOiBBcnJheTxRdWVyeUNhY2hlS2V5PjtcbiAgICBbaWQ6IG51bWJlcl06IEFycmF5PFF1ZXJ5Q2FjaGVLZXk+O1xuICB9IH07XG4gIGtleXM6IFJlY29yZDxRdWVyeUNhY2hlS2V5LCBBcnJheTxGdWxsVGFnRGVzY3JpcHRpb248YW55Pj4+O1xufTtcbmV4cG9ydCB0eXBlIFF1ZXJ5U3RhdGU8RCBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbnM+ID0ge1xuICBbcXVlcnlDYWNoZUtleTogc3RyaW5nXTogUXVlcnlTdWJTdGF0ZTxEW3N0cmluZ10+IHwgSW5maW5pdGVRdWVyeVN1YlN0YXRlPERbc3RyaW5nXT4gfCB1bmRlZmluZWQ7XG59O1xuZXhwb3J0IHR5cGUgU3Vic2NyaXB0aW9uU3RhdGUgPSB7XG4gIFtxdWVyeUNhY2hlS2V5OiBzdHJpbmddOiBTdWJzY3JpYmVycyB8IHVuZGVmaW5lZDtcbn07XG5leHBvcnQgdHlwZSBDb25maWdTdGF0ZTxSZWR1Y2VyUGF0aD4gPSBSZWZldGNoQ29uZmlnT3B0aW9ucyAmIHtcbiAgcmVkdWNlclBhdGg6IFJlZHVjZXJQYXRoO1xuICBvbmxpbmU6IGJvb2xlYW47XG4gIGZvY3VzZWQ6IGJvb2xlYW47XG4gIG1pZGRsZXdhcmVSZWdpc3RlcmVkOiBib29sZWFuIHwgJ2NvbmZsaWN0Jztcbn0gJiBNb2RpZmlhYmxlQ29uZmlnU3RhdGU7XG5leHBvcnQgdHlwZSBNb2RpZmlhYmxlQ29uZmlnU3RhdGUgPSB7XG4gIGtlZXBVbnVzZWREYXRhRm9yOiBudW1iZXI7XG4gIGludmFsaWRhdGlvbkJlaGF2aW9yOiAnZGVsYXllZCcgfCAnaW1tZWRpYXRlbHknO1xufSAmIFJlZmV0Y2hDb25maWdPcHRpb25zO1xuZXhwb3J0IHR5cGUgTXV0YXRpb25TdGF0ZTxEIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9ucz4gPSB7XG4gIFtyZXF1ZXN0SWQ6IHN0cmluZ106IE11dGF0aW9uU3ViU3RhdGU8RFtzdHJpbmddPiB8IHVuZGVmaW5lZDtcbn07XG5leHBvcnQgdHlwZSBSb290U3RhdGU8RGVmaW5pdGlvbnMgZXh0ZW5kcyBFbmRwb2ludERlZmluaXRpb25zLCBUYWdUeXBlcyBleHRlbmRzIHN0cmluZywgUmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmc+ID0geyBbUCBpbiBSZWR1Y2VyUGF0aF06IENvbWJpbmVkU3RhdGU8RGVmaW5pdGlvbnMsIFRhZ1R5cGVzLCBQPiB9OyIsIi8vIFRoaXMgZmlsZSBleGlzdHMgdG8gY29uc29saWRhdGUgYWxsIG9mIHRoZSBpbXBvcnRzIGZyb20gdGhlIGBAcmVkdXhqcy90b29sa2l0YCBwYWNrYWdlLlxuLy8gRVNCdWlsZCBkb2VzIG5vdCBkZS1kdXBsaWNhdGUgaW1wb3J0cywgc28gdGhpcyBmaWxlIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgZWFjaCBtZXRob2Rcbi8vIGltcG9ydGVkIGlzIG9ubHkgbGlzdGVkIG9uY2UsIGFuZCB0aGVyZSdzIG9ubHkgb25lIG1lbnRpb24gb2YgdGhlIGBAcmVkdXhqcy90b29sa2l0YCBwYWNrYWdlLlxuXG5leHBvcnQgeyBjcmVhdGVBY3Rpb24sIGNyZWF0ZVNsaWNlLCBjcmVhdGVTZWxlY3RvciwgY3JlYXRlQXN5bmNUaHVuaywgY29tYmluZVJlZHVjZXJzLCBjcmVhdGVOZXh0U3RhdGUsIGlzQW55T2YsIGlzQWxsT2YsIGlzQWN0aW9uLCBpc1BlbmRpbmcsIGlzUmVqZWN0ZWQsIGlzRnVsZmlsbGVkLCBpc1JlamVjdGVkV2l0aFZhbHVlLCBpc0FzeW5jVGh1bmtBY3Rpb24sIHByZXBhcmVBdXRvQmF0Y2hlZCwgU0hPVUxEX0FVVE9CQVRDSCwgaXNQbGFpbk9iamVjdCwgbmFub2lkIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7IiwiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCBhcyBfaVBPIH0gZnJvbSAnLi4vY29yZS9ydGtJbXBvcnRzJztcblxuLy8gcmVtb3ZlIHR5cGUgZ3VhcmRcbmNvbnN0IGlzUGxhaW5PYmplY3Q6IChfOiBhbnkpID0+IGJvb2xlYW4gPSBfaVBPO1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmc8VD4ob2xkT2JqOiBhbnksIG5ld09iajogVCk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gY29weVdpdGhTdHJ1Y3R1cmFsU2hhcmluZyhvbGRPYmo6IGFueSwgbmV3T2JqOiBhbnkpOiBhbnkge1xuICBpZiAob2xkT2JqID09PSBuZXdPYmogfHwgIShpc1BsYWluT2JqZWN0KG9sZE9iaikgJiYgaXNQbGFpbk9iamVjdChuZXdPYmopIHx8IEFycmF5LmlzQXJyYXkob2xkT2JqKSAmJiBBcnJheS5pc0FycmF5KG5ld09iaikpKSB7XG4gICAgcmV0dXJuIG5ld09iajtcbiAgfVxuICBjb25zdCBuZXdLZXlzID0gT2JqZWN0LmtleXMobmV3T2JqKTtcbiAgY29uc3Qgb2xkS2V5cyA9IE9iamVjdC5rZXlzKG9sZE9iaik7XG4gIGxldCBpc1NhbWVPYmplY3QgPSBuZXdLZXlzLmxlbmd0aCA9PT0gb2xkS2V5cy5sZW5ndGg7XG4gIGNvbnN0IG1lcmdlT2JqOiBhbnkgPSBBcnJheS5pc0FycmF5KG5ld09iaikgPyBbXSA6IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBuZXdLZXlzKSB7XG4gICAgbWVyZ2VPYmpba2V5XSA9IGNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmcob2xkT2JqW2tleV0sIG5ld09ialtrZXldKTtcbiAgICBpZiAoaXNTYW1lT2JqZWN0KSBpc1NhbWVPYmplY3QgPSBvbGRPYmpba2V5XSA9PT0gbWVyZ2VPYmpba2V5XTtcbiAgfVxuICByZXR1cm4gaXNTYW1lT2JqZWN0ID8gb2xkT2JqIDogbWVyZ2VPYmo7XG59IiwiLy8gRmFzdCBtZXRob2QgZm9yIGNvdW50aW5nIGFuIG9iamVjdCdzIGtleXNcbi8vIHdpdGhvdXQgcmVzb3J0aW5nIHRvIGBPYmplY3Qua2V5cyhvYmopLmxlbmd0aFxuLy8gV2lsbCB0aGlzIG1ha2UgYSBiaWcgZGlmZmVyZW5jZSBpbiBwZXJmPyBQcm9iYWJseSBub3Rcbi8vIEJ1dCB3ZSBjYW4gc2F2ZSBhIGZldyBhbGxvY2F0aW9ucy5cblxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50T2JqZWN0S2V5cyhvYmo6IFJlY29yZDxhbnksIGFueT4pIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChjb25zdCBfa2V5IGluIG9iaikge1xuICAgIGNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufSIsIi8qKlxyXG4gKiBBbHRlcm5hdGl2ZSB0byBgQXJyYXkuZmxhdCgxKWBcclxuICogQHBhcmFtIGFyciBBbiBhcnJheSBsaWtlIFsxLDIsMyxbMSwyXV1cclxuICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmxhdFxyXG4gKi9cbmV4cG9ydCBjb25zdCBmbGF0dGVuID0gKGFycjogcmVhZG9ubHkgYW55W10pID0+IFtdLmNvbmNhdCguLi5hcnIpOyIsIi8qKlxyXG4gKiBJZiBlaXRoZXIgOi8vIG9yIC8vIGlzIHByZXNlbnQgY29uc2lkZXIgaXQgdG8gYmUgYW4gYWJzb2x1dGUgdXJsXHJcbiAqXHJcbiAqIEBwYXJhbSB1cmwgc3RyaW5nXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNBYnNvbHV0ZVVybCh1cmw6IHN0cmluZykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgKF58OikvL2ApLnRlc3QodXJsKTtcbn0iLCIvKipcclxuICogQXNzdW1lcyB0cnVlIGZvciBhIG5vbi1icm93c2VyIGVudiwgb3RoZXJ3aXNlIG1ha2VzIGEgYmVzdCBlZmZvcnRcclxuICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L3Zpc2liaWxpdHlTdGF0ZVxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RvY3VtZW50VmlzaWJsZSgpOiBib29sZWFuIHtcbiAgLy8gYGRvY3VtZW50YCBtYXkgbm90IGV4aXN0IGluIG5vbi1icm93c2VyIGVudnMgKGxpa2UgUk4pXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gTWF0Y2ggdHJ1ZSBmb3IgdmlzaWJsZSwgcHJlcmVuZGVyLCB1bmRlZmluZWRcbiAgcmV0dXJuIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSAhPT0gJ2hpZGRlbic7XG59IiwiZXhwb3J0IGZ1bmN0aW9uIGlzTm90TnVsbGlzaDxUPih2OiBUIHwgbnVsbCB8IHVuZGVmaW5lZCk6IHYgaXMgVCB7XG4gIHJldHVybiB2ICE9IG51bGw7XG59IiwiLyoqXG4gKiBBc3N1bWVzIGEgYnJvd3NlciBpcyBvbmxpbmUgaWYgYHVuZGVmaW5lZGAsIG90aGVyd2lzZSBtYWtlcyBhIGJlc3QgZWZmb3J0XG4gKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTmF2aWdhdG9yT25MaW5lL29uTGluZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPbmxpbmUoKSB7XG4gIC8vIFdlIHNldCB0aGUgZGVmYXVsdCBjb25maWcgdmFsdWUgaW4gdGhlIHN0b3JlLCBzbyB3ZSdkIG5lZWQgdG8gY2hlY2sgZm9yIHRoaXMgaW4gYSBTU1IgZW52XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBuYXZpZ2F0b3Iub25MaW5lID09PSB1bmRlZmluZWQgPyB0cnVlIDogbmF2aWdhdG9yLm9uTGluZTtcbn0iLCJpbXBvcnQgeyBpc0Fic29sdXRlVXJsIH0gZnJvbSAnLi9pc0Fic29sdXRlVXJsJztcbmNvbnN0IHdpdGhvdXRUcmFpbGluZ1NsYXNoID0gKHVybDogc3RyaW5nKSA9PiB1cmwucmVwbGFjZSgvXFwvJC8sICcnKTtcbmNvbnN0IHdpdGhvdXRMZWFkaW5nU2xhc2ggPSAodXJsOiBzdHJpbmcpID0+IHVybC5yZXBsYWNlKC9eXFwvLywgJycpO1xuZXhwb3J0IGZ1bmN0aW9uIGpvaW5VcmxzKGJhc2U6IHN0cmluZyB8IHVuZGVmaW5lZCwgdXJsOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICBpZiAoIWJhc2UpIHtcbiAgICByZXR1cm4gdXJsITtcbiAgfVxuICBpZiAoIXVybCkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGlmIChpc0Fic29sdXRlVXJsKHVybCkpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGNvbnN0IGRlbGltaXRlciA9IGJhc2UuZW5kc1dpdGgoJy8nKSB8fCAhdXJsLnN0YXJ0c1dpdGgoJz8nKSA/ICcvJyA6ICcnO1xuICBiYXNlID0gd2l0aG91dFRyYWlsaW5nU2xhc2goYmFzZSk7XG4gIHVybCA9IHdpdGhvdXRMZWFkaW5nU2xhc2godXJsKTtcbiAgcmV0dXJuIGAke2Jhc2V9JHtkZWxpbWl0ZXJ9JHt1cmx9YDtcbn0iLCJleHBvcnQgZnVuY3Rpb24gZ2V0T3JJbnNlcnQ8SyBleHRlbmRzIG9iamVjdCwgVj4obWFwOiBXZWFrTWFwPEssIFY+LCBrZXk6IEssIHZhbHVlOiBWKTogVjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRPckluc2VydDxLLCBWPihtYXA6IE1hcDxLLCBWPiwga2V5OiBLLCB2YWx1ZTogVik6IFY7XG5leHBvcnQgZnVuY3Rpb24gZ2V0T3JJbnNlcnQ8SyBleHRlbmRzIG9iamVjdCwgVj4obWFwOiBNYXA8SywgVj4gfCBXZWFrTWFwPEssIFY+LCBrZXk6IEssIHZhbHVlOiBWKTogViB7XG4gIGlmIChtYXAuaGFzKGtleSkpIHJldHVybiBtYXAuZ2V0KGtleSkgYXMgVjtcbiAgcmV0dXJuIG1hcC5zZXQoa2V5LCB2YWx1ZSkuZ2V0KGtleSkgYXMgVjtcbn0iLCJpbXBvcnQgeyBqb2luVXJscyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4vY29yZS9ydGtJbXBvcnRzJztcbmltcG9ydCB0eXBlIHsgQmFzZVF1ZXJ5QXBpLCBCYXNlUXVlcnlGbiB9IGZyb20gJy4vYmFzZVF1ZXJ5VHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBNYXliZVByb21pc2UsIE92ZXJyaWRlIH0gZnJvbSAnLi90c0hlbHBlcnMnO1xuZXhwb3J0IHR5cGUgUmVzcG9uc2VIYW5kbGVyID0gJ2NvbnRlbnQtdHlwZScgfCAnanNvbicgfCAndGV4dCcgfCAoKHJlc3BvbnNlOiBSZXNwb25zZSkgPT4gUHJvbWlzZTxhbnk+KTtcbnR5cGUgQ3VzdG9tUmVxdWVzdEluaXQgPSBPdmVycmlkZTxSZXF1ZXN0SW5pdCwge1xuICBoZWFkZXJzPzogSGVhZGVycyB8IHN0cmluZ1tdW10gfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+IHwgdW5kZWZpbmVkO1xufT47XG5leHBvcnQgaW50ZXJmYWNlIEZldGNoQXJncyBleHRlbmRzIEN1c3RvbVJlcXVlc3RJbml0IHtcbiAgdXJsOiBzdHJpbmc7XG4gIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIGJvZHk/OiBhbnk7XG4gIHJlc3BvbnNlSGFuZGxlcj86IFJlc3BvbnNlSGFuZGxlcjtcbiAgdmFsaWRhdGVTdGF0dXM/OiAocmVzcG9uc2U6IFJlc3BvbnNlLCBib2R5OiBhbnkpID0+IGJvb2xlYW47XG4gIC8qKlxuICAgKiBBIG51bWJlciBpbiBtaWxsaXNlY29uZHMgdGhhdCByZXByZXNlbnRzIHRoYXQgbWF4aW11bSB0aW1lIGEgcmVxdWVzdCBjYW4gdGFrZSBiZWZvcmUgdGltaW5nIG91dC5cbiAgICovXG4gIHRpbWVvdXQ/OiBudW1iZXI7XG59XG5cbi8qKlxuICogQSBtaW5pLXdyYXBwZXIgdGhhdCBwYXNzZXMgYXJndW1lbnRzIHN0cmFpZ2h0IHRocm91Z2ggdG9cbiAqIHtAbGluayBbZmV0Y2hdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkpfS5cbiAqIEF2b2lkcyBzdG9yaW5nIGBmZXRjaGAgaW4gYSBjbG9zdXJlLCBpbiBvcmRlciB0byBwZXJtaXQgbW9ja2luZy9tb25rZXktcGF0Y2hpbmcuXG4gKi9cbmNvbnN0IGRlZmF1bHRGZXRjaEZuOiB0eXBlb2YgZmV0Y2ggPSAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncyk7XG5jb25zdCBkZWZhdWx0VmFsaWRhdGVTdGF0dXMgPSAocmVzcG9uc2U6IFJlc3BvbnNlKSA9PiByZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8PSAyOTk7XG5jb25zdCBkZWZhdWx0SXNKc29uQ29udGVudFR5cGUgPSAoaGVhZGVyczogSGVhZGVycykgPT4gLyphcHBsaWNhdCovL2lvblxcLyh2bmRcXC5hcGlcXCspP2pzb24vLnRlc3QoaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnKTtcbmV4cG9ydCB0eXBlIEZldGNoQmFzZVF1ZXJ5RXJyb3IgPSB7XG4gIC8qKlxuICAgKiAqIGBudW1iZXJgOlxuICAgKiAgIEhUVFAgc3RhdHVzIGNvZGVcbiAgICovXG4gIHN0YXR1czogbnVtYmVyO1xuICBkYXRhOiB1bmtub3duO1xufSB8IHtcbiAgLyoqXG4gICAqICogYFwiRkVUQ0hfRVJST1JcImA6XG4gICAqICAgQW4gZXJyb3IgdGhhdCBvY2N1cnJlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIGBmZXRjaGAgb3IgdGhlIGBmZXRjaEZuYCBjYWxsYmFjayBvcHRpb25cbiAgICoqL1xuICBzdGF0dXM6ICdGRVRDSF9FUlJPUic7XG4gIGRhdGE/OiB1bmRlZmluZWQ7XG4gIGVycm9yOiBzdHJpbmc7XG59IHwge1xuICAvKipcbiAgICogKiBgXCJQQVJTSU5HX0VSUk9SXCJgOlxuICAgKiAgIEFuIGVycm9yIGhhcHBlbmVkIGR1cmluZyBwYXJzaW5nLlxuICAgKiAgIE1vc3QgbGlrZWx5IGEgbm9uLUpTT04tcmVzcG9uc2Ugd2FzIHJldHVybmVkIHdpdGggdGhlIGRlZmF1bHQgYHJlc3BvbnNlSGFuZGxlcmAgXCJKU09OXCIsXG4gICAqICAgb3IgYW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZXhlY3V0aW5nIGEgY3VzdG9tIGByZXNwb25zZUhhbmRsZXJgLlxuICAgKiovXG4gIHN0YXR1czogJ1BBUlNJTkdfRVJST1InO1xuICBvcmlnaW5hbFN0YXR1czogbnVtYmVyO1xuICBkYXRhOiBzdHJpbmc7XG4gIGVycm9yOiBzdHJpbmc7XG59IHwge1xuICAvKipcbiAgICogKiBgXCJUSU1FT1VUX0VSUk9SXCJgOlxuICAgKiAgIFJlcXVlc3QgdGltZWQgb3V0XG4gICAqKi9cbiAgc3RhdHVzOiAnVElNRU9VVF9FUlJPUic7XG4gIGRhdGE/OiB1bmRlZmluZWQ7XG4gIGVycm9yOiBzdHJpbmc7XG59IHwge1xuICAvKipcbiAgICogKiBgXCJDVVNUT01fRVJST1JcImA6XG4gICAqICAgQSBjdXN0b20gZXJyb3IgdHlwZSB0aGF0IHlvdSBjYW4gcmV0dXJuIGZyb20geW91ciBgcXVlcnlGbmAgd2hlcmUgYW5vdGhlciBlcnJvciBtaWdodCBub3QgbWFrZSBzZW5zZS5cbiAgICoqL1xuICBzdGF0dXM6ICdDVVNUT01fRVJST1InO1xuICBkYXRhPzogdW5rbm93bjtcbiAgZXJyb3I6IHN0cmluZztcbn07XG5mdW5jdGlvbiBzdHJpcFVuZGVmaW5lZChvYmo6IGFueSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgY29uc3QgY29weTogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcbiAgICAuLi5vYmpcbiAgfTtcbiAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoY29weSkpIHtcbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSBkZWxldGUgY29weVtrXTtcbiAgfVxuICByZXR1cm4gY29weTtcbn1cbmV4cG9ydCB0eXBlIEZldGNoQmFzZVF1ZXJ5QXJncyA9IHtcbiAgYmFzZVVybD86IHN0cmluZztcbiAgcHJlcGFyZUhlYWRlcnM/OiAoaGVhZGVyczogSGVhZGVycywgYXBpOiBQaWNrPEJhc2VRdWVyeUFwaSwgJ2dldFN0YXRlJyB8ICdleHRyYScgfCAnZW5kcG9pbnQnIHwgJ3R5cGUnIHwgJ2ZvcmNlZCc+ICYge1xuICAgIGFyZzogc3RyaW5nIHwgRmV0Y2hBcmdzO1xuICAgIGV4dHJhT3B0aW9uczogdW5rbm93bjtcbiAgfSkgPT4gTWF5YmVQcm9taXNlPEhlYWRlcnMgfCB2b2lkPjtcbiAgZmV0Y2hGbj86IChpbnB1dDogUmVxdWVzdEluZm8sIGluaXQ/OiBSZXF1ZXN0SW5pdCB8IHVuZGVmaW5lZCkgPT4gUHJvbWlzZTxSZXNwb25zZT47XG4gIHBhcmFtc1NlcmlhbGl6ZXI/OiAocGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBzdHJpbmc7XG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0LCB3ZSBvbmx5IGNoZWNrIGZvciAnYXBwbGljYXRpb24vanNvbicgYW5kICdhcHBsaWNhdGlvbi92bmQuYXBpK2pzb24nIGFzIHRoZSBjb250ZW50LXR5cGVzIGZvciBqc29uLiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0IGFub3RoZXIgZm9ybWF0LCB5b3UgY2FuIHBhc3NcbiAgICogaW4gYSBwcmVkaWNhdGUgZnVuY3Rpb24gZm9yIHlvdXIgZ2l2ZW4gYXBpIHRvIGdldCB0aGUgc2FtZSBhdXRvbWF0aWMgc3RyaW5naWZ5aW5nIGJlaGF2aW9yXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IGlzSnNvbkNvbnRlbnRUeXBlID0gKGhlYWRlcnM6IEhlYWRlcnMpID0+IFtcImFwcGxpY2F0aW9uL3ZuZC5hcGkranNvblwiLCBcImFwcGxpY2F0aW9uL2pzb25cIiwgXCJhcHBsaWNhdGlvbi92bmQuaGFsK2pzb25cIl0uaW5jbHVkZXMoaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik/LnRyaW0oKSk7XG4gICAqIGBgYFxuICAgKi9cbiAgaXNKc29uQ29udGVudFR5cGU/OiAoaGVhZGVyczogSGVhZGVycykgPT4gYm9vbGVhbjtcbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIGBhcHBsaWNhdGlvbi9qc29uYDtcbiAgICovXG4gIGpzb25Db250ZW50VHlwZT86IHN0cmluZztcblxuICAvKipcbiAgICogQ3VzdG9tIHJlcGxhY2VyIGZ1bmN0aW9uIHVzZWQgd2hlbiBjYWxsaW5nIGBKU09OLnN0cmluZ2lmeSgpYDtcbiAgICovXG4gIGpzb25SZXBsYWNlcj86ICh0aGlzOiBhbnksIGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiBhbnk7XG59ICYgUmVxdWVzdEluaXQgJiBQaWNrPEZldGNoQXJncywgJ3Jlc3BvbnNlSGFuZGxlcicgfCAndmFsaWRhdGVTdGF0dXMnIHwgJ3RpbWVvdXQnPjtcbmV4cG9ydCB0eXBlIEZldGNoQmFzZVF1ZXJ5TWV0YSA9IHtcbiAgcmVxdWVzdDogUmVxdWVzdDtcbiAgcmVzcG9uc2U/OiBSZXNwb25zZTtcbn07XG5cbi8qKlxuICogVGhpcyBpcyBhIHZlcnkgc21hbGwgd3JhcHBlciBhcm91bmQgZmV0Y2ggdGhhdCBhaW1zIHRvIHNpbXBsaWZ5IHJlcXVlc3RzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgYmFzZVF1ZXJ5ID0gZmV0Y2hCYXNlUXVlcnkoe1xuICogICBiYXNlVXJsOiAnaHR0cHM6Ly9hcGkueW91ci1yZWFsbHktZ3JlYXQtYXBwLmNvbS92MS8nLFxuICogICBwcmVwYXJlSGVhZGVyczogKGhlYWRlcnMsIHsgZ2V0U3RhdGUgfSkgPT4ge1xuICogICAgIGNvbnN0IHRva2VuID0gKGdldFN0YXRlKCkgYXMgUm9vdFN0YXRlKS5hdXRoLnRva2VuO1xuICogICAgIC8vIElmIHdlIGhhdmUgYSB0b2tlbiBzZXQgaW4gc3RhdGUsIGxldCdzIGFzc3VtZSB0aGF0IHdlIHNob3VsZCBiZSBwYXNzaW5nIGl0LlxuICogICAgIGlmICh0b2tlbikge1xuICogICAgICAgaGVhZGVycy5zZXQoJ2F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7dG9rZW59YCk7XG4gKiAgICAgfVxuICogICAgIHJldHVybiBoZWFkZXJzO1xuICogICB9LFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVXJsXG4gKiBUaGUgYmFzZSBVUkwgZm9yIGFuIEFQSSBzZXJ2aWNlLlxuICogVHlwaWNhbGx5IGluIHRoZSBmb3JtYXQgb2YgaHR0cHM6Ly9leGFtcGxlLmNvbS9cbiAqXG4gKiBAcGFyYW0geyhoZWFkZXJzOiBIZWFkZXJzLCBhcGk6IHsgZ2V0U3RhdGU6ICgpID0+IHVua25vd247IGFyZzogc3RyaW5nIHwgRmV0Y2hBcmdzOyBleHRyYTogdW5rbm93bjsgZW5kcG9pbnQ6IHN0cmluZzsgdHlwZTogJ3F1ZXJ5JyB8ICdtdXRhdGlvbic7IGZvcmNlZDogYm9vbGVhbjsgfSkgPT4gSGVhZGVyc30gcHJlcGFyZUhlYWRlcnNcbiAqIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW5qZWN0IGhlYWRlcnMgb24gcmVxdWVzdHMuXG4gKiBQcm92aWRlcyBhIEhlYWRlcnMgb2JqZWN0LCBtb3N0IG9mIHRoZSBgQmFzZVF1ZXJ5QXBpYCAoYGRpc3BhdGNoYCBpcyBub3QgYXZhaWxhYmxlKSwgYW5kIHRoZSBhcmcgcGFzc2VkIGludG8gdGhlIHF1ZXJ5IGZ1bmN0aW9uLlxuICogVXNlZnVsIGZvciBzZXR0aW5nIGF1dGhlbnRpY2F0aW9uIG9yIGhlYWRlcnMgdGhhdCBuZWVkIHRvIGJlIHNldCBjb25kaXRpb25hbGx5LlxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IZWFkZXJzXG4gKlxuICogQHBhcmFtIHsoaW5wdXQ6IFJlcXVlc3RJbmZvLCBpbml0PzogUmVxdWVzdEluaXQgfCB1bmRlZmluZWQpID0+IFByb21pc2U8UmVzcG9uc2U+fSBmZXRjaEZuXG4gKiBBY2NlcHRzIGEgY3VzdG9tIGBmZXRjaGAgZnVuY3Rpb24gaWYgeW91IGRvIG5vdCB3YW50IHRvIHVzZSB0aGUgZGVmYXVsdCBvbiB0aGUgd2luZG93LlxuICogVXNlZnVsIGluIFNTUiBlbnZpcm9ubWVudHMgaWYgeW91IG5lZWQgdG8gdXNlIGEgbGlicmFyeSBzdWNoIGFzIGBpc29tb3JwaGljLWZldGNoYCBvciBgY3Jvc3MtZmV0Y2hgXG4gKlxuICogQHBhcmFtIHsocGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgPT4gc3RyaW5nfSBwYXJhbXNTZXJpYWxpemVyXG4gKiBBbiBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHN0cmluZ2lmeSBxdWVyeXN0cmluZyBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7KGhlYWRlcnM6IEhlYWRlcnMpID0+IGJvb2xlYW59IGlzSnNvbkNvbnRlbnRUeXBlXG4gKiBBbiBvcHRpb25hbCBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIGBKU09OLnN0cmluZ2lmeSgpYCBzaG91bGQgYmUgY2FsbGVkIG9uIHRoZSBgYm9keWAgYXJnIG9mIGBGZXRjaEFyZ3NgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGpzb25Db250ZW50VHlwZSBVc2VkIHdoZW4gYXV0b21hdGljYWxseSBzZXR0aW5nIHRoZSBjb250ZW50LXR5cGUgaGVhZGVyIGZvciBhIHJlcXVlc3Qgd2l0aCBhIGpzb25pZmlhYmxlIGJvZHkgdGhhdCBkb2VzIG5vdCBoYXZlIGFuIGV4cGxpY2l0IGNvbnRlbnQtdHlwZSBoZWFkZXIuIERlZmF1bHRzIHRvIGBhcHBsaWNhdGlvbi9qc29uYC5cbiAqXG4gKiBAcGFyYW0geyh0aGlzOiBhbnksIGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiBhbnl9IGpzb25SZXBsYWNlciBDdXN0b20gcmVwbGFjZXIgZnVuY3Rpb24gdXNlZCB3aGVuIGNhbGxpbmcgYEpTT04uc3RyaW5naWZ5KClgLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gKiBBIG51bWJlciBpbiBtaWxsaXNlY29uZHMgdGhhdCByZXByZXNlbnRzIHRoZSBtYXhpbXVtIHRpbWUgYSByZXF1ZXN0IGNhbiB0YWtlIGJlZm9yZSB0aW1pbmcgb3V0LlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaEJhc2VRdWVyeSh7XG4gIGJhc2VVcmwsXG4gIHByZXBhcmVIZWFkZXJzID0geCA9PiB4LFxuICBmZXRjaEZuID0gZGVmYXVsdEZldGNoRm4sXG4gIHBhcmFtc1NlcmlhbGl6ZXIsXG4gIGlzSnNvbkNvbnRlbnRUeXBlID0gZGVmYXVsdElzSnNvbkNvbnRlbnRUeXBlLFxuICBqc29uQ29udGVudFR5cGUgPSAnYXBwbGljYXRpb24vanNvbicsXG4gIGpzb25SZXBsYWNlcixcbiAgdGltZW91dDogZGVmYXVsdFRpbWVvdXQsXG4gIHJlc3BvbnNlSGFuZGxlcjogZ2xvYmFsUmVzcG9uc2VIYW5kbGVyLFxuICB2YWxpZGF0ZVN0YXR1czogZ2xvYmFsVmFsaWRhdGVTdGF0dXMsXG4gIC4uLmJhc2VGZXRjaE9wdGlvbnNcbn06IEZldGNoQmFzZVF1ZXJ5QXJncyA9IHt9KTogQmFzZVF1ZXJ5Rm48c3RyaW5nIHwgRmV0Y2hBcmdzLCB1bmtub3duLCBGZXRjaEJhc2VRdWVyeUVycm9yLCB7fSwgRmV0Y2hCYXNlUXVlcnlNZXRhPiB7XG4gIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnICYmIGZldGNoRm4gPT09IGRlZmF1bHRGZXRjaEZuKSB7XG4gICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBgZmV0Y2hgIGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBzdXBwbHkgYSBjdXN0b20gYGZldGNoRm5gIHByb3BlcnR5IHRvIHVzZSBgZmV0Y2hCYXNlUXVlcnlgIG9uIFNTUiBlbnZpcm9ubWVudHMuJyk7XG4gIH1cbiAgcmV0dXJuIGFzeW5jIChhcmcsIGFwaSwgZXh0cmFPcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZ2V0U3RhdGUsXG4gICAgICBleHRyYSxcbiAgICAgIGVuZHBvaW50LFxuICAgICAgZm9yY2VkLFxuICAgICAgdHlwZVxuICAgIH0gPSBhcGk7XG4gICAgbGV0IG1ldGE6IEZldGNoQmFzZVF1ZXJ5TWV0YSB8IHVuZGVmaW5lZDtcbiAgICBsZXQge1xuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGJhc2VGZXRjaE9wdGlvbnMuaGVhZGVycyksXG4gICAgICBwYXJhbXMgPSB1bmRlZmluZWQsXG4gICAgICByZXNwb25zZUhhbmRsZXIgPSBnbG9iYWxSZXNwb25zZUhhbmRsZXIgPz8gJ2pzb24nIGFzIGNvbnN0LFxuICAgICAgdmFsaWRhdGVTdGF0dXMgPSBnbG9iYWxWYWxpZGF0ZVN0YXR1cyA/PyBkZWZhdWx0VmFsaWRhdGVTdGF0dXMsXG4gICAgICB0aW1lb3V0ID0gZGVmYXVsdFRpbWVvdXQsXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IHR5cGVvZiBhcmcgPT0gJ3N0cmluZycgPyB7XG4gICAgICB1cmw6IGFyZ1xuICAgIH0gOiBhcmc7XG4gICAgbGV0IGFib3J0Q29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgdW5kZWZpbmVkLFxuICAgICAgc2lnbmFsID0gYXBpLnNpZ25hbDtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgYXBpLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0Q29udHJvbGxlci5hYm9ydCk7XG4gICAgICBzaWduYWwgPSBhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgIH1cbiAgICBsZXQgY29uZmlnOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAgIC4uLmJhc2VGZXRjaE9wdGlvbnMsXG4gICAgICBzaWduYWwsXG4gICAgICAuLi5yZXN0XG4gICAgfTtcbiAgICBoZWFkZXJzID0gbmV3IEhlYWRlcnMoc3RyaXBVbmRlZmluZWQoaGVhZGVycykpO1xuICAgIGNvbmZpZy5oZWFkZXJzID0gKGF3YWl0IHByZXBhcmVIZWFkZXJzKGhlYWRlcnMsIHtcbiAgICAgIGdldFN0YXRlLFxuICAgICAgYXJnLFxuICAgICAgZXh0cmEsXG4gICAgICBlbmRwb2ludCxcbiAgICAgIGZvcmNlZCxcbiAgICAgIHR5cGUsXG4gICAgICBleHRyYU9wdGlvbnNcbiAgICB9KSkgfHwgaGVhZGVycztcblxuICAgIC8vIE9ubHkgc2V0IHRoZSBjb250ZW50LXR5cGUgdG8ganNvbiBpZiBhcHByb3ByaWF0ZS4gV2lsbCBub3QgYmUgdHJ1ZSBmb3IgRm9ybURhdGEsIEFycmF5QnVmZmVyLCBCbG9iLCBldGMuXG4gICAgY29uc3QgaXNKc29uaWZpYWJsZSA9IChib2R5OiBhbnkpID0+IHR5cGVvZiBib2R5ID09PSAnb2JqZWN0JyAmJiAoaXNQbGFpbk9iamVjdChib2R5KSB8fCBBcnJheS5pc0FycmF5KGJvZHkpIHx8IHR5cGVvZiBib2R5LnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyk7XG4gICAgaWYgKCFjb25maWcuaGVhZGVycy5oYXMoJ2NvbnRlbnQtdHlwZScpICYmIGlzSnNvbmlmaWFibGUoY29uZmlnLmJvZHkpKSB7XG4gICAgICBjb25maWcuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIGpzb25Db250ZW50VHlwZSk7XG4gICAgfVxuICAgIGlmIChpc0pzb25pZmlhYmxlKGNvbmZpZy5ib2R5KSAmJiBpc0pzb25Db250ZW50VHlwZShjb25maWcuaGVhZGVycykpIHtcbiAgICAgIGNvbmZpZy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoY29uZmlnLmJvZHksIGpzb25SZXBsYWNlcik7XG4gICAgfVxuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIGNvbnN0IGRpdmlkZXIgPSB+dXJsLmluZGV4T2YoJz8nKSA/ICcmJyA6ICc/JztcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gcGFyYW1zU2VyaWFsaXplciA/IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKSA6IG5ldyBVUkxTZWFyY2hQYXJhbXMoc3RyaXBVbmRlZmluZWQocGFyYW1zKSk7XG4gICAgICB1cmwgKz0gZGl2aWRlciArIHF1ZXJ5O1xuICAgIH1cbiAgICB1cmwgPSBqb2luVXJscyhiYXNlVXJsLCB1cmwpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIGNvbmZpZyk7XG4gICAgY29uc3QgcmVxdWVzdENsb25lID0gbmV3IFJlcXVlc3QodXJsLCBjb25maWcpO1xuICAgIG1ldGEgPSB7XG4gICAgICByZXF1ZXN0OiByZXF1ZXN0Q2xvbmVcbiAgICB9O1xuICAgIGxldCByZXNwb25zZSxcbiAgICAgIHRpbWVkT3V0ID0gZmFsc2UsXG4gICAgICB0aW1lb3V0SWQgPSBhYm9ydENvbnRyb2xsZXIgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyIS5hYm9ydCgpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hGbihyZXF1ZXN0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIHN0YXR1czogdGltZWRPdXQgPyAnVElNRU9VVF9FUlJPUicgOiAnRkVUQ0hfRVJST1InLFxuICAgICAgICAgIGVycm9yOiBTdHJpbmcoZSlcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICBhYm9ydENvbnRyb2xsZXI/LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0Q29udHJvbGxlci5hYm9ydCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlQ2xvbmUgPSByZXNwb25zZS5jbG9uZSgpO1xuICAgIG1ldGEucmVzcG9uc2UgPSByZXNwb25zZUNsb25lO1xuICAgIGxldCByZXN1bHREYXRhOiBhbnk7XG4gICAgbGV0IHJlc3BvbnNlVGV4dDogc3RyaW5nID0gJyc7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBoYW5kbGVSZXNwb25zZUVycm9yO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW2hhbmRsZVJlc3BvbnNlKHJlc3BvbnNlLCByZXNwb25zZUhhbmRsZXIpLnRoZW4ociA9PiByZXN1bHREYXRhID0gciwgZSA9PiBoYW5kbGVSZXNwb25zZUVycm9yID0gZSksXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9pc3N1ZXMvNjY1I2lzc3VlY29tbWVudC01Mzg5OTUxODJcbiAgICAgIC8vIHdlICpoYXZlKiB0byBcInVzZSB1cFwiIGJvdGggc3RyZWFtcyBhdCB0aGUgc2FtZSB0aW1lIG9yIHRoZXkgd2lsbCBzdG9wIHJ1bm5pbmcgaW4gbm9kZS1mZXRjaCBzY2VuYXJpb3NcbiAgICAgIHJlc3BvbnNlQ2xvbmUudGV4dCgpLnRoZW4ociA9PiByZXNwb25zZVRleHQgPSByLCAoKSA9PiB7fSldKTtcbiAgICAgIGlmIChoYW5kbGVSZXNwb25zZUVycm9yKSB0aHJvdyBoYW5kbGVSZXNwb25zZUVycm9yO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgc3RhdHVzOiAnUEFSU0lOR19FUlJPUicsXG4gICAgICAgICAgb3JpZ2luYWxTdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICBkYXRhOiByZXNwb25zZVRleHQsXG4gICAgICAgICAgZXJyb3I6IFN0cmluZyhlKVxuICAgICAgICB9LFxuICAgICAgICBtZXRhXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGVTdGF0dXMocmVzcG9uc2UsIHJlc3VsdERhdGEpID8ge1xuICAgICAgZGF0YTogcmVzdWx0RGF0YSxcbiAgICAgIG1ldGFcbiAgICB9IDoge1xuICAgICAgZXJyb3I6IHtcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIGRhdGE6IHJlc3VsdERhdGFcbiAgICAgIH0sXG4gICAgICBtZXRhXG4gICAgfTtcbiAgfTtcbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2UocmVzcG9uc2U6IFJlc3BvbnNlLCByZXNwb25zZUhhbmRsZXI6IFJlc3BvbnNlSGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgcmVzcG9uc2VIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2VIYW5kbGVyKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlSGFuZGxlciA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgIHJlc3BvbnNlSGFuZGxlciA9IGlzSnNvbkNvbnRlbnRUeXBlKHJlc3BvbnNlLmhlYWRlcnMpID8gJ2pzb24nIDogJ3RleHQnO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2VIYW5kbGVyID09PSAnanNvbicpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICByZXR1cm4gdGV4dC5sZW5ndGggPyBKU09OLnBhcnNlKHRleHQpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfVxufSIsImV4cG9ydCBjbGFzcyBIYW5kbGVkRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgdmFsdWU6IGFueSwgcHVibGljIHJlYWRvbmx5IG1ldGE6IGFueSA9IHVuZGVmaW5lZCkge31cbn0iLCJpbXBvcnQgdHlwZSB7IEJhc2VRdWVyeUFwaSwgQmFzZVF1ZXJ5QXJnLCBCYXNlUXVlcnlFbmhhbmNlciwgQmFzZVF1ZXJ5RXJyb3IsIEJhc2VRdWVyeUV4dHJhT3B0aW9ucywgQmFzZVF1ZXJ5Rm4sIEJhc2VRdWVyeU1ldGEgfSBmcm9tICcuL2Jhc2VRdWVyeVR5cGVzJztcbmltcG9ydCB0eXBlIHsgRmV0Y2hCYXNlUXVlcnlFcnJvciB9IGZyb20gJy4vZmV0Y2hCYXNlUXVlcnknO1xuaW1wb3J0IHsgSGFuZGxlZEVycm9yIH0gZnJvbSAnLi9IYW5kbGVkRXJyb3InO1xuXG4vKipcbiAqIEV4cG9uZW50aWFsIGJhY2tvZmYgYmFzZWQgb24gdGhlIGF0dGVtcHQgbnVtYmVyLlxuICpcbiAqIEByZW1hcmtzXG4gKiAxLiA2MDBtcyAqIHJhbmRvbSgwLjQsIDEuNClcbiAqIDIuIDEyMDBtcyAqIHJhbmRvbSgwLjQsIDEuNClcbiAqIDMuIDI0MDBtcyAqIHJhbmRvbSgwLjQsIDEuNClcbiAqIDQuIDQ4MDBtcyAqIHJhbmRvbSgwLjQsIDEuNClcbiAqIDUuIDk2MDBtcyAqIHJhbmRvbSgwLjQsIDEuNClcbiAqXG4gKiBAcGFyYW0gYXR0ZW1wdCAtIEN1cnJlbnQgYXR0ZW1wdFxuICogQHBhcmFtIG1heFJldHJpZXMgLSBNYXhpbXVtIG51bWJlciBvZiByZXRyaWVzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlZmF1bHRCYWNrb2ZmKGF0dGVtcHQ6IG51bWJlciA9IDAsIG1heFJldHJpZXM6IG51bWJlciA9IDUpIHtcbiAgY29uc3QgYXR0ZW1wdHMgPSBNYXRoLm1pbihhdHRlbXB0LCBtYXhSZXRyaWVzKTtcbiAgY29uc3QgdGltZW91dCA9IH5+KChNYXRoLnJhbmRvbSgpICsgMC40KSAqICgzMDAgPDwgYXR0ZW1wdHMpKTsgLy8gRm9yY2UgYSBwb3NpdGl2ZSBpbnQgaW4gdGhlIGNhc2Ugd2UgbWFrZSB0aGlzIGFuIG9wdGlvblxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQoKHJlczogYW55KSA9PiByZXNvbHZlKHJlcyksIHRpbWVvdXQpKTtcbn1cbnR5cGUgUmV0cnlDb25kaXRpb25GdW5jdGlvbiA9IChlcnJvcjogQmFzZVF1ZXJ5RXJyb3I8QmFzZVF1ZXJ5Rm4+LCBhcmdzOiBCYXNlUXVlcnlBcmc8QmFzZVF1ZXJ5Rm4+LCBleHRyYUFyZ3M6IHtcbiAgYXR0ZW1wdDogbnVtYmVyO1xuICBiYXNlUXVlcnlBcGk6IEJhc2VRdWVyeUFwaTtcbiAgZXh0cmFPcHRpb25zOiBCYXNlUXVlcnlFeHRyYU9wdGlvbnM8QmFzZVF1ZXJ5Rm4+ICYgUmV0cnlPcHRpb25zO1xufSkgPT4gYm9vbGVhbjtcbmV4cG9ydCB0eXBlIFJldHJ5T3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIGRlbGF5IGJldHdlZW4gcmV0cmllc1xuICAgKi9cbiAgYmFja29mZj86IChhdHRlbXB0OiBudW1iZXIsIG1heFJldHJpZXM6IG51bWJlcikgPT4gUHJvbWlzZTx2b2lkPjtcbn0gJiAoe1xuICAvKipcbiAgICogSG93IG1hbnkgdGltZXMgdGhlIHF1ZXJ5IHdpbGwgYmUgcmV0cmllZCAoZGVmYXVsdDogNSlcbiAgICovXG4gIG1heFJldHJpZXM/OiBudW1iZXI7XG4gIHJldHJ5Q29uZGl0aW9uPzogdW5kZWZpbmVkO1xufSB8IHtcbiAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGRldGVybWluZSBpZiBhIHJldHJ5IHNob3VsZCBiZSBhdHRlbXB0ZWQuXG4gICAqIFJldHVybiBgdHJ1ZWAgZm9yIGFub3RoZXIgcmV0cnkgYW5kIGBmYWxzZWAgdG8gcXVpdCB0cnlpbmcgcHJlbWF0dXJlbHkuXG4gICAqL1xuICByZXRyeUNvbmRpdGlvbj86IFJldHJ5Q29uZGl0aW9uRnVuY3Rpb247XG4gIG1heFJldHJpZXM/OiB1bmRlZmluZWQ7XG59KTtcbmZ1bmN0aW9uIGZhaWw8QmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4gPSBCYXNlUXVlcnlGbj4oZXJyb3I6IEJhc2VRdWVyeUVycm9yPEJhc2VRdWVyeT4sIG1ldGE/OiBCYXNlUXVlcnlNZXRhPEJhc2VRdWVyeT4pOiBuZXZlciB7XG4gIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEhhbmRsZWRFcnJvcih7XG4gICAgZXJyb3IsXG4gICAgbWV0YVxuICB9KSwge1xuICAgIHRocm93SW1tZWRpYXRlbHk6IHRydWVcbiAgfSk7XG59XG5jb25zdCBFTVBUWV9PUFRJT05TID0ge307XG5jb25zdCByZXRyeVdpdGhCYWNrb2ZmOiBCYXNlUXVlcnlFbmhhbmNlcjx1bmtub3duLCBSZXRyeU9wdGlvbnMsIFJldHJ5T3B0aW9ucyB8IHZvaWQ+ID0gKGJhc2VRdWVyeSwgZGVmYXVsdE9wdGlvbnMpID0+IGFzeW5jIChhcmdzLCBhcGksIGV4dHJhT3B0aW9ucykgPT4ge1xuICAvLyBXZSBuZWVkIHRvIGZpZ3VyZSBvdXQgYG1heFJldHJpZXNgIGJlZm9yZSB3ZSBkZWZpbmUgYGRlZmF1bHRSZXRyeUNvbmRpdGlvbi5cbiAgLy8gVGhpcyBpcyBwcm9iYWJseSBnb29meSwgYnV0IG91Z2h0IHRvIHdvcmsuXG4gIC8vIFB1dCBvdXIgZGVmYXVsdHMgaW4gb25lIGFycmF5LCBmaWx0ZXIgb3V0IHVuZGVmaW5lZHMsIGdyYWIgdGhlIGxhc3QgdmFsdWUuXG4gIGNvbnN0IHBvc3NpYmxlTWF4UmV0cmllczogbnVtYmVyW10gPSBbNSwgKGRlZmF1bHRPcHRpb25zIGFzIGFueSB8fCBFTVBUWV9PUFRJT05TKS5tYXhSZXRyaWVzLCAoZXh0cmFPcHRpb25zIGFzIGFueSB8fCBFTVBUWV9PUFRJT05TKS5tYXhSZXRyaWVzXS5maWx0ZXIoeCA9PiB4ICE9PSB1bmRlZmluZWQpO1xuICBjb25zdCBbbWF4UmV0cmllc10gPSBwb3NzaWJsZU1heFJldHJpZXMuc2xpY2UoLTEpO1xuICBjb25zdCBkZWZhdWx0UmV0cnlDb25kaXRpb246IFJldHJ5Q29uZGl0aW9uRnVuY3Rpb24gPSAoXywgX18sIHtcbiAgICBhdHRlbXB0XG4gIH0pID0+IGF0dGVtcHQgPD0gbWF4UmV0cmllcztcbiAgY29uc3Qgb3B0aW9uczoge1xuICAgIG1heFJldHJpZXM6IG51bWJlcjtcbiAgICBiYWNrb2ZmOiB0eXBlb2YgZGVmYXVsdEJhY2tvZmY7XG4gICAgcmV0cnlDb25kaXRpb246IHR5cGVvZiBkZWZhdWx0UmV0cnlDb25kaXRpb247XG4gIH0gPSB7XG4gICAgbWF4UmV0cmllcyxcbiAgICBiYWNrb2ZmOiBkZWZhdWx0QmFja29mZixcbiAgICByZXRyeUNvbmRpdGlvbjogZGVmYXVsdFJldHJ5Q29uZGl0aW9uLFxuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLmV4dHJhT3B0aW9uc1xuICB9O1xuICBsZXQgcmV0cnkgPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBiYXNlUXVlcnkoYXJncywgYXBpLCBleHRyYU9wdGlvbnMpO1xuICAgICAgLy8gYmFzZVF1ZXJpZXMgX3Nob3VsZF8gcmV0dXJuIGFuIGVycm9yIHByb3BlcnR5LCBzbyB3ZSBzaG91bGQgY2hlY2sgZm9yIHRoYXQgYW5kIHRocm93IGl0IHRvIGNvbnRpbnVlIHJldHJ5aW5nXG4gICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBIYW5kbGVkRXJyb3IocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICByZXRyeSsrO1xuICAgICAgaWYgKGUudGhyb3dJbW1lZGlhdGVseSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEhhbmRsZWRFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgZG9uJ3Qga25vdyB3aGF0IHRoaXMgaXMsIHNvIHdlIGhhdmUgdG8gcmV0aHJvdyBpdFxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBIYW5kbGVkRXJyb3IgJiYgIW9wdGlvbnMucmV0cnlDb25kaXRpb24oZS52YWx1ZS5lcnJvciBhcyBGZXRjaEJhc2VRdWVyeUVycm9yLCBhcmdzLCB7XG4gICAgICAgIGF0dGVtcHQ6IHJldHJ5LFxuICAgICAgICBiYXNlUXVlcnlBcGk6IGFwaSxcbiAgICAgICAgZXh0cmFPcHRpb25zXG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IG9wdGlvbnMuYmFja29mZihyZXRyeSwgb3B0aW9ucy5tYXhSZXRyaWVzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQSB1dGlsaXR5IHRoYXQgY2FuIHdyYXAgYGJhc2VRdWVyeWAgaW4gdGhlIEFQSSBkZWZpbml0aW9uIHRvIHByb3ZpZGUgcmV0cmllcyB3aXRoIGEgYmFzaWMgZXhwb25lbnRpYWwgYmFja29mZi5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiAvLyBjb2RlYmxvY2stbWV0YSB0aXRsZT1cIlJldHJ5IGV2ZXJ5IHJlcXVlc3QgNSB0aW1lcyBieSBkZWZhdWx0XCJcbiAqIGltcG9ydCB7IGNyZWF0ZUFwaSwgZmV0Y2hCYXNlUXVlcnksIHJldHJ5IH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeS9yZWFjdCdcbiAqIGludGVyZmFjZSBQb3N0IHtcbiAqICAgaWQ6IG51bWJlclxuICogICBuYW1lOiBzdHJpbmdcbiAqIH1cbiAqIHR5cGUgUG9zdHNSZXNwb25zZSA9IFBvc3RbXVxuICpcbiAqIC8vIG1heFJldHJpZXM6IDUgaXMgdGhlIGRlZmF1bHQsIGFuZCBjYW4gYmUgb21pdHRlZC4gU2hvd24gZm9yIGRvY3VtZW50YXRpb24gcHVycG9zZXMuXG4gKiBjb25zdCBzdGFnZ2VyZWRCYXNlUXVlcnkgPSByZXRyeShmZXRjaEJhc2VRdWVyeSh7IGJhc2VVcmw6ICcvJyB9KSwgeyBtYXhSZXRyaWVzOiA1IH0pO1xuICogZXhwb3J0IGNvbnN0IGFwaSA9IGNyZWF0ZUFwaSh7XG4gKiAgIGJhc2VRdWVyeTogc3RhZ2dlcmVkQmFzZVF1ZXJ5LFxuICogICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAqICAgICBnZXRQb3N0czogYnVpbGQucXVlcnk8UG9zdHNSZXNwb25zZSwgdm9pZD4oe1xuICogICAgICAgcXVlcnk6ICgpID0+ICh7IHVybDogJ3Bvc3RzJyB9KSxcbiAqICAgICB9KSxcbiAqICAgICBnZXRQb3N0OiBidWlsZC5xdWVyeTxQb3N0c1Jlc3BvbnNlLCBzdHJpbmc+KHtcbiAqICAgICAgIHF1ZXJ5OiAoaWQpID0+ICh7IHVybDogYHBvc3QvJHtpZH1gIH0pLFxuICogICAgICAgZXh0cmFPcHRpb25zOiB7IG1heFJldHJpZXM6IDggfSwgLy8gWW91IGNhbiBvdmVycmlkZSB0aGUgcmV0cnkgYmVoYXZpb3Igb24gZWFjaCBlbmRwb2ludFxuICogICAgIH0pLFxuICogICB9KSxcbiAqIH0pO1xuICpcbiAqIGV4cG9ydCBjb25zdCB7IHVzZUdldFBvc3RzUXVlcnksIHVzZUdldFBvc3RRdWVyeSB9ID0gYXBpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCByZXRyeSA9IC8qIEBfX1BVUkVfXyAqL09iamVjdC5hc3NpZ24ocmV0cnlXaXRoQmFja29mZiwge1xuICBmYWlsXG59KTsiLCJpbXBvcnQgdHlwZSB7IFRodW5rRGlzcGF0Y2gsIEFjdGlvbkNyZWF0b3JXaXRob3V0UGF5bG9hZCAvLyBXb3JrYXJvdW5kIGZvciBBUEktRXh0cmFjdG9yXG59IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IHsgY3JlYXRlQWN0aW9uIH0gZnJvbSAnLi9ydGtJbXBvcnRzJztcbmV4cG9ydCBjb25zdCBvbkZvY3VzID0gLyogQF9fUFVSRV9fICovY3JlYXRlQWN0aW9uKCdfX3J0a3EvZm9jdXNlZCcpO1xuZXhwb3J0IGNvbnN0IG9uRm9jdXNMb3N0ID0gLyogQF9fUFVSRV9fICovY3JlYXRlQWN0aW9uKCdfX3J0a3EvdW5mb2N1c2VkJyk7XG5leHBvcnQgY29uc3Qgb25PbmxpbmUgPSAvKiBAX19QVVJFX18gKi9jcmVhdGVBY3Rpb24oJ19fcnRrcS9vbmxpbmUnKTtcbmV4cG9ydCBjb25zdCBvbk9mZmxpbmUgPSAvKiBAX19QVVJFX18gKi9jcmVhdGVBY3Rpb24oJ19fcnRrcS9vZmZsaW5lJyk7XG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBBIHV0aWxpdHkgdXNlZCB0byBlbmFibGUgYHJlZmV0Y2hPbk1vdW50YCBhbmQgYHJlZmV0Y2hPblJlY29ubmVjdGAgYmVoYXZpb3JzLlxuICogSXQgcmVxdWlyZXMgdGhlIGRpc3BhdGNoIG1ldGhvZCBmcm9tIHlvdXIgc3RvcmUuXG4gKiBDYWxsaW5nIGBzZXR1cExpc3RlbmVycyhzdG9yZS5kaXNwYXRjaClgIHdpbGwgY29uZmlndXJlIGxpc3RlbmVycyB3aXRoIHRoZSByZWNvbW1lbmRlZCBkZWZhdWx0cyxcbiAqIGJ1dCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHByb3ZpZGluZyBhIGNhbGxiYWNrIGZvciBtb3JlIGdyYW51bGFyIGNvbnRyb2wuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBzZXR1cExpc3RlbmVycyhzdG9yZS5kaXNwYXRjaClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBkaXNwYXRjaCAtIFRoZSBkaXNwYXRjaCBtZXRob2QgZnJvbSB5b3VyIHN0b3JlXG4gKiBAcGFyYW0gY3VzdG9tSGFuZGxlciAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZvciBtb3JlIGdyYW51bGFyIGNvbnRyb2wgb3ZlciBsaXN0ZW5lciBiZWhhdmlvclxuICogQHJldHVybnMgUmV0dXJuIHZhbHVlIG9mIHRoZSBoYW5kbGVyLlxuICogVGhlIGRlZmF1bHQgaGFuZGxlciByZXR1cm5zIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuIGJlIGNhbGxlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldHVwTGlzdGVuZXJzKGRpc3BhdGNoOiBUaHVua0Rpc3BhdGNoPGFueSwgYW55LCBhbnk+LCBjdXN0b21IYW5kbGVyPzogKGRpc3BhdGNoOiBUaHVua0Rpc3BhdGNoPGFueSwgYW55LCBhbnk+LCBhY3Rpb25zOiB7XG4gIG9uRm9jdXM6IHR5cGVvZiBvbkZvY3VzO1xuICBvbkZvY3VzTG9zdDogdHlwZW9mIG9uRm9jdXNMb3N0O1xuICBvbk9ubGluZTogdHlwZW9mIG9uT25saW5lO1xuICBvbk9mZmxpbmU6IHR5cGVvZiBvbk9mZmxpbmU7XG59KSA9PiAoKSA9PiB2b2lkKSB7XG4gIGZ1bmN0aW9uIGRlZmF1bHRIYW5kbGVyKCkge1xuICAgIGNvbnN0IGhhbmRsZUZvY3VzID0gKCkgPT4gZGlzcGF0Y2gob25Gb2N1cygpKTtcbiAgICBjb25zdCBoYW5kbGVGb2N1c0xvc3QgPSAoKSA9PiBkaXNwYXRjaChvbkZvY3VzTG9zdCgpKTtcbiAgICBjb25zdCBoYW5kbGVPbmxpbmUgPSAoKSA9PiBkaXNwYXRjaChvbk9ubGluZSgpKTtcbiAgICBjb25zdCBoYW5kbGVPZmZsaW5lID0gKCkgPT4gZGlzcGF0Y2gob25PZmZsaW5lKCkpO1xuICAgIGNvbnN0IGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAod2luZG93LmRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICAgIGhhbmRsZUZvY3VzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVGb2N1c0xvc3QoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAvLyBIYW5kbGUgZm9jdXMgZXZlbnRzXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSwgZmFsc2UpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBoYW5kbGVGb2N1cywgZmFsc2UpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBjb25uZWN0aW9uIGV2ZW50c1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgaGFuZGxlT25saW5lLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgaGFuZGxlT2ZmbGluZSwgZmFsc2UpO1xuICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgaGFuZGxlRm9jdXMpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvbmxpbmUnLCBoYW5kbGVPbmxpbmUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCBoYW5kbGVPZmZsaW5lKTtcbiAgICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH1cbiAgcmV0dXJuIGN1c3RvbUhhbmRsZXIgPyBjdXN0b21IYW5kbGVyKGRpc3BhdGNoLCB7XG4gICAgb25Gb2N1cyxcbiAgICBvbkZvY3VzTG9zdCxcbiAgICBvbk9mZmxpbmUsXG4gICAgb25PbmxpbmVcbiAgfSkgOiBkZWZhdWx0SGFuZGxlcigpO1xufSIsImltcG9ydCB0eXBlIHsgQXBpIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeSc7XG5pbXBvcnQgdHlwZSB7IFN0YW5kYXJkU2NoZW1hVjEgfSBmcm9tICdAc3RhbmRhcmQtc2NoZW1hL3NwZWMnO1xuaW1wb3J0IHR5cGUgeyBCYXNlUXVlcnlBcGksIEJhc2VRdWVyeUFyZywgQmFzZVF1ZXJ5RXJyb3IsIEJhc2VRdWVyeUV4dHJhT3B0aW9ucywgQmFzZVF1ZXJ5Rm4sIEJhc2VRdWVyeU1ldGEsIEJhc2VRdWVyeVJlc3VsdCwgUXVlcnlSZXR1cm5WYWx1ZSB9IGZyb20gJy4vYmFzZVF1ZXJ5VHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBDYWNoZUNvbGxlY3Rpb25RdWVyeUV4dHJhT3B0aW9ucyB9IGZyb20gJy4vY29yZS9idWlsZE1pZGRsZXdhcmUvY2FjaGVDb2xsZWN0aW9uJztcbmltcG9ydCB0eXBlIHsgQ2FjaGVMaWZlY3ljbGVJbmZpbml0ZVF1ZXJ5RXh0cmFPcHRpb25zLCBDYWNoZUxpZmVjeWNsZU11dGF0aW9uRXh0cmFPcHRpb25zLCBDYWNoZUxpZmVjeWNsZVF1ZXJ5RXh0cmFPcHRpb25zIH0gZnJvbSAnLi9jb3JlL2J1aWxkTWlkZGxld2FyZS9jYWNoZUxpZmVjeWNsZSc7XG5pbXBvcnQgdHlwZSB7IFF1ZXJ5TGlmZWN5Y2xlSW5maW5pdGVRdWVyeUV4dHJhT3B0aW9ucywgUXVlcnlMaWZlY3ljbGVNdXRhdGlvbkV4dHJhT3B0aW9ucywgUXVlcnlMaWZlY3ljbGVRdWVyeUV4dHJhT3B0aW9ucyB9IGZyb20gJy4vY29yZS9idWlsZE1pZGRsZXdhcmUvcXVlcnlMaWZlY3ljbGUnO1xuaW1wb3J0IHR5cGUgeyBJbmZpbml0ZURhdGEsIEluZmluaXRlUXVlcnlDb25maWdPcHRpb25zLCBRdWVyeVN1YlN0YXRlLCBSb290U3RhdGUgfSBmcm9tICcuL2NvcmUvaW5kZXgnO1xuaW1wb3J0IHR5cGUgeyBTZXJpYWxpemVRdWVyeUFyZ3MgfSBmcm9tICcuL2RlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MnO1xuaW1wb3J0IHR5cGUgeyBORVZFUiB9IGZyb20gJy4vZmFrZUJhc2VRdWVyeSc7XG5pbXBvcnQgdHlwZSB7IENhc3RBbnksIEhhc1JlcXVpcmVkUHJvcHMsIE1heWJlUHJvbWlzZSwgTm9uVW5kZWZpbmVkLCBPbWl0RnJvbVVuaW9uLCBVbndyYXBQcm9taXNlIH0gZnJvbSAnLi90c0hlbHBlcnMnO1xuaW1wb3J0IHsgaXNOb3ROdWxsaXNoIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IE5hbWVkU2NoZW1hRXJyb3IgfSBmcm9tICcuL3N0YW5kYXJkU2NoZW1hJztcbmNvbnN0IHJhd1Jlc3VsdFR5cGUgPSAvKiBAX19QVVJFX18gKi9TeW1ib2woKTtcbmNvbnN0IHJlc3VsdFR5cGUgPSAvKiBAX19QVVJFX18gKi9TeW1ib2woKTtcbmNvbnN0IGJhc2VRdWVyeSA9IC8qIEBfX1BVUkVfXyAqL1N5bWJvbCgpO1xuZXhwb3J0IGludGVyZmFjZSBTY2hlbWFGYWlsdXJlSW5mbyB7XG4gIGVuZHBvaW50OiBzdHJpbmc7XG4gIGFyZzogYW55O1xuICB0eXBlOiAncXVlcnknIHwgJ211dGF0aW9uJztcbiAgcXVlcnlDYWNoZUtleT86IHN0cmluZztcbn1cbmV4cG9ydCB0eXBlIFNjaGVtYUZhaWx1cmVIYW5kbGVyID0gKGVycm9yOiBOYW1lZFNjaGVtYUVycm9yLCBpbmZvOiBTY2hlbWFGYWlsdXJlSW5mbykgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIFNjaGVtYUZhaWx1cmVDb252ZXJ0ZXI8QmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4+ID0gKGVycm9yOiBOYW1lZFNjaGVtYUVycm9yLCBpbmZvOiBTY2hlbWFGYWlsdXJlSW5mbykgPT4gQmFzZVF1ZXJ5RXJyb3I8QmFzZVF1ZXJ5PjtcbmV4cG9ydCB0eXBlIEVuZHBvaW50RGVmaW5pdGlvbldpdGhRdWVyeTxRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFJlc3VsdFR5cGUsIFJhd1Jlc3VsdFR5cGUgZXh0ZW5kcyBCYXNlUXVlcnlSZXN1bHQ8QmFzZVF1ZXJ5Pj4gPSB7XG4gIC8qKlxuICAgKiBgcXVlcnlgIGNhbiBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBlaXRoZXIgYSBgc3RyaW5nYCBvciBhbiBgb2JqZWN0YCB3aGljaCBpcyBwYXNzZWQgdG8geW91ciBgYmFzZVF1ZXJ5YC4gSWYgeW91IGFyZSB1c2luZyBbZmV0Y2hCYXNlUXVlcnldKC4vZmV0Y2hCYXNlUXVlcnkpLCB0aGlzIGNhbiByZXR1cm4gZWl0aGVyIGEgYHN0cmluZ2Agb3IgYW4gYG9iamVjdGAgb2YgcHJvcGVydGllcyBpbiBgRmV0Y2hBcmdzYC4gSWYgeW91IHVzZSB5b3VyIG93biBjdXN0b20gW2BiYXNlUXVlcnlgXSguLi8uLi9ydGstcXVlcnkvdXNhZ2UvY3VzdG9taXppbmctcXVlcmllcyksIHlvdSBjYW4gY3VzdG9taXplIHRoaXMgYmVoYXZpb3IgdG8geW91ciBsaWtpbmcuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIHRpdGxlPVwicXVlcnkgZXhhbXBsZVwiXG4gICAqXG4gICAqIGltcG9ydCB7IGNyZWF0ZUFwaSwgZmV0Y2hCYXNlUXVlcnkgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5L3JlYWN0J1xuICAgKiBpbnRlcmZhY2UgUG9zdCB7XG4gICAqICAgaWQ6IG51bWJlclxuICAgKiAgIG5hbWU6IHN0cmluZ1xuICAgKiB9XG4gICAqIHR5cGUgUG9zdHNSZXNwb25zZSA9IFBvc3RbXVxuICAgKlxuICAgKiBjb25zdCBhcGkgPSBjcmVhdGVBcGkoe1xuICAgKiAgIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnLycgfSksXG4gICAqICAgdGFnVHlwZXM6IFsnUG9zdCddLFxuICAgKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAgZ2V0UG9zdHM6IGJ1aWxkLnF1ZXJ5PFBvc3RzUmVzcG9uc2UsIHZvaWQ+KHtcbiAgICogICAgICAgLy8gaGlnaGxpZ2h0LXN0YXJ0XG4gICAqICAgICAgIHF1ZXJ5OiAoKSA9PiAncG9zdHMnLFxuICAgKiAgICAgICAvLyBoaWdobGlnaHQtZW5kXG4gICAqICAgICB9KSxcbiAgICogICAgIGFkZFBvc3Q6IGJ1aWxkLm11dGF0aW9uPFBvc3QsIFBhcnRpYWw8UG9zdD4+KHtcbiAgICogICAgICAvLyBoaWdobGlnaHQtc3RhcnRcbiAgICogICAgICBxdWVyeTogKGJvZHkpID0+ICh7XG4gICAqICAgICAgICB1cmw6IGBwb3N0c2AsXG4gICAqICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICogICAgICAgIGJvZHksXG4gICAqICAgICAgfSksXG4gICAqICAgICAgLy8gaGlnaGxpZ2h0LWVuZFxuICAgKiAgICAgIGludmFsaWRhdGVzVGFnczogW3sgdHlwZTogJ1Bvc3QnLCBpZDogJ0xJU1QnIH1dLFxuICAgKiAgICB9KSxcbiAgICogICB9KVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHF1ZXJ5KGFyZzogUXVlcnlBcmcpOiBCYXNlUXVlcnlBcmc8QmFzZVF1ZXJ5PjtcbiAgcXVlcnlGbj86IG5ldmVyO1xuICAvKipcbiAgICogQSBmdW5jdGlvbiB0byBtYW5pcHVsYXRlIHRoZSBkYXRhIHJldHVybmVkIGJ5IGEgcXVlcnkgb3IgbXV0YXRpb24uXG4gICAqL1xuICB0cmFuc2Zvcm1SZXNwb25zZT8oYmFzZVF1ZXJ5UmV0dXJuVmFsdWU6IFJhd1Jlc3VsdFR5cGUsIG1ldGE6IEJhc2VRdWVyeU1ldGE8QmFzZVF1ZXJ5PiwgYXJnOiBRdWVyeUFyZyk6IFJlc3VsdFR5cGUgfCBQcm9taXNlPFJlc3VsdFR5cGU+O1xuICAvKipcbiAgICogQSBmdW5jdGlvbiB0byBtYW5pcHVsYXRlIHRoZSBkYXRhIHJldHVybmVkIGJ5IGEgZmFpbGVkIHF1ZXJ5IG9yIG11dGF0aW9uLlxuICAgKi9cbiAgdHJhbnNmb3JtRXJyb3JSZXNwb25zZT8oYmFzZVF1ZXJ5UmV0dXJuVmFsdWU6IEJhc2VRdWVyeUVycm9yPEJhc2VRdWVyeT4sIG1ldGE6IEJhc2VRdWVyeU1ldGE8QmFzZVF1ZXJ5PiwgYXJnOiBRdWVyeUFyZyk6IHVua25vd247XG5cbiAgLyoqXG4gICAqIEEgc2NoZW1hIGZvciB0aGUgcmVzdWx0ICpiZWZvcmUqIGl0J3MgcGFzc2VkIHRvIGB0cmFuc2Zvcm1SZXNwb25zZWAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIG5vLXRyYW5zcGlsZVxuICAgKiBpbXBvcnQgeyBjcmVhdGVBcGksIGZldGNoQmFzZVF1ZXJ5IH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeS9yZWFjdCdcbiAgICogaW1wb3J0ICogYXMgdiBmcm9tIFwidmFsaWJvdFwiXG4gICAqXG4gICAqIGNvbnN0IHBvc3RTY2hlbWEgPSB2Lm9iamVjdCh7IGlkOiB2Lm51bWJlcigpLCBuYW1lOiB2LnN0cmluZygpIH0pXG4gICAqIHR5cGUgUG9zdCA9IHYuSW5mZXJPdXRwdXQ8dHlwZW9mIHBvc3RTY2hlbWE+XG4gICAqXG4gICAqIGNvbnN0IGFwaSA9IGNyZWF0ZUFwaSh7XG4gICAqICAgYmFzZVF1ZXJ5OiBmZXRjaEJhc2VRdWVyeSh7IGJhc2VVcmw6ICcvJyB9KSxcbiAgICogICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAgICogICAgIGdldFBvc3ROYW1lOiBidWlsZC5xdWVyeTxQb3N0LCB7IGlkOiBudW1iZXIgfT4oe1xuICAgKiAgICAgICBxdWVyeTogKHsgaWQgfSkgPT4gYC9wb3N0LyR7aWR9YCxcbiAgICogICAgICAgcmF3UmVzcG9uc2VTY2hlbWE6IHBvc3RTY2hlbWEsXG4gICAqICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlOiAocG9zdCkgPT4gcG9zdC5uYW1lLFxuICAgKiAgICAgfSksXG4gICAqICAgfSlcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICByYXdSZXNwb25zZVNjaGVtYT86IFN0YW5kYXJkU2NoZW1hVjE8UmF3UmVzdWx0VHlwZT47XG5cbiAgLyoqXG4gICAqIEEgc2NoZW1hIGZvciB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGJ5IHRoZSBgcXVlcnlgIG9yIGBxdWVyeUZuYCwgKmJlZm9yZSogaXQncyBwYXNzZWQgdG8gYHRyYW5zZm9ybUVycm9yUmVzcG9uc2VgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBjb2RlYmxvY2stbWV0YSBuby10cmFuc3BpbGVcbiAgICogaW1wb3J0IHsgY3JlYXRlQXBpLCBmZXRjaEJhc2VRdWVyeSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnXG4gICAqIGltcG9ydCAqIGFzIHYgZnJvbSBcInZhbGlib3RcIlxuICAgKiBpbXBvcnQge2N1c3RvbUJhc2VRdWVyeSwgYmFzZVF1ZXJ5RXJyb3JTY2hlbWF9IGZyb20gXCIuL2N1c3RvbUJhc2VRdWVyeVwiXG4gICAqXG4gICAqIGNvbnN0IGFwaSA9IGNyZWF0ZUFwaSh7XG4gICAqICAgYmFzZVF1ZXJ5OiBjdXN0b21CYXNlUXVlcnksXG4gICAqICAgZW5kcG9pbnRzOiAoYnVpbGQpID0+ICh7XG4gICAqICAgICBnZXRQb3N0OiBidWlsZC5xdWVyeTxQb3N0LCB7IGlkOiBudW1iZXIgfT4oe1xuICAgKiAgICAgICBxdWVyeTogKHsgaWQgfSkgPT4gYC9wb3N0LyR7aWR9YCxcbiAgICogICAgICAgcmF3RXJyb3JSZXNwb25zZVNjaGVtYTogYmFzZVF1ZXJ5RXJyb3JTY2hlbWEsXG4gICAqICAgICAgIHRyYW5zZm9ybUVycm9yUmVzcG9uc2U6IChlcnJvcikgPT4gZXJyb3IuZGF0YSxcbiAgICogICAgIH0pLFxuICAgKiAgIH0pXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgcmF3RXJyb3JSZXNwb25zZVNjaGVtYT86IFN0YW5kYXJkU2NoZW1hVjE8QmFzZVF1ZXJ5RXJyb3I8QmFzZVF1ZXJ5Pj47XG59O1xuZXhwb3J0IHR5cGUgRW5kcG9pbnREZWZpbml0aW9uV2l0aFF1ZXJ5Rm48UXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBSZXN1bHRUeXBlPiA9IHtcbiAgLyoqXG4gICAqIENhbiBiZSB1c2VkIGluIHBsYWNlIG9mIGBxdWVyeWAgYXMgYW4gaW5saW5lIGZ1bmN0aW9uIHRoYXQgYnlwYXNzZXMgYGJhc2VRdWVyeWAgY29tcGxldGVseSBmb3IgdGhlIGVuZHBvaW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBjb2RlYmxvY2stbWV0YSB0aXRsZT1cIkJhc2ljIHF1ZXJ5Rm4gZXhhbXBsZVwiXG4gICAqXG4gICAqIGltcG9ydCB7IGNyZWF0ZUFwaSwgZmV0Y2hCYXNlUXVlcnkgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5L3JlYWN0J1xuICAgKiBpbnRlcmZhY2UgUG9zdCB7XG4gICAqICAgaWQ6IG51bWJlclxuICAgKiAgIG5hbWU6IHN0cmluZ1xuICAgKiB9XG4gICAqIHR5cGUgUG9zdHNSZXNwb25zZSA9IFBvc3RbXVxuICAgKlxuICAgKiBjb25zdCBhcGkgPSBjcmVhdGVBcGkoe1xuICAgKiAgIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnLycgfSksXG4gICAqICAgZW5kcG9pbnRzOiAoYnVpbGQpID0+ICh7XG4gICAqICAgICBnZXRQb3N0czogYnVpbGQucXVlcnk8UG9zdHNSZXNwb25zZSwgdm9pZD4oe1xuICAgKiAgICAgICBxdWVyeTogKCkgPT4gJ3Bvc3RzJyxcbiAgICogICAgIH0pLFxuICAgKiAgICAgZmxpcENvaW46IGJ1aWxkLnF1ZXJ5PCdoZWFkcycgfCAndGFpbHMnLCB2b2lkPih7XG4gICAqICAgICAgIC8vIGhpZ2hsaWdodC1zdGFydFxuICAgKiAgICAgICBxdWVyeUZuKGFyZywgcXVlcnlBcGksIGV4dHJhT3B0aW9ucywgYmFzZVF1ZXJ5KSB7XG4gICAqICAgICAgICAgY29uc3QgcmFuZG9tVmFsID0gTWF0aC5yYW5kb20oKVxuICAgKiAgICAgICAgIGlmIChyYW5kb21WYWwgPCAwLjQ1KSB7XG4gICAqICAgICAgICAgICByZXR1cm4geyBkYXRhOiAnaGVhZHMnIH1cbiAgICogICAgICAgICB9XG4gICAqICAgICAgICAgaWYgKHJhbmRvbVZhbCA8IDAuOSkge1xuICAgKiAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogJ3RhaWxzJyB9XG4gICAqICAgICAgICAgfVxuICAgKiAgICAgICAgIHJldHVybiB7IGVycm9yOiB7IHN0YXR1czogNTAwLCBzdGF0dXNUZXh0OiAnSW50ZXJuYWwgU2VydmVyIEVycm9yJywgZGF0YTogXCJDb2luIGxhbmRlZCBvbiBpdHMgZWRnZSFcIiB9IH1cbiAgICogICAgICAgfVxuICAgKiAgICAgICAvLyBoaWdobGlnaHQtZW5kXG4gICAqICAgICB9KVxuICAgKiAgIH0pXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgcXVlcnlGbihhcmc6IFF1ZXJ5QXJnLCBhcGk6IEJhc2VRdWVyeUFwaSwgZXh0cmFPcHRpb25zOiBCYXNlUXVlcnlFeHRyYU9wdGlvbnM8QmFzZVF1ZXJ5PiwgYmFzZVF1ZXJ5OiAoYXJnOiBQYXJhbWV0ZXJzPEJhc2VRdWVyeT5bMF0pID0+IFJldHVyblR5cGU8QmFzZVF1ZXJ5Pik6IE1heWJlUHJvbWlzZTxRdWVyeVJldHVyblZhbHVlPFJlc3VsdFR5cGUsIEJhc2VRdWVyeUVycm9yPEJhc2VRdWVyeT4sIEJhc2VRdWVyeU1ldGE8QmFzZVF1ZXJ5Pj4+O1xuICBxdWVyeT86IG5ldmVyO1xuICB0cmFuc2Zvcm1SZXNwb25zZT86IG5ldmVyO1xuICB0cmFuc2Zvcm1FcnJvclJlc3BvbnNlPzogbmV2ZXI7XG4gIHJhd1Jlc3BvbnNlU2NoZW1hPzogbmV2ZXI7XG4gIHJhd0Vycm9yUmVzcG9uc2VTY2hlbWE/OiBuZXZlcjtcbn07XG50eXBlIEJhc2VFbmRwb2ludFR5cGVzPFF1ZXJ5QXJnLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgUmVzdWx0VHlwZT4gPSB7XG4gIFF1ZXJ5QXJnOiBRdWVyeUFyZztcbiAgQmFzZVF1ZXJ5OiBCYXNlUXVlcnk7XG4gIFJlc3VsdFR5cGU6IFJlc3VsdFR5cGU7XG59O1xuaW50ZXJmYWNlIENvbW1vbkVuZHBvaW50RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFJlc3VsdFR5cGU+IHtcbiAgLyoqXG4gICAqIEEgc2NoZW1hIGZvciB0aGUgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byB0aGUgYHF1ZXJ5YCBvciBgcXVlcnlGbmAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIG5vLXRyYW5zcGlsZVxuICAgKiBpbXBvcnQgeyBjcmVhdGVBcGksIGZldGNoQmFzZVF1ZXJ5IH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeS9yZWFjdCdcbiAgICogaW1wb3J0ICogYXMgdiBmcm9tIFwidmFsaWJvdFwiXG4gICAqXG4gICAqIGNvbnN0IGFwaSA9IGNyZWF0ZUFwaSh7XG4gICAqICAgYmFzZVF1ZXJ5OiBmZXRjaEJhc2VRdWVyeSh7IGJhc2VVcmw6ICcvJyB9KSxcbiAgICogICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAgICogICAgIGdldFBvc3Q6IGJ1aWxkLnF1ZXJ5PFBvc3QsIHsgaWQ6IG51bWJlciB9Pih7XG4gICAqICAgICAgIHF1ZXJ5OiAoeyBpZCB9KSA9PiBgL3Bvc3QvJHtpZH1gLFxuICAgKiAgICAgICBhcmdTY2hlbWE6IHYub2JqZWN0KHsgaWQ6IHYubnVtYmVyKCkgfSksXG4gICAqICAgICB9KSxcbiAgICogICB9KVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIGFyZ1NjaGVtYT86IFN0YW5kYXJkU2NoZW1hVjE8UXVlcnlBcmc+O1xuXG4gIC8qKlxuICAgKiBBIHNjaGVtYSBmb3IgdGhlIHJlc3VsdCAoaW5jbHVkaW5nIGB0cmFuc2Zvcm1SZXNwb25zZWAgaWYgcHJvdmlkZWQpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBjb2RlYmxvY2stbWV0YSBuby10cmFuc3BpbGVcbiAgICogaW1wb3J0IHsgY3JlYXRlQXBpLCBmZXRjaEJhc2VRdWVyeSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnXG4gICAqIGltcG9ydCAqIGFzIHYgZnJvbSBcInZhbGlib3RcIlxuICAgKlxuICAgKiBjb25zdCBwb3N0U2NoZW1hID0gdi5vYmplY3QoeyBpZDogdi5udW1iZXIoKSwgbmFtZTogdi5zdHJpbmcoKSB9KVxuICAgKiB0eXBlIFBvc3QgPSB2LkluZmVyT3V0cHV0PHR5cGVvZiBwb3N0U2NoZW1hPlxuICAgKlxuICAgKiBjb25zdCBhcGkgPSBjcmVhdGVBcGkoe1xuICAgKiAgIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnLycgfSksXG4gICAqICAgZW5kcG9pbnRzOiAoYnVpbGQpID0+ICh7XG4gICAqICAgICBnZXRQb3N0OiBidWlsZC5xdWVyeTxQb3N0LCB7IGlkOiBudW1iZXIgfT4oe1xuICAgKiAgICAgICBxdWVyeTogKHsgaWQgfSkgPT4gYC9wb3N0LyR7aWR9YCxcbiAgICogICAgICAgcmVzcG9uc2VTY2hlbWE6IHBvc3RTY2hlbWEsXG4gICAqICAgICB9KSxcbiAgICogICB9KVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHJlc3BvbnNlU2NoZW1hPzogU3RhbmRhcmRTY2hlbWFWMTxSZXN1bHRUeXBlPjtcblxuICAvKipcbiAgICogQSBzY2hlbWEgZm9yIHRoZSBlcnJvciBvYmplY3QgcmV0dXJuZWQgYnkgdGhlIGBxdWVyeWAgb3IgYHF1ZXJ5Rm5gIChpbmNsdWRpbmcgYHRyYW5zZm9ybUVycm9yUmVzcG9uc2VgIGlmIHByb3ZpZGVkKS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgbm8tdHJhbnNwaWxlXG4gICAqIGltcG9ydCB7IGNyZWF0ZUFwaSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnXG4gICAqIGltcG9ydCAqIGFzIHYgZnJvbSBcInZhbGlib3RcIlxuICAgKiBpbXBvcnQgeyBjdXN0b21CYXNlUXVlcnksIGJhc2VRdWVyeUVycm9yU2NoZW1hIH0gZnJvbSBcIi4vY3VzdG9tQmFzZVF1ZXJ5XCJcbiAgICpcbiAgICogY29uc3QgYXBpID0gY3JlYXRlQXBpKHtcbiAgICogICBiYXNlUXVlcnk6IGN1c3RvbUJhc2VRdWVyeSxcbiAgICogICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAgICogICAgIGdldFBvc3Q6IGJ1aWxkLnF1ZXJ5PFBvc3QsIHsgaWQ6IG51bWJlciB9Pih7XG4gICAqICAgICAgIHF1ZXJ5OiAoeyBpZCB9KSA9PiBgL3Bvc3QvJHtpZH1gLFxuICAgKiAgICAgICBlcnJvclJlc3BvbnNlU2NoZW1hOiBiYXNlUXVlcnlFcnJvclNjaGVtYSxcbiAgICogICAgIH0pLFxuICAgKiAgIH0pXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgZXJyb3JSZXNwb25zZVNjaGVtYT86IFN0YW5kYXJkU2NoZW1hVjE8QmFzZVF1ZXJ5RXJyb3I8QmFzZVF1ZXJ5Pj47XG5cbiAgLyoqXG4gICAqIEEgc2NoZW1hIGZvciB0aGUgYG1ldGFgIHByb3BlcnR5IHJldHVybmVkIGJ5IHRoZSBgcXVlcnlgIG9yIGBxdWVyeUZuYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgbm8tdHJhbnNwaWxlXG4gICAqIGltcG9ydCB7IGNyZWF0ZUFwaSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnXG4gICAqIGltcG9ydCAqIGFzIHYgZnJvbSBcInZhbGlib3RcIlxuICAgKiBpbXBvcnQgeyBjdXN0b21CYXNlUXVlcnksIGJhc2VRdWVyeU1ldGFTY2hlbWEgfSBmcm9tIFwiLi9jdXN0b21CYXNlUXVlcnlcIlxuICAgKlxuICAgKiBjb25zdCBhcGkgPSBjcmVhdGVBcGkoe1xuICAgKiAgIGJhc2VRdWVyeTogY3VzdG9tQmFzZVF1ZXJ5LFxuICAgKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAgZ2V0UG9zdDogYnVpbGQucXVlcnk8UG9zdCwgeyBpZDogbnVtYmVyIH0+KHtcbiAgICogICAgICAgcXVlcnk6ICh7IGlkIH0pID0+IGAvcG9zdC8ke2lkfWAsXG4gICAqICAgICAgIG1ldGFTY2hlbWE6IGJhc2VRdWVyeU1ldGFTY2hlbWEsXG4gICAqICAgICB9KSxcbiAgICogICB9KVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIG1ldGFTY2hlbWE/OiBTdGFuZGFyZFNjaGVtYVYxPEJhc2VRdWVyeU1ldGE8QmFzZVF1ZXJ5Pj47XG5cbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICpcbiAgICogTW9zdCBhcHBzIHNob3VsZCBsZWF2ZSB0aGlzIHNldHRpbmcgb24uIFRoZSBvbmx5IHRpbWUgaXQgY2FuIGJlIGEgcGVyZm9ybWFuY2UgaXNzdWVcbiAgICogaXMgaWYgYW4gQVBJIHJldHVybnMgZXh0cmVtZWx5IGxhcmdlIGFtb3VudHMgb2YgZGF0YSAoZS5nLiAxMCwwMDAgcm93cyBwZXIgcmVxdWVzdCkgYW5kXG4gICAqIHlvdSdyZSB1bmFibGUgdG8gcGFnaW5hdGUgaXQuXG4gICAqXG4gICAqIEZvciBkZXRhaWxzIG9mIGhvdyB0aGlzIHdvcmtzLCBwbGVhc2Ugc2VlIHRoZSBiZWxvdy4gV2hlbiBpdCBpcyBzZXQgdG8gYGZhbHNlYCxcbiAgICogZXZlcnkgcmVxdWVzdCB3aWxsIGNhdXNlIHN1YnNjcmliZWQgY29tcG9uZW50cyB0byByZXJlbmRlciwgZXZlbiB3aGVuIHRoZSBkYXRhIGhhcyBub3QgY2hhbmdlZC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9vdGhlci1leHBvcnRzI2NvcHl3aXRoc3RydWN0dXJhbHNoYXJpbmdcbiAgICovXG4gIHN0cnVjdHVyYWxTaGFyaW5nPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIGEgc2NoZW1hIHZhbGlkYXRpb24gZmFpbHMuXG4gICAqXG4gICAqIEdldHMgY2FsbGVkIHdpdGggYSBgTmFtZWRTY2hlbWFFcnJvcmAgYW5kIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBlbmRwb2ludCBuYW1lLCB0aGUgdHlwZSBvZiB0aGUgZW5kcG9pbnQsIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gdGhlIGVuZHBvaW50LCBhbmQgdGhlIHF1ZXJ5IGNhY2hlIGtleSAoaWYgYXBwbGljYWJsZSkuXG4gICAqXG4gICAqIGBOYW1lZFNjaGVtYUVycm9yYCBoYXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAtIGBpc3N1ZXNgOiBhbiBhcnJheSBvZiBpc3N1ZXMgdGhhdCBjYXVzZWQgdGhlIHZhbGlkYXRpb24gdG8gZmFpbFxuICAgKiAtIGB2YWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIHNjaGVtYVxuICAgKiAtIGBzY2hlbWFOYW1lYDogdGhlIG5hbWUgb2YgdGhlIHNjaGVtYSB0aGF0IHdhcyB1c2VkIHRvIHZhbGlkYXRlIHRoZSB2YWx1ZSAoZS5nLiBgYXJnU2NoZW1hYClcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgbm8tdHJhbnNwaWxlXG4gICAqIGltcG9ydCB7IGNyZWF0ZUFwaSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnXG4gICAqIGltcG9ydCAqIGFzIHYgZnJvbSBcInZhbGlib3RcIlxuICAgKlxuICAgKiBjb25zdCBhcGkgPSBjcmVhdGVBcGkoe1xuICAgKiAgIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnLycgfSksXG4gICAqICAgZW5kcG9pbnRzOiAoYnVpbGQpID0+ICh7XG4gICAqICAgICBnZXRQb3N0OiBidWlsZC5xdWVyeTxQb3N0LCB7IGlkOiBudW1iZXIgfT4oe1xuICAgKiAgICAgICBxdWVyeTogKHsgaWQgfSkgPT4gYC9wb3N0LyR7aWR9YCxcbiAgICogICAgICAgb25TY2hlbWFGYWlsdXJlOiAoZXJyb3IsIGluZm8pID0+IHtcbiAgICogICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLCBpbmZvKVxuICAgKiAgICAgICB9LFxuICAgKiAgICAgfSksXG4gICAqICAgfSlcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBvblNjaGVtYUZhaWx1cmU/OiBTY2hlbWFGYWlsdXJlSGFuZGxlcjtcblxuICAvKipcbiAgICogQ29udmVydCBhIHNjaGVtYSB2YWxpZGF0aW9uIGZhaWx1cmUgaW50byBhbiBlcnJvciBzaGFwZSBtYXRjaGluZyBiYXNlIHF1ZXJ5IGVycm9ycy5cbiAgICpcbiAgICogV2hlbiBub3QgcHJvdmlkZWQsIHNjaGVtYSBmYWlsdXJlcyBhcmUgdHJlYXRlZCBhcyBmYXRhbCwgYW5kIG5vcm1hbCBlcnJvciBoYW5kbGluZyBzdWNoIGFzIHRhZyBpbnZhbGlkYXRpb24gd2lsbCBub3QgYmUgZXhlY3V0ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIG5vLXRyYW5zcGlsZVxuICAgKiBpbXBvcnQgeyBjcmVhdGVBcGkgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5L3JlYWN0J1xuICAgKiBpbXBvcnQgKiBhcyB2IGZyb20gXCJ2YWxpYm90XCJcbiAgICpcbiAgICogY29uc3QgYXBpID0gY3JlYXRlQXBpKHtcbiAgICogICBiYXNlUXVlcnk6IGZldGNoQmFzZVF1ZXJ5KHsgYmFzZVVybDogJy8nIH0pLFxuICAgKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAgZ2V0UG9zdDogYnVpbGQucXVlcnk8UG9zdCwgeyBpZDogbnVtYmVyIH0+KHtcbiAgICogICAgICAgcXVlcnk6ICh7IGlkIH0pID0+IGAvcG9zdC8ke2lkfWAsXG4gICAqICAgICAgIHJlc3BvbnNlU2NoZW1hOiB2Lm9iamVjdCh7IGlkOiB2Lm51bWJlcigpLCBuYW1lOiB2LnN0cmluZygpIH0pLFxuICAgKiAgICAgICBjYXRjaFNjaGVtYUZhaWx1cmU6IChlcnJvciwgaW5mbykgPT4gKHtcbiAgICogICAgICAgICBzdGF0dXM6IFwiQ1VTVE9NX0VSUk9SXCIsXG4gICAqICAgICAgICAgZXJyb3I6IGVycm9yLnNjaGVtYU5hbWUgKyBcIiBmYWlsZWQgdmFsaWRhdGlvblwiLFxuICAgKiAgICAgICAgIGRhdGE6IGVycm9yLmlzc3VlcyxcbiAgICogICAgICAgfSksXG4gICAqICAgICB9KSxcbiAgICogICB9KSxcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBjYXRjaFNjaGVtYUZhaWx1cmU/OiBTY2hlbWFGYWlsdXJlQ29udmVydGVyPEJhc2VRdWVyeT47XG5cbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqXG4gICAqIElmIHNldCB0byBgdHJ1ZWAsIHdpbGwgc2tpcCBzY2hlbWEgdmFsaWRhdGlvbiBmb3IgdGhpcyBlbmRwb2ludC5cbiAgICogT3ZlcnJpZGVzIHRoZSBnbG9iYWwgc2V0dGluZy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgbm8tdHJhbnNwaWxlXG4gICAqIGltcG9ydCB7IGNyZWF0ZUFwaSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnXG4gICAqIGltcG9ydCAqIGFzIHYgZnJvbSBcInZhbGlib3RcIlxuICAgKlxuICAgKiBjb25zdCBhcGkgPSBjcmVhdGVBcGkoe1xuICAgKiAgIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnLycgfSksXG4gICAqICAgZW5kcG9pbnRzOiAoYnVpbGQpID0+ICh7XG4gICAqICAgICBnZXRQb3N0OiBidWlsZC5xdWVyeTxQb3N0LCB7IGlkOiBudW1iZXIgfT4oe1xuICAgKiAgICAgICBxdWVyeTogKHsgaWQgfSkgPT4gYC9wb3N0LyR7aWR9YCxcbiAgICogICAgICAgcmVzcG9uc2VTY2hlbWE6IHYub2JqZWN0KHsgaWQ6IHYubnVtYmVyKCksIG5hbWU6IHYuc3RyaW5nKCkgfSksXG4gICAqICAgICAgIHNraXBTY2hlbWFWYWxpZGF0aW9uOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIsIC8vIHNraXAgc2NoZW1hIHZhbGlkYXRpb24gaW4gdGVzdHMsIHNpbmNlIHdlJ2xsIGJlIG1vY2tpbmcgdGhlIHJlc3BvbnNlXG4gICAqICAgICB9KSxcbiAgICogICB9KVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHNraXBTY2hlbWFWYWxpZGF0aW9uPzogYm9vbGVhbjtcbn1cbmV4cG9ydCB0eXBlIEJhc2VFbmRwb2ludERlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBSZXN1bHRUeXBlLCBSYXdSZXN1bHRUeXBlIGV4dGVuZHMgQmFzZVF1ZXJ5UmVzdWx0PEJhc2VRdWVyeT4gPSBCYXNlUXVlcnlSZXN1bHQ8QmFzZVF1ZXJ5Pj4gPSAoKFtDYXN0QW55PEJhc2VRdWVyeVJlc3VsdDxCYXNlUXVlcnk+LCB7fT5dIGV4dGVuZHMgW05FVkVSXSA/IG5ldmVyIDogRW5kcG9pbnREZWZpbml0aW9uV2l0aFF1ZXJ5PFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFJlc3VsdFR5cGUsIFJhd1Jlc3VsdFR5cGU+KSB8IEVuZHBvaW50RGVmaW5pdGlvbldpdGhRdWVyeUZuPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFJlc3VsdFR5cGU+KSAmIENvbW1vbkVuZHBvaW50RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZXN1bHRUeXBlPiAmIHtcbiAgLyogcGhhbnRvbSB0eXBlICovXG4gIFtyYXdSZXN1bHRUeXBlXT86IFJhd1Jlc3VsdFR5cGU7XG4gIC8qIHBoYW50b20gdHlwZSAqL1xuICBbcmVzdWx0VHlwZV0/OiBSZXN1bHRUeXBlO1xuICAvKiBwaGFudG9tIHR5cGUgKi9cbiAgW2Jhc2VRdWVyeV0/OiBCYXNlUXVlcnk7XG59ICYgSGFzUmVxdWlyZWRQcm9wczxCYXNlUXVlcnlFeHRyYU9wdGlvbnM8QmFzZVF1ZXJ5Piwge1xuICBleHRyYU9wdGlvbnM6IEJhc2VRdWVyeUV4dHJhT3B0aW9uczxCYXNlUXVlcnk+O1xufSwge1xuICBleHRyYU9wdGlvbnM/OiBCYXNlUXVlcnlFeHRyYU9wdGlvbnM8QmFzZVF1ZXJ5Pjtcbn0+O1xuZXhwb3J0IGVudW0gRGVmaW5pdGlvblR5cGUge1xuICBxdWVyeSA9ICdxdWVyeScsXG4gIG11dGF0aW9uID0gJ211dGF0aW9uJyxcbiAgaW5maW5pdGVxdWVyeSA9ICdpbmZpbml0ZXF1ZXJ5Jyxcbn1cbnR5cGUgVGFnRGVzY3JpcHRpb25BcnJheTxUYWdUeXBlcyBleHRlbmRzIHN0cmluZz4gPSBSZWFkb25seUFycmF5PFRhZ0Rlc2NyaXB0aW9uPFRhZ1R5cGVzPiB8IHVuZGVmaW5lZCB8IG51bGw+O1xuZXhwb3J0IHR5cGUgR2V0UmVzdWx0RGVzY3JpcHRpb25GbjxUYWdUeXBlcyBleHRlbmRzIHN0cmluZywgUmVzdWx0VHlwZSwgUXVlcnlBcmcsIEVycm9yVHlwZSwgTWV0YVR5cGU+ID0gKHJlc3VsdDogUmVzdWx0VHlwZSB8IHVuZGVmaW5lZCwgZXJyb3I6IEVycm9yVHlwZSB8IHVuZGVmaW5lZCwgYXJnOiBRdWVyeUFyZywgbWV0YTogTWV0YVR5cGUpID0+IFRhZ0Rlc2NyaXB0aW9uQXJyYXk8VGFnVHlwZXM+O1xuZXhwb3J0IHR5cGUgRnVsbFRhZ0Rlc2NyaXB0aW9uPFRhZ1R5cGU+ID0ge1xuICB0eXBlOiBUYWdUeXBlO1xuICBpZD86IG51bWJlciB8IHN0cmluZztcbn07XG5leHBvcnQgdHlwZSBUYWdEZXNjcmlwdGlvbjxUYWdUeXBlPiA9IFRhZ1R5cGUgfCBGdWxsVGFnRGVzY3JpcHRpb248VGFnVHlwZT47XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBSZXN1bHREZXNjcmlwdGlvbjxUYWdUeXBlcyBleHRlbmRzIHN0cmluZywgUmVzdWx0VHlwZSwgUXVlcnlBcmcsIEVycm9yVHlwZSwgTWV0YVR5cGU+ID0gVGFnRGVzY3JpcHRpb25BcnJheTxUYWdUeXBlcz4gfCBHZXRSZXN1bHREZXNjcmlwdGlvbkZuPFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBRdWVyeUFyZywgRXJyb3JUeXBlLCBNZXRhVHlwZT47XG50eXBlIFF1ZXJ5VHlwZXM8UXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBUYWdUeXBlcyBleHRlbmRzIHN0cmluZywgUmVzdWx0VHlwZSwgUmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+ID0gQmFzZUVuZHBvaW50VHlwZXM8UXVlcnlBcmcsIEJhc2VRdWVyeSwgUmVzdWx0VHlwZT4gJiB7XG4gIC8qKlxuICAgKiBUaGUgZW5kcG9pbnQgZGVmaW5pdGlvbiB0eXBlLiBUbyBiZSB1c2VkIHdpdGggc29tZSBpbnRlcm5hbCBnZW5lcmljIHR5cGVzLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCB1c2VNeVdyYXBwZWRIb29rOiBVc2VRdWVyeTx0eXBlb2YgYXBpLmVuZHBvaW50cy5xdWVyeS5UeXBlcy5RdWVyeURlZmluaXRpb24+ID0gLi4uXG4gICAqIGBgYFxuICAgKi9cbiAgUXVlcnlEZWZpbml0aW9uOiBRdWVyeURlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSwgVGFnVHlwZXMsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoPjtcbiAgVGFnVHlwZXM6IFRhZ1R5cGVzO1xuICBSZWR1Y2VyUGF0aDogUmVkdWNlclBhdGg7XG59O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBRdWVyeUV4dHJhT3B0aW9uczxUYWdUeXBlcyBleHRlbmRzIHN0cmluZywgUmVzdWx0VHlwZSwgUXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gZXh0ZW5kcyBDYWNoZUxpZmVjeWNsZVF1ZXJ5RXh0cmFPcHRpb25zPFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFJlZHVjZXJQYXRoPiwgUXVlcnlMaWZlY3ljbGVRdWVyeUV4dHJhT3B0aW9uczxSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZWR1Y2VyUGF0aD4sIENhY2hlQ29sbGVjdGlvblF1ZXJ5RXh0cmFPcHRpb25zIHtcbiAgdHlwZTogRGVmaW5pdGlvblR5cGUucXVlcnk7XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYHF1ZXJ5YCBlbmRwb2ludHMuIERldGVybWluZXMgd2hpY2ggJ3RhZycgaXMgYXR0YWNoZWQgdG8gdGhlIGNhY2hlZCBkYXRhIHJldHVybmVkIGJ5IHRoZSBxdWVyeS5cbiAgICogRXhwZWN0cyBhbiBhcnJheSBvZiB0YWcgdHlwZSBzdHJpbmdzLCBhbiBhcnJheSBvZiBvYmplY3RzIG9mIHRhZyB0eXBlcyB3aXRoIGlkcywgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgc3VjaCBhbiBhcnJheS5cbiAgICogMS4gIGBbJ1Bvc3QnXWAgLSBlcXVpdmFsZW50IHRvIGAyYFxuICAgKiAyLiAgYFt7IHR5cGU6ICdQb3N0JyB9XWAgLSBlcXVpdmFsZW50IHRvIGAxYFxuICAgKiAzLiAgYFt7IHR5cGU6ICdQb3N0JywgaWQ6IDEgfV1gXG4gICAqIDQuICBgKHJlc3VsdCwgZXJyb3IsIGFyZykgPT4gWydQb3N0J11gIC0gZXF1aXZhbGVudCB0byBgNWBcbiAgICogNS4gIGAocmVzdWx0LCBlcnJvciwgYXJnKSA9PiBbeyB0eXBlOiAnUG9zdCcgfV1gIC0gZXF1aXZhbGVudCB0byBgNGBcbiAgICogNi4gIGAocmVzdWx0LCBlcnJvciwgYXJnKSA9PiBbeyB0eXBlOiAnUG9zdCcsIGlkOiAxIH1dYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiAvLyBjb2RlYmxvY2stbWV0YSB0aXRsZT1cInByb3ZpZGVzVGFncyBleGFtcGxlXCJcbiAgICpcbiAgICogaW1wb3J0IHsgY3JlYXRlQXBpLCBmZXRjaEJhc2VRdWVyeSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnXG4gICAqIGludGVyZmFjZSBQb3N0IHtcbiAgICogICBpZDogbnVtYmVyXG4gICAqICAgbmFtZTogc3RyaW5nXG4gICAqIH1cbiAgICogdHlwZSBQb3N0c1Jlc3BvbnNlID0gUG9zdFtdXG4gICAqXG4gICAqIGNvbnN0IGFwaSA9IGNyZWF0ZUFwaSh7XG4gICAqICAgYmFzZVF1ZXJ5OiBmZXRjaEJhc2VRdWVyeSh7IGJhc2VVcmw6ICcvJyB9KSxcbiAgICogICB0YWdUeXBlczogWydQb3N0cyddLFxuICAgKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAgZ2V0UG9zdHM6IGJ1aWxkLnF1ZXJ5PFBvc3RzUmVzcG9uc2UsIHZvaWQ+KHtcbiAgICogICAgICAgcXVlcnk6ICgpID0+ICdwb3N0cycsXG4gICAqICAgICAgIC8vIGhpZ2hsaWdodC1zdGFydFxuICAgKiAgICAgICBwcm92aWRlc1RhZ3M6IChyZXN1bHQpID0+XG4gICAqICAgICAgICAgcmVzdWx0XG4gICAqICAgICAgICAgICA/IFtcbiAgICogICAgICAgICAgICAgICAuLi5yZXN1bHQubWFwKCh7IGlkIH0pID0+ICh7IHR5cGU6ICdQb3N0cycgYXMgY29uc3QsIGlkIH0pKSxcbiAgICogICAgICAgICAgICAgICB7IHR5cGU6ICdQb3N0cycsIGlkOiAnTElTVCcgfSxcbiAgICogICAgICAgICAgICAgXVxuICAgKiAgICAgICAgICAgOiBbeyB0eXBlOiAnUG9zdHMnLCBpZDogJ0xJU1QnIH1dLFxuICAgKiAgICAgICAvLyBoaWdobGlnaHQtZW5kXG4gICAqICAgICB9KVxuICAgKiAgIH0pXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgcHJvdmlkZXNUYWdzPzogUmVzdWx0RGVzY3JpcHRpb248VGFnVHlwZXMsIFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBCYXNlUXVlcnlFcnJvcjxCYXNlUXVlcnk+LCBCYXNlUXVlcnlNZXRhPEJhc2VRdWVyeT4+O1xuICAvKipcbiAgICogTm90IHRvIGJlIHVzZWQuIEEgcXVlcnkgc2hvdWxkIG5vdCBpbnZhbGlkYXRlIHRhZ3MgaW4gdGhlIGNhY2hlLlxuICAgKi9cbiAgaW52YWxpZGF0ZXNUYWdzPzogbmV2ZXI7XG5cbiAgLyoqXG4gICAqIENhbiBiZSBwcm92aWRlZCB0byByZXR1cm4gYSBjdXN0b20gY2FjaGUga2V5IHZhbHVlIGJhc2VkIG9uIHRoZSBxdWVyeSBhcmd1bWVudHMuXG4gICAqXG4gICAqIFRoaXMgaXMgcHJpbWFyaWx5IGludGVuZGVkIGZvciBjYXNlcyB3aGVyZSBhIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgaXMgcGFzc2VkIGFzIHBhcnQgb2YgdGhlIHF1ZXJ5IGFyZyBvYmplY3QgYW5kIHNob3VsZCBiZSBleGNsdWRlZCBmcm9tIHRoZSBjYWNoZSBrZXkuICBJdCBtYXkgYWxzbyBiZSB1c2VkIGZvciBjYXNlcyB3aGVyZSBhbiBlbmRwb2ludCBzaG91bGQgb25seSBoYXZlIGEgc2luZ2xlIGNhY2hlIGVudHJ5LCBzdWNoIGFzIGFuIGluZmluaXRlIGxvYWRpbmcgLyBwYWdpbmF0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBVbmxpa2UgdGhlIGBjcmVhdGVBcGlgIHZlcnNpb24gd2hpY2ggY2FuIF9vbmx5XyByZXR1cm4gYSBzdHJpbmcsIHRoaXMgcGVyLWVuZHBvaW50IG9wdGlvbiBjYW4gYWxzbyByZXR1cm4gYW4gYW4gb2JqZWN0LCBudW1iZXIsIG9yIGJvb2xlYW4uICBJZiBpdCByZXR1cm5zIGEgc3RyaW5nLCB0aGF0IHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUgY2FjaGUga2V5IGRpcmVjdGx5LiAgSWYgaXQgcmV0dXJucyBhbiBvYmplY3QgLyBudW1iZXIgLyBib29sZWFuLCB0aGF0IHZhbHVlIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBidWlsdC1pbiBgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJnc2AuICBUaGlzIHNpbXBsaWZpZXMgdGhlIHVzZSBjYXNlIG9mIHN0cmlwcGluZyBvdXQgYXJncyB5b3UgZG9uJ3Qgd2FudCBpbmNsdWRlZCBpbiB0aGUgY2FjaGUga2V5LlxuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiAvLyBjb2RlYmxvY2stbWV0YSB0aXRsZT1cInNlcmlhbGl6ZVF1ZXJ5QXJncyA6IGV4Y2x1ZGUgdmFsdWVcIlxuICAgKlxuICAgKiBpbXBvcnQgeyBjcmVhdGVBcGksIGZldGNoQmFzZVF1ZXJ5LCBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeS9yZWFjdCdcbiAgICogaW50ZXJmYWNlIFBvc3Qge1xuICAgKiAgIGlkOiBudW1iZXJcbiAgICogICBuYW1lOiBzdHJpbmdcbiAgICogfVxuICAgKlxuICAgKiBpbnRlcmZhY2UgTXlBcGlDbGllbnQge1xuICAgKiAgIGZldGNoUG9zdDogKGlkOiBzdHJpbmcpID0+IFByb21pc2U8UG9zdD5cbiAgICogfVxuICAgKlxuICAgKiBjcmVhdGVBcGkoe1xuICAgKiAgYmFzZVF1ZXJ5OiBmZXRjaEJhc2VRdWVyeSh7IGJhc2VVcmw6ICcvJyB9KSxcbiAgICogIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAvLyBFeGFtcGxlOiBhbiBlbmRwb2ludCB3aXRoIGFuIEFQSSBjbGllbnQgcGFzc2VkIGluIGFzIGFuIGFyZ3VtZW50LFxuICAgKiAgICAvLyBidXQgb25seSB0aGUgaXRlbSBJRCBzaG91bGQgYmUgdXNlZCBhcyB0aGUgY2FjaGUga2V5XG4gICAqICAgIGdldFBvc3Q6IGJ1aWxkLnF1ZXJ5PFBvc3QsIHsgaWQ6IHN0cmluZzsgY2xpZW50OiBNeUFwaUNsaWVudCB9Pih7XG4gICAqICAgICAgcXVlcnlGbjogYXN5bmMgKHsgaWQsIGNsaWVudCB9KSA9PiB7XG4gICAqICAgICAgICBjb25zdCBwb3N0ID0gYXdhaXQgY2xpZW50LmZldGNoUG9zdChpZClcbiAgICogICAgICAgIHJldHVybiB7IGRhdGE6IHBvc3QgfVxuICAgKiAgICAgIH0sXG4gICAqICAgICAgLy8gaGlnaGxpZ2h0LXN0YXJ0XG4gICAqICAgICAgc2VyaWFsaXplUXVlcnlBcmdzOiAoeyBxdWVyeUFyZ3MsIGVuZHBvaW50RGVmaW5pdGlvbiwgZW5kcG9pbnROYW1lIH0pID0+IHtcbiAgICogICAgICAgIGNvbnN0IHsgaWQgfSA9IHF1ZXJ5QXJnc1xuICAgKiAgICAgICAgLy8gVGhpcyBjYW4gcmV0dXJuIGEgc3RyaW5nLCBhbiBvYmplY3QsIGEgbnVtYmVyLCBvciBhIGJvb2xlYW4uXG4gICAqICAgICAgICAvLyBJZiBpdCByZXR1cm5zIGFuIG9iamVjdCwgbnVtYmVyIG9yIGJvb2xlYW4sIHRoYXQgdmFsdWVcbiAgICogICAgICAgIC8vIHdpbGwgYmUgc2VyaWFsaXplZCBhdXRvbWF0aWNhbGx5IHZpYSBgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJnc2BcbiAgICogICAgICAgIHJldHVybiB7IGlkIH0gLy8gb21pdCBgY2xpZW50YCBmcm9tIHRoZSBjYWNoZSBrZXlcbiAgICpcbiAgICogICAgICAgIC8vIEFsdGVybmF0ZWx5LCB5b3UgY2FuIHVzZSBgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJnc2AgeW91cnNlbGY6XG4gICAqICAgICAgICAvLyByZXR1cm4gZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAqICAgICAgICAvLyAgIGVuZHBvaW50TmFtZSxcbiAgICogICAgICAgIC8vICAgcXVlcnlBcmdzOiB7IGlkIH0sXG4gICAqICAgICAgICAvLyAgIGVuZHBvaW50RGVmaW5pdGlvblxuICAgKiAgICAgICAgLy8gfSlcbiAgICogICAgICAgIC8vIE9yICBjcmVhdGUgYW5kIHJldHVybiBhIHN0cmluZyB5b3Vyc2VsZjpcbiAgICogICAgICAgIC8vIHJldHVybiBgZ2V0UG9zdCgke2lkfSlgXG4gICAqICAgICAgfSxcbiAgICogICAgICAvLyBoaWdobGlnaHQtZW5kXG4gICAqICAgIH0pLFxuICAgKiAgfSksXG4gICAqfSlcbiAgICogYGBgXG4gICAqL1xuICBzZXJpYWxpemVRdWVyeUFyZ3M/OiBTZXJpYWxpemVRdWVyeUFyZ3M8UXVlcnlBcmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBSZWNvcmQ8YW55LCBhbnk+PjtcblxuICAvKipcbiAgICogQ2FuIGJlIHByb3ZpZGVkIHRvIG1lcmdlIGFuIGluY29taW5nIHJlc3BvbnNlIHZhbHVlIGludG8gdGhlIGN1cnJlbnQgY2FjaGUgZGF0YS5cbiAgICogSWYgc3VwcGxpZWQsIG5vIGF1dG9tYXRpYyBzdHJ1Y3R1cmFsIHNoYXJpbmcgd2lsbCBiZSBhcHBsaWVkIC0gaXQncyB1cCB0b1xuICAgKiB5b3UgdG8gdXBkYXRlIHRoZSBjYWNoZSBhcHByb3ByaWF0ZWx5LlxuICAgKlxuICAgKiBTaW5jZSBSVEtRIG5vcm1hbGx5IHJlcGxhY2VzIGNhY2hlIGVudHJpZXMgd2l0aCB0aGUgbmV3IHJlc3BvbnNlLCB5b3Ugd2lsbCB1c3VhbGx5XG4gICAqIG5lZWQgdG8gdXNlIHRoaXMgd2l0aCB0aGUgYHNlcmlhbGl6ZVF1ZXJ5QXJnc2Agb3IgYGZvcmNlUmVmZXRjaGAgb3B0aW9ucyB0byBrZWVwXG4gICAqIGFuIGV4aXN0aW5nIGNhY2hlIGVudHJ5IHNvIHRoYXQgaXQgY2FuIGJlIHVwZGF0ZWQuXG4gICAqXG4gICAqIFNpbmNlIHRoaXMgaXMgd3JhcHBlZCB3aXRoIEltbWVyLCB5b3UgbWF5IGVpdGhlciBtdXRhdGUgdGhlIGBjdXJyZW50Q2FjaGVWYWx1ZWAgZGlyZWN0bHksXG4gICAqIG9yIHJldHVybiBhIG5ldyB2YWx1ZSwgYnV0IF9ub3RfIGJvdGggYXQgb25jZS5cbiAgICpcbiAgICogV2lsbCBvbmx5IGJlIGNhbGxlZCBpZiB0aGUgZXhpc3RpbmcgYGN1cnJlbnRDYWNoZURhdGFgIGlzIF9ub3RfIGB1bmRlZmluZWRgIC0gb24gZmlyc3QgcmVzcG9uc2UsXG4gICAqIHRoZSBjYWNoZSBlbnRyeSB3aWxsIGp1c3Qgc2F2ZSB0aGUgcmVzcG9uc2UgZGF0YSBkaXJlY3RseS5cbiAgICpcbiAgICogVXNlZnVsIGlmIHlvdSBkb24ndCB3YW50IGEgbmV3IHJlcXVlc3QgdG8gY29tcGxldGVseSBvdmVycmlkZSB0aGUgY3VycmVudCBjYWNoZSB2YWx1ZSxcbiAgICogbWF5YmUgYmVjYXVzZSB5b3UgaGF2ZSBtYW51YWxseSB1cGRhdGVkIGl0IGZyb20gYW5vdGhlciBzb3VyY2UgYW5kIGRvbid0IHdhbnQgdGhvc2VcbiAgICogdXBkYXRlcyB0byBnZXQgbG9zdC5cbiAgICpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgdGl0bGU9XCJtZXJnZTogcGFnaW5hdGlvblwiXG4gICAqXG4gICAqIGltcG9ydCB7IGNyZWF0ZUFwaSwgZmV0Y2hCYXNlUXVlcnksIGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5L3JlYWN0J1xuICAgKiBpbnRlcmZhY2UgUG9zdCB7XG4gICAqICAgaWQ6IG51bWJlclxuICAgKiAgIG5hbWU6IHN0cmluZ1xuICAgKiB9XG4gICAqXG4gICAqIGNyZWF0ZUFwaSh7XG4gICAqICBiYXNlUXVlcnk6IGZldGNoQmFzZVF1ZXJ5KHsgYmFzZVVybDogJy8nIH0pLFxuICAgKiAgZW5kcG9pbnRzOiAoYnVpbGQpID0+ICh7XG4gICAqICAgIGxpc3RJdGVtczogYnVpbGQucXVlcnk8c3RyaW5nW10sIG51bWJlcj4oe1xuICAgKiAgICAgIHF1ZXJ5OiAocGFnZU51bWJlcikgPT4gYC9saXN0SXRlbXM/cGFnZT0ke3BhZ2VOdW1iZXJ9YCxcbiAgICogICAgIC8vIE9ubHkgaGF2ZSBvbmUgY2FjaGUgZW50cnkgYmVjYXVzZSB0aGUgYXJnIGFsd2F5cyBtYXBzIHRvIG9uZSBzdHJpbmdcbiAgICogICAgIHNlcmlhbGl6ZVF1ZXJ5QXJnczogKHsgZW5kcG9pbnROYW1lIH0pID0+IHtcbiAgICogICAgICAgcmV0dXJuIGVuZHBvaW50TmFtZVxuICAgKiAgICAgIH0sXG4gICAqICAgICAgLy8gQWx3YXlzIG1lcmdlIGluY29taW5nIGRhdGEgdG8gdGhlIGNhY2hlIGVudHJ5XG4gICAqICAgICAgbWVyZ2U6IChjdXJyZW50Q2FjaGUsIG5ld0l0ZW1zKSA9PiB7XG4gICAqICAgICAgICBjdXJyZW50Q2FjaGUucHVzaCguLi5uZXdJdGVtcylcbiAgICogICAgICB9LFxuICAgKiAgICAgIC8vIFJlZmV0Y2ggd2hlbiB0aGUgcGFnZSBhcmcgY2hhbmdlc1xuICAgKiAgICAgIGZvcmNlUmVmZXRjaCh7IGN1cnJlbnRBcmcsIHByZXZpb3VzQXJnIH0pIHtcbiAgICogICAgICAgIHJldHVybiBjdXJyZW50QXJnICE9PSBwcmV2aW91c0FyZ1xuICAgKiAgICAgIH0sXG4gICAqICAgIH0pLFxuICAgKiAgfSksXG4gICAqfSlcbiAgICogYGBgXG4gICAqL1xuICBtZXJnZT8oY3VycmVudENhY2hlRGF0YTogUmVzdWx0VHlwZSwgcmVzcG9uc2VEYXRhOiBSZXN1bHRUeXBlLCBvdGhlckFyZ3M6IHtcbiAgICBhcmc6IFF1ZXJ5QXJnO1xuICAgIGJhc2VRdWVyeU1ldGE6IEJhc2VRdWVyeU1ldGE8QmFzZVF1ZXJ5PjtcbiAgICByZXF1ZXN0SWQ6IHN0cmluZztcbiAgICBmdWxmaWxsZWRUaW1lU3RhbXA6IG51bWJlcjtcbiAgfSk6IFJlc3VsdFR5cGUgfCB2b2lkO1xuXG4gIC8qKlxuICAgKiBDaGVjayB0byBzZWUgaWYgdGhlIGVuZHBvaW50IHNob3VsZCBmb3JjZSBhIHJlZmV0Y2ggaW4gY2FzZXMgd2hlcmUgaXQgbm9ybWFsbHkgd291bGRuJ3QuXG4gICAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgXCJpbmZpbml0ZSBzY3JvbGxcIiAvIHBhZ2luYXRpb24gdXNlIGNhc2VzIHdoZXJlXG4gICAqIFJUS1EgaXMga2VlcGluZyBhIHNpbmdsZSBjYWNoZSBlbnRyeSB0aGF0IGlzIGFkZGVkIHRvIG92ZXIgdGltZSwgaW4gY29tYmluYXRpb25cbiAgICogd2l0aCBgc2VyaWFsaXplUXVlcnlBcmdzYCByZXR1cm5pbmcgYSBmaXhlZCBjYWNoZSBrZXkgYW5kIGEgYG1lcmdlYCBjYWxsYmFja1xuICAgKiBzZXQgdG8gYWRkIGluY29taW5nIGRhdGEgdG8gdGhlIGNhY2hlIGVudHJ5IGVhY2ggdGltZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgdGl0bGU9XCJmb3JjZVJlZnJlc2g6IHBhZ2luYXRpb25cIlxuICAgKlxuICAgKiBpbXBvcnQgeyBjcmVhdGVBcGksIGZldGNoQmFzZVF1ZXJ5LCBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeS9yZWFjdCdcbiAgICogaW50ZXJmYWNlIFBvc3Qge1xuICAgKiAgIGlkOiBudW1iZXJcbiAgICogICBuYW1lOiBzdHJpbmdcbiAgICogfVxuICAgKlxuICAgKiBjcmVhdGVBcGkoe1xuICAgKiAgYmFzZVF1ZXJ5OiBmZXRjaEJhc2VRdWVyeSh7IGJhc2VVcmw6ICcvJyB9KSxcbiAgICogIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICBsaXN0SXRlbXM6IGJ1aWxkLnF1ZXJ5PHN0cmluZ1tdLCBudW1iZXI+KHtcbiAgICogICAgICBxdWVyeTogKHBhZ2VOdW1iZXIpID0+IGAvbGlzdEl0ZW1zP3BhZ2U9JHtwYWdlTnVtYmVyfWAsXG4gICAqICAgICAvLyBPbmx5IGhhdmUgb25lIGNhY2hlIGVudHJ5IGJlY2F1c2UgdGhlIGFyZyBhbHdheXMgbWFwcyB0byBvbmUgc3RyaW5nXG4gICAqICAgICBzZXJpYWxpemVRdWVyeUFyZ3M6ICh7IGVuZHBvaW50TmFtZSB9KSA9PiB7XG4gICAqICAgICAgIHJldHVybiBlbmRwb2ludE5hbWVcbiAgICogICAgICB9LFxuICAgKiAgICAgIC8vIEFsd2F5cyBtZXJnZSBpbmNvbWluZyBkYXRhIHRvIHRoZSBjYWNoZSBlbnRyeVxuICAgKiAgICAgIG1lcmdlOiAoY3VycmVudENhY2hlLCBuZXdJdGVtcykgPT4ge1xuICAgKiAgICAgICAgY3VycmVudENhY2hlLnB1c2goLi4ubmV3SXRlbXMpXG4gICAqICAgICAgfSxcbiAgICogICAgICAvLyBSZWZldGNoIHdoZW4gdGhlIHBhZ2UgYXJnIGNoYW5nZXNcbiAgICogICAgICBmb3JjZVJlZmV0Y2goeyBjdXJyZW50QXJnLCBwcmV2aW91c0FyZyB9KSB7XG4gICAqICAgICAgICByZXR1cm4gY3VycmVudEFyZyAhPT0gcHJldmlvdXNBcmdcbiAgICogICAgICB9LFxuICAgKiAgICB9KSxcbiAgICogIH0pLFxuICAgKn0pXG4gICAqIGBgYFxuICAgKi9cbiAgZm9yY2VSZWZldGNoPyhwYXJhbXM6IHtcbiAgICBjdXJyZW50QXJnOiBRdWVyeUFyZyB8IHVuZGVmaW5lZDtcbiAgICBwcmV2aW91c0FyZzogUXVlcnlBcmcgfCB1bmRlZmluZWQ7XG4gICAgc3RhdGU6IFJvb3RTdGF0ZTxhbnksIGFueSwgc3RyaW5nPjtcbiAgICBlbmRwb2ludFN0YXRlPzogUXVlcnlTdWJTdGF0ZTxhbnk+O1xuICB9KTogYm9vbGVhbjtcblxuICAvKipcbiAgICogQWxsIG9mIHRoZXNlIGFyZSBgdW5kZWZpbmVkYCBhdCBydW50aW1lLCBwdXJlbHkgdG8gYmUgdXNlZCBpbiBUeXBlU2NyaXB0IGRlY2xhcmF0aW9ucyFcbiAgICovXG4gIFR5cGVzPzogUXVlcnlUeXBlczxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBUYWdUeXBlcywgUmVzdWx0VHlwZSwgUmVkdWNlclBhdGg+O1xufVxuZXhwb3J0IHR5cGUgUXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgVGFnVHlwZXMgZXh0ZW5kcyBzdHJpbmcsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLCBSYXdSZXN1bHRUeXBlIGV4dGVuZHMgQmFzZVF1ZXJ5UmVzdWx0PEJhc2VRdWVyeT4gPSBCYXNlUXVlcnlSZXN1bHQ8QmFzZVF1ZXJ5Pj4gPSBCYXNlRW5kcG9pbnREZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFJlc3VsdFR5cGUsIFJhd1Jlc3VsdFR5cGU+ICYgUXVlcnlFeHRyYU9wdGlvbnM8VGFnVHlwZXMsIFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFJlZHVjZXJQYXRoPjtcbmV4cG9ydCB0eXBlIEluZmluaXRlUXVlcnlUeXBlczxRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgVGFnVHlwZXMgZXh0ZW5kcyBzdHJpbmcsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IEJhc2VFbmRwb2ludFR5cGVzPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFJlc3VsdFR5cGU+ICYge1xuICAvKipcbiAgICogVGhlIGVuZHBvaW50IGRlZmluaXRpb24gdHlwZS4gVG8gYmUgdXNlZCB3aXRoIHNvbWUgaW50ZXJuYWwgZ2VuZXJpYyB0eXBlcy5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3QgdXNlTXlXcmFwcGVkSG9vazogVXNlUXVlcnk8dHlwZW9mIGFwaS5lbmRwb2ludHMucXVlcnkuVHlwZXMuUXVlcnlEZWZpbml0aW9uPiA9IC4uLlxuICAgKiBgYGBcbiAgICovXG4gIEluZmluaXRlUXVlcnlEZWZpbml0aW9uOiBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnksIFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aD47XG4gIFRhZ1R5cGVzOiBUYWdUeXBlcztcbiAgUmVkdWNlclBhdGg6IFJlZHVjZXJQYXRoO1xufTtcbmV4cG9ydCBpbnRlcmZhY2UgSW5maW5pdGVRdWVyeUV4dHJhT3B0aW9uczxUYWdUeXBlcyBleHRlbmRzIHN0cmluZywgUmVzdWx0VHlwZSwgUXVlcnlBcmcsIFBhZ2VQYXJhbSwgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiBleHRlbmRzIENhY2hlTGlmZWN5Y2xlSW5maW5pdGVRdWVyeUV4dHJhT3B0aW9uczxJbmZpbml0ZURhdGE8UmVzdWx0VHlwZSwgUGFnZVBhcmFtPiwgUXVlcnlBcmcsIEJhc2VRdWVyeSwgUmVkdWNlclBhdGg+LCBRdWVyeUxpZmVjeWNsZUluZmluaXRlUXVlcnlFeHRyYU9wdGlvbnM8SW5maW5pdGVEYXRhPFJlc3VsdFR5cGUsIFBhZ2VQYXJhbT4sIFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFJlZHVjZXJQYXRoPiwgQ2FjaGVDb2xsZWN0aW9uUXVlcnlFeHRyYU9wdGlvbnMge1xuICB0eXBlOiBEZWZpbml0aW9uVHlwZS5pbmZpbml0ZXF1ZXJ5O1xuICBwcm92aWRlc1RhZ3M/OiBSZXN1bHREZXNjcmlwdGlvbjxUYWdUeXBlcywgSW5maW5pdGVEYXRhPFJlc3VsdFR5cGUsIFBhZ2VQYXJhbT4sIFF1ZXJ5QXJnLCBCYXNlUXVlcnlFcnJvcjxCYXNlUXVlcnk+LCBCYXNlUXVlcnlNZXRhPEJhc2VRdWVyeT4+O1xuICAvKipcbiAgICogTm90IHRvIGJlIHVzZWQuIEEgcXVlcnkgc2hvdWxkIG5vdCBpbnZhbGlkYXRlIHRhZ3MgaW4gdGhlIGNhY2hlLlxuICAgKi9cbiAgaW52YWxpZGF0ZXNUYWdzPzogbmV2ZXI7XG5cbiAgLyoqXG4gICAqIFJlcXVpcmVkIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSBpbmZpbml0ZSBxdWVyeSBiZWhhdmlvci5cbiAgICogYGluaXRpYWxQYWdlUGFyYW1gIGFuZCBgZ2V0TmV4dFBhZ2VQYXJhbWAgYXJlIHJlcXVpcmVkLCB0b1xuICAgKiBlbnN1cmUgdGhlIGluZmluaXRlIHF1ZXJ5IGNhbiBwcm9wZXJseSBmZXRjaCB0aGUgbmV4dCBwYWdlIG9mIGRhdGEuXG4gICAqIGBpbml0aWFsUGFnZVBhcmFtYCBtYXkgYmUgc3BlY2lmaWVkIHdoZW4gdXNpbmcgdGhlXG4gICAqIGVuZHBvaW50LCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICogYG1heFBhZ2VzYCBhbmQgYGdldFByZXZpb3VzUGFnZVBhcmFtYCBhcmUgYm90aCBvcHRpb25hbC5cbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIFxuICAgKiBgYGB0c1xuICAgKiAvLyBjb2RlYmxvY2stbWV0YSB0aXRsZT1cImluZmluaXRlUXVlcnlPcHRpb25zIGV4YW1wbGVcIlxuICAgKiBpbXBvcnQgeyBjcmVhdGVBcGksIGZldGNoQmFzZVF1ZXJ5LCBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeS9yZWFjdCdcbiAgICogXG4gICAqIHR5cGUgUG9rZW1vbiA9IHtcbiAgICogICBpZDogc3RyaW5nXG4gICAqICAgbmFtZTogc3RyaW5nXG4gICAqIH1cbiAgICogXG4gICAqIGNvbnN0IHBva2Vtb25BcGkgPSBjcmVhdGVBcGkoe1xuICAgKiAgIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnaHR0cHM6Ly9wb2tlYXBpLmNvL2FwaS92Mi8nIH0pLFxuICAgKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAgZ2V0SW5maW5pdGVQb2tlbW9uV2l0aE1heDogYnVpbGQuaW5maW5pdGVRdWVyeTxQb2tlbW9uW10sIHN0cmluZywgbnVtYmVyPih7XG4gICAqICAgICAgIGluZmluaXRlUXVlcnlPcHRpb25zOiB7XG4gICAqICAgICAgICAgaW5pdGlhbFBhZ2VQYXJhbTogMCxcbiAgICogICAgICAgICBtYXhQYWdlczogMyxcbiAgICogICAgICAgICBnZXROZXh0UGFnZVBhcmFtOiAobGFzdFBhZ2UsIGFsbFBhZ2VzLCBsYXN0UGFnZVBhcmFtLCBhbGxQYWdlUGFyYW1zKSA9PlxuICAgKiAgICAgICAgICAgbGFzdFBhZ2VQYXJhbSArIDEsXG4gICAqICAgICAgICAgZ2V0UHJldmlvdXNQYWdlUGFyYW06IChcbiAgICogICAgICAgICAgIGZpcnN0UGFnZSxcbiAgICogICAgICAgICAgIGFsbFBhZ2VzLFxuICAgKiAgICAgICAgICAgZmlyc3RQYWdlUGFyYW0sXG4gICAqICAgICAgICAgICBhbGxQYWdlUGFyYW1zLFxuICAgKiAgICAgICAgICkgPT4ge1xuICAgKiAgICAgICAgICAgcmV0dXJuIGZpcnN0UGFnZVBhcmFtID4gMCA/IGZpcnN0UGFnZVBhcmFtIC0gMSA6IHVuZGVmaW5lZFxuICAgKiAgICAgICAgIH0sXG4gICAqICAgICAgIH0sXG4gICAqICAgICAgIHF1ZXJ5KHtwYWdlUGFyYW19KSB7XG4gICAqICAgICAgICAgcmV0dXJuIGBodHRwczovL2V4YW1wbGUuY29tL2xpc3RJdGVtcz9wYWdlPSR7cGFnZVBhcmFtfWBcbiAgICogICAgICAgfSxcbiAgICogICAgIH0pLFxuICAgKiAgIH0pLFxuICAgKiB9KVxuICAgXG4gICAqIGBgYFxuICAgKi9cbiAgaW5maW5pdGVRdWVyeU9wdGlvbnM6IEluZmluaXRlUXVlcnlDb25maWdPcHRpb25zPFJlc3VsdFR5cGUsIFBhZ2VQYXJhbSwgUXVlcnlBcmc+O1xuXG4gIC8qKlxuICAgKiBDYW4gYmUgcHJvdmlkZWQgdG8gcmV0dXJuIGEgY3VzdG9tIGNhY2hlIGtleSB2YWx1ZSBiYXNlZCBvbiB0aGUgcXVlcnkgYXJndW1lbnRzLlxuICAgKlxuICAgKiBUaGlzIGlzIHByaW1hcmlseSBpbnRlbmRlZCBmb3IgY2FzZXMgd2hlcmUgYSBub24tc2VyaWFsaXphYmxlIHZhbHVlIGlzIHBhc3NlZCBhcyBwYXJ0IG9mIHRoZSBxdWVyeSBhcmcgb2JqZWN0IGFuZCBzaG91bGQgYmUgZXhjbHVkZWQgZnJvbSB0aGUgY2FjaGUga2V5LiAgSXQgbWF5IGFsc28gYmUgdXNlZCBmb3IgY2FzZXMgd2hlcmUgYW4gZW5kcG9pbnQgc2hvdWxkIG9ubHkgaGF2ZSBhIHNpbmdsZSBjYWNoZSBlbnRyeSwgc3VjaCBhcyBhbiBpbmZpbml0ZSBsb2FkaW5nIC8gcGFnaW5hdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogVW5saWtlIHRoZSBgY3JlYXRlQXBpYCB2ZXJzaW9uIHdoaWNoIGNhbiBfb25seV8gcmV0dXJuIGEgc3RyaW5nLCB0aGlzIHBlci1lbmRwb2ludCBvcHRpb24gY2FuIGFsc28gcmV0dXJuIGFuIGFuIG9iamVjdCwgbnVtYmVyLCBvciBib29sZWFuLiAgSWYgaXQgcmV0dXJucyBhIHN0cmluZywgdGhhdCB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGNhY2hlIGtleSBkaXJlY3RseS4gIElmIGl0IHJldHVybnMgYW4gb2JqZWN0IC8gbnVtYmVyIC8gYm9vbGVhbiwgdGhhdCB2YWx1ZSB3aWxsIGJlIHBhc3NlZCB0byB0aGUgYnVpbHQtaW4gYGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3NgLiAgVGhpcyBzaW1wbGlmaWVzIHRoZSB1c2UgY2FzZSBvZiBzdHJpcHBpbmcgb3V0IGFyZ3MgeW91IGRvbid0IHdhbnQgaW5jbHVkZWQgaW4gdGhlIGNhY2hlIGtleS5cbiAgICpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgdGl0bGU9XCJzZXJpYWxpemVRdWVyeUFyZ3MgOiBleGNsdWRlIHZhbHVlXCJcbiAgICpcbiAgICogaW1wb3J0IHsgY3JlYXRlQXBpLCBmZXRjaEJhc2VRdWVyeSwgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnXG4gICAqIGludGVyZmFjZSBQb3N0IHtcbiAgICogICBpZDogbnVtYmVyXG4gICAqICAgbmFtZTogc3RyaW5nXG4gICAqIH1cbiAgICpcbiAgICogaW50ZXJmYWNlIE15QXBpQ2xpZW50IHtcbiAgICogICBmZXRjaFBvc3Q6IChpZDogc3RyaW5nKSA9PiBQcm9taXNlPFBvc3Q+XG4gICAqIH1cbiAgICpcbiAgICogY3JlYXRlQXBpKHtcbiAgICogIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnLycgfSksXG4gICAqICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAgICogICAgLy8gRXhhbXBsZTogYW4gZW5kcG9pbnQgd2l0aCBhbiBBUEkgY2xpZW50IHBhc3NlZCBpbiBhcyBhbiBhcmd1bWVudCxcbiAgICogICAgLy8gYnV0IG9ubHkgdGhlIGl0ZW0gSUQgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIGNhY2hlIGtleVxuICAgKiAgICBnZXRQb3N0OiBidWlsZC5xdWVyeTxQb3N0LCB7IGlkOiBzdHJpbmc7IGNsaWVudDogTXlBcGlDbGllbnQgfT4oe1xuICAgKiAgICAgIHF1ZXJ5Rm46IGFzeW5jICh7IGlkLCBjbGllbnQgfSkgPT4ge1xuICAgKiAgICAgICAgY29uc3QgcG9zdCA9IGF3YWl0IGNsaWVudC5mZXRjaFBvc3QoaWQpXG4gICAqICAgICAgICByZXR1cm4geyBkYXRhOiBwb3N0IH1cbiAgICogICAgICB9LFxuICAgKiAgICAgIC8vIGhpZ2hsaWdodC1zdGFydFxuICAgKiAgICAgIHNlcmlhbGl6ZVF1ZXJ5QXJnczogKHsgcXVlcnlBcmdzLCBlbmRwb2ludERlZmluaXRpb24sIGVuZHBvaW50TmFtZSB9KSA9PiB7XG4gICAqICAgICAgICBjb25zdCB7IGlkIH0gPSBxdWVyeUFyZ3NcbiAgICogICAgICAgIC8vIFRoaXMgY2FuIHJldHVybiBhIHN0cmluZywgYW4gb2JqZWN0LCBhIG51bWJlciwgb3IgYSBib29sZWFuLlxuICAgKiAgICAgICAgLy8gSWYgaXQgcmV0dXJucyBhbiBvYmplY3QsIG51bWJlciBvciBib29sZWFuLCB0aGF0IHZhbHVlXG4gICAqICAgICAgICAvLyB3aWxsIGJlIHNlcmlhbGl6ZWQgYXV0b21hdGljYWxseSB2aWEgYGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3NgXG4gICAqICAgICAgICByZXR1cm4geyBpZCB9IC8vIG9taXQgYGNsaWVudGAgZnJvbSB0aGUgY2FjaGUga2V5XG4gICAqXG4gICAqICAgICAgICAvLyBBbHRlcm5hdGVseSwgeW91IGNhbiB1c2UgYGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3NgIHlvdXJzZWxmOlxuICAgKiAgICAgICAgLy8gcmV0dXJuIGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3Moe1xuICAgKiAgICAgICAgLy8gICBlbmRwb2ludE5hbWUsXG4gICAqICAgICAgICAvLyAgIHF1ZXJ5QXJnczogeyBpZCB9LFxuICAgKiAgICAgICAgLy8gICBlbmRwb2ludERlZmluaXRpb25cbiAgICogICAgICAgIC8vIH0pXG4gICAqICAgICAgICAvLyBPciAgY3JlYXRlIGFuZCByZXR1cm4gYSBzdHJpbmcgeW91cnNlbGY6XG4gICAqICAgICAgICAvLyByZXR1cm4gYGdldFBvc3QoJHtpZH0pYFxuICAgKiAgICAgIH0sXG4gICAqICAgICAgLy8gaGlnaGxpZ2h0LWVuZFxuICAgKiAgICB9KSxcbiAgICogIH0pLFxuICAgKn0pXG4gICAqIGBgYFxuICAgKi9cbiAgc2VyaWFsaXplUXVlcnlBcmdzPzogU2VyaWFsaXplUXVlcnlBcmdzPFF1ZXJ5QXJnLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgUmVjb3JkPGFueSwgYW55Pj47XG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGVzZSBhcmUgYHVuZGVmaW5lZGAgYXQgcnVudGltZSwgcHVyZWx5IHRvIGJlIHVzZWQgaW4gVHlwZVNjcmlwdCBkZWNsYXJhdGlvbnMhXG4gICAqL1xuICBUeXBlcz86IEluZmluaXRlUXVlcnlUeXBlczxRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnksIFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aD47XG59XG5leHBvcnQgdHlwZSBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgVGFnVHlwZXMgZXh0ZW5kcyBzdHJpbmcsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLCBSYXdSZXN1bHRUeXBlIGV4dGVuZHMgQmFzZVF1ZXJ5UmVzdWx0PEJhc2VRdWVyeT4gPSBCYXNlUXVlcnlSZXN1bHQ8QmFzZVF1ZXJ5Pj4gPVxuLy8gSW5maW5pdGUgcXVlcnkgZW5kcG9pbnRzIHJlY2VpdmUgYHtxdWVyeUFyZywgcGFnZVBhcmFtfWBcbkJhc2VFbmRwb2ludERlZmluaXRpb248SW5maW5pdGVRdWVyeUNvbWJpbmVkQXJnPFF1ZXJ5QXJnLCBQYWdlUGFyYW0+LCBCYXNlUXVlcnksIFJlc3VsdFR5cGUsIFJhd1Jlc3VsdFR5cGU+ICYgSW5maW5pdGVRdWVyeUV4dHJhT3B0aW9uczxUYWdUeXBlcywgUmVzdWx0VHlwZSwgUXVlcnlBcmcsIFBhZ2VQYXJhbSwgQmFzZVF1ZXJ5LCBSZWR1Y2VyUGF0aD47XG50eXBlIE11dGF0aW9uVHlwZXM8UXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBUYWdUeXBlcyBleHRlbmRzIHN0cmluZywgUmVzdWx0VHlwZSwgUmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+ID0gQmFzZUVuZHBvaW50VHlwZXM8UXVlcnlBcmcsIEJhc2VRdWVyeSwgUmVzdWx0VHlwZT4gJiB7XG4gIC8qKlxuICAgKiBUaGUgZW5kcG9pbnQgZGVmaW5pdGlvbiB0eXBlLiBUbyBiZSB1c2VkIHdpdGggc29tZSBpbnRlcm5hbCBnZW5lcmljIHR5cGVzLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCB1c2VNeVdyYXBwZWRIb29rOiBVc2VNdXRhdGlvbjx0eXBlb2YgYXBpLmVuZHBvaW50cy5xdWVyeS5UeXBlcy5NdXRhdGlvbkRlZmluaXRpb24+ID0gLi4uXG4gICAqIGBgYFxuICAgKi9cbiAgTXV0YXRpb25EZWZpbml0aW9uOiBNdXRhdGlvbkRlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSwgVGFnVHlwZXMsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoPjtcbiAgVGFnVHlwZXM6IFRhZ1R5cGVzO1xuICBSZWR1Y2VyUGF0aDogUmVkdWNlclBhdGg7XG59O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNdXRhdGlvbkV4dHJhT3B0aW9uczxUYWdUeXBlcyBleHRlbmRzIHN0cmluZywgUmVzdWx0VHlwZSwgUXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gZXh0ZW5kcyBDYWNoZUxpZmVjeWNsZU11dGF0aW9uRXh0cmFPcHRpb25zPFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFJlZHVjZXJQYXRoPiwgUXVlcnlMaWZlY3ljbGVNdXRhdGlvbkV4dHJhT3B0aW9uczxSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZWR1Y2VyUGF0aD4ge1xuICB0eXBlOiBEZWZpbml0aW9uVHlwZS5tdXRhdGlvbjtcblxuICAvKipcbiAgICogVXNlZCBieSBgbXV0YXRpb25gIGVuZHBvaW50cy4gRGV0ZXJtaW5lcyB3aGljaCBjYWNoZWQgZGF0YSBzaG91bGQgYmUgZWl0aGVyIHJlLWZldGNoZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBjYWNoZS5cbiAgICogRXhwZWN0cyB0aGUgc2FtZSBzaGFwZXMgYXMgYHByb3ZpZGVzVGFnc2AuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIHRpdGxlPVwiaW52YWxpZGF0ZXNUYWdzIGV4YW1wbGVcIlxuICAgKiBpbXBvcnQgeyBjcmVhdGVBcGksIGZldGNoQmFzZVF1ZXJ5IH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeS9yZWFjdCdcbiAgICogaW50ZXJmYWNlIFBvc3Qge1xuICAgKiAgIGlkOiBudW1iZXJcbiAgICogICBuYW1lOiBzdHJpbmdcbiAgICogfVxuICAgKiB0eXBlIFBvc3RzUmVzcG9uc2UgPSBQb3N0W11cbiAgICpcbiAgICogY29uc3QgYXBpID0gY3JlYXRlQXBpKHtcbiAgICogICBiYXNlUXVlcnk6IGZldGNoQmFzZVF1ZXJ5KHsgYmFzZVVybDogJy8nIH0pLFxuICAgKiAgIHRhZ1R5cGVzOiBbJ1Bvc3RzJ10sXG4gICAqICAgZW5kcG9pbnRzOiAoYnVpbGQpID0+ICh7XG4gICAqICAgICBnZXRQb3N0czogYnVpbGQucXVlcnk8UG9zdHNSZXNwb25zZSwgdm9pZD4oe1xuICAgKiAgICAgICBxdWVyeTogKCkgPT4gJ3Bvc3RzJyxcbiAgICogICAgICAgcHJvdmlkZXNUYWdzOiAocmVzdWx0KSA9PlxuICAgKiAgICAgICAgIHJlc3VsdFxuICAgKiAgICAgICAgICAgPyBbXG4gICAqICAgICAgICAgICAgICAgLi4ucmVzdWx0Lm1hcCgoeyBpZCB9KSA9PiAoeyB0eXBlOiAnUG9zdHMnIGFzIGNvbnN0LCBpZCB9KSksXG4gICAqICAgICAgICAgICAgICAgeyB0eXBlOiAnUG9zdHMnLCBpZDogJ0xJU1QnIH0sXG4gICAqICAgICAgICAgICAgIF1cbiAgICogICAgICAgICAgIDogW3sgdHlwZTogJ1Bvc3RzJywgaWQ6ICdMSVNUJyB9XSxcbiAgICogICAgIH0pLFxuICAgKiAgICAgYWRkUG9zdDogYnVpbGQubXV0YXRpb248UG9zdCwgUGFydGlhbDxQb3N0Pj4oe1xuICAgKiAgICAgICBxdWVyeShib2R5KSB7XG4gICAqICAgICAgICAgcmV0dXJuIHtcbiAgICogICAgICAgICAgIHVybDogYHBvc3RzYCxcbiAgICogICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgKiAgICAgICAgICAgYm9keSxcbiAgICogICAgICAgICB9XG4gICAqICAgICAgIH0sXG4gICAqICAgICAgIC8vIGhpZ2hsaWdodC1zdGFydFxuICAgKiAgICAgICBpbnZhbGlkYXRlc1RhZ3M6IFt7IHR5cGU6ICdQb3N0cycsIGlkOiAnTElTVCcgfV0sXG4gICAqICAgICAgIC8vIGhpZ2hsaWdodC1lbmRcbiAgICogICAgIH0pLFxuICAgKiAgIH0pXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgaW52YWxpZGF0ZXNUYWdzPzogUmVzdWx0RGVzY3JpcHRpb248VGFnVHlwZXMsIFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBCYXNlUXVlcnlFcnJvcjxCYXNlUXVlcnk+LCBCYXNlUXVlcnlNZXRhPEJhc2VRdWVyeT4+O1xuICAvKipcbiAgICogTm90IHRvIGJlIHVzZWQuIEEgbXV0YXRpb24gc2hvdWxkIG5vdCBwcm92aWRlIHRhZ3MgdG8gdGhlIGNhY2hlLlxuICAgKi9cbiAgcHJvdmlkZXNUYWdzPzogbmV2ZXI7XG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGVzZSBhcmUgYHVuZGVmaW5lZGAgYXQgcnVudGltZSwgcHVyZWx5IHRvIGJlIHVzZWQgaW4gVHlwZVNjcmlwdCBkZWNsYXJhdGlvbnMhXG4gICAqL1xuICBUeXBlcz86IE11dGF0aW9uVHlwZXM8UXVlcnlBcmcsIEJhc2VRdWVyeSwgVGFnVHlwZXMsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoPjtcbn1cbmV4cG9ydCB0eXBlIE11dGF0aW9uRGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFRhZ1R5cGVzIGV4dGVuZHMgc3RyaW5nLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZyA9IHN0cmluZywgUmF3UmVzdWx0VHlwZSBleHRlbmRzIEJhc2VRdWVyeVJlc3VsdDxCYXNlUXVlcnk+ID0gQmFzZVF1ZXJ5UmVzdWx0PEJhc2VRdWVyeT4+ID0gQmFzZUVuZHBvaW50RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZXN1bHRUeXBlLCBSYXdSZXN1bHRUeXBlPiAmIE11dGF0aW9uRXh0cmFPcHRpb25zPFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZWR1Y2VyUGF0aD47XG5leHBvcnQgdHlwZSBFbmRwb2ludERlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBUYWdUeXBlcyBleHRlbmRzIHN0cmluZywgUmVzdWx0VHlwZSwgUmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsIFBhZ2VQYXJhbSA9IGFueSwgUmF3UmVzdWx0VHlwZSBleHRlbmRzIEJhc2VRdWVyeVJlc3VsdDxCYXNlUXVlcnk+ID0gQmFzZVF1ZXJ5UmVzdWx0PEJhc2VRdWVyeT4+ID0gUXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aCwgUmF3UmVzdWx0VHlwZT4gfCBNdXRhdGlvbkRlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSwgVGFnVHlwZXMsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoLCBSYXdSZXN1bHRUeXBlPiB8IEluZmluaXRlUXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBQYWdlUGFyYW0sIEJhc2VRdWVyeSwgVGFnVHlwZXMsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoLCBSYXdSZXN1bHRUeXBlPjtcbmV4cG9ydCB0eXBlIEVuZHBvaW50RGVmaW5pdGlvbnMgPSBSZWNvcmQ8c3RyaW5nLCBFbmRwb2ludERlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55Pj47XG5leHBvcnQgZnVuY3Rpb24gaXNRdWVyeURlZmluaXRpb24oZTogRW5kcG9pbnREZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueT4pOiBlIGlzIFF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55PiB7XG4gIHJldHVybiBlLnR5cGUgPT09IERlZmluaXRpb25UeXBlLnF1ZXJ5O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTXV0YXRpb25EZWZpbml0aW9uKGU6IEVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+KTogZSBpcyBNdXRhdGlvbkRlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueT4ge1xuICByZXR1cm4gZS50eXBlID09PSBEZWZpbml0aW9uVHlwZS5tdXRhdGlvbjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0luZmluaXRlUXVlcnlEZWZpbml0aW9uKGU6IEVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+KTogZSBpcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+IHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gRGVmaW5pdGlvblR5cGUuaW5maW5pdGVxdWVyeTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0FueVF1ZXJ5RGVmaW5pdGlvbihlOiBFbmRwb2ludERlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55Pik6IGUgaXMgUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4gfCBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4ge1xuICByZXR1cm4gaXNRdWVyeURlZmluaXRpb24oZSkgfHwgaXNJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbihlKTtcbn1cbmV4cG9ydCB0eXBlIEVuZHBvaW50QnVpbGRlcjxCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgVGFnVHlwZXMgZXh0ZW5kcyBzdHJpbmcsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nPiA9IHtcbiAgLyoqXG4gICAqIEFuIGVuZHBvaW50IGRlZmluaXRpb24gdGhhdCByZXRyaWV2ZXMgZGF0YSwgYW5kIG1heSBwcm92aWRlIHRhZ3MgdG8gdGhlIGNhY2hlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiAvLyBjb2RlYmxvY2stbWV0YSB0aXRsZT1cIkV4YW1wbGUgb2YgYWxsIHF1ZXJ5IGVuZHBvaW50IG9wdGlvbnNcIlxuICAgKiBjb25zdCBhcGkgPSBjcmVhdGVBcGkoe1xuICAgKiAgYmFzZVF1ZXJ5LFxuICAgKiAgZW5kcG9pbnRzOiAoYnVpbGQpID0+ICh7XG4gICAqICAgIGdldFBvc3Q6IGJ1aWxkLnF1ZXJ5KHtcbiAgICogICAgICBxdWVyeTogKGlkKSA9PiAoeyB1cmw6IGBwb3N0LyR7aWR9YCB9KSxcbiAgICogICAgICAvLyBQaWNrIG91dCBkYXRhIGFuZCBwcmV2ZW50IG5lc3RlZCBwcm9wZXJ0aWVzIGluIGEgaG9vayBvciBzZWxlY3RvclxuICAgKiAgICAgIHRyYW5zZm9ybVJlc3BvbnNlOiAocmVzcG9uc2UpID0+IHJlc3BvbnNlLmRhdGEsXG4gICAqICAgICAgLy8gUGljayBvdXQgZXJyb3IgYW5kIHByZXZlbnQgbmVzdGVkIHByb3BlcnRpZXMgaW4gYSBob29rIG9yIHNlbGVjdG9yXG4gICAqICAgICAgdHJhbnNmb3JtRXJyb3JSZXNwb25zZTogKHJlc3BvbnNlKSA9PiByZXNwb25zZS5lcnJvcixcbiAgICogICAgICAvLyBgcmVzdWx0YCBpcyB0aGUgc2VydmVyIHJlc3BvbnNlXG4gICAqICAgICAgcHJvdmlkZXNUYWdzOiAocmVzdWx0LCBlcnJvciwgaWQpID0+IFt7IHR5cGU6ICdQb3N0JywgaWQgfV0sXG4gICAqICAgICAgLy8gdHJpZ2dlciBzaWRlIGVmZmVjdHMgb3Igb3B0aW1pc3RpYyB1cGRhdGVzXG4gICAqICAgICAgb25RdWVyeVN0YXJ0ZWQoaWQsIHsgZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYSwgcmVxdWVzdElkLCBxdWVyeUZ1bGZpbGxlZCwgZ2V0Q2FjaGVFbnRyeSwgdXBkYXRlQ2FjaGVkRGF0YSB9KSB7fSxcbiAgICogICAgICAvLyBoYW5kbGUgc3Vic2NyaXB0aW9ucyBldGNcbiAgICogICAgICBvbkNhY2hlRW50cnlBZGRlZChpZCwgeyBkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhLCByZXF1ZXN0SWQsIGNhY2hlRW50cnlSZW1vdmVkLCBjYWNoZURhdGFMb2FkZWQsIGdldENhY2hlRW50cnksIHVwZGF0ZUNhY2hlZERhdGEgfSkge30sXG4gICAqICAgIH0pLFxuICAgKiAgfSksXG4gICAqfSk7XG4gICAqYGBgXG4gICAqL1xuICBxdWVyeTxSZXN1bHRUeXBlLCBRdWVyeUFyZywgUmF3UmVzdWx0VHlwZSBleHRlbmRzIEJhc2VRdWVyeVJlc3VsdDxCYXNlUXVlcnk+ID0gQmFzZVF1ZXJ5UmVzdWx0PEJhc2VRdWVyeT4+KGRlZmluaXRpb246IE9taXRGcm9tVW5pb248UXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aCwgUmF3UmVzdWx0VHlwZT4sICd0eXBlJz4pOiBRdWVyeURlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSwgVGFnVHlwZXMsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoLCBSYXdSZXN1bHRUeXBlPjtcblxuICAvKipcbiAgICogQW4gZW5kcG9pbnQgZGVmaW5pdGlvbiB0aGF0IGFsdGVycyBkYXRhIG9uIHRoZSBzZXJ2ZXIgb3Igd2lsbCBwb3NzaWJseSBpbnZhbGlkYXRlIHRoZSBjYWNoZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgdGl0bGU9XCJFeGFtcGxlIG9mIGFsbCBtdXRhdGlvbiBlbmRwb2ludCBvcHRpb25zXCJcbiAgICogY29uc3QgYXBpID0gY3JlYXRlQXBpKHtcbiAgICogICBiYXNlUXVlcnksXG4gICAqICAgZW5kcG9pbnRzOiAoYnVpbGQpID0+ICh7XG4gICAqICAgICB1cGRhdGVQb3N0OiBidWlsZC5tdXRhdGlvbih7XG4gICAqICAgICAgIHF1ZXJ5OiAoeyBpZCwgLi4ucGF0Y2ggfSkgPT4gKHsgdXJsOiBgcG9zdC8ke2lkfWAsIG1ldGhvZDogJ1BBVENIJywgYm9keTogcGF0Y2ggfSksXG4gICAqICAgICAgIC8vIFBpY2sgb3V0IGRhdGEgYW5kIHByZXZlbnQgbmVzdGVkIHByb3BlcnRpZXMgaW4gYSBob29rIG9yIHNlbGVjdG9yXG4gICAqICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlOiAocmVzcG9uc2UpID0+IHJlc3BvbnNlLmRhdGEsXG4gICAqICAgICAgIC8vIFBpY2sgb3V0IGVycm9yIGFuZCBwcmV2ZW50IG5lc3RlZCBwcm9wZXJ0aWVzIGluIGEgaG9vayBvciBzZWxlY3RvclxuICAgKiAgICAgICB0cmFuc2Zvcm1FcnJvclJlc3BvbnNlOiAocmVzcG9uc2UpID0+IHJlc3BvbnNlLmVycm9yLFxuICAgKiAgICAgICAvLyBgcmVzdWx0YCBpcyB0aGUgc2VydmVyIHJlc3BvbnNlXG4gICAqICAgICAgIGludmFsaWRhdGVzVGFnczogKHJlc3VsdCwgZXJyb3IsIGlkKSA9PiBbeyB0eXBlOiAnUG9zdCcsIGlkIH1dLFxuICAgKiAgICAgIC8vIHRyaWdnZXIgc2lkZSBlZmZlY3RzIG9yIG9wdGltaXN0aWMgdXBkYXRlc1xuICAgKiAgICAgIG9uUXVlcnlTdGFydGVkKGlkLCB7IGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmEsIHJlcXVlc3RJZCwgcXVlcnlGdWxmaWxsZWQsIGdldENhY2hlRW50cnkgfSkge30sXG4gICAqICAgICAgLy8gaGFuZGxlIHN1YnNjcmlwdGlvbnMgZXRjXG4gICAqICAgICAgb25DYWNoZUVudHJ5QWRkZWQoaWQsIHsgZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYSwgcmVxdWVzdElkLCBjYWNoZUVudHJ5UmVtb3ZlZCwgY2FjaGVEYXRhTG9hZGVkLCBnZXRDYWNoZUVudHJ5IH0pIHt9LFxuICAgKiAgICAgfSksXG4gICAqICAgfSksXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIG11dGF0aW9uPFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBSYXdSZXN1bHRUeXBlIGV4dGVuZHMgQmFzZVF1ZXJ5UmVzdWx0PEJhc2VRdWVyeT4gPSBCYXNlUXVlcnlSZXN1bHQ8QmFzZVF1ZXJ5Pj4oZGVmaW5pdGlvbjogT21pdEZyb21VbmlvbjxNdXRhdGlvbkRlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSwgVGFnVHlwZXMsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoLCBSYXdSZXN1bHRUeXBlPiwgJ3R5cGUnPik6IE11dGF0aW9uRGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBUYWdUeXBlcywgUmVzdWx0VHlwZSwgUmVkdWNlclBhdGgsIFJhd1Jlc3VsdFR5cGU+O1xuICBpbmZpbml0ZVF1ZXJ5PFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBQYWdlUGFyYW0sIFJhd1Jlc3VsdFR5cGUgZXh0ZW5kcyBCYXNlUXVlcnlSZXN1bHQ8QmFzZVF1ZXJ5PiA9IEJhc2VRdWVyeVJlc3VsdDxCYXNlUXVlcnk+PihkZWZpbml0aW9uOiBPbWl0RnJvbVVuaW9uPEluZmluaXRlUXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBQYWdlUGFyYW0sIEJhc2VRdWVyeSwgVGFnVHlwZXMsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoLCBSYXdSZXN1bHRUeXBlPiwgJ3R5cGUnPik6IEluZmluaXRlUXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBQYWdlUGFyYW0sIEJhc2VRdWVyeSwgVGFnVHlwZXMsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoLCBSYXdSZXN1bHRUeXBlPjtcbn07XG5leHBvcnQgdHlwZSBBc3NlcnRUYWdUeXBlcyA9IDxUIGV4dGVuZHMgRnVsbFRhZ0Rlc2NyaXB0aW9uPHN0cmluZz4+KHQ6IFQpID0+IFQ7XG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUHJvdmlkZWRCeTxSZXN1bHRUeXBlLCBRdWVyeUFyZywgRXJyb3JUeXBlLCBNZXRhVHlwZT4oZGVzY3JpcHRpb246IFJlc3VsdERlc2NyaXB0aW9uPHN0cmluZywgUmVzdWx0VHlwZSwgUXVlcnlBcmcsIEVycm9yVHlwZSwgTWV0YVR5cGU+IHwgdW5kZWZpbmVkLCByZXN1bHQ6IFJlc3VsdFR5cGUgfCB1bmRlZmluZWQsIGVycm9yOiBFcnJvclR5cGUgfCB1bmRlZmluZWQsIHF1ZXJ5QXJnOiBRdWVyeUFyZywgbWV0YTogTWV0YVR5cGUgfCB1bmRlZmluZWQsIGFzc2VydFRhZ1R5cGVzOiBBc3NlcnRUYWdUeXBlcyk6IHJlYWRvbmx5IEZ1bGxUYWdEZXNjcmlwdGlvbjxzdHJpbmc+W10ge1xuICBpZiAoaXNGdW5jdGlvbihkZXNjcmlwdGlvbikpIHtcbiAgICByZXR1cm4gZGVzY3JpcHRpb24ocmVzdWx0IGFzIFJlc3VsdFR5cGUsIGVycm9yIGFzIHVuZGVmaW5lZCwgcXVlcnlBcmcsIG1ldGEgYXMgTWV0YVR5cGUpLmZpbHRlcihpc05vdE51bGxpc2gpLm1hcChleHBhbmRUYWdEZXNjcmlwdGlvbikubWFwKGFzc2VydFRhZ1R5cGVzKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkZXNjcmlwdGlvbikpIHtcbiAgICByZXR1cm4gZGVzY3JpcHRpb24ubWFwKGV4cGFuZFRhZ0Rlc2NyaXB0aW9uKS5tYXAoYXNzZXJ0VGFnVHlwZXMpO1xuICB9XG4gIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb248VD4odDogVCk6IHQgaXMgRXh0cmFjdDxULCBGdW5jdGlvbj4ge1xuICByZXR1cm4gdHlwZW9mIHQgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kVGFnRGVzY3JpcHRpb24oZGVzY3JpcHRpb246IFRhZ0Rlc2NyaXB0aW9uPHN0cmluZz4pOiBGdWxsVGFnRGVzY3JpcHRpb248c3RyaW5nPiB7XG4gIHJldHVybiB0eXBlb2YgZGVzY3JpcHRpb24gPT09ICdzdHJpbmcnID8ge1xuICAgIHR5cGU6IGRlc2NyaXB0aW9uXG4gIH0gOiBkZXNjcmlwdGlvbjtcbn1cbmV4cG9ydCB0eXBlIFF1ZXJ5QXJnRnJvbTxEIGV4dGVuZHMgQmFzZUVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+PiA9IEQgZXh0ZW5kcyBCYXNlRW5kcG9pbnREZWZpbml0aW9uPGluZmVyIFFBLCBhbnksIGFueSwgYW55PiA/IFFBIDogbmV2ZXI7XG5cbi8vIEp1c3QgZXh0cmFjdGluZyBgUXVlcnlBcmdgIGZyb20gYEJhc2VFbmRwb2ludERlZmluaXRpb25gXG4vLyBkb2Vzbid0IHN1ZmZpY2llbnRseSBtYXRjaCBoZXJlLlxuLy8gV2UgbmVlZCB0byBleHBsaWNpdGx5IG1hdGNoIGFnYWluc3QgYEluZmluaXRlUXVlcnlEZWZpbml0aW9uYFxuZXhwb3J0IHR5cGUgSW5maW5pdGVRdWVyeUFyZ0Zyb208RCBleHRlbmRzIEJhc2VFbmRwb2ludERlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55Pj4gPSBEIGV4dGVuZHMgSW5maW5pdGVRdWVyeURlZmluaXRpb248aW5mZXIgUUEsIGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+ID8gUUEgOiBuZXZlcjtcbmV4cG9ydCB0eXBlIFF1ZXJ5QXJnRnJvbUFueVF1ZXJ5PEQgZXh0ZW5kcyBCYXNlRW5kcG9pbnREZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4+ID0gRCBleHRlbmRzIEluZmluaXRlUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueT4gPyBJbmZpbml0ZVF1ZXJ5QXJnRnJvbTxEPiA6IEQgZXh0ZW5kcyBRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueT4gPyBRdWVyeUFyZ0Zyb208RD4gOiBuZXZlcjtcbmV4cG9ydCB0eXBlIFJlc3VsdFR5cGVGcm9tPEQgZXh0ZW5kcyBCYXNlRW5kcG9pbnREZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4+ID0gRCBleHRlbmRzIEJhc2VFbmRwb2ludERlZmluaXRpb248YW55LCBhbnksIGluZmVyIFJULCBhbnk+ID8gUlQgOiB1bmtub3duO1xuZXhwb3J0IHR5cGUgUmVkdWNlclBhdGhGcm9tPEQgZXh0ZW5kcyBFbmRwb2ludERlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55Pj4gPSBEIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgaW5mZXIgUlAsIGFueSwgYW55PiA/IFJQIDogdW5rbm93bjtcbmV4cG9ydCB0eXBlIFRhZ1R5cGVzRnJvbTxEIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueT4+ID0gRCBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgaW5mZXIgVFQsIGFueSwgYW55LCBhbnksIGFueT4gPyBUVCA6IHVua25vd247XG5leHBvcnQgdHlwZSBQYWdlUGFyYW1Gcm9tPEQgZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+PiA9IEQgZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGluZmVyIFBQLCBhbnksIGFueSwgYW55LCBhbnksIGFueT4gPyBQUCA6IHVua25vd247XG5leHBvcnQgdHlwZSBJbmZpbml0ZVF1ZXJ5Q29tYmluZWRBcmc8UXVlcnlBcmcsIFBhZ2VQYXJhbT4gPSB7XG4gIHF1ZXJ5QXJnOiBRdWVyeUFyZztcbiAgcGFnZVBhcmFtOiBQYWdlUGFyYW07XG59O1xuZXhwb3J0IHR5cGUgVGFnVHlwZXNGcm9tQXBpPFQ+ID0gVCBleHRlbmRzIEFwaTxhbnksIGFueSwgYW55LCBpbmZlciBUYWdUeXBlcz4gPyBUYWdUeXBlcyA6IG5ldmVyO1xuZXhwb3J0IHR5cGUgRGVmaW5pdGlvbnNGcm9tQXBpPFQ+ID0gVCBleHRlbmRzIEFwaTxhbnksIGluZmVyIERlZmluaXRpb25zLCBhbnksIGFueT4gPyBEZWZpbml0aW9ucyA6IG5ldmVyO1xuZXhwb3J0IHR5cGUgVHJhbnNmb3JtZWRSZXNwb25zZTxOZXdEZWZpbml0aW9ucyBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbnMsIEssIFJlc3VsdFR5cGU+ID0gSyBleHRlbmRzIGtleW9mIE5ld0RlZmluaXRpb25zID8gTmV3RGVmaW5pdGlvbnNbS11bJ3RyYW5zZm9ybVJlc3BvbnNlJ10gZXh0ZW5kcyB1bmRlZmluZWQgPyBSZXN1bHRUeXBlIDogVW53cmFwUHJvbWlzZTxSZXR1cm5UeXBlPE5vblVuZGVmaW5lZDxOZXdEZWZpbml0aW9uc1tLXVsndHJhbnNmb3JtUmVzcG9uc2UnXT4+PiA6IFJlc3VsdFR5cGU7XG5leHBvcnQgdHlwZSBPdmVycmlkZVJlc3VsdFR5cGU8RGVmaW5pdGlvbiwgTmV3UmVzdWx0VHlwZT4gPSBEZWZpbml0aW9uIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGluZmVyIFF1ZXJ5QXJnLCBpbmZlciBCYXNlUXVlcnksIGluZmVyIFRhZ1R5cGVzLCBhbnksIGluZmVyIFJlZHVjZXJQYXRoPiA/IFF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBUYWdUeXBlcywgTmV3UmVzdWx0VHlwZSwgUmVkdWNlclBhdGg+IDogRGVmaW5pdGlvbiBleHRlbmRzIE11dGF0aW9uRGVmaW5pdGlvbjxpbmZlciBRdWVyeUFyZywgaW5mZXIgQmFzZVF1ZXJ5LCBpbmZlciBUYWdUeXBlcywgYW55LCBpbmZlciBSZWR1Y2VyUGF0aD4gPyBNdXRhdGlvbkRlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSwgVGFnVHlwZXMsIE5ld1Jlc3VsdFR5cGUsIFJlZHVjZXJQYXRoPiA6IERlZmluaXRpb24gZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxpbmZlciBRdWVyeUFyZywgaW5mZXIgUGFnZVBhcmFtLCBpbmZlciBCYXNlUXVlcnksIGluZmVyIFRhZ1R5cGVzLCBhbnksIGluZmVyIFJlZHVjZXJQYXRoPiA/IEluZmluaXRlUXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBQYWdlUGFyYW0sIEJhc2VRdWVyeSwgVGFnVHlwZXMsIE5ld1Jlc3VsdFR5cGUsIFJlZHVjZXJQYXRoPiA6IG5ldmVyO1xuZXhwb3J0IHR5cGUgVXBkYXRlRGVmaW5pdGlvbnM8RGVmaW5pdGlvbnMgZXh0ZW5kcyBFbmRwb2ludERlZmluaXRpb25zLCBOZXdUYWdUeXBlcyBleHRlbmRzIHN0cmluZywgTmV3RGVmaW5pdGlvbnMgZXh0ZW5kcyBFbmRwb2ludERlZmluaXRpb25zPiA9IHsgW0sgaW4ga2V5b2YgRGVmaW5pdGlvbnNdOiBEZWZpbml0aW9uc1tLXSBleHRlbmRzIFF1ZXJ5RGVmaW5pdGlvbjxpbmZlciBRdWVyeUFyZywgaW5mZXIgQmFzZVF1ZXJ5LCBhbnksIGluZmVyIFJlc3VsdFR5cGUsIGluZmVyIFJlZHVjZXJQYXRoPiA/IFF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBOZXdUYWdUeXBlcywgVHJhbnNmb3JtZWRSZXNwb25zZTxOZXdEZWZpbml0aW9ucywgSywgUmVzdWx0VHlwZT4sIFJlZHVjZXJQYXRoPiA6IERlZmluaXRpb25zW0tdIGV4dGVuZHMgTXV0YXRpb25EZWZpbml0aW9uPGluZmVyIFF1ZXJ5QXJnLCBpbmZlciBCYXNlUXVlcnksIGFueSwgaW5mZXIgUmVzdWx0VHlwZSwgaW5mZXIgUmVkdWNlclBhdGg+ID8gTXV0YXRpb25EZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIE5ld1RhZ1R5cGVzLCBUcmFuc2Zvcm1lZFJlc3BvbnNlPE5ld0RlZmluaXRpb25zLCBLLCBSZXN1bHRUeXBlPiwgUmVkdWNlclBhdGg+IDogRGVmaW5pdGlvbnNbS10gZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxpbmZlciBRdWVyeUFyZywgaW5mZXIgUGFnZVBhcmFtLCBpbmZlciBCYXNlUXVlcnksIGFueSwgaW5mZXIgUmVzdWx0VHlwZSwgaW5mZXIgUmVkdWNlclBhdGg+ID8gSW5maW5pdGVRdWVyeURlZmluaXRpb248UXVlcnlBcmcsIFBhZ2VQYXJhbSwgQmFzZVF1ZXJ5LCBOZXdUYWdUeXBlcywgVHJhbnNmb3JtZWRSZXNwb25zZTxOZXdEZWZpbml0aW9ucywgSywgUmVzdWx0VHlwZT4sIFJlZHVjZXJQYXRoPiA6IG5ldmVyIH07IiwiaW1wb3J0IHR5cGUgeyBBc3luY1RodW5rLCBBc3luY1RodW5rUGF5bG9hZENyZWF0b3IsIERyYWZ0LCBUaHVua0FjdGlvbiwgVGh1bmtEaXNwYXRjaCwgVW5rbm93bkFjdGlvbiB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IHR5cGUgeyBQYXRjaCB9IGZyb20gJ2ltbWVyJztcbmltcG9ydCB7IGlzRHJhZnRhYmxlLCBwcm9kdWNlV2l0aFBhdGNoZXMgfSBmcm9tICdpbW1lcic7XG5pbXBvcnQgdHlwZSB7IEFwaSwgQXBpQ29udGV4dCB9IGZyb20gJy4uL2FwaVR5cGVzJztcbmltcG9ydCB0eXBlIHsgQmFzZVF1ZXJ5RXJyb3IsIEJhc2VRdWVyeUZuLCBRdWVyeVJldHVyblZhbHVlIH0gZnJvbSAnLi4vYmFzZVF1ZXJ5VHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBJbnRlcm5hbFNlcmlhbGl6ZVF1ZXJ5QXJncyB9IGZyb20gJy4uL2RlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MnO1xuaW1wb3J0IHR5cGUgeyBBc3NlcnRUYWdUeXBlcywgRW5kcG9pbnREZWZpbml0aW9uLCBFbmRwb2ludERlZmluaXRpb25zLCBJbmZpbml0ZVF1ZXJ5QXJnRnJvbSwgSW5maW5pdGVRdWVyeUNvbWJpbmVkQXJnLCBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbiwgTXV0YXRpb25EZWZpbml0aW9uLCBQYWdlUGFyYW1Gcm9tLCBRdWVyeUFyZ0Zyb20sIFF1ZXJ5RGVmaW5pdGlvbiwgUmVzdWx0RGVzY3JpcHRpb24sIFJlc3VsdFR5cGVGcm9tLCBTY2hlbWFGYWlsdXJlQ29udmVydGVyLCBTY2hlbWFGYWlsdXJlSGFuZGxlciwgU2NoZW1hRmFpbHVyZUluZm8gfSBmcm9tICcuLi9lbmRwb2ludERlZmluaXRpb25zJztcbmltcG9ydCB7IGNhbGN1bGF0ZVByb3ZpZGVkQnksIGlzSW5maW5pdGVRdWVyeURlZmluaXRpb24sIGlzUXVlcnlEZWZpbml0aW9uIH0gZnJvbSAnLi4vZW5kcG9pbnREZWZpbml0aW9ucyc7XG5pbXBvcnQgeyBIYW5kbGVkRXJyb3IgfSBmcm9tICcuLi9IYW5kbGVkRXJyb3InO1xuaW1wb3J0IHR5cGUgeyBVbndyYXBQcm9taXNlIH0gZnJvbSAnLi4vdHNIZWxwZXJzJztcbmltcG9ydCB0eXBlIHsgUm9vdFN0YXRlLCBRdWVyeUtleXMsIFF1ZXJ5U3Vic3RhdGVJZGVudGlmaWVyLCBJbmZpbml0ZURhdGEsIEluZmluaXRlUXVlcnlDb25maWdPcHRpb25zLCBRdWVyeUNhY2hlS2V5LCBJbmZpbml0ZVF1ZXJ5RGlyZWN0aW9uLCBJbmZpbml0ZVF1ZXJ5S2V5cyB9IGZyb20gJy4vYXBpU3RhdGUnO1xuaW1wb3J0IHsgUXVlcnlTdGF0dXMgfSBmcm9tICcuL2FwaVN0YXRlJztcbmltcG9ydCB0eXBlIHsgSW5maW5pdGVRdWVyeUFjdGlvbkNyZWF0b3JSZXN1bHQsIFF1ZXJ5QWN0aW9uQ3JlYXRvclJlc3VsdCwgU3RhcnRJbmZpbml0ZVF1ZXJ5QWN0aW9uQ3JlYXRvck9wdGlvbnMsIFN0YXJ0UXVlcnlBY3Rpb25DcmVhdG9yT3B0aW9ucyB9IGZyb20gJy4vYnVpbGRJbml0aWF0ZSc7XG5pbXBvcnQgeyBmb3JjZVF1ZXJ5Rm5TeW1ib2wsIGlzVXBzZXJ0UXVlcnkgfSBmcm9tICcuL2J1aWxkSW5pdGlhdGUnO1xuaW1wb3J0IHR5cGUgeyBBbGxTZWxlY3RvcnMgfSBmcm9tICcuL2J1aWxkU2VsZWN0b3JzJztcbmltcG9ydCB0eXBlIHsgQXBpRW5kcG9pbnRRdWVyeSwgUHJlZmV0Y2hPcHRpb25zIH0gZnJvbSAnLi9tb2R1bGUnO1xuaW1wb3J0IHsgY3JlYXRlQXN5bmNUaHVuaywgaXNBbGxPZiwgaXNGdWxmaWxsZWQsIGlzUGVuZGluZywgaXNSZWplY3RlZCwgaXNSZWplY3RlZFdpdGhWYWx1ZSwgU0hPVUxEX0FVVE9CQVRDSCB9IGZyb20gJy4vcnRrSW1wb3J0cyc7XG5pbXBvcnQgeyBwYXJzZVdpdGhTY2hlbWEsIE5hbWVkU2NoZW1hRXJyb3IgfSBmcm9tICcuLi9zdGFuZGFyZFNjaGVtYSc7XG5leHBvcnQgdHlwZSBCdWlsZFRodW5rc0FwaUVuZHBvaW50UXVlcnk8RGVmaW5pdGlvbiBleHRlbmRzIFF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4+ID0gTWF0Y2hlcnM8UXVlcnlUaHVuaywgRGVmaW5pdGlvbj47XG5leHBvcnQgdHlwZSBCdWlsZFRodW5rc0FwaUVuZHBvaW50SW5maW5pdGVRdWVyeTxEZWZpbml0aW9uIGV4dGVuZHMgSW5maW5pdGVRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnk+PiA9IE1hdGNoZXJzPEluZmluaXRlUXVlcnlUaHVuazxhbnk+LCBEZWZpbml0aW9uPjtcbmV4cG9ydCB0eXBlIEJ1aWxkVGh1bmtzQXBpRW5kcG9pbnRNdXRhdGlvbjxEZWZpbml0aW9uIGV4dGVuZHMgTXV0YXRpb25EZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55Pj4gPSBNYXRjaGVyczxNdXRhdGlvblRodW5rLCBEZWZpbml0aW9uPjtcbnR5cGUgRW5kcG9pbnRUaHVuazxUaHVuayBleHRlbmRzIFF1ZXJ5VGh1bmsgfCBNdXRhdGlvblRodW5rIHwgSW5maW5pdGVRdWVyeVRodW5rPGFueT4sIERlZmluaXRpb24gZXh0ZW5kcyBFbmRwb2ludERlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55Pj4gPSBEZWZpbml0aW9uIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9uPGluZmVyIFF1ZXJ5QXJnLCBpbmZlciBCYXNlUXVlcnlGbiwgYW55LCBpbmZlciBSZXN1bHRUeXBlPiA/IFRodW5rIGV4dGVuZHMgQXN5bmNUaHVuazx1bmtub3duLCBpbmZlciBBVEFyZywgaW5mZXIgQVRDb25maWc+ID8gQXN5bmNUaHVuazxSZXN1bHRUeXBlLCBBVEFyZyAmIHtcbiAgb3JpZ2luYWxBcmdzOiBRdWVyeUFyZztcbn0sIEFUQ29uZmlnICYge1xuICByZWplY3RWYWx1ZTogQmFzZVF1ZXJ5RXJyb3I8QmFzZVF1ZXJ5Rm4+O1xufT4gOiBuZXZlciA6IERlZmluaXRpb24gZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxpbmZlciBRdWVyeUFyZywgaW5mZXIgUGFnZVBhcmFtLCBpbmZlciBCYXNlUXVlcnlGbiwgYW55LCBpbmZlciBSZXN1bHRUeXBlPiA/IFRodW5rIGV4dGVuZHMgQXN5bmNUaHVuazx1bmtub3duLCBpbmZlciBBVEFyZywgaW5mZXIgQVRDb25maWc+ID8gQXN5bmNUaHVuazxJbmZpbml0ZURhdGE8UmVzdWx0VHlwZSwgUGFnZVBhcmFtPiwgQVRBcmcgJiB7XG4gIG9yaWdpbmFsQXJnczogUXVlcnlBcmc7XG59LCBBVENvbmZpZyAmIHtcbiAgcmVqZWN0VmFsdWU6IEJhc2VRdWVyeUVycm9yPEJhc2VRdWVyeUZuPjtcbn0+IDogbmV2ZXIgOiBuZXZlcjtcbmV4cG9ydCB0eXBlIFBlbmRpbmdBY3Rpb248VGh1bmsgZXh0ZW5kcyBRdWVyeVRodW5rIHwgTXV0YXRpb25UaHVuayB8IEluZmluaXRlUXVlcnlUaHVuazxhbnk+LCBEZWZpbml0aW9uIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4+ID0gUmV0dXJuVHlwZTxFbmRwb2ludFRodW5rPFRodW5rLCBEZWZpbml0aW9uPlsncGVuZGluZyddPjtcbmV4cG9ydCB0eXBlIEZ1bGZpbGxlZEFjdGlvbjxUaHVuayBleHRlbmRzIFF1ZXJ5VGh1bmsgfCBNdXRhdGlvblRodW5rIHwgSW5maW5pdGVRdWVyeVRodW5rPGFueT4sIERlZmluaXRpb24gZXh0ZW5kcyBFbmRwb2ludERlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55Pj4gPSBSZXR1cm5UeXBlPEVuZHBvaW50VGh1bms8VGh1bmssIERlZmluaXRpb24+WydmdWxmaWxsZWQnXT47XG5leHBvcnQgdHlwZSBSZWplY3RlZEFjdGlvbjxUaHVuayBleHRlbmRzIFF1ZXJ5VGh1bmsgfCBNdXRhdGlvblRodW5rIHwgSW5maW5pdGVRdWVyeVRodW5rPGFueT4sIERlZmluaXRpb24gZXh0ZW5kcyBFbmRwb2ludERlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55Pj4gPSBSZXR1cm5UeXBlPEVuZHBvaW50VGh1bms8VGh1bmssIERlZmluaXRpb24+WydyZWplY3RlZCddPjtcbmV4cG9ydCB0eXBlIE1hdGNoZXI8TT4gPSAodmFsdWU6IGFueSkgPT4gdmFsdWUgaXMgTTtcbmV4cG9ydCBpbnRlcmZhY2UgTWF0Y2hlcnM8VGh1bmsgZXh0ZW5kcyBRdWVyeVRodW5rIHwgTXV0YXRpb25UaHVuayB8IEluZmluaXRlUXVlcnlUaHVuazxhbnk+LCBEZWZpbml0aW9uIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4+IHtcbiAgbWF0Y2hQZW5kaW5nOiBNYXRjaGVyPFBlbmRpbmdBY3Rpb248VGh1bmssIERlZmluaXRpb24+PjtcbiAgbWF0Y2hGdWxmaWxsZWQ6IE1hdGNoZXI8RnVsZmlsbGVkQWN0aW9uPFRodW5rLCBEZWZpbml0aW9uPj47XG4gIG1hdGNoUmVqZWN0ZWQ6IE1hdGNoZXI8UmVqZWN0ZWRBY3Rpb248VGh1bmssIERlZmluaXRpb24+Pjtcbn1cbmV4cG9ydCB0eXBlIFF1ZXJ5VGh1bmtBcmcgPSBRdWVyeVN1YnN0YXRlSWRlbnRpZmllciAmIFN0YXJ0UXVlcnlBY3Rpb25DcmVhdG9yT3B0aW9ucyAmIHtcbiAgdHlwZTogJ3F1ZXJ5JztcbiAgb3JpZ2luYWxBcmdzOiB1bmtub3duO1xuICBlbmRwb2ludE5hbWU6IHN0cmluZztcbn07XG5leHBvcnQgdHlwZSBJbmZpbml0ZVF1ZXJ5VGh1bmtBcmc8RCBleHRlbmRzIEluZmluaXRlUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55Pj4gPSBRdWVyeVN1YnN0YXRlSWRlbnRpZmllciAmIFN0YXJ0SW5maW5pdGVRdWVyeUFjdGlvbkNyZWF0b3JPcHRpb25zPEQ+ICYge1xuICB0eXBlOiBgcXVlcnlgO1xuICBvcmlnaW5hbEFyZ3M6IHVua25vd247XG4gIGVuZHBvaW50TmFtZTogc3RyaW5nO1xuICBwYXJhbTogdW5rbm93bjtcbiAgZGlyZWN0aW9uPzogSW5maW5pdGVRdWVyeURpcmVjdGlvbjtcbn07XG50eXBlIE11dGF0aW9uVGh1bmtBcmcgPSB7XG4gIHR5cGU6ICdtdXRhdGlvbic7XG4gIG9yaWdpbmFsQXJnczogdW5rbm93bjtcbiAgZW5kcG9pbnROYW1lOiBzdHJpbmc7XG4gIHRyYWNrPzogYm9vbGVhbjtcbiAgZml4ZWRDYWNoZUtleT86IHN0cmluZztcbn07XG5leHBvcnQgdHlwZSBUaHVua1Jlc3VsdCA9IHVua25vd247XG5leHBvcnQgdHlwZSBUaHVua0FwaU1ldGFDb25maWcgPSB7XG4gIHBlbmRpbmdNZXRhOiB7XG4gICAgc3RhcnRlZFRpbWVTdGFtcDogbnVtYmVyO1xuICAgIFtTSE9VTERfQVVUT0JBVENIXTogdHJ1ZTtcbiAgfTtcbiAgZnVsZmlsbGVkTWV0YToge1xuICAgIGZ1bGZpbGxlZFRpbWVTdGFtcDogbnVtYmVyO1xuICAgIGJhc2VRdWVyeU1ldGE6IHVua25vd247XG4gICAgW1NIT1VMRF9BVVRPQkFUQ0hdOiB0cnVlO1xuICB9O1xuICByZWplY3RlZE1ldGE6IHtcbiAgICBiYXNlUXVlcnlNZXRhOiB1bmtub3duO1xuICAgIFtTSE9VTERfQVVUT0JBVENIXTogdHJ1ZTtcbiAgfTtcbn07XG5leHBvcnQgdHlwZSBRdWVyeVRodW5rID0gQXN5bmNUaHVuazxUaHVua1Jlc3VsdCwgUXVlcnlUaHVua0FyZywgVGh1bmtBcGlNZXRhQ29uZmlnPjtcbmV4cG9ydCB0eXBlIEluZmluaXRlUXVlcnlUaHVuazxEIGV4dGVuZHMgSW5maW5pdGVRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnk+PiA9IEFzeW5jVGh1bms8VGh1bmtSZXN1bHQsIEluZmluaXRlUXVlcnlUaHVua0FyZzxEPiwgVGh1bmtBcGlNZXRhQ29uZmlnPjtcbmV4cG9ydCB0eXBlIE11dGF0aW9uVGh1bmsgPSBBc3luY1RodW5rPFRodW5rUmVzdWx0LCBNdXRhdGlvblRodW5rQXJnLCBUaHVua0FwaU1ldGFDb25maWc+O1xuZnVuY3Rpb24gZGVmYXVsdFRyYW5zZm9ybVJlc3BvbnNlKGJhc2VRdWVyeVJldHVyblZhbHVlOiB1bmtub3duKSB7XG4gIHJldHVybiBiYXNlUXVlcnlSZXR1cm5WYWx1ZTtcbn1cbmV4cG9ydCB0eXBlIE1heWJlRHJhZnRlZDxUPiA9IFQgfCBEcmFmdDxUPjtcbmV4cG9ydCB0eXBlIFJlY2lwZTxUPiA9IChkYXRhOiBNYXliZURyYWZ0ZWQ8VD4pID0+IHZvaWQgfCBNYXliZURyYWZ0ZWQ8VD47XG5leHBvcnQgdHlwZSBVcHNlcnRSZWNpcGU8VD4gPSAoZGF0YTogTWF5YmVEcmFmdGVkPFQ+IHwgdW5kZWZpbmVkKSA9PiB2b2lkIHwgTWF5YmVEcmFmdGVkPFQ+O1xuZXhwb3J0IHR5cGUgUGF0Y2hRdWVyeURhdGFUaHVuazxEZWZpbml0aW9ucyBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbnMsIFBhcnRpYWxTdGF0ZT4gPSA8RW5kcG9pbnROYW1lIGV4dGVuZHMgUXVlcnlLZXlzPERlZmluaXRpb25zPj4oZW5kcG9pbnROYW1lOiBFbmRwb2ludE5hbWUsIGFyZzogUXVlcnlBcmdGcm9tPERlZmluaXRpb25zW0VuZHBvaW50TmFtZV0+LCBwYXRjaGVzOiByZWFkb25seSBQYXRjaFtdLCB1cGRhdGVQcm92aWRlZD86IGJvb2xlYW4pID0+IFRodW5rQWN0aW9uPHZvaWQsIFBhcnRpYWxTdGF0ZSwgYW55LCBVbmtub3duQWN0aW9uPjtcbmV4cG9ydCB0eXBlIEFsbFF1ZXJ5S2V5czxEZWZpbml0aW9ucyBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbnM+ID0gUXVlcnlLZXlzPERlZmluaXRpb25zPiB8IEluZmluaXRlUXVlcnlLZXlzPERlZmluaXRpb25zPjtcbmV4cG9ydCB0eXBlIFF1ZXJ5QXJnRnJvbUFueVF1ZXJ5RGVmaW5pdGlvbjxEZWZpbml0aW9ucyBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbnMsIEVuZHBvaW50TmFtZSBleHRlbmRzIEFsbFF1ZXJ5S2V5czxEZWZpbml0aW9ucz4+ID0gRGVmaW5pdGlvbnNbRW5kcG9pbnROYW1lXSBleHRlbmRzIEluZmluaXRlUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55PiA/IEluZmluaXRlUXVlcnlBcmdGcm9tPERlZmluaXRpb25zW0VuZHBvaW50TmFtZV0+IDogRGVmaW5pdGlvbnNbRW5kcG9pbnROYW1lXSBleHRlbmRzIFF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+ID8gUXVlcnlBcmdGcm9tPERlZmluaXRpb25zW0VuZHBvaW50TmFtZV0+IDogbmV2ZXI7XG5leHBvcnQgdHlwZSBEYXRhRnJvbUFueVF1ZXJ5RGVmaW5pdGlvbjxEZWZpbml0aW9ucyBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbnMsIEVuZHBvaW50TmFtZSBleHRlbmRzIEFsbFF1ZXJ5S2V5czxEZWZpbml0aW9ucz4+ID0gRGVmaW5pdGlvbnNbRW5kcG9pbnROYW1lXSBleHRlbmRzIEluZmluaXRlUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55PiA/IEluZmluaXRlRGF0YTxSZXN1bHRUeXBlRnJvbTxEZWZpbml0aW9uc1tFbmRwb2ludE5hbWVdPiwgUGFnZVBhcmFtRnJvbTxEZWZpbml0aW9uc1tFbmRwb2ludE5hbWVdPj4gOiBEZWZpbml0aW9uc1tFbmRwb2ludE5hbWVdIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4gPyBSZXN1bHRUeXBlRnJvbTxEZWZpbml0aW9uc1tFbmRwb2ludE5hbWVdPiA6IHVua25vd247XG5leHBvcnQgdHlwZSBVcHNlcnRUaHVua1Jlc3VsdDxEZWZpbml0aW9ucyBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbnMsIEVuZHBvaW50TmFtZSBleHRlbmRzIEFsbFF1ZXJ5S2V5czxEZWZpbml0aW9ucz4+ID0gRGVmaW5pdGlvbnNbRW5kcG9pbnROYW1lXSBleHRlbmRzIEluZmluaXRlUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55PiA/IEluZmluaXRlUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0PERlZmluaXRpb25zW0VuZHBvaW50TmFtZV0+IDogRGVmaW5pdGlvbnNbRW5kcG9pbnROYW1lXSBleHRlbmRzIFF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+ID8gUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0PERlZmluaXRpb25zW0VuZHBvaW50TmFtZV0+IDogUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0PG5ldmVyPjtcbmV4cG9ydCB0eXBlIFVwZGF0ZVF1ZXJ5RGF0YVRodW5rPERlZmluaXRpb25zIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9ucywgUGFydGlhbFN0YXRlPiA9IDxFbmRwb2ludE5hbWUgZXh0ZW5kcyBBbGxRdWVyeUtleXM8RGVmaW5pdGlvbnM+PihlbmRwb2ludE5hbWU6IEVuZHBvaW50TmFtZSwgYXJnOiBRdWVyeUFyZ0Zyb21BbnlRdWVyeURlZmluaXRpb248RGVmaW5pdGlvbnMsIEVuZHBvaW50TmFtZT4sIHVwZGF0ZVJlY2lwZTogUmVjaXBlPERhdGFGcm9tQW55UXVlcnlEZWZpbml0aW9uPERlZmluaXRpb25zLCBFbmRwb2ludE5hbWU+PiwgdXBkYXRlUHJvdmlkZWQ/OiBib29sZWFuKSA9PiBUaHVua0FjdGlvbjxQYXRjaENvbGxlY3Rpb24sIFBhcnRpYWxTdGF0ZSwgYW55LCBVbmtub3duQWN0aW9uPjtcbmV4cG9ydCB0eXBlIFVwc2VydFF1ZXJ5RGF0YVRodW5rPERlZmluaXRpb25zIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9ucywgUGFydGlhbFN0YXRlPiA9IDxFbmRwb2ludE5hbWUgZXh0ZW5kcyBBbGxRdWVyeUtleXM8RGVmaW5pdGlvbnM+PihlbmRwb2ludE5hbWU6IEVuZHBvaW50TmFtZSwgYXJnOiBRdWVyeUFyZ0Zyb21BbnlRdWVyeURlZmluaXRpb248RGVmaW5pdGlvbnMsIEVuZHBvaW50TmFtZT4sIHZhbHVlOiBEYXRhRnJvbUFueVF1ZXJ5RGVmaW5pdGlvbjxEZWZpbml0aW9ucywgRW5kcG9pbnROYW1lPikgPT4gVGh1bmtBY3Rpb248VXBzZXJ0VGh1bmtSZXN1bHQ8RGVmaW5pdGlvbnMsIEVuZHBvaW50TmFtZT4sIFBhcnRpYWxTdGF0ZSwgYW55LCBVbmtub3duQWN0aW9uPjtcblxuLyoqXG4gKiBBbiBvYmplY3QgcmV0dXJuZWQgZnJvbSBkaXNwYXRjaGluZyBhIGBhcGkudXRpbC51cGRhdGVRdWVyeURhdGFgIGNhbGwuXG4gKi9cbmV4cG9ydCB0eXBlIFBhdGNoQ29sbGVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIEFuIGBpbW1lcmAgUGF0Y2ggZGVzY3JpYmluZyB0aGUgY2FjaGUgdXBkYXRlLlxuICAgKi9cbiAgcGF0Y2hlczogUGF0Y2hbXTtcbiAgLyoqXG4gICAqIEFuIGBpbW1lcmAgUGF0Y2ggdG8gcmV2ZXJ0IHRoZSBjYWNoZSB1cGRhdGUuXG4gICAqL1xuICBpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXTtcbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIHVuZG8gdGhlIGNhY2hlIHVwZGF0ZS5cbiAgICovXG4gIHVuZG86ICgpID0+IHZvaWQ7XG59O1xudHlwZSBUcmFuc2Zvcm1DYWxsYmFjayA9IChiYXNlUXVlcnlSZXR1cm5WYWx1ZTogdW5rbm93biwgbWV0YTogdW5rbm93biwgYXJnOiB1bmtub3duKSA9PiBhbnk7XG5leHBvcnQgY29uc3QgYWRkU2hvdWxkQXV0b0JhdGNoID0gPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LD4oYXJnOiBUID0ge30gYXMgVCk6IFQgJiB7XG4gIFtTSE9VTERfQVVUT0JBVENIXTogdHJ1ZTtcbn0gPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLmFyZyxcbiAgICBbU0hPVUxEX0FVVE9CQVRDSF06IHRydWVcbiAgfTtcbn07XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRUaHVua3M8QmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nLCBEZWZpbml0aW9ucyBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbnM+KHtcbiAgcmVkdWNlclBhdGgsXG4gIGJhc2VRdWVyeSxcbiAgY29udGV4dDoge1xuICAgIGVuZHBvaW50RGVmaW5pdGlvbnNcbiAgfSxcbiAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICBhcGksXG4gIGFzc2VydFRhZ1R5cGUsXG4gIHNlbGVjdG9ycyxcbiAgb25TY2hlbWFGYWlsdXJlLFxuICBjYXRjaFNjaGVtYUZhaWx1cmU6IGdsb2JhbENhdGNoU2NoZW1hRmFpbHVyZSxcbiAgc2tpcFNjaGVtYVZhbGlkYXRpb246IGdsb2JhbFNraXBTY2hlbWFWYWxpZGF0aW9uXG59OiB7XG4gIGJhc2VRdWVyeTogQmFzZVF1ZXJ5O1xuICByZWR1Y2VyUGF0aDogUmVkdWNlclBhdGg7XG4gIGNvbnRleHQ6IEFwaUNvbnRleHQ8RGVmaW5pdGlvbnM+O1xuICBzZXJpYWxpemVRdWVyeUFyZ3M6IEludGVybmFsU2VyaWFsaXplUXVlcnlBcmdzO1xuICBhcGk6IEFwaTxCYXNlUXVlcnksIERlZmluaXRpb25zLCBSZWR1Y2VyUGF0aCwgYW55PjtcbiAgYXNzZXJ0VGFnVHlwZTogQXNzZXJ0VGFnVHlwZXM7XG4gIHNlbGVjdG9yczogQWxsU2VsZWN0b3JzO1xuICBvblNjaGVtYUZhaWx1cmU6IFNjaGVtYUZhaWx1cmVIYW5kbGVyIHwgdW5kZWZpbmVkO1xuICBjYXRjaFNjaGVtYUZhaWx1cmU6IFNjaGVtYUZhaWx1cmVDb252ZXJ0ZXI8QmFzZVF1ZXJ5PiB8IHVuZGVmaW5lZDtcbiAgc2tpcFNjaGVtYVZhbGlkYXRpb246IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG59KSB7XG4gIHR5cGUgU3RhdGUgPSBSb290U3RhdGU8YW55LCBzdHJpbmcsIFJlZHVjZXJQYXRoPjtcbiAgY29uc3QgcGF0Y2hRdWVyeURhdGE6IFBhdGNoUXVlcnlEYXRhVGh1bms8RW5kcG9pbnREZWZpbml0aW9ucywgU3RhdGU+ID0gKGVuZHBvaW50TmFtZSwgYXJnLCBwYXRjaGVzLCB1cGRhdGVQcm92aWRlZCkgPT4gKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXTtcbiAgICBjb25zdCBxdWVyeUNhY2hlS2V5ID0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgIHF1ZXJ5QXJnczogYXJnLFxuICAgICAgZW5kcG9pbnREZWZpbml0aW9uLFxuICAgICAgZW5kcG9pbnROYW1lXG4gICAgfSk7XG4gICAgZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5xdWVyeVJlc3VsdFBhdGNoZWQoe1xuICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgIHBhdGNoZXNcbiAgICB9KSk7XG4gICAgaWYgKCF1cGRhdGVQcm92aWRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdWYWx1ZSA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5zZWxlY3QoYXJnKShcbiAgICAvLyBXb3JrIGFyb3VuZCBUUyA0LjEgbWlzbWF0Y2hcbiAgICBnZXRTdGF0ZSgpIGFzIFJvb3RTdGF0ZTxhbnksIGFueSwgYW55Pik7XG4gICAgY29uc3QgcHJvdmlkZWRUYWdzID0gY2FsY3VsYXRlUHJvdmlkZWRCeShlbmRwb2ludERlZmluaXRpb24ucHJvdmlkZXNUYWdzLCBuZXdWYWx1ZS5kYXRhLCB1bmRlZmluZWQsIGFyZywge30sIGFzc2VydFRhZ1R5cGUpO1xuICAgIGRpc3BhdGNoKGFwaS5pbnRlcm5hbEFjdGlvbnMudXBkYXRlUHJvdmlkZWRCeShbe1xuICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgIHByb3ZpZGVkVGFnc1xuICAgIH1dKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGFkZFRvU3RhcnQ8VD4oaXRlbXM6IEFycmF5PFQ+LCBpdGVtOiBULCBtYXggPSAwKTogQXJyYXk8VD4ge1xuICAgIGNvbnN0IG5ld0l0ZW1zID0gW2l0ZW0sIC4uLml0ZW1zXTtcbiAgICByZXR1cm4gbWF4ICYmIG5ld0l0ZW1zLmxlbmd0aCA+IG1heCA/IG5ld0l0ZW1zLnNsaWNlKDAsIC0xKSA6IG5ld0l0ZW1zO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFRvRW5kPFQ+KGl0ZW1zOiBBcnJheTxUPiwgaXRlbTogVCwgbWF4ID0gMCk6IEFycmF5PFQ+IHtcbiAgICBjb25zdCBuZXdJdGVtcyA9IFsuLi5pdGVtcywgaXRlbV07XG4gICAgcmV0dXJuIG1heCAmJiBuZXdJdGVtcy5sZW5ndGggPiBtYXggPyBuZXdJdGVtcy5zbGljZSgxKSA6IG5ld0l0ZW1zO1xuICB9XG4gIGNvbnN0IHVwZGF0ZVF1ZXJ5RGF0YTogVXBkYXRlUXVlcnlEYXRhVGh1bms8RW5kcG9pbnREZWZpbml0aW9ucywgU3RhdGU+ID0gKGVuZHBvaW50TmFtZSwgYXJnLCB1cGRhdGVSZWNpcGUsIHVwZGF0ZVByb3ZpZGVkID0gdHJ1ZSkgPT4gKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXTtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBlbmRwb2ludERlZmluaXRpb24uc2VsZWN0KGFyZykoXG4gICAgLy8gV29yayBhcm91bmQgVFMgNC4xIG1pc21hdGNoXG4gICAgZ2V0U3RhdGUoKSBhcyBSb290U3RhdGU8YW55LCBhbnksIGFueT4pO1xuICAgIGNvbnN0IHJldDogUGF0Y2hDb2xsZWN0aW9uID0ge1xuICAgICAgcGF0Y2hlczogW10sXG4gICAgICBpbnZlcnNlUGF0Y2hlczogW10sXG4gICAgICB1bmRvOiAoKSA9PiBkaXNwYXRjaChhcGkudXRpbC5wYXRjaFF1ZXJ5RGF0YShlbmRwb2ludE5hbWUsIGFyZywgcmV0LmludmVyc2VQYXRjaGVzLCB1cGRhdGVQcm92aWRlZCkpXG4gICAgfTtcbiAgICBpZiAoY3VycmVudFN0YXRlLnN0YXR1cyA9PT0gUXVlcnlTdGF0dXMudW5pbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgbGV0IG5ld1ZhbHVlO1xuICAgIGlmICgnZGF0YScgaW4gY3VycmVudFN0YXRlKSB7XG4gICAgICBpZiAoaXNEcmFmdGFibGUoY3VycmVudFN0YXRlLmRhdGEpKSB7XG4gICAgICAgIGNvbnN0IFt2YWx1ZSwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdID0gcHJvZHVjZVdpdGhQYXRjaGVzKGN1cnJlbnRTdGF0ZS5kYXRhLCB1cGRhdGVSZWNpcGUpO1xuICAgICAgICByZXQucGF0Y2hlcy5wdXNoKC4uLnBhdGNoZXMpO1xuICAgICAgICByZXQuaW52ZXJzZVBhdGNoZXMucHVzaCguLi5pbnZlcnNlUGF0Y2hlcyk7XG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IHVwZGF0ZVJlY2lwZShjdXJyZW50U3RhdGUuZGF0YSk7XG4gICAgICAgIHJldC5wYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiAncmVwbGFjZScsXG4gICAgICAgICAgcGF0aDogW10sXG4gICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXQuaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6ICdyZXBsYWNlJyxcbiAgICAgICAgICBwYXRoOiBbXSxcbiAgICAgICAgICB2YWx1ZTogY3VycmVudFN0YXRlLmRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXQucGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGRpc3BhdGNoKGFwaS51dGlsLnBhdGNoUXVlcnlEYXRhKGVuZHBvaW50TmFtZSwgYXJnLCByZXQucGF0Y2hlcywgdXBkYXRlUHJvdmlkZWQpKTtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICBjb25zdCB1cHNlcnRRdWVyeURhdGE6IFVwc2VydFF1ZXJ5RGF0YVRodW5rPERlZmluaXRpb25zLCBTdGF0ZT4gPSAoZW5kcG9pbnROYW1lLCBhcmcsIHZhbHVlKSA9PiBkaXNwYXRjaCA9PiB7XG4gICAgdHlwZSBFbmRwb2ludE5hbWUgPSB0eXBlb2YgZW5kcG9pbnROYW1lO1xuICAgIGNvbnN0IHJlcyA9IGRpc3BhdGNoKChhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0gYXMgQXBpRW5kcG9pbnRRdWVyeTxRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnk+LCBEZWZpbml0aW9ucz4pLmluaXRpYXRlKGFyZywge1xuICAgICAgc3Vic2NyaWJlOiBmYWxzZSxcbiAgICAgIGZvcmNlUmVmZXRjaDogdHJ1ZSxcbiAgICAgIFtmb3JjZVF1ZXJ5Rm5TeW1ib2xdOiAoKSA9PiAoe1xuICAgICAgICBkYXRhOiB2YWx1ZVxuICAgICAgfSlcbiAgICB9KSkgYXMgVXBzZXJ0VGh1bmtSZXN1bHQ8RGVmaW5pdGlvbnMsIEVuZHBvaW50TmFtZT47XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgY29uc3QgZ2V0VHJhbnNmb3JtQ2FsbGJhY2tGb3JFbmRwb2ludCA9IChlbmRwb2ludERlZmluaXRpb246IEVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+LCB0cmFuc2Zvcm1GaWVsZE5hbWU6ICd0cmFuc2Zvcm1SZXNwb25zZScgfCAndHJhbnNmb3JtRXJyb3JSZXNwb25zZScpOiBUcmFuc2Zvcm1DYWxsYmFjayA9PiB7XG4gICAgcmV0dXJuIGVuZHBvaW50RGVmaW5pdGlvbi5xdWVyeSAmJiBlbmRwb2ludERlZmluaXRpb25bdHJhbnNmb3JtRmllbGROYW1lXSA/IGVuZHBvaW50RGVmaW5pdGlvblt0cmFuc2Zvcm1GaWVsZE5hbWVdISBhcyBUcmFuc2Zvcm1DYWxsYmFjayA6IGRlZmF1bHRUcmFuc2Zvcm1SZXNwb25zZTtcbiAgfTtcblxuICAvLyBUaGUgZ2VuZXJpYyBhc3luYyBwYXlsb2FkIGZ1bmN0aW9uIGZvciBhbGwgb2Ygb3VyIHRodW5rc1xuICBjb25zdCBleGVjdXRlRW5kcG9pbnQ6IEFzeW5jVGh1bmtQYXlsb2FkQ3JlYXRvcjxUaHVua1Jlc3VsdCwgUXVlcnlUaHVua0FyZyB8IE11dGF0aW9uVGh1bmtBcmcgfCBJbmZpbml0ZVF1ZXJ5VGh1bmtBcmc8YW55PiwgVGh1bmtBcGlNZXRhQ29uZmlnICYge1xuICAgIHN0YXRlOiBSb290U3RhdGU8YW55LCBzdHJpbmcsIFJlZHVjZXJQYXRoPjtcbiAgfT4gPSBhc3luYyAoYXJnLCB7XG4gICAgc2lnbmFsLFxuICAgIGFib3J0LFxuICAgIHJlamVjdFdpdGhWYWx1ZSxcbiAgICBmdWxmaWxsV2l0aFZhbHVlLFxuICAgIGRpc3BhdGNoLFxuICAgIGdldFN0YXRlLFxuICAgIGV4dHJhXG4gIH0pID0+IHtcbiAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBlbmRwb2ludERlZmluaXRpb25zW2FyZy5lbmRwb2ludE5hbWVdO1xuICAgIGNvbnN0IHtcbiAgICAgIG1ldGFTY2hlbWEsXG4gICAgICBza2lwU2NoZW1hVmFsaWRhdGlvbiA9IGdsb2JhbFNraXBTY2hlbWFWYWxpZGF0aW9uXG4gICAgfSA9IGVuZHBvaW50RGVmaW5pdGlvbjtcbiAgICB0cnkge1xuICAgICAgbGV0IHRyYW5zZm9ybVJlc3BvbnNlID0gZ2V0VHJhbnNmb3JtQ2FsbGJhY2tGb3JFbmRwb2ludChlbmRwb2ludERlZmluaXRpb24sICd0cmFuc2Zvcm1SZXNwb25zZScpO1xuICAgICAgY29uc3QgYmFzZVF1ZXJ5QXBpID0ge1xuICAgICAgICBzaWduYWwsXG4gICAgICAgIGFib3J0LFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgIGV4dHJhLFxuICAgICAgICBlbmRwb2ludDogYXJnLmVuZHBvaW50TmFtZSxcbiAgICAgICAgdHlwZTogYXJnLnR5cGUsXG4gICAgICAgIGZvcmNlZDogYXJnLnR5cGUgPT09ICdxdWVyeScgPyBpc0ZvcmNlZFF1ZXJ5KGFyZywgZ2V0U3RhdGUoKSkgOiB1bmRlZmluZWQsXG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXk6IGFyZy50eXBlID09PSAncXVlcnknID8gYXJnLnF1ZXJ5Q2FjaGVLZXkgOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBjb25zdCBmb3JjZVF1ZXJ5Rm4gPSBhcmcudHlwZSA9PT0gJ3F1ZXJ5JyA/IGFyZ1tmb3JjZVF1ZXJ5Rm5TeW1ib2xdIDogdW5kZWZpbmVkO1xuICAgICAgbGV0IGZpbmFsUXVlcnlSZXR1cm5WYWx1ZTogUXVlcnlSZXR1cm5WYWx1ZTtcblxuICAgICAgLy8gSW5maW5pdGUgcXVlcnkgd3JhcHBlciwgd2hpY2ggZXhlY3V0ZXMgdGhlIHJlcXVlc3QgYW5kIHJldHVybnNcbiAgICAgIC8vIHRoZSBJbmZpbml0ZURhdGEgYHtwYWdlcywgcGFnZVBhcmFtc31gIHN0cnVjdHVyZVxuICAgICAgY29uc3QgZmV0Y2hQYWdlID0gYXN5bmMgKGRhdGE6IEluZmluaXRlRGF0YTx1bmtub3duLCB1bmtub3duPiwgcGFyYW06IHVua25vd24sIG1heFBhZ2VzOiBudW1iZXIsIHByZXZpb3VzPzogYm9vbGVhbik6IFByb21pc2U8UXVlcnlSZXR1cm5WYWx1ZT4gPT4ge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBoYW5kbGUgY2FzZXMgd2hlcmUgdGhlcmUgaXMgbm8gYGdldFByZXZQYWdlUGFyYW1gLFxuICAgICAgICAvLyBvciBgZ2V0UFBQYCByZXR1cm5lZCBudWxsaXNoXG4gICAgICAgIGlmIChwYXJhbSA9PSBudWxsICYmIGRhdGEucGFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmluYWxRdWVyeUFyZzogSW5maW5pdGVRdWVyeUNvbWJpbmVkQXJnPGFueSwgYW55PiA9IHtcbiAgICAgICAgICBxdWVyeUFyZzogYXJnLm9yaWdpbmFsQXJncyxcbiAgICAgICAgICBwYWdlUGFyYW06IHBhcmFtXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhZ2VSZXNwb25zZSA9IGF3YWl0IGV4ZWN1dGVSZXF1ZXN0KGZpbmFsUXVlcnlBcmcpO1xuICAgICAgICBjb25zdCBhZGRUbyA9IHByZXZpb3VzID8gYWRkVG9TdGFydCA6IGFkZFRvRW5kO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHBhZ2VzOiBhZGRUbyhkYXRhLnBhZ2VzLCBwYWdlUmVzcG9uc2UuZGF0YSwgbWF4UGFnZXMpLFxuICAgICAgICAgICAgcGFnZVBhcmFtczogYWRkVG8oZGF0YS5wYWdlUGFyYW1zLCBwYXJhbSwgbWF4UGFnZXMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtZXRhOiBwYWdlUmVzcG9uc2UubWV0YVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgLy8gV3JhcHBlciBmb3IgZXhlY3V0aW5nIGVpdGhlciBgcXVlcnlgIG9yIGBxdWVyeUZuYCxcbiAgICAgIC8vIGFuZCBoYW5kbGluZyBhbnkgZXJyb3JzXG4gICAgICBhc3luYyBmdW5jdGlvbiBleGVjdXRlUmVxdWVzdChmaW5hbFF1ZXJ5QXJnOiB1bmtub3duKTogUHJvbWlzZTxRdWVyeVJldHVyblZhbHVlPiB7XG4gICAgICAgIGxldCByZXN1bHQ6IFF1ZXJ5UmV0dXJuVmFsdWU7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBleHRyYU9wdGlvbnMsXG4gICAgICAgICAgYXJnU2NoZW1hLFxuICAgICAgICAgIHJhd1Jlc3BvbnNlU2NoZW1hLFxuICAgICAgICAgIHJlc3BvbnNlU2NoZW1hXG4gICAgICAgIH0gPSBlbmRwb2ludERlZmluaXRpb247XG4gICAgICAgIGlmIChhcmdTY2hlbWEgJiYgIXNraXBTY2hlbWFWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgZmluYWxRdWVyeUFyZyA9IGF3YWl0IHBhcnNlV2l0aFNjaGVtYShhcmdTY2hlbWEsIGZpbmFsUXVlcnlBcmcsICdhcmdTY2hlbWEnLCB7fSAvLyB3ZSBkb24ndCBoYXZlIGEgbWV0YSB5ZXQsIHNvIHdlIGNhbid0IHBhc3MgaXRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JjZVF1ZXJ5Rm4pIHtcbiAgICAgICAgICAvLyB1cHNlcnRRdWVyeURhdGEgcmVsaWVzIG9uIHRoaXMgdG8gcGFzcyBpbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZVxuICAgICAgICAgIHJlc3VsdCA9IGZvcmNlUXVlcnlGbigpO1xuICAgICAgICB9IGVsc2UgaWYgKGVuZHBvaW50RGVmaW5pdGlvbi5xdWVyeSkge1xuICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGJhc2VRdWVyeShlbmRwb2ludERlZmluaXRpb24ucXVlcnkoZmluYWxRdWVyeUFyZyBhcyBhbnkpLCBiYXNlUXVlcnlBcGksIGV4dHJhT3B0aW9ucyBhcyBhbnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGVuZHBvaW50RGVmaW5pdGlvbi5xdWVyeUZuKGZpbmFsUXVlcnlBcmcgYXMgYW55LCBiYXNlUXVlcnlBcGksIGV4dHJhT3B0aW9ucyBhcyBhbnksIGFyZyA9PiBiYXNlUXVlcnkoYXJnLCBiYXNlUXVlcnlBcGksIGV4dHJhT3B0aW9ucyBhcyBhbnkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgY29uc3Qgd2hhdCA9IGVuZHBvaW50RGVmaW5pdGlvbi5xdWVyeSA/ICdgYmFzZVF1ZXJ5YCcgOiAnYHF1ZXJ5Rm5gJztcbiAgICAgICAgICBsZXQgZXJyOiB1bmRlZmluZWQgfCBzdHJpbmc7XG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGVyciA9IGAke3doYXR9IGRpZCBub3QgcmV0dXJuIGFueXRoaW5nLmA7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZXJyID0gYCR7d2hhdH0gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0LmA7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuZXJyb3IgJiYgcmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgIGVyciA9IGAke3doYXR9IHJldHVybmVkIGFuIG9iamVjdCBjb250YWluaW5nIGJvdGggXFxgZXJyb3JcXGAgYW5kIFxcYHJlc3VsdFxcYC5gO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmVycm9yID09PSB1bmRlZmluZWQgJiYgcmVzdWx0LmRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyID0gYCR7d2hhdH0gcmV0dXJuZWQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmVpdGhlciBhIHZhbGlkIFxcYGVycm9yXFxgIGFuZCBcXGByZXN1bHRcXGAuIEF0IGxlYXN0IG9uZSBvZiB0aGVtIHNob3VsZCBub3QgYmUgXFxgdW5kZWZpbmVkXFxgYDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocmVzdWx0KSkge1xuICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnZXJyb3InICYmIGtleSAhPT0gJ2RhdGEnICYmIGtleSAhPT0gJ21ldGEnKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gYFRoZSBvYmplY3QgcmV0dXJuZWQgYnkgJHt3aGF0fSBoYXMgdGhlIHVua25vd24gcHJvcGVydHkgJHtrZXl9LmA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZW5jb3VudGVyZWQgaGFuZGxpbmcgdGhlIGVuZHBvaW50ICR7YXJnLmVuZHBvaW50TmFtZX0uXG4gICAgICAgICAgICAgICAgICAke2Vycn1cbiAgICAgICAgICAgICAgICAgIEl0IG5lZWRzIHRvIHJldHVybiBhbiBvYmplY3Qgd2l0aCBlaXRoZXIgdGhlIHNoYXBlIFxcYHsgZGF0YTogPHZhbHVlPiB9XFxgIG9yIFxcYHsgZXJyb3I6IDx2YWx1ZT4gfVxcYCB0aGF0IG1heSBjb250YWluIGFuIG9wdGlvbmFsIFxcYG1ldGFcXGAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICBPYmplY3QgcmV0dXJuZWQgd2FzOmAsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRocm93IG5ldyBIYW5kbGVkRXJyb3IocmVzdWx0LmVycm9yLCByZXN1bHQubWV0YSk7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgZGF0YVxuICAgICAgICB9ID0gcmVzdWx0O1xuICAgICAgICBpZiAocmF3UmVzcG9uc2VTY2hlbWEgJiYgIXNraXBTY2hlbWFWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgZGF0YSA9IGF3YWl0IHBhcnNlV2l0aFNjaGVtYShyYXdSZXNwb25zZVNjaGVtYSwgcmVzdWx0LmRhdGEsICdyYXdSZXNwb25zZVNjaGVtYScsIHJlc3VsdC5tZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHJhbnNmb3JtZWRSZXNwb25zZSA9IGF3YWl0IHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEsIHJlc3VsdC5tZXRhLCBmaW5hbFF1ZXJ5QXJnKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlU2NoZW1hICYmICFza2lwU2NoZW1hVmFsaWRhdGlvbikge1xuICAgICAgICAgIHRyYW5zZm9ybWVkUmVzcG9uc2UgPSBhd2FpdCBwYXJzZVdpdGhTY2hlbWEocmVzcG9uc2VTY2hlbWEsIHRyYW5zZm9ybWVkUmVzcG9uc2UsICdyZXNwb25zZVNjaGVtYScsIHJlc3VsdC5tZXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICBkYXRhOiB0cmFuc2Zvcm1lZFJlc3BvbnNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoYXJnLnR5cGUgPT09ICdxdWVyeScgJiYgJ2luZmluaXRlUXVlcnlPcHRpb25zJyBpbiBlbmRwb2ludERlZmluaXRpb24pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBpbmZpbml0ZSBxdWVyeSBlbmRwb2ludFxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaW5maW5pdGVRdWVyeU9wdGlvbnNcbiAgICAgICAgfSA9IGVuZHBvaW50RGVmaW5pdGlvbjtcblxuICAgICAgICAvLyBSdW50aW1lIGNoZWNrcyBzaG91bGQgZ3VhcmFudGVlIHRoaXMgaXMgYSBwb3NpdGl2ZSBudW1iZXIgaWYgcHJvdmlkZWRcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG1heFBhZ2VzID0gSW5maW5pdHlcbiAgICAgICAgfSA9IGluZmluaXRlUXVlcnlPcHRpb25zO1xuICAgICAgICBsZXQgcmVzdWx0OiBRdWVyeVJldHVyblZhbHVlO1xuXG4gICAgICAgIC8vIFN0YXJ0IGJ5IGxvb2tpbmcgdXAgdGhlIGV4aXN0aW5nIEluZmluaXRlRGF0YSB2YWx1ZSBmcm9tIHN0YXRlLFxuICAgICAgICAvLyBmYWxsaW5nIGJhY2sgdG8gYW4gZW1wdHkgdmFsdWUgaWYgaXQgZG9lc24ndCBleGlzdCB5ZXRcbiAgICAgICAgY29uc3QgYmxhbmtEYXRhID0ge1xuICAgICAgICAgIHBhZ2VzOiBbXSxcbiAgICAgICAgICBwYWdlUGFyYW1zOiBbXVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWNoZWREYXRhID0gc2VsZWN0b3JzLnNlbGVjdFF1ZXJ5RW50cnkoZ2V0U3RhdGUoKSwgYXJnLnF1ZXJ5Q2FjaGVLZXkpPy5kYXRhIGFzIEluZmluaXRlRGF0YTx1bmtub3duLCB1bmtub3duPiB8IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBXaGVuIHRoZSBhcmcgY2hhbmdlcyBvciB0aGUgdXNlciBmb3JjZXMgYSByZWZldGNoLFxuICAgICAgICAvLyB3ZSBkb24ndCBpbmNsdWRlIHRoZSBgZGlyZWN0aW9uYCBmbGFnLiBUaGlzIGxldHMgdXMgZGlzdGluZ3Vpc2hcbiAgICAgICAgLy8gYmV0d2VlbiBhY3R1YWxseSByZWZldGNoaW5nIHdpdGggYSBmb3JjZWQgcXVlcnksIHZzIGp1c3QgZmV0Y2hpbmdcbiAgICAgICAgLy8gdGhlIG5leHQgcGFnZS5cbiAgICAgICAgY29uc3QgaXNGb3JjZWRRdWVyeU5lZWRpbmdSZWZldGNoID1cbiAgICAgICAgLy8gYXJnLmZvcmNlUmVmZXRjaFxuICAgICAgICBpc0ZvcmNlZFF1ZXJ5KGFyZywgZ2V0U3RhdGUoKSkgJiYgIShhcmcgYXMgSW5maW5pdGVRdWVyeVRodW5rQXJnPGFueT4pLmRpcmVjdGlvbjtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdEYXRhID0gKGlzRm9yY2VkUXVlcnlOZWVkaW5nUmVmZXRjaCB8fCAhY2FjaGVkRGF0YSA/IGJsYW5rRGF0YSA6IGNhY2hlZERhdGEpIGFzIEluZmluaXRlRGF0YTx1bmtub3duLCB1bmtub3duPjtcblxuICAgICAgICAvLyBJZiB0aGUgdGh1bmsgc3BlY2lmaWVkIGEgZGlyZWN0aW9uIGFuZCB3ZSBkbyBoYXZlIGF0IGxlYXN0IG9uZSBwYWdlLFxuICAgICAgICAvLyBmZXRjaCB0aGUgbmV4dCBvciBwcmV2aW91cyBwYWdlXG4gICAgICAgIGlmICgnZGlyZWN0aW9uJyBpbiBhcmcgJiYgYXJnLmRpcmVjdGlvbiAmJiBleGlzdGluZ0RhdGEucGFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBhcmcuZGlyZWN0aW9uID09PSAnYmFja3dhcmQnO1xuICAgICAgICAgIGNvbnN0IHBhZ2VQYXJhbUZuID0gcHJldmlvdXMgPyBnZXRQcmV2aW91c1BhZ2VQYXJhbSA6IGdldE5leHRQYWdlUGFyYW07XG4gICAgICAgICAgY29uc3QgcGFyYW0gPSBwYWdlUGFyYW1GbihpbmZpbml0ZVF1ZXJ5T3B0aW9ucywgZXhpc3RpbmdEYXRhLCBhcmcub3JpZ2luYWxBcmdzKTtcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBmZXRjaFBhZ2UoZXhpc3RpbmdEYXRhLCBwYXJhbSwgbWF4UGFnZXMsIHByZXZpb3VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGZldGNoIHRoZSBmaXJzdCBwYWdlIGFuZCB0aGVuIGFueSByZW1haW5pbmcgcGFnZXNcblxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGluaXRpYWxQYWdlUGFyYW0gPSBpbmZpbml0ZVF1ZXJ5T3B0aW9ucy5pbml0aWFsUGFnZVBhcmFtXG4gICAgICAgICAgfSA9IGFyZyBhcyBJbmZpbml0ZVF1ZXJ5VGh1bmtBcmc8YW55PjtcblxuICAgICAgICAgIC8vIElmIHdlJ3JlIGRvaW5nIGEgcmVmZXRjaCwgd2Ugc2hvdWxkIHN0YXJ0IGZyb21cbiAgICAgICAgICAvLyB0aGUgZmlyc3QgcGFnZSB3ZSBoYXZlIGNhY2hlZC5cbiAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIHNob3VsZCBzdGFydCBmcm9tIHRoZSBpbml0aWFsUGFnZVBhcmFtXG4gICAgICAgICAgY29uc3QgY2FjaGVkUGFnZVBhcmFtcyA9IGNhY2hlZERhdGE/LnBhZ2VQYXJhbXMgPz8gW107XG4gICAgICAgICAgY29uc3QgZmlyc3RQYWdlUGFyYW0gPSBjYWNoZWRQYWdlUGFyYW1zWzBdID8/IGluaXRpYWxQYWdlUGFyYW07XG4gICAgICAgICAgY29uc3QgdG90YWxQYWdlcyA9IGNhY2hlZFBhZ2VQYXJhbXMubGVuZ3RoO1xuXG4gICAgICAgICAgLy8gRmV0Y2ggZmlyc3QgcGFnZVxuICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGZldGNoUGFnZShleGlzdGluZ0RhdGEsIGZpcnN0UGFnZVBhcmFtLCBtYXhQYWdlcyk7XG4gICAgICAgICAgaWYgKGZvcmNlUXVlcnlGbikge1xuICAgICAgICAgICAgLy8gSEFDSyBgdXBzZXJ0UXVlcnlEYXRhYCBleHBlY3RzIHRoZSB1c2VyIHRvIHBhc3MgaW4gdGhlIGB7cGFnZXMsIHBhZ2VQYXJhbXN9YCBzdHJ1Y3R1cmUsXG4gICAgICAgICAgICAvLyBidXQgYGZldGNoUGFnZWAgdHJlYXRzIHRoYXQgYXMgYHBhZ2VzWzBdYC4gV2UgaGF2ZSB0byBtYW51YWxseSB1bi1uZXN0IGl0LlxuICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICBkYXRhOiAocmVzdWx0LmRhdGEgYXMgSW5maW5pdGVEYXRhPHVua25vd24sIHVua25vd24+KS5wYWdlc1swXVxuICAgICAgICAgICAgfSBhcyBRdWVyeVJldHVyblZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZldGNoIHJlbWFpbmluZyBwYWdlc1xuICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdG90YWxQYWdlczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGdldE5leHRQYWdlUGFyYW0oaW5maW5pdGVRdWVyeU9wdGlvbnMsIHJlc3VsdC5kYXRhIGFzIEluZmluaXRlRGF0YTx1bmtub3duLCB1bmtub3duPiwgYXJnLm9yaWdpbmFsQXJncyk7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBmZXRjaFBhZ2UocmVzdWx0LmRhdGEgYXMgSW5maW5pdGVEYXRhPHVua25vd24sIHVua25vd24+LCBwYXJhbSwgbWF4UGFnZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbFF1ZXJ5UmV0dXJuVmFsdWUgPSByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb24taW5maW5pdGUgZW5kcG9pbnQuIEp1c3QgcnVuIHRoZSBvbmUgcmVxdWVzdC5cbiAgICAgICAgZmluYWxRdWVyeVJldHVyblZhbHVlID0gYXdhaXQgZXhlY3V0ZVJlcXVlc3QoYXJnLm9yaWdpbmFsQXJncyk7XG4gICAgICB9XG4gICAgICBpZiAobWV0YVNjaGVtYSAmJiAhc2tpcFNjaGVtYVZhbGlkYXRpb24gJiYgZmluYWxRdWVyeVJldHVyblZhbHVlLm1ldGEpIHtcbiAgICAgICAgZmluYWxRdWVyeVJldHVyblZhbHVlLm1ldGEgPSBhd2FpdCBwYXJzZVdpdGhTY2hlbWEobWV0YVNjaGVtYSwgZmluYWxRdWVyeVJldHVyblZhbHVlLm1ldGEsICdtZXRhU2NoZW1hJywgZmluYWxRdWVyeVJldHVyblZhbHVlLm1ldGEpO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25zb2xlLmxvZygnRmluYWwgcmVzdWx0OiAnLCB0cmFuc2Zvcm1lZERhdGEpXG4gICAgICByZXR1cm4gZnVsZmlsbFdpdGhWYWx1ZShmaW5hbFF1ZXJ5UmV0dXJuVmFsdWUuZGF0YSwgYWRkU2hvdWxkQXV0b0JhdGNoKHtcbiAgICAgICAgZnVsZmlsbGVkVGltZVN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBiYXNlUXVlcnlNZXRhOiBmaW5hbFF1ZXJ5UmV0dXJuVmFsdWUubWV0YVxuICAgICAgfSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsZXQgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIGlmIChjYXVnaHRFcnJvciBpbnN0YW5jZW9mIEhhbmRsZWRFcnJvcikge1xuICAgICAgICBsZXQgdHJhbnNmb3JtRXJyb3JSZXNwb25zZSA9IGdldFRyYW5zZm9ybUNhbGxiYWNrRm9yRW5kcG9pbnQoZW5kcG9pbnREZWZpbml0aW9uLCAndHJhbnNmb3JtRXJyb3JSZXNwb25zZScpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmF3RXJyb3JSZXNwb25zZVNjaGVtYSxcbiAgICAgICAgICBlcnJvclJlc3BvbnNlU2NoZW1hXG4gICAgICAgIH0gPSBlbmRwb2ludERlZmluaXRpb247XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgbWV0YVxuICAgICAgICB9ID0gY2F1Z2h0RXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHJhd0Vycm9yUmVzcG9uc2VTY2hlbWEgJiYgIXNraXBTY2hlbWFWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGF3YWl0IHBhcnNlV2l0aFNjaGVtYShyYXdFcnJvclJlc3BvbnNlU2NoZW1hLCB2YWx1ZSwgJ3Jhd0Vycm9yUmVzcG9uc2VTY2hlbWEnLCBtZXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1ldGFTY2hlbWEgJiYgIXNraXBTY2hlbWFWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICBtZXRhID0gYXdhaXQgcGFyc2VXaXRoU2NoZW1hKG1ldGFTY2hlbWEsIG1ldGEsICdtZXRhU2NoZW1hJywgbWV0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB0cmFuc2Zvcm1lZEVycm9yUmVzcG9uc2UgPSBhd2FpdCB0cmFuc2Zvcm1FcnJvclJlc3BvbnNlKHZhbHVlLCBtZXRhLCBhcmcub3JpZ2luYWxBcmdzKTtcbiAgICAgICAgICBpZiAoZXJyb3JSZXNwb25zZVNjaGVtYSAmJiAhc2tpcFNjaGVtYVZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkRXJyb3JSZXNwb25zZSA9IGF3YWl0IHBhcnNlV2l0aFNjaGVtYShlcnJvclJlc3BvbnNlU2NoZW1hLCB0cmFuc2Zvcm1lZEVycm9yUmVzcG9uc2UsICdlcnJvclJlc3BvbnNlU2NoZW1hJywgbWV0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZWplY3RXaXRoVmFsdWUodHJhbnNmb3JtZWRFcnJvclJlc3BvbnNlLCBhZGRTaG91bGRBdXRvQmF0Y2goe1xuICAgICAgICAgICAgYmFzZVF1ZXJ5TWV0YTogbWV0YVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNhdWdodEVycm9yID0gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGNhdWdodEVycm9yIGluc3RhbmNlb2YgTmFtZWRTY2hlbWFFcnJvcikge1xuICAgICAgICAgIGNvbnN0IGluZm86IFNjaGVtYUZhaWx1cmVJbmZvID0ge1xuICAgICAgICAgICAgZW5kcG9pbnQ6IGFyZy5lbmRwb2ludE5hbWUsXG4gICAgICAgICAgICBhcmc6IGFyZy5vcmlnaW5hbEFyZ3MsXG4gICAgICAgICAgICB0eXBlOiBhcmcudHlwZSxcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXk6IGFyZy50eXBlID09PSAncXVlcnknID8gYXJnLnF1ZXJ5Q2FjaGVLZXkgOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbi5vblNjaGVtYUZhaWx1cmU/LihjYXVnaHRFcnJvciwgaW5mbyk7XG4gICAgICAgICAgb25TY2hlbWFGYWlsdXJlPy4oY2F1Z2h0RXJyb3IsIGluZm8pO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNhdGNoU2NoZW1hRmFpbHVyZSA9IGdsb2JhbENhdGNoU2NoZW1hRmFpbHVyZVxuICAgICAgICAgIH0gPSBlbmRwb2ludERlZmluaXRpb247XG4gICAgICAgICAgaWYgKGNhdGNoU2NoZW1hRmFpbHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdFdpdGhWYWx1ZShjYXRjaFNjaGVtYUZhaWx1cmUoY2F1Z2h0RXJyb3IsIGluZm8pLCBhZGRTaG91bGRBdXRvQmF0Y2goe1xuICAgICAgICAgICAgICBiYXNlUXVlcnlNZXRhOiBjYXVnaHRFcnJvci5fYnFNZXRhXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhdWdodEVycm9yID0gZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBBbiB1bmhhbmRsZWQgZXJyb3Igb2NjdXJyZWQgcHJvY2Vzc2luZyBhIHJlcXVlc3QgZm9yIHRoZSBlbmRwb2ludCBcIiR7YXJnLmVuZHBvaW50TmFtZX1cIi5cbkluIHRoZSBjYXNlIG9mIGFuIHVuaGFuZGxlZCBlcnJvciwgbm8gdGFncyB3aWxsIGJlIFwicHJvdmlkZWRcIiBvciBcImludmFsaWRhdGVkXCIuYCwgY2F1Z2h0RXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihjYXVnaHRFcnJvcik7XG4gICAgICB9XG4gICAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGlzRm9yY2VkUXVlcnkoYXJnOiBRdWVyeVRodW5rQXJnLCBzdGF0ZTogUm9vdFN0YXRlPGFueSwgc3RyaW5nLCBSZWR1Y2VyUGF0aD4pIHtcbiAgICBjb25zdCByZXF1ZXN0U3RhdGUgPSBzZWxlY3RvcnMuc2VsZWN0UXVlcnlFbnRyeShzdGF0ZSwgYXJnLnF1ZXJ5Q2FjaGVLZXkpO1xuICAgIGNvbnN0IGJhc2VGZXRjaE9uTW91bnRPckFyZ0NoYW5nZSA9IHNlbGVjdG9ycy5zZWxlY3RDb25maWcoc3RhdGUpLnJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2U7XG4gICAgY29uc3QgZnVsZmlsbGVkVmFsID0gcmVxdWVzdFN0YXRlPy5mdWxmaWxsZWRUaW1lU3RhbXA7XG4gICAgY29uc3QgcmVmZXRjaFZhbCA9IGFyZy5mb3JjZVJlZmV0Y2ggPz8gKGFyZy5zdWJzY3JpYmUgJiYgYmFzZUZldGNoT25Nb3VudE9yQXJnQ2hhbmdlKTtcbiAgICBpZiAocmVmZXRjaFZhbCkge1xuICAgICAgLy8gUmV0dXJuIGlmIGl0J3MgdHJ1ZSBvciBjb21wYXJlIHRoZSBkYXRlcyBiZWNhdXNlIGl0IG11c3QgYmUgYSBudW1iZXJcbiAgICAgIHJldHVybiByZWZldGNoVmFsID09PSB0cnVlIHx8IChOdW1iZXIobmV3IERhdGUoKSkgLSBOdW1iZXIoZnVsZmlsbGVkVmFsKSkgLyAxMDAwID49IHJlZmV0Y2hWYWw7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjcmVhdGVRdWVyeVRodW5rID0gPFRodW5rQXJnVHlwZSBleHRlbmRzIFF1ZXJ5VGh1bmtBcmcgfCBJbmZpbml0ZVF1ZXJ5VGh1bmtBcmc8YW55Piw+KCkgPT4ge1xuICAgIGNvbnN0IGdlbmVyYXRlZFF1ZXJ5VGh1bmsgPSBjcmVhdGVBc3luY1RodW5rPFRodW5rUmVzdWx0LCBUaHVua0FyZ1R5cGUsIFRodW5rQXBpTWV0YUNvbmZpZyAmIHtcbiAgICAgIHN0YXRlOiBSb290U3RhdGU8YW55LCBzdHJpbmcsIFJlZHVjZXJQYXRoPjtcbiAgICB9PihgJHtyZWR1Y2VyUGF0aH0vZXhlY3V0ZVF1ZXJ5YCwgZXhlY3V0ZUVuZHBvaW50LCB7XG4gICAgICBnZXRQZW5kaW5nTWV0YSh7XG4gICAgICAgIGFyZ1xuICAgICAgfSkge1xuICAgICAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBlbmRwb2ludERlZmluaXRpb25zW2FyZy5lbmRwb2ludE5hbWVdO1xuICAgICAgICByZXR1cm4gYWRkU2hvdWxkQXV0b0JhdGNoKHtcbiAgICAgICAgICBzdGFydGVkVGltZVN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgIC4uLihpc0luZmluaXRlUXVlcnlEZWZpbml0aW9uKGVuZHBvaW50RGVmaW5pdGlvbikgPyB7XG4gICAgICAgICAgICBkaXJlY3Rpb246IChhcmcgYXMgSW5maW5pdGVRdWVyeVRodW5rQXJnPGFueT4pLmRpcmVjdGlvblxuICAgICAgICAgIH0gOiB7fSlcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgY29uZGl0aW9uKHF1ZXJ5VGh1bmtBcmcsIHtcbiAgICAgICAgZ2V0U3RhdGVcbiAgICAgIH0pIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCByZXF1ZXN0U3RhdGUgPSBzZWxlY3RvcnMuc2VsZWN0UXVlcnlFbnRyeShzdGF0ZSwgcXVlcnlUaHVua0FyZy5xdWVyeUNhY2hlS2V5KTtcbiAgICAgICAgY29uc3QgZnVsZmlsbGVkVmFsID0gcmVxdWVzdFN0YXRlPy5mdWxmaWxsZWRUaW1lU3RhbXA7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBcmcgPSBxdWVyeVRodW5rQXJnLm9yaWdpbmFsQXJncztcbiAgICAgICAgY29uc3QgcHJldmlvdXNBcmcgPSByZXF1ZXN0U3RhdGU/Lm9yaWdpbmFsQXJncztcbiAgICAgICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gZW5kcG9pbnREZWZpbml0aW9uc1txdWVyeVRodW5rQXJnLmVuZHBvaW50TmFtZV07XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IChxdWVyeVRodW5rQXJnIGFzIEluZmluaXRlUXVlcnlUaHVua0FyZzxhbnk+KS5kaXJlY3Rpb247XG5cbiAgICAgICAgLy8gT3JkZXIgb2YgdGhlc2UgY2hlY2tzIG1hdHRlcnMuXG4gICAgICAgIC8vIEluIG9yZGVyIGZvciBgdXBzZXJ0UXVlcnlEYXRhYCB0byBzdWNjZXNzZnVsbHkgcnVuIHdoaWxlIGFuIGV4aXN0aW5nIHJlcXVlc3QgaXMgaW4gZmxpZ2h0LFxuICAgICAgICAvLy8gd2UgaGF2ZSB0byBjaGVjayBmb3IgdGhhdCBmaXJzdCwgb3RoZXJ3aXNlIGBxdWVyeVRodW5rYCB3aWxsIGJhaWwgb3V0IGFuZCBub3QgcnVuIGF0IGFsbC5cbiAgICAgICAgaWYgKGlzVXBzZXJ0UXVlcnkocXVlcnlUaHVua0FyZykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvbid0IHJldHJ5IGEgcmVxdWVzdCB0aGF0J3MgY3VycmVudGx5IGluLWZsaWdodFxuICAgICAgICBpZiAocmVxdWVzdFN0YXRlPy5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgZm9yY2VkLCBjb250aW51ZVxuICAgICAgICBpZiAoaXNGb3JjZWRRdWVyeShxdWVyeVRodW5rQXJnLCBzdGF0ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNRdWVyeURlZmluaXRpb24oZW5kcG9pbnREZWZpbml0aW9uKSAmJiBlbmRwb2ludERlZmluaXRpb24/LmZvcmNlUmVmZXRjaD8uKHtcbiAgICAgICAgICBjdXJyZW50QXJnLFxuICAgICAgICAgIHByZXZpb3VzQXJnLFxuICAgICAgICAgIGVuZHBvaW50U3RhdGU6IHJlcXVlc3RTdGF0ZSxcbiAgICAgICAgICBzdGF0ZVxuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHVsbCBmcm9tIHRoZSBjYWNoZSB1bmxlc3Mgd2UgZXhwbGljaXRseSBmb3JjZSByZWZldGNoIG9yIHF1YWxpZnkgYmFzZWQgb24gdGltZVxuICAgICAgICBpZiAoZnVsZmlsbGVkVmFsICYmICFkaXJlY3Rpb24pIHtcbiAgICAgICAgICAvLyBWYWx1ZSBpcyBjYWNoZWQgYW5kIHdlIGRpZG4ndCBzcGVjaWZ5IHRvIHJlZnJlc2gsIHNraXAgaXQuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRlZFF1ZXJ5VGh1bms7XG4gIH07XG4gIGNvbnN0IHF1ZXJ5VGh1bmsgPSBjcmVhdGVRdWVyeVRodW5rPFF1ZXJ5VGh1bmtBcmc+KCk7XG4gIGNvbnN0IGluZmluaXRlUXVlcnlUaHVuayA9IGNyZWF0ZVF1ZXJ5VGh1bms8SW5maW5pdGVRdWVyeVRodW5rQXJnPGFueT4+KCk7XG4gIGNvbnN0IG11dGF0aW9uVGh1bmsgPSBjcmVhdGVBc3luY1RodW5rPFRodW5rUmVzdWx0LCBNdXRhdGlvblRodW5rQXJnLCBUaHVua0FwaU1ldGFDb25maWcgJiB7XG4gICAgc3RhdGU6IFJvb3RTdGF0ZTxhbnksIHN0cmluZywgUmVkdWNlclBhdGg+O1xuICB9PihgJHtyZWR1Y2VyUGF0aH0vZXhlY3V0ZU11dGF0aW9uYCwgZXhlY3V0ZUVuZHBvaW50LCB7XG4gICAgZ2V0UGVuZGluZ01ldGEoKSB7XG4gICAgICByZXR1cm4gYWRkU2hvdWxkQXV0b0JhdGNoKHtcbiAgICAgICAgc3RhcnRlZFRpbWVTdGFtcDogRGF0ZS5ub3coKVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgaGFzVGhlRm9yY2UgPSAob3B0aW9uczogYW55KTogb3B0aW9ucyBpcyB7XG4gICAgZm9yY2U6IGJvb2xlYW47XG4gIH0gPT4gJ2ZvcmNlJyBpbiBvcHRpb25zO1xuICBjb25zdCBoYXNNYXhBZ2UgPSAob3B0aW9uczogYW55KTogb3B0aW9ucyBpcyB7XG4gICAgaWZPbGRlclRoYW46IGZhbHNlIHwgbnVtYmVyO1xuICB9ID0+ICdpZk9sZGVyVGhhbicgaW4gb3B0aW9ucztcbiAgY29uc3QgcHJlZmV0Y2ggPSA8RW5kcG9pbnROYW1lIGV4dGVuZHMgUXVlcnlLZXlzPERlZmluaXRpb25zPiw+KGVuZHBvaW50TmFtZTogRW5kcG9pbnROYW1lLCBhcmc6IGFueSwgb3B0aW9uczogUHJlZmV0Y2hPcHRpb25zKTogVGh1bmtBY3Rpb248dm9pZCwgYW55LCBhbnksIFVua25vd25BY3Rpb24+ID0+IChkaXNwYXRjaDogVGh1bmtEaXNwYXRjaDxhbnksIGFueSwgYW55PiwgZ2V0U3RhdGU6ICgpID0+IGFueSkgPT4ge1xuICAgIGNvbnN0IGZvcmNlID0gaGFzVGhlRm9yY2Uob3B0aW9ucykgJiYgb3B0aW9ucy5mb3JjZTtcbiAgICBjb25zdCBtYXhBZ2UgPSBoYXNNYXhBZ2Uob3B0aW9ucykgJiYgb3B0aW9ucy5pZk9sZGVyVGhhbjtcbiAgICBjb25zdCBxdWVyeUFjdGlvbiA9IChmb3JjZTogYm9vbGVhbiA9IHRydWUpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGZvcmNlUmVmZXRjaDogZm9yY2UsXG4gICAgICAgIGlzUHJlZmV0Y2g6IHRydWVcbiAgICAgIH07XG4gICAgICByZXR1cm4gKGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSBhcyBBcGlFbmRwb2ludFF1ZXJ5PGFueSwgYW55PikuaW5pdGlhdGUoYXJnLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGNvbnN0IGxhdGVzdFN0YXRlVmFsdWUgPSAoYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdIGFzIEFwaUVuZHBvaW50UXVlcnk8YW55LCBhbnk+KS5zZWxlY3QoYXJnKShnZXRTdGF0ZSgpKTtcbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIGRpc3BhdGNoKHF1ZXJ5QWN0aW9uKCkpO1xuICAgIH0gZWxzZSBpZiAobWF4QWdlKSB7XG4gICAgICBjb25zdCBsYXN0RnVsZmlsbGVkVHMgPSBsYXRlc3RTdGF0ZVZhbHVlPy5mdWxmaWxsZWRUaW1lU3RhbXA7XG4gICAgICBpZiAoIWxhc3RGdWxmaWxsZWRUcykge1xuICAgICAgICBkaXNwYXRjaChxdWVyeUFjdGlvbigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hvdWxkUmV0cmlnZ2VyID0gKE51bWJlcihuZXcgRGF0ZSgpKSAtIE51bWJlcihuZXcgRGF0ZShsYXN0RnVsZmlsbGVkVHMpKSkgLyAxMDAwID49IG1heEFnZTtcbiAgICAgIGlmIChzaG91bGRSZXRyaWdnZXIpIHtcbiAgICAgICAgZGlzcGF0Y2gocXVlcnlBY3Rpb24oKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHByZWZldGNoaW5nIHdpdGggbm8gb3B0aW9ucywganVzdCBsZXQgaXQgdHJ5XG4gICAgICBkaXNwYXRjaChxdWVyeUFjdGlvbihmYWxzZSkpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gbWF0Y2hlc0VuZHBvaW50KGVuZHBvaW50TmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIChhY3Rpb246IGFueSk6IGFjdGlvbiBpcyBVbmtub3duQWN0aW9uID0+IGFjdGlvbj8ubWV0YT8uYXJnPy5lbmRwb2ludE5hbWUgPT09IGVuZHBvaW50TmFtZTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZE1hdGNoVGh1bmtBY3Rpb25zPFRodW5rIGV4dGVuZHMgQXN5bmNUaHVuazxhbnksIFF1ZXJ5VGh1bmtBcmcsIFRodW5rQXBpTWV0YUNvbmZpZz4gfCBBc3luY1RodW5rPGFueSwgTXV0YXRpb25UaHVua0FyZywgVGh1bmtBcGlNZXRhQ29uZmlnPj4odGh1bms6IFRodW5rLCBlbmRwb2ludE5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiB7XG4gICAgICBtYXRjaFBlbmRpbmc6IGlzQWxsT2YoaXNQZW5kaW5nKHRodW5rKSwgbWF0Y2hlc0VuZHBvaW50KGVuZHBvaW50TmFtZSkpLFxuICAgICAgbWF0Y2hGdWxmaWxsZWQ6IGlzQWxsT2YoaXNGdWxmaWxsZWQodGh1bmspLCBtYXRjaGVzRW5kcG9pbnQoZW5kcG9pbnROYW1lKSksXG4gICAgICBtYXRjaFJlamVjdGVkOiBpc0FsbE9mKGlzUmVqZWN0ZWQodGh1bmspLCBtYXRjaGVzRW5kcG9pbnQoZW5kcG9pbnROYW1lKSlcbiAgICB9IGFzIE1hdGNoZXJzPFRodW5rLCBhbnk+O1xuICB9XG4gIHJldHVybiB7XG4gICAgcXVlcnlUaHVuayxcbiAgICBtdXRhdGlvblRodW5rLFxuICAgIGluZmluaXRlUXVlcnlUaHVuayxcbiAgICBwcmVmZXRjaCxcbiAgICB1cGRhdGVRdWVyeURhdGEsXG4gICAgdXBzZXJ0UXVlcnlEYXRhLFxuICAgIHBhdGNoUXVlcnlEYXRhLFxuICAgIGJ1aWxkTWF0Y2hUaHVua0FjdGlvbnNcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXh0UGFnZVBhcmFtKG9wdGlvbnM6IEluZmluaXRlUXVlcnlDb25maWdPcHRpb25zPHVua25vd24sIHVua25vd24sIHVua25vd24+LCB7XG4gIHBhZ2VzLFxuICBwYWdlUGFyYW1zXG59OiBJbmZpbml0ZURhdGE8dW5rbm93biwgdW5rbm93bj4sIHF1ZXJ5QXJnOiB1bmtub3duKTogdW5rbm93biB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHBhZ2VzLmxlbmd0aCAtIDE7XG4gIHJldHVybiBvcHRpb25zLmdldE5leHRQYWdlUGFyYW0ocGFnZXNbbGFzdEluZGV4XSwgcGFnZXMsIHBhZ2VQYXJhbXNbbGFzdEluZGV4XSwgcGFnZVBhcmFtcywgcXVlcnlBcmcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFByZXZpb3VzUGFnZVBhcmFtKG9wdGlvbnM6IEluZmluaXRlUXVlcnlDb25maWdPcHRpb25zPHVua25vd24sIHVua25vd24sIHVua25vd24+LCB7XG4gIHBhZ2VzLFxuICBwYWdlUGFyYW1zXG59OiBJbmZpbml0ZURhdGE8dW5rbm93biwgdW5rbm93bj4sIHF1ZXJ5QXJnOiB1bmtub3duKTogdW5rbm93biB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBvcHRpb25zLmdldFByZXZpb3VzUGFnZVBhcmFtPy4ocGFnZXNbMF0sIHBhZ2VzLCBwYWdlUGFyYW1zWzBdLCBwYWdlUGFyYW1zLCBxdWVyeUFyZyk7XG59XG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUHJvdmlkZWRCeVRodW5rKGFjdGlvbjogVW53cmFwUHJvbWlzZTxSZXR1cm5UeXBlPFJldHVyblR5cGU8UXVlcnlUaHVuaz4+IHwgUmV0dXJuVHlwZTxSZXR1cm5UeXBlPE11dGF0aW9uVGh1bms+PiB8IFJldHVyblR5cGU8UmV0dXJuVHlwZTxJbmZpbml0ZVF1ZXJ5VGh1bms8YW55Pj4+PiwgdHlwZTogJ3Byb3ZpZGVzVGFncycgfCAnaW52YWxpZGF0ZXNUYWdzJywgZW5kcG9pbnREZWZpbml0aW9uczogRW5kcG9pbnREZWZpbml0aW9ucywgYXNzZXJ0VGFnVHlwZTogQXNzZXJ0VGFnVHlwZXMpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVByb3ZpZGVkQnkoZW5kcG9pbnREZWZpbml0aW9uc1thY3Rpb24ubWV0YS5hcmcuZW5kcG9pbnROYW1lXVt0eXBlXSBhcyBSZXN1bHREZXNjcmlwdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4sIGlzRnVsZmlsbGVkKGFjdGlvbikgPyBhY3Rpb24ucGF5bG9hZCA6IHVuZGVmaW5lZCwgaXNSZWplY3RlZFdpdGhWYWx1ZShhY3Rpb24pID8gYWN0aW9uLnBheWxvYWQgOiB1bmRlZmluZWQsIGFjdGlvbi5tZXRhLmFyZy5vcmlnaW5hbEFyZ3MsICdiYXNlUXVlcnlNZXRhJyBpbiBhY3Rpb24ubWV0YSA/IGFjdGlvbi5tZXRhLmJhc2VRdWVyeU1ldGEgOiB1bmRlZmluZWQsIGFzc2VydFRhZ1R5cGUpO1xufSIsImltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHR5cGUgeyBBc3luY1RodW5rQWN0aW9uLCBTYWZlUHJvbWlzZSwgU2VyaWFsaXplZEVycm9yLCBUaHVua0FjdGlvbiwgVW5rbm93bkFjdGlvbiB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IHR5cGUgeyBEaXNwYXRjaCB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IGFzU2FmZVByb21pc2UgfSBmcm9tICcuLi8uLi90c0hlbHBlcnMnO1xuaW1wb3J0IHR5cGUgeyBBcGksIEFwaUNvbnRleHQgfSBmcm9tICcuLi9hcGlUeXBlcyc7XG5pbXBvcnQgdHlwZSB7IEJhc2VRdWVyeUVycm9yLCBRdWVyeVJldHVyblZhbHVlIH0gZnJvbSAnLi4vYmFzZVF1ZXJ5VHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBJbnRlcm5hbFNlcmlhbGl6ZVF1ZXJ5QXJncyB9IGZyb20gJy4uL2RlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MnO1xuaW1wb3J0IHsgaXNRdWVyeURlZmluaXRpb24sIHR5cGUgRW5kcG9pbnREZWZpbml0aW9uLCB0eXBlIEVuZHBvaW50RGVmaW5pdGlvbnMsIHR5cGUgSW5maW5pdGVRdWVyeUFyZ0Zyb20sIHR5cGUgSW5maW5pdGVRdWVyeURlZmluaXRpb24sIHR5cGUgTXV0YXRpb25EZWZpbml0aW9uLCB0eXBlIFBhZ2VQYXJhbUZyb20sIHR5cGUgUXVlcnlBcmdGcm9tLCB0eXBlIFF1ZXJ5RGVmaW5pdGlvbiwgdHlwZSBSZXN1bHRUeXBlRnJvbSB9IGZyb20gJy4uL2VuZHBvaW50RGVmaW5pdGlvbnMnO1xuaW1wb3J0IHsgY291bnRPYmplY3RLZXlzLCBnZXRPckluc2VydCwgaXNOb3ROdWxsaXNoIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBJbmZpbml0ZURhdGEsIEluZmluaXRlUXVlcnlDb25maWdPcHRpb25zLCBJbmZpbml0ZVF1ZXJ5RGlyZWN0aW9uLCBTdWJzY3JpcHRpb25PcHRpb25zIH0gZnJvbSAnLi9hcGlTdGF0ZSc7XG5pbXBvcnQgdHlwZSB7IEluZmluaXRlUXVlcnlSZXN1bHRTZWxlY3RvclJlc3VsdCwgUXVlcnlSZXN1bHRTZWxlY3RvclJlc3VsdCB9IGZyb20gJy4vYnVpbGRTZWxlY3RvcnMnO1xuaW1wb3J0IHR5cGUgeyBJbmZpbml0ZVF1ZXJ5VGh1bmssIEluZmluaXRlUXVlcnlUaHVua0FyZywgTXV0YXRpb25UaHVuaywgUXVlcnlUaHVuaywgUXVlcnlUaHVua0FyZywgVGh1bmtBcGlNZXRhQ29uZmlnIH0gZnJvbSAnLi9idWlsZFRodW5rcyc7XG5pbXBvcnQgdHlwZSB7IEFwaUVuZHBvaW50UXVlcnkgfSBmcm9tICcuL21vZHVsZSc7XG5leHBvcnQgdHlwZSBCdWlsZEluaXRpYXRlQXBpRW5kcG9pbnRRdWVyeTxEZWZpbml0aW9uIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55Pj4gPSB7XG4gIGluaXRpYXRlOiBTdGFydFF1ZXJ5QWN0aW9uQ3JlYXRvcjxEZWZpbml0aW9uPjtcbn07XG5leHBvcnQgdHlwZSBCdWlsZEluaXRpYXRlQXBpRW5kcG9pbnRJbmZpbml0ZVF1ZXJ5PERlZmluaXRpb24gZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4+ID0ge1xuICBpbml0aWF0ZTogU3RhcnRJbmZpbml0ZVF1ZXJ5QWN0aW9uQ3JlYXRvcjxEZWZpbml0aW9uPjtcbn07XG5leHBvcnQgdHlwZSBCdWlsZEluaXRpYXRlQXBpRW5kcG9pbnRNdXRhdGlvbjxEZWZpbml0aW9uIGV4dGVuZHMgTXV0YXRpb25EZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55Pj4gPSB7XG4gIGluaXRpYXRlOiBTdGFydE11dGF0aW9uQWN0aW9uQ3JlYXRvcjxEZWZpbml0aW9uPjtcbn07XG5leHBvcnQgY29uc3QgZm9yY2VRdWVyeUZuU3ltYm9sID0gU3ltYm9sKCdmb3JjZVF1ZXJ5Rm4nKTtcbmV4cG9ydCBjb25zdCBpc1Vwc2VydFF1ZXJ5ID0gKGFyZzogUXVlcnlUaHVua0FyZykgPT4gdHlwZW9mIGFyZ1tmb3JjZVF1ZXJ5Rm5TeW1ib2xdID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0IHR5cGUgU3RhcnRRdWVyeUFjdGlvbkNyZWF0b3JPcHRpb25zID0ge1xuICBzdWJzY3JpYmU/OiBib29sZWFuO1xuICBmb3JjZVJlZmV0Y2g/OiBib29sZWFuIHwgbnVtYmVyO1xuICBzdWJzY3JpcHRpb25PcHRpb25zPzogU3Vic2NyaXB0aW9uT3B0aW9ucztcbiAgW2ZvcmNlUXVlcnlGblN5bWJvbF0/OiAoKSA9PiBRdWVyeVJldHVyblZhbHVlO1xufTtcbmV4cG9ydCB0eXBlIFN0YXJ0SW5maW5pdGVRdWVyeUFjdGlvbkNyZWF0b3JPcHRpb25zPEQgZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4+ID0gU3RhcnRRdWVyeUFjdGlvbkNyZWF0b3JPcHRpb25zICYge1xuICBkaXJlY3Rpb24/OiBJbmZpbml0ZVF1ZXJ5RGlyZWN0aW9uO1xuICBwYXJhbT86IHVua25vd247XG59ICYgUGFydGlhbDxQaWNrPFBhcnRpYWw8SW5maW5pdGVRdWVyeUNvbmZpZ09wdGlvbnM8UmVzdWx0VHlwZUZyb208RD4sIFBhZ2VQYXJhbUZyb208RD4sIEluZmluaXRlUXVlcnlBcmdGcm9tPEQ+Pj4sICdpbml0aWFsUGFnZVBhcmFtJz4+O1xudHlwZSBBbnlRdWVyeUFjdGlvbkNyZWF0b3I8RCBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+PiA9IChhcmc6IGFueSwgb3B0aW9ucz86IFN0YXJ0UXVlcnlBY3Rpb25DcmVhdG9yT3B0aW9ucykgPT4gVGh1bmtBY3Rpb248QW55QWN0aW9uQ3JlYXRvclJlc3VsdCwgYW55LCBhbnksIFVua25vd25BY3Rpb24+O1xudHlwZSBTdGFydFF1ZXJ5QWN0aW9uQ3JlYXRvcjxEIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55Pj4gPSAoYXJnOiBRdWVyeUFyZ0Zyb208RD4sIG9wdGlvbnM/OiBTdGFydFF1ZXJ5QWN0aW9uQ3JlYXRvck9wdGlvbnMpID0+IFRodW5rQWN0aW9uPFF1ZXJ5QWN0aW9uQ3JlYXRvclJlc3VsdDxEPiwgYW55LCBhbnksIFVua25vd25BY3Rpb24+O1xuZXhwb3J0IHR5cGUgU3RhcnRJbmZpbml0ZVF1ZXJ5QWN0aW9uQ3JlYXRvcjxEIGV4dGVuZHMgSW5maW5pdGVRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnk+PiA9IChhcmc6IEluZmluaXRlUXVlcnlBcmdGcm9tPEQ+LCBvcHRpb25zPzogU3RhcnRJbmZpbml0ZVF1ZXJ5QWN0aW9uQ3JlYXRvck9wdGlvbnM8RD4pID0+IFRodW5rQWN0aW9uPEluZmluaXRlUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0PEQ+LCBhbnksIGFueSwgVW5rbm93bkFjdGlvbj47XG50eXBlIFF1ZXJ5QWN0aW9uQ3JlYXRvckZpZWxkcyA9IHtcbiAgcmVxdWVzdElkOiBzdHJpbmc7XG4gIHN1YnNjcmlwdGlvbk9wdGlvbnM6IFN1YnNjcmlwdGlvbk9wdGlvbnMgfCB1bmRlZmluZWQ7XG4gIGFib3J0KCk6IHZvaWQ7XG4gIHVuc3Vic2NyaWJlKCk6IHZvaWQ7XG4gIHVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMob3B0aW9uczogU3Vic2NyaXB0aW9uT3B0aW9ucyk6IHZvaWQ7XG4gIHF1ZXJ5Q2FjaGVLZXk6IHN0cmluZztcbn07XG50eXBlIEFueUFjdGlvbkNyZWF0b3JSZXN1bHQgPSBTYWZlUHJvbWlzZTxhbnk+ICYgUXVlcnlBY3Rpb25DcmVhdG9yRmllbGRzICYge1xuICBhcmc6IGFueTtcbiAgdW53cmFwKCk6IFByb21pc2U8YW55PjtcbiAgcmVmZXRjaCgpOiBBbnlBY3Rpb25DcmVhdG9yUmVzdWx0O1xufTtcbmV4cG9ydCB0eXBlIFF1ZXJ5QWN0aW9uQ3JlYXRvclJlc3VsdDxEIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4+ID0gU2FmZVByb21pc2U8UXVlcnlSZXN1bHRTZWxlY3RvclJlc3VsdDxEPj4gJiBRdWVyeUFjdGlvbkNyZWF0b3JGaWVsZHMgJiB7XG4gIGFyZzogUXVlcnlBcmdGcm9tPEQ+O1xuICB1bndyYXAoKTogUHJvbWlzZTxSZXN1bHRUeXBlRnJvbTxEPj47XG4gIHJlZmV0Y2goKTogUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0PEQ+O1xufTtcbmV4cG9ydCB0eXBlIEluZmluaXRlUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0PEQgZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4+ID0gU2FmZVByb21pc2U8SW5maW5pdGVRdWVyeVJlc3VsdFNlbGVjdG9yUmVzdWx0PEQ+PiAmIFF1ZXJ5QWN0aW9uQ3JlYXRvckZpZWxkcyAmIHtcbiAgYXJnOiBJbmZpbml0ZVF1ZXJ5QXJnRnJvbTxEPjtcbiAgdW53cmFwKCk6IFByb21pc2U8SW5maW5pdGVEYXRhPFJlc3VsdFR5cGVGcm9tPEQ+LCBQYWdlUGFyYW1Gcm9tPEQ+Pj47XG4gIHJlZmV0Y2goKTogSW5maW5pdGVRdWVyeUFjdGlvbkNyZWF0b3JSZXN1bHQ8RD47XG59O1xudHlwZSBTdGFydE11dGF0aW9uQWN0aW9uQ3JlYXRvcjxEIGV4dGVuZHMgTXV0YXRpb25EZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4+ID0gKGFyZzogUXVlcnlBcmdGcm9tPEQ+LCBvcHRpb25zPzoge1xuICAvKipcbiAgICogSWYgdGhpcyBtdXRhdGlvbiBzaG91bGQgYmUgdHJhY2tlZCBpbiB0aGUgc3RvcmUuXG4gICAqIElmIHlvdSBqdXN0IHdhbnQgdG8gbWFudWFsbHkgdHJpZ2dlciB0aGlzIG11dGF0aW9uIHVzaW5nIGBkaXNwYXRjaGAgYW5kIGRvbid0IGNhcmUgYWJvdXQgdGhlXG4gICAqIHJlc3VsdCwgc3RhdGUgJiBwb3RlbnRpYWwgZXJyb3JzIGJlaW5nIGhlbGQgaW4gc3RvcmUsIHlvdSBjYW4gc2V0IHRoaXMgdG8gZmFsc2UuXG4gICAqIChkZWZhdWx0cyB0byBgdHJ1ZWApXG4gICAqL1xuICB0cmFjaz86IGJvb2xlYW47XG4gIGZpeGVkQ2FjaGVLZXk/OiBzdHJpbmc7XG59KSA9PiBUaHVua0FjdGlvbjxNdXRhdGlvbkFjdGlvbkNyZWF0b3JSZXN1bHQ8RD4sIGFueSwgYW55LCBVbmtub3duQWN0aW9uPjtcbmV4cG9ydCB0eXBlIE11dGF0aW9uQWN0aW9uQ3JlYXRvclJlc3VsdDxEIGV4dGVuZHMgTXV0YXRpb25EZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4+ID0gU2FmZVByb21pc2U8e1xuICBkYXRhOiBSZXN1bHRUeXBlRnJvbTxEPjtcbiAgZXJyb3I/OiB1bmRlZmluZWQ7XG59IHwge1xuICBkYXRhPzogdW5kZWZpbmVkO1xuICBlcnJvcjogRXhjbHVkZTxCYXNlUXVlcnlFcnJvcjxEIGV4dGVuZHMgTXV0YXRpb25EZWZpbml0aW9uPGFueSwgaW5mZXIgQmFzZVF1ZXJ5LCBhbnksIGFueT4gPyBCYXNlUXVlcnkgOiBuZXZlcj4sIHVuZGVmaW5lZD4gfCBTZXJpYWxpemVkRXJyb3I7XG59PiAmIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhcmc6IHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgZ2l2ZW4gZW5kcG9pbnQgZm9yIHRoZSBtdXRhdGlvblxuICAgICAqL1xuICAgIGVuZHBvaW50TmFtZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmlnaW5hbCBhcmd1bWVudHMgc3VwcGxpZWQgdG8gdGhlIG11dGF0aW9uIGNhbGxcbiAgICAgKi9cbiAgICBvcmlnaW5hbEFyZ3M6IFF1ZXJ5QXJnRnJvbTxEPjtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBtdXRhdGlvbiBpcyBiZWluZyB0cmFja2VkIGluIHRoZSBzdG9yZS5cbiAgICAgKi9cbiAgICB0cmFjaz86IGJvb2xlYW47XG4gICAgZml4ZWRDYWNoZUtleT86IHN0cmluZztcbiAgfTtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyBnZW5lcmF0ZWQgZm9yIHRoZSByZXF1ZXN0IHNlcXVlbmNlXG4gICAqL1xuICByZXF1ZXN0SWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQSBtZXRob2QgdG8gY2FuY2VsIHRoZSBtdXRhdGlvbiBwcm9taXNlLiBOb3RlIHRoYXQgdGhpcyBpcyBub3QgaW50ZW5kZWQgdG8gcHJldmVudCB0aGUgbXV0YXRpb25cbiAgICogdGhhdCB3YXMgZmlyZWQgb2ZmIGZyb20gcmVhY2hpbmcgdGhlIHNlcnZlciwgYnV0IG9ubHkgdG8gYXNzaXN0IGluIGhhbmRsaW5nIHRoZSByZXNwb25zZS5cbiAgICpcbiAgICogQ2FsbGluZyBgYWJvcnQoKWAgcHJpb3IgdG8gdGhlIHByb21pc2UgcmVzb2x2aW5nIHdpbGwgZm9yY2UgaXQgdG8gcmVhY2ggdGhlIGVycm9yIHN0YXRlIHdpdGhcbiAgICogdGhlIHNlcmlhbGl6ZWQgZXJyb3I6XG4gICAqIGB7IG5hbWU6ICdBYm9ydEVycm9yJywgbWVzc2FnZTogJ0Fib3J0ZWQnIH1gXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IFt1cGRhdGVVc2VyXSA9IHVzZVVwZGF0ZVVzZXJNdXRhdGlvbigpO1xuICAgKlxuICAgKiB1c2VFZmZlY3QoKCkgPT4ge1xuICAgKiAgIGNvbnN0IHByb21pc2UgPSB1cGRhdGVVc2VyKGlkKTtcbiAgICogICBwcm9taXNlXG4gICAqICAgICAudW53cmFwKClcbiAgICogICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAqICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSByZXR1cm47XG4gICAqICAgICAgIC8vIGVsc2UgaGFuZGxlIHRoZSB1bmV4cGVjdGVkIGVycm9yXG4gICAqICAgICB9KVxuICAgKlxuICAgKiAgIHJldHVybiAoKSA9PiB7XG4gICAqICAgICBwcm9taXNlLmFib3J0KCk7XG4gICAqICAgfVxuICAgKiB9LCBbaWQsIHVwZGF0ZVVzZXJdKVxuICAgKiBgYGBcbiAgICovXG4gIGFib3J0KCk6IHZvaWQ7XG4gIC8qKlxuICAgKiBVbndyYXBzIGEgbXV0YXRpb24gY2FsbCB0byBwcm92aWRlIHRoZSByYXcgcmVzcG9uc2UvZXJyb3IuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgZXJyb3Igb3Igc3VjY2VzcyBwYXlsb2FkIGltbWVkaWF0ZWx5IGFmdGVyIGEgbXV0YXRpb24sIHlvdSBjYW4gY2hhaW4gLnVud3JhcCgpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBjb2RlYmxvY2stbWV0YSB0aXRsZT1cIlVzaW5nIC51bndyYXBcIlxuICAgKiBhZGRQb3N0KHsgaWQ6IDEsIG5hbWU6ICdFeGFtcGxlJyB9KVxuICAgKiAgIC51bndyYXAoKVxuICAgKiAgIC50aGVuKChwYXlsb2FkKSA9PiBjb25zb2xlLmxvZygnZnVsZmlsbGVkJywgcGF5bG9hZCkpXG4gICAqICAgLmNhdGNoKChlcnJvcikgPT4gY29uc29sZS5lcnJvcigncmVqZWN0ZWQnLCBlcnJvcikpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgdGl0bGU9XCJVc2luZyAudW53cmFwIHdpdGggYXN5bmMgYXdhaXRcIlxuICAgKiB0cnkge1xuICAgKiAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCBhZGRQb3N0KHsgaWQ6IDEsIG5hbWU6ICdFeGFtcGxlJyB9KS51bndyYXAoKTtcbiAgICogICBjb25zb2xlLmxvZygnZnVsZmlsbGVkJywgcGF5bG9hZClcbiAgICogfSBjYXRjaCAoZXJyb3IpIHtcbiAgICogICBjb25zb2xlLmVycm9yKCdyZWplY3RlZCcsIGVycm9yKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIHVud3JhcCgpOiBQcm9taXNlPFJlc3VsdFR5cGVGcm9tPEQ+PjtcbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRvIG1hbnVhbGx5IHVuc3Vic2NyaWJlIGZyb20gdGhlIG11dGF0aW9uIGNhbGwsIG1lYW5pbmcgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gY2FjaGUgYWZ0ZXIgdGhlIHVzdWFsIGNhY2hpbmcgZ3JhY2UgcGVyaW9kLlxuICAgVGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBob29rIHdpbGwgcmVzZXQgdG8gYGlzVW5pbml0aWFsaXplZGAgYWZ0ZXJ3YXJkcy5cbiAgICovXG4gIHJlc2V0KCk6IHZvaWQ7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkSW5pdGlhdGUoe1xuICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gIHF1ZXJ5VGh1bmssXG4gIGluZmluaXRlUXVlcnlUaHVuayxcbiAgbXV0YXRpb25UaHVuayxcbiAgYXBpLFxuICBjb250ZXh0XG59OiB7XG4gIHNlcmlhbGl6ZVF1ZXJ5QXJnczogSW50ZXJuYWxTZXJpYWxpemVRdWVyeUFyZ3M7XG4gIHF1ZXJ5VGh1bms6IFF1ZXJ5VGh1bms7XG4gIGluZmluaXRlUXVlcnlUaHVuazogSW5maW5pdGVRdWVyeVRodW5rPGFueT47XG4gIG11dGF0aW9uVGh1bms6IE11dGF0aW9uVGh1bms7XG4gIGFwaTogQXBpPGFueSwgRW5kcG9pbnREZWZpbml0aW9ucywgYW55LCBhbnk+O1xuICBjb250ZXh0OiBBcGlDb250ZXh0PEVuZHBvaW50RGVmaW5pdGlvbnM+O1xufSkge1xuICBjb25zdCBydW5uaW5nUXVlcmllczogTWFwPERpc3BhdGNoLCBSZWNvcmQ8c3RyaW5nLCBRdWVyeUFjdGlvbkNyZWF0b3JSZXN1bHQ8YW55PiB8IEluZmluaXRlUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0PGFueT4gfCB1bmRlZmluZWQ+PiA9IG5ldyBNYXAoKTtcbiAgY29uc3QgcnVubmluZ011dGF0aW9uczogTWFwPERpc3BhdGNoLCBSZWNvcmQ8c3RyaW5nLCBNdXRhdGlvbkFjdGlvbkNyZWF0b3JSZXN1bHQ8YW55PiB8IHVuZGVmaW5lZD4+ID0gbmV3IE1hcCgpO1xuICBjb25zdCB7XG4gICAgdW5zdWJzY3JpYmVRdWVyeVJlc3VsdCxcbiAgICByZW1vdmVNdXRhdGlvblJlc3VsdCxcbiAgICB1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zXG4gIH0gPSBhcGkuaW50ZXJuYWxBY3Rpb25zO1xuICByZXR1cm4ge1xuICAgIGJ1aWxkSW5pdGlhdGVRdWVyeSxcbiAgICBidWlsZEluaXRpYXRlSW5maW5pdGVRdWVyeSxcbiAgICBidWlsZEluaXRpYXRlTXV0YXRpb24sXG4gICAgZ2V0UnVubmluZ1F1ZXJ5VGh1bmssXG4gICAgZ2V0UnVubmluZ011dGF0aW9uVGh1bmssXG4gICAgZ2V0UnVubmluZ1F1ZXJpZXNUaHVuayxcbiAgICBnZXRSdW5uaW5nTXV0YXRpb25zVGh1bmtcbiAgfTtcbiAgZnVuY3Rpb24gZ2V0UnVubmluZ1F1ZXJ5VGh1bmsoZW5kcG9pbnROYW1lOiBzdHJpbmcsIHF1ZXJ5QXJnczogYW55KSB7XG4gICAgcmV0dXJuIChkaXNwYXRjaDogRGlzcGF0Y2gpID0+IHtcbiAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgICAgY29uc3QgcXVlcnlDYWNoZUtleSA9IHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAgICAgIHF1ZXJ5QXJncyxcbiAgICAgICAgZW5kcG9pbnREZWZpbml0aW9uLFxuICAgICAgICBlbmRwb2ludE5hbWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJ1bm5pbmdRdWVyaWVzLmdldChkaXNwYXRjaCk/LltxdWVyeUNhY2hlS2V5XSBhcyBRdWVyeUFjdGlvbkNyZWF0b3JSZXN1bHQ8bmV2ZXI+IHwgSW5maW5pdGVRdWVyeUFjdGlvbkNyZWF0b3JSZXN1bHQ8bmV2ZXI+IHwgdW5kZWZpbmVkO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UnVubmluZ011dGF0aW9uVGh1bmsoXG4gIC8qKlxuICAgKiB0aGlzIGlzIG9ubHkgaGVyZSB0byBhbGxvdyBUUyB0byBpbmZlciB0aGUgcmVzdWx0IHR5cGUgYnkgaW5wdXQgdmFsdWVcbiAgICogd2UgY291bGQgdXNlIGl0IHRvIHZhbGlkYXRlIHRoZSByZXN1bHQsIGJ1dCBpdCdzIHByb2JhYmx5IG5vdCBuZWNlc3NhcnlcbiAgICovXG4gIF9lbmRwb2ludE5hbWU6IHN0cmluZywgZml4ZWRDYWNoZUtleU9yUmVxdWVzdElkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gKGRpc3BhdGNoOiBEaXNwYXRjaCkgPT4ge1xuICAgICAgcmV0dXJuIHJ1bm5pbmdNdXRhdGlvbnMuZ2V0KGRpc3BhdGNoKT8uW2ZpeGVkQ2FjaGVLZXlPclJlcXVlc3RJZF0gYXMgTXV0YXRpb25BY3Rpb25DcmVhdG9yUmVzdWx0PG5ldmVyPiB8IHVuZGVmaW5lZDtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldFJ1bm5pbmdRdWVyaWVzVGh1bmsoKSB7XG4gICAgcmV0dXJuIChkaXNwYXRjaDogRGlzcGF0Y2gpID0+IE9iamVjdC52YWx1ZXMocnVubmluZ1F1ZXJpZXMuZ2V0KGRpc3BhdGNoKSB8fCB7fSkuZmlsdGVyKGlzTm90TnVsbGlzaCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UnVubmluZ011dGF0aW9uc1RodW5rKCkge1xuICAgIHJldHVybiAoZGlzcGF0Y2g6IERpc3BhdGNoKSA9PiBPYmplY3QudmFsdWVzKHJ1bm5pbmdNdXRhdGlvbnMuZ2V0KGRpc3BhdGNoKSB8fCB7fSkuZmlsdGVyKGlzTm90TnVsbGlzaCk7XG4gIH1cbiAgZnVuY3Rpb24gbWlkZGxld2FyZVdhcm5pbmcoZGlzcGF0Y2g6IERpc3BhdGNoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICgobWlkZGxld2FyZVdhcm5pbmcgYXMgYW55KS50cmlnZ2VyZWQpIHJldHVybjtcbiAgICAgIGNvbnN0IHJldHVybmVkVmFsdWUgPSBkaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLmludGVybmFsX2dldFJUS1FTdWJzY3JpcHRpb25zKCkpO1xuICAgICAgKG1pZGRsZXdhcmVXYXJuaW5nIGFzIGFueSkudHJpZ2dlcmVkID0gdHJ1ZTtcblxuICAgICAgLy8gVGhlIFJUS1EgbWlkZGxld2FyZSBzaG91bGQgcmV0dXJuIHRoZSBpbnRlcm5hbCBzdGF0ZSBvYmplY3QsXG4gICAgICAvLyBidXQgaXQgc2hvdWxkIF9ub3RfIGJlIHRoZSBhY3Rpb24gb2JqZWN0LlxuICAgICAgaWYgKHR5cGVvZiByZXR1cm5lZFZhbHVlICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcmV0dXJuZWRWYWx1ZT8udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBtdXN0IG5vdCBoYXZlIGJlZW4gYWRkZWRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDM0KSA6IGBXYXJuaW5nOiBNaWRkbGV3YXJlIGZvciBSVEstUXVlcnkgQVBJIGF0IHJlZHVjZXJQYXRoIFwiJHthcGkucmVkdWNlclBhdGh9XCIgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoZSBzdG9yZS5cbllvdSBtdXN0IGFkZCB0aGUgbWlkZGxld2FyZSBmb3IgUlRLLVF1ZXJ5IHRvIGZ1bmN0aW9uIGNvcnJlY3RseSFgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRJbml0aWF0ZUFueVF1ZXJ5PFQgZXh0ZW5kcyAncXVlcnknIHwgJ2luZmluaXRlUXVlcnknPihlbmRwb2ludE5hbWU6IHN0cmluZywgZW5kcG9pbnREZWZpbml0aW9uOiBRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55PiB8IEluZmluaXRlUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55Pikge1xuICAgIGNvbnN0IHF1ZXJ5QWN0aW9uOiBBbnlRdWVyeUFjdGlvbkNyZWF0b3I8YW55PiA9IChhcmcsIHtcbiAgICAgIHN1YnNjcmliZSA9IHRydWUsXG4gICAgICBmb3JjZVJlZmV0Y2gsXG4gICAgICBzdWJzY3JpcHRpb25PcHRpb25zLFxuICAgICAgW2ZvcmNlUXVlcnlGblN5bWJvbF06IGZvcmNlUXVlcnlGbixcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0ge30pID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IHF1ZXJ5Q2FjaGVLZXkgPSBzZXJpYWxpemVRdWVyeUFyZ3Moe1xuICAgICAgICBxdWVyeUFyZ3M6IGFyZyxcbiAgICAgICAgZW5kcG9pbnREZWZpbml0aW9uLFxuICAgICAgICBlbmRwb2ludE5hbWVcbiAgICAgIH0pO1xuICAgICAgbGV0IHRodW5rOiBBc3luY1RodW5rQWN0aW9uPHVua25vd24sIFF1ZXJ5VGh1bmtBcmcsIFRodW5rQXBpTWV0YUNvbmZpZz47XG4gICAgICBjb25zdCBjb21tb25UaHVua0FyZ3MgPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIHR5cGU6ICdxdWVyeScgYXMgY29uc3QsXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZm9yY2VSZWZldGNoOiBmb3JjZVJlZmV0Y2gsXG4gICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnMsXG4gICAgICAgIGVuZHBvaW50TmFtZSxcbiAgICAgICAgb3JpZ2luYWxBcmdzOiBhcmcsXG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgIFtmb3JjZVF1ZXJ5Rm5TeW1ib2xdOiBmb3JjZVF1ZXJ5Rm5cbiAgICAgIH07XG4gICAgICBpZiAoaXNRdWVyeURlZmluaXRpb24oZW5kcG9pbnREZWZpbml0aW9uKSkge1xuICAgICAgICB0aHVuayA9IHF1ZXJ5VGh1bmsoY29tbW9uVGh1bmtBcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgICAgaW5pdGlhbFBhZ2VQYXJhbVxuICAgICAgICB9ID0gcmVzdCBhcyBQaWNrPEluZmluaXRlUXVlcnlUaHVua0FyZzxhbnk+LCAnZGlyZWN0aW9uJyB8ICdpbml0aWFsUGFnZVBhcmFtJz47XG4gICAgICAgIHRodW5rID0gaW5maW5pdGVRdWVyeVRodW5rKHtcbiAgICAgICAgICAuLi4oY29tbW9uVGh1bmtBcmdzIGFzIEluZmluaXRlUXVlcnlUaHVua0FyZzxhbnk+KSxcbiAgICAgICAgICAvLyBTdXBwbHkgdGhlc2UgZXZlbiBpZiB1bmRlZmluZWQuIFRoaXMgaGVscHMgd2l0aCBhIGZpZWxkIGV4aXN0ZW5jZVxuICAgICAgICAgIC8vIGNoZWNrIG92ZXIgaW4gYGJ1aWxkU2xpY2UudHNgXG4gICAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICAgIGluaXRpYWxQYWdlUGFyYW1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzZWxlY3RvciA9IChhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0gYXMgQXBpRW5kcG9pbnRRdWVyeTxhbnksIGFueT4pLnNlbGVjdChhcmcpO1xuICAgICAgY29uc3QgdGh1bmtSZXN1bHQgPSBkaXNwYXRjaCh0aHVuayk7XG4gICAgICBjb25zdCBzdGF0ZUFmdGVyID0gc2VsZWN0b3IoZ2V0U3RhdGUoKSk7XG4gICAgICBtaWRkbGV3YXJlV2FybmluZyhkaXNwYXRjaCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgYWJvcnRcbiAgICAgIH0gPSB0aHVua1Jlc3VsdDtcbiAgICAgIGNvbnN0IHNraXBwZWRTeW5jaHJvbm91c2x5ID0gc3RhdGVBZnRlci5yZXF1ZXN0SWQgIT09IHJlcXVlc3RJZDtcbiAgICAgIGNvbnN0IHJ1bm5pbmdRdWVyeSA9IHJ1bm5pbmdRdWVyaWVzLmdldChkaXNwYXRjaCk/LltxdWVyeUNhY2hlS2V5XTtcbiAgICAgIGNvbnN0IHNlbGVjdEZyb21TdGF0ZSA9ICgpID0+IHNlbGVjdG9yKGdldFN0YXRlKCkpO1xuICAgICAgY29uc3Qgc3RhdGVQcm9taXNlOiBBbnlBY3Rpb25DcmVhdG9yUmVzdWx0ID0gT2JqZWN0LmFzc2lnbigoZm9yY2VRdWVyeUZuID9cbiAgICAgIC8vIGEgcXVlcnkgaGFzIGJlZW4gZm9yY2VkICh1cHNlcnRRdWVyeURhdGEpXG4gICAgICAvLyAtPiB3ZSB3YW50IHRvIHJlc29sdmUgaXQgb25jZSBkYXRhIGhhcyBiZWVuIHdyaXR0ZW4gd2l0aCB0aGUgZGF0YSB0aGF0IHdpbGwgYmUgd3JpdHRlblxuICAgICAgdGh1bmtSZXN1bHQudGhlbihzZWxlY3RGcm9tU3RhdGUpIDogc2tpcHBlZFN5bmNocm9ub3VzbHkgJiYgIXJ1bm5pbmdRdWVyeSA/XG4gICAgICAvLyBhIHF1ZXJ5IGhhcyBiZWVuIHNraXBwZWQgZHVlIHRvIGEgY29uZGl0aW9uIGFuZCB3ZSBkbyBub3QgaGF2ZSBhbnkgY3VycmVudGx5IHJ1bm5pbmcgcXVlcnlcbiAgICAgIC8vIC0+IHdlIHdhbnQgdG8gcmVzb2x2ZSBpdCBpbW1lZGlhdGVseSB3aXRoIHRoZSBjdXJyZW50IGRhdGFcbiAgICAgIFByb21pc2UucmVzb2x2ZShzdGF0ZUFmdGVyKSA6XG4gICAgICAvLyBxdWVyeSBqdXN0IHN0YXJ0ZWQgb3Igb25lIGlzIGFscmVhZHkgaW4gZmxpZ2h0XG4gICAgICAvLyAtPiB3YWl0IGZvciB0aGUgcnVubmluZyBxdWVyeSwgdGhlbiByZXNvbHZlIHdpdGggZGF0YSBmcm9tIGFmdGVyIHRoYXRcbiAgICAgIFByb21pc2UuYWxsKFtydW5uaW5nUXVlcnksIHRodW5rUmVzdWx0XSkudGhlbihzZWxlY3RGcm9tU3RhdGUpKSBhcyBTYWZlUHJvbWlzZTxhbnk+LCB7XG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBzdWJzY3JpcHRpb25PcHRpb25zLFxuICAgICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgYXN5bmMgdW53cmFwKCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0YXRlUHJvbWlzZTtcbiAgICAgICAgICBpZiAocmVzdWx0LmlzRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB9LFxuICAgICAgICByZWZldGNoOiAoKSA9PiBkaXNwYXRjaChxdWVyeUFjdGlvbihhcmcsIHtcbiAgICAgICAgICBzdWJzY3JpYmU6IGZhbHNlLFxuICAgICAgICAgIGZvcmNlUmVmZXRjaDogdHJ1ZVxuICAgICAgICB9KSksXG4gICAgICAgIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgIGlmIChzdWJzY3JpYmUpIGRpc3BhdGNoKHVuc3Vic2NyaWJlUXVlcnlSZXN1bHQoe1xuICAgICAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucyhvcHRpb25zOiBTdWJzY3JpcHRpb25PcHRpb25zKSB7XG4gICAgICAgICAgc3RhdGVQcm9taXNlLnN1YnNjcmlwdGlvbk9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgIGRpc3BhdGNoKHVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMoe1xuICAgICAgICAgICAgZW5kcG9pbnROYW1lLFxuICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFydW5uaW5nUXVlcnkgJiYgIXNraXBwZWRTeW5jaHJvbm91c2x5ICYmICFmb3JjZVF1ZXJ5Rm4pIHtcbiAgICAgICAgY29uc3QgcnVubmluZyA9IGdldE9ySW5zZXJ0KHJ1bm5pbmdRdWVyaWVzLCBkaXNwYXRjaCwge30pO1xuICAgICAgICBydW5uaW5nW3F1ZXJ5Q2FjaGVLZXldID0gc3RhdGVQcm9taXNlO1xuICAgICAgICBzdGF0ZVByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgZGVsZXRlIHJ1bm5pbmdbcXVlcnlDYWNoZUtleV07XG4gICAgICAgICAgaWYgKCFjb3VudE9iamVjdEtleXMocnVubmluZykpIHtcbiAgICAgICAgICAgIHJ1bm5pbmdRdWVyaWVzLmRlbGV0ZShkaXNwYXRjaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0ZVByb21pc2U7XG4gICAgfTtcbiAgICByZXR1cm4gcXVlcnlBY3Rpb247XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRJbml0aWF0ZVF1ZXJ5KGVuZHBvaW50TmFtZTogc3RyaW5nLCBlbmRwb2ludERlZmluaXRpb246IFF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+KSB7XG4gICAgY29uc3QgcXVlcnlBY3Rpb246IFN0YXJ0UXVlcnlBY3Rpb25DcmVhdG9yPGFueT4gPSBidWlsZEluaXRpYXRlQW55UXVlcnkoZW5kcG9pbnROYW1lLCBlbmRwb2ludERlZmluaXRpb24pO1xuICAgIHJldHVybiBxdWVyeUFjdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBidWlsZEluaXRpYXRlSW5maW5pdGVRdWVyeShlbmRwb2ludE5hbWU6IHN0cmluZywgZW5kcG9pbnREZWZpbml0aW9uOiBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4pIHtcbiAgICBjb25zdCBpbmZpbml0ZVF1ZXJ5QWN0aW9uOiBTdGFydEluZmluaXRlUXVlcnlBY3Rpb25DcmVhdG9yPGFueT4gPSBidWlsZEluaXRpYXRlQW55UXVlcnkoZW5kcG9pbnROYW1lLCBlbmRwb2ludERlZmluaXRpb24pO1xuICAgIHJldHVybiBpbmZpbml0ZVF1ZXJ5QWN0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkSW5pdGlhdGVNdXRhdGlvbihlbmRwb2ludE5hbWU6IHN0cmluZyk6IFN0YXJ0TXV0YXRpb25BY3Rpb25DcmVhdG9yPGFueT4ge1xuICAgIHJldHVybiAoYXJnLCB7XG4gICAgICB0cmFjayA9IHRydWUsXG4gICAgICBmaXhlZENhY2hlS2V5XG4gICAgfSA9IHt9KSA9PiAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgICBjb25zdCB0aHVuayA9IG11dGF0aW9uVGh1bmsoe1xuICAgICAgICB0eXBlOiAnbXV0YXRpb24nLFxuICAgICAgICBlbmRwb2ludE5hbWUsXG4gICAgICAgIG9yaWdpbmFsQXJnczogYXJnLFxuICAgICAgICB0cmFjayxcbiAgICAgICAgZml4ZWRDYWNoZUtleVxuICAgICAgfSk7XG4gICAgICBjb25zdCB0aHVua1Jlc3VsdCA9IGRpc3BhdGNoKHRodW5rKTtcbiAgICAgIG1pZGRsZXdhcmVXYXJuaW5nKGRpc3BhdGNoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgdW53cmFwXG4gICAgICB9ID0gdGh1bmtSZXN1bHQ7XG4gICAgICBjb25zdCByZXR1cm5WYWx1ZVByb21pc2UgPSBhc1NhZmVQcm9taXNlKHRodW5rUmVzdWx0LnVud3JhcCgpLnRoZW4oZGF0YSA9PiAoe1xuICAgICAgICBkYXRhXG4gICAgICB9KSksIGVycm9yID0+ICh7XG4gICAgICAgIGVycm9yXG4gICAgICB9KSk7XG4gICAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2gocmVtb3ZlTXV0YXRpb25SZXN1bHQoe1xuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBmaXhlZENhY2hlS2V5XG4gICAgICAgIH0pKTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXQgPSBPYmplY3QuYXNzaWduKHJldHVyblZhbHVlUHJvbWlzZSwge1xuICAgICAgICBhcmc6IHRodW5rUmVzdWx0LmFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgdW53cmFwLFxuICAgICAgICByZXNldFxuICAgICAgfSk7XG4gICAgICBjb25zdCBydW5uaW5nID0gcnVubmluZ011dGF0aW9ucy5nZXQoZGlzcGF0Y2gpIHx8IHt9O1xuICAgICAgcnVubmluZ011dGF0aW9ucy5zZXQoZGlzcGF0Y2gsIHJ1bm5pbmcpO1xuICAgICAgcnVubmluZ1tyZXF1ZXN0SWRdID0gcmV0O1xuICAgICAgcmV0LnRoZW4oKCkgPT4ge1xuICAgICAgICBkZWxldGUgcnVubmluZ1tyZXF1ZXN0SWRdO1xuICAgICAgICBpZiAoIWNvdW50T2JqZWN0S2V5cyhydW5uaW5nKSkge1xuICAgICAgICAgIHJ1bm5pbmdNdXRhdGlvbnMuZGVsZXRlKGRpc3BhdGNoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZml4ZWRDYWNoZUtleSkge1xuICAgICAgICBydW5uaW5nW2ZpeGVkQ2FjaGVLZXldID0gcmV0O1xuICAgICAgICByZXQudGhlbigoKSA9PiB7XG4gICAgICAgICAgaWYgKHJ1bm5pbmdbZml4ZWRDYWNoZUtleV0gPT09IHJldCkge1xuICAgICAgICAgICAgZGVsZXRlIHJ1bm5pbmdbZml4ZWRDYWNoZUtleV07XG4gICAgICAgICAgICBpZiAoIWNvdW50T2JqZWN0S2V5cyhydW5uaW5nKSkge1xuICAgICAgICAgICAgICBydW5uaW5nTXV0YXRpb25zLmRlbGV0ZShkaXNwYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfVxufSIsImltcG9ydCB0eXBlIHsgTWlkZGxld2FyZSwgU3RvcmVFbmhhbmNlciB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB0eXBlIHsgVHVwbGUgfSBmcm9tICcuL3V0aWxzJztcbmV4cG9ydCBmdW5jdGlvbiBzYWZlQXNzaWduPFQgZXh0ZW5kcyBvYmplY3Q+KHRhcmdldDogVCwgLi4uYXJnczogQXJyYXk8UGFydGlhbDxOb0luZmVyPFQ+Pj4pIHtcbiAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIC4uLmFyZ3MpO1xufVxuXG4vKipcbiAqIHJldHVybiBUcnVlIGlmIFQgaXMgYGFueWAsIG90aGVyd2lzZSByZXR1cm4gRmFsc2VcbiAqIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pvb25ob2Noby90c2RlZlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdHlwZSBJc0FueTxULCBUcnVlLCBGYWxzZSA9IG5ldmVyPiA9XG4vLyB0ZXN0IGlmIHdlIGFyZSBnb2luZyB0aGUgbGVmdCBBTkQgcmlnaHQgcGF0aCBpbiB0aGUgY29uZGl0aW9uXG50cnVlIHwgZmFsc2UgZXh0ZW5kcyAoVCBleHRlbmRzIG5ldmVyID8gdHJ1ZSA6IGZhbHNlKSA/IFRydWUgOiBGYWxzZTtcbmV4cG9ydCB0eXBlIENhc3RBbnk8VCwgQ2FzdFRvPiA9IElzQW55PFQsIENhc3RUbywgVD47XG5cbi8qKlxuICogcmV0dXJuIFRydWUgaWYgVCBpcyBgdW5rbm93bmAsIG90aGVyd2lzZSByZXR1cm4gRmFsc2VcbiAqIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pvb25ob2Noby90c2RlZlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdHlwZSBJc1Vua25vd248VCwgVHJ1ZSwgRmFsc2UgPSBuZXZlcj4gPSB1bmtub3duIGV4dGVuZHMgVCA/IElzQW55PFQsIEZhbHNlLCBUcnVlPiA6IEZhbHNlO1xuZXhwb3J0IHR5cGUgRmFsbGJhY2tJZlVua25vd248VCwgRmFsbGJhY2s+ID0gSXNVbmtub3duPFQsIEZhbGxiYWNrLCBUPjtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgSWZNYXliZVVuZGVmaW5lZDxQLCBUcnVlLCBGYWxzZT4gPSBbdW5kZWZpbmVkXSBleHRlbmRzIFtQXSA/IFRydWUgOiBGYWxzZTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgSWZWb2lkPFAsIFRydWUsIEZhbHNlPiA9IFt2b2lkXSBleHRlbmRzIFtQXSA/IFRydWUgOiBGYWxzZTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgSXNFbXB0eU9iajxULCBUcnVlLCBGYWxzZSA9IG5ldmVyPiA9IFQgZXh0ZW5kcyBhbnkgPyBrZXlvZiBUIGV4dGVuZHMgbmV2ZXIgPyBJc1Vua25vd248VCwgRmFsc2UsIElmTWF5YmVVbmRlZmluZWQ8VCwgRmFsc2UsIElmVm9pZDxULCBGYWxzZSwgVHJ1ZT4+PiA6IEZhbHNlIDogbmV2ZXI7XG5cbi8qKlxuICogcmV0dXJucyBUcnVlIGlmIFRTIHZlcnNpb24gaXMgYWJvdmUgMy41LCBGYWxzZSBpZiBiZWxvdy5cbiAqIHVzZXMgZmVhdHVyZSBkZXRlY3Rpb24gdG8gZGV0ZWN0IFRTIHZlcnNpb24gPj0gMy41XG4gKiAqIHZlcnNpb25zIGJlbG93IDMuNSB3aWxsIHJldHVybiBge31gIGZvciB1bnJlc29sdmFibGUgaW50ZXJmZXJlbmNlXG4gKiAqIHZlcnNpb25zIGFib3ZlIHdpbGwgcmV0dXJuIGB1bmtub3duYFxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdHlwZSBBdExlYXN0VFMzNTxUcnVlLCBGYWxzZT4gPSBbVHJ1ZSwgRmFsc2VdW0lzVW5rbm93bjxSZXR1cm5UeXBlPDxUPigpID0+IFQ+LCAwLCAxPl07XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCB0eXBlIElzVW5rbm93bk9yTm9uSW5mZXJyYWJsZTxULCBUcnVlLCBGYWxzZT4gPSBBdExlYXN0VFMzNTxJc1Vua25vd248VCwgVHJ1ZSwgRmFsc2U+LCBJc0VtcHR5T2JqPFQsIFRydWUsIElzVW5rbm93bjxULCBUcnVlLCBGYWxzZT4+PjtcblxuLyoqXG4gKiBDb252ZXJ0IGEgVW5pb24gdHlwZSBgKEF8QilgIHRvIGFuIGludGVyc2VjdGlvbiB0eXBlIGAoQSZCKWBcbiAqL1xuZXhwb3J0IHR5cGUgVW5pb25Ub0ludGVyc2VjdGlvbjxVPiA9IChVIGV4dGVuZHMgYW55ID8gKGs6IFUpID0+IHZvaWQgOiBuZXZlcikgZXh0ZW5kcyAoKGs6IGluZmVyIEkpID0+IHZvaWQpID8gSSA6IG5ldmVyO1xuXG4vLyBBcHBlYXJzIHRvIGhhdmUgYSBjb252ZW5pZW50IHNpZGUgZWZmZWN0IG9mIGlnbm9yaW5nIGBuZXZlcmAgZXZlbiBpZiB0aGF0J3Mgbm90IHdoYXQgeW91IHNwZWNpZmllZFxuZXhwb3J0IHR5cGUgRXhjbHVkZUZyb21UdXBsZTxULCBFLCBBY2MgZXh0ZW5kcyB1bmtub3duW10gPSBbXT4gPSBUIGV4dGVuZHMgW2luZmVyIEhlYWQsIC4uLmluZmVyIFRhaWxdID8gRXhjbHVkZUZyb21UdXBsZTxUYWlsLCBFLCBbLi4uQWNjLCAuLi4oW0hlYWRdIGV4dGVuZHMgW0VdID8gW10gOiBbSGVhZF0pXT4gOiBBY2M7XG50eXBlIEV4dHJhY3REaXNwYXRjaEZyb21NaWRkbGV3YXJlVHVwbGU8TWlkZGxld2FyZVR1cGxlIGV4dGVuZHMgcmVhZG9ubHkgYW55W10sIEFjYyBleHRlbmRzIHt9PiA9IE1pZGRsZXdhcmVUdXBsZSBleHRlbmRzIFtpbmZlciBIZWFkLCAuLi5pbmZlciBUYWlsXSA/IEV4dHJhY3REaXNwYXRjaEZyb21NaWRkbGV3YXJlVHVwbGU8VGFpbCwgQWNjICYgKEhlYWQgZXh0ZW5kcyBNaWRkbGV3YXJlPGluZmVyIEQ+ID8gSXNBbnk8RCwge30sIEQ+IDoge30pPiA6IEFjYztcbmV4cG9ydCB0eXBlIEV4dHJhY3REaXNwYXRjaEV4dGVuc2lvbnM8TT4gPSBNIGV4dGVuZHMgVHVwbGU8aW5mZXIgTWlkZGxld2FyZVR1cGxlPiA/IEV4dHJhY3REaXNwYXRjaEZyb21NaWRkbGV3YXJlVHVwbGU8TWlkZGxld2FyZVR1cGxlLCB7fT4gOiBNIGV4dGVuZHMgUmVhZG9ubHlBcnJheTxNaWRkbGV3YXJlPiA/IEV4dHJhY3REaXNwYXRjaEZyb21NaWRkbGV3YXJlVHVwbGU8Wy4uLk1dLCB7fT4gOiBuZXZlcjtcbnR5cGUgRXh0cmFjdFN0b3JlRXh0ZW5zaW9uc0Zyb21FbmhhbmNlclR1cGxlPEVuaGFuY2VyVHVwbGUgZXh0ZW5kcyByZWFkb25seSBhbnlbXSwgQWNjIGV4dGVuZHMge30+ID0gRW5oYW5jZXJUdXBsZSBleHRlbmRzIFtpbmZlciBIZWFkLCAuLi5pbmZlciBUYWlsXSA/IEV4dHJhY3RTdG9yZUV4dGVuc2lvbnNGcm9tRW5oYW5jZXJUdXBsZTxUYWlsLCBBY2MgJiAoSGVhZCBleHRlbmRzIFN0b3JlRW5oYW5jZXI8aW5mZXIgRXh0PiA/IElzQW55PEV4dCwge30sIEV4dD4gOiB7fSk+IDogQWNjO1xuZXhwb3J0IHR5cGUgRXh0cmFjdFN0b3JlRXh0ZW5zaW9uczxFPiA9IEUgZXh0ZW5kcyBUdXBsZTxpbmZlciBFbmhhbmNlclR1cGxlPiA/IEV4dHJhY3RTdG9yZUV4dGVuc2lvbnNGcm9tRW5oYW5jZXJUdXBsZTxFbmhhbmNlclR1cGxlLCB7fT4gOiBFIGV4dGVuZHMgUmVhZG9ubHlBcnJheTxTdG9yZUVuaGFuY2VyPiA/IFVuaW9uVG9JbnRlcnNlY3Rpb248RVtudW1iZXJdIGV4dGVuZHMgU3RvcmVFbmhhbmNlcjxpbmZlciBFeHQ+ID8gRXh0IGV4dGVuZHMge30gPyBJc0FueTxFeHQsIHt9LCBFeHQ+IDoge30gOiB7fT4gOiBuZXZlcjtcbnR5cGUgRXh0cmFjdFN0YXRlRXh0ZW5zaW9uc0Zyb21FbmhhbmNlclR1cGxlPEVuaGFuY2VyVHVwbGUgZXh0ZW5kcyByZWFkb25seSBhbnlbXSwgQWNjIGV4dGVuZHMge30+ID0gRW5oYW5jZXJUdXBsZSBleHRlbmRzIFtpbmZlciBIZWFkLCAuLi5pbmZlciBUYWlsXSA/IEV4dHJhY3RTdGF0ZUV4dGVuc2lvbnNGcm9tRW5oYW5jZXJUdXBsZTxUYWlsLCBBY2MgJiAoSGVhZCBleHRlbmRzIFN0b3JlRW5oYW5jZXI8YW55LCBpbmZlciBTdGF0ZUV4dD4gPyBJc0FueTxTdGF0ZUV4dCwge30sIFN0YXRlRXh0PiA6IHt9KT4gOiBBY2M7XG5leHBvcnQgdHlwZSBFeHRyYWN0U3RhdGVFeHRlbnNpb25zPEU+ID0gRSBleHRlbmRzIFR1cGxlPGluZmVyIEVuaGFuY2VyVHVwbGU+ID8gRXh0cmFjdFN0YXRlRXh0ZW5zaW9uc0Zyb21FbmhhbmNlclR1cGxlPEVuaGFuY2VyVHVwbGUsIHt9PiA6IEUgZXh0ZW5kcyBSZWFkb25seUFycmF5PFN0b3JlRW5oYW5jZXI+ID8gVW5pb25Ub0ludGVyc2VjdGlvbjxFW251bWJlcl0gZXh0ZW5kcyBTdG9yZUVuaGFuY2VyPGFueSwgaW5mZXIgU3RhdGVFeHQ+ID8gU3RhdGVFeHQgZXh0ZW5kcyB7fSA/IElzQW55PFN0YXRlRXh0LCB7fSwgU3RhdGVFeHQ+IDoge30gOiB7fT4gOiBuZXZlcjtcblxuLyoqXG4gKiBIZWxwZXIgdHlwZS4gUGFzc2VzIFQgb3V0IGFnYWluLCBidXQgYm94ZXMgaXQgaW4gYSB3YXkgdGhhdCBpdCBjYW5ub3RcbiAqIFwid2lkZW5cIiB0aGUgdHlwZSBieSBhY2NpZGVudCBpZiBpdCBpcyBhIGdlbmVyaWMgdGhhdCBzaG91bGQgYmUgaW5mZXJyZWRcbiAqIGZyb20gZWxzZXdoZXJlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdHlwZSBOb0luZmVyPFQ+ID0gW1RdW1QgZXh0ZW5kcyBhbnkgPyAwIDogbmV2ZXJdO1xuZXhwb3J0IHR5cGUgTm9uVW5kZWZpbmVkPFQ+ID0gVCBleHRlbmRzIHVuZGVmaW5lZCA/IG5ldmVyIDogVDtcbmV4cG9ydCB0eXBlIFdpdGhSZXF1aXJlZFByb3A8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gT21pdDxULCBLPiAmIFJlcXVpcmVkPFBpY2s8VCwgSz4+O1xuZXhwb3J0IHR5cGUgV2l0aE9wdGlvbmFsUHJvcDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBPbWl0PFQsIEs+ICYgUGFydGlhbDxQaWNrPFQsIEs+PjtcbmV4cG9ydCBpbnRlcmZhY2UgVHlwZUd1YXJkPFQ+IHtcbiAgKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBUO1xufVxuZXhwb3J0IGludGVyZmFjZSBIYXNNYXRjaEZ1bmN0aW9uPFQ+IHtcbiAgbWF0Y2g6IFR5cGVHdWFyZDxUPjtcbn1cbmV4cG9ydCBjb25zdCBoYXNNYXRjaEZ1bmN0aW9uID0gPFQsPih2OiBNYXRjaGVyPFQ+KTogdiBpcyBIYXNNYXRjaEZ1bmN0aW9uPFQ+ID0+IHtcbiAgcmV0dXJuIHYgJiYgdHlwZW9mICh2IGFzIEhhc01hdGNoRnVuY3Rpb248VD4pLm1hdGNoID09PSAnZnVuY3Rpb24nO1xufTtcblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCB0eXBlIE1hdGNoZXI8VD4gPSBIYXNNYXRjaEZ1bmN0aW9uPFQ+IHwgVHlwZUd1YXJkPFQ+O1xuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IHR5cGUgQWN0aW9uRnJvbU1hdGNoZXI8TSBleHRlbmRzIE1hdGNoZXI8YW55Pj4gPSBNIGV4dGVuZHMgTWF0Y2hlcjxpbmZlciBUPiA/IFQgOiBuZXZlcjtcbmV4cG9ydCB0eXBlIElkPFQ+ID0geyBbSyBpbiBrZXlvZiBUXTogVFtLXSB9ICYge307XG5leHBvcnQgdHlwZSBUYWlsPFQgZXh0ZW5kcyBhbnlbXT4gPSBUIGV4dGVuZHMgW2FueSwgLi4uaW5mZXIgVGFpbF0gPyBUYWlsIDogbmV2ZXI7XG5leHBvcnQgdHlwZSBVbmtub3duSWZOb25TcGVjaWZpYzxUPiA9IHt9IGV4dGVuZHMgVCA/IHVua25vd24gOiBUO1xuXG4vKipcbiAqIEEgUHJvbWlzZSB0aGF0IHdpbGwgbmV2ZXIgcmVqZWN0LlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVkdXhqcy9yZWR1eC10b29sa2l0L2lzc3Vlcy80MTAxXG4gKi9cbmV4cG9ydCB0eXBlIFNhZmVQcm9taXNlPFQ+ID0gUHJvbWlzZTxUPiAmIHtcbiAgX19saW50ZXJCcmFuZHM6ICdTYWZlUHJvbWlzZSc7XG59O1xuXG4vKipcbiAqIFByb3Blcmx5IHdyYXBzIGEgUHJvbWlzZSBhcyBhIHtAbGluayBTYWZlUHJvbWlzZX0gd2l0aCAuY2F0Y2goZmFsbGJhY2spLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNTYWZlUHJvbWlzZTxSZXNvbHZlZCwgUmVqZWN0ZWQ+KHByb21pc2U6IFByb21pc2U8UmVzb2x2ZWQ+LCBmYWxsYmFjazogKGVycm9yOiB1bmtub3duKSA9PiBSZWplY3RlZCkge1xuICByZXR1cm4gcHJvbWlzZS5jYXRjaChmYWxsYmFjaykgYXMgU2FmZVByb21pc2U8UmVzb2x2ZWQgfCBSZWplY3RlZD47XG59IiwiaW1wb3J0IHR5cGUgeyBTdGFuZGFyZFNjaGVtYVYxIH0gZnJvbSAnQHN0YW5kYXJkLXNjaGVtYS9zcGVjJztcbmltcG9ydCB7IFNjaGVtYUVycm9yIH0gZnJvbSAnQHN0YW5kYXJkLXNjaGVtYS91dGlscyc7XG5leHBvcnQgY2xhc3MgTmFtZWRTY2hlbWFFcnJvciBleHRlbmRzIFNjaGVtYUVycm9yIHtcbiAgY29uc3RydWN0b3IoaXNzdWVzOiByZWFkb25seSBTdGFuZGFyZFNjaGVtYVYxLklzc3VlW10sIHB1YmxpYyByZWFkb25seSB2YWx1ZTogYW55LCBwdWJsaWMgcmVhZG9ubHkgc2NoZW1hTmFtZTogc3RyaW5nLCBwdWJsaWMgcmVhZG9ubHkgX2JxTWV0YTogYW55KSB7XG4gICAgc3VwZXIoaXNzdWVzKTtcbiAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlV2l0aFNjaGVtYTxTY2hlbWEgZXh0ZW5kcyBTdGFuZGFyZFNjaGVtYVYxPihzY2hlbWE6IFNjaGVtYSwgZGF0YTogdW5rbm93biwgc2NoZW1hTmFtZTogc3RyaW5nLCBicU1ldGE6IGFueSk6IFByb21pc2U8U3RhbmRhcmRTY2hlbWFWMS5JbmZlck91dHB1dDxTY2hlbWE+PiB7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNjaGVtYVsnfnN0YW5kYXJkJ10udmFsaWRhdGUoZGF0YSk7XG4gIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgdGhyb3cgbmV3IE5hbWVkU2NoZW1hRXJyb3IocmVzdWx0Lmlzc3VlcywgZGF0YSwgc2NoZW1hTmFtZSwgYnFNZXRhKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufSIsImltcG9ydCB0eXBlIHsgUGF5bG9hZEFjdGlvbiB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzLCBjcmVhdGVBY3Rpb24sIGNyZWF0ZVNsaWNlLCBpc0FueU9mLCBpc0Z1bGZpbGxlZCwgaXNSZWplY3RlZFdpdGhWYWx1ZSwgY3JlYXRlTmV4dFN0YXRlLCBwcmVwYXJlQXV0b0JhdGNoZWQsIFNIT1VMRF9BVVRPQkFUQ0gsIG5hbm9pZCB9IGZyb20gJy4vcnRrSW1wb3J0cyc7XG5pbXBvcnQgdHlwZSB7IFF1ZXJ5U3Vic3RhdGVJZGVudGlmaWVyLCBRdWVyeVN1YlN0YXRlLCBNdXRhdGlvblN1YnN0YXRlSWRlbnRpZmllciwgTXV0YXRpb25TdWJTdGF0ZSwgTXV0YXRpb25TdGF0ZSwgUXVlcnlTdGF0ZSwgSW52YWxpZGF0aW9uU3RhdGUsIFN1YnNjcmliZXJzLCBRdWVyeUNhY2hlS2V5LCBTdWJzY3JpcHRpb25TdGF0ZSwgQ29uZmlnU3RhdGUsIEluZmluaXRlUXVlcnlTdWJTdGF0ZSwgSW5maW5pdGVRdWVyeURpcmVjdGlvbiB9IGZyb20gJy4vYXBpU3RhdGUnO1xuaW1wb3J0IHsgUXVlcnlTdGF0dXMgfSBmcm9tICcuL2FwaVN0YXRlJztcbmltcG9ydCB0eXBlIHsgQWxsUXVlcnlLZXlzLCBRdWVyeUFyZ0Zyb21BbnlRdWVyeURlZmluaXRpb24sIERhdGFGcm9tQW55UXVlcnlEZWZpbml0aW9uLCBJbmZpbml0ZVF1ZXJ5VGh1bmssIE11dGF0aW9uVGh1bmssIFF1ZXJ5VGh1bmssIFF1ZXJ5VGh1bmtBcmcgfSBmcm9tICcuL2J1aWxkVGh1bmtzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVByb3ZpZGVkQnlUaHVuayB9IGZyb20gJy4vYnVpbGRUaHVua3MnO1xuaW1wb3J0IHsgaXNJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbiwgdHlwZSBBc3NlcnRUYWdUeXBlcywgdHlwZSBFbmRwb2ludERlZmluaXRpb25zLCB0eXBlIEZ1bGxUYWdEZXNjcmlwdGlvbiwgdHlwZSBRdWVyeURlZmluaXRpb24gfSBmcm9tICcuLi9lbmRwb2ludERlZmluaXRpb25zJztcbmltcG9ydCB0eXBlIHsgUGF0Y2ggfSBmcm9tICdpbW1lcic7XG5pbXBvcnQgeyBpc0RyYWZ0IH0gZnJvbSAnaW1tZXInO1xuaW1wb3J0IHsgYXBwbHlQYXRjaGVzLCBvcmlnaW5hbCB9IGZyb20gJ2ltbWVyJztcbmltcG9ydCB7IG9uRm9jdXMsIG9uRm9jdXNMb3N0LCBvbk9mZmxpbmUsIG9uT25saW5lIH0gZnJvbSAnLi9zZXR1cExpc3RlbmVycyc7XG5pbXBvcnQgeyBpc0RvY3VtZW50VmlzaWJsZSwgaXNPbmxpbmUsIGNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmcgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IEFwaUNvbnRleHQgfSBmcm9tICcuLi9hcGlUeXBlcyc7XG5pbXBvcnQgeyBpc1Vwc2VydFF1ZXJ5IH0gZnJvbSAnLi9idWlsZEluaXRpYXRlJztcbmltcG9ydCB0eXBlIHsgSW50ZXJuYWxTZXJpYWxpemVRdWVyeUFyZ3MgfSBmcm9tICcuLi9kZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzJztcbmltcG9ydCB0eXBlIHsgVW53cmFwUHJvbWlzZSB9IGZyb20gJy4uL3RzSGVscGVycyc7XG5cbi8qKlxuICogQSB0eXBlc2FmZSBzaW5nbGUgZW50cnkgdG8gYmUgdXBzZXJ0ZWQgaW50byB0aGUgY2FjaGVcbiAqL1xuZXhwb3J0IHR5cGUgTm9ybWFsaXplZFF1ZXJ5VXBzZXJ0RW50cnk8RGVmaW5pdGlvbnMgZXh0ZW5kcyBFbmRwb2ludERlZmluaXRpb25zLCBFbmRwb2ludE5hbWUgZXh0ZW5kcyBBbGxRdWVyeUtleXM8RGVmaW5pdGlvbnM+PiA9IHtcbiAgZW5kcG9pbnROYW1lOiBFbmRwb2ludE5hbWU7XG4gIGFyZzogUXVlcnlBcmdGcm9tQW55UXVlcnlEZWZpbml0aW9uPERlZmluaXRpb25zLCBFbmRwb2ludE5hbWU+O1xuICB2YWx1ZTogRGF0YUZyb21BbnlRdWVyeURlZmluaXRpb248RGVmaW5pdGlvbnMsIEVuZHBvaW50TmFtZT47XG59O1xuXG4vKipcbiAqIFRoZSBpbnRlcm5hbCB2ZXJzaW9uIHRoYXQgaXMgbm90IHR5cGVzYWZlIHNpbmNlIHdlIGNhbid0IGNhcnJ5IHRoZSBnZW5lcmljcyB0aHJvdWdoIGBjcmVhdGVTbGljZWBcbiAqL1xudHlwZSBOb3JtYWxpemVkUXVlcnlVcHNlcnRFbnRyeVBheWxvYWQgPSB7XG4gIGVuZHBvaW50TmFtZTogc3RyaW5nO1xuICBhcmc6IHVua25vd247XG4gIHZhbHVlOiB1bmtub3duO1xufTtcbmV4cG9ydCB0eXBlIFByb2Nlc3NlZFF1ZXJ5VXBzZXJ0RW50cnkgPSB7XG4gIHF1ZXJ5RGVzY3JpcHRpb246IFF1ZXJ5VGh1bmtBcmc7XG4gIHZhbHVlOiB1bmtub3duO1xufTtcblxuLyoqXG4gKiBBIHR5cGVzYWZlIHJlcHJlc2VudGF0aW9uIG9mIGEgdXRpbCBhY3Rpb24gY3JlYXRvciB0aGF0IGFjY2VwdHMgY2FjaGUgZW50cnkgZGVzY3JpcHRpb25zIHRvIHVwc2VydFxuICovXG5leHBvcnQgdHlwZSBVcHNlcnRFbnRyaWVzPERlZmluaXRpb25zIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9ucz4gPSAoPEVuZHBvaW50TmFtZXMgZXh0ZW5kcyBBcnJheTxBbGxRdWVyeUtleXM8RGVmaW5pdGlvbnM+Pj4oZW50cmllczogWy4uLnsgW0kgaW4ga2V5b2YgRW5kcG9pbnROYW1lc106IE5vcm1hbGl6ZWRRdWVyeVVwc2VydEVudHJ5PERlZmluaXRpb25zLCBFbmRwb2ludE5hbWVzW0ldPiB9XSkgPT4gUGF5bG9hZEFjdGlvbjxOb3JtYWxpemVkUXVlcnlVcHNlcnRFbnRyeVBheWxvYWRbXT4pICYge1xuICBtYXRjaDogKGFjdGlvbjogdW5rbm93bikgPT4gYWN0aW9uIGlzIFBheWxvYWRBY3Rpb248Tm9ybWFsaXplZFF1ZXJ5VXBzZXJ0RW50cnlQYXlsb2FkW10+O1xufTtcbmZ1bmN0aW9uIHVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyhzdGF0ZTogUXVlcnlTdGF0ZTxhbnk+LCBxdWVyeUNhY2hlS2V5OiBRdWVyeUNhY2hlS2V5LCB1cGRhdGU6IChzdWJzdGF0ZTogUXVlcnlTdWJTdGF0ZTxhbnk+IHwgSW5maW5pdGVRdWVyeVN1YlN0YXRlPGFueT4pID0+IHZvaWQpIHtcbiAgY29uc3Qgc3Vic3RhdGUgPSBzdGF0ZVtxdWVyeUNhY2hlS2V5XTtcbiAgaWYgKHN1YnN0YXRlKSB7XG4gICAgdXBkYXRlKHN1YnN0YXRlKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE11dGF0aW9uQ2FjaGVLZXkoaWQ6IE11dGF0aW9uU3Vic3RhdGVJZGVudGlmaWVyIHwge1xuICByZXF1ZXN0SWQ6IHN0cmluZztcbiAgYXJnOiB7XG4gICAgZml4ZWRDYWNoZUtleT86IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgfTtcbn0pOiBzdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0TXV0YXRpb25DYWNoZUtleShpZDoge1xuICBmaXhlZENhY2hlS2V5Pzogc3RyaW5nO1xuICByZXF1ZXN0SWQ/OiBzdHJpbmc7XG59KTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuZXhwb3J0IGZ1bmN0aW9uIGdldE11dGF0aW9uQ2FjaGVLZXkoaWQ6IHtcbiAgZml4ZWRDYWNoZUtleT86IHN0cmluZztcbiAgcmVxdWVzdElkPzogc3RyaW5nO1xufSB8IE11dGF0aW9uU3Vic3RhdGVJZGVudGlmaWVyIHwge1xuICByZXF1ZXN0SWQ6IHN0cmluZztcbiAgYXJnOiB7XG4gICAgZml4ZWRDYWNoZUtleT86IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgfTtcbn0pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICByZXR1cm4gKCdhcmcnIGluIGlkID8gaWQuYXJnLmZpeGVkQ2FjaGVLZXkgOiBpZC5maXhlZENhY2hlS2V5KSA/PyBpZC5yZXF1ZXN0SWQ7XG59XG5mdW5jdGlvbiB1cGRhdGVNdXRhdGlvblN1YnN0YXRlSWZFeGlzdHMoc3RhdGU6IE11dGF0aW9uU3RhdGU8YW55PiwgaWQ6IE11dGF0aW9uU3Vic3RhdGVJZGVudGlmaWVyIHwge1xuICByZXF1ZXN0SWQ6IHN0cmluZztcbiAgYXJnOiB7XG4gICAgZml4ZWRDYWNoZUtleT86IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgfTtcbn0sIHVwZGF0ZTogKHN1YnN0YXRlOiBNdXRhdGlvblN1YlN0YXRlPGFueT4pID0+IHZvaWQpIHtcbiAgY29uc3Qgc3Vic3RhdGUgPSBzdGF0ZVtnZXRNdXRhdGlvbkNhY2hlS2V5KGlkKV07XG4gIGlmIChzdWJzdGF0ZSkge1xuICAgIHVwZGF0ZShzdWJzdGF0ZSk7XG4gIH1cbn1cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHt9IGFzIGFueTtcbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNsaWNlKHtcbiAgcmVkdWNlclBhdGgsXG4gIHF1ZXJ5VGh1bmssXG4gIG11dGF0aW9uVGh1bmssXG4gIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgY29udGV4dDoge1xuICAgIGVuZHBvaW50RGVmaW5pdGlvbnM6IGRlZmluaXRpb25zLFxuICAgIGFwaVVpZCxcbiAgICBleHRyYWN0UmVoeWRyYXRpb25JbmZvLFxuICAgIGhhc1JlaHlkcmF0aW9uSW5mb1xuICB9LFxuICBhc3NlcnRUYWdUeXBlLFxuICBjb25maWdcbn06IHtcbiAgcmVkdWNlclBhdGg6IHN0cmluZztcbiAgcXVlcnlUaHVuazogUXVlcnlUaHVuaztcbiAgaW5maW5pdGVRdWVyeVRodW5rOiBJbmZpbml0ZVF1ZXJ5VGh1bms8YW55PjtcbiAgbXV0YXRpb25UaHVuazogTXV0YXRpb25UaHVuaztcbiAgc2VyaWFsaXplUXVlcnlBcmdzOiBJbnRlcm5hbFNlcmlhbGl6ZVF1ZXJ5QXJncztcbiAgY29udGV4dDogQXBpQ29udGV4dDxFbmRwb2ludERlZmluaXRpb25zPjtcbiAgYXNzZXJ0VGFnVHlwZTogQXNzZXJ0VGFnVHlwZXM7XG4gIGNvbmZpZzogT21pdDxDb25maWdTdGF0ZTxzdHJpbmc+LCAnb25saW5lJyB8ICdmb2N1c2VkJyB8ICdtaWRkbGV3YXJlUmVnaXN0ZXJlZCc+O1xufSkge1xuICBjb25zdCByZXNldEFwaVN0YXRlID0gY3JlYXRlQWN0aW9uKGAke3JlZHVjZXJQYXRofS9yZXNldEFwaVN0YXRlYCk7XG4gIGZ1bmN0aW9uIHdyaXRlUGVuZGluZ0NhY2hlRW50cnkoZHJhZnQ6IFF1ZXJ5U3RhdGU8YW55PiwgYXJnOiBRdWVyeVRodW5rQXJnLCB1cHNlcnRpbmc6IGJvb2xlYW4sIG1ldGE6IHtcbiAgICBhcmc6IFF1ZXJ5VGh1bmtBcmc7XG4gICAgcmVxdWVzdElkOiBzdHJpbmc7XG4gICAgLy8gcmVxdWVzdFN0YXR1czogJ3BlbmRpbmcnXG4gIH0gJiB7XG4gICAgc3RhcnRlZFRpbWVTdGFtcDogbnVtYmVyO1xuICB9KSB7XG4gICAgZHJhZnRbYXJnLnF1ZXJ5Q2FjaGVLZXldID8/PSB7XG4gICAgICBzdGF0dXM6IFF1ZXJ5U3RhdHVzLnVuaW5pdGlhbGl6ZWQsXG4gICAgICBlbmRwb2ludE5hbWU6IGFyZy5lbmRwb2ludE5hbWVcbiAgICB9O1xuICAgIHVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgYXJnLnF1ZXJ5Q2FjaGVLZXksIHN1YnN0YXRlID0+IHtcbiAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFF1ZXJ5U3RhdHVzLnBlbmRpbmc7XG4gICAgICBzdWJzdGF0ZS5yZXF1ZXN0SWQgPSB1cHNlcnRpbmcgJiYgc3Vic3RhdGUucmVxdWVzdElkID9cbiAgICAgIC8vIGZvciBgdXBzZXJ0UXVlcnlgICoqdXBkYXRlcyoqLCBrZWVwIHRoZSBjdXJyZW50IGByZXF1ZXN0SWRgXG4gICAgICBzdWJzdGF0ZS5yZXF1ZXN0SWQgOlxuICAgICAgLy8gZm9yIG5vcm1hbCBxdWVyaWVzIG9yIGB1cHNlcnRRdWVyeWAgKippbnNlcnRzKiogYWx3YXlzIHVwZGF0ZSB0aGUgYHJlcXVlc3RJZGBcbiAgICAgIG1ldGEucmVxdWVzdElkO1xuICAgICAgaWYgKGFyZy5vcmlnaW5hbEFyZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdWJzdGF0ZS5vcmlnaW5hbEFyZ3MgPSBhcmcub3JpZ2luYWxBcmdzO1xuICAgICAgfVxuICAgICAgc3Vic3RhdGUuc3RhcnRlZFRpbWVTdGFtcCA9IG1ldGEuc3RhcnRlZFRpbWVTdGFtcDtcbiAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGRlZmluaXRpb25zW21ldGEuYXJnLmVuZHBvaW50TmFtZV07XG4gICAgICBpZiAoaXNJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbihlbmRwb2ludERlZmluaXRpb24pICYmICdkaXJlY3Rpb24nIGluIGFyZykge1xuICAgICAgICA7XG4gICAgICAgIChzdWJzdGF0ZSBhcyBJbmZpbml0ZVF1ZXJ5U3ViU3RhdGU8YW55PikuZGlyZWN0aW9uID0gYXJnLmRpcmVjdGlvbiBhcyBJbmZpbml0ZVF1ZXJ5RGlyZWN0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHdyaXRlRnVsZmlsbGVkQ2FjaGVFbnRyeShkcmFmdDogUXVlcnlTdGF0ZTxhbnk+LCBtZXRhOiB7XG4gICAgYXJnOiBRdWVyeVRodW5rQXJnO1xuICAgIHJlcXVlc3RJZDogc3RyaW5nO1xuICB9ICYge1xuICAgIGZ1bGZpbGxlZFRpbWVTdGFtcDogbnVtYmVyO1xuICAgIGJhc2VRdWVyeU1ldGE6IHVua25vd247XG4gIH0sIHBheWxvYWQ6IHVua25vd24sIHVwc2VydGluZzogYm9vbGVhbikge1xuICAgIHVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgbWV0YS5hcmcucXVlcnlDYWNoZUtleSwgc3Vic3RhdGUgPT4ge1xuICAgICAgaWYgKHN1YnN0YXRlLnJlcXVlc3RJZCAhPT0gbWV0YS5yZXF1ZXN0SWQgJiYgIXVwc2VydGluZykgcmV0dXJuO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZXJnZVxuICAgICAgfSA9IGRlZmluaXRpb25zW21ldGEuYXJnLmVuZHBvaW50TmFtZV0gYXMgUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT47XG4gICAgICBzdWJzdGF0ZS5zdGF0dXMgPSBRdWVyeVN0YXR1cy5mdWxmaWxsZWQ7XG4gICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgaWYgKHN1YnN0YXRlLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGZ1bGZpbGxlZFRpbWVTdGFtcCxcbiAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgIGJhc2VRdWVyeU1ldGEsXG4gICAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgICB9ID0gbWV0YTtcbiAgICAgICAgICAvLyBUaGVyZSdzIGV4aXN0aW5nIGNhY2hlIGRhdGEuIExldCB0aGUgdXNlciBtZXJnZSBpdCBpbiB0aGVtc2VsdmVzLlxuICAgICAgICAgIC8vIFdlJ3JlIGFscmVhZHkgaW5zaWRlIGFuIEltbWVyLXBvd2VyZWQgcmVkdWNlciwgYW5kIHRoZSB1c2VyIGNvdWxkIGp1c3QgbXV0YXRlIGBzdWJzdGF0ZS5kYXRhYFxuICAgICAgICAgIC8vIHRoZW1zZWx2ZXMgaW5zaWRlIG9mIGBtZXJnZSgpYC4gQnV0LCB0aGV5IG1pZ2h0IGFsc28gd2FudCB0byByZXR1cm4gYSBuZXcgdmFsdWUuXG4gICAgICAgICAgLy8gVHJ5IHRvIGxldCBJbW1lciBmaWd1cmUgdGhhdCBwYXJ0IG91dCwgc2F2ZSB0aGUgcmVzdWx0LCBhbmQgYXNzaWduIGl0IHRvIGBzdWJzdGF0ZS5kYXRhYC5cbiAgICAgICAgICBsZXQgbmV3RGF0YSA9IGNyZWF0ZU5leHRTdGF0ZShzdWJzdGF0ZS5kYXRhLCBkcmFmdFN1YnN0YXRlRGF0YSA9PiB7XG4gICAgICAgICAgICAvLyBBcyB1c3VhbCB3aXRoIEltbWVyLCB5b3UgY2FuIG11dGF0ZSBfb3JfIHJldHVybiBpbnNpZGUgaGVyZSwgYnV0IG5vdCBib3RoXG4gICAgICAgICAgICByZXR1cm4gbWVyZ2UoZHJhZnRTdWJzdGF0ZURhdGEsIHBheWxvYWQsIHtcbiAgICAgICAgICAgICAgYXJnOiBhcmcub3JpZ2luYWxBcmdzLFxuICAgICAgICAgICAgICBiYXNlUXVlcnlNZXRhLFxuICAgICAgICAgICAgICBmdWxmaWxsZWRUaW1lU3RhbXAsXG4gICAgICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3Vic3RhdGUuZGF0YSA9IG5ld0RhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUHJlc3VtYWJseSBhIGZyZXNoIHJlcXVlc3QuIEp1c3QgY2FjaGUgdGhlIHJlc3BvbnNlIGRhdGEuXG4gICAgICAgICAgc3Vic3RhdGUuZGF0YSA9IHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFzc2lnbiBvciBzYWZlbHkgdXBkYXRlIHRoZSBjYWNoZSBkYXRhLlxuICAgICAgICBzdWJzdGF0ZS5kYXRhID0gZGVmaW5pdGlvbnNbbWV0YS5hcmcuZW5kcG9pbnROYW1lXS5zdHJ1Y3R1cmFsU2hhcmluZyA/PyB0cnVlID8gY29weVdpdGhTdHJ1Y3R1cmFsU2hhcmluZyhpc0RyYWZ0KHN1YnN0YXRlLmRhdGEpID8gb3JpZ2luYWwoc3Vic3RhdGUuZGF0YSkgOiBzdWJzdGF0ZS5kYXRhLCBwYXlsb2FkKSA6IHBheWxvYWQ7XG4gICAgICB9XG4gICAgICBkZWxldGUgc3Vic3RhdGUuZXJyb3I7XG4gICAgICBzdWJzdGF0ZS5mdWxmaWxsZWRUaW1lU3RhbXAgPSBtZXRhLmZ1bGZpbGxlZFRpbWVTdGFtcDtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBxdWVyeVNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6IGAke3JlZHVjZXJQYXRofS9xdWVyaWVzYCxcbiAgICBpbml0aWFsU3RhdGU6IGluaXRpYWxTdGF0ZSBhcyBRdWVyeVN0YXRlPGFueT4sXG4gICAgcmVkdWNlcnM6IHtcbiAgICAgIHJlbW92ZVF1ZXJ5UmVzdWx0OiB7XG4gICAgICAgIHJlZHVjZXIoZHJhZnQsIHtcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICAgICAgfVxuICAgICAgICB9OiBQYXlsb2FkQWN0aW9uPFF1ZXJ5U3Vic3RhdGVJZGVudGlmaWVyPikge1xuICAgICAgICAgIGRlbGV0ZSBkcmFmdFtxdWVyeUNhY2hlS2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZTogcHJlcGFyZUF1dG9CYXRjaGVkPFF1ZXJ5U3Vic3RhdGVJZGVudGlmaWVyPigpXG4gICAgICB9LFxuICAgICAgY2FjaGVFbnRyaWVzVXBzZXJ0ZWQ6IHtcbiAgICAgICAgcmVkdWNlcihkcmFmdCwgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPFByb2Nlc3NlZFF1ZXJ5VXBzZXJ0RW50cnlbXSwgc3RyaW5nLCB7XG4gICAgICAgICAgUlRLX2F1dG9CYXRjaDogYm9vbGVhbjtcbiAgICAgICAgICByZXF1ZXN0SWQ6IHN0cmluZztcbiAgICAgICAgICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgICAgICAgfT4pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGFjdGlvbi5wYXlsb2FkKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHF1ZXJ5RGVzY3JpcHRpb246IGFyZyxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0gPSBlbnRyeTtcbiAgICAgICAgICAgIHdyaXRlUGVuZGluZ0NhY2hlRW50cnkoZHJhZnQsIGFyZywgdHJ1ZSwge1xuICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgIHJlcXVlc3RJZDogYWN0aW9uLm1ldGEucmVxdWVzdElkLFxuICAgICAgICAgICAgICBzdGFydGVkVGltZVN0YW1wOiBhY3Rpb24ubWV0YS50aW1lc3RhbXBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd3JpdGVGdWxmaWxsZWRDYWNoZUVudHJ5KGRyYWZ0LCB7XG4gICAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgICAgcmVxdWVzdElkOiBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIGZ1bGZpbGxlZFRpbWVTdGFtcDogYWN0aW9uLm1ldGEudGltZXN0YW1wLFxuICAgICAgICAgICAgICBiYXNlUXVlcnlNZXRhOiB7fVxuICAgICAgICAgICAgfSwgdmFsdWUsXG4gICAgICAgICAgICAvLyBXZSBrbm93IHdlJ3JlIHVwc2VydGluZyBoZXJlXG4gICAgICAgICAgICB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcmU6IChwYXlsb2FkOiBOb3JtYWxpemVkUXVlcnlVcHNlcnRFbnRyeVBheWxvYWRbXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHF1ZXJ5RGVzY3JpcHRpb25zOiBQcm9jZXNzZWRRdWVyeVVwc2VydEVudHJ5W10gPSBwYXlsb2FkLm1hcChlbnRyeSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGVuZHBvaW50TmFtZSxcbiAgICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSA9IGVudHJ5O1xuICAgICAgICAgICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gZGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5RGVzY3JpcHRpb246IFF1ZXJ5VGh1bmtBcmcgPSB7XG4gICAgICAgICAgICAgIHR5cGU6ICdxdWVyeScsXG4gICAgICAgICAgICAgIGVuZHBvaW50TmFtZTogZW5kcG9pbnROYW1lLFxuICAgICAgICAgICAgICBvcmlnaW5hbEFyZ3M6IGVudHJ5LmFyZyxcbiAgICAgICAgICAgICAgcXVlcnlDYWNoZUtleTogc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgICAgICAgICBxdWVyeUFyZ3M6IGFyZyxcbiAgICAgICAgICAgICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICAgICAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcXVlcnlEZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgcGF5bG9hZDogcXVlcnlEZXNjcmlwdGlvbnMsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgIFtTSE9VTERfQVVUT0JBVENIXTogdHJ1ZSxcbiAgICAgICAgICAgICAgcmVxdWVzdElkOiBuYW5vaWQoKSxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcXVlcnlSZXN1bHRQYXRjaGVkOiB7XG4gICAgICAgIHJlZHVjZXIoZHJhZnQsIHtcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgICAgICAgcGF0Y2hlc1xuICAgICAgICAgIH1cbiAgICAgICAgfTogUGF5bG9hZEFjdGlvbjxRdWVyeVN1YnN0YXRlSWRlbnRpZmllciAmIHtcbiAgICAgICAgICBwYXRjaGVzOiByZWFkb25seSBQYXRjaFtdO1xuICAgICAgICB9Pikge1xuICAgICAgICAgIHVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgcXVlcnlDYWNoZUtleSwgc3Vic3RhdGUgPT4ge1xuICAgICAgICAgICAgc3Vic3RhdGUuZGF0YSA9IGFwcGx5UGF0Y2hlcyhzdWJzdGF0ZS5kYXRhIGFzIGFueSwgcGF0Y2hlcy5jb25jYXQoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcmU6IHByZXBhcmVBdXRvQmF0Y2hlZDxRdWVyeVN1YnN0YXRlSWRlbnRpZmllciAmIHtcbiAgICAgICAgICBwYXRjaGVzOiByZWFkb25seSBQYXRjaFtdO1xuICAgICAgICB9PigpXG4gICAgICB9XG4gICAgfSxcbiAgICBleHRyYVJlZHVjZXJzKGJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkQ2FzZShxdWVyeVRodW5rLnBlbmRpbmcsIChkcmFmdCwge1xuICAgICAgICBtZXRhLFxuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgYXJnXG4gICAgICAgIH1cbiAgICAgIH0pID0+IHtcbiAgICAgICAgY29uc3QgdXBzZXJ0aW5nID0gaXNVcHNlcnRRdWVyeShhcmcpO1xuICAgICAgICB3cml0ZVBlbmRpbmdDYWNoZUVudHJ5KGRyYWZ0LCBhcmcsIHVwc2VydGluZywgbWV0YSk7XG4gICAgICB9KS5hZGRDYXNlKHF1ZXJ5VGh1bmsuZnVsZmlsbGVkLCAoZHJhZnQsIHtcbiAgICAgICAgbWV0YSxcbiAgICAgICAgcGF5bG9hZFxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zdCB1cHNlcnRpbmcgPSBpc1Vwc2VydFF1ZXJ5KG1ldGEuYXJnKTtcbiAgICAgICAgd3JpdGVGdWxmaWxsZWRDYWNoZUVudHJ5KGRyYWZ0LCBtZXRhLCBwYXlsb2FkLCB1cHNlcnRpbmcpO1xuICAgICAgfSkuYWRkQ2FzZShxdWVyeVRodW5rLnJlamVjdGVkLCAoZHJhZnQsIHtcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yLFxuICAgICAgICBwYXlsb2FkXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgYXJnLnF1ZXJ5Q2FjaGVLZXksIHN1YnN0YXRlID0+IHtcbiAgICAgICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAvLyByZXF1ZXN0IHdhcyBhYm9ydGVkIGR1ZSB0byBjb25kaXRpb24gKGFub3RoZXIgcXVlcnkgYWxyZWFkeSBydW5uaW5nKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByZXF1ZXN0IGZhaWxlZFxuICAgICAgICAgICAgaWYgKHN1YnN0YXRlLnJlcXVlc3RJZCAhPT0gcmVxdWVzdElkKSByZXR1cm47XG4gICAgICAgICAgICBzdWJzdGF0ZS5zdGF0dXMgPSBRdWVyeVN0YXR1cy5yZWplY3RlZDtcbiAgICAgICAgICAgIHN1YnN0YXRlLmVycm9yID0gKHBheWxvYWQgPz8gZXJyb3IpIGFzIGFueTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSkuYWRkTWF0Y2hlcihoYXNSZWh5ZHJhdGlvbkluZm8sIChkcmFmdCwgYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBxdWVyaWVzXG4gICAgICAgIH0gPSBleHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbikhO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyhxdWVyaWVzKSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAvLyBkbyBub3QgcmVoeWRyYXRlIGVudHJpZXMgdGhhdCB3ZXJlIGN1cnJlbnRseSBpbiBmbGlnaHQuXG4gICAgICAgICAgZW50cnk/LnN0YXR1cyA9PT0gUXVlcnlTdGF0dXMuZnVsZmlsbGVkIHx8IGVudHJ5Py5zdGF0dXMgPT09IFF1ZXJ5U3RhdHVzLnJlamVjdGVkKSB7XG4gICAgICAgICAgICBkcmFmdFtrZXldID0gZW50cnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBtdXRhdGlvblNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6IGAke3JlZHVjZXJQYXRofS9tdXRhdGlvbnNgLFxuICAgIGluaXRpYWxTdGF0ZTogaW5pdGlhbFN0YXRlIGFzIE11dGF0aW9uU3RhdGU8YW55PixcbiAgICByZWR1Y2Vyczoge1xuICAgICAgcmVtb3ZlTXV0YXRpb25SZXN1bHQ6IHtcbiAgICAgICAgcmVkdWNlcihkcmFmdCwge1xuICAgICAgICAgIHBheWxvYWRcbiAgICAgICAgfTogUGF5bG9hZEFjdGlvbjxNdXRhdGlvblN1YnN0YXRlSWRlbnRpZmllcj4pIHtcbiAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IGdldE11dGF0aW9uQ2FjaGVLZXkocGF5bG9hZCk7XG4gICAgICAgICAgaWYgKGNhY2hlS2V5IGluIGRyYWZ0KSB7XG4gICAgICAgICAgICBkZWxldGUgZHJhZnRbY2FjaGVLZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZTogcHJlcGFyZUF1dG9CYXRjaGVkPE11dGF0aW9uU3Vic3RhdGVJZGVudGlmaWVyPigpXG4gICAgICB9XG4gICAgfSxcbiAgICBleHRyYVJlZHVjZXJzKGJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkQ2FzZShtdXRhdGlvblRodW5rLnBlbmRpbmcsIChkcmFmdCwge1xuICAgICAgICBtZXRhLFxuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIGFyZyxcbiAgICAgICAgICBzdGFydGVkVGltZVN0YW1wXG4gICAgICAgIH1cbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKCFhcmcudHJhY2spIHJldHVybjtcbiAgICAgICAgZHJhZnRbZ2V0TXV0YXRpb25DYWNoZUtleShtZXRhKV0gPSB7XG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIHN0YXR1czogUXVlcnlTdGF0dXMucGVuZGluZyxcbiAgICAgICAgICBlbmRwb2ludE5hbWU6IGFyZy5lbmRwb2ludE5hbWUsXG4gICAgICAgICAgc3RhcnRlZFRpbWVTdGFtcFxuICAgICAgICB9O1xuICAgICAgfSkuYWRkQ2FzZShtdXRhdGlvblRodW5rLmZ1bGZpbGxlZCwgKGRyYWZ0LCB7XG4gICAgICAgIHBheWxvYWQsXG4gICAgICAgIG1ldGFcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKCFtZXRhLmFyZy50cmFjaykgcmV0dXJuO1xuICAgICAgICB1cGRhdGVNdXRhdGlvblN1YnN0YXRlSWZFeGlzdHMoZHJhZnQsIG1ldGEsIHN1YnN0YXRlID0+IHtcbiAgICAgICAgICBpZiAoc3Vic3RhdGUucmVxdWVzdElkICE9PSBtZXRhLnJlcXVlc3RJZCkgcmV0dXJuO1xuICAgICAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFF1ZXJ5U3RhdHVzLmZ1bGZpbGxlZDtcbiAgICAgICAgICBzdWJzdGF0ZS5kYXRhID0gcGF5bG9hZDtcbiAgICAgICAgICBzdWJzdGF0ZS5mdWxmaWxsZWRUaW1lU3RhbXAgPSBtZXRhLmZ1bGZpbGxlZFRpbWVTdGFtcDtcbiAgICAgICAgfSk7XG4gICAgICB9KS5hZGRDYXNlKG11dGF0aW9uVGh1bmsucmVqZWN0ZWQsIChkcmFmdCwge1xuICAgICAgICBwYXlsb2FkLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgbWV0YVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoIW1ldGEuYXJnLnRyYWNrKSByZXR1cm47XG4gICAgICAgIHVwZGF0ZU11dGF0aW9uU3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgbWV0YSwgc3Vic3RhdGUgPT4ge1xuICAgICAgICAgIGlmIChzdWJzdGF0ZS5yZXF1ZXN0SWQgIT09IG1ldGEucmVxdWVzdElkKSByZXR1cm47XG4gICAgICAgICAgc3Vic3RhdGUuc3RhdHVzID0gUXVlcnlTdGF0dXMucmVqZWN0ZWQ7XG4gICAgICAgICAgc3Vic3RhdGUuZXJyb3IgPSAocGF5bG9hZCA/PyBlcnJvcikgYXMgYW55O1xuICAgICAgICB9KTtcbiAgICAgIH0pLmFkZE1hdGNoZXIoaGFzUmVoeWRyYXRpb25JbmZvLCAoZHJhZnQsIGFjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbXV0YXRpb25zXG4gICAgICAgIH0gPSBleHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbikhO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyhtdXRhdGlvbnMpKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIGRvIG5vdCByZWh5ZHJhdGUgZW50cmllcyB0aGF0IHdlcmUgY3VycmVudGx5IGluIGZsaWdodC5cbiAgICAgICAgICAoZW50cnk/LnN0YXR1cyA9PT0gUXVlcnlTdGF0dXMuZnVsZmlsbGVkIHx8IGVudHJ5Py5zdGF0dXMgPT09IFF1ZXJ5U3RhdHVzLnJlamVjdGVkKSAmJlxuICAgICAgICAgIC8vIG9ubHkgcmVoeWRyYXRlIGVuZHBvaW50cyB0aGF0IHdlcmUgcGVyc2lzdGVkIHVzaW5nIGEgYGZpeGVkQ2FjaGVLZXlgXG4gICAgICAgICAga2V5ICE9PSBlbnRyeT8ucmVxdWVzdElkKSB7XG4gICAgICAgICAgICBkcmFmdFtrZXldID0gZW50cnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICB0eXBlIENhbGN1bGF0ZVByb3ZpZGVkQnlBY3Rpb24gPSBVbndyYXBQcm9taXNlPFJldHVyblR5cGU8UmV0dXJuVHlwZTxRdWVyeVRodW5rPj4gfCBSZXR1cm5UeXBlPFJldHVyblR5cGU8SW5maW5pdGVRdWVyeVRodW5rPGFueT4+Pj47XG4gIGNvbnN0IGluaXRpYWxJbnZhbGlkYXRpb25TdGF0ZTogSW52YWxpZGF0aW9uU3RhdGU8c3RyaW5nPiA9IHtcbiAgICB0YWdzOiB7fSxcbiAgICBrZXlzOiB7fVxuICB9O1xuICBjb25zdCBpbnZhbGlkYXRpb25TbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vaW52YWxpZGF0aW9uYCxcbiAgICBpbml0aWFsU3RhdGU6IGluaXRpYWxJbnZhbGlkYXRpb25TdGF0ZSxcbiAgICByZWR1Y2Vyczoge1xuICAgICAgdXBkYXRlUHJvdmlkZWRCeToge1xuICAgICAgICByZWR1Y2VyKGRyYWZ0LCBhY3Rpb246IFBheWxvYWRBY3Rpb248QXJyYXk8e1xuICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXk6IFF1ZXJ5Q2FjaGVLZXk7XG4gICAgICAgICAgcHJvdmlkZWRUYWdzOiByZWFkb25seSBGdWxsVGFnRGVzY3JpcHRpb248c3RyaW5nPltdO1xuICAgICAgICB9Pj4pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgICAgICBwcm92aWRlZFRhZ3NcbiAgICAgICAgICB9IG9mIGFjdGlvbi5wYXlsb2FkKSB7XG4gICAgICAgICAgICByZW1vdmVDYWNoZUtleUZyb21UYWdzKGRyYWZ0LCBxdWVyeUNhY2hlS2V5KTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgfSBvZiBwcm92aWRlZFRhZ3MpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlZFF1ZXJpZXMgPSAoZHJhZnQudGFnc1t0eXBlXSA/Pz0ge30pW2lkIHx8ICdfX2ludGVybmFsX3dpdGhvdXRfaWQnXSA/Pz0gW107XG4gICAgICAgICAgICAgIGNvbnN0IGFscmVhZHlTdWJzY3JpYmVkID0gc3Vic2NyaWJlZFF1ZXJpZXMuaW5jbHVkZXMocXVlcnlDYWNoZUtleSk7XG4gICAgICAgICAgICAgIGlmICghYWxyZWFkeVN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVkUXVlcmllcy5wdXNoKHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSByZWFkb25seSBmcm9tIHRoZSBwcm92aWRlZFRhZ3MgYXJyYXlcbiAgICAgICAgICAgIGRyYWZ0LmtleXNbcXVlcnlDYWNoZUtleV0gPSBwcm92aWRlZFRhZ3MgYXMgRnVsbFRhZ0Rlc2NyaXB0aW9uPHN0cmluZz5bXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcmU6IHByZXBhcmVBdXRvQmF0Y2hlZDxBcnJheTx7XG4gICAgICAgICAgcXVlcnlDYWNoZUtleTogUXVlcnlDYWNoZUtleTtcbiAgICAgICAgICBwcm92aWRlZFRhZ3M6IHJlYWRvbmx5IEZ1bGxUYWdEZXNjcmlwdGlvbjxzdHJpbmc+W107XG4gICAgICAgIH0+PigpXG4gICAgICB9XG4gICAgfSxcbiAgICBleHRyYVJlZHVjZXJzKGJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkQ2FzZShxdWVyeVNsaWNlLmFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQsIChkcmFmdCwge1xuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgICB9XG4gICAgICB9KSA9PiB7XG4gICAgICAgIHJlbW92ZUNhY2hlS2V5RnJvbVRhZ3MoZHJhZnQsIHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgfSkuYWRkTWF0Y2hlcihoYXNSZWh5ZHJhdGlvbkluZm8sIChkcmFmdCwgYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwcm92aWRlZFxuICAgICAgICB9ID0gZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyhhY3Rpb24pITtcbiAgICAgICAgZm9yIChjb25zdCBbdHlwZSwgaW5jb21pbmdUYWdzXSBvZiBPYmplY3QuZW50cmllcyhwcm92aWRlZCkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtpZCwgY2FjaGVLZXlzXSBvZiBPYmplY3QuZW50cmllcyhpbmNvbWluZ1RhZ3MpKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVkUXVlcmllcyA9IChkcmFmdC50YWdzW3R5cGVdID8/PSB7fSlbaWQgfHwgJ19faW50ZXJuYWxfd2l0aG91dF9pZCddID8/PSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcXVlcnlDYWNoZUtleSBvZiBjYWNoZUtleXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgYWxyZWFkeVN1YnNjcmliZWQgPSBzdWJzY3JpYmVkUXVlcmllcy5pbmNsdWRlcyhxdWVyeUNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgaWYgKCFhbHJlYWR5U3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZWRRdWVyaWVzLnB1c2gocXVlcnlDYWNoZUtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLmFkZE1hdGNoZXIoaXNBbnlPZihpc0Z1bGZpbGxlZChxdWVyeVRodW5rKSwgaXNSZWplY3RlZFdpdGhWYWx1ZShxdWVyeVRodW5rKSksIChkcmFmdCwgYWN0aW9uKSA9PiB7XG4gICAgICAgIHdyaXRlUHJvdmlkZWRUYWdzRm9yUXVlcmllcyhkcmFmdCwgW2FjdGlvbl0pO1xuICAgICAgfSkuYWRkTWF0Y2hlcihxdWVyeVNsaWNlLmFjdGlvbnMuY2FjaGVFbnRyaWVzVXBzZXJ0ZWQubWF0Y2gsIChkcmFmdCwgYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tBY3Rpb25zOiBDYWxjdWxhdGVQcm92aWRlZEJ5QWN0aW9uW10gPSBhY3Rpb24ucGF5bG9hZC5tYXAoKHtcbiAgICAgICAgICBxdWVyeURlc2NyaXB0aW9uLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1VOS05PV04nLFxuICAgICAgICAgICAgcGF5bG9hZDogdmFsdWUsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgIHJlcXVlc3RTdGF0dXM6ICdmdWxmaWxsZWQnLFxuICAgICAgICAgICAgICByZXF1ZXN0SWQ6ICdVTktOT1dOJyxcbiAgICAgICAgICAgICAgYXJnOiBxdWVyeURlc2NyaXB0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdyaXRlUHJvdmlkZWRUYWdzRm9yUXVlcmllcyhkcmFmdCwgbW9ja0FjdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gcmVtb3ZlQ2FjaGVLZXlGcm9tVGFncyhkcmFmdDogSW52YWxpZGF0aW9uU3RhdGU8YW55PiwgcXVlcnlDYWNoZUtleTogUXVlcnlDYWNoZUtleSkge1xuICAgIGNvbnN0IGV4aXN0aW5nVGFncyA9IGRyYWZ0LmtleXNbcXVlcnlDYWNoZUtleV0gPz8gW107XG5cbiAgICAvLyBEZWxldGUgdGhpcyBjYWNoZSBrZXkgZnJvbSBhbnkgZXhpc3RpbmcgdGFncyB0aGF0IG1heSBoYXZlIHByb3ZpZGVkIGl0XG4gICAgZm9yIChjb25zdCB0YWcgb2YgZXhpc3RpbmdUYWdzKSB7XG4gICAgICBjb25zdCB0YWdUeXBlID0gdGFnLnR5cGU7XG4gICAgICBjb25zdCB0YWdJZCA9IHRhZy5pZCA/PyAnX19pbnRlcm5hbF93aXRob3V0X2lkJztcbiAgICAgIGNvbnN0IHRhZ1N1YnNjcmlwdGlvbnMgPSBkcmFmdC50YWdzW3RhZ1R5cGVdPy5bdGFnSWRdO1xuICAgICAgaWYgKHRhZ1N1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgZHJhZnQudGFnc1t0YWdUeXBlXVt0YWdJZF0gPSB0YWdTdWJzY3JpcHRpb25zLmZpbHRlcihxYyA9PiBxYyAhPT0gcXVlcnlDYWNoZUtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZSBkcmFmdC5rZXlzW3F1ZXJ5Q2FjaGVLZXldO1xuICB9XG4gIGZ1bmN0aW9uIHdyaXRlUHJvdmlkZWRUYWdzRm9yUXVlcmllcyhkcmFmdDogSW52YWxpZGF0aW9uU3RhdGU8c3RyaW5nPiwgYWN0aW9uczogQ2FsY3VsYXRlUHJvdmlkZWRCeUFjdGlvbltdKSB7XG4gICAgY29uc3QgcHJvdmlkZWRCeUVudHJpZXMgPSBhY3Rpb25zLm1hcChhY3Rpb24gPT4ge1xuICAgICAgY29uc3QgcHJvdmlkZWRUYWdzID0gY2FsY3VsYXRlUHJvdmlkZWRCeVRodW5rKGFjdGlvbiwgJ3Byb3ZpZGVzVGFncycsIGRlZmluaXRpb25zLCBhc3NlcnRUYWdUeXBlKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgfSA9IGFjdGlvbi5tZXRhLmFyZztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgIHByb3ZpZGVkVGFnc1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBpbnZhbGlkYXRpb25TbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlUHJvdmlkZWRCeShkcmFmdCwgaW52YWxpZGF0aW9uU2xpY2UuYWN0aW9ucy51cGRhdGVQcm92aWRlZEJ5KHByb3ZpZGVkQnlFbnRyaWVzKSk7XG4gIH1cblxuICAvLyBEdW1teSBzbGljZSB0byBnZW5lcmF0ZSBhY3Rpb25zXG4gIGNvbnN0IHN1YnNjcmlwdGlvblNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6IGAke3JlZHVjZXJQYXRofS9zdWJzY3JpcHRpb25zYCxcbiAgICBpbml0aWFsU3RhdGU6IGluaXRpYWxTdGF0ZSBhcyBTdWJzY3JpcHRpb25TdGF0ZSxcbiAgICByZWR1Y2Vyczoge1xuICAgICAgdXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucyhkLCBhOiBQYXlsb2FkQWN0aW9uPHtcbiAgICAgICAgZW5kcG9pbnROYW1lOiBzdHJpbmc7XG4gICAgICAgIHJlcXVlc3RJZDogc3RyaW5nO1xuICAgICAgICBvcHRpb25zOiBTdWJzY3JpYmVyc1tudW1iZXJdO1xuICAgICAgfSAmIFF1ZXJ5U3Vic3RhdGVJZGVudGlmaWVyPikge1xuICAgICAgICAvLyBEdW1teVxuICAgICAgfSxcbiAgICAgIHVuc3Vic2NyaWJlUXVlcnlSZXN1bHQoZCwgYTogUGF5bG9hZEFjdGlvbjx7XG4gICAgICAgIHJlcXVlc3RJZDogc3RyaW5nO1xuICAgICAgfSAmIFF1ZXJ5U3Vic3RhdGVJZGVudGlmaWVyPikge1xuICAgICAgICAvLyBEdW1teVxuICAgICAgfSxcbiAgICAgIGludGVybmFsX2dldFJUS1FTdWJzY3JpcHRpb25zKCkge31cbiAgICB9XG4gIH0pO1xuICBjb25zdCBpbnRlcm5hbFN1YnNjcmlwdGlvbnNTbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vaW50ZXJuYWxTdWJzY3JpcHRpb25zYCxcbiAgICBpbml0aWFsU3RhdGU6IGluaXRpYWxTdGF0ZSBhcyBTdWJzY3JpcHRpb25TdGF0ZSxcbiAgICByZWR1Y2Vyczoge1xuICAgICAgc3Vic2NyaXB0aW9uc1VwZGF0ZWQ6IHtcbiAgICAgICAgcmVkdWNlcihzdGF0ZSwgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPFBhdGNoW10+KSB7XG4gICAgICAgICAgcmV0dXJuIGFwcGx5UGF0Y2hlcyhzdGF0ZSwgYWN0aW9uLnBheWxvYWQpO1xuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJlOiBwcmVwYXJlQXV0b0JhdGNoZWQ8UGF0Y2hbXT4oKVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGNvbmZpZ1NsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6IGAke3JlZHVjZXJQYXRofS9jb25maWdgLFxuICAgIGluaXRpYWxTdGF0ZToge1xuICAgICAgb25saW5lOiBpc09ubGluZSgpLFxuICAgICAgZm9jdXNlZDogaXNEb2N1bWVudFZpc2libGUoKSxcbiAgICAgIG1pZGRsZXdhcmVSZWdpc3RlcmVkOiBmYWxzZSxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH0gYXMgQ29uZmlnU3RhdGU8c3RyaW5nPixcbiAgICByZWR1Y2Vyczoge1xuICAgICAgbWlkZGxld2FyZVJlZ2lzdGVyZWQoc3RhdGUsIHtcbiAgICAgICAgcGF5bG9hZFxuICAgICAgfTogUGF5bG9hZEFjdGlvbjxzdHJpbmc+KSB7XG4gICAgICAgIHN0YXRlLm1pZGRsZXdhcmVSZWdpc3RlcmVkID0gc3RhdGUubWlkZGxld2FyZVJlZ2lzdGVyZWQgPT09ICdjb25mbGljdCcgfHwgYXBpVWlkICE9PSBwYXlsb2FkID8gJ2NvbmZsaWN0JyA6IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBleHRyYVJlZHVjZXJzOiBidWlsZGVyID0+IHtcbiAgICAgIGJ1aWxkZXIuYWRkQ2FzZShvbk9ubGluZSwgc3RhdGUgPT4ge1xuICAgICAgICBzdGF0ZS5vbmxpbmUgPSB0cnVlO1xuICAgICAgfSkuYWRkQ2FzZShvbk9mZmxpbmUsIHN0YXRlID0+IHtcbiAgICAgICAgc3RhdGUub25saW5lID0gZmFsc2U7XG4gICAgICB9KS5hZGRDYXNlKG9uRm9jdXMsIHN0YXRlID0+IHtcbiAgICAgICAgc3RhdGUuZm9jdXNlZCA9IHRydWU7XG4gICAgICB9KS5hZGRDYXNlKG9uRm9jdXNMb3N0LCBzdGF0ZSA9PiB7XG4gICAgICAgIHN0YXRlLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgIH0pXG4gICAgICAvLyB1cGRhdGUgdGhlIHN0YXRlIHRvIGJlIGEgbmV3IG9iamVjdCB0byBiZSBwaWNrZWQgdXAgYXMgYSBcInN0YXRlIGNoYW5nZVwiXG4gICAgICAvLyBieSByZWR1eC1wZXJzaXN0J3MgYGF1dG9NZXJnZUxldmVsMmBcbiAgICAgIC5hZGRNYXRjaGVyKGhhc1JlaHlkcmF0aW9uSW5mbywgZHJhZnQgPT4gKHtcbiAgICAgICAgLi4uZHJhZnRcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBjb21iaW5lZFJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMoe1xuICAgIHF1ZXJpZXM6IHF1ZXJ5U2xpY2UucmVkdWNlcixcbiAgICBtdXRhdGlvbnM6IG11dGF0aW9uU2xpY2UucmVkdWNlcixcbiAgICBwcm92aWRlZDogaW52YWxpZGF0aW9uU2xpY2UucmVkdWNlcixcbiAgICBzdWJzY3JpcHRpb25zOiBpbnRlcm5hbFN1YnNjcmlwdGlvbnNTbGljZS5yZWR1Y2VyLFxuICAgIGNvbmZpZzogY29uZmlnU2xpY2UucmVkdWNlclxuICB9KTtcbiAgY29uc3QgcmVkdWNlcjogdHlwZW9mIGNvbWJpbmVkUmVkdWNlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiBjb21iaW5lZFJlZHVjZXIocmVzZXRBcGlTdGF0ZS5tYXRjaChhY3Rpb24pID8gdW5kZWZpbmVkIDogc3RhdGUsIGFjdGlvbik7XG4gIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgLi4uY29uZmlnU2xpY2UuYWN0aW9ucyxcbiAgICAuLi5xdWVyeVNsaWNlLmFjdGlvbnMsXG4gICAgLi4uc3Vic2NyaXB0aW9uU2xpY2UuYWN0aW9ucyxcbiAgICAuLi5pbnRlcm5hbFN1YnNjcmlwdGlvbnNTbGljZS5hY3Rpb25zLFxuICAgIC4uLm11dGF0aW9uU2xpY2UuYWN0aW9ucyxcbiAgICAuLi5pbnZhbGlkYXRpb25TbGljZS5hY3Rpb25zLFxuICAgIHJlc2V0QXBpU3RhdGVcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICByZWR1Y2VyLFxuICAgIGFjdGlvbnNcbiAgfTtcbn1cbmV4cG9ydCB0eXBlIFNsaWNlQWN0aW9ucyA9IFJldHVyblR5cGU8dHlwZW9mIGJ1aWxkU2xpY2U+WydhY3Rpb25zJ107IiwiaW1wb3J0IHR5cGUgeyBJbnRlcm5hbFNlcmlhbGl6ZVF1ZXJ5QXJncyB9IGZyb20gJy4uL2RlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MnO1xuaW1wb3J0IHR5cGUgeyBFbmRwb2ludERlZmluaXRpb24sIEVuZHBvaW50RGVmaW5pdGlvbnMsIEluZmluaXRlUXVlcnlBcmdGcm9tLCBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbiwgTXV0YXRpb25EZWZpbml0aW9uLCBRdWVyeUFyZ0Zyb20sIFF1ZXJ5QXJnRnJvbUFueVF1ZXJ5LCBRdWVyeURlZmluaXRpb24sIFJlZHVjZXJQYXRoRnJvbSwgVGFnRGVzY3JpcHRpb24sIFRhZ1R5cGVzRnJvbSB9IGZyb20gJy4uL2VuZHBvaW50RGVmaW5pdGlvbnMnO1xuaW1wb3J0IHsgZXhwYW5kVGFnRGVzY3JpcHRpb24gfSBmcm9tICcuLi9lbmRwb2ludERlZmluaXRpb25zJztcbmltcG9ydCB7IGZsYXR0ZW4sIGlzTm90TnVsbGlzaCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgSW5maW5pdGVEYXRhLCBJbmZpbml0ZVF1ZXJ5Q29uZmlnT3B0aW9ucywgSW5maW5pdGVRdWVyeVN1YlN0YXRlLCBNdXRhdGlvblN1YlN0YXRlLCBRdWVyeUNhY2hlS2V5LCBRdWVyeUtleXMsIFF1ZXJ5U3RhdGUsIFF1ZXJ5U3ViU3RhdGUsIFJlcXVlc3RTdGF0dXNGbGFncywgUm9vdFN0YXRlIGFzIF9Sb290U3RhdGUgfSBmcm9tICcuL2FwaVN0YXRlJztcbmltcG9ydCB7IFF1ZXJ5U3RhdHVzLCBnZXRSZXF1ZXN0U3RhdHVzRmxhZ3MgfSBmcm9tICcuL2FwaVN0YXRlJztcbmltcG9ydCB7IGdldE11dGF0aW9uQ2FjaGVLZXkgfSBmcm9tICcuL2J1aWxkU2xpY2UnO1xuaW1wb3J0IHR5cGUgeyBjcmVhdGVTZWxlY3RvciBhcyBfY3JlYXRlU2VsZWN0b3IgfSBmcm9tICcuL3J0a0ltcG9ydHMnO1xuaW1wb3J0IHsgY3JlYXRlTmV4dFN0YXRlIH0gZnJvbSAnLi9ydGtJbXBvcnRzJztcbmltcG9ydCB7IHR5cGUgQWxsUXVlcnlLZXlzLCBnZXROZXh0UGFnZVBhcmFtLCBnZXRQcmV2aW91c1BhZ2VQYXJhbSB9IGZyb20gJy4vYnVpbGRUaHVua3MnO1xuZXhwb3J0IHR5cGUgU2tpcFRva2VuID0gdHlwZW9mIHNraXBUb2tlbjtcbi8qKlxuICogQ2FuIGJlIHBhc3NlZCBpbnRvIGB1c2VRdWVyeWAsIGB1c2VRdWVyeVN0YXRlYCBvciBgdXNlUXVlcnlTdWJzY3JpcHRpb25gXG4gKiBpbnN0ZWFkIG9mIHRoZSBxdWVyeSBhcmd1bWVudCB0byBnZXQgdGhlIHNhbWUgZWZmZWN0IGFzIGlmIHNldHRpbmdcbiAqIGBza2lwOiB0cnVlYCBpbiB0aGUgcXVlcnkgb3B0aW9ucy5cbiAqXG4gKiBVc2VmdWwgZm9yIHNjZW5hcmlvcyB3aGVyZSBhIHF1ZXJ5IHNob3VsZCBiZSBza2lwcGVkIHdoZW4gYGFyZ2AgaXMgYHVuZGVmaW5lZGBcbiAqIGFuZCBUeXBlU2NyaXB0IGNvbXBsYWlucyBhYm91dCBpdCBiZWNhdXNlIGBhcmdgIGlzIG5vdCBhbGxvd2VkIHRvIGJlIHBhc3NlZFxuICogaW4gYXMgYHVuZGVmaW5lZGAsIHN1Y2ggYXNcbiAqXG4gKiBgYGB0c1xuICogLy8gY29kZWJsb2NrLW1ldGEgdGl0bGU9XCJ3aWxsIGVycm9yIGlmIHRoZSBxdWVyeSBhcmd1bWVudCBpcyBub3QgYWxsb3dlZCB0byBiZSB1bmRlZmluZWRcIiBuby10cmFuc3BpbGVcbiAqIHVzZVNvbWVRdWVyeShhcmcsIHsgc2tpcDogISFhcmcgfSlcbiAqIGBgYFxuICpcbiAqIGBgYHRzXG4gKiAvLyBjb2RlYmxvY2stbWV0YSB0aXRsZT1cInVzaW5nIHNraXBUb2tlbiBpbnN0ZWFkXCIgbm8tdHJhbnNwaWxlXG4gKiB1c2VTb21lUXVlcnkoYXJnID8/IHNraXBUb2tlbilcbiAqIGBgYFxuICpcbiAqIElmIHBhc3NlZCBkaXJlY3RseSBpbnRvIGEgcXVlcnkgb3IgbXV0YXRpb24gc2VsZWN0b3IsIHRoYXQgc2VsZWN0b3Igd2lsbCBhbHdheXNcbiAqIHJldHVybiBhbiB1bmluaXRpYWxpemVkIHN0YXRlLlxuICovXG5leHBvcnQgY29uc3Qgc2tpcFRva2VuID0gLyogQF9fUFVSRV9fICovU3ltYm9sLmZvcignUlRLUS9za2lwVG9rZW4nKTtcbmV4cG9ydCB0eXBlIEJ1aWxkU2VsZWN0b3JzQXBpRW5kcG9pbnRRdWVyeTxEZWZpbml0aW9uIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55PiwgRGVmaW5pdGlvbnMgZXh0ZW5kcyBFbmRwb2ludERlZmluaXRpb25zPiA9IHtcbiAgc2VsZWN0OiBRdWVyeVJlc3VsdFNlbGVjdG9yRmFjdG9yeTxEZWZpbml0aW9uLCBfUm9vdFN0YXRlPERlZmluaXRpb25zLCBUYWdUeXBlc0Zyb208RGVmaW5pdGlvbj4sIFJlZHVjZXJQYXRoRnJvbTxEZWZpbml0aW9uPj4+O1xufTtcbmV4cG9ydCB0eXBlIEJ1aWxkU2VsZWN0b3JzQXBpRW5kcG9pbnRJbmZpbml0ZVF1ZXJ5PERlZmluaXRpb24gZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4sIERlZmluaXRpb25zIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9ucz4gPSB7XG4gIHNlbGVjdDogSW5maW5pdGVRdWVyeVJlc3VsdFNlbGVjdG9yRmFjdG9yeTxEZWZpbml0aW9uLCBfUm9vdFN0YXRlPERlZmluaXRpb25zLCBUYWdUeXBlc0Zyb208RGVmaW5pdGlvbj4sIFJlZHVjZXJQYXRoRnJvbTxEZWZpbml0aW9uPj4+O1xufTtcbmV4cG9ydCB0eXBlIEJ1aWxkU2VsZWN0b3JzQXBpRW5kcG9pbnRNdXRhdGlvbjxEZWZpbml0aW9uIGV4dGVuZHMgTXV0YXRpb25EZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55PiwgRGVmaW5pdGlvbnMgZXh0ZW5kcyBFbmRwb2ludERlZmluaXRpb25zPiA9IHtcbiAgc2VsZWN0OiBNdXRhdGlvblJlc3VsdFNlbGVjdG9yRmFjdG9yeTxEZWZpbml0aW9uLCBfUm9vdFN0YXRlPERlZmluaXRpb25zLCBUYWdUeXBlc0Zyb208RGVmaW5pdGlvbj4sIFJlZHVjZXJQYXRoRnJvbTxEZWZpbml0aW9uPj4+O1xufTtcbnR5cGUgUXVlcnlSZXN1bHRTZWxlY3RvckZhY3Rvcnk8RGVmaW5pdGlvbiBleHRlbmRzIFF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+LCBSb290U3RhdGU+ID0gKHF1ZXJ5QXJnOiBRdWVyeUFyZ0Zyb208RGVmaW5pdGlvbj4gfCBTa2lwVG9rZW4pID0+IChzdGF0ZTogUm9vdFN0YXRlKSA9PiBRdWVyeVJlc3VsdFNlbGVjdG9yUmVzdWx0PERlZmluaXRpb24+O1xuZXhwb3J0IHR5cGUgUXVlcnlSZXN1bHRTZWxlY3RvclJlc3VsdDxEZWZpbml0aW9uIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4+ID0gUXVlcnlTdWJTdGF0ZTxEZWZpbml0aW9uPiAmIFJlcXVlc3RTdGF0dXNGbGFncztcbnR5cGUgSW5maW5pdGVRdWVyeVJlc3VsdFNlbGVjdG9yRmFjdG9yeTxEZWZpbml0aW9uIGV4dGVuZHMgSW5maW5pdGVRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnk+LCBSb290U3RhdGU+ID0gKHF1ZXJ5QXJnOiBJbmZpbml0ZVF1ZXJ5QXJnRnJvbTxEZWZpbml0aW9uPiB8IFNraXBUb2tlbikgPT4gKHN0YXRlOiBSb290U3RhdGUpID0+IEluZmluaXRlUXVlcnlSZXN1bHRTZWxlY3RvclJlc3VsdDxEZWZpbml0aW9uPjtcbmV4cG9ydCB0eXBlIEluZmluaXRlUXVlcnlSZXN1bHRGbGFncyA9IHtcbiAgaGFzTmV4dFBhZ2U6IGJvb2xlYW47XG4gIGhhc1ByZXZpb3VzUGFnZTogYm9vbGVhbjtcbiAgaXNGZXRjaGluZ05leHRQYWdlOiBib29sZWFuO1xuICBpc0ZldGNoaW5nUHJldmlvdXNQYWdlOiBib29sZWFuO1xuICBpc0ZldGNoTmV4dFBhZ2VFcnJvcjogYm9vbGVhbjtcbiAgaXNGZXRjaFByZXZpb3VzUGFnZUVycm9yOiBib29sZWFuO1xufTtcbmV4cG9ydCB0eXBlIEluZmluaXRlUXVlcnlSZXN1bHRTZWxlY3RvclJlc3VsdDxEZWZpbml0aW9uIGV4dGVuZHMgSW5maW5pdGVRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnk+PiA9IEluZmluaXRlUXVlcnlTdWJTdGF0ZTxEZWZpbml0aW9uPiAmIFJlcXVlc3RTdGF0dXNGbGFncyAmIEluZmluaXRlUXVlcnlSZXN1bHRGbGFncztcbnR5cGUgTXV0YXRpb25SZXN1bHRTZWxlY3RvckZhY3Rvcnk8RGVmaW5pdGlvbiBleHRlbmRzIE11dGF0aW9uRGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+LCBSb290U3RhdGU+ID0gKHJlcXVlc3RJZDogc3RyaW5nIHwge1xuICByZXF1ZXN0SWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgZml4ZWRDYWNoZUtleTogc3RyaW5nIHwgdW5kZWZpbmVkO1xufSB8IFNraXBUb2tlbikgPT4gKHN0YXRlOiBSb290U3RhdGUpID0+IE11dGF0aW9uUmVzdWx0U2VsZWN0b3JSZXN1bHQ8RGVmaW5pdGlvbj47XG5leHBvcnQgdHlwZSBNdXRhdGlvblJlc3VsdFNlbGVjdG9yUmVzdWx0PERlZmluaXRpb24gZXh0ZW5kcyBNdXRhdGlvbkRlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55Pj4gPSBNdXRhdGlvblN1YlN0YXRlPERlZmluaXRpb24+ICYgUmVxdWVzdFN0YXR1c0ZsYWdzO1xuY29uc3QgaW5pdGlhbFN1YlN0YXRlOiBRdWVyeVN1YlN0YXRlPGFueT4gPSB7XG4gIHN0YXR1czogUXVlcnlTdGF0dXMudW5pbml0aWFsaXplZCBhcyBjb25zdFxufTtcblxuLy8gYWJ1c2UgaW1tZXIgdG8gZnJlZXplIGRlZmF1bHQgc3RhdGVzXG5jb25zdCBkZWZhdWx0UXVlcnlTdWJTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZU5leHRTdGF0ZShpbml0aWFsU3ViU3RhdGUsICgpID0+IHt9KTtcbmNvbnN0IGRlZmF1bHRNdXRhdGlvblN1YlN0YXRlID0gLyogQF9fUFVSRV9fICovY3JlYXRlTmV4dFN0YXRlKGluaXRpYWxTdWJTdGF0ZSBhcyBNdXRhdGlvblN1YlN0YXRlPGFueT4sICgpID0+IHt9KTtcbmV4cG9ydCB0eXBlIEFsbFNlbGVjdG9ycyA9IFJldHVyblR5cGU8dHlwZW9mIGJ1aWxkU2VsZWN0b3JzPjtcbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNlbGVjdG9yczxEZWZpbml0aW9ucyBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbnMsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nPih7XG4gIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgcmVkdWNlclBhdGgsXG4gIGNyZWF0ZVNlbGVjdG9yXG59OiB7XG4gIHNlcmlhbGl6ZVF1ZXJ5QXJnczogSW50ZXJuYWxTZXJpYWxpemVRdWVyeUFyZ3M7XG4gIHJlZHVjZXJQYXRoOiBSZWR1Y2VyUGF0aDtcbiAgY3JlYXRlU2VsZWN0b3I6IHR5cGVvZiBfY3JlYXRlU2VsZWN0b3I7XG59KSB7XG4gIHR5cGUgUm9vdFN0YXRlID0gX1Jvb3RTdGF0ZTxEZWZpbml0aW9ucywgc3RyaW5nLCBzdHJpbmc+O1xuICBjb25zdCBzZWxlY3RTa2lwcGVkUXVlcnkgPSAoc3RhdGU6IFJvb3RTdGF0ZSkgPT4gZGVmYXVsdFF1ZXJ5U3ViU3RhdGU7XG4gIGNvbnN0IHNlbGVjdFNraXBwZWRNdXRhdGlvbiA9IChzdGF0ZTogUm9vdFN0YXRlKSA9PiBkZWZhdWx0TXV0YXRpb25TdWJTdGF0ZTtcbiAgcmV0dXJuIHtcbiAgICBidWlsZFF1ZXJ5U2VsZWN0b3IsXG4gICAgYnVpbGRJbmZpbml0ZVF1ZXJ5U2VsZWN0b3IsXG4gICAgYnVpbGRNdXRhdGlvblNlbGVjdG9yLFxuICAgIHNlbGVjdEludmFsaWRhdGVkQnksXG4gICAgc2VsZWN0Q2FjaGVkQXJnc0ZvclF1ZXJ5LFxuICAgIHNlbGVjdEFwaVN0YXRlLFxuICAgIHNlbGVjdFF1ZXJpZXMsXG4gICAgc2VsZWN0TXV0YXRpb25zLFxuICAgIHNlbGVjdFF1ZXJ5RW50cnksXG4gICAgc2VsZWN0Q29uZmlnXG4gIH07XG4gIGZ1bmN0aW9uIHdpdGhSZXF1ZXN0RmxhZ3M8VCBleHRlbmRzIHtcbiAgICBzdGF0dXM6IFF1ZXJ5U3RhdHVzO1xuICB9PihzdWJzdGF0ZTogVCk6IFQgJiBSZXF1ZXN0U3RhdHVzRmxhZ3Mge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdWJzdGF0ZSxcbiAgICAgIC4uLmdldFJlcXVlc3RTdGF0dXNGbGFncyhzdWJzdGF0ZS5zdGF0dXMpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RBcGlTdGF0ZShyb290U3RhdGU6IFJvb3RTdGF0ZSkge1xuICAgIGNvbnN0IHN0YXRlID0gcm9vdFN0YXRlW3JlZHVjZXJQYXRoXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICBpZiAoKHNlbGVjdEFwaVN0YXRlIGFzIGFueSkudHJpZ2dlcmVkKSByZXR1cm4gc3RhdGU7XG4gICAgICAgIChzZWxlY3RBcGlTdGF0ZSBhcyBhbnkpLnRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yOiBObyBkYXRhIGZvdW5kIGF0IFxcYHN0YXRlLiR7cmVkdWNlclBhdGh9XFxgLiBEaWQgeW91IGZvcmdldCB0byBhZGQgdGhlIHJlZHVjZXIgdG8gdGhlIHN0b3JlP2ApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0UXVlcmllcyhyb290U3RhdGU6IFJvb3RTdGF0ZSkge1xuICAgIHJldHVybiBzZWxlY3RBcGlTdGF0ZShyb290U3RhdGUpPy5xdWVyaWVzO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdFF1ZXJ5RW50cnkocm9vdFN0YXRlOiBSb290U3RhdGUsIGNhY2hlS2V5OiBRdWVyeUNhY2hlS2V5KSB7XG4gICAgcmV0dXJuIHNlbGVjdFF1ZXJpZXMocm9vdFN0YXRlKT8uW2NhY2hlS2V5XTtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RNdXRhdGlvbnMocm9vdFN0YXRlOiBSb290U3RhdGUpIHtcbiAgICByZXR1cm4gc2VsZWN0QXBpU3RhdGUocm9vdFN0YXRlKT8ubXV0YXRpb25zO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdENvbmZpZyhyb290U3RhdGU6IFJvb3RTdGF0ZSkge1xuICAgIHJldHVybiBzZWxlY3RBcGlTdGF0ZShyb290U3RhdGUpPy5jb25maWc7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRBbnlRdWVyeVNlbGVjdG9yKGVuZHBvaW50TmFtZTogc3RyaW5nLCBlbmRwb2ludERlZmluaXRpb246IEVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+LCBjb21iaW5lcjogPFQgZXh0ZW5kcyB7XG4gICAgc3RhdHVzOiBRdWVyeVN0YXR1cztcbiAgfT4oc3Vic3RhdGU6IFQpID0+IFQgJiBSZXF1ZXN0U3RhdHVzRmxhZ3MpIHtcbiAgICByZXR1cm4gKHF1ZXJ5QXJnczogYW55KSA9PiB7XG4gICAgICAvLyBBdm9pZCBjYWxsaW5nIHNlcmlhbGl6ZVF1ZXJ5QXJncyBpZiB0aGUgYXJnIGlzIHNraXBUb2tlblxuICAgICAgaWYgKHF1ZXJ5QXJncyA9PT0gc2tpcFRva2VuKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTZWxlY3RvcihzZWxlY3RTa2lwcGVkUXVlcnksIGNvbWJpbmVyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRBcmdzID0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgcXVlcnlBcmdzLFxuICAgICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICAgIGVuZHBvaW50TmFtZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBzZWxlY3RRdWVyeVN1YnN0YXRlID0gKHN0YXRlOiBSb290U3RhdGUpID0+IHNlbGVjdFF1ZXJ5RW50cnkoc3RhdGUsIHNlcmlhbGl6ZWRBcmdzKSA/PyBkZWZhdWx0UXVlcnlTdWJTdGF0ZTtcbiAgICAgIHJldHVybiBjcmVhdGVTZWxlY3RvcihzZWxlY3RRdWVyeVN1YnN0YXRlLCBjb21iaW5lcik7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZFF1ZXJ5U2VsZWN0b3IoZW5kcG9pbnROYW1lOiBzdHJpbmcsIGVuZHBvaW50RGVmaW5pdGlvbjogUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4pIHtcbiAgICByZXR1cm4gYnVpbGRBbnlRdWVyeVNlbGVjdG9yKGVuZHBvaW50TmFtZSwgZW5kcG9pbnREZWZpbml0aW9uLCB3aXRoUmVxdWVzdEZsYWdzKSBhcyBRdWVyeVJlc3VsdFNlbGVjdG9yRmFjdG9yeTxhbnksIFJvb3RTdGF0ZT47XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRJbmZpbml0ZVF1ZXJ5U2VsZWN0b3IoZW5kcG9pbnROYW1lOiBzdHJpbmcsIGVuZHBvaW50RGVmaW5pdGlvbjogSW5maW5pdGVRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnk+KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5maW5pdGVRdWVyeU9wdGlvbnNcbiAgICB9ID0gZW5kcG9pbnREZWZpbml0aW9uO1xuICAgIGZ1bmN0aW9uIHdpdGhJbmZpbml0ZVF1ZXJ5UmVzdWx0RmxhZ3M8VCBleHRlbmRzIHtcbiAgICAgIHN0YXR1czogUXVlcnlTdGF0dXM7XG4gICAgfT4oc3Vic3RhdGU6IFQpOiBUICYgUmVxdWVzdFN0YXR1c0ZsYWdzICYgSW5maW5pdGVRdWVyeVJlc3VsdEZsYWdzIHtcbiAgICAgIGNvbnN0IHN0YXRlV2l0aFJlcXVlc3RGbGFncyA9IHtcbiAgICAgICAgLi4uKHN1YnN0YXRlIGFzIEluZmluaXRlUXVlcnlTdWJTdGF0ZTxhbnk+KSxcbiAgICAgICAgLi4uZ2V0UmVxdWVzdFN0YXR1c0ZsYWdzKHN1YnN0YXRlLnN0YXR1cylcbiAgICAgIH07XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgaXNFcnJvcixcbiAgICAgICAgZGlyZWN0aW9uXG4gICAgICB9ID0gc3RhdGVXaXRoUmVxdWVzdEZsYWdzO1xuICAgICAgY29uc3QgaXNGb3J3YXJkID0gZGlyZWN0aW9uID09PSAnZm9yd2FyZCc7XG4gICAgICBjb25zdCBpc0JhY2t3YXJkID0gZGlyZWN0aW9uID09PSAnYmFja3dhcmQnO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGVXaXRoUmVxdWVzdEZsYWdzLFxuICAgICAgICBoYXNOZXh0UGFnZTogZ2V0SGFzTmV4dFBhZ2UoaW5maW5pdGVRdWVyeU9wdGlvbnMsIHN0YXRlV2l0aFJlcXVlc3RGbGFncy5kYXRhLCBzdGF0ZVdpdGhSZXF1ZXN0RmxhZ3Mub3JpZ2luYWxBcmdzKSxcbiAgICAgICAgaGFzUHJldmlvdXNQYWdlOiBnZXRIYXNQcmV2aW91c1BhZ2UoaW5maW5pdGVRdWVyeU9wdGlvbnMsIHN0YXRlV2l0aFJlcXVlc3RGbGFncy5kYXRhLCBzdGF0ZVdpdGhSZXF1ZXN0RmxhZ3Mub3JpZ2luYWxBcmdzKSxcbiAgICAgICAgaXNGZXRjaGluZ05leHRQYWdlOiBpc0xvYWRpbmcgJiYgaXNGb3J3YXJkLFxuICAgICAgICBpc0ZldGNoaW5nUHJldmlvdXNQYWdlOiBpc0xvYWRpbmcgJiYgaXNCYWNrd2FyZCxcbiAgICAgICAgaXNGZXRjaE5leHRQYWdlRXJyb3I6IGlzRXJyb3IgJiYgaXNGb3J3YXJkLFxuICAgICAgICBpc0ZldGNoUHJldmlvdXNQYWdlRXJyb3I6IGlzRXJyb3IgJiYgaXNCYWNrd2FyZFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkQW55UXVlcnlTZWxlY3RvcihlbmRwb2ludE5hbWUsIGVuZHBvaW50RGVmaW5pdGlvbiwgd2l0aEluZmluaXRlUXVlcnlSZXN1bHRGbGFncykgYXMgdW5rbm93biBhcyBJbmZpbml0ZVF1ZXJ5UmVzdWx0U2VsZWN0b3JGYWN0b3J5PGFueSwgUm9vdFN0YXRlPjtcbiAgfVxuICBmdW5jdGlvbiBidWlsZE11dGF0aW9uU2VsZWN0b3IoKSB7XG4gICAgcmV0dXJuIChpZCA9PiB7XG4gICAgICBsZXQgbXV0YXRpb25JZDogc3RyaW5nIHwgdHlwZW9mIHNraXBUb2tlbjtcbiAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG11dGF0aW9uSWQgPSBnZXRNdXRhdGlvbkNhY2hlS2V5KGlkKSA/PyBza2lwVG9rZW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdXRhdGlvbklkID0gaWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBzZWxlY3RNdXRhdGlvblN1YnN0YXRlID0gKHN0YXRlOiBSb290U3RhdGUpID0+IHNlbGVjdEFwaVN0YXRlKHN0YXRlKT8ubXV0YXRpb25zPy5bbXV0YXRpb25JZCBhcyBzdHJpbmddID8/IGRlZmF1bHRNdXRhdGlvblN1YlN0YXRlO1xuICAgICAgY29uc3QgZmluYWxTZWxlY3RNdXRhdGlvblN1YnN0YXRlID0gbXV0YXRpb25JZCA9PT0gc2tpcFRva2VuID8gc2VsZWN0U2tpcHBlZE11dGF0aW9uIDogc2VsZWN0TXV0YXRpb25TdWJzdGF0ZTtcbiAgICAgIHJldHVybiBjcmVhdGVTZWxlY3RvcihmaW5hbFNlbGVjdE11dGF0aW9uU3Vic3RhdGUsIHdpdGhSZXF1ZXN0RmxhZ3MpO1xuICAgIH0pIGFzIE11dGF0aW9uUmVzdWx0U2VsZWN0b3JGYWN0b3J5PGFueSwgUm9vdFN0YXRlPjtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RJbnZhbGlkYXRlZEJ5KHN0YXRlOiBSb290U3RhdGUsIHRhZ3M6IFJlYWRvbmx5QXJyYXk8VGFnRGVzY3JpcHRpb248c3RyaW5nPiB8IG51bGwgfCB1bmRlZmluZWQ+KTogQXJyYXk8e1xuICAgIGVuZHBvaW50TmFtZTogc3RyaW5nO1xuICAgIG9yaWdpbmFsQXJnczogYW55O1xuICAgIHF1ZXJ5Q2FjaGVLZXk6IFF1ZXJ5Q2FjaGVLZXk7XG4gIH0+IHtcbiAgICBjb25zdCBhcGlTdGF0ZSA9IHN0YXRlW3JlZHVjZXJQYXRoXTtcbiAgICBjb25zdCB0b0ludmFsaWRhdGUgPSBuZXcgU2V0PFF1ZXJ5Q2FjaGVLZXk+KCk7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGFncy5maWx0ZXIoaXNOb3ROdWxsaXNoKS5tYXAoZXhwYW5kVGFnRGVzY3JpcHRpb24pKSB7XG4gICAgICBjb25zdCBwcm92aWRlZCA9IGFwaVN0YXRlLnByb3ZpZGVkLnRhZ3NbdGFnLnR5cGVdO1xuICAgICAgaWYgKCFwcm92aWRlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBpbnZhbGlkYXRlU3Vic2NyaXB0aW9ucyA9ICh0YWcuaWQgIT09IHVuZGVmaW5lZCA/XG4gICAgICAvLyBpZCBnaXZlbjogaW52YWxpZGF0ZSBhbGwgcXVlcmllcyB0aGF0IHByb3ZpZGUgdGhpcyB0eXBlICYgaWRcbiAgICAgIHByb3ZpZGVkW3RhZy5pZF0gOlxuICAgICAgLy8gbm8gaWQ6IGludmFsaWRhdGUgYWxsIHF1ZXJpZXMgdGhhdCBwcm92aWRlIHRoaXMgdHlwZVxuICAgICAgZmxhdHRlbihPYmplY3QudmFsdWVzKHByb3ZpZGVkKSkpID8/IFtdO1xuICAgICAgZm9yIChjb25zdCBpbnZhbGlkYXRlIG9mIGludmFsaWRhdGVTdWJzY3JpcHRpb25zKSB7XG4gICAgICAgIHRvSW52YWxpZGF0ZS5hZGQoaW52YWxpZGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmbGF0dGVuKEFycmF5LmZyb20odG9JbnZhbGlkYXRlLnZhbHVlcygpKS5tYXAocXVlcnlDYWNoZUtleSA9PiB7XG4gICAgICBjb25zdCBxdWVyeVN1YlN0YXRlID0gYXBpU3RhdGUucXVlcmllc1txdWVyeUNhY2hlS2V5XTtcbiAgICAgIHJldHVybiBxdWVyeVN1YlN0YXRlID8gW3tcbiAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgZW5kcG9pbnROYW1lOiBxdWVyeVN1YlN0YXRlLmVuZHBvaW50TmFtZSEsXG4gICAgICAgIG9yaWdpbmFsQXJnczogcXVlcnlTdWJTdGF0ZS5vcmlnaW5hbEFyZ3NcbiAgICAgIH1dIDogW107XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdENhY2hlZEFyZ3NGb3JRdWVyeTxRdWVyeU5hbWUgZXh0ZW5kcyBBbGxRdWVyeUtleXM8RGVmaW5pdGlvbnM+PihzdGF0ZTogUm9vdFN0YXRlLCBxdWVyeU5hbWU6IFF1ZXJ5TmFtZSk6IEFycmF5PFF1ZXJ5QXJnRnJvbUFueVF1ZXJ5PERlZmluaXRpb25zW1F1ZXJ5TmFtZV0+PiB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc2VsZWN0UXVlcmllcyhzdGF0ZSkgYXMgUXVlcnlTdGF0ZTxhbnk+KS5maWx0ZXIoKGVudHJ5KTogZW50cnkgaXMgRXhjbHVkZTxRdWVyeVN1YlN0YXRlPERlZmluaXRpb25zW1F1ZXJ5TmFtZV0+LCB7XG4gICAgICBzdGF0dXM6IFF1ZXJ5U3RhdHVzLnVuaW5pdGlhbGl6ZWQ7XG4gICAgfT4gPT4gZW50cnk/LmVuZHBvaW50TmFtZSA9PT0gcXVlcnlOYW1lICYmIGVudHJ5LnN0YXR1cyAhPT0gUXVlcnlTdGF0dXMudW5pbml0aWFsaXplZCkubWFwKGVudHJ5ID0+IGVudHJ5Lm9yaWdpbmFsQXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SGFzTmV4dFBhZ2Uob3B0aW9uczogSW5maW5pdGVRdWVyeUNvbmZpZ09wdGlvbnM8YW55LCBhbnksIGFueT4sIGRhdGE/OiBJbmZpbml0ZURhdGE8dW5rbm93biwgdW5rbm93bj4sIHF1ZXJ5QXJnPzogdW5rbm93bik6IGJvb2xlYW4ge1xuICAgIGlmICghZGF0YSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBnZXROZXh0UGFnZVBhcmFtKG9wdGlvbnMsIGRhdGEsIHF1ZXJ5QXJnKSAhPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGdldEhhc1ByZXZpb3VzUGFnZShvcHRpb25zOiBJbmZpbml0ZVF1ZXJ5Q29uZmlnT3B0aW9uczxhbnksIGFueSwgYW55PiwgZGF0YT86IEluZmluaXRlRGF0YTx1bmtub3duLCB1bmtub3duPiwgcXVlcnlBcmc/OiB1bmtub3duKTogYm9vbGVhbiB7XG4gICAgaWYgKCFkYXRhIHx8ICFvcHRpb25zLmdldFByZXZpb3VzUGFnZVBhcmFtKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGdldFByZXZpb3VzUGFnZVBhcmFtKG9wdGlvbnMsIGRhdGEsIHF1ZXJ5QXJnKSAhPSBudWxsO1xuICB9XG59IiwiaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSwgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIsIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB0eXBlIHsgQXBpLCBBcGlDb250ZXh0LCBNb2R1bGUsIE1vZHVsZU5hbWUgfSBmcm9tICcuL2FwaVR5cGVzJztcbmltcG9ydCB0eXBlIHsgQ29tYmluZWRTdGF0ZSB9IGZyb20gJy4vY29yZS9hcGlTdGF0ZSc7XG5pbXBvcnQgdHlwZSB7IEJhc2VRdWVyeUFyZywgQmFzZVF1ZXJ5Rm4gfSBmcm9tICcuL2Jhc2VRdWVyeVR5cGVzJztcbmltcG9ydCB0eXBlIHsgU2VyaWFsaXplUXVlcnlBcmdzIH0gZnJvbSAnLi9kZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzJztcbmltcG9ydCB7IGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MgfSBmcm9tICcuL2RlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MnO1xuaW1wb3J0IHR5cGUgeyBFbmRwb2ludEJ1aWxkZXIsIEVuZHBvaW50RGVmaW5pdGlvbnMsIFNjaGVtYUZhaWx1cmVDb252ZXJ0ZXIsIFNjaGVtYUZhaWx1cmVIYW5kbGVyIH0gZnJvbSAnLi9lbmRwb2ludERlZmluaXRpb25zJztcbmltcG9ydCB7IERlZmluaXRpb25UeXBlLCBpc0luZmluaXRlUXVlcnlEZWZpbml0aW9uLCBpc1F1ZXJ5RGVmaW5pdGlvbiB9IGZyb20gJy4vZW5kcG9pbnREZWZpbml0aW9ucyc7XG5pbXBvcnQgeyBuYW5vaWQgfSBmcm9tICcuL2NvcmUvcnRrSW1wb3J0cyc7XG5pbXBvcnQgdHlwZSB7IFVua25vd25BY3Rpb24gfSBmcm9tICdAcmVkdXhqcy90b29sa2l0JztcbmltcG9ydCB0eXBlIHsgTm9JbmZlciB9IGZyb20gJy4vdHNIZWxwZXJzJztcbmltcG9ydCB7IHdlYWtNYXBNZW1vaXplIH0gZnJvbSAncmVzZWxlY3QnO1xuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVBcGlPcHRpb25zPEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBEZWZpbml0aW9ucyBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbnMsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gJ2FwaScsIFRhZ1R5cGVzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+IHtcbiAgLyoqXG4gICAqIFRoZSBiYXNlIHF1ZXJ5IHVzZWQgYnkgZWFjaCBlbmRwb2ludCBpZiBubyBgcXVlcnlGbmAgb3B0aW9uIGlzIHNwZWNpZmllZC4gUlRLIFF1ZXJ5IGV4cG9ydHMgYSB1dGlsaXR5IGNhbGxlZCBbZmV0Y2hCYXNlUXVlcnldKC4vZmV0Y2hCYXNlUXVlcnkpIGFzIGEgbGlnaHR3ZWlnaHQgd3JhcHBlciBhcm91bmQgYGZldGNoYCBmb3IgY29tbW9uIHVzZS1jYXNlcy4gU2VlIFtDdXN0b21pemluZyBRdWVyaWVzXSguLi8uLi9ydGstcXVlcnkvdXNhZ2UvY3VzdG9taXppbmctcXVlcmllcykgaWYgYGZldGNoQmFzZVF1ZXJ5YCBkb2VzIG5vdCBoYW5kbGUgeW91ciByZXF1aXJlbWVudHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCB7IGNyZWF0ZUFwaSwgZmV0Y2hCYXNlUXVlcnkgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5J1xuICAgKlxuICAgKiBjb25zdCBhcGkgPSBjcmVhdGVBcGkoe1xuICAgKiAgIC8vIGhpZ2hsaWdodC1zdGFydFxuICAgKiAgIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnLycgfSksXG4gICAqICAgLy8gaGlnaGxpZ2h0LWVuZFxuICAgKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAgLy8gLi4uZW5kcG9pbnRzXG4gICAqICAgfSksXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgYmFzZVF1ZXJ5OiBCYXNlUXVlcnk7XG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBzdHJpbmcgdGFnIHR5cGUgbmFtZXMuIFNwZWNpZnlpbmcgdGFnIHR5cGVzIGlzIG9wdGlvbmFsLCBidXQgeW91IHNob3VsZCBkZWZpbmUgdGhlbSBzbyB0aGF0IHRoZXkgY2FuIGJlIHVzZWQgZm9yIGNhY2hpbmcgYW5kIGludmFsaWRhdGlvbi4gV2hlbiBkZWZpbmluZyBhIHRhZyB0eXBlLCB5b3Ugd2lsbCBiZSBhYmxlIHRvIFtwcm92aWRlXSguLi8uLi9ydGstcXVlcnkvdXNhZ2UvYXV0b21hdGVkLXJlZmV0Y2hpbmcjcHJvdmlkaW5nLXRhZ3MpIHRoZW0gd2l0aCBgcHJvdmlkZXNUYWdzYCBhbmQgW2ludmFsaWRhdGVdKC4uLy4uL3J0ay1xdWVyeS91c2FnZS9hdXRvbWF0ZWQtcmVmZXRjaGluZyNpbnZhbGlkYXRpbmctdGFncykgdGhlbSB3aXRoIGBpbnZhbGlkYXRlc1RhZ3NgIHdoZW4gY29uZmlndXJpbmcgW2VuZHBvaW50c10oI2VuZHBvaW50cykuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCB7IGNyZWF0ZUFwaSwgZmV0Y2hCYXNlUXVlcnkgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5J1xuICAgKlxuICAgKiBjb25zdCBhcGkgPSBjcmVhdGVBcGkoe1xuICAgKiAgIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnLycgfSksXG4gICAqICAgLy8gaGlnaGxpZ2h0LXN0YXJ0XG4gICAqICAgdGFnVHlwZXM6IFsnUG9zdCcsICdVc2VyJ10sXG4gICAqICAgLy8gaGlnaGxpZ2h0LWVuZFxuICAgKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAgLy8gLi4uZW5kcG9pbnRzXG4gICAqICAgfSksXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgdGFnVHlwZXM/OiByZWFkb25seSBUYWdUeXBlc1tdO1xuICAvKipcbiAgICogVGhlIGByZWR1Y2VyUGF0aGAgaXMgYSBfdW5pcXVlXyBrZXkgdGhhdCB5b3VyIHNlcnZpY2Ugd2lsbCBiZSBtb3VudGVkIHRvIGluIHlvdXIgc3RvcmUuIElmIHlvdSBjYWxsIGBjcmVhdGVBcGlgIG1vcmUgdGhhbiBvbmNlIGluIHlvdXIgYXBwbGljYXRpb24sIHlvdSB3aWxsIG5lZWQgdG8gcHJvdmlkZSBhIHVuaXF1ZSB2YWx1ZSBlYWNoIHRpbWUuIERlZmF1bHRzIHRvIGAnYXBpJ2AuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIHRpdGxlPVwiYXBpcy5qc1wiXG4gICAqIGltcG9ydCB7IGNyZWF0ZUFwaSwgZmV0Y2hCYXNlUXVlcnkgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5JztcbiAgICpcbiAgICogY29uc3QgYXBpT25lID0gY3JlYXRlQXBpKHtcbiAgICogICAvLyBoaWdobGlnaHQtc3RhcnRcbiAgICogICByZWR1Y2VyUGF0aDogJ2FwaU9uZScsXG4gICAqICAgLy8gaGlnaGxpZ2h0LWVuZFxuICAgKiAgIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnLycgfSksXG4gICAqICAgZW5kcG9pbnRzOiAoYnVpbGRlcikgPT4gKHtcbiAgICogICAgIC8vIC4uLmVuZHBvaW50c1xuICAgKiAgIH0pLFxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3QgYXBpVHdvID0gY3JlYXRlQXBpKHtcbiAgICogICAvLyBoaWdobGlnaHQtc3RhcnRcbiAgICogICByZWR1Y2VyUGF0aDogJ2FwaVR3bycsXG4gICAqICAgLy8gaGlnaGxpZ2h0LWVuZFxuICAgKiAgIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnLycgfSksXG4gICAqICAgZW5kcG9pbnRzOiAoYnVpbGRlcikgPT4gKHtcbiAgICogICAgIC8vIC4uLmVuZHBvaW50c1xuICAgKiAgIH0pLFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICByZWR1Y2VyUGF0aD86IFJlZHVjZXJQYXRoO1xuICAvKipcbiAgICogQWNjZXB0cyBhIGN1c3RvbSBmdW5jdGlvbiBpZiB5b3UgaGF2ZSBhIG5lZWQgdG8gY2hhbmdlIHRoZSBjcmVhdGlvbiBvZiBjYWNoZSBrZXlzIGZvciBhbnkgcmVhc29uLlxuICAgKi9cbiAgc2VyaWFsaXplUXVlcnlBcmdzPzogU2VyaWFsaXplUXVlcnlBcmdzPHVua25vd24+O1xuICAvKipcbiAgICogRW5kcG9pbnRzIGFyZSBhIHNldCBvZiBvcGVyYXRpb25zIHRoYXQgeW91IHdhbnQgdG8gcGVyZm9ybSBhZ2FpbnN0IHlvdXIgc2VydmVyLiBZb3UgZGVmaW5lIHRoZW0gYXMgYW4gb2JqZWN0IHVzaW5nIHRoZSBidWlsZGVyIHN5bnRheC4gVGhlcmUgYXJlIHRocmVlIGVuZHBvaW50IHR5cGVzOiBbYHF1ZXJ5YF0oLi4vLi4vcnRrLXF1ZXJ5L3VzYWdlL3F1ZXJpZXMpLCBbYGluZmluaXRlUXVlcnlgXSguLi8uLi9ydGstcXVlcnkvdXNhZ2UvaW5maW5pdGUtcXVlcmllcykgYW5kIFtgbXV0YXRpb25gXSguLi8uLi9ydGstcXVlcnkvdXNhZ2UvbXV0YXRpb25zKS5cbiAgICovXG4gIGVuZHBvaW50cyhidWlsZDogRW5kcG9pbnRCdWlsZGVyPEJhc2VRdWVyeSwgVGFnVHlwZXMsIFJlZHVjZXJQYXRoPik6IERlZmluaXRpb25zO1xuICAvKipcbiAgICogRGVmYXVsdHMgdG8gYDYwYCBfKHRoaXMgdmFsdWUgaXMgaW4gc2Vjb25kcylfLiBUaGlzIGlzIGhvdyBsb25nIFJUSyBRdWVyeSB3aWxsIGtlZXAgeW91ciBkYXRhIGNhY2hlZCBmb3IgKiphZnRlcioqIHRoZSBsYXN0IGNvbXBvbmVudCB1bnN1YnNjcmliZXMuIEZvciBleGFtcGxlLCBpZiB5b3UgcXVlcnkgYW4gZW5kcG9pbnQsIHRoZW4gdW5tb3VudCB0aGUgY29tcG9uZW50LCB0aGVuIG1vdW50IGFub3RoZXIgY29tcG9uZW50IHRoYXQgbWFrZXMgdGhlIHNhbWUgcmVxdWVzdCB3aXRoaW4gdGhlIGdpdmVuIHRpbWUgZnJhbWUsIHRoZSBtb3N0IHJlY2VudCB2YWx1ZSB3aWxsIGJlIHNlcnZlZCBmcm9tIHRoZSBjYWNoZS5cbiAgICpcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgdGl0bGU9XCJrZWVwVW51c2VkRGF0YUZvciBleGFtcGxlXCJcbiAgICpcbiAgICogaW1wb3J0IHsgY3JlYXRlQXBpLCBmZXRjaEJhc2VRdWVyeSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnXG4gICAqIGludGVyZmFjZSBQb3N0IHtcbiAgICogICBpZDogbnVtYmVyXG4gICAqICAgbmFtZTogc3RyaW5nXG4gICAqIH1cbiAgICogdHlwZSBQb3N0c1Jlc3BvbnNlID0gUG9zdFtdXG4gICAqXG4gICAqIGNvbnN0IGFwaSA9IGNyZWF0ZUFwaSh7XG4gICAqICAgYmFzZVF1ZXJ5OiBmZXRjaEJhc2VRdWVyeSh7IGJhc2VVcmw6ICcvJyB9KSxcbiAgICogICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAgICogICAgIGdldFBvc3RzOiBidWlsZC5xdWVyeTxQb3N0c1Jlc3BvbnNlLCB2b2lkPih7XG4gICAqICAgICAgIHF1ZXJ5OiAoKSA9PiAncG9zdHMnLFxuICAgKiAgICAgICAvLyBoaWdobGlnaHQtc3RhcnRcbiAgICogICAgICAga2VlcFVudXNlZERhdGFGb3I6IDVcbiAgICogICAgICAgLy8gaGlnaGxpZ2h0LWVuZFxuICAgKiAgICAgfSlcbiAgICogICB9KVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIGtlZXBVbnVzZWREYXRhRm9yPzogbnVtYmVyO1xuICAvKipcbiAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC4gVGhpcyBzZXR0aW5nIGFsbG93cyB5b3UgdG8gY29udHJvbCB3aGV0aGVyIGlmIGEgY2FjaGVkIHJlc3VsdCBpcyBhbHJlYWR5IGF2YWlsYWJsZSBSVEsgUXVlcnkgd2lsbCBvbmx5IHNlcnZlIGEgY2FjaGVkIHJlc3VsdCwgb3IgaWYgaXQgc2hvdWxkIGByZWZldGNoYCB3aGVuIHNldCB0byBgdHJ1ZWAgb3IgaWYgYW4gYWRlcXVhdGUgYW1vdW50IG9mIHRpbWUgaGFzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCBzdWNjZXNzZnVsIHF1ZXJ5IHJlc3VsdC5cbiAgICogLSBgZmFsc2VgIC0gV2lsbCBub3QgY2F1c2UgYSBxdWVyeSB0byBiZSBwZXJmb3JtZWQgX3VubGVzc18gaXQgZG9lcyBub3QgZXhpc3QgeWV0LlxuICAgKiAtIGB0cnVlYCAtIFdpbGwgYWx3YXlzIHJlZmV0Y2ggd2hlbiBhIG5ldyBzdWJzY3JpYmVyIHRvIGEgcXVlcnkgaXMgYWRkZWQuIEJlaGF2ZXMgdGhlIHNhbWUgYXMgY2FsbGluZyB0aGUgYHJlZmV0Y2hgIGNhbGxiYWNrIG9yIHBhc3NpbmcgYGZvcmNlUmVmZXRjaDogdHJ1ZWAgaW4gdGhlIGFjdGlvbiBjcmVhdG9yLlxuICAgKiAtIGBudW1iZXJgIC0gKipWYWx1ZSBpcyBpbiBzZWNvbmRzKiouIElmIGEgbnVtYmVyIGlzIHByb3ZpZGVkIGFuZCB0aGVyZSBpcyBhbiBleGlzdGluZyBxdWVyeSBpbiB0aGUgY2FjaGUsIGl0IHdpbGwgY29tcGFyZSB0aGUgY3VycmVudCB0aW1lIHZzIHRoZSBsYXN0IGZ1bGZpbGxlZCB0aW1lc3RhbXAsIGFuZCBvbmx5IHJlZmV0Y2ggaWYgZW5vdWdoIHRpbWUgaGFzIGVsYXBzZWQuXG4gICAqXG4gICAqIElmIHlvdSBzcGVjaWZ5IHRoaXMgb3B0aW9uIGFsb25nc2lkZSBgc2tpcDogdHJ1ZWAsIHRoaXMgKip3aWxsIG5vdCBiZSBldmFsdWF0ZWQqKiB1bnRpbCBgc2tpcGAgaXMgZmFsc2UuXG4gICAqL1xuICByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlPzogYm9vbGVhbiB8IG51bWJlcjtcbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuIFRoaXMgc2V0dGluZyBhbGxvd3MgeW91IHRvIGNvbnRyb2wgd2hldGhlciBSVEsgUXVlcnkgd2lsbCB0cnkgdG8gcmVmZXRjaCBhbGwgc3Vic2NyaWJlZCBxdWVyaWVzIGFmdGVyIHRoZSBhcHBsaWNhdGlvbiB3aW5kb3cgcmVnYWlucyBmb2N1cy5cbiAgICpcbiAgICogSWYgeW91IHNwZWNpZnkgdGhpcyBvcHRpb24gYWxvbmdzaWRlIGBza2lwOiB0cnVlYCwgdGhpcyAqKndpbGwgbm90IGJlIGV2YWx1YXRlZCoqIHVudGlsIGBza2lwYCBpcyBmYWxzZS5cbiAgICpcbiAgICogTm90ZTogcmVxdWlyZXMgW2BzZXR1cExpc3RlbmVyc2BdKC4vc2V0dXBMaXN0ZW5lcnMpIHRvIGhhdmUgYmVlbiBjYWxsZWQuXG4gICAqL1xuICByZWZldGNoT25Gb2N1cz86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLiBUaGlzIHNldHRpbmcgYWxsb3dzIHlvdSB0byBjb250cm9sIHdoZXRoZXIgUlRLIFF1ZXJ5IHdpbGwgdHJ5IHRvIHJlZmV0Y2ggYWxsIHN1YnNjcmliZWQgcXVlcmllcyBhZnRlciByZWdhaW5pbmcgYSBuZXR3b3JrIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIElmIHlvdSBzcGVjaWZ5IHRoaXMgb3B0aW9uIGFsb25nc2lkZSBgc2tpcDogdHJ1ZWAsIHRoaXMgKip3aWxsIG5vdCBiZSBldmFsdWF0ZWQqKiB1bnRpbCBgc2tpcGAgaXMgZmFsc2UuXG4gICAqXG4gICAqIE5vdGU6IHJlcXVpcmVzIFtgc2V0dXBMaXN0ZW5lcnNgXSguL3NldHVwTGlzdGVuZXJzKSB0byBoYXZlIGJlZW4gY2FsbGVkLlxuICAgKi9cbiAgcmVmZXRjaE9uUmVjb25uZWN0PzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIGAnZGVsYXllZCdgLiBUaGlzIHNldHRpbmcgYWxsb3dzIHlvdSB0byBjb250cm9sIHdoZW4gdGFncyBhcmUgaW52YWxpZGF0ZWQgYWZ0ZXIgYSBtdXRhdGlvbi5cbiAgICpcbiAgICogLSBgJ2ltbWVkaWF0ZWx5J2A6IFF1ZXJpZXMgYXJlIGludmFsaWRhdGVkIGluc3RhbnRseSBhZnRlciB0aGUgbXV0YXRpb24gZmluaXNoZWQsIGV2ZW4gaWYgdGhleSBhcmUgcnVubmluZy5cbiAgICogICBJZiB0aGUgcXVlcnkgcHJvdmlkZXMgdGFncyB0aGF0IHdlcmUgaW52YWxpZGF0ZWQgd2hpbGUgaXQgcmFuLCBpdCB3b24ndCBiZSByZS1mZXRjaGVkLlxuICAgKiAtIGAnZGVsYXllZCdgOiBJbnZhbGlkYXRpb24gb25seSBoYXBwZW5zIGFmdGVyIGFsbCBxdWVyaWVzIGFuZCBtdXRhdGlvbnMgYXJlIHNldHRsZWQuXG4gICAqICAgVGhpcyBlbnN1cmVzIHRoYXQgcXVlcmllcyBhcmUgYWx3YXlzIGludmFsaWRhdGVkIGNvcnJlY3RseSBhbmQgYXV0b21hdGljYWxseSBcImJhdGNoZXNcIiBpbnZhbGlkYXRpb25zIG9mIGNvbmN1cnJlbnQgbXV0YXRpb25zLlxuICAgKiAgIE5vdGUgdGhhdCBpZiB5b3UgY29uc3RhbnRseSBoYXZlIHNvbWUgcXVlcmllcyAob3IgbXV0YXRpb25zKSBydW5uaW5nLCB0aGlzIGNhbiBkZWxheSB0YWcgaW52YWxpZGF0aW9ucyBpbmRlZmluaXRlbHkuXG4gICAqL1xuICBpbnZhbGlkYXRpb25CZWhhdmlvcj86ICdkZWxheWVkJyB8ICdpbW1lZGlhdGVseSc7XG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgaXMgcGFzc2VkIGV2ZXJ5IGRpc3BhdGNoZWQgYWN0aW9uLiBJZiB0aGlzIHJldHVybnMgc29tZXRoaW5nIG90aGVyIHRoYW4gYHVuZGVmaW5lZGAsXG4gICAqIHRoYXQgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZCB0byByZWh5ZHJhdGUgZnVsZmlsbGVkICYgZXJyb3JlZCBxdWVyaWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiAvLyBjb2RlYmxvY2stbWV0YSB0aXRsZT1cIm5leHQtcmVkdXgtd3JhcHBlciByZWh5ZHJhdGlvbiBleGFtcGxlXCJcbiAgICogaW1wb3J0IHR5cGUgeyBBY3Rpb24sIFBheWxvYWRBY3Rpb24gfSBmcm9tICdAcmVkdXhqcy90b29sa2l0J1xuICAgKiBpbXBvcnQgeyBjcmVhdGVBcGksIGZldGNoQmFzZVF1ZXJ5IH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeS9yZWFjdCdcbiAgICogaW1wb3J0IHsgSFlEUkFURSB9IGZyb20gJ25leHQtcmVkdXgtd3JhcHBlcidcbiAgICpcbiAgICogdHlwZSBSb290U3RhdGUgPSBhbnk7IC8vIG5vcm1hbGx5IGluZmVycmVkIGZyb20gc3RhdGVcbiAgICpcbiAgICogZnVuY3Rpb24gaXNIeWRyYXRlQWN0aW9uKGFjdGlvbjogQWN0aW9uKTogYWN0aW9uIGlzIFBheWxvYWRBY3Rpb248Um9vdFN0YXRlPiB7XG4gICAqICAgcmV0dXJuIGFjdGlvbi50eXBlID09PSBIWURSQVRFXG4gICAqIH1cbiAgICpcbiAgICogZXhwb3J0IGNvbnN0IGFwaSA9IGNyZWF0ZUFwaSh7XG4gICAqICAgYmFzZVF1ZXJ5OiBmZXRjaEJhc2VRdWVyeSh7IGJhc2VVcmw6ICcvJyB9KSxcbiAgICogICAvLyBoaWdobGlnaHQtc3RhcnRcbiAgICogICBleHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbiwgeyByZWR1Y2VyUGF0aCB9KTogYW55IHtcbiAgICogICAgIGlmIChpc0h5ZHJhdGVBY3Rpb24oYWN0aW9uKSkge1xuICAgKiAgICAgICByZXR1cm4gYWN0aW9uLnBheWxvYWRbcmVkdWNlclBhdGhdXG4gICAqICAgICB9XG4gICAqICAgfSxcbiAgICogICAvLyBoaWdobGlnaHQtZW5kXG4gICAqICAgZW5kcG9pbnRzOiAoYnVpbGQpID0+ICh7XG4gICAqICAgICAvLyBvbWl0dGVkXG4gICAqICAgfSksXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgZXh0cmFjdFJlaHlkcmF0aW9uSW5mbz86IChhY3Rpb246IFVua25vd25BY3Rpb24sIHtcbiAgICByZWR1Y2VyUGF0aFxuICB9OiB7XG4gICAgcmVkdWNlclBhdGg6IFJlZHVjZXJQYXRoO1xuICB9KSA9PiB1bmRlZmluZWQgfCBDb21iaW5lZFN0YXRlPE5vSW5mZXI8RGVmaW5pdGlvbnM+LCBOb0luZmVyPFRhZ1R5cGVzPiwgTm9JbmZlcjxSZWR1Y2VyUGF0aD4+O1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBzY2hlbWEgdmFsaWRhdGlvbiBmYWlscy5cbiAgICpcbiAgICogR2V0cyBjYWxsZWQgd2l0aCBhIGBOYW1lZFNjaGVtYUVycm9yYCBhbmQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVuZHBvaW50IG5hbWUsIHRoZSB0eXBlIG9mIHRoZSBlbmRwb2ludCwgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgZW5kcG9pbnQsIGFuZCB0aGUgcXVlcnkgY2FjaGUga2V5IChpZiBhcHBsaWNhYmxlKS5cbiAgICpcbiAgICogYE5hbWVkU2NoZW1hRXJyb3JgIGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqIC0gYGlzc3Vlc2A6IGFuIGFycmF5IG9mIGlzc3VlcyB0aGF0IGNhdXNlZCB0aGUgdmFsaWRhdGlvbiB0byBmYWlsXG4gICAqIC0gYHZhbHVlYDogdGhlIHZhbHVlIHRoYXQgd2FzIHBhc3NlZCB0byB0aGUgc2NoZW1hXG4gICAqIC0gYHNjaGVtYU5hbWVgOiB0aGUgbmFtZSBvZiB0aGUgc2NoZW1hIHRoYXQgd2FzIHVzZWQgdG8gdmFsaWRhdGUgdGhlIHZhbHVlIChlLmcuIGBhcmdTY2hlbWFgKVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBjb2RlYmxvY2stbWV0YSBuby10cmFuc3BpbGVcbiAgICogaW1wb3J0IHsgY3JlYXRlQXBpIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeS9yZWFjdCdcbiAgICogaW1wb3J0ICogYXMgdiBmcm9tIFwidmFsaWJvdFwiXG4gICAqXG4gICAqIGNvbnN0IGFwaSA9IGNyZWF0ZUFwaSh7XG4gICAqICAgYmFzZVF1ZXJ5OiBmZXRjaEJhc2VRdWVyeSh7IGJhc2VVcmw6ICcvJyB9KSxcbiAgICogICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAgICogICAgIGdldFBvc3Q6IGJ1aWxkLnF1ZXJ5PFBvc3QsIHsgaWQ6IG51bWJlciB9Pih7XG4gICAqICAgICAgIHF1ZXJ5OiAoeyBpZCB9KSA9PiBgL3Bvc3QvJHtpZH1gLFxuICAgKiAgICAgfSksXG4gICAqICAgfSksXG4gICAqICAgb25TY2hlbWFGYWlsdXJlOiAoZXJyb3IsIGluZm8pID0+IHtcbiAgICogICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IsIGluZm8pXG4gICAqICAgfSxcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBvblNjaGVtYUZhaWx1cmU/OiBTY2hlbWFGYWlsdXJlSGFuZGxlcjtcblxuICAvKipcbiAgICogQ29udmVydCBhIHNjaGVtYSB2YWxpZGF0aW9uIGZhaWx1cmUgaW50byBhbiBlcnJvciBzaGFwZSBtYXRjaGluZyBiYXNlIHF1ZXJ5IGVycm9ycy5cbiAgICpcbiAgICogV2hlbiBub3QgcHJvdmlkZWQsIHNjaGVtYSBmYWlsdXJlcyBhcmUgdHJlYXRlZCBhcyBmYXRhbCwgYW5kIG5vcm1hbCBlcnJvciBoYW5kbGluZyBzdWNoIGFzIHRhZyBpbnZhbGlkYXRpb24gd2lsbCBub3QgYmUgZXhlY3V0ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIG5vLXRyYW5zcGlsZVxuICAgKiBpbXBvcnQgeyBjcmVhdGVBcGkgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5L3JlYWN0J1xuICAgKiBpbXBvcnQgKiBhcyB2IGZyb20gXCJ2YWxpYm90XCJcbiAgICpcbiAgICogY29uc3QgYXBpID0gY3JlYXRlQXBpKHtcbiAgICogICBiYXNlUXVlcnk6IGZldGNoQmFzZVF1ZXJ5KHsgYmFzZVVybDogJy8nIH0pLFxuICAgKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAgZ2V0UG9zdDogYnVpbGQucXVlcnk8UG9zdCwgeyBpZDogbnVtYmVyIH0+KHtcbiAgICogICAgICAgcXVlcnk6ICh7IGlkIH0pID0+IGAvcG9zdC8ke2lkfWAsXG4gICAqICAgICAgIHJlc3BvbnNlU2NoZW1hOiB2Lm9iamVjdCh7IGlkOiB2Lm51bWJlcigpLCBuYW1lOiB2LnN0cmluZygpIH0pLFxuICAgKiAgICAgfSksXG4gICAqICAgfSksXG4gICAqICAgY2F0Y2hTY2hlbWFGYWlsdXJlOiAoZXJyb3IsIGluZm8pID0+ICh7XG4gICAqICAgICBzdGF0dXM6IFwiQ1VTVE9NX0VSUk9SXCIsXG4gICAqICAgICBlcnJvcjogZXJyb3Iuc2NoZW1hTmFtZSArIFwiIGZhaWxlZCB2YWxpZGF0aW9uXCIsXG4gICAqICAgICBkYXRhOiBlcnJvci5pc3N1ZXMsXG4gICAqICAgfSksXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgY2F0Y2hTY2hlbWFGYWlsdXJlPzogU2NoZW1hRmFpbHVyZUNvbnZlcnRlcjxCYXNlUXVlcnk+O1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKlxuICAgKiBJZiBzZXQgdG8gYHRydWVgLCB3aWxsIHNraXAgc2NoZW1hIHZhbGlkYXRpb24gZm9yIGFsbCBlbmRwb2ludHMsIHVubGVzcyBvdmVycmlkZGVuIGJ5IHRoZSBlbmRwb2ludC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgbm8tdHJhbnNwaWxlXG4gICAqIGltcG9ydCB7IGNyZWF0ZUFwaSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnXG4gICAqIGltcG9ydCAqIGFzIHYgZnJvbSBcInZhbGlib3RcIlxuICAgKlxuICAgKiBjb25zdCBhcGkgPSBjcmVhdGVBcGkoe1xuICAgKiAgIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnLycgfSksXG4gICAqICAgc2tpcFNjaGVtYVZhbGlkYXRpb246IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiwgLy8gc2tpcCBzY2hlbWEgdmFsaWRhdGlvbiBpbiB0ZXN0cywgc2luY2Ugd2UnbGwgYmUgbW9ja2luZyB0aGUgcmVzcG9uc2VcbiAgICogICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAgICogICAgIGdldFBvc3Q6IGJ1aWxkLnF1ZXJ5PFBvc3QsIHsgaWQ6IG51bWJlciB9Pih7XG4gICAqICAgICAgIHF1ZXJ5OiAoeyBpZCB9KSA9PiBgL3Bvc3QvJHtpZH1gLFxuICAgKiAgICAgICByZXNwb25zZVNjaGVtYTogdi5vYmplY3QoeyBpZDogdi5udW1iZXIoKSwgbmFtZTogdi5zdHJpbmcoKSB9KSxcbiAgICogICAgIH0pLFxuICAgKiAgIH0pXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgc2tpcFNjaGVtYVZhbGlkYXRpb24/OiBib29sZWFuO1xufVxuZXhwb3J0IHR5cGUgQ3JlYXRlQXBpPE1vZHVsZXMgZXh0ZW5kcyBNb2R1bGVOYW1lPiA9IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzZXJ2aWNlIHRvIHVzZSBpbiB5b3VyIGFwcGxpY2F0aW9uLiBDb250YWlucyBvbmx5IHRoZSBiYXNpYyByZWR1eCBsb2dpYyAodGhlIGNvcmUgbW9kdWxlKS5cbiAgICpcbiAgICogQGxpbmsgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9ydGstcXVlcnkvYXBpL2NyZWF0ZUFwaVxuICAgKi9cbiAgPEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBEZWZpbml0aW9ucyBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbnMsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gJ2FwaScsIFRhZ1R5cGVzIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+KG9wdGlvbnM6IENyZWF0ZUFwaU9wdGlvbnM8QmFzZVF1ZXJ5LCBEZWZpbml0aW9ucywgUmVkdWNlclBhdGgsIFRhZ1R5cGVzPik6IEFwaTxCYXNlUXVlcnksIERlZmluaXRpb25zLCBSZWR1Y2VyUGF0aCwgVGFnVHlwZXMsIE1vZHVsZXM+O1xufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBgY3JlYXRlQXBpYCBtZXRob2QgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGBtb2R1bGVzYC5cbiAqXG4gKiBAbGluayBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL3J0ay1xdWVyeS91c2FnZS9jdXN0b21pemluZy1jcmVhdGUtYXBpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBNeUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PFJlYWN0UmVkdXhDb250ZXh0VmFsdWUgfCBudWxsPihudWxsKTtcbiAqIGNvbnN0IGN1c3RvbUNyZWF0ZUFwaSA9IGJ1aWxkQ3JlYXRlQXBpKFxuICogICBjb3JlTW9kdWxlKCksXG4gKiAgIHJlYWN0SG9va3NNb2R1bGUoe1xuICogICAgIGhvb2tzOiB7XG4gKiAgICAgICB1c2VEaXNwYXRjaDogY3JlYXRlRGlzcGF0Y2hIb29rKE15Q29udGV4dCksXG4gKiAgICAgICB1c2VTZWxlY3RvcjogY3JlYXRlU2VsZWN0b3JIb29rKE15Q29udGV4dCksXG4gKiAgICAgICB1c2VTdG9yZTogY3JlYXRlU3RvcmVIb29rKE15Q29udGV4dClcbiAqICAgICB9XG4gKiAgIH0pXG4gKiApO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG1vZHVsZXMgLSBBIHZhcmlhYmxlIG51bWJlciBvZiBtb2R1bGVzIHRoYXQgY3VzdG9taXplIGhvdyB0aGUgYGNyZWF0ZUFwaWAgbWV0aG9kIGhhbmRsZXMgZW5kcG9pbnRzXG4gKiBAcmV0dXJucyBBIGBjcmVhdGVBcGlgIG1ldGhvZCB1c2luZyB0aGUgcHJvdmlkZWQgYG1vZHVsZXNgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRDcmVhdGVBcGk8TW9kdWxlcyBleHRlbmRzIFtNb2R1bGU8YW55PiwgLi4uTW9kdWxlPGFueT5bXV0+KC4uLm1vZHVsZXM6IE1vZHVsZXMpOiBDcmVhdGVBcGk8TW9kdWxlc1tudW1iZXJdWyduYW1lJ10+IHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJhc2VDcmVhdGVBcGkob3B0aW9ucykge1xuICAgIGNvbnN0IGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8gPSB3ZWFrTWFwTWVtb2l6ZSgoYWN0aW9uOiBVbmtub3duQWN0aW9uKSA9PiBvcHRpb25zLmV4dHJhY3RSZWh5ZHJhdGlvbkluZm8/LihhY3Rpb24sIHtcbiAgICAgIHJlZHVjZXJQYXRoOiAob3B0aW9ucy5yZWR1Y2VyUGF0aCA/PyAnYXBpJykgYXMgYW55XG4gICAgfSkpO1xuICAgIGNvbnN0IG9wdGlvbnNXaXRoRGVmYXVsdHM6IENyZWF0ZUFwaU9wdGlvbnM8YW55LCBhbnksIGFueSwgYW55PiA9IHtcbiAgICAgIHJlZHVjZXJQYXRoOiAnYXBpJyxcbiAgICAgIGtlZXBVbnVzZWREYXRhRm9yOiA2MCxcbiAgICAgIHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2U6IGZhbHNlLFxuICAgICAgcmVmZXRjaE9uRm9jdXM6IGZhbHNlLFxuICAgICAgcmVmZXRjaE9uUmVjb25uZWN0OiBmYWxzZSxcbiAgICAgIGludmFsaWRhdGlvbkJlaGF2aW9yOiAnZGVsYXllZCcsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyxcbiAgICAgIHNlcmlhbGl6ZVF1ZXJ5QXJncyhxdWVyeUFyZ3NBcGkpIHtcbiAgICAgICAgbGV0IGZpbmFsU2VyaWFsaXplUXVlcnlBcmdzID0gZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncztcbiAgICAgICAgaWYgKCdzZXJpYWxpemVRdWVyeUFyZ3MnIGluIHF1ZXJ5QXJnc0FwaS5lbmRwb2ludERlZmluaXRpb24pIHtcbiAgICAgICAgICBjb25zdCBlbmRwb2ludFNRQSA9IHF1ZXJ5QXJnc0FwaS5lbmRwb2ludERlZmluaXRpb24uc2VyaWFsaXplUXVlcnlBcmdzITtcbiAgICAgICAgICBmaW5hbFNlcmlhbGl6ZVF1ZXJ5QXJncyA9IHF1ZXJ5QXJnc0FwaSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsUmVzdWx0ID0gZW5kcG9pbnRTUUEocXVlcnlBcmdzQXBpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbFJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgZnVuY3Rpb24gcmV0dXJuZWQgYSBzdHJpbmcsIHVzZSBpdCBhcy1pc1xuICAgICAgICAgICAgICByZXR1cm4gaW5pdGlhbFJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEFzc3VtZSB0aGV5IHJldHVybmVkIGFuIG9iamVjdCAoc3VjaCBhcyBhIHN1YnNldCBvZiB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgLy8gcXVlcnkgYXJncykgb3IgYSBwcmltaXRpdmUsIGFuZCBzZXJpYWxpemUgaXQgb3Vyc2VsdmVzXG4gICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgICAgICAgICAuLi5xdWVyeUFyZ3NBcGksXG4gICAgICAgICAgICAgICAgcXVlcnlBcmdzOiBpbml0aWFsUmVzdWx0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZXJpYWxpemVRdWVyeUFyZ3MpIHtcbiAgICAgICAgICBmaW5hbFNlcmlhbGl6ZVF1ZXJ5QXJncyA9IG9wdGlvbnMuc2VyaWFsaXplUXVlcnlBcmdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5hbFNlcmlhbGl6ZVF1ZXJ5QXJncyhxdWVyeUFyZ3NBcGkpO1xuICAgICAgfSxcbiAgICAgIHRhZ1R5cGVzOiBbLi4uKG9wdGlvbnMudGFnVHlwZXMgfHwgW10pXVxuICAgIH07XG4gICAgY29uc3QgY29udGV4dDogQXBpQ29udGV4dDxFbmRwb2ludERlZmluaXRpb25zPiA9IHtcbiAgICAgIGVuZHBvaW50RGVmaW5pdGlvbnM6IHt9LFxuICAgICAgYmF0Y2goZm4pIHtcbiAgICAgICAgLy8gcGxhY2Vob2xkZXIgXCJiYXRjaFwiIG1ldGhvZCB0byBiZSBvdmVycmlkZGVuIGJ5IHBsdWdpbnMsIGZvciBleGFtcGxlIHdpdGggUmVhY3QudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZVxuICAgICAgICBmbigpO1xuICAgICAgfSxcbiAgICAgIGFwaVVpZDogbmFub2lkKCksXG4gICAgICBleHRyYWN0UmVoeWRyYXRpb25JbmZvLFxuICAgICAgaGFzUmVoeWRyYXRpb25JbmZvOiB3ZWFrTWFwTWVtb2l6ZShhY3Rpb24gPT4gZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyhhY3Rpb24pICE9IG51bGwpXG4gICAgfTtcbiAgICBjb25zdCBhcGkgPSB7XG4gICAgICBpbmplY3RFbmRwb2ludHMsXG4gICAgICBlbmhhbmNlRW5kcG9pbnRzKHtcbiAgICAgICAgYWRkVGFnVHlwZXMsXG4gICAgICAgIGVuZHBvaW50c1xuICAgICAgfSkge1xuICAgICAgICBpZiAoYWRkVGFnVHlwZXMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVUIG9mIGFkZFRhZ1R5cGVzKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnNXaXRoRGVmYXVsdHMudGFnVHlwZXMhLmluY2x1ZGVzKGVUIGFzIGFueSkpIHtcbiAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAob3B0aW9uc1dpdGhEZWZhdWx0cy50YWdUeXBlcyBhcyBhbnlbXSkucHVzaChlVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRwb2ludHMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtlbmRwb2ludE5hbWUsIHBhcnRpYWxEZWZpbml0aW9uXSBvZiBPYmplY3QuZW50cmllcyhlbmRwb2ludHMpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnRpYWxEZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHBhcnRpYWxEZWZpbml0aW9uKGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV0gfHwge30sIHBhcnRpYWxEZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgIH1cbiAgICB9IGFzIEFwaTxCYXNlUXVlcnlGbiwge30sIHN0cmluZywgc3RyaW5nLCBNb2R1bGVzW251bWJlcl1bJ25hbWUnXT47XG4gICAgY29uc3QgaW5pdGlhbGl6ZWRNb2R1bGVzID0gbW9kdWxlcy5tYXAobSA9PiBtLmluaXQoYXBpIGFzIGFueSwgb3B0aW9uc1dpdGhEZWZhdWx0cyBhcyBhbnksIGNvbnRleHQpKTtcbiAgICBmdW5jdGlvbiBpbmplY3RFbmRwb2ludHMoaW5qZWN0OiBQYXJhbWV0ZXJzPHR5cGVvZiBhcGkuaW5qZWN0RW5kcG9pbnRzPlswXSkge1xuICAgICAgY29uc3QgZXZhbHVhdGVkRW5kcG9pbnRzID0gaW5qZWN0LmVuZHBvaW50cyh7XG4gICAgICAgIHF1ZXJ5OiB4ID0+ICh7XG4gICAgICAgICAgLi4ueCxcbiAgICAgICAgICB0eXBlOiBEZWZpbml0aW9uVHlwZS5xdWVyeVxuICAgICAgICB9KSBhcyBhbnksXG4gICAgICAgIG11dGF0aW9uOiB4ID0+ICh7XG4gICAgICAgICAgLi4ueCxcbiAgICAgICAgICB0eXBlOiBEZWZpbml0aW9uVHlwZS5tdXRhdGlvblxuICAgICAgICB9KSBhcyBhbnksXG4gICAgICAgIGluZmluaXRlUXVlcnk6IHggPT4gKHtcbiAgICAgICAgICAuLi54LFxuICAgICAgICAgIHR5cGU6IERlZmluaXRpb25UeXBlLmluZmluaXRlcXVlcnlcbiAgICAgICAgfSkgYXMgYW55XG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgW2VuZHBvaW50TmFtZSwgZGVmaW5pdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMoZXZhbHVhdGVkRW5kcG9pbnRzKSkge1xuICAgICAgICBpZiAoaW5qZWN0Lm92ZXJyaWRlRXhpc3RpbmcgIT09IHRydWUgJiYgZW5kcG9pbnROYW1lIGluIGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9ucykge1xuICAgICAgICAgIGlmIChpbmplY3Qub3ZlcnJpZGVFeGlzdGluZyA9PT0gJ3Rocm93Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDM5KSA6IGBjYWxsZWQgXFxgaW5qZWN0RW5kcG9pbnRzXFxgIHRvIG92ZXJyaWRlIGFscmVhZHktZXhpc3RpbmcgZW5kcG9pbnROYW1lICR7ZW5kcG9pbnROYW1lfSB3aXRob3V0IHNwZWNpZnlpbmcgXFxgb3ZlcnJpZGVFeGlzdGluZzogdHJ1ZVxcYGApO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBjYWxsZWQgXFxgaW5qZWN0RW5kcG9pbnRzXFxgIHRvIG92ZXJyaWRlIGFscmVhZHktZXhpc3RpbmcgZW5kcG9pbnROYW1lICR7ZW5kcG9pbnROYW1lfSB3aXRob3V0IHNwZWNpZnlpbmcgXFxgb3ZlcnJpZGVFeGlzdGluZzogdHJ1ZVxcYGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgaWYgKGlzSW5maW5pdGVRdWVyeURlZmluaXRpb24oZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaW5maW5pdGVRdWVyeU9wdGlvbnNcbiAgICAgICAgICAgIH0gPSBkZWZpbml0aW9uO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBtYXhQYWdlcyxcbiAgICAgICAgICAgICAgZ2V0UHJldmlvdXNQYWdlUGFyYW1cbiAgICAgICAgICAgIH0gPSBpbmZpbml0ZVF1ZXJ5T3B0aW9ucztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWF4UGFnZXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIGlmIChtYXhQYWdlcyA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDQwKSA6IGBtYXhQYWdlcyBmb3IgZW5kcG9pbnQgJyR7ZW5kcG9pbnROYW1lfScgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMGApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2V0UHJldmlvdXNQYWdlUGFyYW0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzKDQxKSA6IGBnZXRQcmV2aW91c1BhZ2VQYXJhbSBmb3IgZW5kcG9pbnQgJyR7ZW5kcG9pbnROYW1lfScgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIG1heFBhZ2VzIGlzIHVzZWRgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXSA9IGRlZmluaXRpb247XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiBpbml0aWFsaXplZE1vZHVsZXMpIHtcbiAgICAgICAgICBtLmluamVjdEVuZHBvaW50KGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcGkgYXMgYW55O1xuICAgIH1cbiAgICByZXR1cm4gYXBpLmluamVjdEVuZHBvaW50cyh7XG4gICAgICBlbmRwb2ludHM6IG9wdGlvbnMuZW5kcG9pbnRzIGFzIGFueVxuICAgIH0pO1xuICB9O1xufSIsImltcG9ydCB0eXBlIHsgUXVlcnlDYWNoZUtleSB9IGZyb20gJy4vY29yZS9hcGlTdGF0ZSc7XG5pbXBvcnQgdHlwZSB7IEVuZHBvaW50RGVmaW5pdGlvbiB9IGZyb20gJy4vZW5kcG9pbnREZWZpbml0aW9ucyc7XG5pbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi9jb3JlL3J0a0ltcG9ydHMnO1xuY29uc3QgY2FjaGU6IFdlYWtNYXA8YW55LCBzdHJpbmc+IHwgdW5kZWZpbmVkID0gV2Vha01hcCA/IG5ldyBXZWFrTWFwKCkgOiB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3QgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJnczogU2VyaWFsaXplUXVlcnlBcmdzPGFueT4gPSAoe1xuICBlbmRwb2ludE5hbWUsXG4gIHF1ZXJ5QXJnc1xufSkgPT4ge1xuICBsZXQgc2VyaWFsaXplZCA9ICcnO1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZT8uZ2V0KHF1ZXJ5QXJncyk7XG4gIGlmICh0eXBlb2YgY2FjaGVkID09PSAnc3RyaW5nJykge1xuICAgIHNlcmlhbGl6ZWQgPSBjYWNoZWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3RyaW5naWZpZWQgPSBKU09OLnN0cmluZ2lmeShxdWVyeUFyZ3MsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAvLyBIYW5kbGUgYmlnaW50c1xuICAgICAgdmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnID8ge1xuICAgICAgICAkYmlnaW50OiB2YWx1ZS50b1N0cmluZygpXG4gICAgICB9IDogdmFsdWU7XG4gICAgICAvLyBTb3J0IHRoZSBvYmplY3Qga2V5cyBiZWZvcmUgc3RyaW5naWZ5aW5nLCB0byBwcmV2ZW50IHVzZVF1ZXJ5KHsgYTogMSwgYjogMiB9KSBoYXZpbmcgYSBkaWZmZXJlbnQgY2FjaGUga2V5IHRoYW4gdXNlUXVlcnkoeyBiOiAyLCBhOiAxIH0pXG4gICAgICB2YWx1ZSA9IGlzUGxhaW5PYmplY3QodmFsdWUpID8gT2JqZWN0LmtleXModmFsdWUpLnNvcnQoKS5yZWR1Y2U8YW55PigoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgYWNjW2tleV0gPSAodmFsdWUgYXMgYW55KVtrZXldO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pIDogdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocXVlcnlBcmdzKSkge1xuICAgICAgY2FjaGU/LnNldChxdWVyeUFyZ3MsIHN0cmluZ2lmaWVkKTtcbiAgICB9XG4gICAgc2VyaWFsaXplZCA9IHN0cmluZ2lmaWVkO1xuICB9XG4gIHJldHVybiBgJHtlbmRwb2ludE5hbWV9KCR7c2VyaWFsaXplZH0pYDtcbn07XG5leHBvcnQgdHlwZSBTZXJpYWxpemVRdWVyeUFyZ3M8UXVlcnlBcmdzLCBSZXR1cm5UeXBlID0gc3RyaW5nPiA9IChfOiB7XG4gIHF1ZXJ5QXJnczogUXVlcnlBcmdzO1xuICBlbmRwb2ludERlZmluaXRpb246IEVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+O1xuICBlbmRwb2ludE5hbWU6IHN0cmluZztcbn0pID0+IFJldHVyblR5cGU7XG5leHBvcnQgdHlwZSBJbnRlcm5hbFNlcmlhbGl6ZVF1ZXJ5QXJncyA9IChfOiB7XG4gIHF1ZXJ5QXJnczogYW55O1xuICBlbmRwb2ludERlZmluaXRpb246IEVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+O1xuICBlbmRwb2ludE5hbWU6IHN0cmluZztcbn0pID0+IFF1ZXJ5Q2FjaGVLZXk7IiwiaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgdHlwZSB7IEJhc2VRdWVyeUZuIH0gZnJvbSAnLi9iYXNlUXVlcnlUeXBlcyc7XG5leHBvcnQgY29uc3QgX05FVkVSID0gLyogQF9fUFVSRV9fICovU3ltYm9sKCk7XG5leHBvcnQgdHlwZSBORVZFUiA9IHR5cGVvZiBfTkVWRVI7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFwiZmFrZVwiIGJhc2VRdWVyeSB0byBiZSB1c2VkIGlmIHlvdXIgYXBpICpvbmx5KiB1c2VzIHRoZSBgcXVlcnlGbmAgZGVmaW5pdGlvbiBzeW50YXguXG4gKiBUaGlzIGFsc28gYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGEgc3BlY2lmaWMgZXJyb3IgdHlwZSB0byBiZSBzaGFyZWQgYnkgYWxsIHlvdXIgYHF1ZXJ5Rm5gIGRlZmluaXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmFrZUJhc2VRdWVyeTxFcnJvclR5cGU+KCk6IEJhc2VRdWVyeUZuPHZvaWQsIE5FVkVSLCBFcnJvclR5cGUsIHt9PiB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMzKSA6ICdXaGVuIHVzaW5nIGBmYWtlQmFzZVF1ZXJ5YCwgYWxsIHF1ZXJpZXMgJiBtdXRhdGlvbnMgbXVzdCB1c2UgdGhlIGBxdWVyeUZuYCBkZWZpbml0aW9uIHN5bnRheC4nKTtcbiAgfTtcbn0iLCIvKipcbiAqIE5vdGU6IHRoaXMgZmlsZSBzaG91bGQgaW1wb3J0IGFsbCBvdGhlciBmaWxlcyBmb3IgdHlwZSBkaXNjb3ZlcnkgYW5kIGRlY2xhcmF0aW9uIG1lcmdpbmdcbiAqL1xuaW1wb3J0IHR5cGUgeyBBY3Rpb25DcmVhdG9yV2l0aFBheWxvYWQsIE1pZGRsZXdhcmUsIFJlZHVjZXIsIFRodW5rQWN0aW9uLCBUaHVua0Rpc3BhdGNoLCBVbmtub3duQWN0aW9uIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XG5pbXBvcnQgeyBlbmFibGVQYXRjaGVzIH0gZnJvbSAnaW1tZXInO1xuaW1wb3J0IHR5cGUgeyBBcGksIE1vZHVsZSB9IGZyb20gJy4uL2FwaVR5cGVzJztcbmltcG9ydCB0eXBlIHsgQmFzZVF1ZXJ5Rm4gfSBmcm9tICcuLi9iYXNlUXVlcnlUeXBlcyc7XG5pbXBvcnQgdHlwZSB7IEludGVybmFsU2VyaWFsaXplUXVlcnlBcmdzIH0gZnJvbSAnLi4vZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyc7XG5pbXBvcnQgdHlwZSB7IEFzc2VydFRhZ1R5cGVzLCBFbmRwb2ludERlZmluaXRpb25zLCBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbiwgTXV0YXRpb25EZWZpbml0aW9uLCBRdWVyeUFyZ0Zyb20sIFF1ZXJ5QXJnRnJvbUFueVF1ZXJ5LCBRdWVyeURlZmluaXRpb24sIFRhZ0Rlc2NyaXB0aW9uIH0gZnJvbSAnLi4vZW5kcG9pbnREZWZpbml0aW9ucyc7XG5pbXBvcnQgeyBpc0luZmluaXRlUXVlcnlEZWZpbml0aW9uLCBpc011dGF0aW9uRGVmaW5pdGlvbiwgaXNRdWVyeURlZmluaXRpb24gfSBmcm9tICcuLi9lbmRwb2ludERlZmluaXRpb25zJztcbmltcG9ydCB7IGFzc2VydENhc3QsIHNhZmVBc3NpZ24gfSBmcm9tICcuLi90c0hlbHBlcnMnO1xuaW1wb3J0IHR5cGUgeyBDb21iaW5lZFN0YXRlLCBNdXRhdGlvbktleXMsIFF1ZXJ5S2V5cywgUm9vdFN0YXRlIH0gZnJvbSAnLi9hcGlTdGF0ZSc7XG5pbXBvcnQgdHlwZSB7IEJ1aWxkSW5pdGlhdGVBcGlFbmRwb2ludE11dGF0aW9uLCBCdWlsZEluaXRpYXRlQXBpRW5kcG9pbnRRdWVyeSwgTXV0YXRpb25BY3Rpb25DcmVhdG9yUmVzdWx0LCBRdWVyeUFjdGlvbkNyZWF0b3JSZXN1bHQsIEluZmluaXRlUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0LCBCdWlsZEluaXRpYXRlQXBpRW5kcG9pbnRJbmZpbml0ZVF1ZXJ5IH0gZnJvbSAnLi9idWlsZEluaXRpYXRlJztcbmltcG9ydCB7IGJ1aWxkSW5pdGlhdGUgfSBmcm9tICcuL2J1aWxkSW5pdGlhdGUnO1xuaW1wb3J0IHR5cGUgeyBSZWZlcmVuY2VDYWNoZUNvbGxlY3Rpb24sIFJlZmVyZW5jZUNhY2hlTGlmZWN5Y2xlLCBSZWZlcmVuY2VRdWVyeUxpZmVjeWNsZSB9IGZyb20gJy4vYnVpbGRNaWRkbGV3YXJlJztcbmltcG9ydCB7IGJ1aWxkTWlkZGxld2FyZSB9IGZyb20gJy4vYnVpbGRNaWRkbGV3YXJlJztcbmltcG9ydCB0eXBlIHsgQnVpbGRTZWxlY3RvcnNBcGlFbmRwb2ludEluZmluaXRlUXVlcnksIEJ1aWxkU2VsZWN0b3JzQXBpRW5kcG9pbnRNdXRhdGlvbiwgQnVpbGRTZWxlY3RvcnNBcGlFbmRwb2ludFF1ZXJ5IH0gZnJvbSAnLi9idWlsZFNlbGVjdG9ycyc7XG5pbXBvcnQgeyBidWlsZFNlbGVjdG9ycyB9IGZyb20gJy4vYnVpbGRTZWxlY3RvcnMnO1xuaW1wb3J0IHR5cGUgeyBTbGljZUFjdGlvbnMsIFVwc2VydEVudHJpZXMgfSBmcm9tICcuL2J1aWxkU2xpY2UnO1xuaW1wb3J0IHsgYnVpbGRTbGljZSB9IGZyb20gJy4vYnVpbGRTbGljZSc7XG5pbXBvcnQgdHlwZSB7IEFsbFF1ZXJ5S2V5cywgQnVpbGRUaHVua3NBcGlFbmRwb2ludEluZmluaXRlUXVlcnksIEJ1aWxkVGh1bmtzQXBpRW5kcG9pbnRNdXRhdGlvbiwgQnVpbGRUaHVua3NBcGlFbmRwb2ludFF1ZXJ5LCBQYXRjaFF1ZXJ5RGF0YVRodW5rLCBRdWVyeUFyZ0Zyb21BbnlRdWVyeURlZmluaXRpb24sIFVwZGF0ZVF1ZXJ5RGF0YVRodW5rLCBVcHNlcnRRdWVyeURhdGFUaHVuayB9IGZyb20gJy4vYnVpbGRUaHVua3MnO1xuaW1wb3J0IHsgYnVpbGRUaHVua3MgfSBmcm9tICcuL2J1aWxkVGh1bmtzJztcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIGFzIF9jcmVhdGVTZWxlY3RvciB9IGZyb20gJy4vcnRrSW1wb3J0cyc7XG5pbXBvcnQgeyBvbkZvY3VzLCBvbkZvY3VzTG9zdCwgb25PZmZsaW5lLCBvbk9ubGluZSB9IGZyb20gJy4vc2V0dXBMaXN0ZW5lcnMnO1xuXG4vKipcbiAqIGBpZk9sZGVyVGhhbmAgLSAoZGVmYXVsdDogYGZhbHNlYCB8IGBudW1iZXJgKSAtIF9udW1iZXIgaXMgdmFsdWUgaW4gc2Vjb25kc19cbiAqIC0gSWYgc3BlY2lmaWVkLCBpdCB3aWxsIG9ubHkgcnVuIHRoZSBxdWVyeSBpZiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGBuZXcgRGF0ZSgpYCBhbmQgdGhlIGxhc3QgYGZ1bGZpbGxlZFRpbWVTdGFtcGAgaXMgZ3JlYXRlciB0aGFuIHRoZSBnaXZlbiB2YWx1ZVxuICpcbiAqIEBvdmVybG9hZFN1bW1hcnlcbiAqIGBmb3JjZWBcbiAqIC0gSWYgYGZvcmNlOiB0cnVlYCwgaXQgd2lsbCBpZ25vcmUgdGhlIGBpZk9sZGVyVGhhbmAgdmFsdWUgaWYgaXQgaXMgc2V0IGFuZCB0aGUgcXVlcnkgd2lsbCBiZSBydW4gZXZlbiBpZiBpdCBleGlzdHMgaW4gdGhlIGNhY2hlLlxuICovXG5leHBvcnQgdHlwZSBQcmVmZXRjaE9wdGlvbnMgPSB7XG4gIGlmT2xkZXJUaGFuPzogZmFsc2UgfCBudW1iZXI7XG59IHwge1xuICBmb3JjZT86IGJvb2xlYW47XG59O1xuZXhwb3J0IGNvbnN0IGNvcmVNb2R1bGVOYW1lID0gLyogQF9fUFVSRV9fICovU3ltYm9sKCk7XG5leHBvcnQgdHlwZSBDb3JlTW9kdWxlID0gdHlwZW9mIGNvcmVNb2R1bGVOYW1lIHwgUmVmZXJlbmNlQ2FjaGVMaWZlY3ljbGUgfCBSZWZlcmVuY2VRdWVyeUxpZmVjeWNsZSB8IFJlZmVyZW5jZUNhY2hlQ29sbGVjdGlvbjtcbmV4cG9ydCB0eXBlIFRodW5rV2l0aFJldHVyblZhbHVlPFQ+ID0gVGh1bmtBY3Rpb248VCwgYW55LCBhbnksIFVua25vd25BY3Rpb24+O1xuZXhwb3J0IGludGVyZmFjZSBBcGlNb2R1bGVzPFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIERlZmluaXRpb25zIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9ucywgUmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcsIFRhZ1R5cGVzIGV4dGVuZHMgc3RyaW5nPiB7XG4gIFtjb3JlTW9kdWxlTmFtZV06IHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGFwaSdzIHJlZHVjZXIgc2hvdWxkIGJlIG1vdW50ZWQgYXQgYHN0b3JlW2FwaS5yZWR1Y2VyUGF0aF1gLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbmZpZ3VyZVN0b3JlKHtcbiAgICAgKiAgIHJlZHVjZXI6IHtcbiAgICAgKiAgICAgW2FwaS5yZWR1Y2VyUGF0aF06IGFwaS5yZWR1Y2VyLFxuICAgICAqICAgfSxcbiAgICAgKiAgIG1pZGRsZXdhcmU6IChnZXREZWZhdWx0TWlkZGxld2FyZSkgPT4gZ2V0RGVmYXVsdE1pZGRsZXdhcmUoKS5jb25jYXQoYXBpLm1pZGRsZXdhcmUpLFxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmVkdWNlclBhdGg6IFJlZHVjZXJQYXRoO1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIGFjdGlvbnMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkuIE5vdGU6IFRoZXNlIGFyZSBzdWJqZWN0IHRvIGNoYW5nZSBhdCBhbnkgZ2l2ZW4gdGltZS5cbiAgICAgKi9cbiAgICBpbnRlcm5hbEFjdGlvbnM6IEludGVybmFsQWN0aW9ucztcbiAgICAvKipcbiAgICAgKiAgQSBzdGFuZGFyZCByZWR1eCByZWR1Y2VyIHRoYXQgZW5hYmxlcyBjb3JlIGZ1bmN0aW9uYWxpdHkuIE1ha2Ugc3VyZSBpdCdzIGluY2x1ZGVkIGluIHlvdXIgc3RvcmUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uZmlndXJlU3RvcmUoe1xuICAgICAqICAgcmVkdWNlcjoge1xuICAgICAqICAgICBbYXBpLnJlZHVjZXJQYXRoXTogYXBpLnJlZHVjZXIsXG4gICAgICogICB9LFxuICAgICAqICAgbWlkZGxld2FyZTogKGdldERlZmF1bHRNaWRkbGV3YXJlKSA9PiBnZXREZWZhdWx0TWlkZGxld2FyZSgpLmNvbmNhdChhcGkubWlkZGxld2FyZSksXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICByZWR1Y2VyOiBSZWR1Y2VyPENvbWJpbmVkU3RhdGU8RGVmaW5pdGlvbnMsIFRhZ1R5cGVzLCBSZWR1Y2VyUGF0aD4sIFVua25vd25BY3Rpb24+O1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBzdGFuZGFyZCByZWR1eCBtaWRkbGV3YXJlIGFuZCBpcyByZXNwb25zaWJsZSBmb3IgdGhpbmdzIGxpa2UgcG9sbGluZywgZ2FyYmFnZSBjb2xsZWN0aW9uIGFuZCBhIGhhbmRmdWwgb2Ygb3RoZXIgdGhpbmdzLiBNYWtlIHN1cmUgaXQncyBpbmNsdWRlZCBpbiB5b3VyIHN0b3JlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbmZpZ3VyZVN0b3JlKHtcbiAgICAgKiAgIHJlZHVjZXI6IHtcbiAgICAgKiAgICAgW2FwaS5yZWR1Y2VyUGF0aF06IGFwaS5yZWR1Y2VyLFxuICAgICAqICAgfSxcbiAgICAgKiAgIG1pZGRsZXdhcmU6IChnZXREZWZhdWx0TWlkZGxld2FyZSkgPT4gZ2V0RGVmYXVsdE1pZGRsZXdhcmUoKS5jb25jYXQoYXBpLm1pZGRsZXdhcmUpLFxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgbWlkZGxld2FyZTogTWlkZGxld2FyZTx7fSwgUm9vdFN0YXRlPERlZmluaXRpb25zLCBzdHJpbmcsIFJlZHVjZXJQYXRoPiwgVGh1bmtEaXNwYXRjaDxhbnksIGFueSwgVW5rbm93bkFjdGlvbj4+O1xuICAgIC8qKlxuICAgICAqIEEgY29sbGVjdGlvbiBvZiB1dGlsaXR5IHRodW5rcyBmb3IgdmFyaW91cyBzaXR1YXRpb25zLlxuICAgICAqL1xuICAgIHV0aWw6IHtcbiAgICAgIC8qKlxuICAgICAgICogQSB0aHVuayB0aGF0IChpZiBkaXNwYXRjaGVkKSB3aWxsIHJldHVybiBhIHNwZWNpZmljIHJ1bm5pbmcgcXVlcnksIGlkZW50aWZpZWRcbiAgICAgICAqIGJ5IGBlbmRwb2ludE5hbWVgIGFuZCBgYXJnYC5cbiAgICAgICAqIElmIHRoYXQgcXVlcnkgaXMgbm90IHJ1bm5pbmcsIGRpc3BhdGNoaW5nIHRoZSB0aHVuayB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYC5cbiAgICAgICAqXG4gICAgICAgKiBDYW4gYmUgdXNlZCB0byBhd2FpdCBhIHNwZWNpZmljIHF1ZXJ5IHRyaWdnZXJlZCBpbiBhbnkgd2F5LFxuICAgICAgICogaW5jbHVkaW5nIHZpYSBob29rIGNhbGxzIG9yIG1hbnVhbGx5IGRpc3BhdGNoaW5nIGBpbml0aWF0ZWAgYWN0aW9ucy5cbiAgICAgICAqXG4gICAgICAgKiBTZWUgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9ydGstcXVlcnkvdXNhZ2Uvc2VydmVyLXNpZGUtcmVuZGVyaW5nIGZvciBkZXRhaWxzLlxuICAgICAgICovXG4gICAgICBnZXRSdW5uaW5nUXVlcnlUaHVuazxFbmRwb2ludE5hbWUgZXh0ZW5kcyBBbGxRdWVyeUtleXM8RGVmaW5pdGlvbnM+PihlbmRwb2ludE5hbWU6IEVuZHBvaW50TmFtZSwgYXJnOiBRdWVyeUFyZ0Zyb21BbnlRdWVyeURlZmluaXRpb248RGVmaW5pdGlvbnMsIEVuZHBvaW50TmFtZT4pOiBUaHVua1dpdGhSZXR1cm5WYWx1ZTxRdWVyeUFjdGlvbkNyZWF0b3JSZXN1bHQ8RGVmaW5pdGlvbnNbRW5kcG9pbnROYW1lXSAmIHtcbiAgICAgICAgdHlwZTogJ3F1ZXJ5JztcbiAgICAgIH0+IHwgSW5maW5pdGVRdWVyeUFjdGlvbkNyZWF0b3JSZXN1bHQ8RGVmaW5pdGlvbnNbRW5kcG9pbnROYW1lXSAmIHtcbiAgICAgICAgdHlwZTogJ2luZmluaXRlcXVlcnknO1xuICAgICAgfT4gfCB1bmRlZmluZWQ+O1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgdGh1bmsgdGhhdCAoaWYgZGlzcGF0Y2hlZCkgd2lsbCByZXR1cm4gYSBzcGVjaWZpYyBydW5uaW5nIG11dGF0aW9uLCBpZGVudGlmaWVkXG4gICAgICAgKiBieSBgZW5kcG9pbnROYW1lYCBhbmQgYGZpeGVkQ2FjaGVLZXlgIG9yIGByZXF1ZXN0SWRgLlxuICAgICAgICogSWYgdGhhdCBtdXRhdGlvbiBpcyBub3QgcnVubmluZywgZGlzcGF0Y2hpbmcgdGhlIHRodW5rIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgLlxuICAgICAgICpcbiAgICAgICAqIENhbiBiZSB1c2VkIHRvIGF3YWl0IGEgc3BlY2lmaWMgbXV0YXRpb24gdHJpZ2dlcmVkIGluIGFueSB3YXksXG4gICAgICAgKiBpbmNsdWRpbmcgdmlhIGhvb2sgdHJpZ2dlciBmdW5jdGlvbnMgb3IgbWFudWFsbHkgZGlzcGF0Y2hpbmcgYGluaXRpYXRlYCBhY3Rpb25zLlxuICAgICAgICpcbiAgICAgICAqIFNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL3J0ay1xdWVyeS91c2FnZS9zZXJ2ZXItc2lkZS1yZW5kZXJpbmcgZm9yIGRldGFpbHMuXG4gICAgICAgKi9cbiAgICAgIGdldFJ1bm5pbmdNdXRhdGlvblRodW5rPEVuZHBvaW50TmFtZSBleHRlbmRzIE11dGF0aW9uS2V5czxEZWZpbml0aW9ucz4+KGVuZHBvaW50TmFtZTogRW5kcG9pbnROYW1lLCBmaXhlZENhY2hlS2V5T3JSZXF1ZXN0SWQ6IHN0cmluZyk6IFRodW5rV2l0aFJldHVyblZhbHVlPE11dGF0aW9uQWN0aW9uQ3JlYXRvclJlc3VsdDxEZWZpbml0aW9uc1tFbmRwb2ludE5hbWVdICYge1xuICAgICAgICB0eXBlOiAnbXV0YXRpb24nO1xuICAgICAgfT4gfCB1bmRlZmluZWQ+O1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgdGh1bmsgdGhhdCAoaWYgZGlzcGF0Y2hlZCkgd2lsbCByZXR1cm4gYWxsIHJ1bm5pbmcgcXVlcmllcy5cbiAgICAgICAqXG4gICAgICAgKiBVc2VmdWwgZm9yIFNTUiBzY2VuYXJpb3MgdG8gYXdhaXQgYWxsIHJ1bm5pbmcgcXVlcmllcyB0cmlnZ2VyZWQgaW4gYW55IHdheSxcbiAgICAgICAqIGluY2x1ZGluZyB2aWEgaG9vayBjYWxscyBvciBtYW51YWxseSBkaXNwYXRjaGluZyBgaW5pdGlhdGVgIGFjdGlvbnMuXG4gICAgICAgKlxuICAgICAgICogU2VlIGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvcnRrLXF1ZXJ5L3VzYWdlL3NlcnZlci1zaWRlLXJlbmRlcmluZyBmb3IgZGV0YWlscy5cbiAgICAgICAqL1xuICAgICAgZ2V0UnVubmluZ1F1ZXJpZXNUaHVuaygpOiBUaHVua1dpdGhSZXR1cm5WYWx1ZTxBcnJheTxRdWVyeUFjdGlvbkNyZWF0b3JSZXN1bHQ8YW55PiB8IEluZmluaXRlUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0PGFueT4+PjtcblxuICAgICAgLyoqXG4gICAgICAgKiBBIHRodW5rIHRoYXQgKGlmIGRpc3BhdGNoZWQpIHdpbGwgcmV0dXJuIGFsbCBydW5uaW5nIG11dGF0aW9ucy5cbiAgICAgICAqXG4gICAgICAgKiBVc2VmdWwgZm9yIFNTUiBzY2VuYXJpb3MgdG8gYXdhaXQgYWxsIHJ1bm5pbmcgbXV0YXRpb25zIHRyaWdnZXJlZCBpbiBhbnkgd2F5LFxuICAgICAgICogaW5jbHVkaW5nIHZpYSBob29rIGNhbGxzIG9yIG1hbnVhbGx5IGRpc3BhdGNoaW5nIGBpbml0aWF0ZWAgYWN0aW9ucy5cbiAgICAgICAqXG4gICAgICAgKiBTZWUgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9ydGstcXVlcnkvdXNhZ2Uvc2VydmVyLXNpZGUtcmVuZGVyaW5nIGZvciBkZXRhaWxzLlxuICAgICAgICovXG4gICAgICBnZXRSdW5uaW5nTXV0YXRpb25zVGh1bmsoKTogVGh1bmtXaXRoUmV0dXJuVmFsdWU8QXJyYXk8TXV0YXRpb25BY3Rpb25DcmVhdG9yUmVzdWx0PGFueT4+PjtcblxuICAgICAgLyoqXG4gICAgICAgKiBBIFJlZHV4IHRodW5rIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFudWFsbHkgdHJpZ2dlciBwcmUtZmV0Y2hpbmcgb2YgZGF0YS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgdGh1bmsgYWNjZXB0cyB0aHJlZSBhcmd1bWVudHM6IHRoZSBuYW1lIG9mIHRoZSBlbmRwb2ludCB3ZSBhcmUgdXBkYXRpbmcgKHN1Y2ggYXMgYCdnZXRQb3N0J2ApLCB0aGUgYXBwcm9wcmlhdGUgcXVlcnkgYXJnIHZhbHVlcyB0byBjb25zdHJ1Y3QgdGhlIGRlc2lyZWQgY2FjaGUga2V5LCBhbmQgYSBzZXQgb2Ygb3B0aW9ucyB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgZGF0YSBhY3R1YWxseSBzaG91bGQgYmUgcmUtZmV0Y2hlZCBiYXNlZCBvbiBjYWNoZSBzdGFsZW5lc3MuXG4gICAgICAgKlxuICAgICAgICogUmVhY3QgSG9va3MgdXNlcnMgd2lsbCBtb3N0IGxpa2VseSBuZXZlciBuZWVkIHRvIHVzZSB0aGlzIGRpcmVjdGx5LCBhcyB0aGUgYHVzZVByZWZldGNoYCBob29rIHdpbGwgZGlzcGF0Y2ggdGhpcyB0aHVuayBpbnRlcm5hbGx5IGFzIG5lZWRlZCB3aGVuIHlvdSBjYWxsIHRoZSBwcmVmZXRjaGluZyBmdW5jdGlvbiBzdXBwbGllZCBieSB0aGUgaG9vay5cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICpcbiAgICAgICAqIGBgYHRzIG5vLXRyYW5zcGlsZVxuICAgICAgICogZGlzcGF0Y2goYXBpLnV0aWwucHJlZmV0Y2goJ2dldFBvc3RzJywgdW5kZWZpbmVkLCB7IGZvcmNlOiB0cnVlIH0pKVxuICAgICAgICogYGBgXG4gICAgICAgKi9cbiAgICAgIHByZWZldGNoPEVuZHBvaW50TmFtZSBleHRlbmRzIFF1ZXJ5S2V5czxEZWZpbml0aW9ucz4+KGVuZHBvaW50TmFtZTogRW5kcG9pbnROYW1lLCBhcmc6IFF1ZXJ5QXJnRnJvbTxEZWZpbml0aW9uc1tFbmRwb2ludE5hbWVdPiwgb3B0aW9uczogUHJlZmV0Y2hPcHRpb25zKTogVGh1bmtBY3Rpb248dm9pZCwgYW55LCBhbnksIFVua25vd25BY3Rpb24+O1xuICAgICAgLyoqXG4gICAgICAgKiBBIFJlZHV4IHRodW5rIGFjdGlvbiBjcmVhdG9yIHRoYXQsIHdoZW4gZGlzcGF0Y2hlZCwgY3JlYXRlcyBhbmQgYXBwbGllcyBhIHNldCBvZiBKU09OIGRpZmYvcGF0Y2ggb2JqZWN0cyB0byB0aGUgY3VycmVudCBzdGF0ZS4gVGhpcyBpbW1lZGlhdGVseSB1cGRhdGVzIHRoZSBSZWR1eCBzdGF0ZSB3aXRoIHRob3NlIGNoYW5nZXMuXG4gICAgICAgKlxuICAgICAgICogVGhlIHRodW5rIGFjdGlvbiBjcmVhdG9yIGFjY2VwdHMgdGhyZWUgYXJndW1lbnRzOiB0aGUgbmFtZSBvZiB0aGUgZW5kcG9pbnQgd2UgYXJlIHVwZGF0aW5nIChzdWNoIGFzIGAnZ2V0UG9zdCdgKSwgdGhlIGFwcHJvcHJpYXRlIHF1ZXJ5IGFyZyB2YWx1ZXMgdG8gY29uc3RydWN0IHRoZSBkZXNpcmVkIGNhY2hlIGtleSwgYW5kIGFuIGB1cGRhdGVSZWNpcGVgIGNhbGxiYWNrIGZ1bmN0aW9uLiBUaGUgY2FsbGJhY2sgcmVjZWl2ZXMgYW4gSW1tZXItd3JhcHBlZCBgZHJhZnRgIG9mIHRoZSBjdXJyZW50IHN0YXRlLCBhbmQgbWF5IG1vZGlmeSB0aGUgZHJhZnQgdG8gbWF0Y2ggdGhlIGV4cGVjdGVkIHJlc3VsdHMgYWZ0ZXIgdGhlIG11dGF0aW9uIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHkuXG4gICAgICAgKlxuICAgICAgICogVGhlIHRodW5rIGV4ZWN1dGVzIF9zeW5jaHJvbm91c2x5XywgYW5kIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYHtwYXRjaGVzOiBQYXRjaFtdLCBpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXSwgdW5kbzogKCkgPT4gdm9pZH1gLiBUaGUgYHBhdGNoZXNgIGFuZCBgaW52ZXJzZVBhdGNoZXNgIGFyZSBnZW5lcmF0ZWQgdXNpbmcgSW1tZXIncyBbYHByb2R1Y2VXaXRoUGF0Y2hlc2AgbWV0aG9kXShodHRwczovL2ltbWVyanMuZ2l0aHViLmlvL2ltbWVyL3BhdGNoZXMpLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgaXMgdHlwaWNhbGx5IHVzZWQgYXMgdGhlIGZpcnN0IHN0ZXAgaW4gaW1wbGVtZW50aW5nIG9wdGltaXN0aWMgdXBkYXRlcy4gVGhlIGdlbmVyYXRlZCBgaW52ZXJzZVBhdGNoZXNgIGNhbiBiZSB1c2VkIHRvIHJldmVydCB0aGUgdXBkYXRlcyBieSBjYWxsaW5nIGBkaXNwYXRjaChwYXRjaFF1ZXJ5RGF0YShlbmRwb2ludE5hbWUsIGFyZywgaW52ZXJzZVBhdGNoZXMpKWAuIEFsdGVybmF0aXZlbHksIHRoZSBgdW5kb2AgbWV0aG9kIGNhbiBiZSBjYWxsZWQgZGlyZWN0bHkgdG8gYWNoaWV2ZSB0aGUgc2FtZSBlZmZlY3QuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGF0IHRoZSBmaXJzdCB0d28gYXJndW1lbnRzIChgZW5kcG9pbnROYW1lYCBhbmQgYGFyZ2ApIGFyZSB1c2VkIHRvIGRldGVybWluZSB3aGljaCBleGlzdGluZyBjYWNoZSBlbnRyeSB0byB1cGRhdGUuIElmIG5vIGV4aXN0aW5nIGNhY2hlIGVudHJ5IGlzIGZvdW5kLCB0aGUgYHVwZGF0ZVJlY2lwZWAgY2FsbGJhY2sgd2lsbCBub3QgcnVuLlxuICAgICAgICpcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKlxuICAgICAgICogYGBgdHNcbiAgICAgICAqIGNvbnN0IHBhdGNoQ29sbGVjdGlvbiA9IGRpc3BhdGNoKFxuICAgICAgICogICBhcGkudXRpbC51cGRhdGVRdWVyeURhdGEoJ2dldFBvc3RzJywgdW5kZWZpbmVkLCAoZHJhZnRQb3N0cykgPT4ge1xuICAgICAgICogICAgIGRyYWZ0UG9zdHMucHVzaCh7IGlkOiAxLCBuYW1lOiAnVGVkZHknIH0pXG4gICAgICAgKiAgIH0pXG4gICAgICAgKiApXG4gICAgICAgKiBgYGBcbiAgICAgICAqL1xuICAgICAgdXBkYXRlUXVlcnlEYXRhOiBVcGRhdGVRdWVyeURhdGFUaHVuazxEZWZpbml0aW9ucywgUm9vdFN0YXRlPERlZmluaXRpb25zLCBzdHJpbmcsIFJlZHVjZXJQYXRoPj47XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBSZWR1eCB0aHVuayBhY3Rpb24gY3JlYXRvciB0aGF0LCB3aGVuIGRpc3BhdGNoZWQsIGFjdHMgYXMgYW4gYXJ0aWZpY2lhbCBBUEkgcmVxdWVzdCB0byB1cHNlcnQgYSB2YWx1ZSBpbnRvIHRoZSBjYWNoZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgdGh1bmsgYWN0aW9uIGNyZWF0b3IgYWNjZXB0cyB0aHJlZSBhcmd1bWVudHM6IHRoZSBuYW1lIG9mIHRoZSBlbmRwb2ludCB3ZSBhcmUgdXBkYXRpbmcgKHN1Y2ggYXMgYCdnZXRQb3N0J2ApLCB0aGUgYXBwcm9wcmlhdGUgcXVlcnkgYXJnIHZhbHVlcyB0byBjb25zdHJ1Y3QgdGhlIGRlc2lyZWQgY2FjaGUga2V5LCBhbmQgdGhlIGRhdGEgdG8gdXBzZXJ0LlxuICAgICAgICpcbiAgICAgICAqIElmIG5vIGNhY2hlIGVudHJ5IGZvciB0aGF0IGNhY2hlIGtleSBleGlzdHMsIGEgY2FjaGUgZW50cnkgd2lsbCBiZSBjcmVhdGVkIGFuZCB0aGUgZGF0YSBhZGRlZC4gSWYgYSBjYWNoZSBlbnRyeSBhbHJlYWR5IGV4aXN0cywgdGhpcyB3aWxsIF9vdmVyd3JpdGVfIHRoZSBleGlzdGluZyBjYWNoZSBlbnRyeSBkYXRhLlxuICAgICAgICpcbiAgICAgICAqIFRoZSB0aHVuayBleGVjdXRlcyBfYXN5bmNocm9ub3VzbHlfLCBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBzdG9yZSBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAgICpcbiAgICAgICAqIElmIGRpc3BhdGNoZWQgd2hpbGUgYW4gYWN0dWFsIHJlcXVlc3QgaXMgaW4gcHJvZ3Jlc3MsIGJvdGggdGhlIHVwc2VydCBhbmQgcmVxdWVzdCB3aWxsIGJlIGhhbmRsZWQgYXMgc29vbiBhcyB0aGV5IHJlc29sdmUsIHJlc3VsdGluZyBpbiBhIFwibGFzdCByZXN1bHQgd2luc1wiIHVwZGF0ZSBiZWhhdmlvci5cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICpcbiAgICAgICAqIGBgYHRzXG4gICAgICAgKiBhd2FpdCBkaXNwYXRjaChcbiAgICAgICAqICAgYXBpLnV0aWwudXBzZXJ0UXVlcnlEYXRhKCdnZXRQb3N0Jywge2lkOiAxfSwge2lkOiAxLCB0ZXh0OiBcIkhlbGxvIVwifSlcbiAgICAgICAqIClcbiAgICAgICAqIGBgYFxuICAgICAgICovXG4gICAgICB1cHNlcnRRdWVyeURhdGE6IFVwc2VydFF1ZXJ5RGF0YVRodW5rPERlZmluaXRpb25zLCBSb290U3RhdGU8RGVmaW5pdGlvbnMsIHN0cmluZywgUmVkdWNlclBhdGg+PjtcbiAgICAgIC8qKlxuICAgICAgICogQSBSZWR1eCB0aHVuayB0aGF0IGFwcGxpZXMgYSBKU09OIGRpZmYvcGF0Y2ggYXJyYXkgdG8gdGhlIGNhY2hlZCBkYXRhIGZvciBhIGdpdmVuIHF1ZXJ5IHJlc3VsdC4gVGhpcyBpbW1lZGlhdGVseSB1cGRhdGVzIHRoZSBSZWR1eCBzdGF0ZSB3aXRoIHRob3NlIGNoYW5nZXMuXG4gICAgICAgKlxuICAgICAgICogVGhlIHRodW5rIGFjY2VwdHMgdGhyZWUgYXJndW1lbnRzOiB0aGUgbmFtZSBvZiB0aGUgZW5kcG9pbnQgd2UgYXJlIHVwZGF0aW5nIChzdWNoIGFzIGAnZ2V0UG9zdCdgKSwgdGhlIGFwcHJvcHJpYXRlIHF1ZXJ5IGFyZyB2YWx1ZXMgdG8gY29uc3RydWN0IHRoZSBkZXNpcmVkIGNhY2hlIGtleSwgYW5kIGEgSlNPTiBkaWZmL3BhdGNoIGFycmF5IGFzIHByb2R1Y2VkIGJ5IEltbWVyJ3MgYHByb2R1Y2VXaXRoUGF0Y2hlc2AuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCBhcyB0aGUgc2Vjb25kIHN0ZXAgaW4gaW1wbGVtZW50aW5nIG9wdGltaXN0aWMgdXBkYXRlcy4gSWYgYSByZXF1ZXN0IGZhaWxzLCB0aGUgb3B0aW1pc3RpY2FsbHktYXBwbGllZCBjaGFuZ2VzIGNhbiBiZSByZXZlcnRlZCBieSBkaXNwYXRjaGluZyBgcGF0Y2hRdWVyeURhdGFgIHdpdGggdGhlIGBpbnZlcnNlUGF0Y2hlc2AgdGhhdCB3ZXJlIGdlbmVyYXRlZCBieSBgdXBkYXRlUXVlcnlEYXRhYCBlYXJsaWVyLlxuICAgICAgICpcbiAgICAgICAqIEluIGNhc2VzIHdoZXJlIGl0IGlzIGRlc2lyZWQgdG8gc2ltcGx5IHJldmVydCB0aGUgcHJldmlvdXMgY2hhbmdlcywgaXQgbWF5IGJlIHByZWZlcmFibGUgdG8gY2FsbCB0aGUgYHVuZG9gIG1ldGhvZCByZXR1cm5lZCBmcm9tIGRpc3BhdGNoaW5nIGB1cGRhdGVRdWVyeURhdGFgIGluc3RlYWQuXG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGBgYHRzXG4gICAgICAgKiBjb25zdCBwYXRjaENvbGxlY3Rpb24gPSBkaXNwYXRjaChcbiAgICAgICAqICAgYXBpLnV0aWwudXBkYXRlUXVlcnlEYXRhKCdnZXRQb3N0cycsIHVuZGVmaW5lZCwgKGRyYWZ0UG9zdHMpID0+IHtcbiAgICAgICAqICAgICBkcmFmdFBvc3RzLnB1c2goeyBpZDogMSwgbmFtZTogJ1RlZGR5JyB9KVxuICAgICAgICogICB9KVxuICAgICAgICogKVxuICAgICAgICpcbiAgICAgICAqIC8vIGxhdGVyXG4gICAgICAgKiBkaXNwYXRjaChcbiAgICAgICAqICAgYXBpLnV0aWwucGF0Y2hRdWVyeURhdGEoJ2dldFBvc3RzJywgdW5kZWZpbmVkLCBwYXRjaENvbGxlY3Rpb24uaW52ZXJzZVBhdGNoZXMpXG4gICAgICAgKiApXG4gICAgICAgKlxuICAgICAgICogLy8gb3JcbiAgICAgICAqIHBhdGNoQ29sbGVjdGlvbi51bmRvKClcbiAgICAgICAqIGBgYFxuICAgICAgICovXG4gICAgICBwYXRjaFF1ZXJ5RGF0YTogUGF0Y2hRdWVyeURhdGFUaHVuazxEZWZpbml0aW9ucywgUm9vdFN0YXRlPERlZmluaXRpb25zLCBzdHJpbmcsIFJlZHVjZXJQYXRoPj47XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBSZWR1eCBhY3Rpb24gY3JlYXRvciB0aGF0IGNhbiBiZSBkaXNwYXRjaGVkIHRvIG1hbnVhbGx5IHJlc2V0IHRoZSBhcGkgc3RhdGUgY29tcGxldGVseS4gVGhpcyB3aWxsIGltbWVkaWF0ZWx5IHJlbW92ZSBhbGwgZXhpc3RpbmcgY2FjaGUgZW50cmllcywgYW5kIGFsbCBxdWVyaWVzIHdpbGwgYmUgY29uc2lkZXJlZCAndW5pbml0aWFsaXplZCcuXG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqXG4gICAgICAgKiBgYGB0c1xuICAgICAgICogZGlzcGF0Y2goYXBpLnV0aWwucmVzZXRBcGlTdGF0ZSgpKVxuICAgICAgICogYGBgXG4gICAgICAgKi9cbiAgICAgIHJlc2V0QXBpU3RhdGU6IFNsaWNlQWN0aW9uc1sncmVzZXRBcGlTdGF0ZSddO1xuICAgICAgdXBzZXJ0UXVlcnlFbnRyaWVzOiBVcHNlcnRFbnRyaWVzPERlZmluaXRpb25zPjtcblxuICAgICAgLyoqXG4gICAgICAgKiBBIFJlZHV4IGFjdGlvbiBjcmVhdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFudWFsbHkgaW52YWxpZGF0ZSBjYWNoZSB0YWdzIGZvciBbYXV0b21hdGVkIHJlLWZldGNoaW5nXSguLi8uLi91c2FnZS9hdXRvbWF0ZWQtcmVmZXRjaGluZy5tZHgpLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBhY3Rpb24gY3JlYXRvciBhY2NlcHRzIG9uZSBhcmd1bWVudDogdGhlIGNhY2hlIHRhZ3MgdG8gYmUgaW52YWxpZGF0ZWQuIEl0IHJldHVybnMgYW4gYWN0aW9uIHdpdGggdGhvc2UgdGFncyBhcyBhIHBheWxvYWQsIGFuZCB0aGUgY29ycmVzcG9uZGluZyBgaW52YWxpZGF0ZVRhZ3NgIGFjdGlvbiB0eXBlIGZvciB0aGUgYXBpLlxuICAgICAgICpcbiAgICAgICAqIERpc3BhdGNoaW5nIHRoZSByZXN1bHQgb2YgdGhpcyBhY3Rpb24gY3JlYXRvciB3aWxsIFtpbnZhbGlkYXRlXSguLi8uLi91c2FnZS9hdXRvbWF0ZWQtcmVmZXRjaGluZy5tZHgjaW52YWxpZGF0aW5nLWNhY2hlLWRhdGEpIHRoZSBnaXZlbiB0YWdzLCBjYXVzaW5nIHF1ZXJpZXMgdG8gYXV0b21hdGljYWxseSByZS1mZXRjaCBpZiB0aGV5IGFyZSBzdWJzY3JpYmVkIHRvIGNhY2hlIGRhdGEgdGhhdCBbcHJvdmlkZXNdKC4uLy4uL3VzYWdlL2F1dG9tYXRlZC1yZWZldGNoaW5nLm1keCNwcm92aWRpbmctY2FjaGUtZGF0YSkgdGhlIGNvcnJlc3BvbmRpbmcgdGFncy5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgYXJyYXkgb2YgdGFncyBwcm92aWRlZCB0byB0aGUgYWN0aW9uIGNyZWF0b3Igc2hvdWxkIGJlIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1hdHMsIHdoZXJlIGBUYWdUeXBlYCBpcyBlcXVhbCB0byBhIHN0cmluZyBwcm92aWRlZCB0byB0aGUgW2B0YWdUeXBlc2BdKC4uL2NyZWF0ZUFwaS5tZHgjdGFndHlwZXMpIHByb3BlcnR5IG9mIHRoZSBhcGk6XG4gICAgICAgKlxuICAgICAgICogLSBgW1RhZ1R5cGVdYFxuICAgICAgICogLSBgW3sgdHlwZTogVGFnVHlwZSB9XWBcbiAgICAgICAqIC0gYFt7IHR5cGU6IFRhZ1R5cGUsIGlkOiBudW1iZXIgfCBzdHJpbmcgfV1gXG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqXG4gICAgICAgKiBgYGB0c1xuICAgICAgICogZGlzcGF0Y2goYXBpLnV0aWwuaW52YWxpZGF0ZVRhZ3MoWydQb3N0J10pKVxuICAgICAgICogZGlzcGF0Y2goYXBpLnV0aWwuaW52YWxpZGF0ZVRhZ3MoW3sgdHlwZTogJ1Bvc3QnLCBpZDogMSB9XSkpXG4gICAgICAgKiBkaXNwYXRjaChcbiAgICAgICAqICAgYXBpLnV0aWwuaW52YWxpZGF0ZVRhZ3MoW1xuICAgICAgICogICAgIHsgdHlwZTogJ1Bvc3QnLCBpZDogMSB9LFxuICAgICAgICogICAgIHsgdHlwZTogJ1Bvc3QnLCBpZDogJ0xJU1QnIH0sXG4gICAgICAgKiAgIF0pXG4gICAgICAgKiApXG4gICAgICAgKiBgYGBcbiAgICAgICAqL1xuICAgICAgaW52YWxpZGF0ZVRhZ3M6IEFjdGlvbkNyZWF0b3JXaXRoUGF5bG9hZDxBcnJheTxUYWdEZXNjcmlwdGlvbjxUYWdUeXBlcz4gfCBudWxsIHwgdW5kZWZpbmVkPiwgc3RyaW5nPjtcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGZ1bmN0aW9uIHRvIHNlbGVjdCBhbGwgYHsgZW5kcG9pbnROYW1lLCBvcmlnaW5hbEFyZ3MsIHF1ZXJ5Q2FjaGVLZXkgfWAgY29tYmluYXRpb25zIHRoYXQgd291bGQgYmUgaW52YWxpZGF0ZWQgYnkgYSBzcGVjaWZpYyBzZXQgb2YgdGFncy5cbiAgICAgICAqXG4gICAgICAgKiBDYW4gYmUgdXNlZCBmb3IgbXV0YXRpb25zIHRoYXQgd2FudCB0byBkbyBvcHRpbWlzdGljIHVwZGF0ZXMgaW5zdGVhZCBvZiBpbnZhbGlkYXRpbmcgYSBzZXQgb2YgdGFncywgYnV0IGRvbid0IGtub3cgZXhhY3RseSB3aGF0IHRoZXkgbmVlZCB0byB1cGRhdGUuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdEludmFsaWRhdGVkQnk6IChzdGF0ZTogUm9vdFN0YXRlPERlZmluaXRpb25zLCBzdHJpbmcsIFJlZHVjZXJQYXRoPiwgdGFnczogUmVhZG9ubHlBcnJheTxUYWdEZXNjcmlwdGlvbjxUYWdUeXBlcz4gfCBudWxsIHwgdW5kZWZpbmVkPikgPT4gQXJyYXk8e1xuICAgICAgICBlbmRwb2ludE5hbWU6IHN0cmluZztcbiAgICAgICAgb3JpZ2luYWxBcmdzOiBhbnk7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXk6IHN0cmluZztcbiAgICAgIH0+O1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgZnVuY3Rpb24gdG8gc2VsZWN0IGFsbCBhcmd1bWVudHMgY3VycmVudGx5IGNhY2hlZCBmb3IgYSBnaXZlbiBlbmRwb2ludC5cbiAgICAgICAqXG4gICAgICAgKiBDYW4gYmUgdXNlZCBmb3IgbXV0YXRpb25zIHRoYXQgd2FudCB0byBkbyBvcHRpbWlzdGljIHVwZGF0ZXMgaW5zdGVhZCBvZiBpbnZhbGlkYXRpbmcgYSBzZXQgb2YgdGFncywgYnV0IGRvbid0IGtub3cgZXhhY3RseSB3aGF0IHRoZXkgbmVlZCB0byB1cGRhdGUuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdENhY2hlZEFyZ3NGb3JRdWVyeTogPFF1ZXJ5TmFtZSBleHRlbmRzIEFsbFF1ZXJ5S2V5czxEZWZpbml0aW9ucz4+KHN0YXRlOiBSb290U3RhdGU8RGVmaW5pdGlvbnMsIHN0cmluZywgUmVkdWNlclBhdGg+LCBxdWVyeU5hbWU6IFF1ZXJ5TmFtZSkgPT4gQXJyYXk8UXVlcnlBcmdGcm9tQW55UXVlcnk8RGVmaW5pdGlvbnNbUXVlcnlOYW1lXT4+O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5kcG9pbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBlbmRwb2ludHMgcHJvdmlkZWQgdG8gYGNyZWF0ZUFwaWAsIGNvbnRhaW5pbmcgYHNlbGVjdGAgYW5kIGBhY3Rpb24gbWF0Y2hlcnNgLlxuICAgICAqL1xuICAgIGVuZHBvaW50czogeyBbSyBpbiBrZXlvZiBEZWZpbml0aW9uc106IERlZmluaXRpb25zW0tdIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55PiA/IEFwaUVuZHBvaW50UXVlcnk8RGVmaW5pdGlvbnNbS10sIERlZmluaXRpb25zPiA6IERlZmluaXRpb25zW0tdIGV4dGVuZHMgTXV0YXRpb25EZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55PiA/IEFwaUVuZHBvaW50TXV0YXRpb248RGVmaW5pdGlvbnNbS10sIERlZmluaXRpb25zPiA6IERlZmluaXRpb25zW0tdIGV4dGVuZHMgSW5maW5pdGVRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnk+ID8gQXBpRW5kcG9pbnRJbmZpbml0ZVF1ZXJ5PERlZmluaXRpb25zW0tdLCBEZWZpbml0aW9ucz4gOiBuZXZlciB9O1xuICB9O1xufVxuZXhwb3J0IGludGVyZmFjZSBBcGlFbmRwb2ludFF1ZXJ5PFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuRGVmaW5pdGlvbiBleHRlbmRzIFF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4sXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5EZWZpbml0aW9ucyBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbnM+IGV4dGVuZHMgQnVpbGRUaHVua3NBcGlFbmRwb2ludFF1ZXJ5PERlZmluaXRpb24+LCBCdWlsZEluaXRpYXRlQXBpRW5kcG9pbnRRdWVyeTxEZWZpbml0aW9uPiwgQnVpbGRTZWxlY3RvcnNBcGlFbmRwb2ludFF1ZXJ5PERlZmluaXRpb24sIERlZmluaXRpb25zPiB7XG4gIG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIEFsbCBvZiB0aGVzZSBhcmUgYHVuZGVmaW5lZGAgYXQgcnVudGltZSwgcHVyZWx5IHRvIGJlIHVzZWQgaW4gVHlwZVNjcmlwdCBkZWNsYXJhdGlvbnMhXG4gICAqL1xuICBUeXBlczogTm9uTnVsbGFibGU8RGVmaW5pdGlvblsnVHlwZXMnXT47XG59XG5leHBvcnQgaW50ZXJmYWNlIEFwaUVuZHBvaW50SW5maW5pdGVRdWVyeTxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbkRlZmluaXRpb24gZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4sXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5EZWZpbml0aW9ucyBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbnM+IGV4dGVuZHMgQnVpbGRUaHVua3NBcGlFbmRwb2ludEluZmluaXRlUXVlcnk8RGVmaW5pdGlvbj4sIEJ1aWxkSW5pdGlhdGVBcGlFbmRwb2ludEluZmluaXRlUXVlcnk8RGVmaW5pdGlvbj4sIEJ1aWxkU2VsZWN0b3JzQXBpRW5kcG9pbnRJbmZpbml0ZVF1ZXJ5PERlZmluaXRpb24sIERlZmluaXRpb25zPiB7XG4gIG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIEFsbCBvZiB0aGVzZSBhcmUgYHVuZGVmaW5lZGAgYXQgcnVudGltZSwgcHVyZWx5IHRvIGJlIHVzZWQgaW4gVHlwZVNjcmlwdCBkZWNsYXJhdGlvbnMhXG4gICAqL1xuICBUeXBlczogTm9uTnVsbGFibGU8RGVmaW5pdGlvblsnVHlwZXMnXT47XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbmV4cG9ydCBpbnRlcmZhY2UgQXBpRW5kcG9pbnRNdXRhdGlvbjxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbkRlZmluaXRpb24gZXh0ZW5kcyBNdXRhdGlvbkRlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnk+LFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuRGVmaW5pdGlvbnMgZXh0ZW5kcyBFbmRwb2ludERlZmluaXRpb25zPiBleHRlbmRzIEJ1aWxkVGh1bmtzQXBpRW5kcG9pbnRNdXRhdGlvbjxEZWZpbml0aW9uPiwgQnVpbGRJbml0aWF0ZUFwaUVuZHBvaW50TXV0YXRpb248RGVmaW5pdGlvbj4sIEJ1aWxkU2VsZWN0b3JzQXBpRW5kcG9pbnRNdXRhdGlvbjxEZWZpbml0aW9uLCBEZWZpbml0aW9ucz4ge1xuICBuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlc2UgYXJlIGB1bmRlZmluZWRgIGF0IHJ1bnRpbWUsIHB1cmVseSB0byBiZSB1c2VkIGluIFR5cGVTY3JpcHQgZGVjbGFyYXRpb25zIVxuICAgKi9cbiAgVHlwZXM6IE5vbk51bGxhYmxlPERlZmluaXRpb25bJ1R5cGVzJ10+O1xufVxuZXhwb3J0IHR5cGUgTGlzdGVuZXJBY3Rpb25zID0ge1xuICAvKipcbiAgICogV2lsbCBjYXVzZSB0aGUgUlRLIFF1ZXJ5IG1pZGRsZXdhcmUgdG8gdHJpZ2dlciBhbnkgcmVmZXRjaE9uUmVjb25uZWN0LXJlbGF0ZWQgYmVoYXZpb3JcbiAgICogQGxpbmsgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9ydGstcXVlcnkvYXBpL3NldHVwTGlzdGVuZXJzXG4gICAqL1xuICBvbk9ubGluZTogdHlwZW9mIG9uT25saW5lO1xuICBvbk9mZmxpbmU6IHR5cGVvZiBvbk9mZmxpbmU7XG4gIC8qKlxuICAgKiBXaWxsIGNhdXNlIHRoZSBSVEsgUXVlcnkgbWlkZGxld2FyZSB0byB0cmlnZ2VyIGFueSByZWZldGNoT25Gb2N1cy1yZWxhdGVkIGJlaGF2aW9yXG4gICAqIEBsaW5rIGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvcnRrLXF1ZXJ5L2FwaS9zZXR1cExpc3RlbmVyc1xuICAgKi9cbiAgb25Gb2N1czogdHlwZW9mIG9uRm9jdXM7XG4gIG9uRm9jdXNMb3N0OiB0eXBlb2Ygb25Gb2N1c0xvc3Q7XG59O1xuZXhwb3J0IHR5cGUgSW50ZXJuYWxBY3Rpb25zID0gU2xpY2VBY3Rpb25zICYgTGlzdGVuZXJBY3Rpb25zO1xuZXhwb3J0IGludGVyZmFjZSBDb3JlTW9kdWxlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBBIHNlbGVjdG9yIGNyZWF0b3IgKHVzdWFsbHkgZnJvbSBgcmVzZWxlY3RgLCBvciBtYXRjaGluZyB0aGUgc2FtZSBzaWduYXR1cmUpXG4gICAqL1xuICBjcmVhdGVTZWxlY3Rvcj86IHR5cGVvZiBfY3JlYXRlU2VsZWN0b3I7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1vZHVsZSBjb250YWluaW5nIHRoZSBiYXNpYyByZWR1eCBsb2dpYyBmb3IgdXNlIHdpdGggYGJ1aWxkQ3JlYXRlQXBpYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNyZWF0ZUJhc2VBcGkgPSBidWlsZENyZWF0ZUFwaShjb3JlTW9kdWxlKCkpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBjb3JlTW9kdWxlID0gKHtcbiAgY3JlYXRlU2VsZWN0b3IgPSBfY3JlYXRlU2VsZWN0b3Jcbn06IENvcmVNb2R1bGVPcHRpb25zID0ge30pOiBNb2R1bGU8Q29yZU1vZHVsZT4gPT4gKHtcbiAgbmFtZTogY29yZU1vZHVsZU5hbWUsXG4gIGluaXQoYXBpLCB7XG4gICAgYmFzZVF1ZXJ5LFxuICAgIHRhZ1R5cGVzLFxuICAgIHJlZHVjZXJQYXRoLFxuICAgIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgICBrZWVwVW51c2VkRGF0YUZvcixcbiAgICByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlLFxuICAgIHJlZmV0Y2hPbkZvY3VzLFxuICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICBpbnZhbGlkYXRpb25CZWhhdmlvcixcbiAgICBvblNjaGVtYUZhaWx1cmUsXG4gICAgY2F0Y2hTY2hlbWFGYWlsdXJlLFxuICAgIHNraXBTY2hlbWFWYWxpZGF0aW9uXG4gIH0sIGNvbnRleHQpIHtcbiAgICBlbmFibGVQYXRjaGVzKCk7XG4gICAgYXNzZXJ0Q2FzdDxJbnRlcm5hbFNlcmlhbGl6ZVF1ZXJ5QXJncz4oc2VyaWFsaXplUXVlcnlBcmdzKTtcbiAgICBjb25zdCBhc3NlcnRUYWdUeXBlOiBBc3NlcnRUYWdUeXBlcyA9IHRhZyA9PiB7XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGlmICghdGFnVHlwZXMuaW5jbHVkZXModGFnLnR5cGUgYXMgYW55KSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFRhZyB0eXBlICcke3RhZy50eXBlfScgd2FzIHVzZWQsIGJ1dCBub3Qgc3BlY2lmaWVkIGluIFxcYHRhZ1R5cGVzXFxgIWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH07XG4gICAgT2JqZWN0LmFzc2lnbihhcGksIHtcbiAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgZW5kcG9pbnRzOiB7fSxcbiAgICAgIGludGVybmFsQWN0aW9uczoge1xuICAgICAgICBvbk9ubGluZSxcbiAgICAgICAgb25PZmZsaW5lLFxuICAgICAgICBvbkZvY3VzLFxuICAgICAgICBvbkZvY3VzTG9zdFxuICAgICAgfSxcbiAgICAgIHV0aWw6IHt9XG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZWN0b3JzID0gYnVpbGRTZWxlY3RvcnMoe1xuICAgICAgc2VyaWFsaXplUXVlcnlBcmdzOiBzZXJpYWxpemVRdWVyeUFyZ3MgYXMgYW55LFxuICAgICAgcmVkdWNlclBhdGgsXG4gICAgICBjcmVhdGVTZWxlY3RvclxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHNlbGVjdEludmFsaWRhdGVkQnksXG4gICAgICBzZWxlY3RDYWNoZWRBcmdzRm9yUXVlcnksXG4gICAgICBidWlsZFF1ZXJ5U2VsZWN0b3IsXG4gICAgICBidWlsZEluZmluaXRlUXVlcnlTZWxlY3RvcixcbiAgICAgIGJ1aWxkTXV0YXRpb25TZWxlY3RvclxuICAgIH0gPSBzZWxlY3RvcnM7XG4gICAgc2FmZUFzc2lnbihhcGkudXRpbCwge1xuICAgICAgc2VsZWN0SW52YWxpZGF0ZWRCeSxcbiAgICAgIHNlbGVjdENhY2hlZEFyZ3NGb3JRdWVyeVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHF1ZXJ5VGh1bmssXG4gICAgICBpbmZpbml0ZVF1ZXJ5VGh1bmssXG4gICAgICBtdXRhdGlvblRodW5rLFxuICAgICAgcGF0Y2hRdWVyeURhdGEsXG4gICAgICB1cGRhdGVRdWVyeURhdGEsXG4gICAgICB1cHNlcnRRdWVyeURhdGEsXG4gICAgICBwcmVmZXRjaCxcbiAgICAgIGJ1aWxkTWF0Y2hUaHVua0FjdGlvbnNcbiAgICB9ID0gYnVpbGRUaHVua3Moe1xuICAgICAgYmFzZVF1ZXJ5LFxuICAgICAgcmVkdWNlclBhdGgsXG4gICAgICBjb250ZXh0LFxuICAgICAgYXBpLFxuICAgICAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICAgICAgYXNzZXJ0VGFnVHlwZSxcbiAgICAgIHNlbGVjdG9ycyxcbiAgICAgIG9uU2NoZW1hRmFpbHVyZSxcbiAgICAgIGNhdGNoU2NoZW1hRmFpbHVyZSxcbiAgICAgIHNraXBTY2hlbWFWYWxpZGF0aW9uXG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgcmVkdWNlcixcbiAgICAgIGFjdGlvbnM6IHNsaWNlQWN0aW9uc1xuICAgIH0gPSBidWlsZFNsaWNlKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBxdWVyeVRodW5rLFxuICAgICAgaW5maW5pdGVRdWVyeVRodW5rLFxuICAgICAgbXV0YXRpb25UaHVuayxcbiAgICAgIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgYXNzZXJ0VGFnVHlwZSxcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICByZWZldGNoT25Gb2N1cyxcbiAgICAgICAgcmVmZXRjaE9uUmVjb25uZWN0LFxuICAgICAgICByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlLFxuICAgICAgICBrZWVwVW51c2VkRGF0YUZvcixcbiAgICAgICAgcmVkdWNlclBhdGgsXG4gICAgICAgIGludmFsaWRhdGlvbkJlaGF2aW9yXG4gICAgICB9XG4gICAgfSk7XG4gICAgc2FmZUFzc2lnbihhcGkudXRpbCwge1xuICAgICAgcGF0Y2hRdWVyeURhdGEsXG4gICAgICB1cGRhdGVRdWVyeURhdGEsXG4gICAgICB1cHNlcnRRdWVyeURhdGEsXG4gICAgICBwcmVmZXRjaCxcbiAgICAgIHJlc2V0QXBpU3RhdGU6IHNsaWNlQWN0aW9ucy5yZXNldEFwaVN0YXRlLFxuICAgICAgdXBzZXJ0UXVlcnlFbnRyaWVzOiBzbGljZUFjdGlvbnMuY2FjaGVFbnRyaWVzVXBzZXJ0ZWQgYXMgYW55XG4gICAgfSk7XG4gICAgc2FmZUFzc2lnbihhcGkuaW50ZXJuYWxBY3Rpb25zLCBzbGljZUFjdGlvbnMpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1pZGRsZXdhcmUsXG4gICAgICBhY3Rpb25zOiBtaWRkbGV3YXJlQWN0aW9uc1xuICAgIH0gPSBidWlsZE1pZGRsZXdhcmUoe1xuICAgICAgcmVkdWNlclBhdGgsXG4gICAgICBjb250ZXh0LFxuICAgICAgcXVlcnlUaHVuayxcbiAgICAgIG11dGF0aW9uVGh1bmssXG4gICAgICBpbmZpbml0ZVF1ZXJ5VGh1bmssXG4gICAgICBhcGksXG4gICAgICBhc3NlcnRUYWdUeXBlLFxuICAgICAgc2VsZWN0b3JzXG4gICAgfSk7XG4gICAgc2FmZUFzc2lnbihhcGkudXRpbCwgbWlkZGxld2FyZUFjdGlvbnMpO1xuICAgIHNhZmVBc3NpZ24oYXBpLCB7XG4gICAgICByZWR1Y2VyOiByZWR1Y2VyIGFzIGFueSxcbiAgICAgIG1pZGRsZXdhcmVcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBidWlsZEluaXRpYXRlUXVlcnksXG4gICAgICBidWlsZEluaXRpYXRlSW5maW5pdGVRdWVyeSxcbiAgICAgIGJ1aWxkSW5pdGlhdGVNdXRhdGlvbixcbiAgICAgIGdldFJ1bm5pbmdNdXRhdGlvblRodW5rLFxuICAgICAgZ2V0UnVubmluZ011dGF0aW9uc1RodW5rLFxuICAgICAgZ2V0UnVubmluZ1F1ZXJpZXNUaHVuayxcbiAgICAgIGdldFJ1bm5pbmdRdWVyeVRodW5rXG4gICAgfSA9IGJ1aWxkSW5pdGlhdGUoe1xuICAgICAgcXVlcnlUaHVuayxcbiAgICAgIG11dGF0aW9uVGh1bmssXG4gICAgICBpbmZpbml0ZVF1ZXJ5VGh1bmssXG4gICAgICBhcGksXG4gICAgICBzZXJpYWxpemVRdWVyeUFyZ3M6IHNlcmlhbGl6ZVF1ZXJ5QXJncyBhcyBhbnksXG4gICAgICBjb250ZXh0XG4gICAgfSk7XG4gICAgc2FmZUFzc2lnbihhcGkudXRpbCwge1xuICAgICAgZ2V0UnVubmluZ011dGF0aW9uVGh1bmssXG4gICAgICBnZXRSdW5uaW5nTXV0YXRpb25zVGh1bmssXG4gICAgICBnZXRSdW5uaW5nUXVlcnlUaHVuayxcbiAgICAgIGdldFJ1bm5pbmdRdWVyaWVzVGh1bmtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogY29yZU1vZHVsZU5hbWUsXG4gICAgICBpbmplY3RFbmRwb2ludChlbmRwb2ludE5hbWUsIGRlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3QgYW55QXBpID0gYXBpIGFzIGFueSBhcyBBcGk8YW55LCBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBzdHJpbmcsIHN0cmluZywgQ29yZU1vZHVsZT47XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYW55QXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdID8/PSB7fSBhcyBhbnk7XG4gICAgICAgIGlmIChpc1F1ZXJ5RGVmaW5pdGlvbihkZWZpbml0aW9uKSkge1xuICAgICAgICAgIHNhZmVBc3NpZ24oZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG5hbWU6IGVuZHBvaW50TmFtZSxcbiAgICAgICAgICAgIHNlbGVjdDogYnVpbGRRdWVyeVNlbGVjdG9yKGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbiksXG4gICAgICAgICAgICBpbml0aWF0ZTogYnVpbGRJbml0aWF0ZVF1ZXJ5KGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbilcbiAgICAgICAgICB9LCBidWlsZE1hdGNoVGh1bmtBY3Rpb25zKHF1ZXJ5VGh1bmssIGVuZHBvaW50TmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc011dGF0aW9uRGVmaW5pdGlvbihkZWZpbml0aW9uKSkge1xuICAgICAgICAgIHNhZmVBc3NpZ24oZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG5hbWU6IGVuZHBvaW50TmFtZSxcbiAgICAgICAgICAgIHNlbGVjdDogYnVpbGRNdXRhdGlvblNlbGVjdG9yKCksXG4gICAgICAgICAgICBpbml0aWF0ZTogYnVpbGRJbml0aWF0ZU11dGF0aW9uKGVuZHBvaW50TmFtZSlcbiAgICAgICAgICB9LCBidWlsZE1hdGNoVGh1bmtBY3Rpb25zKG11dGF0aW9uVGh1bmssIGVuZHBvaW50TmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0luZmluaXRlUXVlcnlEZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgc2FmZUFzc2lnbihlbmRwb2ludCwge1xuICAgICAgICAgICAgbmFtZTogZW5kcG9pbnROYW1lLFxuICAgICAgICAgICAgc2VsZWN0OiBidWlsZEluZmluaXRlUXVlcnlTZWxlY3RvcihlbmRwb2ludE5hbWUsIGRlZmluaXRpb24pLFxuICAgICAgICAgICAgaW5pdGlhdGU6IGJ1aWxkSW5pdGlhdGVJbmZpbml0ZVF1ZXJ5KGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbilcbiAgICAgICAgICB9LCBidWlsZE1hdGNoVGh1bmtBY3Rpb25zKHF1ZXJ5VGh1bmssIGVuZHBvaW50TmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7IiwiZXhwb3J0IHR5cGUgSWQ8VD4gPSB7IFtLIGluIGtleW9mIFRdOiBUW0tdIH0gJiB7fTtcbmV4cG9ydCB0eXBlIFdpdGhSZXF1aXJlZFByb3A8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gT21pdDxULCBLPiAmIFJlcXVpcmVkPFBpY2s8VCwgSz4+O1xuZXhwb3J0IHR5cGUgT3ZlcnJpZGU8VDEsIFQyPiA9IFQyIGV4dGVuZHMgYW55ID8gT21pdDxUMSwga2V5b2YgVDI+ICYgVDIgOiBuZXZlcjtcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRDYXN0PFQ+KHY6IGFueSk6IGFzc2VydHMgdiBpcyBUIHt9XG5leHBvcnQgZnVuY3Rpb24gc2FmZUFzc2lnbjxUIGV4dGVuZHMgb2JqZWN0Pih0YXJnZXQ6IFQsIC4uLmFyZ3M6IEFycmF5PFBhcnRpYWw8Tm9JbmZlcjxUPj4+KTogVCB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHRhcmdldCwgLi4uYXJncyk7XG59XG5cbi8qKlxuICogQ29udmVydCBhIFVuaW9uIHR5cGUgYChBfEIpYCB0byBhbiBpbnRlcnNlY3Rpb24gdHlwZSBgKEEmQilgXG4gKi9cbmV4cG9ydCB0eXBlIFVuaW9uVG9JbnRlcnNlY3Rpb248VT4gPSAoVSBleHRlbmRzIGFueSA/IChrOiBVKSA9PiB2b2lkIDogbmV2ZXIpIGV4dGVuZHMgKChrOiBpbmZlciBJKSA9PiB2b2lkKSA/IEkgOiBuZXZlcjtcbmV4cG9ydCB0eXBlIE5vbk9wdGlvbmFsS2V5czxUPiA9IHsgW0sgaW4ga2V5b2YgVF0tPzogdW5kZWZpbmVkIGV4dGVuZHMgVFtLXSA/IG5ldmVyIDogSyB9W2tleW9mIFRdO1xuZXhwb3J0IHR5cGUgSGFzUmVxdWlyZWRQcm9wczxULCBUcnVlLCBGYWxzZT4gPSBOb25PcHRpb25hbEtleXM8VD4gZXh0ZW5kcyBuZXZlciA/IEZhbHNlIDogVHJ1ZTtcbmV4cG9ydCB0eXBlIE9wdGlvbmFsSWZBbGxQcm9wc09wdGlvbmFsPFQ+ID0gSGFzUmVxdWlyZWRQcm9wczxULCBULCBUIHwgbmV2ZXI+O1xuZXhwb3J0IHR5cGUgTm9JbmZlcjxUPiA9IFtUXVtUIGV4dGVuZHMgYW55ID8gMCA6IG5ldmVyXTtcbmV4cG9ydCB0eXBlIE5vblVuZGVmaW5lZDxUPiA9IFQgZXh0ZW5kcyB1bmRlZmluZWQgPyBuZXZlciA6IFQ7XG5leHBvcnQgdHlwZSBVbndyYXBQcm9taXNlPFQ+ID0gVCBleHRlbmRzIFByb21pc2VMaWtlPGluZmVyIFY+ID8gViA6IFQ7XG5leHBvcnQgdHlwZSBNYXliZVByb21pc2U8VD4gPSBUIHwgUHJvbWlzZUxpa2U8VD47XG5leHBvcnQgdHlwZSBPbWl0RnJvbVVuaW9uPFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFQgZXh0ZW5kcyBhbnkgPyBPbWl0PFQsIEs+IDogbmV2ZXI7XG5leHBvcnQgdHlwZSBJc0FueTxULCBUcnVlLCBGYWxzZSA9IG5ldmVyPiA9IHRydWUgfCBmYWxzZSBleHRlbmRzIChUIGV4dGVuZHMgbmV2ZXIgPyB0cnVlIDogZmFsc2UpID8gVHJ1ZSA6IEZhbHNlO1xuZXhwb3J0IHR5cGUgQ2FzdEFueTxULCBDYXN0VG8+ID0gSXNBbnk8VCwgQ2FzdFRvLCBUPjsiLCJpbXBvcnQgdHlwZSB7IEludGVybmFsSGFuZGxlckJ1aWxkZXIsIFN1YnNjcmlwdGlvblNlbGVjdG9ycyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBTdWJzY3JpcHRpb25TdGF0ZSB9IGZyb20gJy4uL2FwaVN0YXRlJztcbmltcG9ydCB7IHByb2R1Y2VXaXRoUGF0Y2hlcyB9IGZyb20gJ2ltbWVyJztcbmltcG9ydCB0eXBlIHsgQWN0aW9uIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XG5pbXBvcnQgeyBjb3VudE9iamVjdEtleXMgfSBmcm9tICcuLi8uLi91dGlscy9jb3VudE9iamVjdEtleXMnO1xuZXhwb3J0IGNvbnN0IGJ1aWxkQmF0Y2hlZEFjdGlvbnNIYW5kbGVyOiBJbnRlcm5hbEhhbmRsZXJCdWlsZGVyPFthY3Rpb25TaG91bGRDb250aW51ZTogYm9vbGVhbiwgcmV0dXJuVmFsdWU6IFN1YnNjcmlwdGlvblNlbGVjdG9ycyB8IGJvb2xlYW5dPiA9ICh7XG4gIGFwaSxcbiAgcXVlcnlUaHVuayxcbiAgaW50ZXJuYWxTdGF0ZVxufSkgPT4ge1xuICBjb25zdCBzdWJzY3JpcHRpb25zUHJlZml4ID0gYCR7YXBpLnJlZHVjZXJQYXRofS9zdWJzY3JpcHRpb25zYDtcbiAgbGV0IHByZXZpb3VzU3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uU3RhdGUgPSBudWxsIGFzIHVua25vd24gYXMgU3Vic2NyaXB0aW9uU3RhdGU7XG4gIGxldCB1cGRhdGVTeW5jVGltZXI6IFJldHVyblR5cGU8dHlwZW9mIHdpbmRvdy5zZXRUaW1lb3V0PiB8IG51bGwgPSBudWxsO1xuICBjb25zdCB7XG4gICAgdXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucyxcbiAgICB1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0XG4gIH0gPSBhcGkuaW50ZXJuYWxBY3Rpb25zO1xuXG4gIC8vIEFjdHVhbGx5IGludGVudGlvbmFsbHkgbXV0YXRlIHRoZSBzdWJzY3JpcHRpb25zIHN0YXRlIHVzZWQgaW4gdGhlIG1pZGRsZXdhcmVcbiAgLy8gVGhpcyBpcyBkb25lIHRvIHNwZWVkIHVwIHBlcmYgd2hlbiBsb2FkaW5nIG1hbnkgY29tcG9uZW50c1xuICBjb25zdCBhY3R1YWxseU11dGF0ZVN1YnNjcmlwdGlvbnMgPSAobXV0YWJsZVN0YXRlOiBTdWJzY3JpcHRpb25TdGF0ZSwgYWN0aW9uOiBBY3Rpb24pID0+IHtcbiAgICBpZiAodXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgaWYgKG11dGFibGVTdGF0ZT8uW3F1ZXJ5Q2FjaGVLZXldPy5bcmVxdWVzdElkXSkge1xuICAgICAgICBtdXRhYmxlU3RhdGVbcXVlcnlDYWNoZUtleV0hW3JlcXVlc3RJZF0gPSBvcHRpb25zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0Lm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgcmVxdWVzdElkXG4gICAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICBpZiAobXV0YWJsZVN0YXRlW3F1ZXJ5Q2FjaGVLZXldKSB7XG4gICAgICAgIGRlbGV0ZSBtdXRhYmxlU3RhdGVbcXVlcnlDYWNoZUtleV0hW3JlcXVlc3RJZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSkge1xuICAgICAgZGVsZXRlIG11dGFibGVTdGF0ZVthY3Rpb24ucGF5bG9hZC5xdWVyeUNhY2hlS2V5XTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocXVlcnlUaHVuay5wZW5kaW5nLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIGFyZyxcbiAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgfVxuICAgICAgfSA9IGFjdGlvbjtcbiAgICAgIGNvbnN0IHN1YnN0YXRlID0gbXV0YWJsZVN0YXRlW2FyZy5xdWVyeUNhY2hlS2V5XSA/Pz0ge307XG4gICAgICBzdWJzdGF0ZVtgJHtyZXF1ZXN0SWR9X3J1bm5pbmdgXSA9IHt9O1xuICAgICAgaWYgKGFyZy5zdWJzY3JpYmUpIHtcbiAgICAgICAgc3Vic3RhdGVbcmVxdWVzdElkXSA9IGFyZy5zdWJzY3JpcHRpb25PcHRpb25zID8/IHN1YnN0YXRlW3JlcXVlc3RJZF0gPz8ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG11dGF0ZWQgPSBmYWxzZTtcbiAgICBpZiAocXVlcnlUaHVuay5mdWxmaWxsZWQubWF0Y2goYWN0aW9uKSB8fCBxdWVyeVRodW5rLnJlamVjdGVkLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gbXV0YWJsZVN0YXRlW2FjdGlvbi5tZXRhLmFyZy5xdWVyeUNhY2hlS2V5XSB8fCB7fTtcbiAgICAgIGNvbnN0IGtleSA9IGAke2FjdGlvbi5tZXRhLnJlcXVlc3RJZH1fcnVubmluZ2A7XG4gICAgICBtdXRhdGVkIHx8PSAhIXN0YXRlW2tleV07XG4gICAgICBkZWxldGUgc3RhdGVba2V5XTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5VGh1bmsucmVqZWN0ZWQubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgIGFyZyxcbiAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgfVxuICAgICAgfSA9IGFjdGlvbjtcbiAgICAgIGlmIChjb25kaXRpb24gJiYgYXJnLnN1YnNjcmliZSkge1xuICAgICAgICBjb25zdCBzdWJzdGF0ZSA9IG11dGFibGVTdGF0ZVthcmcucXVlcnlDYWNoZUtleV0gPz89IHt9O1xuICAgICAgICBzdWJzdGF0ZVtyZXF1ZXN0SWRdID0gYXJnLnN1YnNjcmlwdGlvbk9wdGlvbnMgPz8gc3Vic3RhdGVbcmVxdWVzdElkXSA/PyB7fTtcbiAgICAgICAgbXV0YXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtdXRhdGVkO1xuICB9O1xuICBjb25zdCBnZXRTdWJzY3JpcHRpb25zID0gKCkgPT4gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucztcbiAgY29uc3QgZ2V0U3Vic2NyaXB0aW9uQ291bnQgPSAocXVlcnlDYWNoZUtleTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IGdldFN1YnNjcmlwdGlvbnMoKTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zRm9yUXVlcnlBcmcgPSBzdWJzY3JpcHRpb25zW3F1ZXJ5Q2FjaGVLZXldID8/IHt9O1xuICAgIHJldHVybiBjb3VudE9iamVjdEtleXMoc3Vic2NyaXB0aW9uc0ZvclF1ZXJ5QXJnKTtcbiAgfTtcbiAgY29uc3QgaXNSZXF1ZXN0U3Vic2NyaWJlZCA9IChxdWVyeUNhY2hlS2V5OiBzdHJpbmcsIHJlcXVlc3RJZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IGdldFN1YnNjcmlwdGlvbnMoKTtcbiAgICByZXR1cm4gISFzdWJzY3JpcHRpb25zPy5bcXVlcnlDYWNoZUtleV0/LltyZXF1ZXN0SWRdO1xuICB9O1xuICBjb25zdCBzdWJzY3JpcHRpb25TZWxlY3RvcnM6IFN1YnNjcmlwdGlvblNlbGVjdG9ycyA9IHtcbiAgICBnZXRTdWJzY3JpcHRpb25zLFxuICAgIGdldFN1YnNjcmlwdGlvbkNvdW50LFxuICAgIGlzUmVxdWVzdFN1YnNjcmliZWRcbiAgfTtcbiAgcmV0dXJuIChhY3Rpb24sIG13QXBpKTogW2FjdGlvblNob3VsZENvbnRpbnVlOiBib29sZWFuLCByZXN1bHQ6IFN1YnNjcmlwdGlvblNlbGVjdG9ycyB8IGJvb2xlYW5dID0+IHtcbiAgICBpZiAoIXByZXZpb3VzU3Vic2NyaXB0aW9ucykge1xuICAgICAgLy8gSW5pdGlhbGl6ZSBpdCB0aGUgZmlyc3QgdGltZSB0aGlzIGhhbmRsZXIgcnVuc1xuICAgICAgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zKSk7XG4gICAgfVxuICAgIGlmIChhcGkudXRpbC5yZXNldEFwaVN0YXRlLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHByZXZpb3VzU3Vic2NyaXB0aW9ucyA9IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICAgIHVwZGF0ZVN5bmNUaW1lciA9IG51bGw7XG4gICAgICByZXR1cm4gW3RydWUsIGZhbHNlXTtcbiAgICB9XG5cbiAgICAvLyBJbnRlcmNlcHQgcmVxdWVzdHMgYnkgaG9va3MgdG8gc2VlIGlmIHRoZXkncmUgc3Vic2NyaWJlZFxuICAgIC8vIFdlIHJldHVybiB0aGUgaW50ZXJuYWwgc3RhdGUgcmVmZXJlbmNlIHNvIHRoYXQgaG9va3NcbiAgICAvLyBjYW4gZG8gdGhlaXIgb3duIGNoZWNrcyB0byBzZWUgaWYgdGhleSdyZSBzdGlsbCBhY3RpdmUuXG4gICAgLy8gSXQncyBzdHVwaWQgYW5kIGhhY2t5LCBidXQgaXQgZG9lcyBjdXQgZG93biBvbiBzb21lIGRpc3BhdGNoIGNhbGxzLlxuICAgIGlmIChhcGkuaW50ZXJuYWxBY3Rpb25zLmludGVybmFsX2dldFJUS1FTdWJzY3JpcHRpb25zLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHJldHVybiBbZmFsc2UsIHN1YnNjcmlwdGlvblNlbGVjdG9yc107XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHN1YnNjcmlwdGlvbiBkYXRhIGJhc2VkIG9uIHRoaXMgYWN0aW9uXG4gICAgY29uc3QgZGlkTXV0YXRlID0gYWN0dWFsbHlNdXRhdGVTdWJzY3JpcHRpb25zKGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnMsIGFjdGlvbik7XG4gICAgbGV0IGFjdGlvblNob3VsZENvbnRpbnVlID0gdHJ1ZTtcbiAgICBpZiAoZGlkTXV0YXRlKSB7XG4gICAgICBpZiAoIXVwZGF0ZVN5bmNUaW1lcikge1xuICAgICAgICAvLyBXZSBvbmx5IHVzZSB0aGUgc3Vic2NyaXB0aW9uIHN0YXRlIGZvciB0aGUgUmVkdXggRGV2VG9vbHMgYXQgdGhpcyBwb2ludCxcbiAgICAgICAgLy8gYXMgdGhlIHJlYWwgZGF0YSBpcyBrZXB0IGhlcmUgaW4gdGhlIG1pZGRsZXdhcmUuXG4gICAgICAgIC8vIEdpdmVuIHRoYXQsIHdlIGNhbiB0aHJvdHRsZSBzeW5jaHJvbml6aW5nIHRoaXMgc3RhdGUgc2lnbmlmaWNhbnRseSB0b1xuICAgICAgICAvLyBzYXZlIG9uIG92ZXJhbGwgcGVyZi5cbiAgICAgICAgLy8gSW4gMS45LCBpdCB3YXMgdXBkYXRlZCBpbiBhIG1pY3JvdGFzaywgYnV0IG5vdyB3ZSBkbyBpdCBhdCBtb3N0IGV2ZXJ5IDUwMG1zLlxuICAgICAgICB1cGRhdGVTeW5jVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAvLyBEZWVwIGNsb25lIHRoZSBjdXJyZW50IHN1YnNjcmlwdGlvbiBkYXRhXG4gICAgICAgICAgY29uc3QgbmV3U3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uU3RhdGUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnMpKTtcbiAgICAgICAgICAvLyBGaWd1cmUgb3V0IGEgc21hbGxlciBkaWZmIGJldHdlZW4gb3JpZ2luYWwgYW5kIGN1cnJlbnRcbiAgICAgICAgICBjb25zdCBbLCBwYXRjaGVzXSA9IHByb2R1Y2VXaXRoUGF0Y2hlcyhwcmV2aW91c1N1YnNjcmlwdGlvbnMsICgpID0+IG5ld1N1YnNjcmlwdGlvbnMpO1xuXG4gICAgICAgICAgLy8gU3luYyB0aGUgc3RvcmUgc3RhdGUgZm9yIHZpc2liaWxpdHlcbiAgICAgICAgICBtd0FwaS5uZXh0KGFwaS5pbnRlcm5hbEFjdGlvbnMuc3Vic2NyaXB0aW9uc1VwZGF0ZWQocGF0Y2hlcykpO1xuICAgICAgICAgIC8vIFNhdmUgdGhlIGNsb25lZCBzdGF0ZSBmb3IgbGF0ZXIgcmVmZXJlbmNlXG4gICAgICAgICAgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gbmV3U3Vic2NyaXB0aW9ucztcbiAgICAgICAgICB1cGRhdGVTeW5jVGltZXIgPSBudWxsO1xuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNTdWJzY3JpcHRpb25TbGljZUFjdGlvbiA9IHR5cGVvZiBhY3Rpb24udHlwZSA9PSAnc3RyaW5nJyAmJiAhIWFjdGlvbi50eXBlLnN0YXJ0c1dpdGgoc3Vic2NyaXB0aW9uc1ByZWZpeCk7XG4gICAgICBjb25zdCBpc0FkZGl0aW9uYWxTdWJzY3JpcHRpb25BY3Rpb24gPSBxdWVyeVRodW5rLnJlamVjdGVkLm1hdGNoKGFjdGlvbikgJiYgYWN0aW9uLm1ldGEuY29uZGl0aW9uICYmICEhYWN0aW9uLm1ldGEuYXJnLnN1YnNjcmliZTtcbiAgICAgIGFjdGlvblNob3VsZENvbnRpbnVlID0gIWlzU3Vic2NyaXB0aW9uU2xpY2VBY3Rpb24gJiYgIWlzQWRkaXRpb25hbFN1YnNjcmlwdGlvbkFjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIFthY3Rpb25TaG91bGRDb250aW51ZSwgZmFsc2VdO1xuICB9O1xufTsiLCJpbXBvcnQgdHlwZSB7IFF1ZXJ5RGVmaW5pdGlvbiB9IGZyb20gJy4uLy4uL2VuZHBvaW50RGVmaW5pdGlvbnMnO1xuaW1wb3J0IHR5cGUgeyBDb25maWdTdGF0ZSwgUXVlcnlDYWNoZUtleSB9IGZyb20gJy4uL2FwaVN0YXRlJztcbmltcG9ydCB7IGlzQW55T2YgfSBmcm9tICcuLi9ydGtJbXBvcnRzJztcbmltcG9ydCB0eXBlIHsgQXBpTWlkZGxld2FyZUludGVybmFsSGFuZGxlciwgSW50ZXJuYWxIYW5kbGVyQnVpbGRlciwgUXVlcnlTdGF0ZU1ldGEsIFN1Yk1pZGRsZXdhcmVBcGksIFRpbWVvdXRJZCB9IGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IHR5cGUgUmVmZXJlbmNlQ2FjaGVDb2xsZWN0aW9uID0gbmV2ZXI7XG5mdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iajogUmVjb3JkPGFueSwgYW55Pikge1xuICAvLyBBcHBhcmVudGx5IGEgZm9yLi5pbiBsb29wIGlzIGZhc3RlciB0aGFuIGBPYmplY3Qua2V5cygpYCBoZXJlOlxuICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTk3ODc3ODQvNjI5MzdcbiAgZm9yIChjb25zdCBrIGluIG9iaikge1xuICAgIC8vIElmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBrZXksIGl0J3Mgbm90IGVtcHR5XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IHR5cGUgQ2FjaGVDb2xsZWN0aW9uUXVlcnlFeHRyYU9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBPdmVycmlkZXMgdGhlIGFwaS13aWRlIGRlZmluaXRpb24gb2YgYGtlZXBVbnVzZWREYXRhRm9yYCBmb3IgdGhpcyBlbmRwb2ludCBvbmx5LiBfKFRoaXMgdmFsdWUgaXMgaW4gc2Vjb25kcy4pX1xuICAgKlxuICAgKiBUaGlzIGlzIGhvdyBsb25nIFJUSyBRdWVyeSB3aWxsIGtlZXAgeW91ciBkYXRhIGNhY2hlZCBmb3IgKiphZnRlcioqIHRoZSBsYXN0IGNvbXBvbmVudCB1bnN1YnNjcmliZXMuIEZvciBleGFtcGxlLCBpZiB5b3UgcXVlcnkgYW4gZW5kcG9pbnQsIHRoZW4gdW5tb3VudCB0aGUgY29tcG9uZW50LCB0aGVuIG1vdW50IGFub3RoZXIgY29tcG9uZW50IHRoYXQgbWFrZXMgdGhlIHNhbWUgcmVxdWVzdCB3aXRoaW4gdGhlIGdpdmVuIHRpbWUgZnJhbWUsIHRoZSBtb3N0IHJlY2VudCB2YWx1ZSB3aWxsIGJlIHNlcnZlZCBmcm9tIHRoZSBjYWNoZS5cbiAgICovXG4gIGtlZXBVbnVzZWREYXRhRm9yPzogbnVtYmVyO1xufTtcblxuLy8gUGVyIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9zZXRUaW1lb3V0I21heGltdW1fZGVsYXlfdmFsdWUgLCBicm93c2VycyBzdG9yZVxuLy8gYHNldFRpbWVvdXQoKWAgdGltZXIgdmFsdWVzIGluIGEgMzItYml0IGludC4gSWYgd2UgcGFzcyBhIHZhbHVlIGluIHRoYXQncyBsYXJnZXIgdGhhbiB0aGF0LFxuLy8gaXQgd3JhcHMgYW5kIGVuZHMgdXAgZXhlY3V0aW5nIGltbWVkaWF0ZWx5LlxuLy8gT3VyIGBrZWVwVW51c2VkRGF0YUZvcmAgdmFsdWVzIGFyZSBpbiBzZWNvbmRzLCBzbyBhZGp1c3QgdGhlIG51bWJlcnMgaGVyZSBhY2NvcmRpbmdseS5cbmV4cG9ydCBjb25zdCBUSElSVFlfVFdPX0JJVF9NQVhfSU5UID0gMl8xNDdfNDgzXzY0NztcbmV4cG9ydCBjb25zdCBUSElSVFlfVFdPX0JJVF9NQVhfVElNRVJfU0VDT05EUyA9IDJfMTQ3XzQ4M182NDcgLyAxXzAwMCAtIDE7XG5leHBvcnQgY29uc3QgYnVpbGRDYWNoZUNvbGxlY3Rpb25IYW5kbGVyOiBJbnRlcm5hbEhhbmRsZXJCdWlsZGVyID0gKHtcbiAgcmVkdWNlclBhdGgsXG4gIGFwaSxcbiAgcXVlcnlUaHVuayxcbiAgY29udGV4dCxcbiAgaW50ZXJuYWxTdGF0ZSxcbiAgc2VsZWN0b3JzOiB7XG4gICAgc2VsZWN0UXVlcnlFbnRyeSxcbiAgICBzZWxlY3RDb25maWdcbiAgfVxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmVtb3ZlUXVlcnlSZXN1bHQsXG4gICAgdW5zdWJzY3JpYmVRdWVyeVJlc3VsdCxcbiAgICBjYWNoZUVudHJpZXNVcHNlcnRlZFxuICB9ID0gYXBpLmludGVybmFsQWN0aW9ucztcbiAgY29uc3QgY2FuVHJpZ2dlclVuc3Vic2NyaWJlID0gaXNBbnlPZih1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0Lm1hdGNoLCBxdWVyeVRodW5rLmZ1bGZpbGxlZCwgcXVlcnlUaHVuay5yZWplY3RlZCwgY2FjaGVFbnRyaWVzVXBzZXJ0ZWQubWF0Y2gpO1xuICBmdW5jdGlvbiBhbnlTdWJzY3JpcHRpb25zUmVtYWluaW5nRm9yS2V5KHF1ZXJ5Q2FjaGVLZXk6IHN0cmluZykge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zW3F1ZXJ5Q2FjaGVLZXldO1xuICAgIHJldHVybiAhIXN1YnNjcmlwdGlvbnMgJiYgIWlzT2JqZWN0RW1wdHkoc3Vic2NyaXB0aW9ucyk7XG4gIH1cbiAgY29uc3QgY3VycmVudFJlbW92YWxUaW1lb3V0czogUXVlcnlTdGF0ZU1ldGE8VGltZW91dElkPiA9IHt9O1xuICBjb25zdCBoYW5kbGVyOiBBcGlNaWRkbGV3YXJlSW50ZXJuYWxIYW5kbGVyID0gKGFjdGlvbiwgbXdBcGksIGludGVybmFsU3RhdGUpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IG13QXBpLmdldFN0YXRlKCk7XG4gICAgY29uc3QgY29uZmlnID0gc2VsZWN0Q29uZmlnKHN0YXRlKTtcbiAgICBpZiAoY2FuVHJpZ2dlclVuc3Vic2NyaWJlKGFjdGlvbikpIHtcbiAgICAgIGxldCBxdWVyeUNhY2hlS2V5czogUXVlcnlDYWNoZUtleVtdO1xuICAgICAgaWYgKGNhY2hlRW50cmllc1Vwc2VydGVkLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgICAgcXVlcnlDYWNoZUtleXMgPSBhY3Rpb24ucGF5bG9hZC5tYXAoZW50cnkgPT4gZW50cnkucXVlcnlEZXNjcmlwdGlvbi5xdWVyeUNhY2hlS2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICAgIH0gPSB1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0Lm1hdGNoKGFjdGlvbikgPyBhY3Rpb24ucGF5bG9hZCA6IGFjdGlvbi5tZXRhLmFyZztcbiAgICAgICAgcXVlcnlDYWNoZUtleXMgPSBbcXVlcnlDYWNoZUtleV07XG4gICAgICB9XG4gICAgICBoYW5kbGVVbnN1YnNjcmliZU1hbnkocXVlcnlDYWNoZUtleXMsIG13QXBpLCBjb25maWcpO1xuICAgIH1cbiAgICBpZiAoYXBpLnV0aWwucmVzZXRBcGlTdGF0ZS5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHRpbWVvdXRdIG9mIE9iamVjdC5lbnRyaWVzKGN1cnJlbnRSZW1vdmFsVGltZW91dHMpKSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIGRlbGV0ZSBjdXJyZW50UmVtb3ZhbFRpbWVvdXRzW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0Lmhhc1JlaHlkcmF0aW9uSW5mbyhhY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHF1ZXJpZXNcbiAgICAgIH0gPSBjb250ZXh0LmV4dHJhY3RSZWh5ZHJhdGlvbkluZm8oYWN0aW9uKSE7XG4gICAgICAvLyBHb3RjaGE6XG4gICAgICAvLyBJZiByZWh5ZHJhdGluZyBiZWZvcmUgdGhlIGVuZHBvaW50IGhhcyBiZWVuIGluamVjdGVkLHRoZSBnbG9iYWwgYGtlZXBVbnVzZWREYXRhRm9yYFxuICAgICAgLy8gd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGVuZHBvaW50LXNwZWNpZmljIG9uZS5cbiAgICAgIGhhbmRsZVVuc3Vic2NyaWJlTWFueShPYmplY3Qua2V5cyhxdWVyaWVzKSBhcyBRdWVyeUNhY2hlS2V5W10sIG13QXBpLCBjb25maWcpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gaGFuZGxlVW5zdWJzY3JpYmVNYW55KGNhY2hlS2V5czogUXVlcnlDYWNoZUtleVtdLCBhcGk6IFN1Yk1pZGRsZXdhcmVBcGksIGNvbmZpZzogQ29uZmlnU3RhdGU8c3RyaW5nPikge1xuICAgIGNvbnN0IHN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgZm9yIChjb25zdCBxdWVyeUNhY2hlS2V5IG9mIGNhY2hlS2V5cykge1xuICAgICAgY29uc3QgZW50cnkgPSBzZWxlY3RRdWVyeUVudHJ5KHN0YXRlLCBxdWVyeUNhY2hlS2V5KTtcbiAgICAgIGhhbmRsZVVuc3Vic2NyaWJlKHF1ZXJ5Q2FjaGVLZXksIGVudHJ5Py5lbmRwb2ludE5hbWUsIGFwaSwgY29uZmlnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlVW5zdWJzY3JpYmUocXVlcnlDYWNoZUtleTogUXVlcnlDYWNoZUtleSwgZW5kcG9pbnROYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQsIGFwaTogU3ViTWlkZGxld2FyZUFwaSwgY29uZmlnOiBDb25maWdTdGF0ZTxzdHJpbmc+KSB7XG4gICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZSFdIGFzIFF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+O1xuICAgIGNvbnN0IGtlZXBVbnVzZWREYXRhRm9yID0gZW5kcG9pbnREZWZpbml0aW9uPy5rZWVwVW51c2VkRGF0YUZvciA/PyBjb25maWcua2VlcFVudXNlZERhdGFGb3I7XG4gICAgaWYgKGtlZXBVbnVzZWREYXRhRm9yID09PSBJbmZpbml0eSkge1xuICAgICAgLy8gSGV5LCB1c2VyIHNhaWQga2VlcCB0aGlzIGZvcmV2ZXIhXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFByZXZlbnQgYHNldFRpbWVvdXRgIHRpbWVycyBmcm9tIG92ZXJmbG93aW5nIGEgMzItYml0IGludGVybmFsIGludCwgYnlcbiAgICAvLyBjbGFtcGluZyB0aGUgbWF4IHZhbHVlIHRvIGJlIGF0IG1vc3QgMTAwMG1zIGxlc3MgdGhhbiB0aGUgMzItYml0IG1heC5cbiAgICAvLyBMb29rLCBhIDI0LjgtZGF5IGtlZXBhbGl2ZSBvdWdodCB0byBiZSBlbm91Z2ggZm9yIGFueWJvZHksIHJpZ2h0PyA6KVxuICAgIC8vIEFsc28gYXZvaWQgbmVnYXRpdmUgdmFsdWVzIHRvby5cbiAgICBjb25zdCBmaW5hbEtlZXBVbnVzZWREYXRhRm9yID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oa2VlcFVudXNlZERhdGFGb3IsIFRISVJUWV9UV09fQklUX01BWF9USU1FUl9TRUNPTkRTKSk7XG4gICAgaWYgKCFhbnlTdWJzY3JpcHRpb25zUmVtYWluaW5nRm9yS2V5KHF1ZXJ5Q2FjaGVLZXkpKSB7XG4gICAgICBjb25zdCBjdXJyZW50VGltZW91dCA9IGN1cnJlbnRSZW1vdmFsVGltZW91dHNbcXVlcnlDYWNoZUtleV07XG4gICAgICBpZiAoY3VycmVudFRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGN1cnJlbnRUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRSZW1vdmFsVGltZW91dHNbcXVlcnlDYWNoZUtleV0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCFhbnlTdWJzY3JpcHRpb25zUmVtYWluaW5nRm9yS2V5KHF1ZXJ5Q2FjaGVLZXkpKSB7XG4gICAgICAgICAgYXBpLmRpc3BhdGNoKHJlbW92ZVF1ZXJ5UmVzdWx0KHtcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGN1cnJlbnRSZW1vdmFsVGltZW91dHMhW3F1ZXJ5Q2FjaGVLZXldO1xuICAgICAgfSwgZmluYWxLZWVwVW51c2VkRGF0YUZvciAqIDEwMDApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGFuZGxlcjtcbn07IiwiaW1wb3J0IHR5cGUgeyBUaHVua0Rpc3BhdGNoLCBVbmtub3duQWN0aW9uIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XG5pbXBvcnQgdHlwZSB7IEJhc2VRdWVyeUZuLCBCYXNlUXVlcnlNZXRhLCBCYXNlUXVlcnlSZXN1bHQgfSBmcm9tICcuLi8uLi9iYXNlUXVlcnlUeXBlcyc7XG5pbXBvcnQgdHlwZSB7IEJhc2VFbmRwb2ludERlZmluaXRpb24gfSBmcm9tICcuLi8uLi9lbmRwb2ludERlZmluaXRpb25zJztcbmltcG9ydCB7IERlZmluaXRpb25UeXBlLCBpc0FueVF1ZXJ5RGVmaW5pdGlvbiB9IGZyb20gJy4uLy4uL2VuZHBvaW50RGVmaW5pdGlvbnMnO1xuaW1wb3J0IHR5cGUgeyBRdWVyeUNhY2hlS2V5LCBSb290U3RhdGUgfSBmcm9tICcuLi9hcGlTdGF0ZSc7XG5pbXBvcnQgdHlwZSB7IE11dGF0aW9uUmVzdWx0U2VsZWN0b3JSZXN1bHQsIFF1ZXJ5UmVzdWx0U2VsZWN0b3JSZXN1bHQgfSBmcm9tICcuLi9idWlsZFNlbGVjdG9ycyc7XG5pbXBvcnQgeyBnZXRNdXRhdGlvbkNhY2hlS2V5IH0gZnJvbSAnLi4vYnVpbGRTbGljZSc7XG5pbXBvcnQgdHlwZSB7IFBhdGNoQ29sbGVjdGlvbiwgUmVjaXBlIH0gZnJvbSAnLi4vYnVpbGRUaHVua3MnO1xuaW1wb3J0IHsgaXNBc3luY1RodW5rQWN0aW9uLCBpc0Z1bGZpbGxlZCB9IGZyb20gJy4uL3J0a0ltcG9ydHMnO1xuaW1wb3J0IHR5cGUgeyBBcGlNaWRkbGV3YXJlSW50ZXJuYWxIYW5kbGVyLCBJbnRlcm5hbEhhbmRsZXJCdWlsZGVyLCBQcm9taXNlV2l0aEtub3duUmVhc29uLCBTdWJNaWRkbGV3YXJlQXBpIH0gZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgdHlwZSBSZWZlcmVuY2VDYWNoZUxpZmVjeWNsZSA9IG5ldmVyO1xuZXhwb3J0IGludGVyZmFjZSBRdWVyeUJhc2VMaWZlY3ljbGVBcGk8UXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gZXh0ZW5kcyBMaWZlY3ljbGVBcGk8UmVkdWNlclBhdGg+IHtcbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhpcyBjYWNoZSBlbnRyeS5cbiAgICovXG4gIGdldENhY2hlRW50cnkoKTogUXVlcnlSZXN1bHRTZWxlY3RvclJlc3VsdDx7XG4gICAgdHlwZTogRGVmaW5pdGlvblR5cGUucXVlcnk7XG4gIH0gJiBCYXNlRW5kcG9pbnREZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFJlc3VsdFR5cGUsIEJhc2VRdWVyeVJlc3VsdDxCYXNlUXVlcnk+Pj47XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IGNhY2hlIGVudHJ5IHZhbHVlLlxuICAgKiBGb3IgZG9jdW1lbnRhdGlvbiBzZWUgYGFwaS51dGlsLnVwZGF0ZVF1ZXJ5RGF0YWAuXG4gICAqL1xuICB1cGRhdGVDYWNoZWREYXRhKHVwZGF0ZVJlY2lwZTogUmVjaXBlPFJlc3VsdFR5cGU+KTogUGF0Y2hDb2xsZWN0aW9uO1xufVxuZXhwb3J0IHR5cGUgTXV0YXRpb25CYXNlTGlmZWN5Y2xlQXBpPFF1ZXJ5QXJnLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgUmVzdWx0VHlwZSwgUmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+ID0gTGlmZWN5Y2xlQXBpPFJlZHVjZXJQYXRoPiAmIHtcbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhpcyBjYWNoZSBlbnRyeS5cbiAgICovXG4gIGdldENhY2hlRW50cnkoKTogTXV0YXRpb25SZXN1bHRTZWxlY3RvclJlc3VsdDx7XG4gICAgdHlwZTogRGVmaW5pdGlvblR5cGUubXV0YXRpb247XG4gIH0gJiBCYXNlRW5kcG9pbnREZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFJlc3VsdFR5cGUsIEJhc2VRdWVyeVJlc3VsdDxCYXNlUXVlcnk+Pj47XG59O1xudHlwZSBMaWZlY3ljbGVBcGk8UmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+ID0ge1xuICAvKipcbiAgICogVGhlIGRpc3BhdGNoIG1ldGhvZCBmb3IgdGhlIHN0b3JlXG4gICAqL1xuICBkaXNwYXRjaDogVGh1bmtEaXNwYXRjaDxhbnksIGFueSwgVW5rbm93bkFjdGlvbj47XG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0byBnZXQgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICovXG4gIGdldFN0YXRlKCk6IFJvb3RTdGF0ZTxhbnksIGFueSwgUmVkdWNlclBhdGg+O1xuICAvKipcbiAgICogYGV4dHJhYCBhcyBwcm92aWRlZCBhcyBgdGh1bmsuZXh0cmFBcmd1bWVudGAgdG8gdGhlIGBjb25maWd1cmVTdG9yZWAgYGdldERlZmF1bHRNaWRkbGV3YXJlYCBvcHRpb24uXG4gICAqL1xuICBleHRyYTogdW5rbm93bjtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIElEIGdlbmVyYXRlZCBmb3IgdGhlIG11dGF0aW9uXG4gICAqL1xuICByZXF1ZXN0SWQ6IHN0cmluZztcbn07XG50eXBlIENhY2hlTGlmZWN5Y2xlUHJvbWlzZXM8UmVzdWx0VHlwZSA9IHVua25vd24sIE1ldGFUeXBlID0gdW5rbm93bj4gPSB7XG4gIC8qKlxuICAgKiBQcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdpdGggdGhlIGZpcnN0IHZhbHVlIGZvciB0aGlzIGNhY2hlIGtleS5cbiAgICogVGhpcyBhbGxvd3MgeW91IHRvIGBhd2FpdGAgdW50aWwgYW4gYWN0dWFsIHZhbHVlIGlzIGluIGNhY2hlLlxuICAgKlxuICAgKiBJZiB0aGUgY2FjaGUgZW50cnkgaXMgcmVtb3ZlZCBmcm9tIHRoZSBjYWNoZSBiZWZvcmUgYW55IHZhbHVlIGhhcyBldmVyXG4gICAqIGJlZW4gcmVzb2x2ZWQsIHRoaXMgUHJvbWlzZSB3aWxsIHJlamVjdCB3aXRoXG4gICAqIGBuZXcgRXJyb3IoJ1Byb21pc2UgbmV2ZXIgcmVzb2x2ZWQgYmVmb3JlIGNhY2hlRW50cnlSZW1vdmVkLicpYFxuICAgKiB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy5cbiAgICogWW91IGNhbiBqdXN0IHJlLXRocm93IHRoYXQgZXJyb3IgKG9yIG5vdCBoYW5kbGUgaXQgYXQgYWxsKSAtXG4gICAqIGl0IHdpbGwgYmUgY2F1Z2h0IG91dHNpZGUgb2YgYGNhY2hlRW50cnlBZGRlZGAuXG4gICAqXG4gICAqIElmIHlvdSBkb24ndCBpbnRlcmFjdCB3aXRoIHRoaXMgcHJvbWlzZSwgaXQgd2lsbCBub3QgdGhyb3cuXG4gICAqL1xuICBjYWNoZURhdGFMb2FkZWQ6IFByb21pc2VXaXRoS25vd25SZWFzb248e1xuICAgIC8qKlxuICAgICAqIFRoZSAodHJhbnNmb3JtZWQpIHF1ZXJ5IHJlc3VsdC5cbiAgICAgKi9cbiAgICBkYXRhOiBSZXN1bHRUeXBlO1xuICAgIC8qKlxuICAgICAqIFRoZSBgbWV0YWAgcmV0dXJuZWQgYnkgdGhlIGBiYXNlUXVlcnlgXG4gICAgICovXG4gICAgbWV0YTogTWV0YVR5cGU7XG4gIH0sIHR5cGVvZiBuZXZlclJlc29sdmVkRXJyb3I+O1xuICAvKipcbiAgICogUHJvbWlzZSB0aGF0IGFsbG93cyB5b3UgdG8gd2FpdCBmb3IgdGhlIHBvaW50IGluIHRpbWUgd2hlbiB0aGUgY2FjaGUgZW50cnlcbiAgICogaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBjYWNoZSwgYnkgbm90IGJlaW5nIHVzZWQvc3Vic2NyaWJlZCB0byBhbnkgbW9yZVxuICAgKiBpbiB0aGUgYXBwbGljYXRpb24gZm9yIHRvbyBsb25nIG9yIGJ5IGRpc3BhdGNoaW5nIGBhcGkudXRpbC5yZXNldEFwaVN0YXRlYC5cbiAgICovXG4gIGNhY2hlRW50cnlSZW1vdmVkOiBQcm9taXNlPHZvaWQ+O1xufTtcbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlDYWNoZUxpZmVjeWNsZUFwaTxRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiBleHRlbmRzIFF1ZXJ5QmFzZUxpZmVjeWNsZUFwaTxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aD4sIENhY2hlTGlmZWN5Y2xlUHJvbWlzZXM8UmVzdWx0VHlwZSwgQmFzZVF1ZXJ5TWV0YTxCYXNlUXVlcnk+PiB7fVxuZXhwb3J0IHR5cGUgTXV0YXRpb25DYWNoZUxpZmVjeWNsZUFwaTxRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IE11dGF0aW9uQmFzZUxpZmVjeWNsZUFwaTxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aD4gJiBDYWNoZUxpZmVjeWNsZVByb21pc2VzPFJlc3VsdFR5cGUsIEJhc2VRdWVyeU1ldGE8QmFzZVF1ZXJ5Pj47XG5leHBvcnQgdHlwZSBDYWNoZUxpZmVjeWNsZVF1ZXJ5RXh0cmFPcHRpb25zPFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgUmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+ID0ge1xuICBvbkNhY2hlRW50cnlBZGRlZD8oYXJnOiBRdWVyeUFyZywgYXBpOiBRdWVyeUNhY2hlTGlmZWN5Y2xlQXBpPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoPik6IFByb21pc2U8dm9pZD4gfCB2b2lkO1xufTtcbmV4cG9ydCB0eXBlIENhY2hlTGlmZWN5Y2xlSW5maW5pdGVRdWVyeUV4dHJhT3B0aW9uczxSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IENhY2hlTGlmZWN5Y2xlUXVlcnlFeHRyYU9wdGlvbnM8UmVzdWx0VHlwZSwgUXVlcnlBcmcsIEJhc2VRdWVyeSwgUmVkdWNlclBhdGg+O1xuZXhwb3J0IHR5cGUgQ2FjaGVMaWZlY3ljbGVNdXRhdGlvbkV4dHJhT3B0aW9uczxSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IHtcbiAgb25DYWNoZUVudHJ5QWRkZWQ/KGFyZzogUXVlcnlBcmcsIGFwaTogTXV0YXRpb25DYWNoZUxpZmVjeWNsZUFwaTxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aD4pOiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbn07XG5jb25zdCBuZXZlclJlc29sdmVkRXJyb3IgPSBuZXcgRXJyb3IoJ1Byb21pc2UgbmV2ZXIgcmVzb2x2ZWQgYmVmb3JlIGNhY2hlRW50cnlSZW1vdmVkLicpIGFzIEVycm9yICYge1xuICBtZXNzYWdlOiAnUHJvbWlzZSBuZXZlciByZXNvbHZlZCBiZWZvcmUgY2FjaGVFbnRyeVJlbW92ZWQuJztcbn07XG5leHBvcnQgY29uc3QgYnVpbGRDYWNoZUxpZmVjeWNsZUhhbmRsZXI6IEludGVybmFsSGFuZGxlckJ1aWxkZXIgPSAoe1xuICBhcGksXG4gIHJlZHVjZXJQYXRoLFxuICBjb250ZXh0LFxuICBxdWVyeVRodW5rLFxuICBtdXRhdGlvblRodW5rLFxuICBpbnRlcm5hbFN0YXRlLFxuICBzZWxlY3RvcnM6IHtcbiAgICBzZWxlY3RRdWVyeUVudHJ5LFxuICAgIHNlbGVjdEFwaVN0YXRlXG4gIH1cbn0pID0+IHtcbiAgY29uc3QgaXNRdWVyeVRodW5rID0gaXNBc3luY1RodW5rQWN0aW9uKHF1ZXJ5VGh1bmspO1xuICBjb25zdCBpc011dGF0aW9uVGh1bmsgPSBpc0FzeW5jVGh1bmtBY3Rpb24obXV0YXRpb25UaHVuayk7XG4gIGNvbnN0IGlzRnVsZmlsbGVkVGh1bmsgPSBpc0Z1bGZpbGxlZChxdWVyeVRodW5rLCBtdXRhdGlvblRodW5rKTtcbiAgdHlwZSBDYWNoZUxpZmVjeWNsZSA9IHtcbiAgICB2YWx1ZVJlc29sdmVkPyh2YWx1ZToge1xuICAgICAgZGF0YTogdW5rbm93bjtcbiAgICAgIG1ldGE6IHVua25vd247XG4gICAgfSk6IHVua25vd247XG4gICAgY2FjaGVFbnRyeVJlbW92ZWQoKTogdm9pZDtcbiAgfTtcbiAgY29uc3QgbGlmZWN5Y2xlTWFwOiBSZWNvcmQ8c3RyaW5nLCBDYWNoZUxpZmVjeWNsZT4gPSB7fTtcbiAgZnVuY3Rpb24gcmVzb2x2ZUxpZmVjeWNsZUVudHJ5KGNhY2hlS2V5OiBzdHJpbmcsIGRhdGE6IHVua25vd24sIG1ldGE6IHVua25vd24pIHtcbiAgICBjb25zdCBsaWZlY3ljbGUgPSBsaWZlY3ljbGVNYXBbY2FjaGVLZXldO1xuICAgIGlmIChsaWZlY3ljbGU/LnZhbHVlUmVzb2x2ZWQpIHtcbiAgICAgIGxpZmVjeWNsZS52YWx1ZVJlc29sdmVkKHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgbWV0YVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgbGlmZWN5Y2xlLnZhbHVlUmVzb2x2ZWQ7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUxpZmVjeWNsZUVudHJ5KGNhY2hlS2V5OiBzdHJpbmcpIHtcbiAgICBjb25zdCBsaWZlY3ljbGUgPSBsaWZlY3ljbGVNYXBbY2FjaGVLZXldO1xuICAgIGlmIChsaWZlY3ljbGUpIHtcbiAgICAgIGRlbGV0ZSBsaWZlY3ljbGVNYXBbY2FjaGVLZXldO1xuICAgICAgbGlmZWN5Y2xlLmNhY2hlRW50cnlSZW1vdmVkKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGhhbmRsZXI6IEFwaU1pZGRsZXdhcmVJbnRlcm5hbEhhbmRsZXIgPSAoYWN0aW9uLCBtd0FwaSwgc3RhdGVCZWZvcmUpID0+IHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KGFjdGlvbikgYXMgUXVlcnlDYWNoZUtleTtcbiAgICBmdW5jdGlvbiBjaGVja0Zvck5ld0NhY2hlS2V5KGVuZHBvaW50TmFtZTogc3RyaW5nLCBjYWNoZUtleTogUXVlcnlDYWNoZUtleSwgcmVxdWVzdElkOiBzdHJpbmcsIG9yaWdpbmFsQXJnczogdW5rbm93bikge1xuICAgICAgY29uc3Qgb2xkRW50cnkgPSBzZWxlY3RRdWVyeUVudHJ5KHN0YXRlQmVmb3JlLCBjYWNoZUtleSk7XG4gICAgICBjb25zdCBuZXdFbnRyeSA9IHNlbGVjdFF1ZXJ5RW50cnkobXdBcGkuZ2V0U3RhdGUoKSwgY2FjaGVLZXkpO1xuICAgICAgaWYgKCFvbGRFbnRyeSAmJiBuZXdFbnRyeSkge1xuICAgICAgICBoYW5kbGVOZXdLZXkoZW5kcG9pbnROYW1lLCBvcmlnaW5hbEFyZ3MsIGNhY2hlS2V5LCBtd0FwaSwgcmVxdWVzdElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHF1ZXJ5VGh1bmsucGVuZGluZy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjaGVja0Zvck5ld0NhY2hlS2V5KGFjdGlvbi5tZXRhLmFyZy5lbmRwb2ludE5hbWUsIGNhY2hlS2V5LCBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQsIGFjdGlvbi5tZXRhLmFyZy5vcmlnaW5hbEFyZ3MpO1xuICAgIH0gZWxzZSBpZiAoYXBpLmludGVybmFsQWN0aW9ucy5jYWNoZUVudHJpZXNVcHNlcnRlZC5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgcXVlcnlEZXNjcmlwdGlvbixcbiAgICAgICAgdmFsdWVcbiAgICAgIH0gb2YgYWN0aW9uLnBheWxvYWQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGVuZHBvaW50TmFtZSxcbiAgICAgICAgICBvcmlnaW5hbEFyZ3MsXG4gICAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgICB9ID0gcXVlcnlEZXNjcmlwdGlvbjtcbiAgICAgICAgY2hlY2tGb3JOZXdDYWNoZUtleShlbmRwb2ludE5hbWUsIHF1ZXJ5Q2FjaGVLZXksIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCwgb3JpZ2luYWxBcmdzKTtcbiAgICAgICAgcmVzb2x2ZUxpZmVjeWNsZUVudHJ5KHF1ZXJ5Q2FjaGVLZXksIHZhbHVlLCB7fSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtdXRhdGlvblRodW5rLnBlbmRpbmcubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXS5tdXRhdGlvbnNbY2FjaGVLZXldO1xuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIGhhbmRsZU5ld0tleShhY3Rpb24ubWV0YS5hcmcuZW5kcG9pbnROYW1lLCBhY3Rpb24ubWV0YS5hcmcub3JpZ2luYWxBcmdzLCBjYWNoZUtleSwgbXdBcGksIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0Z1bGZpbGxlZFRodW5rKGFjdGlvbikpIHtcbiAgICAgIHJlc29sdmVMaWZlY3ljbGVFbnRyeShjYWNoZUtleSwgYWN0aW9uLnBheWxvYWQsIGFjdGlvbi5tZXRhLmJhc2VRdWVyeU1ldGEpO1xuICAgIH0gZWxzZSBpZiAoYXBpLmludGVybmFsQWN0aW9ucy5yZW1vdmVRdWVyeVJlc3VsdC5tYXRjaChhY3Rpb24pIHx8IGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlTXV0YXRpb25SZXN1bHQubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmVtb3ZlTGlmZWN5Y2xlRW50cnkoY2FjaGVLZXkpO1xuICAgIH0gZWxzZSBpZiAoYXBpLnV0aWwucmVzZXRBcGlTdGF0ZS5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBmb3IgKGNvbnN0IGNhY2hlS2V5IG9mIE9iamVjdC5rZXlzKGxpZmVjeWNsZU1hcCkpIHtcbiAgICAgICAgcmVtb3ZlTGlmZWN5Y2xlRW50cnkoY2FjaGVLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZ2V0Q2FjaGVLZXkoYWN0aW9uOiBhbnkpIHtcbiAgICBpZiAoaXNRdWVyeVRodW5rKGFjdGlvbikpIHJldHVybiBhY3Rpb24ubWV0YS5hcmcucXVlcnlDYWNoZUtleTtcbiAgICBpZiAoaXNNdXRhdGlvblRodW5rKGFjdGlvbikpIHtcbiAgICAgIHJldHVybiBhY3Rpb24ubWV0YS5hcmcuZml4ZWRDYWNoZUtleSA/PyBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQ7XG4gICAgfVxuICAgIGlmIChhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZVF1ZXJ5UmVzdWx0Lm1hdGNoKGFjdGlvbikpIHJldHVybiBhY3Rpb24ucGF5bG9hZC5xdWVyeUNhY2hlS2V5O1xuICAgIGlmIChhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZU11dGF0aW9uUmVzdWx0Lm1hdGNoKGFjdGlvbikpIHJldHVybiBnZXRNdXRhdGlvbkNhY2hlS2V5KGFjdGlvbi5wYXlsb2FkKTtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3S2V5KGVuZHBvaW50TmFtZTogc3RyaW5nLCBvcmlnaW5hbEFyZ3M6IGFueSwgcXVlcnlDYWNoZUtleTogc3RyaW5nLCBtd0FwaTogU3ViTWlkZGxld2FyZUFwaSwgcmVxdWVzdElkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXTtcbiAgICBjb25zdCBvbkNhY2hlRW50cnlBZGRlZCA9IGVuZHBvaW50RGVmaW5pdGlvbj8ub25DYWNoZUVudHJ5QWRkZWQ7XG4gICAgaWYgKCFvbkNhY2hlRW50cnlBZGRlZCkgcmV0dXJuO1xuICAgIGNvbnN0IGxpZmVjeWNsZSA9IHt9IGFzIENhY2hlTGlmZWN5Y2xlO1xuICAgIGNvbnN0IGNhY2hlRW50cnlSZW1vdmVkID0gbmV3IFByb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiB7XG4gICAgICBsaWZlY3ljbGUuY2FjaGVFbnRyeVJlbW92ZWQgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGNvbnN0IGNhY2hlRGF0YUxvYWRlZDogUHJvbWlzZVdpdGhLbm93blJlYXNvbjx7XG4gICAgICBkYXRhOiB1bmtub3duO1xuICAgICAgbWV0YTogdW5rbm93bjtcbiAgICB9LCB0eXBlb2YgbmV2ZXJSZXNvbHZlZEVycm9yPiA9IFByb21pc2UucmFjZShbbmV3IFByb21pc2U8e1xuICAgICAgZGF0YTogdW5rbm93bjtcbiAgICAgIG1ldGE6IHVua25vd247XG4gICAgfT4ocmVzb2x2ZSA9PiB7XG4gICAgICBsaWZlY3ljbGUudmFsdWVSZXNvbHZlZCA9IHJlc29sdmU7XG4gICAgfSksIGNhY2hlRW50cnlSZW1vdmVkLnRoZW4oKCkgPT4ge1xuICAgICAgdGhyb3cgbmV2ZXJSZXNvbHZlZEVycm9yO1xuICAgIH0pXSk7XG4gICAgLy8gcHJldmVudCB1bmNhdWdodCBwcm9taXNlIHJlamVjdGlvbnMgZnJvbSBoYXBwZW5pbmcuXG4gICAgLy8gaWYgdGhlIG9yaWdpbmFsIHByb21pc2UgaXMgdXNlZCBpbiBhbnkgd2F5LCB0aGF0IHdpbGwgY3JlYXRlIGEgbmV3IHByb21pc2UgdGhhdCB3aWxsIHRocm93IGFnYWluXG4gICAgY2FjaGVEYXRhTG9hZGVkLmNhdGNoKCgpID0+IHt9KTtcbiAgICBsaWZlY3ljbGVNYXBbcXVlcnlDYWNoZUtleV0gPSBsaWZlY3ljbGU7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSAoYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdIGFzIGFueSkuc2VsZWN0KGlzQW55UXVlcnlEZWZpbml0aW9uKGVuZHBvaW50RGVmaW5pdGlvbikgPyBvcmlnaW5hbEFyZ3MgOiBxdWVyeUNhY2hlS2V5KTtcbiAgICBjb25zdCBleHRyYSA9IG13QXBpLmRpc3BhdGNoKChfLCBfXywgZXh0cmEpID0+IGV4dHJhKTtcbiAgICBjb25zdCBsaWZlY3ljbGVBcGkgPSB7XG4gICAgICAuLi5td0FwaSxcbiAgICAgIGdldENhY2hlRW50cnk6ICgpID0+IHNlbGVjdG9yKG13QXBpLmdldFN0YXRlKCkpLFxuICAgICAgcmVxdWVzdElkLFxuICAgICAgZXh0cmEsXG4gICAgICB1cGRhdGVDYWNoZWREYXRhOiAoaXNBbnlRdWVyeURlZmluaXRpb24oZW5kcG9pbnREZWZpbml0aW9uKSA/ICh1cGRhdGVSZWNpcGU6IFJlY2lwZTxhbnk+KSA9PiBtd0FwaS5kaXNwYXRjaChhcGkudXRpbC51cGRhdGVRdWVyeURhdGEoZW5kcG9pbnROYW1lIGFzIG5ldmVyLCBvcmlnaW5hbEFyZ3MgYXMgbmV2ZXIsIHVwZGF0ZVJlY2lwZSkpIDogdW5kZWZpbmVkKSBhcyBhbnksXG4gICAgICBjYWNoZURhdGFMb2FkZWQsXG4gICAgICBjYWNoZUVudHJ5UmVtb3ZlZFxuICAgIH07XG4gICAgY29uc3QgcnVubmluZ0hhbmRsZXIgPSBvbkNhY2hlRW50cnlBZGRlZChvcmlnaW5hbEFyZ3MsIGxpZmVjeWNsZUFwaSBhcyBhbnkpO1xuICAgIC8vIGlmIGEgYG5ldmVyUmVzb2x2ZWRFcnJvcmAgd2FzIHRocm93biwgYnV0IG5vdCBoYW5kbGVkIGluIHRoZSBydW5uaW5nIGhhbmRsZXIsIGRvIG5vdCBsZXQgaXQgbGVhayBvdXQgZnVydGhlclxuICAgIFByb21pc2UucmVzb2x2ZShydW5uaW5nSGFuZGxlcikuY2F0Y2goZSA9PiB7XG4gICAgICBpZiAoZSA9PT0gbmV2ZXJSZXNvbHZlZEVycm9yKSByZXR1cm47XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBoYW5kbGVyO1xufTsiLCJpbXBvcnQgdHlwZSB7IEludGVybmFsSGFuZGxlckJ1aWxkZXIgfSBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCBjb25zdCBidWlsZERldkNoZWNrSGFuZGxlcjogSW50ZXJuYWxIYW5kbGVyQnVpbGRlciA9ICh7XG4gIGFwaSxcbiAgY29udGV4dDoge1xuICAgIGFwaVVpZFxuICB9LFxuICByZWR1Y2VyUGF0aFxufSkgPT4ge1xuICByZXR1cm4gKGFjdGlvbiwgbXdBcGkpID0+IHtcbiAgICBpZiAoYXBpLnV0aWwucmVzZXRBcGlTdGF0ZS5tYXRjaChhY3Rpb24pKSB7XG4gICAgICAvLyBkaXNwYXRjaCBhZnRlciBhcGkgcmVzZXRcbiAgICAgIG13QXBpLmRpc3BhdGNoKGFwaS5pbnRlcm5hbEFjdGlvbnMubWlkZGxld2FyZVJlZ2lzdGVyZWQoYXBpVWlkKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmIChhcGkuaW50ZXJuYWxBY3Rpb25zLm1pZGRsZXdhcmVSZWdpc3RlcmVkLm1hdGNoKGFjdGlvbikgJiYgYWN0aW9uLnBheWxvYWQgPT09IGFwaVVpZCAmJiBtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXT8uY29uZmlnPy5taWRkbGV3YXJlUmVnaXN0ZXJlZCA9PT0gJ2NvbmZsaWN0Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oYFRoZXJlIGlzIGEgbWlzbWF0Y2ggYmV0d2VlbiBzbGljZSBhbmQgbWlkZGxld2FyZSBmb3IgdGhlIHJlZHVjZXJQYXRoIFwiJHtyZWR1Y2VyUGF0aH1cIi5cbllvdSBjYW4gb25seSBoYXZlIG9uZSBhcGkgcGVyIHJlZHVjZXIgcGF0aCwgdGhpcyB3aWxsIGxlYWQgdG8gY3Jhc2hlcyBpbiB2YXJpb3VzIHNpdHVhdGlvbnMhJHtyZWR1Y2VyUGF0aCA9PT0gJ2FwaScgPyBgXG5JZiB5b3UgaGF2ZSBtdWx0aXBsZSBhcGlzLCB5b3UgKmhhdmUqIHRvIHNwZWNpZnkgdGhlIHJlZHVjZXJQYXRoIG9wdGlvbiB3aGVuIHVzaW5nIGNyZWF0ZUFwaSFgIDogJyd9YCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTsiLCJpbXBvcnQgeyBpc0FueU9mLCBpc0Z1bGZpbGxlZCwgaXNSZWplY3RlZCwgaXNSZWplY3RlZFdpdGhWYWx1ZSB9IGZyb20gJy4uL3J0a0ltcG9ydHMnO1xuaW1wb3J0IHR5cGUgeyBFbmRwb2ludERlZmluaXRpb25zLCBGdWxsVGFnRGVzY3JpcHRpb24gfSBmcm9tICcuLi8uLi9lbmRwb2ludERlZmluaXRpb25zJztcbmltcG9ydCB7IGNhbGN1bGF0ZVByb3ZpZGVkQnkgfSBmcm9tICcuLi8uLi9lbmRwb2ludERlZmluaXRpb25zJztcbmltcG9ydCB0eXBlIHsgQ29tYmluZWRTdGF0ZSwgUXVlcnlDYWNoZUtleSB9IGZyb20gJy4uL2FwaVN0YXRlJztcbmltcG9ydCB7IFF1ZXJ5U3RhdHVzIH0gZnJvbSAnLi4vYXBpU3RhdGUnO1xuaW1wb3J0IHsgY2FsY3VsYXRlUHJvdmlkZWRCeVRodW5rIH0gZnJvbSAnLi4vYnVpbGRUaHVua3MnO1xuaW1wb3J0IHR5cGUgeyBTdWJNaWRkbGV3YXJlQXBpLCBJbnRlcm5hbEhhbmRsZXJCdWlsZGVyLCBBcGlNaWRkbGV3YXJlSW50ZXJuYWxIYW5kbGVyLCBJbnRlcm5hbE1pZGRsZXdhcmVTdGF0ZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgY291bnRPYmplY3RLZXlzIH0gZnJvbSAnLi4vLi4vdXRpbHMvY291bnRPYmplY3RLZXlzJztcbmV4cG9ydCBjb25zdCBidWlsZEludmFsaWRhdGlvbkJ5VGFnc0hhbmRsZXI6IEludGVybmFsSGFuZGxlckJ1aWxkZXIgPSAoe1xuICByZWR1Y2VyUGF0aCxcbiAgY29udGV4dCxcbiAgY29udGV4dDoge1xuICAgIGVuZHBvaW50RGVmaW5pdGlvbnNcbiAgfSxcbiAgbXV0YXRpb25UaHVuayxcbiAgcXVlcnlUaHVuayxcbiAgYXBpLFxuICBhc3NlcnRUYWdUeXBlLFxuICByZWZldGNoUXVlcnksXG4gIGludGVybmFsU3RhdGVcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIHJlbW92ZVF1ZXJ5UmVzdWx0XG4gIH0gPSBhcGkuaW50ZXJuYWxBY3Rpb25zO1xuICBjb25zdCBpc1RodW5rQWN0aW9uV2l0aFRhZ3MgPSBpc0FueU9mKGlzRnVsZmlsbGVkKG11dGF0aW9uVGh1bmspLCBpc1JlamVjdGVkV2l0aFZhbHVlKG11dGF0aW9uVGh1bmspKTtcbiAgY29uc3QgaXNRdWVyeUVuZCA9IGlzQW55T2YoaXNGdWxmaWxsZWQobXV0YXRpb25UaHVuaywgcXVlcnlUaHVuayksIGlzUmVqZWN0ZWQobXV0YXRpb25UaHVuaywgcXVlcnlUaHVuaykpO1xuICBsZXQgcGVuZGluZ1RhZ0ludmFsaWRhdGlvbnM6IEZ1bGxUYWdEZXNjcmlwdGlvbjxzdHJpbmc+W10gPSBbXTtcbiAgY29uc3QgaGFuZGxlcjogQXBpTWlkZGxld2FyZUludGVybmFsSGFuZGxlciA9IChhY3Rpb24sIG13QXBpKSA9PiB7XG4gICAgaWYgKGlzVGh1bmtBY3Rpb25XaXRoVGFncyhhY3Rpb24pKSB7XG4gICAgICBpbnZhbGlkYXRlVGFncyhjYWxjdWxhdGVQcm92aWRlZEJ5VGh1bmsoYWN0aW9uLCAnaW52YWxpZGF0ZXNUYWdzJywgZW5kcG9pbnREZWZpbml0aW9ucywgYXNzZXJ0VGFnVHlwZSksIG13QXBpKTtcbiAgICB9IGVsc2UgaWYgKGlzUXVlcnlFbmQoYWN0aW9uKSkge1xuICAgICAgaW52YWxpZGF0ZVRhZ3MoW10sIG13QXBpKTtcbiAgICB9IGVsc2UgaWYgKGFwaS51dGlsLmludmFsaWRhdGVUYWdzLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGludmFsaWRhdGVUYWdzKGNhbGN1bGF0ZVByb3ZpZGVkQnkoYWN0aW9uLnBheWxvYWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXNzZXJ0VGFnVHlwZSksIG13QXBpKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGhhc1BlbmRpbmdSZXF1ZXN0cyhzdGF0ZTogQ29tYmluZWRTdGF0ZTxFbmRwb2ludERlZmluaXRpb25zLCBzdHJpbmcsIHN0cmluZz4pIHtcbiAgICBjb25zdCB7XG4gICAgICBxdWVyaWVzLFxuICAgICAgbXV0YXRpb25zXG4gICAgfSA9IHN0YXRlO1xuICAgIGZvciAoY29uc3QgY2FjaGVSZWNvcmQgb2YgW3F1ZXJpZXMsIG11dGF0aW9uc10pIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNhY2hlUmVjb3JkKSB7XG4gICAgICAgIGlmIChjYWNoZVJlY29yZFtrZXldPy5zdGF0dXMgPT09IFF1ZXJ5U3RhdHVzLnBlbmRpbmcpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZVRhZ3MobmV3VGFnczogcmVhZG9ubHkgRnVsbFRhZ0Rlc2NyaXB0aW9uPHN0cmluZz5bXSwgbXdBcGk6IFN1Yk1pZGRsZXdhcmVBcGkpIHtcbiAgICBjb25zdCByb290U3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHN0YXRlID0gcm9vdFN0YXRlW3JlZHVjZXJQYXRoXTtcbiAgICBwZW5kaW5nVGFnSW52YWxpZGF0aW9ucy5wdXNoKC4uLm5ld1RhZ3MpO1xuICAgIGlmIChzdGF0ZS5jb25maWcuaW52YWxpZGF0aW9uQmVoYXZpb3IgPT09ICdkZWxheWVkJyAmJiBoYXNQZW5kaW5nUmVxdWVzdHMoc3RhdGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhZ3MgPSBwZW5kaW5nVGFnSW52YWxpZGF0aW9ucztcbiAgICBwZW5kaW5nVGFnSW52YWxpZGF0aW9ucyA9IFtdO1xuICAgIGlmICh0YWdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IHRvSW52YWxpZGF0ZSA9IGFwaS51dGlsLnNlbGVjdEludmFsaWRhdGVkQnkocm9vdFN0YXRlLCB0YWdzKTtcbiAgICBjb250ZXh0LmJhdGNoKCgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlc0FycmF5ID0gQXJyYXkuZnJvbSh0b0ludmFsaWRhdGUudmFsdWVzKCkpO1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgIH0gb2YgdmFsdWVzQXJyYXkpIHtcbiAgICAgICAgY29uc3QgcXVlcnlTdWJTdGF0ZSA9IHN0YXRlLnF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvblN1YlN0YXRlID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9uc1txdWVyeUNhY2hlS2V5XSA/PyB7fTtcbiAgICAgICAgaWYgKHF1ZXJ5U3ViU3RhdGUpIHtcbiAgICAgICAgICBpZiAoY291bnRPYmplY3RLZXlzKHN1YnNjcmlwdGlvblN1YlN0YXRlKSA9PT0gMCkge1xuICAgICAgICAgICAgbXdBcGkuZGlzcGF0Y2gocmVtb3ZlUXVlcnlSZXN1bHQoe1xuICAgICAgICAgICAgICBxdWVyeUNhY2hlS2V5OiBxdWVyeUNhY2hlS2V5IGFzIFF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHF1ZXJ5U3ViU3RhdGUuc3RhdHVzICE9PSBRdWVyeVN0YXR1cy51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBtd0FwaS5kaXNwYXRjaChyZWZldGNoUXVlcnkocXVlcnlTdWJTdGF0ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBoYW5kbGVyO1xufTsiLCJpbXBvcnQgdHlwZSB7IFF1ZXJ5Q2FjaGVLZXksIFF1ZXJ5U3Vic3RhdGVJZGVudGlmaWVyLCBTdWJzY3JpYmVycyB9IGZyb20gJy4uL2FwaVN0YXRlJztcbmltcG9ydCB7IFF1ZXJ5U3RhdHVzIH0gZnJvbSAnLi4vYXBpU3RhdGUnO1xuaW1wb3J0IHR5cGUgeyBRdWVyeVN0YXRlTWV0YSwgU3ViTWlkZGxld2FyZUFwaSwgVGltZW91dElkLCBJbnRlcm5hbEhhbmRsZXJCdWlsZGVyLCBBcGlNaWRkbGV3YXJlSW50ZXJuYWxIYW5kbGVyLCBJbnRlcm5hbE1pZGRsZXdhcmVTdGF0ZSB9IGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IGNvbnN0IGJ1aWxkUG9sbGluZ0hhbmRsZXI6IEludGVybmFsSGFuZGxlckJ1aWxkZXIgPSAoe1xuICByZWR1Y2VyUGF0aCxcbiAgcXVlcnlUaHVuayxcbiAgYXBpLFxuICByZWZldGNoUXVlcnksXG4gIGludGVybmFsU3RhdGVcbn0pID0+IHtcbiAgY29uc3QgY3VycmVudFBvbGxzOiBRdWVyeVN0YXRlTWV0YTx7XG4gICAgbmV4dFBvbGxUaW1lc3RhbXA6IG51bWJlcjtcbiAgICB0aW1lb3V0PzogVGltZW91dElkO1xuICAgIHBvbGxpbmdJbnRlcnZhbDogbnVtYmVyO1xuICB9PiA9IHt9O1xuICBjb25zdCBoYW5kbGVyOiBBcGlNaWRkbGV3YXJlSW50ZXJuYWxIYW5kbGVyID0gKGFjdGlvbiwgbXdBcGkpID0+IHtcbiAgICBpZiAoYXBpLmludGVybmFsQWN0aW9ucy51cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zLm1hdGNoKGFjdGlvbikgfHwgYXBpLmludGVybmFsQWN0aW9ucy51bnN1YnNjcmliZVF1ZXJ5UmVzdWx0Lm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHVwZGF0ZVBvbGxpbmdJbnRlcnZhbChhY3Rpb24ucGF5bG9hZCwgbXdBcGkpO1xuICAgIH1cbiAgICBpZiAocXVlcnlUaHVuay5wZW5kaW5nLm1hdGNoKGFjdGlvbikgfHwgcXVlcnlUaHVuay5yZWplY3RlZC5tYXRjaChhY3Rpb24pICYmIGFjdGlvbi5tZXRhLmNvbmRpdGlvbikge1xuICAgICAgdXBkYXRlUG9sbGluZ0ludGVydmFsKGFjdGlvbi5tZXRhLmFyZywgbXdBcGkpO1xuICAgIH1cbiAgICBpZiAocXVlcnlUaHVuay5mdWxmaWxsZWQubWF0Y2goYWN0aW9uKSB8fCBxdWVyeVRodW5rLnJlamVjdGVkLm1hdGNoKGFjdGlvbikgJiYgIWFjdGlvbi5tZXRhLmNvbmRpdGlvbikge1xuICAgICAgc3RhcnROZXh0UG9sbChhY3Rpb24ubWV0YS5hcmcsIG13QXBpKTtcbiAgICB9XG4gICAgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY2xlYXJQb2xscygpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZ2V0Q2FjaGVFbnRyeVN1YnNjcmlwdGlvbnMocXVlcnlDYWNoZUtleTogUXVlcnlDYWNoZUtleSwgYXBpOiBTdWJNaWRkbGV3YXJlQXBpKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBhcGkuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF07XG4gICAgY29uc3QgcXVlcnlTdWJTdGF0ZSA9IHN0YXRlLnF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnNbcXVlcnlDYWNoZUtleV07XG4gICAgaWYgKCFxdWVyeVN1YlN0YXRlIHx8IHF1ZXJ5U3ViU3RhdGUuc3RhdHVzID09PSBRdWVyeVN0YXR1cy51bmluaXRpYWxpemVkKSByZXR1cm47XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnROZXh0UG9sbCh7XG4gICAgcXVlcnlDYWNoZUtleVxuICB9OiBRdWVyeVN1YnN0YXRlSWRlbnRpZmllciwgYXBpOiBTdWJNaWRkbGV3YXJlQXBpKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBhcGkuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF07XG4gICAgY29uc3QgcXVlcnlTdWJTdGF0ZSA9IHN0YXRlLnF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnNbcXVlcnlDYWNoZUtleV07XG4gICAgaWYgKCFxdWVyeVN1YlN0YXRlIHx8IHF1ZXJ5U3ViU3RhdGUuc3RhdHVzID09PSBRdWVyeVN0YXR1cy51bmluaXRpYWxpemVkKSByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgbG93ZXN0UG9sbGluZ0ludGVydmFsLFxuICAgICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZFxuICAgIH0gPSBmaW5kTG93ZXN0UG9sbGluZ0ludGVydmFsKHN1YnNjcmlwdGlvbnMpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGxvd2VzdFBvbGxpbmdJbnRlcnZhbCkpIHJldHVybjtcbiAgICBjb25zdCBjdXJyZW50UG9sbCA9IGN1cnJlbnRQb2xsc1txdWVyeUNhY2hlS2V5XTtcbiAgICBpZiAoY3VycmVudFBvbGw/LnRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChjdXJyZW50UG9sbC50aW1lb3V0KTtcbiAgICAgIGN1cnJlbnRQb2xsLnRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IG5leHRQb2xsVGltZXN0YW1wID0gRGF0ZS5ub3coKSArIGxvd2VzdFBvbGxpbmdJbnRlcnZhbDtcbiAgICBjdXJyZW50UG9sbHNbcXVlcnlDYWNoZUtleV0gPSB7XG4gICAgICBuZXh0UG9sbFRpbWVzdGFtcCxcbiAgICAgIHBvbGxpbmdJbnRlcnZhbDogbG93ZXN0UG9sbGluZ0ludGVydmFsLFxuICAgICAgdGltZW91dDogc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5jb25maWcuZm9jdXNlZCB8fCAhc2tpcFBvbGxpbmdJZlVuZm9jdXNlZCkge1xuICAgICAgICAgIGFwaS5kaXNwYXRjaChyZWZldGNoUXVlcnkocXVlcnlTdWJTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0TmV4dFBvbGwoe1xuICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgfSwgYXBpKTtcbiAgICAgIH0sIGxvd2VzdFBvbGxpbmdJbnRlcnZhbClcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVBvbGxpbmdJbnRlcnZhbCh7XG4gICAgcXVlcnlDYWNoZUtleVxuICB9OiBRdWVyeVN1YnN0YXRlSWRlbnRpZmllciwgYXBpOiBTdWJNaWRkbGV3YXJlQXBpKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBhcGkuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF07XG4gICAgY29uc3QgcXVlcnlTdWJTdGF0ZSA9IHN0YXRlLnF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnNbcXVlcnlDYWNoZUtleV07XG4gICAgaWYgKCFxdWVyeVN1YlN0YXRlIHx8IHF1ZXJ5U3ViU3RhdGUuc3RhdHVzID09PSBRdWVyeVN0YXR1cy51bmluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxvd2VzdFBvbGxpbmdJbnRlcnZhbFxuICAgIH0gPSBmaW5kTG93ZXN0UG9sbGluZ0ludGVydmFsKHN1YnNjcmlwdGlvbnMpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGxvd2VzdFBvbGxpbmdJbnRlcnZhbCkpIHtcbiAgICAgIGNsZWFudXBQb2xsRm9yS2V5KHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50UG9sbCA9IGN1cnJlbnRQb2xsc1txdWVyeUNhY2hlS2V5XTtcbiAgICBjb25zdCBuZXh0UG9sbFRpbWVzdGFtcCA9IERhdGUubm93KCkgKyBsb3dlc3RQb2xsaW5nSW50ZXJ2YWw7XG4gICAgaWYgKCFjdXJyZW50UG9sbCB8fCBuZXh0UG9sbFRpbWVzdGFtcCA8IGN1cnJlbnRQb2xsLm5leHRQb2xsVGltZXN0YW1wKSB7XG4gICAgICBzdGFydE5leHRQb2xsKHtcbiAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgfSwgYXBpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2xlYW51cFBvbGxGb3JLZXkoa2V5OiBzdHJpbmcpIHtcbiAgICBjb25zdCBleGlzdGluZ1BvbGwgPSBjdXJyZW50UG9sbHNba2V5XTtcbiAgICBpZiAoZXhpc3RpbmdQb2xsPy50aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoZXhpc3RpbmdQb2xsLnRpbWVvdXQpO1xuICAgIH1cbiAgICBkZWxldGUgY3VycmVudFBvbGxzW2tleV07XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXJQb2xscygpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjdXJyZW50UG9sbHMpKSB7XG4gICAgICBjbGVhbnVwUG9sbEZvcktleShrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmaW5kTG93ZXN0UG9sbGluZ0ludGVydmFsKHN1YnNjcmliZXJzOiBTdWJzY3JpYmVycyA9IHt9KSB7XG4gICAgbGV0IHNraXBQb2xsaW5nSWZVbmZvY3VzZWQ6IGJvb2xlYW4gfCB1bmRlZmluZWQgPSBmYWxzZTtcbiAgICBsZXQgbG93ZXN0UG9sbGluZ0ludGVydmFsID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGZvciAobGV0IGtleSBpbiBzdWJzY3JpYmVycykge1xuICAgICAgaWYgKCEhc3Vic2NyaWJlcnNba2V5XS5wb2xsaW5nSW50ZXJ2YWwpIHtcbiAgICAgICAgbG93ZXN0UG9sbGluZ0ludGVydmFsID0gTWF0aC5taW4oc3Vic2NyaWJlcnNba2V5XS5wb2xsaW5nSW50ZXJ2YWwhLCBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICBza2lwUG9sbGluZ0lmVW5mb2N1c2VkID0gc3Vic2NyaWJlcnNba2V5XS5za2lwUG9sbGluZ0lmVW5mb2N1c2VkIHx8IHNraXBQb2xsaW5nSWZVbmZvY3VzZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwsXG4gICAgICBza2lwUG9sbGluZ0lmVW5mb2N1c2VkXG4gICAgfTtcbiAgfVxuICByZXR1cm4gaGFuZGxlcjtcbn07IiwiaW1wb3J0IHR5cGUgeyBCYXNlUXVlcnlFcnJvciwgQmFzZVF1ZXJ5Rm4sIEJhc2VRdWVyeU1ldGEgfSBmcm9tICcuLi8uLi9iYXNlUXVlcnlUeXBlcyc7XG5pbXBvcnQgeyBEZWZpbml0aW9uVHlwZSwgaXNBbnlRdWVyeURlZmluaXRpb24gfSBmcm9tICcuLi8uLi9lbmRwb2ludERlZmluaXRpb25zJztcbmltcG9ydCB0eXBlIHsgUmVjaXBlIH0gZnJvbSAnLi4vYnVpbGRUaHVua3MnO1xuaW1wb3J0IHsgaXNGdWxmaWxsZWQsIGlzUGVuZGluZywgaXNSZWplY3RlZCB9IGZyb20gJy4uL3J0a0ltcG9ydHMnO1xuaW1wb3J0IHR5cGUgeyBNdXRhdGlvbkJhc2VMaWZlY3ljbGVBcGksIFF1ZXJ5QmFzZUxpZmVjeWNsZUFwaSB9IGZyb20gJy4vY2FjaGVMaWZlY3ljbGUnO1xuaW1wb3J0IHR5cGUgeyBBcGlNaWRkbGV3YXJlSW50ZXJuYWxIYW5kbGVyLCBJbnRlcm5hbEhhbmRsZXJCdWlsZGVyLCBQcm9taXNlQ29uc3RydWN0b3JXaXRoS25vd25SZWFzb24sIFByb21pc2VXaXRoS25vd25SZWFzb24gfSBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCB0eXBlIFJlZmVyZW5jZVF1ZXJ5TGlmZWN5Y2xlID0gbmV2ZXI7XG50eXBlIFF1ZXJ5TGlmZWN5Y2xlUHJvbWlzZXM8UmVzdWx0VHlwZSwgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4+ID0ge1xuICAvKipcbiAgICogUHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aXRoIHRoZSAodHJhbnNmb3JtZWQpIHF1ZXJ5IHJlc3VsdC5cbiAgICpcbiAgICogSWYgdGhlIHF1ZXJ5IGZhaWxzLCB0aGlzIHByb21pc2Ugd2lsbCByZWplY3Qgd2l0aCB0aGUgZXJyb3IuXG4gICAqXG4gICAqIFRoaXMgYWxsb3dzIHlvdSB0byBgYXdhaXRgIGZvciB0aGUgcXVlcnkgdG8gZmluaXNoLlxuICAgKlxuICAgKiBJZiB5b3UgZG9uJ3QgaW50ZXJhY3Qgd2l0aCB0aGlzIHByb21pc2UsIGl0IHdpbGwgbm90IHRocm93LlxuICAgKi9cbiAgcXVlcnlGdWxmaWxsZWQ6IFByb21pc2VXaXRoS25vd25SZWFzb248e1xuICAgIC8qKlxuICAgICAqIFRoZSAodHJhbnNmb3JtZWQpIHF1ZXJ5IHJlc3VsdC5cbiAgICAgKi9cbiAgICBkYXRhOiBSZXN1bHRUeXBlO1xuICAgIC8qKlxuICAgICAqIFRoZSBgbWV0YWAgcmV0dXJuZWQgYnkgdGhlIGBiYXNlUXVlcnlgXG4gICAgICovXG4gICAgbWV0YTogQmFzZVF1ZXJ5TWV0YTxCYXNlUXVlcnk+O1xuICB9LCBRdWVyeUZ1bGZpbGxlZFJlamVjdGlvblJlYXNvbjxCYXNlUXVlcnk+Pjtcbn07XG50eXBlIFF1ZXJ5RnVsZmlsbGVkUmVqZWN0aW9uUmVhc29uPEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuPiA9IHtcbiAgZXJyb3I6IEJhc2VRdWVyeUVycm9yPEJhc2VRdWVyeT47XG4gIC8qKlxuICAgKiBJZiB0aGlzIGlzIGBmYWxzZWAsIHRoYXQgbWVhbnMgdGhpcyBlcnJvciB3YXMgcmV0dXJuZWQgZnJvbSB0aGUgYGJhc2VRdWVyeWAgb3IgYHF1ZXJ5Rm5gIGluIGEgY29udHJvbGxlZCBtYW5uZXIuXG4gICAqL1xuICBpc1VuaGFuZGxlZEVycm9yOiBmYWxzZTtcbiAgLyoqXG4gICAqIFRoZSBgbWV0YWAgcmV0dXJuZWQgYnkgdGhlIGBiYXNlUXVlcnlgXG4gICAqL1xuICBtZXRhOiBCYXNlUXVlcnlNZXRhPEJhc2VRdWVyeT47XG59IHwge1xuICBlcnJvcjogdW5rbm93bjtcbiAgbWV0YT86IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIElmIHRoaXMgaXMgYHRydWVgLCB0aGF0IG1lYW5zIHRoYXQgdGhpcyBlcnJvciBpcyB0aGUgcmVzdWx0IG9mIGBiYXNlUXVlcnlGbmAsIGBxdWVyeUZuYCwgYHRyYW5zZm9ybVJlc3BvbnNlYCBvciBgdHJhbnNmb3JtRXJyb3JSZXNwb25zZWAgdGhyb3dpbmcgYW4gZXJyb3IgaW5zdGVhZCBvZiBoYW5kbGluZyBpdCBwcm9wZXJseS5cbiAgICogVGhlcmUgY2FuIG5vdCBiZSBtYWRlIGFueSBhc3N1bXB0aW9uIGFib3V0IHRoZSBzaGFwZSBvZiBgZXJyb3JgLlxuICAgKi9cbiAgaXNVbmhhbmRsZWRFcnJvcjogdHJ1ZTtcbn07XG5leHBvcnQgdHlwZSBRdWVyeUxpZmVjeWNsZVF1ZXJ5RXh0cmFPcHRpb25zPFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgUmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+ID0ge1xuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBpbmRpdmlkdWFsIHF1ZXJ5IGlzIHN0YXJ0ZWQuIFRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhIGxpZmVjeWNsZSBhcGkgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBzdWNoIGFzIGBxdWVyeUZ1bGZpbGxlZGAsIGFsbG93aW5nIGNvZGUgdG8gYmUgcnVuIHdoZW4gYSBxdWVyeSBpcyBzdGFydGVkLCB3aGVuIGl0IHN1Y2NlZWRzLCBhbmQgd2hlbiBpdCBmYWlscyAoaS5lLiB0aHJvdWdob3V0IHRoZSBsaWZlY3ljbGUgb2YgYW4gaW5kaXZpZHVhbCBxdWVyeS9tdXRhdGlvbiBjYWxsKS5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBzaWRlLWVmZmVjdHMgdGhyb3VnaG91dCB0aGUgbGlmZWN5Y2xlIG9mIHRoZSBxdWVyeS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IHsgY3JlYXRlQXBpLCBmZXRjaEJhc2VRdWVyeSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnknXG4gICAqIGltcG9ydCB7IG1lc3NhZ2VDcmVhdGVkIH0gZnJvbSAnLi9ub3RpZmljYXRpb25zU2xpY2VcbiAgICogZXhwb3J0IGludGVyZmFjZSBQb3N0IHtcbiAgICogICBpZDogbnVtYmVyXG4gICAqICAgbmFtZTogc3RyaW5nXG4gICAqIH1cbiAgICpcbiAgICogY29uc3QgYXBpID0gY3JlYXRlQXBpKHtcbiAgICogICBiYXNlUXVlcnk6IGZldGNoQmFzZVF1ZXJ5KHtcbiAgICogICAgIGJhc2VVcmw6ICcvJyxcbiAgICogICB9KSxcbiAgICogICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAgICogICAgIGdldFBvc3Q6IGJ1aWxkLnF1ZXJ5PFBvc3QsIG51bWJlcj4oe1xuICAgKiAgICAgICBxdWVyeTogKGlkKSA9PiBgcG9zdC8ke2lkfWAsXG4gICAqICAgICAgIGFzeW5jIG9uUXVlcnlTdGFydGVkKGlkLCB7IGRpc3BhdGNoLCBxdWVyeUZ1bGZpbGxlZCB9KSB7XG4gICAqICAgICAgICAgLy8gYG9uU3RhcnRgIHNpZGUtZWZmZWN0XG4gICAqICAgICAgICAgZGlzcGF0Y2gobWVzc2FnZUNyZWF0ZWQoJ0ZldGNoaW5nIHBvc3RzLi4uJykpXG4gICAqICAgICAgICAgdHJ5IHtcbiAgICogICAgICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgcXVlcnlGdWxmaWxsZWRcbiAgICogICAgICAgICAgIC8vIGBvblN1Y2Nlc3NgIHNpZGUtZWZmZWN0XG4gICAqICAgICAgICAgICBkaXNwYXRjaChtZXNzYWdlQ3JlYXRlZCgnUG9zdHMgcmVjZWl2ZWQhJykpXG4gICAqICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAqICAgICAgICAgICAvLyBgb25FcnJvcmAgc2lkZS1lZmZlY3RcbiAgICogICAgICAgICAgIGRpc3BhdGNoKG1lc3NhZ2VDcmVhdGVkKCdFcnJvciBmZXRjaGluZyBwb3N0cyEnKSlcbiAgICogICAgICAgICB9XG4gICAqICAgICAgIH1cbiAgICogICAgIH0pLFxuICAgKiAgIH0pLFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIG9uUXVlcnlTdGFydGVkPyhxdWVyeUFyZ3VtZW50OiBRdWVyeUFyZywgcXVlcnlMaWZlQ3ljbGVBcGk6IFF1ZXJ5TGlmZWN5Y2xlQXBpPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoPik6IFByb21pc2U8dm9pZD4gfCB2b2lkO1xufTtcbmV4cG9ydCB0eXBlIFF1ZXJ5TGlmZWN5Y2xlSW5maW5pdGVRdWVyeUV4dHJhT3B0aW9uczxSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IFF1ZXJ5TGlmZWN5Y2xlUXVlcnlFeHRyYU9wdGlvbnM8UmVzdWx0VHlwZSwgUXVlcnlBcmcsIEJhc2VRdWVyeSwgUmVkdWNlclBhdGg+O1xuZXhwb3J0IHR5cGUgUXVlcnlMaWZlY3ljbGVNdXRhdGlvbkV4dHJhT3B0aW9uczxSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IHtcbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgaW5kaXZpZHVhbCBtdXRhdGlvbiBpcyBzdGFydGVkLiBUaGUgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYSBsaWZlY3ljbGUgYXBpIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgc3VjaCBhcyBgcXVlcnlGdWxmaWxsZWRgLCBhbGxvd2luZyBjb2RlIHRvIGJlIHJ1biB3aGVuIGEgcXVlcnkgaXMgc3RhcnRlZCwgd2hlbiBpdCBzdWNjZWVkcywgYW5kIHdoZW4gaXQgZmFpbHMgKGkuZS4gdGhyb3VnaG91dCB0aGUgbGlmZWN5Y2xlIG9mIGFuIGluZGl2aWR1YWwgcXVlcnkvbXV0YXRpb24gY2FsbCkuXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIGZvciBgb3B0aW1pc3RpYyB1cGRhdGVzYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IHsgY3JlYXRlQXBpLCBmZXRjaEJhc2VRdWVyeSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnknXG4gICAqIGV4cG9ydCBpbnRlcmZhY2UgUG9zdCB7XG4gICAqICAgaWQ6IG51bWJlclxuICAgKiAgIG5hbWU6IHN0cmluZ1xuICAgKiB9XG4gICAqXG4gICAqIGNvbnN0IGFwaSA9IGNyZWF0ZUFwaSh7XG4gICAqICAgYmFzZVF1ZXJ5OiBmZXRjaEJhc2VRdWVyeSh7XG4gICAqICAgICBiYXNlVXJsOiAnLycsXG4gICAqICAgfSksXG4gICAqICAgdGFnVHlwZXM6IFsnUG9zdCddLFxuICAgKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAgZ2V0UG9zdDogYnVpbGQucXVlcnk8UG9zdCwgbnVtYmVyPih7XG4gICAqICAgICAgIHF1ZXJ5OiAoaWQpID0+IGBwb3N0LyR7aWR9YCxcbiAgICogICAgICAgcHJvdmlkZXNUYWdzOiBbJ1Bvc3QnXSxcbiAgICogICAgIH0pLFxuICAgKiAgICAgdXBkYXRlUG9zdDogYnVpbGQubXV0YXRpb248dm9pZCwgUGljazxQb3N0LCAnaWQnPiAmIFBhcnRpYWw8UG9zdD4+KHtcbiAgICogICAgICAgcXVlcnk6ICh7IGlkLCAuLi5wYXRjaCB9KSA9PiAoe1xuICAgKiAgICAgICAgIHVybDogYHBvc3QvJHtpZH1gLFxuICAgKiAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICogICAgICAgICBib2R5OiBwYXRjaCxcbiAgICogICAgICAgfSksXG4gICAqICAgICAgIGludmFsaWRhdGVzVGFnczogWydQb3N0J10sXG4gICAqICAgICAgIGFzeW5jIG9uUXVlcnlTdGFydGVkKHsgaWQsIC4uLnBhdGNoIH0sIHsgZGlzcGF0Y2gsIHF1ZXJ5RnVsZmlsbGVkIH0pIHtcbiAgICogICAgICAgICBjb25zdCBwYXRjaFJlc3VsdCA9IGRpc3BhdGNoKFxuICAgKiAgICAgICAgICAgYXBpLnV0aWwudXBkYXRlUXVlcnlEYXRhKCdnZXRQb3N0JywgaWQsIChkcmFmdCkgPT4ge1xuICAgKiAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGRyYWZ0LCBwYXRjaClcbiAgICogICAgICAgICAgIH0pXG4gICAqICAgICAgICAgKVxuICAgKiAgICAgICAgIHRyeSB7XG4gICAqICAgICAgICAgICBhd2FpdCBxdWVyeUZ1bGZpbGxlZFxuICAgKiAgICAgICAgIH0gY2F0Y2gge1xuICAgKiAgICAgICAgICAgcGF0Y2hSZXN1bHQudW5kbygpXG4gICAqICAgICAgICAgfVxuICAgKiAgICAgICB9LFxuICAgKiAgICAgfSksXG4gICAqICAgfSksXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgb25RdWVyeVN0YXJ0ZWQ/KHF1ZXJ5QXJndW1lbnQ6IFF1ZXJ5QXJnLCBtdXRhdGlvbkxpZmVDeWNsZUFwaTogTXV0YXRpb25MaWZlY3ljbGVBcGk8UXVlcnlBcmcsIEJhc2VRdWVyeSwgUmVzdWx0VHlwZSwgUmVkdWNlclBhdGg+KTogUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG59O1xuZXhwb3J0IGludGVyZmFjZSBRdWVyeUxpZmVjeWNsZUFwaTxRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiBleHRlbmRzIFF1ZXJ5QmFzZUxpZmVjeWNsZUFwaTxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aD4sIFF1ZXJ5TGlmZWN5Y2xlUHJvbWlzZXM8UmVzdWx0VHlwZSwgQmFzZVF1ZXJ5PiB7fVxuZXhwb3J0IHR5cGUgTXV0YXRpb25MaWZlY3ljbGVBcGk8UXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gPSBNdXRhdGlvbkJhc2VMaWZlY3ljbGVBcGk8UXVlcnlBcmcsIEJhc2VRdWVyeSwgUmVzdWx0VHlwZSwgUmVkdWNlclBhdGg+ICYgUXVlcnlMaWZlY3ljbGVQcm9taXNlczxSZXN1bHRUeXBlLCBCYXNlUXVlcnk+O1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIGRlZmluZSBhIHN0cm9uZ2x5LXR5cGVkIHZlcnNpb24gb2ZcbiAqIHtAbGlua2NvZGUgUXVlcnlMaWZlY3ljbGVRdWVyeUV4dHJhT3B0aW9ucy5vblF1ZXJ5U3RhcnRlZCB8IG9uUXVlcnlTdGFydGVkfVxuICogZm9yIGEgc3BlY2lmaWMgcXVlcnkuXG4gKlxuICogQGV4YW1wbGVcbiAqIDxjYXB0aW9uPiMjIyMgX19DcmVhdGUgYW5kIHJldXNlIGEgc3Ryb25nbHktdHlwZWQgYG9uUXVlcnlTdGFydGVkYCBmdW5jdGlvbl9fPC9jYXB0aW9uPlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgdHlwZSB7IFR5cGVkUXVlcnlPblF1ZXJ5U3RhcnRlZCB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnknXG4gKiBpbXBvcnQgeyBjcmVhdGVBcGksIGZldGNoQmFzZVF1ZXJ5IH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeSdcbiAqXG4gKiB0eXBlIFBvc3QgPSB7XG4gKiAgIGlkOiBudW1iZXJcbiAqICAgdGl0bGU6IHN0cmluZ1xuICogICB1c2VySWQ6IG51bWJlclxuICogfVxuICpcbiAqIHR5cGUgUG9zdHNBcGlSZXNwb25zZSA9IHtcbiAqICAgcG9zdHM6IFBvc3RbXVxuICogICB0b3RhbDogbnVtYmVyXG4gKiAgIHNraXA6IG51bWJlclxuICogICBsaW1pdDogbnVtYmVyXG4gKiB9XG4gKlxuICogdHlwZSBRdWVyeUFyZ3VtZW50ID0gbnVtYmVyIHwgdW5kZWZpbmVkXG4gKlxuICogdHlwZSBCYXNlUXVlcnlGdW5jdGlvbiA9IFJldHVyblR5cGU8dHlwZW9mIGZldGNoQmFzZVF1ZXJ5PlxuICpcbiAqIGNvbnN0IGJhc2VBcGlTbGljZSA9IGNyZWF0ZUFwaSh7XG4gKiAgIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnaHR0cHM6Ly9kdW1teWpzb24uY29tJyB9KSxcbiAqICAgcmVkdWNlclBhdGg6ICdwb3N0c0FwaScsXG4gKiAgIHRhZ1R5cGVzOiBbJ1Bvc3RzJ10sXG4gKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICogICAgIGdldFBvc3RzOiBidWlsZC5xdWVyeTxQb3N0c0FwaVJlc3BvbnNlLCB2b2lkPih7XG4gKiAgICAgICBxdWVyeTogKCkgPT4gYC9wb3N0c2AsXG4gKiAgICAgfSksXG4gKlxuICogICAgIGdldFBvc3RCeUlkOiBidWlsZC5xdWVyeTxQb3N0LCBRdWVyeUFyZ3VtZW50Pih7XG4gKiAgICAgICBxdWVyeTogKHBvc3RJZCkgPT4gYC9wb3N0cy8ke3Bvc3RJZH1gLFxuICogICAgIH0pLFxuICogICB9KSxcbiAqIH0pXG4gKlxuICogY29uc3QgdXBkYXRlUG9zdE9uRnVsZmlsbGVkOiBUeXBlZFF1ZXJ5T25RdWVyeVN0YXJ0ZWQ8XG4gKiAgIFBvc3RzQXBpUmVzcG9uc2UsXG4gKiAgIFF1ZXJ5QXJndW1lbnQsXG4gKiAgIEJhc2VRdWVyeUZ1bmN0aW9uLFxuICogICAncG9zdHNBcGknXG4gKiA+ID0gYXN5bmMgKHF1ZXJ5QXJndW1lbnQsIHsgZGlzcGF0Y2gsIHF1ZXJ5RnVsZmlsbGVkIH0pID0+IHtcbiAqICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnlGdWxmaWxsZWRcbiAqXG4gKiAgIGNvbnN0IHsgcG9zdHMgfSA9IHJlc3VsdC5kYXRhXG4gKlxuICogICAvLyBQcmUtZmlsbCB0aGUgaW5kaXZpZHVhbCBwb3N0IGVudHJpZXMgd2l0aCB0aGUgcmVzdWx0c1xuICogICAvLyBmcm9tIHRoZSBsaXN0IGVuZHBvaW50IHF1ZXJ5XG4gKiAgIGRpc3BhdGNoKFxuICogICAgIGJhc2VBcGlTbGljZS51dGlsLnVwc2VydFF1ZXJ5RW50cmllcyhcbiAqICAgICAgIHBvc3RzLm1hcCgocG9zdCkgPT4gKHtcbiAqICAgICAgICAgZW5kcG9pbnROYW1lOiAnZ2V0UG9zdEJ5SWQnLFxuICogICAgICAgICBhcmc6IHBvc3QuaWQsXG4gKiAgICAgICAgIHZhbHVlOiBwb3N0LFxuICogICAgICAgfSkpLFxuICogICAgICksXG4gKiAgIClcbiAqIH1cbiAqXG4gKiBleHBvcnQgY29uc3QgZXh0ZW5kZWRBcGlTbGljZSA9IGJhc2VBcGlTbGljZS5pbmplY3RFbmRwb2ludHMoe1xuICogICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAqICAgICBnZXRQb3N0c0J5VXNlcklkOiBidWlsZC5xdWVyeTxQb3N0c0FwaVJlc3BvbnNlLCBRdWVyeUFyZ3VtZW50Pih7XG4gKiAgICAgICBxdWVyeTogKHVzZXJJZCkgPT4gYC9wb3N0cy91c2VyLyR7dXNlcklkfWAsXG4gKlxuICogICAgICAgb25RdWVyeVN0YXJ0ZWQ6IHVwZGF0ZVBvc3RPbkZ1bGZpbGxlZCxcbiAqICAgICB9KSxcbiAqICAgfSksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHRlbXBsYXRlIFJlc3VsdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcmVzdWx0IGBkYXRhYCByZXR1cm5lZCBieSB0aGUgcXVlcnkuXG4gKiBAdGVtcGxhdGUgUXVlcnlBcmd1bWVudFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgYXJndW1lbnQgcGFzc2VkIGludG8gdGhlIHF1ZXJ5LlxuICogQHRlbXBsYXRlIEJhc2VRdWVyeUZ1bmN0aW9uVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBiYXNlIHF1ZXJ5IGZ1bmN0aW9uIGJlaW5nIHVzZWQuXG4gKiBAdGVtcGxhdGUgUmVkdWNlclBhdGggLSBUaGUgdHlwZSByZXByZXNlbnRpbmcgdGhlIGByZWR1Y2VyUGF0aGAgZm9yIHRoZSBBUEkgc2xpY2UuXG4gKlxuICogQHNpbmNlIDIuNC4wXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFR5cGVkUXVlcnlPblF1ZXJ5U3RhcnRlZDxSZXN1bHRUeXBlLCBRdWVyeUFyZ3VtZW50VHlwZSwgQmFzZVF1ZXJ5RnVuY3Rpb25UeXBlIGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IFF1ZXJ5TGlmZWN5Y2xlUXVlcnlFeHRyYU9wdGlvbnM8UmVzdWx0VHlwZSwgUXVlcnlBcmd1bWVudFR5cGUsIEJhc2VRdWVyeUZ1bmN0aW9uVHlwZSwgUmVkdWNlclBhdGg+WydvblF1ZXJ5U3RhcnRlZCddO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIGRlZmluZSBhIHN0cm9uZ2x5LXR5cGVkIHZlcnNpb24gb2ZcbiAqIHtAbGlua2NvZGUgUXVlcnlMaWZlY3ljbGVNdXRhdGlvbkV4dHJhT3B0aW9ucy5vblF1ZXJ5U3RhcnRlZCB8IG9uUXVlcnlTdGFydGVkfVxuICogZm9yIGEgc3BlY2lmaWMgbXV0YXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIDxjYXB0aW9uPiMjIyMgX19DcmVhdGUgYW5kIHJldXNlIGEgc3Ryb25nbHktdHlwZWQgYG9uUXVlcnlTdGFydGVkYCBmdW5jdGlvbl9fPC9jYXB0aW9uPlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgdHlwZSB7IFR5cGVkTXV0YXRpb25PblF1ZXJ5U3RhcnRlZCB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnknXG4gKiBpbXBvcnQgeyBjcmVhdGVBcGksIGZldGNoQmFzZVF1ZXJ5IH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeSdcbiAqXG4gKiB0eXBlIFBvc3QgPSB7XG4gKiAgIGlkOiBudW1iZXJcbiAqICAgdGl0bGU6IHN0cmluZ1xuICogICB1c2VySWQ6IG51bWJlclxuICogfVxuICpcbiAqIHR5cGUgUG9zdHNBcGlSZXNwb25zZSA9IHtcbiAqICAgcG9zdHM6IFBvc3RbXVxuICogICB0b3RhbDogbnVtYmVyXG4gKiAgIHNraXA6IG51bWJlclxuICogICBsaW1pdDogbnVtYmVyXG4gKiB9XG4gKlxuICogdHlwZSBRdWVyeUFyZ3VtZW50ID0gUGljazxQb3N0LCAnaWQnPiAmIFBhcnRpYWw8UG9zdD5cbiAqXG4gKiB0eXBlIEJhc2VRdWVyeUZ1bmN0aW9uID0gUmV0dXJuVHlwZTx0eXBlb2YgZmV0Y2hCYXNlUXVlcnk+XG4gKlxuICogY29uc3QgYmFzZUFwaVNsaWNlID0gY3JlYXRlQXBpKHtcbiAqICAgYmFzZVF1ZXJ5OiBmZXRjaEJhc2VRdWVyeSh7IGJhc2VVcmw6ICdodHRwczovL2R1bW15anNvbi5jb20nIH0pLFxuICogICByZWR1Y2VyUGF0aDogJ3Bvc3RzQXBpJyxcbiAqICAgdGFnVHlwZXM6IFsnUG9zdHMnXSxcbiAqICAgZW5kcG9pbnRzOiAoYnVpbGQpID0+ICh7XG4gKiAgICAgZ2V0UG9zdHM6IGJ1aWxkLnF1ZXJ5PFBvc3RzQXBpUmVzcG9uc2UsIHZvaWQ+KHtcbiAqICAgICAgIHF1ZXJ5OiAoKSA9PiBgL3Bvc3RzYCxcbiAqICAgICB9KSxcbiAqXG4gKiAgICAgZ2V0UG9zdEJ5SWQ6IGJ1aWxkLnF1ZXJ5PFBvc3QsIG51bWJlcj4oe1xuICogICAgICAgcXVlcnk6IChwb3N0SWQpID0+IGAvcG9zdHMvJHtwb3N0SWR9YCxcbiAqICAgICB9KSxcbiAqICAgfSksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHVwZGF0ZVBvc3RPbkZ1bGZpbGxlZDogVHlwZWRNdXRhdGlvbk9uUXVlcnlTdGFydGVkPFxuICogICBQb3N0LFxuICogICBRdWVyeUFyZ3VtZW50LFxuICogICBCYXNlUXVlcnlGdW5jdGlvbixcbiAqICAgJ3Bvc3RzQXBpJ1xuICogPiA9IGFzeW5jICh7IGlkLCAuLi5wYXRjaCB9LCB7IGRpc3BhdGNoLCBxdWVyeUZ1bGZpbGxlZCB9KSA9PiB7XG4gKiAgIGNvbnN0IHBhdGNoQ29sbGVjdGlvbiA9IGRpc3BhdGNoKFxuICogICAgIGJhc2VBcGlTbGljZS51dGlsLnVwZGF0ZVF1ZXJ5RGF0YSgnZ2V0UG9zdEJ5SWQnLCBpZCwgKGRyYWZ0UG9zdCkgPT4ge1xuICogICAgICAgT2JqZWN0LmFzc2lnbihkcmFmdFBvc3QsIHBhdGNoKVxuICogICAgIH0pLFxuICogICApXG4gKlxuICogICB0cnkge1xuICogICAgIGF3YWl0IHF1ZXJ5RnVsZmlsbGVkXG4gKiAgIH0gY2F0Y2gge1xuICogICAgIHBhdGNoQ29sbGVjdGlvbi51bmRvKClcbiAqICAgfVxuICogfVxuICpcbiAqIGV4cG9ydCBjb25zdCBleHRlbmRlZEFwaVNsaWNlID0gYmFzZUFwaVNsaWNlLmluamVjdEVuZHBvaW50cyh7XG4gKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICogICAgIGFkZFBvc3Q6IGJ1aWxkLm11dGF0aW9uPFBvc3QsIE9taXQ8UXVlcnlBcmd1bWVudCwgJ2lkJz4+KHtcbiAqICAgICAgIHF1ZXJ5OiAoYm9keSkgPT4gKHtcbiAqICAgICAgICAgdXJsOiBgcG9zdHMvYWRkYCxcbiAqICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gKiAgICAgICAgIGJvZHksXG4gKiAgICAgICB9KSxcbiAqXG4gKiAgICAgICBvblF1ZXJ5U3RhcnRlZDogdXBkYXRlUG9zdE9uRnVsZmlsbGVkLFxuICogICAgIH0pLFxuICpcbiAqICAgICB1cGRhdGVQb3N0OiBidWlsZC5tdXRhdGlvbjxQb3N0LCBRdWVyeUFyZ3VtZW50Pih7XG4gKiAgICAgICBxdWVyeTogKHsgaWQsIC4uLnBhdGNoIH0pID0+ICh7XG4gKiAgICAgICAgIHVybDogYHBvc3QvJHtpZH1gLFxuICogICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gKiAgICAgICAgIGJvZHk6IHBhdGNoLFxuICogICAgICAgfSksXG4gKlxuICogICAgICAgb25RdWVyeVN0YXJ0ZWQ6IHVwZGF0ZVBvc3RPbkZ1bGZpbGxlZCxcbiAqICAgICB9KSxcbiAqICAgfSksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHRlbXBsYXRlIFJlc3VsdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgcmVzdWx0IGBkYXRhYCByZXR1cm5lZCBieSB0aGUgcXVlcnkuXG4gKiBAdGVtcGxhdGUgUXVlcnlBcmd1bWVudFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgYXJndW1lbnQgcGFzc2VkIGludG8gdGhlIHF1ZXJ5LlxuICogQHRlbXBsYXRlIEJhc2VRdWVyeUZ1bmN0aW9uVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBiYXNlIHF1ZXJ5IGZ1bmN0aW9uIGJlaW5nIHVzZWQuXG4gKiBAdGVtcGxhdGUgUmVkdWNlclBhdGggLSBUaGUgdHlwZSByZXByZXNlbnRpbmcgdGhlIGByZWR1Y2VyUGF0aGAgZm9yIHRoZSBBUEkgc2xpY2UuXG4gKlxuICogQHNpbmNlIDIuNC4wXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFR5cGVkTXV0YXRpb25PblF1ZXJ5U3RhcnRlZDxSZXN1bHRUeXBlLCBRdWVyeUFyZ3VtZW50VHlwZSwgQmFzZVF1ZXJ5RnVuY3Rpb25UeXBlIGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IFF1ZXJ5TGlmZWN5Y2xlTXV0YXRpb25FeHRyYU9wdGlvbnM8UmVzdWx0VHlwZSwgUXVlcnlBcmd1bWVudFR5cGUsIEJhc2VRdWVyeUZ1bmN0aW9uVHlwZSwgUmVkdWNlclBhdGg+WydvblF1ZXJ5U3RhcnRlZCddO1xuZXhwb3J0IGNvbnN0IGJ1aWxkUXVlcnlMaWZlY3ljbGVIYW5kbGVyOiBJbnRlcm5hbEhhbmRsZXJCdWlsZGVyID0gKHtcbiAgYXBpLFxuICBjb250ZXh0LFxuICBxdWVyeVRodW5rLFxuICBtdXRhdGlvblRodW5rXG59KSA9PiB7XG4gIGNvbnN0IGlzUGVuZGluZ1RodW5rID0gaXNQZW5kaW5nKHF1ZXJ5VGh1bmssIG11dGF0aW9uVGh1bmspO1xuICBjb25zdCBpc1JlamVjdGVkVGh1bmsgPSBpc1JlamVjdGVkKHF1ZXJ5VGh1bmssIG11dGF0aW9uVGh1bmspO1xuICBjb25zdCBpc0Z1bGxmaWxsZWRUaHVuayA9IGlzRnVsZmlsbGVkKHF1ZXJ5VGh1bmssIG11dGF0aW9uVGh1bmspO1xuICB0eXBlIENhY2hlTGlmZWN5Y2xlID0ge1xuICAgIHJlc29sdmUodmFsdWU6IHtcbiAgICAgIGRhdGE6IHVua25vd247XG4gICAgICBtZXRhOiB1bmtub3duO1xuICAgIH0pOiB1bmtub3duO1xuICAgIHJlamVjdCh2YWx1ZTogUXVlcnlGdWxmaWxsZWRSZWplY3Rpb25SZWFzb248YW55Pik6IHVua25vd247XG4gIH07XG4gIGNvbnN0IGxpZmVjeWNsZU1hcDogUmVjb3JkPHN0cmluZywgQ2FjaGVMaWZlY3ljbGU+ID0ge307XG4gIGNvbnN0IGhhbmRsZXI6IEFwaU1pZGRsZXdhcmVJbnRlcm5hbEhhbmRsZXIgPSAoYWN0aW9uLCBtd0FwaSkgPT4ge1xuICAgIGlmIChpc1BlbmRpbmdUaHVuayhhY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgYXJnOiB7XG4gICAgICAgICAgZW5kcG9pbnROYW1lLFxuICAgICAgICAgIG9yaWdpbmFsQXJnc1xuICAgICAgICB9XG4gICAgICB9ID0gYWN0aW9uLm1ldGE7XG4gICAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXTtcbiAgICAgIGNvbnN0IG9uUXVlcnlTdGFydGVkID0gZW5kcG9pbnREZWZpbml0aW9uPy5vblF1ZXJ5U3RhcnRlZDtcbiAgICAgIGlmIChvblF1ZXJ5U3RhcnRlZCkge1xuICAgICAgICBjb25zdCBsaWZlY3ljbGUgPSB7fSBhcyBDYWNoZUxpZmVjeWNsZTtcbiAgICAgICAgY29uc3QgcXVlcnlGdWxmaWxsZWQgPSBuZXcgKFByb21pc2UgYXMgUHJvbWlzZUNvbnN0cnVjdG9yV2l0aEtub3duUmVhc29uKTx7XG4gICAgICAgICAgZGF0YTogdW5rbm93bjtcbiAgICAgICAgICBtZXRhOiB1bmtub3duO1xuICAgICAgICB9LCBRdWVyeUZ1bGZpbGxlZFJlamVjdGlvblJlYXNvbjxhbnk+PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgbGlmZWN5Y2xlLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgIGxpZmVjeWNsZS5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBwcmV2ZW50IHVuY2F1Z2h0IHByb21pc2UgcmVqZWN0aW9ucyBmcm9tIGhhcHBlbmluZy5cbiAgICAgICAgLy8gaWYgdGhlIG9yaWdpbmFsIHByb21pc2UgaXMgdXNlZCBpbiBhbnkgd2F5LCB0aGF0IHdpbGwgY3JlYXRlIGEgbmV3IHByb21pc2UgdGhhdCB3aWxsIHRocm93IGFnYWluXG4gICAgICAgIHF1ZXJ5RnVsZmlsbGVkLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgICAgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF0gPSBsaWZlY3ljbGU7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSBhcyBhbnkpLnNlbGVjdChpc0FueVF1ZXJ5RGVmaW5pdGlvbihlbmRwb2ludERlZmluaXRpb24pID8gb3JpZ2luYWxBcmdzIDogcmVxdWVzdElkKTtcbiAgICAgICAgY29uc3QgZXh0cmEgPSBtd0FwaS5kaXNwYXRjaCgoXywgX18sIGV4dHJhKSA9PiBleHRyYSk7XG4gICAgICAgIGNvbnN0IGxpZmVjeWNsZUFwaSA9IHtcbiAgICAgICAgICAuLi5td0FwaSxcbiAgICAgICAgICBnZXRDYWNoZUVudHJ5OiAoKSA9PiBzZWxlY3Rvcihtd0FwaS5nZXRTdGF0ZSgpKSxcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgdXBkYXRlQ2FjaGVkRGF0YTogKGlzQW55UXVlcnlEZWZpbml0aW9uKGVuZHBvaW50RGVmaW5pdGlvbikgPyAodXBkYXRlUmVjaXBlOiBSZWNpcGU8YW55PikgPT4gbXdBcGkuZGlzcGF0Y2goYXBpLnV0aWwudXBkYXRlUXVlcnlEYXRhKGVuZHBvaW50TmFtZSBhcyBuZXZlciwgb3JpZ2luYWxBcmdzIGFzIG5ldmVyLCB1cGRhdGVSZWNpcGUpKSA6IHVuZGVmaW5lZCkgYXMgYW55LFxuICAgICAgICAgIHF1ZXJ5RnVsZmlsbGVkXG4gICAgICAgIH07XG4gICAgICAgIG9uUXVlcnlTdGFydGVkKG9yaWdpbmFsQXJncywgbGlmZWN5Y2xlQXBpIGFzIGFueSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0Z1bGxmaWxsZWRUaHVuayhhY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgYmFzZVF1ZXJ5TWV0YVxuICAgICAgfSA9IGFjdGlvbi5tZXRhO1xuICAgICAgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF0/LnJlc29sdmUoe1xuICAgICAgICBkYXRhOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgbWV0YTogYmFzZVF1ZXJ5TWV0YVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF07XG4gICAgfSBlbHNlIGlmIChpc1JlamVjdGVkVGh1bmsoYWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJlamVjdGVkV2l0aFZhbHVlLFxuICAgICAgICBiYXNlUXVlcnlNZXRhXG4gICAgICB9ID0gYWN0aW9uLm1ldGE7XG4gICAgICBsaWZlY3ljbGVNYXBbcmVxdWVzdElkXT8ucmVqZWN0KHtcbiAgICAgICAgZXJyb3I6IGFjdGlvbi5wYXlsb2FkID8/IGFjdGlvbi5lcnJvcixcbiAgICAgICAgaXNVbmhhbmRsZWRFcnJvcjogIXJlamVjdGVkV2l0aFZhbHVlLFxuICAgICAgICBtZXRhOiBiYXNlUXVlcnlNZXRhIGFzIGFueVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGFuZGxlcjtcbn07IiwiaW1wb3J0IHsgUXVlcnlTdGF0dXMgfSBmcm9tICcuLi9hcGlTdGF0ZSc7XG5pbXBvcnQgdHlwZSB7IFF1ZXJ5Q2FjaGVLZXkgfSBmcm9tICcuLi9hcGlTdGF0ZSc7XG5pbXBvcnQgeyBvbkZvY3VzLCBvbk9ubGluZSB9IGZyb20gJy4uL3NldHVwTGlzdGVuZXJzJztcbmltcG9ydCB0eXBlIHsgQXBpTWlkZGxld2FyZUludGVybmFsSGFuZGxlciwgSW50ZXJuYWxIYW5kbGVyQnVpbGRlciwgU3ViTWlkZGxld2FyZUFwaSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgY291bnRPYmplY3RLZXlzIH0gZnJvbSAnLi4vLi4vdXRpbHMvY291bnRPYmplY3RLZXlzJztcbmV4cG9ydCBjb25zdCBidWlsZFdpbmRvd0V2ZW50SGFuZGxlcjogSW50ZXJuYWxIYW5kbGVyQnVpbGRlciA9ICh7XG4gIHJlZHVjZXJQYXRoLFxuICBjb250ZXh0LFxuICBhcGksXG4gIHJlZmV0Y2hRdWVyeSxcbiAgaW50ZXJuYWxTdGF0ZVxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmVtb3ZlUXVlcnlSZXN1bHRcbiAgfSA9IGFwaS5pbnRlcm5hbEFjdGlvbnM7XG4gIGNvbnN0IGhhbmRsZXI6IEFwaU1pZGRsZXdhcmVJbnRlcm5hbEhhbmRsZXIgPSAoYWN0aW9uLCBtd0FwaSkgPT4ge1xuICAgIGlmIChvbkZvY3VzLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHJlZmV0Y2hWYWxpZFF1ZXJpZXMobXdBcGksICdyZWZldGNoT25Gb2N1cycpO1xuICAgIH1cbiAgICBpZiAob25PbmxpbmUubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmVmZXRjaFZhbGlkUXVlcmllcyhtd0FwaSwgJ3JlZmV0Y2hPblJlY29ubmVjdCcpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gcmVmZXRjaFZhbGlkUXVlcmllcyhhcGk6IFN1Yk1pZGRsZXdhcmVBcGksIHR5cGU6ICdyZWZldGNoT25Gb2N1cycgfCAncmVmZXRjaE9uUmVjb25uZWN0Jykge1xuICAgIGNvbnN0IHN0YXRlID0gYXBpLmdldFN0YXRlKClbcmVkdWNlclBhdGhdO1xuICAgIGNvbnN0IHF1ZXJpZXMgPSBzdGF0ZS5xdWVyaWVzO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zO1xuICAgIGNvbnRleHQuYmF0Y2goKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBxdWVyeUNhY2hlS2V5IG9mIE9iamVjdC5rZXlzKHN1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5U3ViU3RhdGUgPSBxdWVyaWVzW3F1ZXJ5Q2FjaGVLZXldO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25TdWJTdGF0ZSA9IHN1YnNjcmlwdGlvbnNbcXVlcnlDYWNoZUtleV07XG4gICAgICAgIGlmICghc3Vic2NyaXB0aW9uU3ViU3RhdGUgfHwgIXF1ZXJ5U3ViU3RhdGUpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBzaG91bGRSZWZldGNoID0gT2JqZWN0LnZhbHVlcyhzdWJzY3JpcHRpb25TdWJTdGF0ZSkuc29tZShzdWIgPT4gc3ViW3R5cGVdID09PSB0cnVlKSB8fCBPYmplY3QudmFsdWVzKHN1YnNjcmlwdGlvblN1YlN0YXRlKS5ldmVyeShzdWIgPT4gc3ViW3R5cGVdID09PSB1bmRlZmluZWQpICYmIHN0YXRlLmNvbmZpZ1t0eXBlXTtcbiAgICAgICAgaWYgKHNob3VsZFJlZmV0Y2gpIHtcbiAgICAgICAgICBpZiAoY291bnRPYmplY3RLZXlzKHN1YnNjcmlwdGlvblN1YlN0YXRlKSA9PT0gMCkge1xuICAgICAgICAgICAgYXBpLmRpc3BhdGNoKHJlbW92ZVF1ZXJ5UmVzdWx0KHtcbiAgICAgICAgICAgICAgcXVlcnlDYWNoZUtleTogcXVlcnlDYWNoZUtleSBhcyBRdWVyeUNhY2hlS2V5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChxdWVyeVN1YlN0YXRlLnN0YXR1cyAhPT0gUXVlcnlTdGF0dXMudW5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgYXBpLmRpc3BhdGNoKHJlZmV0Y2hRdWVyeShxdWVyeVN1YlN0YXRlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZXI7XG59OyIsImltcG9ydCB0eXBlIHsgQWN0aW9uLCBNaWRkbGV3YXJlLCBUaHVua0Rpc3BhdGNoLCBVbmtub3duQWN0aW9uIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XG5pbXBvcnQgdHlwZSB7IEVuZHBvaW50RGVmaW5pdGlvbnMsIEZ1bGxUYWdEZXNjcmlwdGlvbiB9IGZyb20gJy4uLy4uL2VuZHBvaW50RGVmaW5pdGlvbnMnO1xuaW1wb3J0IHR5cGUgeyBRdWVyeVN0YXR1cywgUXVlcnlTdWJTdGF0ZSwgUm9vdFN0YXRlIH0gZnJvbSAnLi4vYXBpU3RhdGUnO1xuaW1wb3J0IHR5cGUgeyBRdWVyeVRodW5rQXJnIH0gZnJvbSAnLi4vYnVpbGRUaHVua3MnO1xuaW1wb3J0IHsgY3JlYXRlQWN0aW9uLCBpc0FjdGlvbiB9IGZyb20gJy4uL3J0a0ltcG9ydHMnO1xuaW1wb3J0IHsgYnVpbGRCYXRjaGVkQWN0aW9uc0hhbmRsZXIgfSBmcm9tICcuL2JhdGNoQWN0aW9ucyc7XG5pbXBvcnQgeyBidWlsZENhY2hlQ29sbGVjdGlvbkhhbmRsZXIgfSBmcm9tICcuL2NhY2hlQ29sbGVjdGlvbic7XG5pbXBvcnQgeyBidWlsZENhY2hlTGlmZWN5Y2xlSGFuZGxlciB9IGZyb20gJy4vY2FjaGVMaWZlY3ljbGUnO1xuaW1wb3J0IHsgYnVpbGREZXZDaGVja0hhbmRsZXIgfSBmcm9tICcuL2Rldk1pZGRsZXdhcmUnO1xuaW1wb3J0IHsgYnVpbGRJbnZhbGlkYXRpb25CeVRhZ3NIYW5kbGVyIH0gZnJvbSAnLi9pbnZhbGlkYXRpb25CeVRhZ3MnO1xuaW1wb3J0IHsgYnVpbGRQb2xsaW5nSGFuZGxlciB9IGZyb20gJy4vcG9sbGluZyc7XG5pbXBvcnQgeyBidWlsZFF1ZXJ5TGlmZWN5Y2xlSGFuZGxlciB9IGZyb20gJy4vcXVlcnlMaWZlY3ljbGUnO1xuaW1wb3J0IHR5cGUgeyBCdWlsZE1pZGRsZXdhcmVJbnB1dCwgSW50ZXJuYWxIYW5kbGVyQnVpbGRlciwgSW50ZXJuYWxNaWRkbGV3YXJlU3RhdGUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGJ1aWxkV2luZG93RXZlbnRIYW5kbGVyIH0gZnJvbSAnLi93aW5kb3dFdmVudEhhbmRsaW5nJztcbmltcG9ydCB0eXBlIHsgQXBpRW5kcG9pbnRRdWVyeSB9IGZyb20gJy4uL21vZHVsZSc7XG5leHBvcnQgdHlwZSB7IFJlZmVyZW5jZUNhY2hlQ29sbGVjdGlvbiB9IGZyb20gJy4vY2FjaGVDb2xsZWN0aW9uJztcbmV4cG9ydCB0eXBlIHsgTXV0YXRpb25DYWNoZUxpZmVjeWNsZUFwaSwgUXVlcnlDYWNoZUxpZmVjeWNsZUFwaSwgUmVmZXJlbmNlQ2FjaGVMaWZlY3ljbGUgfSBmcm9tICcuL2NhY2hlTGlmZWN5Y2xlJztcbmV4cG9ydCB0eXBlIHsgTXV0YXRpb25MaWZlY3ljbGVBcGksIFF1ZXJ5TGlmZWN5Y2xlQXBpLCBSZWZlcmVuY2VRdWVyeUxpZmVjeWNsZSwgVHlwZWRNdXRhdGlvbk9uUXVlcnlTdGFydGVkLCBUeXBlZFF1ZXJ5T25RdWVyeVN0YXJ0ZWQgfSBmcm9tICcuL3F1ZXJ5TGlmZWN5Y2xlJztcbmV4cG9ydCB0eXBlIHsgU3Vic2NyaXB0aW9uU2VsZWN0b3JzIH0gZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRNaWRkbGV3YXJlPERlZmluaXRpb25zIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9ucywgUmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcsIFRhZ1R5cGVzIGV4dGVuZHMgc3RyaW5nPihpbnB1dDogQnVpbGRNaWRkbGV3YXJlSW5wdXQ8RGVmaW5pdGlvbnMsIFJlZHVjZXJQYXRoLCBUYWdUeXBlcz4pIHtcbiAgY29uc3Qge1xuICAgIHJlZHVjZXJQYXRoLFxuICAgIHF1ZXJ5VGh1bmssXG4gICAgYXBpLFxuICAgIGNvbnRleHRcbiAgfSA9IGlucHV0O1xuICBjb25zdCB7XG4gICAgYXBpVWlkXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCBhY3Rpb25zID0ge1xuICAgIGludmFsaWRhdGVUYWdzOiBjcmVhdGVBY3Rpb248QXJyYXk8VGFnVHlwZXMgfCBGdWxsVGFnRGVzY3JpcHRpb248VGFnVHlwZXM+IHwgbnVsbCB8IHVuZGVmaW5lZD4+KGAke3JlZHVjZXJQYXRofS9pbnZhbGlkYXRlVGFnc2ApXG4gIH07XG4gIGNvbnN0IGlzVGhpc0FwaVNsaWNlQWN0aW9uID0gKGFjdGlvbjogQWN0aW9uKSA9PiBhY3Rpb24udHlwZS5zdGFydHNXaXRoKGAke3JlZHVjZXJQYXRofS9gKTtcbiAgY29uc3QgaGFuZGxlckJ1aWxkZXJzOiBJbnRlcm5hbEhhbmRsZXJCdWlsZGVyW10gPSBbYnVpbGREZXZDaGVja0hhbmRsZXIsIGJ1aWxkQ2FjaGVDb2xsZWN0aW9uSGFuZGxlciwgYnVpbGRJbnZhbGlkYXRpb25CeVRhZ3NIYW5kbGVyLCBidWlsZFBvbGxpbmdIYW5kbGVyLCBidWlsZENhY2hlTGlmZWN5Y2xlSGFuZGxlciwgYnVpbGRRdWVyeUxpZmVjeWNsZUhhbmRsZXJdO1xuICBjb25zdCBtaWRkbGV3YXJlOiBNaWRkbGV3YXJlPHt9LCBSb290U3RhdGU8RGVmaW5pdGlvbnMsIHN0cmluZywgUmVkdWNlclBhdGg+LCBUaHVua0Rpc3BhdGNoPGFueSwgYW55LCBVbmtub3duQWN0aW9uPj4gPSBtd0FwaSA9PiB7XG4gICAgbGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgY29uc3QgaW50ZXJuYWxTdGF0ZTogSW50ZXJuYWxNaWRkbGV3YXJlU3RhdGUgPSB7XG4gICAgICBjdXJyZW50U3Vic2NyaXB0aW9uczoge31cbiAgICB9O1xuICAgIGNvbnN0IGJ1aWxkZXJBcmdzID0ge1xuICAgICAgLi4uKGlucHV0IGFzIGFueSBhcyBCdWlsZE1pZGRsZXdhcmVJbnB1dDxFbmRwb2ludERlZmluaXRpb25zLCBzdHJpbmcsIHN0cmluZz4pLFxuICAgICAgaW50ZXJuYWxTdGF0ZSxcbiAgICAgIHJlZmV0Y2hRdWVyeSxcbiAgICAgIGlzVGhpc0FwaVNsaWNlQWN0aW9uXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVycyA9IGhhbmRsZXJCdWlsZGVycy5tYXAoYnVpbGQgPT4gYnVpbGQoYnVpbGRlckFyZ3MpKTtcbiAgICBjb25zdCBiYXRjaGVkQWN0aW9uc0hhbmRsZXIgPSBidWlsZEJhdGNoZWRBY3Rpb25zSGFuZGxlcihidWlsZGVyQXJncyk7XG4gICAgY29uc3Qgd2luZG93RXZlbnRzSGFuZGxlciA9IGJ1aWxkV2luZG93RXZlbnRIYW5kbGVyKGJ1aWxkZXJBcmdzKTtcbiAgICByZXR1cm4gbmV4dCA9PiB7XG4gICAgICByZXR1cm4gYWN0aW9uID0+IHtcbiAgICAgICAgaWYgKCFpc0FjdGlvbihhY3Rpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluaXRpYWxpemVkKSB7XG4gICAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgIC8vIGRpc3BhdGNoIGJlZm9yZSBhbnkgb3RoZXIgYWN0aW9uXG4gICAgICAgICAgbXdBcGkuZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5taWRkbGV3YXJlUmVnaXN0ZXJlZChhcGlVaWQpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtd0FwaVdpdGhOZXh0ID0ge1xuICAgICAgICAgIC4uLm13QXBpLFxuICAgICAgICAgIG5leHRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RhdGVCZWZvcmUgPSBtd0FwaS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBbYWN0aW9uU2hvdWxkQ29udGludWUsIGludGVybmFsUHJvYmVSZXN1bHRdID0gYmF0Y2hlZEFjdGlvbnNIYW5kbGVyKGFjdGlvbiwgbXdBcGlXaXRoTmV4dCwgc3RhdGVCZWZvcmUpO1xuICAgICAgICBsZXQgcmVzOiBhbnk7XG4gICAgICAgIGlmIChhY3Rpb25TaG91bGRDb250aW51ZSkge1xuICAgICAgICAgIHJlcyA9IG5leHQoYWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSBpbnRlcm5hbFByb2JlUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghIW13QXBpLmdldFN0YXRlKClbcmVkdWNlclBhdGhdKSB7XG4gICAgICAgICAgLy8gT25seSBydW4gdGhlc2UgY2hlY2tzIGlmIHRoZSBtaWRkbGV3YXJlIGlzIHJlZ2lzdGVyZWQgb2theVxuXG4gICAgICAgICAgLy8gVGhpcyBsb29rcyBmb3IgYWN0aW9ucyB0aGF0IGFyZW4ndCBzcGVjaWZpYyB0byB0aGUgQVBJIHNsaWNlXG4gICAgICAgICAgd2luZG93RXZlbnRzSGFuZGxlcihhY3Rpb24sIG13QXBpV2l0aE5leHQsIHN0YXRlQmVmb3JlKTtcbiAgICAgICAgICBpZiAoaXNUaGlzQXBpU2xpY2VBY3Rpb24oYWN0aW9uKSB8fCBjb250ZXh0Lmhhc1JlaHlkcmF0aW9uSW5mbyhhY3Rpb24pKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHJ1biB0aGVzZSBhZGRpdGlvbmFsIGNoZWNrcyBpZiB0aGUgYWN0aW9ucyBhcmUgcGFydCBvZiB0aGUgQVBJIHNsaWNlLFxuICAgICAgICAgICAgLy8gb3IgdGhlIGFjdGlvbiBoYXMgaHlkcmF0aW9uLXJlbGF0ZWQgZGF0YVxuICAgICAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgIGhhbmRsZXIoYWN0aW9uLCBtd0FwaVdpdGhOZXh0LCBzdGF0ZUJlZm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWlkZGxld2FyZSxcbiAgICBhY3Rpb25zXG4gIH07XG4gIGZ1bmN0aW9uIHJlZmV0Y2hRdWVyeShxdWVyeVN1YlN0YXRlOiBFeGNsdWRlPFF1ZXJ5U3ViU3RhdGU8YW55Piwge1xuICAgIHN0YXR1czogUXVlcnlTdGF0dXMudW5pbml0aWFsaXplZDtcbiAgfT4pIHtcbiAgICByZXR1cm4gKGlucHV0LmFwaS5lbmRwb2ludHNbcXVlcnlTdWJTdGF0ZS5lbmRwb2ludE5hbWVdIGFzIEFwaUVuZHBvaW50UXVlcnk8YW55LCBhbnk+KS5pbml0aWF0ZShxdWVyeVN1YlN0YXRlLm9yaWdpbmFsQXJncyBhcyBhbnksIHtcbiAgICAgIHN1YnNjcmliZTogZmFsc2UsXG4gICAgICBmb3JjZVJlZmV0Y2g6IHRydWVcbiAgICB9KTtcbiAgfVxufSIsImltcG9ydCB7IGJ1aWxkQ3JlYXRlQXBpIH0gZnJvbSAnLi4vY3JlYXRlQXBpJztcbmltcG9ydCB7IGNvcmVNb2R1bGUgfSBmcm9tICcuL21vZHVsZSc7XG5leHBvcnQgY29uc3QgY3JlYXRlQXBpID0gLyogQF9fUFVSRV9fICovYnVpbGRDcmVhdGVBcGkoY29yZU1vZHVsZSgpKTtcbmV4cG9ydCB7IFF1ZXJ5U3RhdHVzIH0gZnJvbSAnLi9hcGlTdGF0ZSc7XG5leHBvcnQgdHlwZSB7IENvbWJpbmVkU3RhdGUsIEluZmluaXRlRGF0YSwgSW5maW5pdGVRdWVyeUNvbmZpZ09wdGlvbnMsIEluZmluaXRlUXVlcnlTdWJTdGF0ZSwgTXV0YXRpb25LZXlzLCBRdWVyeUNhY2hlS2V5LCBRdWVyeUtleXMsIFF1ZXJ5U3ViU3RhdGUsIFJvb3RTdGF0ZSwgU3Vic2NyaXB0aW9uT3B0aW9ucyB9IGZyb20gJy4vYXBpU3RhdGUnO1xuZXhwb3J0IHR5cGUgeyBJbmZpbml0ZVF1ZXJ5QWN0aW9uQ3JlYXRvclJlc3VsdCwgTXV0YXRpb25BY3Rpb25DcmVhdG9yUmVzdWx0LCBRdWVyeUFjdGlvbkNyZWF0b3JSZXN1bHQsIFN0YXJ0UXVlcnlBY3Rpb25DcmVhdG9yT3B0aW9ucyB9IGZyb20gJy4vYnVpbGRJbml0aWF0ZSc7XG5leHBvcnQgdHlwZSB7IE11dGF0aW9uQ2FjaGVMaWZlY3ljbGVBcGksIE11dGF0aW9uTGlmZWN5Y2xlQXBpLCBRdWVyeUNhY2hlTGlmZWN5Y2xlQXBpLCBRdWVyeUxpZmVjeWNsZUFwaSwgU3Vic2NyaXB0aW9uU2VsZWN0b3JzLCBUeXBlZE11dGF0aW9uT25RdWVyeVN0YXJ0ZWQsIFR5cGVkUXVlcnlPblF1ZXJ5U3RhcnRlZCB9IGZyb20gJy4vYnVpbGRNaWRkbGV3YXJlL2luZGV4JztcbmV4cG9ydCB7IHNraXBUb2tlbiB9IGZyb20gJy4vYnVpbGRTZWxlY3RvcnMnO1xuZXhwb3J0IHR5cGUgeyBJbmZpbml0ZVF1ZXJ5UmVzdWx0U2VsZWN0b3JSZXN1bHQsIE11dGF0aW9uUmVzdWx0U2VsZWN0b3JSZXN1bHQsIFF1ZXJ5UmVzdWx0U2VsZWN0b3JSZXN1bHQsIFNraXBUb2tlbiB9IGZyb20gJy4vYnVpbGRTZWxlY3RvcnMnO1xuZXhwb3J0IHR5cGUgeyBTbGljZUFjdGlvbnMgfSBmcm9tICcuL2J1aWxkU2xpY2UnO1xuZXhwb3J0IHR5cGUgeyBQYXRjaFF1ZXJ5RGF0YVRodW5rLCBVcGRhdGVRdWVyeURhdGFUaHVuaywgVXBzZXJ0UXVlcnlEYXRhVGh1bmsgfSBmcm9tICcuL2J1aWxkVGh1bmtzJztcbmV4cG9ydCB7IGNvcmVNb2R1bGVOYW1lIH0gZnJvbSAnLi9tb2R1bGUnO1xuZXhwb3J0IHR5cGUgeyBBcGlFbmRwb2ludEluZmluaXRlUXVlcnksIEFwaUVuZHBvaW50TXV0YXRpb24sIEFwaUVuZHBvaW50UXVlcnksIENvcmVNb2R1bGUsIEludGVybmFsQWN0aW9ucywgUHJlZmV0Y2hPcHRpb25zLCBUaHVua1dpdGhSZXR1cm5WYWx1ZSB9IGZyb20gJy4vbW9kdWxlJztcbmV4cG9ydCB7IHNldHVwTGlzdGVuZXJzIH0gZnJvbSAnLi9zZXR1cExpc3RlbmVycyc7XG5leHBvcnQgeyBidWlsZENyZWF0ZUFwaSwgY29yZU1vZHVsZSB9OyJdLCJuYW1lcyI6WyJRdWVyeVN0YXR1cyIsImlzUGxhaW5PYmplY3QiLCJyZXRyeSIsImFyZyIsImZvcmNlIiwib3B0aW9ucyIsImFjdGlvbnMiLCJjcmVhdGVTZWxlY3RvciIsIl9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIiwiX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyIiwia2V5IiwicXVlcnlBcmdzQXBpIiwiX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UiLCJnZXRQcmV2aW91c1BhZ2VQYXJhbSIsIl9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiIsIl9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIiwicHJvZHVjZVdpdGhQYXRjaGVzIiwicHJvZHVjZVdpdGhQYXRjaGVzIiwiaW50ZXJuYWxTdGF0ZSIsImFwaSIsImNhY2hlS2V5IiwiZXh0cmEiLCJhcGkiLCJleHRyYSIsImFwaSIsImluaXRpYWxpemVkIiwiY3JlYXRlU2VsZWN0b3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0F5QjRYaUI7O0F4QnhYakIsU0FBUyxjQUFjLGFBQWEsZ0JBQWdCLGtCQUFrQixpQkFBaUIsaUJBQWlCLFNBQVMsU0FBUyxVQUFVLFdBQVcsWUFBWSxhQUFhLHFCQUFxQixvQkFBb0Isb0JBQW9CLGtCQUFrQixlQUFlLGNBQWM7Ozs7O0FlRnBSLFNBQVMsYUFBYSwwQkFBMEI7O0FHRGhELFNBQVMsbUJBQW1CO0FuQm1EckIsSUFBSyxjQUFMLGFBQUEsR0FBQSxDQUFBLENBQUtBLGlCQUFMO0lBQ0xBLFlBQUFBLENBQUEsZ0JBQUEsR0FBZ0I7SUFDaEJBLFlBQUFBLENBQUEsVUFBQSxHQUFVO0lBQ1ZBLFlBQUFBLENBQUEsWUFBQSxHQUFZO0lBQ1pBLFlBQUFBLENBQUEsV0FBQSxHQUFXO0lBSkQsT0FBQUE7QUFBQSxDQUFBLEVBQUEsZUFBQSxDQUFBO0FBK0JMLFNBQVMsc0JBQXNCLE1BQUEsRUFBeUM7SUFDN0UsT0FBTztRQUNMO1FBQ0EsaUJBQWlCLFdBQVcsZ0JBQUEsaUJBQUE7UUFDNUIsV0FBVyxXQUFXLFVBQUEsV0FBQTtRQUN0QixXQUFXLFdBQVcsWUFBQSxhQUFBO1FBQ3RCLFNBQVMsV0FBVyxXQUFBLFlBQUE7SUFDdEI7QUFDRjs7O0FFeEZBLElBQU1DLDRKQUFxQyxnQkFBQTtBQUVwQyxTQUFTLDBCQUEwQixNQUFBLEVBQWEsTUFBQSxFQUFrQjtJQUN2RSxJQUFJLFdBQVcsVUFBVSxDQUFBLENBQUVBLGVBQWMsTUFBTSxLQUFLQSxlQUFjLE1BQU0sS0FBSyxNQUFNLE9BQUEsQ0FBUSxNQUFNLEtBQUssTUFBTSxPQUFBLENBQVEsTUFBTSxDQUFBLEdBQUk7UUFDNUgsT0FBTztJQUNUO0lBQ0EsTUFBTSxVQUFVLE9BQU8sSUFBQSxDQUFLLE1BQU07SUFDbEMsTUFBTSxVQUFVLE9BQU8sSUFBQSxDQUFLLE1BQU07SUFDbEMsSUFBSSxlQUFlLFFBQVEsTUFBQSxLQUFXLFFBQVEsTUFBQTtJQUM5QyxNQUFNLFdBQWdCLE1BQU0sT0FBQSxDQUFRLE1BQU0sSUFBSSxDQUFDLENBQUEsR0FBSSxDQUFDO0lBQ3BELEtBQUEsTUFBVyxPQUFPLFFBQVM7UUFDekIsUUFBQSxDQUFTLEdBQUcsQ0FBQSxHQUFJLDBCQUEwQixNQUFBLENBQU8sR0FBRyxDQUFBLEVBQUcsTUFBQSxDQUFPLEdBQUcsQ0FBQztRQUNsRSxJQUFJLGFBQWMsQ0FBQSxlQUFlLE1BQUEsQ0FBTyxHQUFHLENBQUEsS0FBTSxRQUFBLENBQVMsR0FBRyxDQUFBO0lBQy9EO0lBQ0EsT0FBTyxlQUFlLFNBQVM7QUFDakM7O0FDYk8sU0FBUyxnQkFBZ0IsR0FBQSxFQUF1QjtJQUNyRCxJQUFJLFFBQVE7SUFDWixJQUFBLE1BQVcsUUFBUSxJQUFLO1FBQ3RCO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7O0FDTk8sSUFBTSxVQUFVLENBQUMsTUFBd0IsQ0FBQyxDQUFBLENBQUUsTUFBQSxDQUFPLEdBQUcsR0FBRzs7QUNDekQsU0FBUyxjQUFjLEdBQUEsRUFBYTtJQUN6QyxPQUFPLElBQUksT0FBTyxRQUFTLEdBQUUsSUFBQSxDQUFLLEdBQUc7QUFDdkM7O0FDSk8sU0FBUyxvQkFBNkI7SUFFM0MsSUFBSSxPQUFPLGFBQWEsYUFBYTtRQUNuQyxPQUFPO0lBQ1Q7SUFFQSxPQUFPLFNBQVMsZUFBQSxLQUFvQjtBQUN0Qzs7QUNYTyxTQUFTLGFBQWdCLENBQUEsRUFBaUM7SUFDL0QsT0FBTyxLQUFLO0FBQ2Q7O0FDRU8sU0FBUyxXQUFXO0lBRXpCLE9BQU8sT0FBTyxjQUFjLGNBQWMsT0FBTyxVQUFVLE1BQUEsS0FBVyxLQUFBLElBQVksT0FBTyxVQUFVLE1BQUE7QUFDckc7O0FDTkEsSUFBTSx1QkFBdUIsQ0FBQyxNQUFnQixJQUFJLE9BQUEsQ0FBUSxPQUFPLEVBQUU7QUFDbkUsSUFBTSxzQkFBc0IsQ0FBQyxNQUFnQixJQUFJLE9BQUEsQ0FBUSxPQUFPLEVBQUU7QUFDM0QsU0FBUyxTQUFTLElBQUEsRUFBMEIsR0FBQSxFQUFpQztJQUNsRixJQUFJLENBQUMsTUFBTTtRQUNULE9BQU87SUFDVDtJQUNBLElBQUksQ0FBQyxLQUFLO1FBQ1IsT0FBTztJQUNUO0lBQ0EsSUFBSSxjQUFjLEdBQUcsR0FBRztRQUN0QixPQUFPO0lBQ1Q7SUFDQSxNQUFNLFlBQVksS0FBSyxRQUFBLENBQVMsR0FBRyxLQUFLLENBQUMsSUFBSSxVQUFBLENBQVcsR0FBRyxJQUFJLE1BQU07SUFDckUsT0FBTyxxQkFBcUIsSUFBSTtJQUNoQyxNQUFNLG9CQUFvQixHQUFHO0lBQzdCLE9BQU8sVUFBRyxJQUFJLFNBQUcsU0FBUyxFQUFNLE9BQUgsR0FBRztBQUNsQzs7QUNmTyxTQUFTLFlBQWlDLEdBQUEsRUFBZ0MsR0FBQSxFQUFRLEtBQUEsRUFBYTtJQUNwRyxJQUFJLElBQUksR0FBQSxDQUFJLEdBQUcsRUFBRyxDQUFBLE9BQU8sSUFBSSxHQUFBLENBQUksR0FBRztJQUNwQyxPQUFPLElBQUksR0FBQSxDQUFJLEtBQUssS0FBSyxFQUFFLEdBQUEsQ0FBSSxHQUFHO0FBQ3BDOztBQ29CQSxJQUFNLGlCQUErQjs7UUFBSTs7V0FBUyxNQUFNLEdBQUcsSUFBSTs7QUFDL0QsSUFBTSx3QkFBd0IsQ0FBQyxXQUF1QixTQUFTLE1BQUEsSUFBVSxPQUFPLFNBQVMsTUFBQSxJQUFVO0FBQ25HLElBQU0sMkJBQTJCLENBQUMsVUFBQSxVQUFBLEdBQWlDLHlCQUF5QixJQUFBLENBQUssUUFBUSxHQUFBLENBQUksY0FBYyxLQUFLLEVBQUU7QUE0Q2xJLFNBQVMsZUFBZSxHQUFBLEVBQVU7SUFDaEMsSUFBSSxnSkFBQyxnQkFBQSxFQUFjLEdBQUcsR0FBRztRQUN2QixPQUFPO0lBQ1Q7SUFDQSxNQUFNLE9BQTRCO1FBQ2hDLEdBQUcsR0FBQTtJQUNMO0lBQ0EsS0FBQSxNQUFXLENBQUMsR0FBRyxDQUFDLENBQUEsSUFBSyxPQUFPLE9BQUEsQ0FBUSxJQUFJLEVBQUc7UUFDekMsSUFBSSxNQUFNLEtBQUEsRUFBVyxDQUFBLE9BQU8sSUFBQSxDQUFLLENBQUMsQ0FBQTtJQUNwQztJQUNBLE9BQU87QUFDVDtBQWdGTyxTQUFTO1FBQWUsRUFDN0IsT0FBQSxFQUNBLGlCQUFpQixDQUFBLElBQUssQ0FBQSxFQUN0QixVQUFVLGNBQUEsRUFDVixnQkFBQSxFQUNBLG9CQUFvQix3QkFBQSxFQUNwQixrQkFBa0Isa0JBQUEsRUFDbEIsWUFBQSxFQUNBLFNBQVMsY0FBQSxFQUNULGlCQUFpQixxQkFBQSxFQUNqQixnQkFBZ0Isb0JBQUEsRUFDaEIsR0FBRyxrQkFDTCxvRUFBd0IsQ0FBQyxHQUEwRjtJQUNqSCxJQUFJLE9BQU8sVUFBVSxlQUFlLFlBQVksZ0JBQWdCO1FBQzlELFFBQVEsSUFBQSxDQUFLLDJIQUEySDtJQUMxSTtJQUNBLE9BQU8sT0FBTyxLQUFLLEtBQUssaUJBQWlCO1FBQ3ZDLE1BQU0sRUFDSixRQUFBLEVBQ0EsS0FBQSxFQUNBLFFBQUEsRUFDQSxNQUFBLEVBQ0EsSUFBQSxFQUNGLEdBQUk7UUFDSixJQUFJO1FBQ0osSUFBSSxFQUNGLEdBQUEsRUFDQSxVQUFVLElBQUksUUFBUSxpQkFBaUIsT0FBTyxDQUFBLEVBQzlDLFNBQVMsS0FBQSxDQUFBLEVBQ1QsdUZBQWtCLHdCQUF5QixNQUFBLEVBQzNDLGtEQUFpQix5REFBd0IscUJBQUEsRUFDekMsVUFBVSxjQUFBLEVBQ1YsR0FBRyxNQUNMLEdBQUksT0FBTyxPQUFPLFdBQVc7WUFDM0IsS0FBSztRQUNQLElBQUk7UUFDSixJQUFJLGlCQUNGLFNBQVMsSUFBSSxNQUFBO1FBQ2YsSUFBSSxTQUFTO1lBQ1gsa0JBQWtCLElBQUksZ0JBQWdCO1lBQ3RDLElBQUksTUFBQSxDQUFPLGdCQUFBLENBQWlCLFNBQVMsZ0JBQWdCLEtBQUs7WUFDMUQsU0FBUyxnQkFBZ0IsTUFBQTtRQUMzQjtRQUNBLElBQUksU0FBc0I7WUFDeEIsR0FBRyxnQkFBQTtZQUNIO1lBQ0EsR0FBRyxJQUFBO1FBQ0w7UUFDQSxVQUFVLElBQUksUUFBUSxlQUFlLE9BQU8sQ0FBQztRQUM3QyxPQUFPLE9BQUEsR0FBVyxNQUFNLGVBQWUsU0FBUztZQUM5QztZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtRQUNGLENBQUMsS0FBTTtRQUdQLE1BQU0sZ0JBQWdCLENBQUMsT0FBYyxPQUFPLFNBQVMsWUFBQSxnSkFBYSxnQkFBQSxFQUFjLElBQUksS0FBSyxNQUFNLE9BQUEsQ0FBUSxJQUFJLEtBQUssT0FBTyxLQUFLLE1BQUEsS0FBVyxVQUFBO1FBQ3ZJLElBQUksQ0FBQyxPQUFPLE9BQUEsQ0FBUSxHQUFBLENBQUksY0FBYyxLQUFLLGNBQWMsT0FBTyxJQUFJLEdBQUc7WUFDckUsT0FBTyxPQUFBLENBQVEsR0FBQSxDQUFJLGdCQUFnQixlQUFlO1FBQ3BEO1FBQ0EsSUFBSSxjQUFjLE9BQU8sSUFBSSxLQUFLLGtCQUFrQixPQUFPLE9BQU8sR0FBRztZQUNuRSxPQUFPLElBQUEsR0FBTyxLQUFLLFNBQUEsQ0FBVSxPQUFPLElBQUEsRUFBTSxZQUFZO1FBQ3hEO1FBQ0EsSUFBSSxRQUFRO1lBQ1YsTUFBTSxVQUFVLENBQUMsSUFBSSxPQUFBLENBQVEsR0FBRyxJQUFJLE1BQU07WUFDMUMsTUFBTSxRQUFRLG1CQUFtQixpQkFBaUIsTUFBTSxJQUFJLElBQUksZ0JBQWdCLGVBQWUsTUFBTSxDQUFDO1lBQ3RHLE9BQU8sVUFBVTtRQUNuQjtRQUNBLE1BQU0sU0FBUyxTQUFTLEdBQUc7UUFDM0IsTUFBTSxVQUFVLElBQUksUUFBUSxLQUFLLE1BQU07UUFDdkMsTUFBTSxlQUFlLElBQUksUUFBUSxLQUFLLE1BQU07UUFDNUMsT0FBTztZQUNMLFNBQVM7UUFDWDtRQUNBLElBQUksVUFDRixXQUFXLE9BQ1gsWUFBWSxtQkFBbUIsV0FBVyxNQUFNO1lBQzlDLFdBQVc7WUFDWCxnQkFBaUIsS0FBQSxDQUFNO1FBQ3pCLEdBQUcsT0FBTztRQUNaLElBQUk7WUFDRixXQUFXLE1BQU0sUUFBUSxPQUFPO1FBQ2xDLEVBQUEsT0FBUyxHQUFHO1lBQ1YsT0FBTztnQkFDTCxPQUFPO29CQUNMLFFBQVEsV0FBVyxrQkFBa0I7b0JBQ3JDLE9BQU8sT0FBTyxDQUFDO2dCQUNqQjtnQkFDQTtZQUNGO1FBQ0YsU0FBRTtZQUNBLElBQUksVUFBVyxDQUFBLGFBQWEsU0FBUztZQUNyQyw0QkFBQSxzQ0FBQSxnQkFBaUIsTUFBQSxDQUFPLG1CQUFBLENBQW9CLFNBQVMsZ0JBQWdCLEtBQUs7UUFDNUU7UUFDQSxNQUFNLGdCQUFnQixTQUFTLEtBQUEsQ0FBTTtRQUNyQyxLQUFLLFFBQUEsR0FBVztRQUNoQixJQUFJO1FBQ0osSUFBSSxlQUF1QjtRQUMzQixJQUFJO1lBQ0YsSUFBSTtZQUNKLE1BQU0sUUFBUSxHQUFBLENBQUk7Z0JBQUMsZUFBZSxVQUFVLGVBQWUsRUFBRSxJQUFBLENBQUssQ0FBQSxJQUFLLGFBQWEsR0FBRyxDQUFBLElBQUssc0JBQXNCLENBQUM7Z0JBQUEsaUZBQUE7Z0JBQUEsd0dBQUE7Z0JBR25ILGNBQWMsSUFBQSxDQUFLLEVBQUUsSUFBQSxDQUFLLENBQUEsSUFBSyxlQUFlLEdBQUcsS0FBTyxDQUFELEFBQUU7YUFBRTtZQUMzRCxJQUFJLG9CQUFxQixDQUFBLE1BQU07UUFDakMsRUFBQSxPQUFTLEdBQUc7WUFDVixPQUFPO2dCQUNMLE9BQU87b0JBQ0wsUUFBUTtvQkFDUixnQkFBZ0IsU0FBUyxNQUFBO29CQUN6QixNQUFNO29CQUNOLE9BQU8sT0FBTyxDQUFDO2dCQUNqQjtnQkFDQTtZQUNGO1FBQ0Y7UUFDQSxPQUFPLGVBQWUsVUFBVSxVQUFVLElBQUk7WUFDNUMsTUFBTTtZQUNOO1FBQ0YsSUFBSTtZQUNGLE9BQU87Z0JBQ0wsUUFBUSxTQUFTLE1BQUE7Z0JBQ2pCLE1BQU07WUFDUjtZQUNBO1FBQ0Y7SUFDRjs7O0lBQ0EsZUFBZSxlQUFlLFFBQUEsRUFBb0IsZUFBQSxFQUFrQztRQUNsRixJQUFJLE9BQU8sb0JBQW9CLFlBQVk7WUFDekMsT0FBTyxnQkFBZ0IsUUFBUTtRQUNqQztRQUNBLElBQUksb0JBQW9CLGdCQUFnQjtZQUN0QyxrQkFBa0Isa0JBQWtCLFNBQVMsT0FBTyxJQUFJLFNBQVM7UUFDbkU7UUFDQSxJQUFJLG9CQUFvQixRQUFRO1lBQzlCLE1BQU0sT0FBTyxNQUFNLFNBQVMsSUFBQSxDQUFLO1lBQ2pDLE9BQU8sS0FBSyxNQUFBLEdBQVMsS0FBSyxLQUFBLENBQU0sSUFBSSxJQUFJO1FBQzFDO1FBQ0EsT0FBTyxTQUFTLElBQUEsQ0FBSztJQUN2QjtBQUNGOztBQ2xUTyxJQUFNLGVBQU4sTUFBbUI7SUFDeEIsWUFBNEIsS0FBQSxFQUE0QixPQUFZLEtBQUEsQ0FBQSxDQUFXO1FBQW5ELElBQUEsQ0FBQSxLQUFBLEdBQUE7UUFBNEIsSUFBQSxDQUFBLElBQUEsR0FBQTtJQUF3QjtBQUNsRjs7QUNlQSxlQUFlO2tCQUFlLGlFQUFrQixnQkFBRyxpRUFBcUIsR0FBRztJQUN6RSxNQUFNLFdBQVcsS0FBSyxHQUFBLENBQUksU0FBUyxVQUFVO0lBQzdDLE1BQU0sVUFBVSxDQUFDLENBQUEsQ0FBQSxDQUFHLEtBQUssTUFBQSxDQUFPLElBQUksR0FBQSxJQUFBLENBQVEsT0FBTyxRQUFBLENBQUE7SUFDbkQsTUFBTSxJQUFJLFFBQVEsQ0FBQSxVQUFXLFdBQVcsQ0FBQyxNQUFhLFFBQVEsR0FBRyxHQUFHLE9BQU8sQ0FBQztBQUM5RTtBQXlCQSxTQUFTLEtBQWtELEtBQUEsRUFBa0MsSUFBQSxFQUF3QztJQUNuSSxNQUFNLE9BQU8sTUFBQSxDQUFPLElBQUksYUFBYTtRQUNuQztRQUNBO0lBQ0YsQ0FBQyxHQUFHO1FBQ0Ysa0JBQWtCO0lBQ3BCLENBQUM7QUFDSDtBQUNBLElBQU0sZ0JBQWdCLENBQUM7QUFDdkIsSUFBTSxtQkFBa0YsQ0FBQyxXQUFXLGlCQUFtQixPQUFPLE1BQU0sS0FBSyxpQkFBaUI7UUFJeEosTUFBTSxxQkFBK0I7WUFBQztZQUFBLENBQUksa0JBQXlCLGFBQUEsRUFBZSxVQUFBO1lBQUEsQ0FBYSxnQkFBdUIsYUFBQSxFQUFlLFVBQVU7U0FBQSxDQUFFLE1BQUEsQ0FBTyxDQUFBLElBQUssTUFBTSxLQUFBLENBQVM7UUFDNUssTUFBTSxDQUFDLFVBQVUsQ0FBQSxHQUFJLG1CQUFtQixLQUFBLENBQU0sQ0FBQSxDQUFFO1FBQ2hELE1BQU0sd0JBQWdELENBQUMsR0FBRztnQkFBSSxFQUM1RCxPQUFBLEVBQ0Y7bUJBQU0sV0FBVzs7UUFDakIsTUFBTSxVQUlGO1lBQ0Y7WUFDQSxTQUFTO1lBQ1QsZ0JBQWdCO1lBQ2hCLEdBQUcsY0FBQTtZQUNILEdBQUcsWUFBQTtRQUNMO1FBQ0EsSUFBSUMsU0FBUTtRQUNaLE1BQU8sS0FBTTtZQUNYLElBQUk7Z0JBQ0YsTUFBTSxTQUFTLE1BQU0sVUFBVSxNQUFNLEtBQUssWUFBWTtnQkFFdEQsSUFBSSxPQUFPLEtBQUEsRUFBTztvQkFDaEIsTUFBTSxJQUFJLGFBQWEsTUFBTTtnQkFDL0I7Z0JBQ0EsT0FBTztZQUNULEVBQUEsT0FBUyxHQUFRO2dCQUNmQTtnQkFDQSxJQUFJLEVBQUUsZ0JBQUEsRUFBa0I7b0JBQ3RCLElBQUksYUFBYSxjQUFjO3dCQUM3QixPQUFPLEVBQUUsS0FBQTtvQkFDWDtvQkFHQSxNQUFNO2dCQUNSO2dCQUNBLElBQUksYUFBYSxnQkFBZ0IsQ0FBQyxRQUFRLGNBQUEsQ0FBZSxFQUFFLEtBQUEsQ0FBTSxLQUFBLEVBQThCLE1BQU07b0JBQ25HLFNBQVNBO29CQUNULGNBQWM7b0JBQ2Q7Z0JBQ0YsQ0FBQyxHQUFHO29CQUNGLE9BQU8sRUFBRSxLQUFBO2dCQUNYO2dCQUNBLE1BQU0sUUFBUSxPQUFBLENBQVFBLFFBQU8sUUFBUSxVQUFVO1lBQ2pEO1FBQ0Y7SUFDRjtBQWtDTyxJQUFNLFFBQXVCLGFBQUEsR0FBQSxPQUFPLE1BQUEsQ0FBTyxrQkFBa0I7SUFDbEU7QUFDRixDQUFDOztBQ3pJTSxJQUFNLFVBQXlCLGFBQUEsR0FBQSxDQUFBLEdBQUEsOExBQUEsQ0FBQSxlQUFBLEVBQWEsZ0JBQWdCO0FBQzVELElBQU0sY0FBNkIsYUFBQSxHQUFBLENBQUEsR0FBQSw4TEFBQSxDQUFBLGVBQUEsRUFBYSxrQkFBa0I7QUFDbEUsSUFBTSxXQUEwQixhQUFBLEdBQUEsQ0FBQSxHQUFBLDhMQUFBLENBQUEsZUFBQSxFQUFhLGVBQWU7QUFDNUQsSUFBTSxZQUEyQixhQUFBLEdBQUEsQ0FBQSxHQUFBLDhMQUFBLENBQUEsZUFBQSxFQUFhLGdCQUFnQjtBQUNyRSxJQUFJLGNBQWM7QUFrQlgsU0FBUyxlQUFlLFFBQUEsRUFBd0MsYUFBQSxFQUtyRDtJQUNoQixTQUFTLGlCQUFpQjtRQUN4QixNQUFNLGNBQWMsSUFBTSxTQUFTLFFBQVEsQ0FBQztRQUM1QyxNQUFNLGtCQUFrQixJQUFNLFNBQVMsWUFBWSxDQUFDO1FBQ3BELE1BQU0sZUFBZSxJQUFNLFNBQVMsU0FBUyxDQUFDO1FBQzlDLE1BQU0sZ0JBQWdCLElBQU0sU0FBUyxVQUFVLENBQUM7UUFDaEQsTUFBTSx5QkFBeUIsTUFBTTtZQUNuQyxJQUFJLE9BQU8sUUFBQSxDQUFTLGVBQUEsS0FBb0IsV0FBVztnQkFDakQsWUFBWTtZQUNkLE9BQU87Z0JBQ0wsZ0JBQWdCO1lBQ2xCO1FBQ0Y7UUFDQSxJQUFJLENBQUMsYUFBYTtZQUNoQixJQUFJLE9BQU8sV0FBVyxlQUFlLE9BQU8sZ0JBQUEsRUFBa0I7Z0JBRTVELE9BQU8sZ0JBQUEsQ0FBaUIsb0JBQW9CLHdCQUF3QixLQUFLO2dCQUN6RSxPQUFPLGdCQUFBLENBQWlCLFNBQVMsYUFBYSxLQUFLO2dCQUduRCxPQUFPLGdCQUFBLENBQWlCLFVBQVUsY0FBYyxLQUFLO2dCQUNyRCxPQUFPLGdCQUFBLENBQWlCLFdBQVcsZUFBZSxLQUFLO2dCQUN2RCxjQUFjO1lBQ2hCO1FBQ0Y7UUFDQSxNQUFNLGNBQWMsTUFBTTtZQUN4QixPQUFPLG1CQUFBLENBQW9CLFNBQVMsV0FBVztZQUMvQyxPQUFPLG1CQUFBLENBQW9CLG9CQUFvQixzQkFBc0I7WUFDckUsT0FBTyxtQkFBQSxDQUFvQixVQUFVLFlBQVk7WUFDakQsT0FBTyxtQkFBQSxDQUFvQixXQUFXLGFBQWE7WUFDbkQsY0FBYztRQUNoQjtRQUNBLE9BQU87SUFDVDtJQUNBLE9BQU8sZ0JBQWdCLGNBQWMsVUFBVTtRQUM3QztRQUNBO1FBQ0E7UUFDQTtJQUNGLENBQUMsSUFBSSxlQUFlO0FBQ3RCOztBQ3l3Qk8sU0FBUyxrQkFBa0IsQ0FBQSxFQUE4RztJQUM5SSxPQUFPLEVBQUUsSUFBQSxLQUFTLFFBQUEsU0FBQTtBQUNwQjtBQUNPLFNBQVMscUJBQXFCLENBQUEsRUFBaUg7SUFDcEosT0FBTyxFQUFFLElBQUEsS0FBUyxXQUFBLFlBQUE7QUFDcEI7QUFDTyxTQUFTLDBCQUEwQixDQUFBLEVBQTJIO0lBQ25LLE9BQU8sRUFBRSxJQUFBLEtBQVMsZ0JBQUEsaUJBQUE7QUFDcEI7QUFDTyxTQUFTLHFCQUFxQixDQUFBLEVBQXdJO0lBQzNLLE9BQU8sa0JBQWtCLENBQUMsS0FBSywwQkFBMEIsQ0FBQztBQUM1RDtBQTRETyxTQUFTLG9CQUErRCxXQUFBLEVBQStGLE1BQUEsRUFBZ0MsS0FBQSxFQUE4QixRQUFBLEVBQW9CLElBQUEsRUFBNEIsY0FBQSxFQUF1RTtJQUNqVyxJQUFJLFdBQVcsV0FBVyxHQUFHO1FBQzNCLE9BQU8sWUFBWSxRQUFzQixPQUFvQixVQUFVLElBQWdCLEVBQUUsTUFBQSxDQUFPLFlBQVksRUFBRSxHQUFBLENBQUksb0JBQW9CLEVBQUUsR0FBQSxDQUFJLGNBQWM7SUFDNUo7SUFDQSxJQUFJLE1BQU0sT0FBQSxDQUFRLFdBQVcsR0FBRztRQUM5QixPQUFPLFlBQVksR0FBQSxDQUFJLG9CQUFvQixFQUFFLEdBQUEsQ0FBSSxjQUFjO0lBQ2pFO0lBQ0EsT0FBTyxDQUFDLENBQUE7QUFDVjtBQUNBLFNBQVMsV0FBYyxDQUFBLEVBQWlDO0lBQ3RELE9BQU8sT0FBTyxNQUFNO0FBQ3RCO0FBQ08sU0FBUyxxQkFBcUIsV0FBQSxFQUFpRTtJQUNwRyxPQUFPLE9BQU8sZ0JBQWdCLFdBQVc7UUFDdkMsTUFBTTtJQUNSLElBQUk7QUFDTjs7OztBR3Z6Qk8sU0FBUyxjQUFrQyxPQUFBLEVBQTRCLFFBQUEsRUFBd0M7SUFDcEgsT0FBTyxRQUFRLEtBQUEsQ0FBTSxRQUFRO0FBQy9COztBRDNGTyxJQUFNLHFCQUFxQixPQUFPLGNBQWM7QUFDaEQsSUFBTSxnQkFBZ0IsQ0FBQyxNQUF1QixPQUFPLEdBQUEsQ0FBSSxrQkFBa0IsQ0FBQSxLQUFNO0FBd0lqRixTQUFTLG1CQU9oQixFQU9HO1FBZDJCLEVBQzVCLGtCQUFBLEVBQ0EsVUFBQSxFQUNBLGtCQUFBLEVBQ0EsYUFBQSxFQUNBLEdBQUEsRUFDQSxPQUFBLEVBQ0Y7SUFRRSxNQUFNLGlCQUFtSSxhQUFBLEdBQUEsSUFBSSxJQUFJO0lBQ2pKLE1BQU0sbUJBQWdHLGFBQUEsR0FBQSxJQUFJLElBQUk7SUFDOUcsTUFBTSxFQUNKLHNCQUFBLEVBQ0Esb0JBQUEsRUFDQSx5QkFBQSxFQUNGLEdBQUksSUFBSSxlQUFBO0lBQ1IsT0FBTztRQUNMO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0lBQ0Y7OztJQUNBLFNBQVMscUJBQXFCLFlBQUEsRUFBc0IsU0FBQSxFQUFnQjtRQUNsRSxPQUFPLENBQUMsYUFBdUI7O1lBQzdCLE1BQU0scUJBQXFCLFFBQVEsbUJBQUEsQ0FBb0IsWUFBWSxDQUFBO1lBQ25FLE1BQU0sZ0JBQWdCLG1CQUFtQjtnQkFDdkM7Z0JBQ0E7Z0JBQ0E7WUFDRixDQUFDO1lBQ0QsOEJBQU8sZUFBZSxHQUFBLENBQUksUUFBUSw0RUFBQSxDQUFJLGFBQWEsQ0FBQTtRQUNyRDtJQUNGO0lBQ0EsU0FBUyx3QkFLVCxhQUFBLEVBQXVCLHdCQUFBLEVBQWtDO1FBQ3ZELE9BQU8sQ0FBQyxhQUF1QjtnQkFDdEI7WUFBUCxpREFBd0IsR0FBQSxDQUFJLFFBQVEsZ0ZBQUEsQ0FBSSx3QkFBd0IsQ0FBQTtRQUNsRTtJQUNGO0lBQ0EsU0FBUyx5QkFBeUI7UUFDaEMsT0FBTyxDQUFDLFdBQXVCLE9BQU8sTUFBQSxDQUFPLGVBQWUsR0FBQSxDQUFJLFFBQVEsS0FBSyxDQUFDLENBQUMsRUFBRSxNQUFBLENBQU8sWUFBWTtJQUN0RztJQUNBLFNBQVMsMkJBQTJCO1FBQ2xDLE9BQU8sQ0FBQyxXQUF1QixPQUFPLE1BQUEsQ0FBTyxpQkFBaUIsR0FBQSxDQUFJLFFBQVEsS0FBSyxDQUFDLENBQUMsRUFBRSxNQUFBLENBQU8sWUFBWTtJQUN4RztJQUNBLFNBQVMsa0JBQWtCLFFBQUEsRUFBb0I7UUFDN0MsSUFBSSxRQUFRLElBQUksYUFBYSxXQUFjO1lBQ3pDLElBQUssa0JBQTBCLFNBQUEsQ0FBVyxDQUFBO1lBQzFDLE1BQU0sZ0JBQWdCLFNBQVMsSUFBSSxlQUFBLENBQWdCLDZCQUFBLENBQThCLENBQUM7WUFDakYsa0JBQTBCLFNBQUEsR0FBWTtZQUl2QyxJQUFJLE9BQU8sa0JBQWtCLFlBQVksc0VBQU8sY0FBZSxJQUFBLE1BQVMsVUFBVTtnQkFFaEYsTUFBTSxJQUFJLE1BQU0sUUFBUSxJQUFJLGFBQWEsYUFBZSx3QkFBd0IsRUFBTSxBQUFKLHlEQUE0RSxPQUFmLElBQUksV0FBVyxFQUFBO1lBRWhLO1FBQ0Y7SUFDRjtJQUNBLFNBQVMsc0JBQTJELFlBQUEsRUFBc0Isa0JBQUEsRUFBNEc7UUFDcE0sTUFBTSxjQUEwQyxTQUFDO2dCQUFLLEVBQ3BELFlBQVksSUFBQSxFQUNaLFlBQUEsRUFDQSxtQkFBQSxFQUNBLENBQUMsbUJBQUEsRUFBcUIsWUFBQSxFQUN0QixHQUFHLE1BQ0wsb0VBQUksQ0FBQzttQkFBTSxDQUFDLFVBQVUsYUFBYTtvQkEwQ1o7Z0JBekNyQixNQUFNLGdCQUFnQixtQkFBbUI7b0JBQ3ZDLFdBQVc7b0JBQ1g7b0JBQ0E7Z0JBQ0YsQ0FBQztnQkFDRCxJQUFJO2dCQUNKLE1BQU0sa0JBQWtCO29CQUN0QixHQUFHLElBQUE7b0JBQ0gsTUFBTTtvQkFDTjtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQSxjQUFjO29CQUNkO29CQUNBLENBQUMsa0JBQWtCLENBQUEsRUFBRztnQkFDeEI7Z0JBQ0EsSUFBSSxrQkFBa0Isa0JBQWtCLEdBQUc7b0JBQ3pDLFFBQVEsV0FBVyxlQUFlO2dCQUNwQyxPQUFPO29CQUNMLE1BQU0sRUFDSixTQUFBLEVBQ0EsZ0JBQUEsRUFDRixHQUFJO29CQUNKLFFBQVEsbUJBQW1CO3dCQUN6QixHQUFJLGVBQUE7d0JBQUEsb0VBQUE7d0JBQUEsZ0NBQUE7d0JBR0o7d0JBQ0E7b0JBQ0YsQ0FBQztnQkFDSDtnQkFDQSxNQUFNLFdBQVksSUFBSSxTQUFBLENBQVUsWUFBWSxDQUFBLENBQWlDLE1BQUEsQ0FBTyxHQUFHO2dCQUN2RixNQUFNLGNBQWMsU0FBUyxLQUFLO2dCQUNsQyxNQUFNLGFBQWEsU0FBUyxTQUFTLENBQUM7Z0JBQ3RDLGtCQUFrQixRQUFRO2dCQUMxQixNQUFNLEVBQ0osU0FBQSxFQUNBLEtBQUEsRUFDRixHQUFJO2dCQUNKLE1BQU0sdUJBQXVCLFdBQVcsU0FBQSxLQUFjO2dCQUN0RCxNQUFNLHFEQUE4QixHQUFBLENBQUksUUFBUSw0RUFBQSxDQUFJLGFBQWEsQ0FBQTtnQkFDakUsTUFBTSxrQkFBa0IsSUFBTSxTQUFTLFNBQVMsQ0FBQztnQkFDakQsTUFBTSxlQUF1QyxPQUFPLE1BQUEsQ0FBUSxlQUFBLDRDQUFBO2dCQUFBLHlGQUFBO2dCQUc1RCxZQUFZLElBQUEsQ0FBSyxlQUFlLElBQUksd0JBQXdCLENBQUMsZUFBQSw2RkFBQTtnQkFBQSw2REFBQTtnQkFHN0QsUUFBUSxPQUFBLENBQVEsVUFBVSxJQUFBLGlEQUFBO2dCQUFBLHdFQUFBO2dCQUcxQixRQUFRLEdBQUEsQ0FBSTtvQkFBQztvQkFBYyxXQUFXO2lCQUFDLEVBQUUsSUFBQSxDQUFLLGVBQWUsR0FBd0I7b0JBQ25GO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBLE1BQU0sU0FBUzt3QkFDYixNQUFNLFNBQVMsTUFBTTt3QkFDckIsSUFBSSxPQUFPLE9BQUEsRUFBUzs0QkFDbEIsTUFBTSxPQUFPLEtBQUE7d0JBQ2Y7d0JBQ0EsT0FBTyxPQUFPLElBQUE7b0JBQ2hCO29CQUNBLFNBQVMsSUFBTSxTQUFTLFlBQVksS0FBSzs0QkFDdkMsV0FBVzs0QkFDWCxjQUFjO3dCQUNoQixDQUFDLENBQUM7b0JBQ0YsY0FBYzt3QkFDWixJQUFJLFVBQVcsQ0FBQSxTQUFTLHVCQUF1Qjs0QkFDN0M7NEJBQ0E7d0JBQ0YsQ0FBQyxDQUFDO29CQUNKO29CQUNBLDJCQUEwQixPQUFBLEVBQThCO3dCQUN0RCxhQUFhLG1CQUFBLEdBQXNCO3dCQUNuQyxTQUFTLDBCQUEwQjs0QkFDakM7NEJBQ0E7NEJBQ0E7NEJBQ0E7d0JBQ0YsQ0FBQyxDQUFDO29CQUNKO2dCQUNGLENBQUM7Z0JBQ0QsSUFBSSxDQUFDLGdCQUFnQixDQUFDLHdCQUF3QixDQUFDLGNBQWM7b0JBQzNELE1BQU0sVUFBVSxZQUFZLGdCQUFnQixVQUFVLENBQUMsQ0FBQztvQkFDeEQsT0FBQSxDQUFRLGFBQWEsQ0FBQSxHQUFJO29CQUN6QixhQUFhLElBQUEsQ0FBSyxNQUFNO3dCQUN0QixPQUFPLE9BQUEsQ0FBUSxhQUFhLENBQUE7d0JBQzVCLElBQUksQ0FBQyxnQkFBZ0IsT0FBTyxHQUFHOzRCQUM3QixlQUFlLE1BQUEsQ0FBTyxRQUFRO3dCQUNoQztvQkFDRixDQUFDO2dCQUNIO2dCQUNBLE9BQU87WUFDVDs7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxTQUFTLG1CQUFtQixZQUFBLEVBQXNCLGtCQUFBLEVBQXlEO1FBQ3pHLE1BQU0sY0FBNEMsc0JBQXNCLGNBQWMsa0JBQWtCO1FBQ3hHLE9BQU87SUFDVDtJQUNBLFNBQVMsMkJBQTJCLFlBQUEsRUFBc0Isa0JBQUEsRUFBc0U7UUFDOUgsTUFBTSxzQkFBNEQsc0JBQXNCLGNBQWMsa0JBQWtCO1FBQ3hILE9BQU87SUFDVDtJQUNBLFNBQVMsc0JBQXNCLFlBQUEsRUFBdUQ7UUFDcEYsT0FBTyxTQUFDO2dCQUFLLEVBQ1gsUUFBUSxJQUFBLEVBQ1IsYUFBQSxFQUNGLG9FQUFJLENBQUM7bUJBQU0sQ0FBQyxVQUFVLGFBQWE7Z0JBQ2pDLE1BQU0sUUFBUSxjQUFjO29CQUMxQixNQUFNO29CQUNOO29CQUNBLGNBQWM7b0JBQ2Q7b0JBQ0E7Z0JBQ0YsQ0FBQztnQkFDRCxNQUFNLGNBQWMsU0FBUyxLQUFLO2dCQUNsQyxrQkFBa0IsUUFBUTtnQkFDMUIsTUFBTSxFQUNKLFNBQUEsRUFDQSxLQUFBLEVBQ0EsTUFBQSxFQUNGLEdBQUk7Z0JBQ0osTUFBTSxxQkFBcUIsY0FBYyxZQUFZLE1BQUEsQ0FBTyxFQUFFLElBQUEsQ0FBSyxDQUFBLE9BQUEsQ0FBUzt3QkFDMUU7b0JBQ0YsQ0FBQSxDQUFFLEdBQUcsQ0FBQSxRQUFBLENBQVU7d0JBQ2I7b0JBQ0YsQ0FBQSxDQUFFO2dCQUNGLE1BQU0sUUFBUSxNQUFNO29CQUNsQixTQUFTLHFCQUFxQjt3QkFDNUI7d0JBQ0E7b0JBQ0YsQ0FBQyxDQUFDO2dCQUNKO2dCQUNBLE1BQU0sTUFBTSxPQUFPLE1BQUEsQ0FBTyxvQkFBb0I7b0JBQzVDLEtBQUssWUFBWSxHQUFBO29CQUNqQjtvQkFDQTtvQkFDQTtvQkFDQTtnQkFDRixDQUFDO2dCQUNELE1BQU0sVUFBVSxpQkFBaUIsR0FBQSxDQUFJLFFBQVEsS0FBSyxDQUFDO2dCQUNuRCxpQkFBaUIsR0FBQSxDQUFJLFVBQVUsT0FBTztnQkFDdEMsT0FBQSxDQUFRLFNBQVMsQ0FBQSxHQUFJO2dCQUNyQixJQUFJLElBQUEsQ0FBSyxNQUFNO29CQUNiLE9BQU8sT0FBQSxDQUFRLFNBQVMsQ0FBQTtvQkFDeEIsSUFBSSxDQUFDLGdCQUFnQixPQUFPLEdBQUc7d0JBQzdCLGlCQUFpQixNQUFBLENBQU8sUUFBUTtvQkFDbEM7Z0JBQ0YsQ0FBQztnQkFDRCxJQUFJLGVBQWU7b0JBQ2pCLE9BQUEsQ0FBUSxhQUFhLENBQUEsR0FBSTtvQkFDekIsSUFBSSxJQUFBLENBQUssTUFBTTt3QkFDYixJQUFJLE9BQUEsQ0FBUSxhQUFhLENBQUEsS0FBTSxLQUFLOzRCQUNsQyxPQUFPLE9BQUEsQ0FBUSxhQUFhLENBQUE7NEJBQzVCLElBQUksQ0FBQyxnQkFBZ0IsT0FBTyxHQUFHO2dDQUM3QixpQkFBaUIsTUFBQSxDQUFPLFFBQVE7NEJBQ2xDO3dCQUNGO29CQUNGLENBQUM7Z0JBQ0g7Z0JBQ0EsT0FBTztZQUNUOztJQUNGO0FBQ0Y7O0FFclpPLElBQU0sbUJBQU4sZ0xBQStCLGNBQUEsQ0FBWTtJQUNoRCxZQUFZLE1BQUEsRUFBMkQsS0FBQSxFQUE0QixVQUFBLEVBQW9DLE9BQUEsQ0FBYztRQUNuSixLQUFBLENBQU0sTUFBTTtRQUR5RCxJQUFBLENBQUEsS0FBQSxHQUFBO1FBQTRCLElBQUEsQ0FBQSxVQUFBLEdBQUE7UUFBb0MsSUFBQSxDQUFBLE9BQUEsR0FBQTtJQUV2STtBQUNGO0FBQ0EsZUFBc0IsZ0JBQWlELE1BQUEsRUFBZ0IsSUFBQSxFQUFlLFVBQUEsRUFBb0IsTUFBQSxFQUE0RDtJQUNwTCxNQUFNLFNBQVMsTUFBTSxNQUFBLENBQU8sV0FBVyxDQUFBLENBQUUsUUFBQSxDQUFTLElBQUk7SUFDdEQsSUFBSSxPQUFPLE1BQUEsRUFBUTtRQUNqQixNQUFNLElBQUksaUJBQWlCLE9BQU8sTUFBQSxFQUFRLE1BQU0sWUFBWSxNQUFNO0lBQ3BFO0lBQ0EsT0FBTyxPQUFPLEtBQUE7QUFDaEI7O0FIZ0VBLFNBQVMseUJBQXlCLG9CQUFBLEVBQStCO0lBQy9ELE9BQU87QUFDVDtBQThCTyxJQUFNLHFCQUFxQjtRQUFpQyx1RUFBUyxDQUFDLE1BRXhFO0lBQ0gsT0FBTztRQUNMLEdBQUcsR0FBQTtRQUNILCtMQUFDLG9CQUFnQixDQUFBLEVBQUc7SUFDdEI7QUFDRjtBQUNPLFNBQVMsaUJBYWhCLEVBV0c7VUF2QkQsV0FBQSxFQUNBLFNBQUEsRUFDQSxTQUFTLEVBQ1AsbUJBQUEsRUFDRixFQUNBLGtCQUFBLEVBQ0EsR0FBQSxFQUNBLGFBQUEsRUFDQSxTQUFBLEVBQ0EsZUFBQSxFQUNBLG9CQUFvQix3QkFBQSxFQUNwQixzQkFBc0IsMEJBQUEsRUFDeEIsR0FiZ0k7SUEwQjlILE1BQU0saUJBQWtFLENBQUMsY0FBYyxLQUFLLFNBQVMsaUJBQW1CLENBQUMsVUFBVSxhQUFhO1lBQzlJLE1BQU0scUJBQXFCLG1CQUFBLENBQW9CLFlBQVksQ0FBQTtZQUMzRCxNQUFNLGdCQUFnQixtQkFBbUI7Z0JBQ3ZDLFdBQVc7Z0JBQ1g7Z0JBQ0E7WUFDRixDQUFDO1lBQ0QsU0FBUyxJQUFJLGVBQUEsQ0FBZ0Isa0JBQUEsQ0FBbUI7Z0JBQzlDO2dCQUNBO1lBQ0YsQ0FBQyxDQUFDO1lBQ0YsSUFBSSxDQUFDLGdCQUFnQjtnQkFDbkI7WUFDRjtZQUNBLE1BQU0sV0FBVyxJQUFJLFNBQUEsQ0FBVSxZQUFZLENBQUEsQ0FBRSxNQUFBLENBQU8sR0FBRyxFQUFBLDhCQUFBO1lBRXZELFNBQVM7WUFDVCxNQUFNLGVBQWUsb0JBQW9CLG1CQUFtQixZQUFBLEVBQWMsU0FBUyxJQUFBLEVBQU0sS0FBQSxHQUFXLEtBQUssQ0FBQyxHQUFHLGFBQWE7WUFDMUgsU0FBUyxJQUFJLGVBQUEsQ0FBZ0IsZ0JBQUEsQ0FBaUI7Z0JBQUM7b0JBQzdDO29CQUNBO2dCQUNGLENBQUM7YUFBQyxDQUFDO1FBQ0w7SUFDQSxTQUFTLFdBQWMsS0FBQSxFQUFpQixJQUFBO2tCQUFTLGlFQUFNLEdBQWE7UUFDbEUsTUFBTSxXQUFXO1lBQUMsTUFBTTtlQUFHLEtBQUs7U0FBQTtRQUNoQyxPQUFPLE9BQU8sU0FBUyxNQUFBLEdBQVMsTUFBTSxTQUFTLEtBQUEsQ0FBTSxHQUFHLENBQUEsQ0FBRSxJQUFJO0lBQ2hFO0lBQ0EsU0FBUyxTQUFZLEtBQUEsRUFBaUIsSUFBQTtrQkFBUyxpRUFBTSxHQUFhO1FBQ2hFLE1BQU0sV0FBVyxDQUFDO2VBQUc7WUFBTyxJQUFJO1NBQUE7UUFDaEMsT0FBTyxPQUFPLFNBQVMsTUFBQSxHQUFTLE1BQU0sU0FBUyxLQUFBLENBQU0sQ0FBQyxJQUFJO0lBQzVEO0lBQ0EsTUFBTSxrQkFBb0UsU0FBQyxjQUFjLEtBQUs7WUFBYyxrRkFBaUI7ZUFBUyxDQUFDLFVBQVUsYUFBYTtZQUM1SixNQUFNLHFCQUFxQixJQUFJLFNBQUEsQ0FBVSxZQUFZLENBQUE7WUFDckQsTUFBTSxlQUFlLG1CQUFtQixNQUFBLENBQU8sR0FBRyxFQUFBLDhCQUFBO1lBRWxELFNBQVM7WUFDVCxNQUFNLE1BQXVCO2dCQUMzQixTQUFTLENBQUMsQ0FBQTtnQkFDVixnQkFBZ0IsQ0FBQyxDQUFBO2dCQUNqQixNQUFNLElBQU0sU0FBUyxJQUFJLElBQUEsQ0FBSyxjQUFBLENBQWUsY0FBYyxLQUFLLElBQUksY0FBQSxFQUFnQixjQUFjLENBQUM7WUFDckc7WUFDQSxJQUFJLGFBQWEsTUFBQSxLQUFBLGdCQUFBLGlCQUFBLEtBQXNDO2dCQUNyRCxPQUFPO1lBQ1Q7WUFDQSxJQUFJO1lBQ0osSUFBSSxVQUFVLGNBQWM7Z0JBQzFCLElBQUksNkpBQUEsRUFBWSxhQUFhLElBQUksR0FBRztvQkFDbEMsTUFBTSxDQUFDLE9BQU8sU0FBUyxjQUFjLENBQUEsa0pBQUkscUJBQUEsRUFBbUIsYUFBYSxJQUFBLEVBQU0sWUFBWTtvQkFDM0YsSUFBSSxPQUFBLENBQVEsSUFBQSxDQUFLLEdBQUcsT0FBTztvQkFDM0IsSUFBSSxjQUFBLENBQWUsSUFBQSxDQUFLLEdBQUcsY0FBYztvQkFDekMsV0FBVztnQkFDYixPQUFPO29CQUNMLFdBQVcsYUFBYSxhQUFhLElBQUk7b0JBQ3pDLElBQUksT0FBQSxDQUFRLElBQUEsQ0FBSzt3QkFDZixJQUFJO3dCQUNKLE1BQU0sQ0FBQyxDQUFBO3dCQUNQLE9BQU87b0JBQ1QsQ0FBQztvQkFDRCxJQUFJLGNBQUEsQ0FBZSxJQUFBLENBQUs7d0JBQ3RCLElBQUk7d0JBQ0osTUFBTSxDQUFDLENBQUE7d0JBQ1AsT0FBTyxhQUFhLElBQUE7b0JBQ3RCLENBQUM7Z0JBQ0g7WUFDRjtZQUNBLElBQUksSUFBSSxPQUFBLENBQVEsTUFBQSxLQUFXLEdBQUc7Z0JBQzVCLE9BQU87WUFDVDtZQUNBLFNBQVMsSUFBSSxJQUFBLENBQUssY0FBQSxDQUFlLGNBQWMsS0FBSyxJQUFJLE9BQUEsRUFBUyxjQUFjLENBQUM7WUFDaEYsT0FBTztRQUNUOztJQUNBLE1BQU0sa0JBQTRELENBQUMsY0FBYyxLQUFLLFFBQVUsQ0FBQSxhQUFZO1lBRTFHLE1BQU0sTUFBTSxTQUFVLElBQUksU0FBQSxDQUFVLFlBQVksQ0FBQSxDQUE4RSxRQUFBLENBQVMsS0FBSztnQkFDMUksV0FBVztnQkFDWCxjQUFjO2dCQUNkLENBQUMsa0JBQWtCLENBQUEsRUFBRyxJQUFBLENBQU87d0JBQzNCLE1BQU07b0JBQ1IsQ0FBQTtZQUNGLENBQUMsQ0FBQztZQUNGLE9BQU87UUFDVDtJQUNBLE1BQU0sa0NBQWtDLENBQUMsb0JBQTRELHVCQUEwRjtRQUM3TCxPQUFPLG1CQUFtQixLQUFBLElBQVMsa0JBQUEsQ0FBbUIsa0JBQWtCLENBQUEsR0FBSSxrQkFBQSxDQUFtQixrQkFBa0IsQ0FBQSxHQUEwQjtJQUM3STtJQUdBLE1BQU0sa0JBRUQsT0FBTztZQUFLLEVBQ2YsTUFBQSxFQUNBLEtBQUEsRUFDQSxlQUFBLEVBQ0EsZ0JBQUEsRUFDQSxRQUFBLEVBQ0EsUUFBQSxFQUNBLEtBQUEsRUFDRixLQUFNO1FBQ0osTUFBTSxxQkFBcUIsbUJBQUEsQ0FBb0IsSUFBSSxZQUFZLENBQUE7UUFDL0QsTUFBTSxFQUNKLFVBQUEsRUFDQSx1QkFBdUIsMEJBQUEsRUFDekIsR0FBSTtRQUNKLElBQUk7WUFDRixJQUFJLG9CQUFvQixnQ0FBZ0Msb0JBQW9CLG1CQUFtQjtZQUMvRixNQUFNLGVBQWU7Z0JBQ25CO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBLFVBQVUsSUFBSSxZQUFBO2dCQUNkLE1BQU0sSUFBSSxJQUFBO2dCQUNWLFFBQVEsSUFBSSxJQUFBLEtBQVMsVUFBVSxjQUFjLEtBQUssU0FBUyxDQUFDLElBQUksS0FBQTtnQkFDaEUsZUFBZSxJQUFJLElBQUEsS0FBUyxVQUFVLElBQUksYUFBQSxHQUFnQixLQUFBO1lBQzVEO1lBQ0EsTUFBTSxlQUFlLElBQUksSUFBQSxLQUFTLFVBQVUsR0FBQSxDQUFJLGtCQUFrQixDQUFBLEdBQUksS0FBQTtZQUN0RSxJQUFJO1lBSUosTUFBTSxZQUFZLE9BQU8sTUFBc0MsT0FBZ0IsVUFBa0IsYUFBa0Q7Z0JBR2pKLElBQUksU0FBUyxRQUFRLEtBQUssS0FBQSxDQUFNLE1BQUEsRUFBUTtvQkFDdEMsT0FBTyxRQUFRLE9BQUEsQ0FBUTt3QkFDckI7b0JBQ0YsQ0FBQztnQkFDSDtnQkFDQSxNQUFNLGdCQUFvRDtvQkFDeEQsVUFBVSxJQUFJLFlBQUE7b0JBQ2QsV0FBVztnQkFDYjtnQkFDQSxNQUFNLGVBQWUsTUFBTSxlQUFlLGFBQWE7Z0JBQ3ZELE1BQU0sUUFBUSxXQUFXLGFBQWE7Z0JBQ3RDLE9BQU87b0JBQ0wsTUFBTTt3QkFDSixPQUFPLE1BQU0sS0FBSyxLQUFBLEVBQU8sYUFBYSxJQUFBLEVBQU0sUUFBUTt3QkFDcEQsWUFBWSxNQUFNLEtBQUssVUFBQSxFQUFZLE9BQU8sUUFBUTtvQkFDcEQ7b0JBQ0EsTUFBTSxhQUFhLElBQUE7Z0JBQ3JCO1lBQ0Y7WUFJQSxlQUFlLGVBQWUsYUFBQSxFQUFtRDtnQkFDL0UsSUFBSTtnQkFDSixNQUFNLEVBQ0osWUFBQSxFQUNBLFNBQUEsRUFDQSxpQkFBQSxFQUNBLGNBQUEsRUFDRixHQUFJO2dCQUNKLElBQUksYUFBYSxDQUFDLHNCQUFzQjtvQkFDdEMsZ0JBQWdCLE1BQU0sZ0JBQWdCLFdBQVcsZUFBZSxhQUFhLENBQUM7Z0JBRWhGO2dCQUNBLElBQUksY0FBYztvQkFFaEIsU0FBUyxhQUFhO2dCQUN4QixPQUFBLElBQVcsbUJBQW1CLEtBQUEsRUFBTztvQkFDbkMsU0FBUyxNQUFNLFVBQVUsbUJBQW1CLEtBQUEsQ0FBTSxhQUFvQixHQUFHLGNBQWMsWUFBbUI7Z0JBQzVHLE9BQU87b0JBQ0wsU0FBUyxNQUFNLG1CQUFtQixPQUFBLENBQVEsZUFBc0IsY0FBYyxjQUFxQixDQUFBQyxPQUFPLFVBQVVBLE1BQUssY0FBYyxZQUFtQixDQUFDO2dCQUM3SjtnQkFDQSxJQUFJLE9BQU8sMktBQUEsS0FBWSxlQUFlLFFBQVEsSUFBSSx3Q0FBYSxlQUFlO29CQUM1RSxNQUFNLE9BQU8sbUJBQW1CLEtBQUEsR0FBUSxnQkFBZ0I7b0JBQ3hELElBQUk7b0JBQ0osSUFBSSxDQUFDLFFBQVE7d0JBQ1gsTUFBTSxHQUFPLE9BQUosSUFBSSxFQUFBO29CQUNmLE9BQUEsSUFBVyxPQUFPLFdBQVcsVUFBVTt3QkFDckMsTUFBTSxHQUFPLE9BQUosSUFBSSxFQUFBO29CQUNmLE9BQUEsSUFBVyxPQUFPLEtBQUEsSUFBUyxPQUFPLElBQUEsRUFBTTt3QkFDdEMsTUFBTSxHQUFPLE9BQUosSUFBSSxFQUFBO29CQUNmLE9BQUEsSUFBVyxPQUFPLEtBQUEsS0FBVSxLQUFBLEtBQWEsT0FBTyxJQUFBLEtBQVMsS0FBQSxHQUFXO3dCQUNsRSxNQUFNLEdBQU8sT0FBSixJQUFJLEVBQUE7b0JBQ2YsT0FBTzt3QkFDTCxLQUFBLE1BQVcsT0FBTyxPQUFPLElBQUEsQ0FBSyxNQUFNLEVBQUc7NEJBQ3JDLElBQUksUUFBUSxXQUFXLFFBQVEsVUFBVSxRQUFRLFFBQVE7Z0NBQ3ZELE1BQU0saUNBQTBCLElBQUksRUFBQSw4QkFBZ0MsT0FBSCxHQUFHLEVBQUE7Z0NBQ3BFOzRCQUNGO3dCQUNGO29CQUNGO29CQUNBLElBQUksS0FBSzt3QkFDUCxRQUFRLEtBQUEsQ0FBTSwyQ0FDTixHQUFHLElBRDhDLElBQUksWUFBWSxFQUFBLHlCQUM5RCxZQUFBLDZNQUVrQixNQUFNO29CQUNyQztnQkFDRjtnQkFDQSxJQUFJLE9BQU8sS0FBQSxDQUFPLENBQUEsTUFBTSxJQUFJLGFBQWEsT0FBTyxLQUFBLEVBQU8sT0FBTyxJQUFJO2dCQUNsRSxJQUFJLEVBQ0YsSUFBQSxFQUNGLEdBQUk7Z0JBQ0osSUFBSSxxQkFBcUIsQ0FBQyxzQkFBc0I7b0JBQzlDLE9BQU8sTUFBTSxnQkFBZ0IsbUJBQW1CLE9BQU8sSUFBQSxFQUFNLHFCQUFxQixPQUFPLElBQUk7Z0JBQy9GO2dCQUNBLElBQUksc0JBQXNCLE1BQU0sa0JBQWtCLE1BQU0sT0FBTyxJQUFBLEVBQU0sYUFBYTtnQkFDbEYsSUFBSSxrQkFBa0IsQ0FBQyxzQkFBc0I7b0JBQzNDLHNCQUFzQixNQUFNLGdCQUFnQixnQkFBZ0IscUJBQXFCLGtCQUFrQixPQUFPLElBQUk7Z0JBQ2hIO2dCQUNBLE9BQU87b0JBQ0wsR0FBRyxNQUFBO29CQUNILE1BQU07Z0JBQ1I7WUFDRjtZQUNBLElBQUksSUFBSSxJQUFBLEtBQVMsV0FBVywwQkFBMEIsb0JBQW9CO29CQWtCckQ7Z0JBaEJuQixNQUFNLEVBQ0osb0JBQUEsRUFDRixHQUFJO2dCQUdKLE1BQU0sRUFDSixXQUFXLFFBQUEsRUFDYixHQUFJO2dCQUNKLElBQUk7Z0JBSUosTUFBTSxZQUFZO29CQUNoQixPQUFPLENBQUMsQ0FBQTtvQkFDUixZQUFZLENBQUMsQ0FBQTtnQkFDZjtnQkFDQSxNQUFNLHNEQUF1QixnQkFBQSxDQUFpQixTQUFTLEdBQUcsSUFBSSxhQUFhLDZGQUFHLElBQUE7Z0JBTTlFLE1BQU0sOEJBQUEsbUJBQUE7Z0JBRU4sY0FBYyxLQUFLLFNBQVMsQ0FBQyxLQUFLLENBQUUsSUFBbUMsU0FBQTtnQkFDdkUsTUFBTSxlQUFnQiwrQkFBK0IsQ0FBQyxhQUFhLFlBQVk7Z0JBSS9FLElBQUksZUFBZSxPQUFPLElBQUksU0FBQSxJQUFhLGFBQWEsS0FBQSxDQUFNLE1BQUEsRUFBUTtvQkFDcEUsTUFBTSxXQUFXLElBQUksU0FBQSxLQUFjO29CQUNuQyxNQUFNLGNBQWMsV0FBVyx1QkFBdUI7b0JBQ3RELE1BQU0sUUFBUSxZQUFZLHNCQUFzQixjQUFjLElBQUksWUFBWTtvQkFDOUUsU0FBUyxNQUFNLFVBQVUsY0FBYyxPQUFPLFVBQVUsUUFBUTtnQkFDbEUsT0FBTztvQkFHTCxNQUFNLEVBQ0osbUJBQW1CLHFCQUFxQixnQkFBQSxFQUMxQyxHQUFJOztvQkFLSixNQUFNLDZDQUFtQixtRUFBWSxVQUFBLDJFQUFjLENBQUMsQ0FBQTs7b0JBQ3BELE1BQU0sdURBQWlCLENBQWlCLENBQUMsQ0FBQSw4Q0FBbEIscUJBQXVCO29CQUM5QyxNQUFNLGFBQWEsaUJBQWlCLE1BQUE7b0JBR3BDLFNBQVMsTUFBTSxVQUFVLGNBQWMsZ0JBQWdCLFFBQVE7b0JBQy9ELElBQUksY0FBYzt3QkFHaEIsU0FBUzs0QkFDUCxNQUFPLE9BQU8sSUFBQSxDQUF3QyxLQUFBLENBQU0sQ0FBQyxDQUFBO3dCQUMvRDtvQkFDRjtvQkFHQSxJQUFBLElBQVMsSUFBSSxHQUFHLElBQUksWUFBWSxJQUFLO3dCQUNuQyxNQUFNLFFBQVEsaUJBQWlCLHNCQUFzQixPQUFPLElBQUEsRUFBd0MsSUFBSSxZQUFZO3dCQUNwSCxTQUFTLE1BQU0sVUFBVSxPQUFPLElBQUEsRUFBd0MsT0FBTyxRQUFRO29CQUN6RjtnQkFDRjtnQkFDQSx3QkFBd0I7WUFDMUIsT0FBTztnQkFFTCx3QkFBd0IsTUFBTSxlQUFlLElBQUksWUFBWTtZQUMvRDtZQUNBLElBQUksY0FBYyxDQUFDLHdCQUF3QixzQkFBc0IsSUFBQSxFQUFNO2dCQUNyRSxzQkFBc0IsSUFBQSxHQUFPLE1BQU0sZ0JBQWdCLFlBQVksc0JBQXNCLElBQUEsRUFBTSxjQUFjLHNCQUFzQixJQUFJO1lBQ3JJO1lBR0EsT0FBTyxpQkFBaUIsc0JBQXNCLElBQUEsRUFBTSxtQkFBbUI7Z0JBQ3JFLG9CQUFvQixLQUFLLEdBQUEsQ0FBSTtnQkFDN0IsZUFBZSxzQkFBc0IsSUFBQTtZQUN2QyxDQUFDLENBQUM7UUFDSixFQUFBLE9BQVMsT0FBTztZQUNkLElBQUksY0FBYztZQUNsQixJQUFJLHVCQUF1QixjQUFjO2dCQUN2QyxJQUFJLHlCQUF5QixnQ0FBZ0Msb0JBQW9CLHdCQUF3QjtnQkFDekcsTUFBTSxFQUNKLHNCQUFBLEVBQ0EsbUJBQUEsRUFDRixHQUFJO2dCQUNKLElBQUksRUFDRixLQUFBLEVBQ0EsSUFBQSxFQUNGLEdBQUk7Z0JBQ0osSUFBSTtvQkFDRixJQUFJLDBCQUEwQixDQUFDLHNCQUFzQjt3QkFDbkQsUUFBUSxNQUFNLGdCQUFnQix3QkFBd0IsT0FBTywwQkFBMEIsSUFBSTtvQkFDN0Y7b0JBQ0EsSUFBSSxjQUFjLENBQUMsc0JBQXNCO3dCQUN2QyxPQUFPLE1BQU0sZ0JBQWdCLFlBQVksTUFBTSxjQUFjLElBQUk7b0JBQ25FO29CQUNBLElBQUksMkJBQTJCLE1BQU0sdUJBQXVCLE9BQU8sTUFBTSxJQUFJLFlBQVk7b0JBQ3pGLElBQUksdUJBQXVCLENBQUMsc0JBQXNCO3dCQUNoRCwyQkFBMkIsTUFBTSxnQkFBZ0IscUJBQXFCLDBCQUEwQix1QkFBdUIsSUFBSTtvQkFDN0g7b0JBQ0EsT0FBTyxnQkFBZ0IsMEJBQTBCLG1CQUFtQjt3QkFDbEUsZUFBZTtvQkFDakIsQ0FBQyxDQUFDO2dCQUNKLEVBQUEsT0FBUyxHQUFHO29CQUNWLGNBQWM7Z0JBQ2hCO1lBQ0Y7WUFDQSxJQUFJO2dCQUNGLElBQUksdUJBQXVCLGtCQUFrQjt3QkFPM0M7b0JBTkEsTUFBTSxPQUEwQjt3QkFDOUIsVUFBVSxJQUFJLFlBQUE7d0JBQ2QsS0FBSyxJQUFJLFlBQUE7d0JBQ1QsTUFBTSxJQUFJLElBQUE7d0JBQ1YsZUFBZSxJQUFJLElBQUEsS0FBUyxVQUFVLElBQUksYUFBQSxHQUFnQixLQUFBO29CQUM1RDtxQkFDQSxzQ0FBQSxtQkFBbUIsZUFBQSxjQUFuQiwwREFBQSx5Q0FBQSxvQkFBcUMsYUFBYSxJQUFJO29CQUN0RCw0QkFBQSxzQ0FBQSxnQkFBa0IsYUFBYSxJQUFJO29CQUNuQyxNQUFNLEVBQ0oscUJBQXFCLHdCQUFBLEVBQ3ZCLEdBQUk7b0JBQ0osSUFBSSxvQkFBb0I7d0JBQ3RCLE9BQU8sZ0JBQWdCLG1CQUFtQixhQUFhLElBQUksR0FBRyxtQkFBbUI7NEJBQy9FLGVBQWUsWUFBWSxPQUFBO3dCQUM3QixDQUFDLENBQUM7b0JBQ0o7Z0JBQ0Y7WUFDRixFQUFBLE9BQVMsR0FBRztnQkFDVixjQUFjO1lBQ2hCO1lBQ0EsSUFBSSx3S0FBTyxVQUFBLEtBQVksZUFBZSxRQUFRLElBQUksd0NBQWEsY0FBYztnQkFDM0UsUUFBUSxLQUFBLENBQU0sc0VBQXNGLE9BQWhCLElBQUksWUFBWSxFQUFBLHdGQUMxQixXQUFXO1lBQ3ZGLE9BQU87Z0JBQ0wsUUFBUSxLQUFBLENBQU0sV0FBVztZQUMzQjtZQUNBLE1BQU07UUFDUjtJQUNGO0lBQ0EsU0FBUyxjQUFjLEdBQUEsRUFBb0IsS0FBQSxFQUE0QztRQUNyRixNQUFNLGVBQWUsVUFBVSxnQkFBQSxDQUFpQixPQUFPLElBQUksYUFBYTtRQUN4RSxNQUFNLDhCQUE4QixVQUFVLFlBQUEsQ0FBYSxLQUFLLEVBQUUseUJBQUE7UUFDbEUsTUFBTSwyRUFBZSxhQUFjLGtCQUFBOztRQUNuQyxNQUFNLHNDQUFpQixZQUFBLDZDQUFKLG9CQUFxQixJQUFJLFNBQUEsSUFBYTtRQUN6RCxJQUFJLFlBQVk7WUFFZCxPQUFPLGVBQWUsUUFBQSxDQUFTLE9BQU8sYUFBQSxHQUFBLElBQUksS0FBSyxDQUFDLElBQUksT0FBTyxZQUFZLENBQUEsSUFBSyxPQUFRO1FBQ3RGO1FBQ0EsT0FBTztJQUNUO0lBQ0EsTUFBTSxtQkFBbUIsTUFBd0U7UUFDL0YsTUFBTSx5TkFBc0IsbUJBQUEsRUFFekIsR0FBYyxPQUFYLFdBQVcsRUFBQSxrQkFBaUIsaUJBQWlCO1lBQ2pELGdCQUFlLEtBRWY7c0JBREUsR0FBQSxFQUNGLEVBQUc7Z0JBQ0QsTUFBTSxxQkFBcUIsbUJBQUEsQ0FBb0IsSUFBSSxZQUFZLENBQUE7Z0JBQy9ELE9BQU8sbUJBQW1CO29CQUN4QixrQkFBa0IsS0FBSyxHQUFBLENBQUk7b0JBQzNCLEdBQUksMEJBQTBCLGtCQUFrQixJQUFJO3dCQUNsRCxXQUFZLElBQW1DLFNBQUE7b0JBQ2pELElBQUksQ0FBQyxDQUFBO2dCQUNQLENBQUM7WUFDSDtZQUNBLFdBQVUsYUFBQSxPQUVWLEVBQUc7b0JBRnNCLEVBQ3ZCLFFBQUEsRUFDRjs7Z0JBQ0UsTUFBTSxRQUFRLFNBQVM7Z0JBQ3ZCLE1BQU0sZUFBZSxVQUFVLGdCQUFBLENBQWlCLE9BQU8sY0FBYyxhQUFhO2dCQUNsRixNQUFNLDJFQUFlLGFBQWMsa0JBQUE7Z0JBQ25DLE1BQU0sYUFBYSxjQUFjLFlBQUE7Z0JBQ2pDLE1BQU0sMEVBQWMsYUFBYyxZQUFBO2dCQUNsQyxNQUFNLHFCQUFxQixtQkFBQSxDQUFvQixjQUFjLFlBQVksQ0FBQTtnQkFDekUsTUFBTSxZQUFhLGNBQTZDLFNBQUE7Z0JBS2hFLElBQUksY0FBYyxhQUFhLEdBQUc7b0JBQ2hDLE9BQU87Z0JBQ1Q7Z0JBR0EsaUVBQUksYUFBYyxNQUFBLE1BQVcsV0FBVztvQkFDdEMsT0FBTztnQkFDVDtnQkFHQSxJQUFJLGNBQWMsZUFBZSxLQUFLLEdBQUc7b0JBQ3ZDLE9BQU87Z0JBQ1Q7Z0JBQ0EsSUFBSSxrQkFBa0Isa0JBQWtCLCtFQUFLLHNEQUFvQixZQUFBLCtIQUFlO29CQUM5RTtvQkFDQTtvQkFDQSxlQUFlO29CQUNmO2dCQUNGLENBQUMsSUFBRztvQkFDRixPQUFPO2dCQUNUO2dCQUdBLElBQUksZ0JBQWdCLENBQUMsV0FBVztvQkFFOUIsT0FBTztnQkFDVDtnQkFDQSxPQUFPO1lBQ1Q7WUFDQSw0QkFBNEI7UUFDOUIsQ0FBQztRQUNELE9BQU87SUFDVDtJQUNBLE1BQU0sYUFBYSxpQkFBZ0M7SUFDbkQsTUFBTSxxQkFBcUIsaUJBQTZDO0lBQ3hFLE1BQU0sbU5BQWdCLG1CQUFBLEVBRW5CLEdBQWMsT0FBWCxXQUFXLEVBQUEscUJBQW9CLGlCQUFpQjtRQUNwRCxpQkFBaUI7WUFDZixPQUFPLG1CQUFtQjtnQkFDeEIsa0JBQWtCLEtBQUssR0FBQSxDQUFJO1lBQzdCLENBQUM7UUFDSDtJQUNGLENBQUM7SUFDRCxNQUFNLGNBQWMsQ0FBQyxVQUVoQixXQUFXO0lBQ2hCLE1BQU0sWUFBWSxDQUFDLFVBRWQsaUJBQWlCO0lBQ3RCLE1BQU0sV0FBVyxDQUErQyxjQUE0QixLQUFVLFVBQXlFLENBQUMsVUFBd0MsYUFBd0I7WUFDOU8sTUFBTSxRQUFRLFlBQVksT0FBTyxLQUFLLFFBQVEsS0FBQTtZQUM5QyxNQUFNLFNBQVMsVUFBVSxPQUFPLEtBQUssUUFBUSxXQUFBO1lBQzdDLE1BQU0sY0FBYztvQkFBQ0MsMEVBQWlCLFNBQVM7Z0JBQzdDLE1BQU1DLFdBQVU7b0JBQ2QsY0FBY0Q7b0JBQ2QsWUFBWTtnQkFDZDtnQkFDQSxPQUFRLElBQUksU0FBQSxDQUFVLFlBQVksQ0FBQSxDQUFpQyxRQUFBLENBQVMsS0FBS0MsUUFBTztZQUMxRjtZQUNBLE1BQU0sbUJBQW9CLElBQUksU0FBQSxDQUFVLFlBQVksQ0FBQSxDQUFpQyxNQUFBLENBQU8sR0FBRyxFQUFFLFNBQVMsQ0FBQztZQUMzRyxJQUFJLE9BQU87Z0JBQ1QsU0FBUyxZQUFZLENBQUM7WUFDeEIsT0FBQSxJQUFXLFFBQVE7Z0JBQ2pCLE1BQU0sc0ZBQWtCLGlCQUFrQixrQkFBQTtnQkFDMUMsSUFBSSxDQUFDLGlCQUFpQjtvQkFDcEIsU0FBUyxZQUFZLENBQUM7b0JBQ3RCO2dCQUNGO2dCQUNBLE1BQU0sa0JBQUEsQ0FBbUIsT0FBTyxhQUFBLEdBQUEsSUFBSSxLQUFLLENBQUMsSUFBSSxPQUFPLElBQUksS0FBSyxlQUFlLENBQUMsQ0FBQSxJQUFLLE9BQVE7Z0JBQzNGLElBQUksaUJBQWlCO29CQUNuQixTQUFTLFlBQVksQ0FBQztnQkFDeEI7WUFDRixPQUFPO2dCQUVMLFNBQVMsWUFBWSxLQUFLLENBQUM7WUFDN0I7UUFDRjtJQUNBLFNBQVMsZ0JBQWdCLFlBQUEsRUFBc0I7UUFDN0MsT0FBTyxDQUFDOztvQkFBeUMsdUVBQVEsSUFBQSxrRkFBTSxHQUFBLHNFQUFLLFlBQUEsTUFBaUI7O0lBQ3ZGO0lBQ0EsU0FBUyx1QkFBaUosS0FBQSxFQUFjLFlBQUEsRUFBc0I7UUFDNUwsT0FBTztZQUNMLGlOQUFjLFVBQUEscU1BQVEsWUFBQSxFQUFVLEtBQUssR0FBRyxnQkFBZ0IsWUFBWSxDQUFDO1lBQ3JFLG9CQUFnQix5TUFBQSxxTUFBUSxjQUFBLEVBQVksS0FBSyxHQUFHLGdCQUFnQixZQUFZLENBQUM7WUFDekUsa05BQWUsVUFBQSxxTUFBUSxhQUFBLEVBQVcsS0FBSyxHQUFHLGdCQUFnQixZQUFZLENBQUM7UUFDekU7SUFDRjtJQUNBLE9BQU87UUFDTDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0lBQ0Y7QUFDRjtBQUNPLFNBQVMsaUJBQWlCLE9BQUEsRUFBZ0UsS0FHakcsRUFBbUMsUUFBQSxFQUF3QztVQUZ6RSxLQUFBLEVBQ0EsVUFBQSxFQUNGO0lBQ0UsTUFBTSxZQUFZLE1BQU0sTUFBQSxHQUFTO0lBQ2pDLE9BQU8sUUFBUSxnQkFBQSxDQUFpQixLQUFBLENBQU0sU0FBUyxDQUFBLEVBQUcsT0FBTyxVQUFBLENBQVcsU0FBUyxDQUFBLEVBQUcsWUFBWSxRQUFRO0FBQ3RHO0FBQ08sU0FBUyxxQkFBcUIsT0FBQSxPQUdyQyxFQUFtQyxRQUFBLEVBQXdDO1VBRnpFLEtBQUEsRUFDQSxVQUFBLEVBQ0YsR0FIcUc7O0lBSW5HLGdEQUFlLG9CQUFBLGNBQVIsZ0dBQStCLEtBQUEsQ0FBTSxDQUFDLENBQUEsRUFBRyxPQUFPLFVBQUEsQ0FBVyxDQUFDLENBQUEsRUFBRyxZQUFZLFFBQVE7QUFDNUY7QUFDTyxTQUFTLHlCQUF5QixNQUFBLEVBQXFKLElBQUEsRUFBMEMsbUJBQUEsRUFBMEMsYUFBQSxFQUErQjtJQUMvUyxPQUFPLG9CQUFvQixtQkFBQSxDQUFvQixPQUFPLElBQUEsQ0FBSyxHQUFBLENBQUksWUFBWSxDQUFBLENBQUUsSUFBSSxDQUFBLHFNQUFpRCxjQUFBLEVBQVksTUFBTSxJQUFJLE9BQU8sT0FBQSxHQUFVLEtBQUEsc01BQVcsc0JBQUEsRUFBb0IsTUFBTSxJQUFJLE9BQU8sT0FBQSxHQUFVLEtBQUEsR0FBVyxPQUFPLElBQUEsQ0FBSyxHQUFBLENBQUksWUFBQSxFQUFjLG1CQUFtQixPQUFPLElBQUEsR0FBTyxPQUFPLElBQUEsQ0FBSyxhQUFBLEdBQWdCLEtBQUEsR0FBVyxhQUFhO0FBQ25XOzs7QUl6bEJBLFNBQVMsNEJBQTRCLEtBQUEsRUFBd0IsYUFBQSxFQUE4QixNQUFBLEVBQTZFO0lBQ3RLLE1BQU0sV0FBVyxLQUFBLENBQU0sYUFBYSxDQUFBO0lBQ3BDLElBQUksVUFBVTtRQUNaLE9BQU8sUUFBUTtJQUNqQjtBQUNGO0FBV08sU0FBUyxvQkFBb0IsRUFBQSxFQVFiO1FBQ3JCO0lBQUEsT0FBQSxDQUFBLE9BQVEsU0FBUyxLQUFLLEdBQUcsR0FBQSxDQUFJLGFBQUEsR0FBZ0IsR0FBRyxhQUFBLGNBQWhELGtCQUFBLE9BQWtFLEdBQUcsU0FBQTtBQUN2RTtBQUNBLFNBQVMsK0JBQStCLEtBQUEsRUFBMkIsRUFBQSxFQUtoRSxNQUFBLEVBQW1EO0lBQ3BELE1BQU0sV0FBVyxLQUFBLENBQU0sb0JBQW9CLEVBQUUsQ0FBQyxDQUFBO0lBQzlDLElBQUksVUFBVTtRQUNaLE9BQU8sUUFBUTtJQUNqQjtBQUNGO0FBQ0EsSUFBTSxlQUFlLENBQUM7QUFDZixTQUFTLGdCQWFoQixFQVNHO1VBckJELFdBQUEsRUFDQSxVQUFBLEVBQ0EsYUFBQSxFQUNBLGtCQUFBLEVBQ0EsU0FBUyxFQUNQLHFCQUFxQixXQUFBLEVBQ3JCLE1BQUEsRUFDQSxzQkFBQSxFQUNBLGtCQUFBLEVBQ0YsRUFDQSxhQUFBLEVBQ0EsTUFBQSxFQUNGLEdBYjJCO0lBdUJ6QixNQUFNLGtOQUFnQixnQkFBQSxFQUFhLEdBQWMsT0FBWCxXQUFXLEVBQUEsZUFBZ0I7SUFDakUsU0FBUyx1QkFBdUIsS0FBQSxFQUF3QixHQUFBLEVBQW9CLFNBQUEsRUFBb0IsSUFBQSxFQU03RjtZQUNELFFBQU07O1FBQU4sTUFBQSxTQUFBLE1BQUEsMEJBQVUsYUFBYSxDQUFBLGlDQUF2QixNQUFBLG9CQUF1QixHQUFNO1lBQzNCLFFBQUEsZ0JBQUEsaUJBQUE7WUFDQSxjQUFjLElBQUksWUFBQTtRQUNwQjtRQUNBLDRCQUE0QixPQUFPLElBQUksYUFBQSxFQUFlLENBQUEsYUFBWTtZQUNoRSxTQUFTLE1BQUEsR0FBQSxVQUFBLFdBQUE7WUFDVCxTQUFTLFNBQUEsR0FBWSxhQUFhLFNBQVMsU0FBQSxHQUFBLDhEQUFBO1lBRTNDLFNBQVMsU0FBQSxHQUFBLGdGQUFBO1lBRVQsS0FBSyxTQUFBO1lBQ0wsSUFBSSxJQUFJLFlBQUEsS0FBaUIsS0FBQSxHQUFXO2dCQUNsQyxTQUFTLFlBQUEsR0FBZSxJQUFJLFlBQUE7WUFDOUI7WUFDQSxTQUFTLGdCQUFBLEdBQW1CLEtBQUssZ0JBQUE7WUFDakMsTUFBTSxxQkFBcUIsV0FBQSxDQUFZLEtBQUssR0FBQSxDQUFJLFlBQVksQ0FBQTtZQUM1RCxJQUFJLDBCQUEwQixrQkFBa0IsS0FBSyxlQUFlLEtBQUs7O2dCQUV0RSxTQUF3QyxTQUFBLEdBQVksSUFBSSxTQUFBO1lBQzNEO1FBQ0YsQ0FBQztJQUNIO0lBQ0EsU0FBUyx5QkFBeUIsS0FBQSxFQUF3QixJQUFBLEVBTXZELE9BQUEsRUFBa0IsU0FBQSxFQUFvQjtRQUN2Qyw0QkFBNEIsT0FBTyxLQUFLLEdBQUEsQ0FBSSxhQUFBLEVBQWUsQ0FBQSxhQUFZO1lBQ3JFLElBQUksU0FBUyxTQUFBLEtBQWMsS0FBSyxTQUFBLElBQWEsQ0FBQyxVQUFXLENBQUE7WUFDekQsTUFBTSxFQUNKLEtBQUEsRUFDRixHQUFJLFdBQUEsQ0FBWSxLQUFLLEdBQUEsQ0FBSSxZQUFZLENBQUE7WUFDckMsU0FBUyxNQUFBLEdBQUEsWUFBQSxhQUFBO1lBQ1QsSUFBSSxPQUFPO2dCQUNULElBQUksU0FBUyxJQUFBLEtBQVMsS0FBQSxHQUFXO29CQUMvQixNQUFNLEVBQ0osa0JBQUEsRUFDQSxHQUFBLEVBQ0EsYUFBQSxFQUNBLFNBQUEsRUFDRixHQUFJO29CQUtKLElBQUksdU1BQVUsa0JBQUEsRUFBZ0IsU0FBUyxJQUFBLEVBQU0sQ0FBQSxzQkFBcUI7d0JBRWhFLE9BQU8sTUFBTSxtQkFBbUIsU0FBUzs0QkFDdkMsS0FBSyxJQUFJLFlBQUE7NEJBQ1Q7NEJBQ0E7NEJBQ0E7d0JBQ0YsQ0FBQztvQkFDSCxDQUFDO29CQUNELFNBQVMsSUFBQSxHQUFPO2dCQUNsQixPQUFPO29CQUVMLFNBQVMsSUFBQSxHQUFPO2dCQUNsQjtZQUNGLE9BQU87b0JBRVc7Z0JBQWhCLFNBQVMsSUFBQSx1RUFBTyxDQUFZLEtBQUssR0FBQSxDQUFJLFlBQVksQ0FBQSxDQUFFLGlCQUFBLHVJQUFxQixJQUFBLElBQU8seUtBQTBCLFVBQUEsRUFBUSxTQUFTLElBQUksbUpBQUksV0FBQSxFQUFTLFNBQVMsSUFBSSxJQUFJLFNBQVMsSUFBQSxFQUFNLE9BQU8sSUFBSTtZQUN4TDtZQUNBLE9BQU8sU0FBUyxLQUFBO1lBQ2hCLFNBQVMsa0JBQUEsR0FBcUIsS0FBSyxrQkFBQTtRQUNyQyxDQUFDO0lBQ0g7SUFDQSxNQUFNLGdOQUFhLGNBQUEsRUFBWTtRQUM3QixNQUFNLEdBQWMsT0FBWCxXQUFXLEVBQUE7UUFDcEI7UUFDQSxVQUFVO1lBQ1IsbUJBQW1CO2dCQUNqQixTQUFRLEtBQUEsT0FJUixFQUEyQzt3QkFKNUIsRUFDYixTQUFTLEVBQ1AsYUFBQSxFQUNGLEVBQ0Y7b0JBQ0UsT0FBTyxLQUFBLENBQU0sYUFBYSxDQUFBO2dCQUM1QjtnQkFDQSxTQUFTLHdOQUFBLENBQTRDO1lBQ3ZEO1lBQ0Esc0JBQXNCO2dCQUNwQixTQUFRLEtBQUEsRUFBTyxNQUFBLEVBSVg7b0JBQ0YsS0FBQSxNQUFXLFNBQVMsT0FBTyxPQUFBLENBQVM7d0JBQ2xDLE1BQU0sRUFDSixrQkFBa0IsR0FBQSxFQUNsQixLQUFBLEVBQ0YsR0FBSTt3QkFDSix1QkFBdUIsT0FBTyxLQUFLLE1BQU07NEJBQ3ZDOzRCQUNBLFdBQVcsT0FBTyxJQUFBLENBQUssU0FBQTs0QkFDdkIsa0JBQWtCLE9BQU8sSUFBQSxDQUFLLFNBQUE7d0JBQ2hDLENBQUM7d0JBQ0QseUJBQXlCLE9BQU87NEJBQzlCOzRCQUNBLFdBQVcsT0FBTyxJQUFBLENBQUssU0FBQTs0QkFDdkIsb0JBQW9CLE9BQU8sSUFBQSxDQUFLLFNBQUE7NEJBQ2hDLGVBQWUsQ0FBQzt3QkFDbEIsR0FBRyxPQUFBLCtCQUFBO3dCQUVIO29CQUNGO2dCQUNGO2dCQUNBLFNBQVMsQ0FBQyxZQUFpRDtvQkFDekQsTUFBTSxvQkFBaUQsUUFBUSxHQUFBLENBQUksQ0FBQSxVQUFTO3dCQUMxRSxNQUFNLEVBQ0osWUFBQSxFQUNBLEdBQUEsRUFDQSxLQUFBLEVBQ0YsR0FBSTt3QkFDSixNQUFNLHFCQUFxQixXQUFBLENBQVksWUFBWSxDQUFBO3dCQUNuRCxNQUFNLG1CQUFrQzs0QkFDdEMsTUFBTTs0QkFDTjs0QkFDQSxjQUFjLE1BQU0sR0FBQTs0QkFDcEIsZUFBZSxtQkFBbUI7Z0NBQ2hDLFdBQVc7Z0NBQ1g7Z0NBQ0E7NEJBQ0YsQ0FBQzt3QkFDSDt3QkFDQSxPQUFPOzRCQUNMOzRCQUNBO3dCQUNGO29CQUNGLENBQUM7b0JBQ0QsTUFBTSxTQUFTO3dCQUNiLFNBQVM7d0JBQ1QsTUFBTTs0QkFDSixnTUFBQyxtQkFBZ0IsQ0FBQSxFQUFHOzRCQUNwQixXQUFXLDRNQUFBLENBQU87NEJBQ2xCLFdBQVcsS0FBSyxHQUFBLENBQUk7d0JBQ3RCO29CQUNGO29CQUNBLE9BQU87Z0JBQ1Q7WUFDRjtZQUNBLG9CQUFvQjtnQkFDbEIsU0FBUSxLQUFBLE9BS1IsRUFFSTt3QkFQVyxFQUNiLFNBQVMsRUFDUCxhQUFBLEVBQ0EsT0FBQSxFQUNGLEVBQ0Y7b0JBR0UsNEJBQTRCLE9BQU8sZUFBZSxDQUFBLGFBQVk7d0JBQzVELFNBQVMsSUFBQSxrSkFBTyxlQUFBLEVBQWEsU0FBUyxJQUFBLEVBQWEsUUFBUSxNQUFBLENBQU8sQ0FBQztvQkFDckUsQ0FBQztnQkFDSDtnQkFDQSwyTUFBUyxzQkFBQSxDQUVOO1lBQ0w7UUFDRjtRQUNBLGVBQWMsT0FBQSxFQUFTO1lBQ3JCLFFBQVEsT0FBQSxDQUFRLFdBQVcsT0FBQSxFQUFTLENBQUM7b0JBQU8sRUFDMUMsSUFBQSxFQUNBLE1BQU0sRUFDSixHQUFBLEVBQ0YsRUFDRixLQUFNO2dCQUNKLE1BQU0sWUFBWSxjQUFjLEdBQUc7Z0JBQ25DLHVCQUF1QixPQUFPLEtBQUssV0FBVyxJQUFJO1lBQ3BELENBQUMsRUFBRSxPQUFBLENBQVEsV0FBVyxTQUFBLEVBQVcsQ0FBQztvQkFBTyxFQUN2QyxJQUFBLEVBQ0EsT0FBQSxFQUNGLEtBQU07Z0JBQ0osTUFBTSxZQUFZLGNBQWMsS0FBSyxHQUFHO2dCQUN4Qyx5QkFBeUIsT0FBTyxNQUFNLFNBQVMsU0FBUztZQUMxRCxDQUFDLEVBQUUsT0FBQSxDQUFRLFdBQVcsUUFBQSxFQUFVLENBQUM7b0JBQU8sRUFDdEMsTUFBTSxFQUNKLFNBQUEsRUFDQSxHQUFBLEVBQ0EsU0FBQSxFQUNGLEVBQ0EsS0FBQSxFQUNBLE9BQUEsRUFDRixLQUFNO2dCQUNKLDRCQUE0QixPQUFPLElBQUksYUFBQSxFQUFlLENBQUEsYUFBWTtvQkFDaEUsSUFBSSxXQUFXLENBRWYsT0FBTzt3QkFFTCxJQUFJLFNBQVMsU0FBQSxLQUFjLFVBQVcsQ0FBQTt3QkFDdEMsU0FBUyxNQUFBLEdBQUEsV0FBQSxZQUFBO3dCQUNULFNBQVMsS0FBQSw0Q0FBUyxVQUFXO29CQUMvQjtnQkFDRixDQUFDO1lBQ0gsQ0FBQyxFQUFFLFVBQUEsQ0FBVyxvQkFBb0IsQ0FBQyxPQUFPLFdBQVc7Z0JBQ25ELE1BQU0sRUFDSixPQUFBLEVBQ0YsR0FBSSx1QkFBdUIsTUFBTTtnQkFDakMsS0FBQSxNQUFXLENBQUMsS0FBSyxLQUFLLENBQUEsSUFBSyxPQUFPLE9BQUEsQ0FBUSxPQUFPLEVBQUc7b0JBQ2xELElBQUEsMERBQUE7bUVBRUEsTUFBTyxNQUFBLE1BQUEsWUFBQSxhQUFBLHNEQUFvQyxNQUFPLE1BQUEsTUFBQSxXQUFBLFlBQUEsS0FBaUM7d0JBQ2pGLEtBQUEsQ0FBTSxHQUFHLENBQUEsR0FBSTtvQkFDZjtnQkFDRjtZQUNGLENBQUM7UUFDSDtJQUNGLENBQUM7SUFDRCxNQUFNLG1OQUFnQixjQUFBLEVBQVk7UUFDaEMsTUFBTSxHQUFjLE9BQVgsV0FBVyxFQUFBO1FBQ3BCO1FBQ0EsVUFBVTtZQUNSLHNCQUFzQjtnQkFDcEIsU0FBUSxLQUFBLE9BRVIsRUFBOEM7d0JBRi9CLEVBQ2IsT0FBQSxFQUNGO29CQUNFLE1BQU0sV0FBVyxvQkFBb0IsT0FBTztvQkFDNUMsSUFBSSxZQUFZLE9BQU87d0JBQ3JCLE9BQU8sS0FBQSxDQUFNLFFBQVEsQ0FBQTtvQkFDdkI7Z0JBQ0Y7Z0JBQ0EsNE1BQVMscUJBQUEsQ0FBK0M7WUFDMUQ7UUFDRjtRQUNBLGVBQWMsT0FBQSxFQUFTO1lBQ3JCLFFBQVEsT0FBQSxDQUFRLGNBQWMsT0FBQSxFQUFTLENBQUM7b0JBQU8sRUFDN0MsSUFBQSxFQUNBLE1BQU0sRUFDSixTQUFBLEVBQ0EsR0FBQSxFQUNBLGdCQUFBLEVBQ0YsRUFDRixLQUFNO2dCQUNKLElBQUksQ0FBQyxJQUFJLEtBQUEsQ0FBTyxDQUFBO2dCQUNoQixLQUFBLENBQU0sb0JBQW9CLElBQUksQ0FBQyxDQUFBLEdBQUk7b0JBQ2pDO29CQUNBLFFBQUEsVUFBQSxXQUFBO29CQUNBLGNBQWMsSUFBSSxZQUFBO29CQUNsQjtnQkFDRjtZQUNGLENBQUMsRUFBRSxPQUFBLENBQVEsY0FBYyxTQUFBLEVBQVcsQ0FBQztvQkFBTyxFQUMxQyxPQUFBLEVBQ0EsSUFBQSxFQUNGLEtBQU07Z0JBQ0osSUFBSSxDQUFDLEtBQUssR0FBQSxDQUFJLEtBQUEsQ0FBTyxDQUFBO2dCQUNyQiwrQkFBK0IsT0FBTyxNQUFNLENBQUEsYUFBWTtvQkFDdEQsSUFBSSxTQUFTLFNBQUEsS0FBYyxLQUFLLFNBQUEsQ0FBVyxDQUFBO29CQUMzQyxTQUFTLE1BQUEsR0FBQSxZQUFBLGFBQUE7b0JBQ1QsU0FBUyxJQUFBLEdBQU87b0JBQ2hCLFNBQVMsa0JBQUEsR0FBcUIsS0FBSyxrQkFBQTtnQkFDckMsQ0FBQztZQUNILENBQUMsRUFBRSxPQUFBLENBQVEsY0FBYyxRQUFBLEVBQVUsQ0FBQztvQkFBTyxFQUN6QyxPQUFBLEVBQ0EsS0FBQSxFQUNBLElBQUEsRUFDRixLQUFNO2dCQUNKLElBQUksQ0FBQyxLQUFLLEdBQUEsQ0FBSSxLQUFBLENBQU8sQ0FBQTtnQkFDckIsK0JBQStCLE9BQU8sTUFBTSxDQUFBLGFBQVk7b0JBQ3RELElBQUksU0FBUyxTQUFBLEtBQWMsS0FBSyxTQUFBLENBQVcsQ0FBQTtvQkFDM0MsU0FBUyxNQUFBLEdBQUEsV0FBQSxZQUFBO29CQUNULFNBQVMsS0FBQSw0Q0FBUyxVQUFXO2dCQUMvQixDQUFDO1lBQ0gsQ0FBQyxFQUFFLFVBQUEsQ0FBVyxvQkFBb0IsQ0FBQyxPQUFPLFdBQVc7Z0JBQ25ELE1BQU0sRUFDSixTQUFBLEVBQ0YsR0FBSSx1QkFBdUIsTUFBTTtnQkFDakMsS0FBQSxNQUFXLENBQUMsS0FBSyxLQUFLLENBQUEsSUFBSyxPQUFPLE9BQUEsQ0FBUSxTQUFTLEVBQUc7b0JBQ3BELElBQUEsMERBQUE7b0JBQUEsZ0RBRUMsTUFBTyxNQUFBLE1BQUEsWUFBQSxhQUFBLHNEQUFvQyxNQUFPLE1BQUEsTUFBQSxXQUFBLFlBQUEsR0FBQSxLQUFBLHVFQUFBO29CQUVuRCx1REFBUSxNQUFPLFNBQUEsR0FBVzt3QkFDeEIsS0FBQSxDQUFNLEdBQUcsQ0FBQSxHQUFJO29CQUNmO2dCQUNGO1lBQ0YsQ0FBQztRQUNIO0lBQ0YsQ0FBQztJQUVELE1BQU0sMkJBQXNEO1FBQzFELE1BQU0sQ0FBQztRQUNQLE1BQU0sQ0FBQztJQUNUO0lBQ0EsTUFBTSxzTkFBb0IsZUFBQSxFQUFZO1FBQ3BDLE1BQU0sR0FBYyxPQUFYLFdBQVcsRUFBQTtRQUNwQixjQUFjO1FBQ2QsVUFBVTtZQUNSLGtCQUFrQjtnQkFDaEIsU0FBUSxLQUFBLEVBQU8sTUFBQSxFQUdWO29CQUNILEtBQUEsTUFBVyxFQUNULGFBQUEsRUFDQSxZQUFBLEVBQ0YsSUFBSyxPQUFPLE9BQUEsQ0FBUzt3QkFDbkIsdUJBQXVCLE9BQU8sYUFBYTt3QkFDM0MsS0FBQSxNQUFXLEVBQ1QsSUFBQSxFQUNBLEVBQUEsRUFDRixJQUFLLGFBQWM7b0RBQ1g7OzRCQUFOLE1BQU0sb0JBQUEsT0FBQSxpQ0FBMkIsSUFBQSxDQUFBLGNBQVMsaUNBQWYsV0FBTSxDQUFLLElBQUksRUFBQSxHQUFNLENBQUMsRUFBQSxDQUFHLGNBQU0sdUJBQXVCLENBQUEsbUNBQTNFLElBQTJDLE9BQWdDLEdBQU0sQ0FBQyxDQUFBOzRCQUN4RixNQUFNLG9CQUFvQixrQkFBa0IsUUFBQSxDQUFTLGFBQWE7NEJBQ2xFLElBQUksQ0FBQyxtQkFBbUI7Z0NBQ3RCLGtCQUFrQixJQUFBLENBQUssYUFBYTs0QkFDdEM7d0JBQ0Y7d0JBR0EsTUFBTSxJQUFBLENBQUssYUFBYSxDQUFBLEdBQUk7b0JBQzlCO2dCQUNGO2dCQUNBLDRNQUFTLHFCQUFBLENBR0w7WUFDTjtRQUNGO1FBQ0EsZUFBYyxPQUFBLEVBQVM7WUFDckIsUUFBUSxPQUFBLENBQVEsV0FBVyxPQUFBLENBQVEsaUJBQUEsRUFBbUIsQ0FBQztvQkFBTyxFQUM1RCxTQUFTLEVBQ1AsYUFBQSxFQUNGLEVBQ0YsS0FBTTtnQkFDSix1QkFBdUIsT0FBTyxhQUFhO1lBQzdDLENBQUMsRUFBRSxVQUFBLENBQVcsb0JBQW9CLENBQUMsT0FBTyxXQUFXO2dCQUNuRCxNQUFNLEVBQ0osUUFBQSxFQUNGLEdBQUksdUJBQXVCLE1BQU07Z0JBQ2pDLEtBQUEsTUFBVyxDQUFDLE1BQU0sWUFBWSxDQUFBLElBQUssT0FBTyxPQUFBLENBQVEsUUFBUSxFQUFHO29CQUMzRCxLQUFBLE1BQVcsQ0FBQyxJQUFJLFNBQVMsQ0FBQSxJQUFLLE9BQU8sT0FBQSxDQUFRLFlBQVksRUFBRzs0QkFDL0IsYUFBVyxJQUFJLEdBQXBDOzt3QkFBTixNQUFNLG9CQUFBLE9BQUEsaUNBQTJCLElBQUEsQ0FBQSxjQUFTLDRDQUFULE9BQVMsR0FBTSxDQUFDLEVBQUEsU0FBRyxNQUFNLHVCQUF1QixDQUFBLG1DQUEzRSxJQUEyQyxPQUFnQyxHQUFNLENBQUMsQ0FBQTt3QkFDeEYsS0FBQSxNQUFXLGlCQUFpQixVQUFXOzRCQUNyQyxNQUFNLG9CQUFvQixrQkFBa0IsUUFBQSxDQUFTLGFBQWE7NEJBQ2xFLElBQUksQ0FBQyxtQkFBbUI7Z0NBQ3RCLGtCQUFrQixJQUFBLENBQUssYUFBYTs0QkFDdEM7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRixDQUFDLEVBQUUsVUFBQSxvTUFBVyxVQUFBLHFNQUFRLGNBQUEsRUFBWSxVQUFVLHNNQUFHLHNCQUFBLEVBQW9CLFVBQVUsQ0FBQyxHQUFHLENBQUMsT0FBTyxXQUFXO2dCQUNsRyw0QkFBNEIsT0FBTztvQkFBQyxNQUFNO2lCQUFDO1lBQzdDLENBQUMsRUFBRSxVQUFBLENBQVcsV0FBVyxPQUFBLENBQVEsb0JBQUEsQ0FBcUIsS0FBQSxFQUFPLENBQUMsT0FBTyxXQUFXO2dCQUM5RSxNQUFNLGNBQTJDLE9BQU8sT0FBQSxDQUFRLEdBQUEsQ0FBSTt3QkFBQyxFQUNuRSxnQkFBQSxFQUNBLEtBQUEsRUFDRixLQUFNO29CQUNKLE9BQU87d0JBQ0wsTUFBTTt3QkFDTixTQUFTO3dCQUNULE1BQU07NEJBQ0osZUFBZTs0QkFDZixXQUFXOzRCQUNYLEtBQUs7d0JBQ1A7b0JBQ0Y7Z0JBQ0YsQ0FBQztnQkFDRCw0QkFBNEIsT0FBTyxXQUFXO1lBQ2hELENBQUM7UUFDSDtJQUNGLENBQUM7SUFDRCxTQUFTLHVCQUF1QixLQUFBLEVBQStCLGFBQUEsRUFBOEI7O1FBQzNGLE1BQU0sZ0JBQWUsa0NBQU0sSUFBQSxDQUFLLGFBQWEsQ0FBQSxpRkFBSyxDQUFDLENBQUE7UUFHbkQsS0FBQSxNQUFXLE9BQU8sYUFBYzs7WUFDOUIsTUFBTSxVQUFVLElBQUksSUFBQTtnQkFDTjtZQUFkLE1BQU0sdUJBQVksRUFBQSw2Q0FBTTtZQUN4QixNQUFNLGdEQUF5QixJQUFBLENBQUssT0FBTyxDQUFBLHdEQUFsQixtQkFBa0IsQ0FBSSxLQUFLLENBQUE7WUFDcEQsSUFBSSxrQkFBa0I7Z0JBQ3BCLE1BQU0sSUFBQSxDQUFLLE9BQU8sQ0FBQSxDQUFFLEtBQUssQ0FBQSxHQUFJLGlCQUFpQixNQUFBLENBQU8sQ0FBQSxLQUFNLE9BQU8sYUFBYTtZQUNqRjtRQUNGO1FBQ0EsT0FBTyxNQUFNLElBQUEsQ0FBSyxhQUFhLENBQUE7SUFDakM7SUFDQSxTQUFTLDRCQUE0QixLQUFBLEVBQWtDQyxRQUFBQSxFQUFzQztRQUMzRyxNQUFNLG9CQUFvQkEsU0FBUSxHQUFBLENBQUksQ0FBQSxXQUFVO1lBQzlDLE1BQU0sZUFBZSx5QkFBeUIsUUFBUSxnQkFBZ0IsYUFBYSxhQUFhO1lBQ2hHLE1BQU0sRUFDSixhQUFBLEVBQ0YsR0FBSSxPQUFPLElBQUEsQ0FBSyxHQUFBO1lBQ2hCLE9BQU87Z0JBQ0w7Z0JBQ0E7WUFDRjtRQUNGLENBQUM7UUFDRCxrQkFBa0IsWUFBQSxDQUFhLGdCQUFBLENBQWlCLE9BQU8sa0JBQWtCLE9BQUEsQ0FBUSxnQkFBQSxDQUFpQixpQkFBaUIsQ0FBQztJQUN0SDtJQUdBLE1BQU0sdU5BQW9CLGNBQUEsRUFBWTtRQUNwQyxNQUFNLEdBQWMsT0FBWCxXQUFXLEVBQUE7UUFDcEI7UUFDQSxVQUFVO1lBQ1IsMkJBQTBCLENBQUEsRUFBRyxDQUFBLEVBSUMsQ0FFOUI7WUFDQSx3QkFBdUIsQ0FBQSxFQUFHLENBQUEsRUFFSSxDQUU5QjtZQUNBLGdDQUFnQyxFQUFDO1FBQ25DO0lBQ0YsQ0FBQztJQUNELE1BQU0sZ09BQTZCLGNBQUEsRUFBWTtRQUM3QyxNQUFNLEdBQWMsT0FBWCxXQUFXLEVBQUE7UUFDcEI7UUFDQSxVQUFVO1lBQ1Isc0JBQXNCO2dCQUNwQixTQUFRLEtBQUEsRUFBTyxNQUFBLEVBQWdDO29CQUM3QyxRQUFPLDZKQUFBLEVBQWEsT0FBTyxPQUFPLE9BQU87Z0JBQzNDO2dCQUNBLDRNQUFTLHFCQUFBLENBQTRCO1lBQ3ZDO1FBQ0Y7SUFDRixDQUFDO0lBQ0QsTUFBTSxpTkFBYyxjQUFBLEVBQVk7UUFDOUIsTUFBTSxHQUFjLE9BQVgsV0FBVyxFQUFBO1FBQ3BCLGNBQWM7WUFDWixRQUFRLFNBQVM7WUFDakIsU0FBUyxrQkFBa0I7WUFDM0Isc0JBQXNCO1lBQ3RCLEdBQUcsTUFBQTtRQUNMO1FBQ0EsVUFBVTtZQUNSLHNCQUFxQixLQUFBLE9BRXJCO3NCQURFLE9BQUEsRUFDRixFQUEwQixDQUZFO2dCQUcxQixNQUFNLG9CQUFBLEdBQXVCLE1BQU0sb0JBQUEsS0FBeUIsY0FBYyxXQUFXLFVBQVUsYUFBYTtZQUM5RztRQUNGO1FBQ0EsZUFBZSxDQUFBLFlBQVc7WUFDeEIsUUFBUSxPQUFBLENBQVEsVUFBVSxDQUFBLFVBQVM7Z0JBQ2pDLE1BQU0sTUFBQSxHQUFTO1lBQ2pCLENBQUMsRUFBRSxPQUFBLENBQVEsV0FBVyxDQUFBLFVBQVM7Z0JBQzdCLE1BQU0sTUFBQSxHQUFTO1lBQ2pCLENBQUMsRUFBRSxPQUFBLENBQVEsU0FBUyxDQUFBLFVBQVM7Z0JBQzNCLE1BQU0sT0FBQSxHQUFVO1lBQ2xCLENBQUMsRUFBRSxPQUFBLENBQVEsYUFBYSxDQUFBLFVBQVM7Z0JBQy9CLE1BQU0sT0FBQSxHQUFVO1lBQ2xCLENBQUMsRUFHQSxVQUFBLENBQVcsb0JBQW9CLENBQUEsUUFBQSxDQUFVO29CQUN4QyxHQUFHLEtBQUE7Z0JBQ0wsQ0FBQSxDQUFFO1FBQ0o7SUFDRixDQUFDO0lBQ0QsTUFBTSxpS0FBa0Isa0JBQUEsRUFBZ0I7UUFDdEMsU0FBUyxXQUFXLE9BQUE7UUFDcEIsV0FBVyxjQUFjLE9BQUE7UUFDekIsVUFBVSxrQkFBa0IsT0FBQTtRQUM1QixlQUFlLDJCQUEyQixPQUFBO1FBQzFDLFFBQVEsWUFBWSxPQUFBO0lBQ3RCLENBQUM7SUFDRCxNQUFNLFVBQWtDLENBQUMsT0FBTyxTQUFXLGdCQUFnQixjQUFjLEtBQUEsQ0FBTSxNQUFNLElBQUksS0FBQSxJQUFZLE9BQU8sTUFBTTtJQUNsSSxNQUFNLFVBQVU7UUFDZCxHQUFHLFlBQVksT0FBQTtRQUNmLEdBQUcsV0FBVyxPQUFBO1FBQ2QsR0FBRyxrQkFBa0IsT0FBQTtRQUNyQixHQUFHLDJCQUEyQixPQUFBO1FBQzlCLEdBQUcsY0FBYyxPQUFBO1FBQ2pCLEdBQUcsa0JBQWtCLE9BQUE7UUFDckI7SUFDRjtJQUNBLE9BQU87UUFDTDtRQUNBO0lBQ0Y7QUFDRjs7QUM3aUJPLElBQU0sWUFBMkIsYUFBQSxHQUFBLE9BQU8sR0FBQSxDQUFJLGdCQUFnQjtBQTJCbkUsSUFBTSxrQkFBc0M7SUFDMUMsUUFBQSxnQkFBQSxpQkFBQTtBQUNGO0FBR0EsSUFBTSx1QkFBc0MsYUFBQSxHQUFBLENBQUEsR0FBQSx3TEFBQSxDQUFBLGtCQUFBLEVBQWdCLGlCQUFpQixLQUFPLENBQUQsQUFBRTtBQUNyRixJQUFNLDBCQUF5QyxhQUFBLEdBQUEsQ0FBQSxHQUFBLHdMQUFBLENBQUEsa0JBQUEsRUFBZ0IsaUJBQTBDLEtBQU8sQ0FBRCxBQUFFO0FBRTFHLFNBQVMsb0JBSWhCLEVBSUc7VUFQRCxrQkFBQSxFQUNBLFdBQUEsRUFDQSxnQkFBQUMsZUFBQUEsRUFDRixHQUpvRztJQVVsRyxNQUFNLHFCQUFxQixDQUFDLFFBQXFCO0lBQ2pELE1BQU0sd0JBQXdCLENBQUMsUUFBcUI7SUFDcEQsT0FBTztRQUNMO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0lBQ0Y7OztJQUNBLFNBQVMsaUJBRU4sUUFBQSxFQUFxQztRQUN0QyxPQUFPO1lBQ0wsR0FBRyxRQUFBO1lBQ0gsR0FBRyxzQkFBc0IsU0FBUyxNQUFNLENBQUE7UUFDMUM7SUFDRjtJQUNBLFNBQVMsZUFBZSxTQUFBLEVBQXNCO1FBQzVDLE1BQU0sUUFBUSxTQUFBLENBQVUsV0FBVyxDQUFBO1FBQ25DLElBQUksUUFBUSxJQUFJLGFBQWEsV0FBYztZQUN6QyxJQUFJLENBQUMsT0FBTztnQkFDVixJQUFLLGVBQXVCLFNBQUEsQ0FBVyxDQUFBLE9BQU87Z0JBQzdDLGVBQXVCLFNBQUEsR0FBWTtnQkFDcEMsUUFBUSxLQUFBLENBQU0sa0NBQThDLE9BQVgsV0FBVyxFQUFBLGdDQUFxRDtZQUNuSDtRQUNGO1FBQ0EsT0FBTztJQUNUO0lBQ0EsU0FBUyxjQUFjLFNBQUEsRUFBc0I7O1FBQzNDLHlDQUFzQixTQUFTLHFEQUF4QixnQkFBMkIsT0FBQTtJQUNwQztJQUNBLFNBQVMsaUJBQWlCLFNBQUEsRUFBc0IsUUFBQSxFQUF5Qjs7UUFDdkUsdUNBQXFCLFNBQVMsb0RBQXZCLGNBQXVCLENBQUksUUFBUSxDQUFBO0lBQzVDO0lBQ0EsU0FBUyxnQkFBZ0IsU0FBQSxFQUFzQjs7UUFDN0MseUNBQXNCLFNBQVMscURBQXhCLGdCQUEyQixTQUFBO0lBQ3BDO0lBQ0EsU0FBUyxhQUFhLFNBQUEsRUFBc0I7O1FBQzFDLHlDQUFzQixTQUFTLGVBQXhCLHNEQUEyQixNQUFBO0lBQ3BDO0lBQ0EsU0FBUyxzQkFBc0IsWUFBQSxFQUFzQixrQkFBQSxFQUE0RCxRQUFBLEVBRXRFO1FBQ3pDLE9BQU8sQ0FBQyxjQUFtQjtZQUV6QixJQUFJLGNBQWMsV0FBVztnQkFDM0IsT0FBT0EsZ0JBQWUsb0JBQW9CLFFBQVE7WUFDcEQ7WUFDQSxNQUFNLGlCQUFpQixtQkFBbUI7Z0JBQ3hDO2dCQUNBO2dCQUNBO1lBQ0YsQ0FBQztZQUNELE1BQU0sc0JBQXNCLENBQUM7OzZEQUFzQyxPQUFPLGNBQWMsZUFBdEMsbURBQTJDOztZQUM3RixPQUFPQSxnQkFBZSxxQkFBcUIsUUFBUTtRQUNyRDtJQUNGO0lBQ0EsU0FBUyxtQkFBbUIsWUFBQSxFQUFzQixrQkFBQSxFQUF5RDtRQUN6RyxPQUFPLHNCQUFzQixjQUFjLG9CQUFvQixnQkFBZ0I7SUFDakY7SUFDQSxTQUFTLDJCQUEyQixZQUFBLEVBQXNCLGtCQUFBLEVBQXNFO1FBQzlILE1BQU0sRUFDSixvQkFBQSxFQUNGLEdBQUk7UUFDSixTQUFTLDZCQUVOLFFBQUEsRUFBZ0U7WUFDakUsTUFBTSx3QkFBd0I7Z0JBQzVCLEdBQUksUUFBQTtnQkFDSixHQUFHLHNCQUFzQixTQUFTLE1BQU0sQ0FBQTtZQUMxQztZQUNBLE1BQU0sRUFDSixTQUFBLEVBQ0EsT0FBQSxFQUNBLFNBQUEsRUFDRixHQUFJO1lBQ0osTUFBTSxZQUFZLGNBQWM7WUFDaEMsTUFBTSxhQUFhLGNBQWM7WUFDakMsT0FBTztnQkFDTCxHQUFHLHFCQUFBO2dCQUNILGFBQWEsZUFBZSxzQkFBc0Isc0JBQXNCLElBQUEsRUFBTSxzQkFBc0IsWUFBWTtnQkFDaEgsaUJBQWlCLG1CQUFtQixzQkFBc0Isc0JBQXNCLElBQUEsRUFBTSxzQkFBc0IsWUFBWTtnQkFDeEgsb0JBQW9CLGFBQWE7Z0JBQ2pDLHdCQUF3QixhQUFhO2dCQUNyQyxzQkFBc0IsV0FBVztnQkFDakMsMEJBQTBCLFdBQVc7WUFDdkM7UUFDRjtRQUNBLE9BQU8sc0JBQXNCLGNBQWMsb0JBQW9CLDRCQUE0QjtJQUM3RjtJQUNBLFNBQVMsd0JBQXdCO1FBQy9CLE9BQVEsQ0FBQSxPQUFNO1lBQ1osSUFBSTtZQUNKLElBQUksT0FBTyxPQUFPLFVBQVU7O2dCQUMxQix5REFBaUMsRUFBRSxpREFBdEIsdUJBQTJCO1lBQzFDLE9BQU87Z0JBQ0wsYUFBYTtZQUNmO1lBQ0EsTUFBTSx5QkFBeUIsQ0FBQzs7O3dCQUFxQix5RUFBZSxLQUFLLGtHQUFHLFNBQUEsdUZBQUEsQ0FBWSxVQUFvQixDQUFBLHVHQUFLOztZQUNqSCxNQUFNLDhCQUE4QixlQUFlLFlBQVksd0JBQXdCO1lBQ3ZGLE9BQU9BLGdCQUFlLDZCQUE2QixnQkFBZ0I7UUFDckU7SUFDRjtJQUNBLFNBQVMsb0JBQW9CLEtBQUEsRUFBa0IsSUFBQSxFQUk1QztRQUNELE1BQU0sV0FBVyxLQUFBLENBQU0sV0FBVyxDQUFBO1FBQ2xDLE1BQU0sZUFBZSxhQUFBLEdBQUEsSUFBSSxJQUFtQjtRQUM1QyxLQUFBLE1BQVcsT0FBTyxLQUFLLE1BQUEsQ0FBTyxZQUFZLEVBQUUsR0FBQSxDQUFJLG9CQUFvQixFQUFHO1lBQ3JFLE1BQU0sV0FBVyxTQUFTLFFBQUEsQ0FBUyxJQUFBLENBQUssSUFBSSxJQUFJLENBQUE7WUFDaEQsSUFBSSxDQUFDLFVBQVU7Z0JBQ2I7WUFDRjtnQkFDSTtZQUFKLElBQUksMEJBQUEsQ0FBQSxPQUEyQixJQUFJLEVBQUEsS0FBTyxLQUFBLElBQUEsK0RBQUE7WUFFMUMsUUFBQSxDQUFTLElBQUksRUFBRSxDQUFBLEdBQUEsdURBQUE7WUFFZixRQUFRLE9BQU8sTUFBQSxDQUFPLFFBQVEsQ0FBQyxlQUozQixrQkFBQSxPQUlpQyxDQUFDLENBQUE7WUFDdEMsS0FBQSxNQUFXLGNBQWMsd0JBQXlCO2dCQUNoRCxhQUFhLEdBQUEsQ0FBSSxVQUFVO1lBQzdCO1FBQ0Y7UUFDQSxPQUFPLFFBQVEsTUFBTSxJQUFBLENBQUssYUFBYSxNQUFBLENBQU8sQ0FBQyxFQUFFLEdBQUEsQ0FBSSxDQUFBLGtCQUFpQjtZQUNwRSxNQUFNLGdCQUFnQixTQUFTLE9BQUEsQ0FBUSxhQUFhLENBQUE7WUFDcEQsT0FBTyxnQkFBZ0I7Z0JBQUM7b0JBQ3RCO29CQUNBLGNBQWMsY0FBYyxZQUFBO29CQUM1QixjQUFjLGNBQWMsWUFBQTtnQkFDOUIsQ0FBQzthQUFBLEdBQUksQ0FBQyxDQUFBO1FBQ1IsQ0FBQyxDQUFDO0lBQ0o7SUFDQSxTQUFTLHlCQUFzRSxLQUFBLEVBQWtCLFNBQUEsRUFBMkU7UUFDMUssT0FBTyxPQUFPLE1BQUEsQ0FBTyxjQUFjLEtBQUssQ0FBb0IsRUFBRSxNQUFBLENBQU8sQ0FBQyxRQUVoRSxxREFBTyxZQUFBLE1BQWlCLGFBQWEsTUFBTSxNQUFBLEtBQUEsZ0JBQUEsaUJBQUEsRUFBb0MsR0FBRSxHQUFBLENBQUksQ0FBQSxRQUFTLE1BQU0sWUFBWTtJQUN4SDtJQUNBLFNBQVMsZUFBZSxPQUFBLEVBQW9ELElBQUEsRUFBdUMsUUFBQSxFQUE2QjtRQUM5SSxJQUFJLENBQUMsS0FBTSxDQUFBLE9BQU87UUFDbEIsT0FBTyxpQkFBaUIsU0FBUyxNQUFNLFFBQVEsS0FBSztJQUN0RDtJQUNBLFNBQVMsbUJBQW1CLE9BQUEsRUFBb0QsSUFBQSxFQUF1QyxRQUFBLEVBQTZCO1FBQ2xKLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxvQkFBQSxDQUFzQixDQUFBLE9BQU87UUFDbkQsT0FBTyxxQkFBcUIsU0FBUyxNQUFNLFFBQVEsS0FBSztJQUMxRDtBQUNGOzs7QUVsT0EsSUFBTSxRQUEwQyxVQUFVLGFBQUEsR0FBQSxJQUFJLFFBQVEsSUFBSSxLQUFBO0FBQ25FLElBQU0sNEJBQXFEO1FBQUMsRUFDakUsWUFBQSxFQUNBLFNBQUEsRUFDRixLQUFNO0lBQ0osSUFBSSxhQUFhO0lBQ2pCLE1BQU0sdURBQVMsTUFBTyxHQUFBLENBQUksU0FBUztJQUNuQyxJQUFJLE9BQU8sV0FBVyxVQUFVO1FBQzlCLGFBQWE7SUFDZixPQUFPO1FBQ0wsTUFBTSxjQUFjLEtBQUssU0FBQSxDQUFVLFdBQVcsQ0FBQyxLQUFLLFVBQVU7WUFFNUQsUUFBUSxPQUFPLFVBQVUsV0FBVztnQkFDbEMsU0FBUyxNQUFNLFFBQUEsQ0FBUztZQUMxQixJQUFJO1lBRUosdUpBQVEsZ0JBQUEsRUFBYyxLQUFLLElBQUksT0FBTyxJQUFBLENBQUssS0FBSyxFQUFFLElBQUEsQ0FBSyxFQUFFLE1BQUEsQ0FBWSxDQUFDLEtBQUtHLFNBQVE7Z0JBQ2pGLEdBQUEsQ0FBSUEsSUFBRyxDQUFBLEdBQUssS0FBQSxDQUFjQSxJQUFHLENBQUE7Z0JBQzdCLE9BQU87WUFDVCxHQUFHLENBQUMsQ0FBQyxJQUFJO1lBQ1QsT0FBTztRQUNULENBQUM7UUFDRCxrSkFBSSxpQkFBQSxFQUFjLFNBQVMsR0FBRztZQUM1QixrQkFBQSw0QkFBQSxNQUFPLEdBQUEsQ0FBSSxXQUFXLFdBQVc7UUFDbkM7UUFDQSxhQUFhO0lBQ2Y7SUFDQSxPQUFPLEdBQW1CLE9BQWhCLEdBQTBCLFNBQWQsRUFBQSxLQUFjLG1CQUFBO0FBQ3RDOztBRHNSTyxTQUFTO0lBQUEsSUFBQSxJQUFBLE9BQUEsVUFBQSxRQUFBLFVBQUEsVUFBQSxPQUFBLE9BQUEsR0FBQSxPQUFBLE1BQUE7UUFBbUUsUUFBbkUsUUFBQSxTQUFBLENBQUEsS0FBbUUsRUFBc0Q7O0lBQ3ZJLE9BQU8sU0FBUyxjQUFjLE9BQUEsRUFBUztRQUNyQyxNQUFNLDhLQUF5QixpQkFBQSxFQUFlLENBQUM7O2dCQUMvQjs4REFEaUUsc0JBQUEseUdBQVIsU0FBaUMsUUFBUTtnQkFDaEgsNkNBQXNCLFdBQUEsdUVBQWU7WUFDdkMsQ0FBQyxDQUFDOztRQUNGLE1BQU0sc0JBQTREO1lBQ2hFLGFBQWE7WUFDYixtQkFBbUI7WUFDbkIsMkJBQTJCO1lBQzNCLGdCQUFnQjtZQUNoQixvQkFBb0I7WUFDcEIsc0JBQXNCO1lBQ3RCLEdBQUcsT0FBQTtZQUNIO1lBQ0Esb0JBQW1CLFlBQUEsRUFBYztnQkFDL0IsSUFBSSwwQkFBMEI7Z0JBQzlCLElBQUksd0JBQXdCLGFBQWEsa0JBQUEsRUFBb0I7b0JBQzNELE1BQU0sY0FBYyxhQUFhLGtCQUFBLENBQW1CLGtCQUFBO29CQUNwRCwwQkFBMEIsQ0FBQUMsa0JBQWdCO3dCQUN4QyxNQUFNLGdCQUFnQixZQUFZQSxhQUFZO3dCQUM5QyxJQUFJLE9BQU8sa0JBQWtCLFVBQVU7NEJBRXJDLE9BQU87d0JBQ1QsT0FBTzs0QkFHTCxPQUFPLDBCQUEwQjtnQ0FDL0IsR0FBR0EsYUFBQUE7Z0NBQ0gsV0FBVzs0QkFDYixDQUFDO3dCQUNIO29CQUNGO2dCQUNGLE9BQUEsSUFBVyxRQUFRLGtCQUFBLEVBQW9CO29CQUNyQywwQkFBMEIsUUFBUSxrQkFBQTtnQkFDcEM7Z0JBQ0EsT0FBTyx3QkFBd0IsWUFBWTtZQUM3QztZQUNBLFVBQVUsQ0FBQzttQkFBSSxRQUFRLFFBQUEsSUFBWSxDQUFDLENBQUU7YUFBQTtRQUN4QztRQUNBLE1BQU0sVUFBMkM7WUFDL0MscUJBQXFCLENBQUM7WUFDdEIsT0FBTSxFQUFBLEVBQUk7Z0JBRVIsR0FBRztZQUNMO1lBQ0EsMk1BQVEsU0FBQSxDQUFPO1lBQ2Y7WUFDQSx3QkFBb0Isa0tBQUEsRUFBZSxDQUFBLFNBQVUsdUJBQXVCLE1BQU0sS0FBSyxJQUFJO1FBQ3JGO1FBQ0EsTUFBTSxNQUFNO1lBQ1Y7WUFDQSx1QkFHQSxFQUFHO3NCQUZELFdBQUEsRUFDQSxTQUFBLEVBQ0YsR0FIaUI7Z0JBSWYsSUFBSSxhQUFhO29CQUNmLEtBQUEsTUFBVyxNQUFNLFlBQWE7d0JBQzVCLElBQUksQ0FBQyxvQkFBb0IsUUFBQSxDQUFVLFFBQUEsQ0FBUyxFQUFTLEdBQUc7OzRCQUVyRCxvQkFBb0IsUUFBQSxDQUFtQixJQUFBLENBQUssRUFBRTt3QkFDakQ7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsSUFBSSxXQUFXO29CQUNiLEtBQUEsTUFBVyxDQUFDLGNBQWMsaUJBQWlCLENBQUEsSUFBSyxPQUFPLE9BQUEsQ0FBUSxTQUFTLEVBQUc7d0JBQ3pFLElBQUksT0FBTyxzQkFBc0IsWUFBWTs0QkFDM0Msa0JBQWtCLFFBQVEsbUJBQUEsQ0FBb0IsWUFBWSxDQUFDO3dCQUM3RCxPQUFPOzRCQUNMLE9BQU8sTUFBQSxDQUFPLFFBQVEsbUJBQUEsQ0FBb0IsWUFBWSxDQUFBLElBQUssQ0FBQyxHQUFHLGlCQUFpQjt3QkFDbEY7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsT0FBTztZQUNUO1FBQ0Y7UUFDQSxNQUFNLHFCQUFxQixRQUFRLEdBQUEsQ0FBSSxDQUFBLElBQUssRUFBRSxJQUFBLENBQUssS0FBWSxxQkFBNEIsT0FBTyxDQUFDO1FBQ25HLFNBQVMsZ0JBQWdCLE1BQUEsRUFBbUQ7WUFDMUUsTUFBTSxxQkFBcUIsT0FBTyxTQUFBLENBQVU7Z0JBQzFDLE9BQU8sQ0FBQSxJQUFBLENBQU07d0JBQ1gsR0FBRyxDQUFBO3dCQUNILE1BQUEsUUFBQSxTQUFBO29CQUNGLENBQUE7Z0JBQ0EsVUFBVSxDQUFBLElBQUEsQ0FBTTt3QkFDZCxHQUFHLENBQUE7d0JBQ0gsTUFBQSxXQUFBLFlBQUE7b0JBQ0YsQ0FBQTtnQkFDQSxlQUFlLENBQUEsSUFBQSxDQUFNO3dCQUNuQixHQUFHLENBQUE7d0JBQ0gsTUFBQSxnQkFBQSxpQkFBQTtvQkFDRixDQUFBO1lBQ0YsQ0FBQztZQUNELEtBQUEsTUFBVyxDQUFDLGNBQWMsVUFBVSxDQUFBLElBQUssT0FBTyxPQUFBLENBQVEsa0JBQWtCLEVBQUc7Z0JBQzNFLElBQUksT0FBTyxnQkFBQSxLQUFxQixRQUFRLGdCQUFnQixRQUFRLG1CQUFBLEVBQXFCO29CQUNuRixJQUFJLE9BQU8sZ0JBQUEsS0FBcUIsU0FBUzt3QkFDdkMsTUFBTSxJQUFJLE1BQU0sUUFBUSxJQUFJLGFBQWEsYUFBZUMseUJBQXdCLENBQU0sQ0FBSixxRUFBd0YsT0FBWixZQUFZLEVBQUEsK0NBQWdEO29CQUM1TixPQUFBLElBQVcsd0tBQU8sVUFBQSxLQUFZLGVBQWUsUUFBUSxJQUFJLHdDQUFhLGVBQWU7d0JBQ25GLFFBQVEsS0FBQSxDQUFNLHNFQUFvRixPQUFaLFlBQVksRUFBQSwrQ0FBZ0Q7b0JBQ3BKO29CQUNBO2dCQUNGO2dCQUNBLElBQUksd0tBQU8sVUFBQSxLQUFZLGVBQWUsUUFBUSxJQUFJLHdDQUFhLGVBQWU7b0JBQzVFLElBQUksMEJBQTBCLFVBQVUsR0FBRzt3QkFDekMsTUFBTSxFQUNKLG9CQUFBLEVBQ0YsR0FBSTt3QkFDSixNQUFNLEVBQ0osUUFBQSxFQUNBLHNCQUFBQyxxQkFBQUEsRUFDRixHQUFJO3dCQUNKLElBQUksT0FBTyxhQUFhLFVBQVU7NEJBQ2hDLElBQUksV0FBVyxHQUFHO2dDQUNoQixNQUFNLElBQUksTUFBTSxRQUFRLElBQUksYUFBYSxhQUFlQywwQkFBeUIsQUFBTSxFQUFKLHdCQUEwQyxPQUFaLFlBQVksRUFBQSxrQ0FBbUM7NEJBQ2xLOzRCQUNBLElBQUksT0FBT0QsMEJBQXlCLFlBQVk7Z0NBQzlDLE1BQU0sSUFBSSxNQUFNLFFBQVEsSUFBSSxhQUFhLGFBQWUseUJBQXlCLENBQU0sQ0FBSixxQ0FBc0QsT0FBWixZQUFZLEVBQUEseUNBQTBDOzRCQUNyTDt3QkFDRjtvQkFDRjtnQkFDRjtnQkFDQSxRQUFRLG1CQUFBLENBQW9CLFlBQVksQ0FBQSxHQUFJO2dCQUM1QyxLQUFBLE1BQVcsS0FBSyxtQkFBb0I7b0JBQ2xDLEVBQUUsY0FBQSxDQUFlLGNBQWMsVUFBVTtnQkFDM0M7WUFDRjtZQUNBLE9BQU87UUFDVDtRQUNBLE9BQU8sSUFBSSxlQUFBLENBQWdCO1lBQ3pCLFdBQVcsUUFBUSxTQUFBO1FBQ3JCLENBQUM7SUFDSDtBQUNGOztBRXJiTyxJQUFNLFNBQXdCLGFBQUEsR0FBQSxPQUFPO0FBT3JDLFNBQVMsZ0JBQW9FO0lBQ2xGLE9BQU8sV0FBWTtRQUNqQixNQUFNLElBQUksTUFBTSxRQUFRLElBQUksYUFBYSxhQUFlRSx5QkFBd0IsQ0FBTSxDQUFKLDhGQUFtRztJQUN2TDtBQUNGOzs7QUVWTyxTQUFTLFdBQWMsQ0FBQSxFQUF3QixDQUFDO0FBQ2hELFNBQVMsV0FBNkIsTUFBQTtJQUFBLElBQUEsSUFBQSxPQUFBLFVBQUEsUUFBQSxPQUFBLFVBQUEsT0FBQSxJQUFBLE9BQUEsUUFBQSxPQUFBLEdBQUEsT0FBQSxNQUFBO1FBQWMsS0FBZCxPQUFBLEtBQUEsU0FBQSxDQUFBLEtBQWMsRUFBcUM7O0lBQzlGLE9BQU8sT0FBTyxNQUFBLENBQU8sUUFBUSxHQUFHLElBQUk7QUFDdEM7O0FDRE8sSUFBTSw2QkFBb0k7UUFBQyxFQUNoSixHQUFBLEVBQ0EsVUFBQSxFQUNBLGFBQUEsRUFDRixLQUFNO0lBQ0osTUFBTSxzQkFBc0IsR0FBa0IsT0FBZixJQUFJLFdBQVcsRUFBQTtJQUM5QyxJQUFJLHdCQUEyQztJQUMvQyxJQUFJLGtCQUErRDtJQUNuRSxNQUFNLEVBQ0oseUJBQUEsRUFDQSxzQkFBQSxFQUNGLEdBQUksSUFBSSxlQUFBO0lBSVIsTUFBTSw4QkFBOEIsQ0FBQyxjQUFpQyxXQUFtQjtRQUN2RixJQUFJLDBCQUEwQixLQUFBLENBQU0sTUFBTSxHQUFHOztZQUMzQyxNQUFNLEVBQ0osYUFBQSxFQUNBLFNBQUEsRUFDQSxPQUFBLEVBQ0YsR0FBSSxPQUFPLE9BQUE7WUFDWCwyR0FBSSxDQUFlLGFBQWEsQ0FBQSxnRUFBNUIsMkJBQTRCLENBQUksU0FBUyxDQUFBLEVBQUc7Z0JBQzlDLFlBQUEsQ0FBYSxhQUFhLENBQUEsQ0FBRyxTQUFTLENBQUEsR0FBSTtZQUM1QztZQUNBLE9BQU87UUFDVDtRQUNBLElBQUksdUJBQXVCLEtBQUEsQ0FBTSxNQUFNLEdBQUc7WUFDeEMsTUFBTSxFQUNKLGFBQUEsRUFDQSxTQUFBLEVBQ0YsR0FBSSxPQUFPLE9BQUE7WUFDWCxJQUFJLFlBQUEsQ0FBYSxhQUFhLENBQUEsRUFBRztnQkFDL0IsT0FBTyxZQUFBLENBQWEsYUFBYSxDQUFBLENBQUcsU0FBUyxDQUFBO1lBQy9DO1lBQ0EsT0FBTztRQUNUO1FBQ0EsSUFBSSxJQUFJLGVBQUEsQ0FBZ0IsaUJBQUEsQ0FBa0IsS0FBQSxDQUFNLE1BQU0sR0FBRztZQUN2RCxPQUFPLFlBQUEsQ0FBYSxPQUFPLE9BQUEsQ0FBUSxhQUFhLENBQUE7WUFDaEQsT0FBTztRQUNUO1FBQ0EsSUFBSSxXQUFXLE9BQUEsQ0FBUSxLQUFBLENBQU0sTUFBTSxHQUFHO2dCQU9uQixlQUFhO1lBTjlCLE1BQU0sRUFDSixNQUFNLEVBQ0osR0FBQSxFQUNBLFNBQUEsRUFDRixFQUNGLEdBQUk7O1lBQ0osTUFBTSw4Q0FBVywwQkFBaUIsYUFBYSxDQUFBLDhDQUE5QixvQkFBOEIsR0FBTSxDQUFDO1lBQ3RELFFBQUEsQ0FBUyxHQUFZLE9BQVQsU0FBUyxFQUFBLFNBQVUsR0FBQSxHQUFJLENBQUM7WUFDcEMsSUFBSSxJQUFJLFNBQUEsRUFBVzs7Z0JBQ2pCLFFBQUEsQ0FBUyxTQUFTLENBQUEsR0FBSSx3Q0FBSSxtQkFBQSwrRUFBdUIsUUFBQSxDQUFTLFNBQVMsQ0FBQSx1Q0FBSyxDQUFDO1lBQzNFO1lBQ0EsT0FBTztRQUNUO1FBQ0EsSUFBSSxVQUFVO1FBQ2QsSUFBSSxXQUFXLFNBQUEsQ0FBVSxLQUFBLENBQU0sTUFBTSxLQUFLLFdBQVcsUUFBQSxDQUFTLEtBQUEsQ0FBTSxNQUFNLEdBQUc7WUFDM0UsTUFBTSxRQUFRLFlBQUEsQ0FBYSxPQUFPLElBQUEsQ0FBSyxHQUFBLENBQUksYUFBYSxDQUFBLElBQUssQ0FBQztZQUM5RCxNQUFNLE1BQU0sR0FBd0IsT0FBckIsT0FBTyxJQUFBLENBQUssU0FBUyxFQUFBO1lBQ3BDLFlBQUEsVUFBWSxDQUFDLENBQUMsS0FBQSxDQUFNLEdBQUcsQ0FBQTtZQUN2QixPQUFPLEtBQUEsQ0FBTSxHQUFHLENBQUE7UUFDbEI7UUFDQSxJQUFJLFdBQVcsUUFBQSxDQUFTLEtBQUEsQ0FBTSxNQUFNLEdBQUc7WUFDckMsTUFBTSxFQUNKLE1BQU0sRUFDSixTQUFBLEVBQ0EsR0FBQSxFQUNBLFNBQUEsRUFDRixFQUNGLEdBQUk7WUFDSixJQUFJLGFBQWEsSUFBSSxTQUFBLEVBQVc7OztnQkFDOUIsTUFBTSxnREFBVywyQkFBaUIsYUFBYSxDQUFBLG1DQUE5QixjQUFBLENBQWEsb0JBQWlCLEdBQU0sQ0FBQzsrQ0FDaEM7Z0JBQXRCLFFBQUEsQ0FBUyxTQUFTLENBQUEsNkNBQVEsbUJBQUEsaUZBQXVCLFFBQUEsQ0FBUyxTQUFTLENBQUEseUNBQUssQ0FBQztnQkFDekUsVUFBVTtZQUNaO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxNQUFNLG1CQUFtQixJQUFNLGNBQWMsb0JBQUE7SUFDN0MsTUFBTSx1QkFBdUIsQ0FBQyxrQkFBMEI7UUFDdEQsTUFBTSxnQkFBZ0IsaUJBQWlCOztRQUN2QyxNQUFNLDJEQUEyQixhQUFBLENBQWMsYUFBYSxDQUFBLHVGQUFLLENBQUM7UUFDbEUsT0FBTyxnQkFBZ0Isd0JBQXdCO0lBQ2pEO0lBQ0EsTUFBTSxzQkFBc0IsQ0FBQyxlQUF1QixjQUFzQjs7UUFDeEUsTUFBTSxnQkFBZ0IsaUJBQWlCO1FBQ3ZDLE9BQU8sQ0FBQyxnR0FBQyxhQUFBLENBQWdCLGFBQWEsQ0FBQSw2RkFBQSxDQUFJLFNBQVMsQ0FBQTtJQUNyRDtJQUNBLE1BQU0sd0JBQStDO1FBQ25EO1FBQ0E7UUFDQTtJQUNGO0lBQ0EsT0FBTyxDQUFDLFFBQVEsVUFBb0Y7UUFDbEcsSUFBSSxDQUFDLHVCQUF1QjtZQUUxQix3QkFBd0IsS0FBSyxLQUFBLENBQU0sS0FBSyxTQUFBLENBQVUsY0FBYyxvQkFBb0IsQ0FBQztRQUN2RjtRQUNBLElBQUksSUFBSSxJQUFBLENBQUssYUFBQSxDQUFjLEtBQUEsQ0FBTSxNQUFNLEdBQUc7WUFDeEMsd0JBQXdCLGNBQWMsb0JBQUEsR0FBdUIsQ0FBQztZQUM5RCxrQkFBa0I7WUFDbEIsT0FBTztnQkFBQztnQkFBTSxLQUFLO2FBQUE7UUFDckI7UUFNQSxJQUFJLElBQUksZUFBQSxDQUFnQiw2QkFBQSxDQUE4QixLQUFBLENBQU0sTUFBTSxHQUFHO1lBQ25FLE9BQU87Z0JBQUM7Z0JBQU8scUJBQXFCO2FBQUE7UUFDdEM7UUFHQSxNQUFNLFlBQVksNEJBQTRCLGNBQWMsb0JBQUEsRUFBc0IsTUFBTTtRQUN4RixJQUFJLHVCQUF1QjtRQUMzQixJQUFJLFdBQVc7WUFDYixJQUFJLENBQUMsaUJBQWlCO2dCQU1wQixrQkFBa0IsV0FBVyxNQUFNO29CQUVqQyxNQUFNLG1CQUFzQyxLQUFLLEtBQUEsQ0FBTSxLQUFLLFNBQUEsQ0FBVSxjQUFjLG9CQUFvQixDQUFDO29CQUV6RyxNQUFNLENBQUMsRUFBRSxPQUFPLENBQUEsa0pBQUlFLHFCQUFBQSxFQUFtQix1QkFBdUIsSUFBTSxnQkFBZ0I7b0JBR3BGLE1BQU0sSUFBQSxDQUFLLElBQUksZUFBQSxDQUFnQixvQkFBQSxDQUFxQixPQUFPLENBQUM7b0JBRTVELHdCQUF3QjtvQkFDeEIsa0JBQWtCO2dCQUNwQixHQUFHLEdBQUc7WUFDUjtZQUNBLE1BQU0sNEJBQTRCLE9BQU8sT0FBTyxJQUFBLElBQVEsWUFBWSxDQUFDLENBQUMsT0FBTyxJQUFBLENBQUssVUFBQSxDQUFXLG1CQUFtQjtZQUNoSCxNQUFNLGlDQUFpQyxXQUFXLFFBQUEsQ0FBUyxLQUFBLENBQU0sTUFBTSxLQUFLLE9BQU8sSUFBQSxDQUFLLFNBQUEsSUFBYSxDQUFDLENBQUMsT0FBTyxJQUFBLENBQUssR0FBQSxDQUFJLFNBQUE7WUFDdkgsdUJBQXVCLENBQUMsNkJBQTZCLENBQUM7UUFDeEQ7UUFDQSxPQUFPO1lBQUM7WUFBc0IsS0FBSztTQUFBO0lBQ3JDO0FBQ0Y7O0FDN0lBLFNBQVMsY0FBYyxHQUFBLEVBQXVCO0lBRzVDLElBQUEsTUFBVyxLQUFLLElBQUs7UUFFbkIsT0FBTztJQUNUO0lBQ0EsT0FBTztBQUNUO0FBZU8sSUFBTSxtQ0FBbUMsYUFBZ0IsTUFBUTtBQUNqRSxJQUFNLDhCQUFzRDtRQUFDLEVBQ2xFLFdBQUEsRUFDQSxHQUFBLEVBQ0EsVUFBQSxFQUNBLE9BQUEsRUFDQSxhQUFBLEVBQ0EsV0FBVyxFQUNULGdCQUFBLEVBQ0EsWUFBQSxFQUNGLEVBQ0YsS0FBTTtJQUNKLE1BQU0sRUFDSixpQkFBQSxFQUNBLHNCQUFBLEVBQ0Esb0JBQUEsRUFDRixHQUFJLElBQUksZUFBQTtJQUNSLE1BQU0sMk5BQXdCLFVBQUEsRUFBUSx1QkFBdUIsS0FBQSxFQUFPLFdBQVcsU0FBQSxFQUFXLFdBQVcsUUFBQSxFQUFVLHFCQUFxQixLQUFLO0lBQ3pJLFNBQVMsZ0NBQWdDLGFBQUEsRUFBdUI7UUFDOUQsTUFBTSxnQkFBZ0IsY0FBYyxvQkFBQSxDQUFxQixhQUFhLENBQUE7UUFDdEUsT0FBTyxDQUFDLENBQUMsaUJBQWlCLENBQUMsY0FBYyxhQUFhO0lBQ3hEO0lBQ0EsTUFBTSx5QkFBb0QsQ0FBQztJQUMzRCxNQUFNLFVBQXdDLENBQUMsUUFBUSxPQUFPQyxtQkFBa0I7UUFDOUUsTUFBTSxRQUFRLE1BQU0sUUFBQSxDQUFTO1FBQzdCLE1BQU0sU0FBUyxhQUFhLEtBQUs7UUFDakMsSUFBSSxzQkFBc0IsTUFBTSxHQUFHO1lBQ2pDLElBQUk7WUFDSixJQUFJLHFCQUFxQixLQUFBLENBQU0sTUFBTSxHQUFHO2dCQUN0QyxpQkFBaUIsT0FBTyxPQUFBLENBQVEsR0FBQSxDQUFJLENBQUEsUUFBUyxNQUFNLGdCQUFBLENBQWlCLGFBQWE7WUFDbkYsT0FBTztnQkFDTCxNQUFNLEVBQ0osYUFBQSxFQUNGLEdBQUksdUJBQXVCLEtBQUEsQ0FBTSxNQUFNLElBQUksT0FBTyxPQUFBLEdBQVUsT0FBTyxJQUFBLENBQUssR0FBQTtnQkFDeEUsaUJBQWlCO29CQUFDLGFBQWE7aUJBQUE7WUFDakM7WUFDQSxzQkFBc0IsZ0JBQWdCLE9BQU8sTUFBTTtRQUNyRDtRQUNBLElBQUksSUFBSSxJQUFBLENBQUssYUFBQSxDQUFjLEtBQUEsQ0FBTSxNQUFNLEdBQUc7WUFDeEMsS0FBQSxNQUFXLENBQUMsS0FBSyxPQUFPLENBQUEsSUFBSyxPQUFPLE9BQUEsQ0FBUSxzQkFBc0IsRUFBRztnQkFDbkUsSUFBSSxRQUFTLENBQUEsYUFBYSxPQUFPO2dCQUNqQyxPQUFPLHNCQUFBLENBQXVCLEdBQUcsQ0FBQTtZQUNuQztRQUNGO1FBQ0EsSUFBSSxRQUFRLGtCQUFBLENBQW1CLE1BQU0sR0FBRztZQUN0QyxNQUFNLEVBQ0osT0FBQSxFQUNGLEdBQUksUUFBUSxzQkFBQSxDQUF1QixNQUFNO1lBSXpDLHNCQUFzQixPQUFPLElBQUEsQ0FBSyxPQUFPLEdBQXNCLE9BQU8sTUFBTTtRQUM5RTtJQUNGO0lBQ0EsU0FBUyxzQkFBc0IsU0FBQSxFQUE0QkMsSUFBQUEsRUFBdUIsTUFBQSxFQUE2QjtRQUM3RyxNQUFNLFFBQVFBLEtBQUksUUFBQSxDQUFTO1FBQzNCLEtBQUEsTUFBVyxpQkFBaUIsVUFBVztZQUNyQyxNQUFNLFFBQVEsaUJBQWlCLE9BQU8sYUFBYTtZQUNuRCxrQkFBa0IsNkRBQWUsTUFBTyxZQUFBLEVBQWNBLE1BQUssTUFBTTtRQUNuRTtJQUNGO0lBQ0EsU0FBUyxrQkFBa0IsYUFBQSxFQUE4QixZQUFBLEVBQWtDQSxJQUFBQSxFQUF1QixNQUFBLEVBQTZCO1FBQzdJLE1BQU0scUJBQXFCLFFBQVEsbUJBQUEsQ0FBb0IsWUFBYSxDQUFBOztRQUNwRSxNQUFNLHdKQUF3QyxpQkFBQSxpRUFBcEIsd0NBQXlDLE9BQU8saUJBQUE7UUFDMUUsSUFBSSxzQkFBc0IsVUFBVTtZQUVsQztRQUNGO1FBS0EsTUFBTSx5QkFBeUIsS0FBSyxHQUFBLENBQUksR0FBRyxLQUFLLEdBQUEsQ0FBSSxtQkFBbUIsZ0NBQWdDLENBQUM7UUFDeEcsSUFBSSxDQUFDLGdDQUFnQyxhQUFhLEdBQUc7WUFDbkQsTUFBTSxpQkFBaUIsc0JBQUEsQ0FBdUIsYUFBYSxDQUFBO1lBQzNELElBQUksZ0JBQWdCO2dCQUNsQixhQUFhLGNBQWM7WUFDN0I7WUFDQSxzQkFBQSxDQUF1QixhQUFhLENBQUEsR0FBSSxXQUFXLE1BQU07Z0JBQ3ZELElBQUksQ0FBQyxnQ0FBZ0MsYUFBYSxHQUFHO29CQUNuREEsS0FBSSxRQUFBLENBQVMsa0JBQWtCO3dCQUM3QjtvQkFDRixDQUFDLENBQUM7Z0JBQ0o7Z0JBQ0EsT0FBTyxzQkFBQSxDQUF3QixhQUFhLENBQUE7WUFDOUMsR0FBRyx5QkFBeUIsR0FBSTtRQUNsQztJQUNGO0lBQ0EsT0FBTztBQUNUOztBQzNCQSxJQUFNLHFCQUFxQixJQUFJLE1BQU0sa0RBQWtEO0FBR2hGLElBQU0sNkJBQXFEO1FBQUMsRUFDakUsR0FBQSxFQUNBLFdBQUEsRUFDQSxPQUFBLEVBQ0EsVUFBQSxFQUNBLGFBQUEsRUFDQSxhQUFBLEVBQ0EsV0FBVyxFQUNULGdCQUFBLEVBQ0EsY0FBQSxFQUNGLEVBQ0YsS0FBTTtJQUNKLE1BQU0sa05BQWUscUJBQUEsRUFBbUIsVUFBVTtJQUNsRCxNQUFNLGtCQUFrQix3TkFBQSxFQUFtQixhQUFhO0lBQ3hELE1BQU0sc05BQW1CLGNBQUEsRUFBWSxZQUFZLGFBQWE7SUFROUQsTUFBTSxlQUErQyxDQUFDO0lBQ3RELFNBQVMsc0JBQXNCLFFBQUEsRUFBa0IsSUFBQSxFQUFlLElBQUEsRUFBZTtRQUM3RSxNQUFNLFlBQVksWUFBQSxDQUFhLFFBQVEsQ0FBQTtRQUN2QywwREFBSSxVQUFXLGFBQUEsRUFBZTtZQUM1QixVQUFVLGFBQUEsQ0FBYztnQkFDdEI7Z0JBQ0E7WUFDRixDQUFDO1lBQ0QsT0FBTyxVQUFVLGFBQUE7UUFDbkI7SUFDRjtJQUNBLFNBQVMscUJBQXFCLFFBQUEsRUFBa0I7UUFDOUMsTUFBTSxZQUFZLFlBQUEsQ0FBYSxRQUFRLENBQUE7UUFDdkMsSUFBSSxXQUFXO1lBQ2IsT0FBTyxZQUFBLENBQWEsUUFBUSxDQUFBO1lBQzVCLFVBQVUsaUJBQUEsQ0FBa0I7UUFDOUI7SUFDRjtJQUNBLE1BQU0sVUFBd0MsQ0FBQyxRQUFRLE9BQU8sZ0JBQWdCO1FBQzVFLE1BQU0sV0FBVyxZQUFZLE1BQU07UUFDbkMsU0FBUyxvQkFBb0IsWUFBQSxFQUFzQkMsU0FBQUEsRUFBeUIsU0FBQSxFQUFtQixZQUFBLEVBQXVCO1lBQ3BILE1BQU0sV0FBVyxpQkFBaUIsYUFBYUEsU0FBUTtZQUN2RCxNQUFNLFdBQVcsaUJBQWlCLE1BQU0sUUFBQSxDQUFTLEdBQUdBLFNBQVE7WUFDNUQsSUFBSSxDQUFDLFlBQVksVUFBVTtnQkFDekIsYUFBYSxjQUFjLGNBQWNBLFdBQVUsT0FBTyxTQUFTO1lBQ3JFO1FBQ0Y7UUFDQSxJQUFJLFdBQVcsT0FBQSxDQUFRLEtBQUEsQ0FBTSxNQUFNLEdBQUc7WUFDcEMsb0JBQW9CLE9BQU8sSUFBQSxDQUFLLEdBQUEsQ0FBSSxZQUFBLEVBQWMsVUFBVSxPQUFPLElBQUEsQ0FBSyxTQUFBLEVBQVcsT0FBTyxJQUFBLENBQUssR0FBQSxDQUFJLFlBQVk7UUFDakgsT0FBQSxJQUFXLElBQUksZUFBQSxDQUFnQixvQkFBQSxDQUFxQixLQUFBLENBQU0sTUFBTSxHQUFHO1lBQ2pFLEtBQUEsTUFBVyxFQUNULGdCQUFBLEVBQ0EsS0FBQSxFQUNGLElBQUssT0FBTyxPQUFBLENBQVM7Z0JBQ25CLE1BQU0sRUFDSixZQUFBLEVBQ0EsWUFBQSxFQUNBLGFBQUEsRUFDRixHQUFJO2dCQUNKLG9CQUFvQixjQUFjLGVBQWUsT0FBTyxJQUFBLENBQUssU0FBQSxFQUFXLFlBQVk7Z0JBQ3BGLHNCQUFzQixlQUFlLE9BQU8sQ0FBQyxDQUFDO1lBQ2hEO1FBQ0YsT0FBQSxJQUFXLGNBQWMsT0FBQSxDQUFRLEtBQUEsQ0FBTSxNQUFNLEdBQUc7WUFDOUMsTUFBTSxRQUFRLE1BQU0sUUFBQSxDQUFTLENBQUEsQ0FBRSxXQUFXLENBQUEsQ0FBRSxTQUFBLENBQVUsUUFBUSxDQUFBO1lBQzlELElBQUksT0FBTztnQkFDVCxhQUFhLE9BQU8sSUFBQSxDQUFLLEdBQUEsQ0FBSSxZQUFBLEVBQWMsT0FBTyxJQUFBLENBQUssR0FBQSxDQUFJLFlBQUEsRUFBYyxVQUFVLE9BQU8sT0FBTyxJQUFBLENBQUssU0FBUztZQUNqSDtRQUNGLE9BQUEsSUFBVyxpQkFBaUIsTUFBTSxHQUFHO1lBQ25DLHNCQUFzQixVQUFVLE9BQU8sT0FBQSxFQUFTLE9BQU8sSUFBQSxDQUFLLGFBQWE7UUFDM0UsT0FBQSxJQUFXLElBQUksZUFBQSxDQUFnQixpQkFBQSxDQUFrQixLQUFBLENBQU0sTUFBTSxLQUFLLElBQUksZUFBQSxDQUFnQixvQkFBQSxDQUFxQixLQUFBLENBQU0sTUFBTSxHQUFHO1lBQ3hILHFCQUFxQixRQUFRO1FBQy9CLE9BQUEsSUFBVyxJQUFJLElBQUEsQ0FBSyxhQUFBLENBQWMsS0FBQSxDQUFNLE1BQU0sR0FBRztZQUMvQyxLQUFBLE1BQVdBLGFBQVksT0FBTyxJQUFBLENBQUssWUFBWSxFQUFHO2dCQUNoRCxxQkFBcUJBLFNBQVE7WUFDL0I7UUFDRjtJQUNGO0lBQ0EsU0FBUyxZQUFZLE1BQUEsRUFBYTtRQUNoQyxJQUFJLGFBQWEsTUFBTSxFQUFHLENBQUEsT0FBTyxPQUFPLElBQUEsQ0FBSyxHQUFBLENBQUksYUFBQTtRQUNqRCxJQUFJLGdCQUFnQixNQUFNLEdBQUc7O1lBQzNCLE9BQU8seUNBQU8sSUFBQSxDQUFLLEdBQUEsQ0FBSSxhQUFBLDJGQUFpQixPQUFPLElBQUEsQ0FBSyxTQUFBO1FBQ3REO1FBQ0EsSUFBSSxJQUFJLGVBQUEsQ0FBZ0IsaUJBQUEsQ0FBa0IsS0FBQSxDQUFNLE1BQU0sRUFBRyxDQUFBLE9BQU8sT0FBTyxPQUFBLENBQVEsYUFBQTtRQUMvRSxJQUFJLElBQUksZUFBQSxDQUFnQixvQkFBQSxDQUFxQixLQUFBLENBQU0sTUFBTSxFQUFHLENBQUEsT0FBTyxvQkFBb0IsT0FBTyxPQUFPO1FBQ3JHLE9BQU87SUFDVDtJQUNBLFNBQVMsYUFBYSxZQUFBLEVBQXNCLFlBQUEsRUFBbUIsYUFBQSxFQUF1QixLQUFBLEVBQXlCLFNBQUEsRUFBbUI7UUFDaEksTUFBTSxxQkFBcUIsUUFBUSxtQkFBQSxDQUFvQixZQUFZLENBQUE7UUFDbkUsTUFBTSw0RkFBb0IsbUJBQW9CLGlCQUFBO1FBQzlDLElBQUksQ0FBQyxrQkFBbUIsQ0FBQTtRQUN4QixNQUFNLFlBQVksQ0FBQztRQUNuQixNQUFNLG9CQUFvQixJQUFJLFFBQWMsQ0FBQSxZQUFXO1lBQ3JELFVBQVUsaUJBQUEsR0FBb0I7UUFDaEMsQ0FBQztRQUNELE1BQU0sa0JBRzBCLFFBQVEsSUFBQSxDQUFLO1lBQUMsSUFBSSxRQUcvQyxDQUFBLFlBQVc7Z0JBQ1osVUFBVSxhQUFBLEdBQWdCO1lBQzVCLENBQUM7WUFBRyxrQkFBa0IsSUFBQSxDQUFLLE1BQU07Z0JBQy9CLE1BQU07WUFDUixDQUFDLENBQUM7U0FBQztRQUdILGdCQUFnQixLQUFBLENBQU0sS0FBTyxDQUFELEFBQUU7UUFDOUIsWUFBQSxDQUFhLGFBQWEsQ0FBQSxHQUFJO1FBQzlCLE1BQU0sV0FBWSxJQUFJLFNBQUEsQ0FBVSxZQUFZLENBQUEsQ0FBVSxNQUFBLENBQU8scUJBQXFCLGtCQUFrQixJQUFJLGVBQWUsYUFBYTtRQUNwSSxNQUFNLFFBQVEsTUFBTSxRQUFBLENBQVMsQ0FBQyxHQUFHLElBQUlDLFNBQVVBLE1BQUs7UUFDcEQsTUFBTSxlQUFlO1lBQ25CLEdBQUcsS0FBQTtZQUNILGVBQWUsSUFBTSxTQUFTLE1BQU0sUUFBQSxDQUFTLENBQUM7WUFDOUM7WUFDQTtZQUNBLGtCQUFtQixxQkFBcUIsa0JBQWtCLElBQUksQ0FBQyxlQUE4QixNQUFNLFFBQUEsQ0FBUyxJQUFJLElBQUEsQ0FBSyxlQUFBLENBQWdCLGNBQXVCLGNBQXVCLFlBQVksQ0FBQyxJQUFJLEtBQUE7WUFDcE07WUFDQTtRQUNGO1FBQ0EsTUFBTSxpQkFBaUIsa0JBQWtCLGNBQWMsWUFBbUI7UUFFMUUsUUFBUSxPQUFBLENBQVEsY0FBYyxFQUFFLEtBQUEsQ0FBTSxDQUFBLE1BQUs7WUFDekMsSUFBSSxNQUFNLG1CQUFvQixDQUFBO1lBQzlCLE1BQU07UUFDUixDQUFDO0lBQ0g7SUFDQSxPQUFPO0FBQ1Q7O0FDOU5PLElBQU0sdUJBQStDO1FBQUMsRUFDM0QsR0FBQSxFQUNBLFNBQVMsRUFDUCxNQUFBLEVBQ0YsRUFDQSxXQUFBLEVBQ0YsS0FBTTtJQUNKLE9BQU8sQ0FBQyxRQUFRLFVBQVU7UUFDeEIsSUFBSSxJQUFJLElBQUEsQ0FBSyxhQUFBLENBQWMsS0FBQSxDQUFNLE1BQU0sR0FBRztZQUV4QyxNQUFNLFFBQUEsQ0FBUyxJQUFJLGVBQUEsQ0FBZ0Isb0JBQUEsQ0FBcUIsTUFBTSxDQUFDO1FBQ2pFO1FBQ0EsSUFBSSx3S0FBTyxVQUFBLEtBQVksZUFBZSxRQUFRLElBQUksd0NBQWEsZUFBZTtnQkFDZTtZQUEzRixJQUFJLElBQUksZUFBQSxDQUFnQixvQkFBQSxDQUFxQixLQUFBLENBQU0sTUFBTSxLQUFLLE9BQU8sT0FBQSxLQUFZLGdEQUFnQixRQUFBLENBQVMsQ0FBQSxDQUFFLFdBQVcsQ0FBQSxrSUFBRyxNQUFBLDBHQUFRLG9CQUFBLE1BQXlCLFlBQVk7Z0JBQ3JLLFFBQVEsSUFBQSxDQUFLLHlFQUN5RSxPQURBLFdBQVcsRUFBQSxvR0FFTixDQUFFLHNCQURTLFFBQVEsb0dBQ3JCLEVBQUU7WUFDN0Y7UUFDRjtJQUNGO0FBQ0Y7O0FDYk8sSUFBTSxpQ0FBeUQ7UUFBQyxFQUNyRSxXQUFBLEVBQ0EsT0FBQSxFQUNBLFNBQVMsRUFDUCxtQkFBQSxFQUNGLEVBQ0EsYUFBQSxFQUNBLFVBQUEsRUFDQSxHQUFBLEVBQ0EsYUFBQSxFQUNBLFlBQUEsRUFDQSxhQUFBLEVBQ0YsS0FBTTtJQUNKLE1BQU0sRUFDSixpQkFBQSxFQUNGLEdBQUksSUFBSSxlQUFBO0lBQ1IsTUFBTSwyTkFBd0IsVUFBQSxxTUFBUSxjQUFBLEVBQVksYUFBYSxHQUFHLHlOQUFBLEVBQW9CLGFBQWEsQ0FBQztJQUNwRyxNQUFNLGdOQUFhLFVBQUEscU1BQVEsY0FBQSxFQUFZLGVBQWUsVUFBVSxJQUFHLCtNQUFBLEVBQVcsZUFBZSxVQUFVLENBQUM7SUFDeEcsSUFBSSwwQkFBd0QsQ0FBQyxDQUFBO0lBQzdELE1BQU0sVUFBd0MsQ0FBQyxRQUFRLFVBQVU7UUFDL0QsSUFBSSxzQkFBc0IsTUFBTSxHQUFHO1lBQ2pDLGVBQWUseUJBQXlCLFFBQVEsbUJBQW1CLHFCQUFxQixhQUFhLEdBQUcsS0FBSztRQUMvRyxPQUFBLElBQVcsV0FBVyxNQUFNLEdBQUc7WUFDN0IsZUFBZSxDQUFDLENBQUEsRUFBRyxLQUFLO1FBQzFCLE9BQUEsSUFBVyxJQUFJLElBQUEsQ0FBSyxjQUFBLENBQWUsS0FBQSxDQUFNLE1BQU0sR0FBRztZQUNoRCxlQUFlLG9CQUFvQixPQUFPLE9BQUEsRUFBUyxLQUFBLEdBQVcsS0FBQSxHQUFXLEtBQUEsR0FBVyxLQUFBLEdBQVcsYUFBYSxHQUFHLEtBQUs7UUFDdEg7SUFDRjtJQUNBLFNBQVMsbUJBQW1CLEtBQUEsRUFBMkQ7UUFDckYsTUFBTSxFQUNKLE9BQUEsRUFDQSxTQUFBLEVBQ0YsR0FBSTtRQUNKLEtBQUEsTUFBVyxlQUFlO1lBQUM7WUFBUyxTQUFTO1NBQUEsQ0FBRztZQUM5QyxJQUFBLE1BQVcsT0FBTyxZQUFhO29CQUN6QjtnQkFBSixvQ0FBSSxDQUFZLEdBQUcsQ0FBQSxzRUFBRyxNQUFBLE1BQUEsVUFBQSxXQUFBLEdBQWdDLEVBQUEsT0FBTztZQUMvRDtRQUNGO1FBQ0EsT0FBTztJQUNUO0lBQ0EsU0FBUyxlQUFlLE9BQUEsRUFBZ0QsS0FBQSxFQUF5QjtRQUMvRixNQUFNLFlBQVksTUFBTSxRQUFBLENBQVM7UUFDakMsTUFBTSxRQUFRLFNBQUEsQ0FBVSxXQUFXLENBQUE7UUFDbkMsd0JBQXdCLElBQUEsQ0FBSyxHQUFHLE9BQU87UUFDdkMsSUFBSSxNQUFNLE1BQUEsQ0FBTyxvQkFBQSxLQUF5QixhQUFhLG1CQUFtQixLQUFLLEdBQUc7WUFDaEY7UUFDRjtRQUNBLE1BQU0sT0FBTztRQUNiLDBCQUEwQixDQUFDLENBQUE7UUFDM0IsSUFBSSxLQUFLLE1BQUEsS0FBVyxFQUFHLENBQUE7UUFDdkIsTUFBTSxlQUFlLElBQUksSUFBQSxDQUFLLG1CQUFBLENBQW9CLFdBQVcsSUFBSTtRQUNqRSxRQUFRLEtBQUEsQ0FBTSxNQUFNO1lBQ2xCLE1BQU0sY0FBYyxNQUFNLElBQUEsQ0FBSyxhQUFhLE1BQUEsQ0FBTyxDQUFDO1lBQ3BELEtBQUEsTUFBVyxFQUNULGFBQUEsRUFDRixJQUFLLFlBQWE7Z0JBQ2hCLE1BQU0sZ0JBQWdCLE1BQU0sT0FBQSxDQUFRLGFBQWEsQ0FBQTs7Z0JBQ2pELE1BQU0sNEVBQXVCLGNBQWMsb0JBQUEsQ0FBcUIsYUFBYSxDQUFBLGlJQUFLLENBQUM7Z0JBQ25GLElBQUksZUFBZTtvQkFDakIsSUFBSSxnQkFBZ0Isb0JBQW9CLE1BQU0sR0FBRzt3QkFDL0MsTUFBTSxRQUFBLENBQVMsa0JBQWtCOzRCQUMvQjt3QkFDRixDQUFDLENBQUM7b0JBQ0osT0FBQSxJQUFXLGNBQWMsTUFBQSxLQUFBLGdCQUFBLGlCQUFBLEtBQXNDO3dCQUM3RCxNQUFNLFFBQUEsQ0FBUyxhQUFhLGFBQWEsQ0FBQztvQkFDNUM7Z0JBQ0Y7WUFDRjtRQUNGLENBQUM7SUFDSDtJQUNBLE9BQU87QUFDVDs7QUM1RU8sSUFBTSxzQkFBOEM7UUFBQyxFQUMxRCxXQUFBLEVBQ0EsVUFBQSxFQUNBLEdBQUEsRUFDQSxZQUFBLEVBQ0EsYUFBQSxFQUNGLEtBQU07SUFDSixNQUFNLGVBSUQsQ0FBQztJQUNOLE1BQU0sVUFBd0MsQ0FBQyxRQUFRLFVBQVU7UUFDL0QsSUFBSSxJQUFJLGVBQUEsQ0FBZ0IseUJBQUEsQ0FBMEIsS0FBQSxDQUFNLE1BQU0sS0FBSyxJQUFJLGVBQUEsQ0FBZ0Isc0JBQUEsQ0FBdUIsS0FBQSxDQUFNLE1BQU0sR0FBRztZQUMzSCxzQkFBc0IsT0FBTyxPQUFBLEVBQVMsS0FBSztRQUM3QztRQUNBLElBQUksV0FBVyxPQUFBLENBQVEsS0FBQSxDQUFNLE1BQU0sS0FBSyxXQUFXLFFBQUEsQ0FBUyxLQUFBLENBQU0sTUFBTSxLQUFLLE9BQU8sSUFBQSxDQUFLLFNBQUEsRUFBVztZQUNsRyxzQkFBc0IsT0FBTyxJQUFBLENBQUssR0FBQSxFQUFLLEtBQUs7UUFDOUM7UUFDQSxJQUFJLFdBQVcsU0FBQSxDQUFVLEtBQUEsQ0FBTSxNQUFNLEtBQUssV0FBVyxRQUFBLENBQVMsS0FBQSxDQUFNLE1BQU0sS0FBSyxDQUFDLE9BQU8sSUFBQSxDQUFLLFNBQUEsRUFBVztZQUNyRyxjQUFjLE9BQU8sSUFBQSxDQUFLLEdBQUEsRUFBSyxLQUFLO1FBQ3RDO1FBQ0EsSUFBSSxJQUFJLElBQUEsQ0FBSyxhQUFBLENBQWMsS0FBQSxDQUFNLE1BQU0sR0FBRztZQUN4QyxXQUFXO1FBQ2I7SUFDRjtJQUNBLFNBQVMsMkJBQTJCLGFBQUEsRUFBOEJDLElBQUFBLEVBQXVCO1FBQ3ZGLE1BQU0sUUFBUUEsS0FBSSxRQUFBLENBQVMsQ0FBQSxDQUFFLFdBQVcsQ0FBQTtRQUN4QyxNQUFNLGdCQUFnQixNQUFNLE9BQUEsQ0FBUSxhQUFhLENBQUE7UUFDakQsTUFBTSxnQkFBZ0IsY0FBYyxvQkFBQSxDQUFxQixhQUFhLENBQUE7UUFDdEUsSUFBSSxDQUFDLGlCQUFpQixjQUFjLE1BQUEsS0FBQSxnQkFBQSxpQkFBQSxHQUFzQyxFQUFBO1FBQzFFLE9BQU87SUFDVDtJQUNBLFNBQVMsbUJBRVQsRUFBNEJBLElBQUFBLEVBQXVCO2NBRGpELGFBQUEsRUFDRixHQUZ1QjtRQUdyQixNQUFNLFFBQVFBLEtBQUksUUFBQSxDQUFTLENBQUEsQ0FBRSxXQUFXLENBQUE7UUFDeEMsTUFBTSxnQkFBZ0IsTUFBTSxPQUFBLENBQVEsYUFBYSxDQUFBO1FBQ2pELE1BQU0sZ0JBQWdCLGNBQWMsb0JBQUEsQ0FBcUIsYUFBYSxDQUFBO1FBQ3RFLElBQUksQ0FBQyxpQkFBaUIsY0FBYyxNQUFBLEtBQUEsZ0JBQUEsaUJBQUEsR0FBc0MsRUFBQTtRQUMxRSxNQUFNLEVBQ0oscUJBQUEsRUFDQSxzQkFBQSxFQUNGLEdBQUksMEJBQTBCLGFBQWE7UUFDM0MsSUFBSSxDQUFDLE9BQU8sUUFBQSxDQUFTLHFCQUFxQixFQUFHLENBQUE7UUFDN0MsTUFBTSxjQUFjLFlBQUEsQ0FBYSxhQUFhLENBQUE7UUFDOUMsOERBQUksWUFBYSxPQUFBLEVBQVM7WUFDeEIsYUFBYSxZQUFZLE9BQU87WUFDaEMsWUFBWSxPQUFBLEdBQVUsS0FBQTtRQUN4QjtRQUNBLE1BQU0sb0JBQW9CLEtBQUssR0FBQSxDQUFJLElBQUk7UUFDdkMsWUFBQSxDQUFhLGFBQWEsQ0FBQSxHQUFJO1lBQzVCO1lBQ0EsaUJBQWlCO1lBQ2pCLFNBQVMsV0FBVyxNQUFNO2dCQUN4QixJQUFJLE1BQU0sTUFBQSxDQUFPLE9BQUEsSUFBVyxDQUFDLHdCQUF3QjtvQkFDbkRBLEtBQUksUUFBQSxDQUFTLGFBQWEsYUFBYSxDQUFDO2dCQUMxQztnQkFDQSxjQUFjO29CQUNaO2dCQUNGLEdBQUdBLElBQUc7WUFDUixHQUFHLHFCQUFxQjtRQUMxQjtJQUNGO0lBQ0EsU0FBUyxzQkFBc0IsS0FFL0IsRUFBNEJBLElBQUFBLEVBQXVCO2NBRGpELGFBQUEsRUFDRjtRQUNFLE1BQU0sUUFBUUEsS0FBSSxRQUFBLENBQVMsQ0FBQSxDQUFFLFdBQVcsQ0FBQTtRQUN4QyxNQUFNLGdCQUFnQixNQUFNLE9BQUEsQ0FBUSxhQUFhLENBQUE7UUFDakQsTUFBTSxnQkFBZ0IsY0FBYyxvQkFBQSxDQUFxQixhQUFhLENBQUE7UUFDdEUsSUFBSSxDQUFDLGlCQUFpQixjQUFjLE1BQUEsS0FBQSxnQkFBQSxpQkFBQSxLQUFzQztZQUN4RTtRQUNGO1FBQ0EsTUFBTSxFQUNKLHFCQUFBLEVBQ0YsR0FBSSwwQkFBMEIsYUFBYTtRQUMzQyxJQUFJLENBQUMsT0FBTyxRQUFBLENBQVMscUJBQXFCLEdBQUc7WUFDM0Msa0JBQWtCLGFBQWE7WUFDL0I7UUFDRjtRQUNBLE1BQU0sY0FBYyxZQUFBLENBQWEsYUFBYSxDQUFBO1FBQzlDLE1BQU0sb0JBQW9CLEtBQUssR0FBQSxDQUFJLElBQUk7UUFDdkMsSUFBSSxDQUFDLGVBQWUsb0JBQW9CLFlBQVksaUJBQUEsRUFBbUI7WUFDckUsY0FBYztnQkFDWjtZQUNGLEdBQUdBLElBQUc7UUFDUjtJQUNGO0lBQ0EsU0FBUyxrQkFBa0IsR0FBQSxFQUFhO1FBQ3RDLE1BQU0sZUFBZSxZQUFBLENBQWEsR0FBRyxDQUFBO1FBQ3JDLGdFQUFJLGFBQWMsT0FBQSxFQUFTO1lBQ3pCLGFBQWEsYUFBYSxPQUFPO1FBQ25DO1FBQ0EsT0FBTyxZQUFBLENBQWEsR0FBRyxDQUFBO0lBQ3pCO0lBQ0EsU0FBUyxhQUFhO1FBQ3BCLEtBQUEsTUFBVyxPQUFPLE9BQU8sSUFBQSxDQUFLLFlBQVksRUFBRztZQUMzQyxrQkFBa0IsR0FBRztRQUN2QjtJQUNGO0lBQ0EsU0FBUzswQkFBMEIsaUVBQTJCLENBQUMsR0FBRztRQUNoRSxJQUFJLHlCQUE4QztRQUNsRCxJQUFJLHdCQUF3QixPQUFPLGlCQUFBO1FBQ25DLElBQUEsSUFBUyxPQUFPLFlBQWE7WUFDM0IsSUFBSSxDQUFDLENBQUMsV0FBQSxDQUFZLEdBQUcsQ0FBQSxDQUFFLGVBQUEsRUFBaUI7Z0JBQ3RDLHdCQUF3QixLQUFLLEdBQUEsQ0FBSSxXQUFBLENBQVksR0FBRyxDQUFBLENBQUUsZUFBQSxFQUFrQixxQkFBcUI7Z0JBQ3pGLHlCQUF5QixXQUFBLENBQVksR0FBRyxDQUFBLENBQUUsc0JBQUEsSUFBMEI7WUFDdEU7UUFDRjtRQUNBLE9BQU87WUFDTDtZQUNBO1FBQ0Y7SUFDRjtJQUNBLE9BQU87QUFDVDs7QUNrTk8sSUFBTSw2QkFBcUQ7UUFBQyxFQUNqRSxHQUFBLEVBQ0EsT0FBQSxFQUNBLFVBQUEsRUFDQSxhQUFBLEVBQ0YsS0FBTTtJQUNKLE1BQU0sa0JBQWlCLDhNQUFBLEVBQVUsWUFBWSxhQUFhO0lBQzFELE1BQU0scU5BQWtCLGFBQUEsRUFBVyxZQUFZLGFBQWE7SUFDNUQsTUFBTSxxQkFBb0IsZ05BQUEsRUFBWSxZQUFZLGFBQWE7SUFRL0QsTUFBTSxlQUErQyxDQUFDO0lBQ3RELE1BQU0sVUFBd0MsQ0FBQyxRQUFRLFVBQVU7UUFDL0QsSUFBSSxlQUFlLE1BQU0sR0FBRztZQUMxQixNQUFNLEVBQ0osU0FBQSxFQUNBLEtBQUssRUFDSCxZQUFBLEVBQ0EsWUFBQSxFQUNGLEVBQ0YsR0FBSSxPQUFPLElBQUE7WUFDWCxNQUFNLHFCQUFxQixRQUFRLG1CQUFBLENBQW9CLFlBQVksQ0FBQTtZQUNuRSxNQUFNLGlCQUFpQiwyRkFBb0IsY0FBQTtZQUMzQyxJQUFJLGdCQUFnQjtnQkFDbEIsTUFBTSxZQUFZLENBQUM7Z0JBQ25CLE1BQU0saUJBQWlCLElBQUssUUFHVyxDQUFDLFNBQVMsV0FBVztvQkFDMUQsVUFBVSxPQUFBLEdBQVU7b0JBQ3BCLFVBQVUsTUFBQSxHQUFTO2dCQUNyQixDQUFDO2dCQUdELGVBQWUsS0FBQSxDQUFNLEtBQU8sQ0FBRCxBQUFFO2dCQUM3QixZQUFBLENBQWEsU0FBUyxDQUFBLEdBQUk7Z0JBQzFCLE1BQU0sV0FBWSxJQUFJLFNBQUEsQ0FBVSxZQUFZLENBQUEsQ0FBVSxNQUFBLENBQU8scUJBQXFCLGtCQUFrQixJQUFJLGVBQWUsU0FBUztnQkFDaEksTUFBTSxRQUFRLE1BQU0sUUFBQSxDQUFTLENBQUMsR0FBRyxJQUFJQyxTQUFVQSxNQUFLO2dCQUNwRCxNQUFNLGVBQWU7b0JBQ25CLEdBQUcsS0FBQTtvQkFDSCxlQUFlLElBQU0sU0FBUyxNQUFNLFFBQUEsQ0FBUyxDQUFDO29CQUM5QztvQkFDQTtvQkFDQSxrQkFBbUIscUJBQXFCLGtCQUFrQixJQUFJLENBQUMsZUFBOEIsTUFBTSxRQUFBLENBQVMsSUFBSSxJQUFBLENBQUssZUFBQSxDQUFnQixjQUF1QixjQUF1QixZQUFZLENBQUMsSUFBSSxLQUFBO29CQUNwTTtnQkFDRjtnQkFDQSxlQUFlLGNBQWMsWUFBbUI7WUFDbEQ7UUFDRixPQUFBLElBQVcsa0JBQWtCLE1BQU0sR0FBRztnQkFLcEM7WUFKQSxNQUFNLEVBQ0osU0FBQSxFQUNBLGFBQUEsRUFDRixHQUFJLE9BQU8sSUFBQTthQUNYLDBCQUFBLFlBQUEsQ0FBYSxTQUFTLENBQUEsY0FBdEIsOENBQUEsd0JBQXlCLE9BQUEsQ0FBUTtnQkFDL0IsTUFBTSxPQUFPLE9BQUE7Z0JBQ2IsTUFBTTtZQUNSLENBQUM7WUFDRCxPQUFPLFlBQUEsQ0FBYSxTQUFTLENBQUE7UUFDL0IsT0FBQSxJQUFXLGdCQUFnQixNQUFNLEdBQUc7Z0JBTWxDO1lBTEEsTUFBTSxFQUNKLFNBQUEsRUFDQSxpQkFBQSxFQUNBLGFBQUEsRUFDRixHQUFJLE9BQU8sSUFBQTtnQkFFRjthQURULDJCQUFBLFlBQUEsQ0FBYSxTQUFTLENBQUEsY0FBdEIsK0NBQUEseUJBQXlCLE1BQUEsQ0FBTztnQkFDOUIsaUNBQWMsT0FBQSw2REFBVyxPQUFPLEtBQUE7Z0JBQ2hDLGtCQUFrQixDQUFDO2dCQUNuQixNQUFNO1lBQ1IsQ0FBQztZQUNELE9BQU8sWUFBQSxDQUFhLFNBQVMsQ0FBQTtRQUMvQjtJQUNGO0lBQ0EsT0FBTztBQUNUOztBQ2paTyxJQUFNLDBCQUFrRDtRQUFDLEVBQzlELFdBQUEsRUFDQSxPQUFBLEVBQ0EsR0FBQSxFQUNBLFlBQUEsRUFDQSxhQUFBLEVBQ0YsS0FBTTtJQUNKLE1BQU0sRUFDSixpQkFBQSxFQUNGLEdBQUksSUFBSSxlQUFBO0lBQ1IsTUFBTSxVQUF3QyxDQUFDLFFBQVEsVUFBVTtRQUMvRCxJQUFJLFFBQVEsS0FBQSxDQUFNLE1BQU0sR0FBRztZQUN6QixvQkFBb0IsT0FBTyxnQkFBZ0I7UUFDN0M7UUFDQSxJQUFJLFNBQVMsS0FBQSxDQUFNLE1BQU0sR0FBRztZQUMxQixvQkFBb0IsT0FBTyxvQkFBb0I7UUFDakQ7SUFDRjtJQUNBLFNBQVMsb0JBQW9CQyxJQUFBQSxFQUF1QixJQUFBLEVBQStDO1FBQ2pHLE1BQU0sUUFBUUEsS0FBSSxRQUFBLENBQVMsQ0FBQSxDQUFFLFdBQVcsQ0FBQTtRQUN4QyxNQUFNLFVBQVUsTUFBTSxPQUFBO1FBQ3RCLE1BQU0sZ0JBQWdCLGNBQWMsb0JBQUE7UUFDcEMsUUFBUSxLQUFBLENBQU0sTUFBTTtZQUNsQixLQUFBLE1BQVcsaUJBQWlCLE9BQU8sSUFBQSxDQUFLLGFBQWEsRUFBRztnQkFDdEQsTUFBTSxnQkFBZ0IsT0FBQSxDQUFRLGFBQWEsQ0FBQTtnQkFDM0MsTUFBTSx1QkFBdUIsYUFBQSxDQUFjLGFBQWEsQ0FBQTtnQkFDeEQsSUFBSSxDQUFDLHdCQUF3QixDQUFDLGNBQWUsQ0FBQTtnQkFDN0MsTUFBTSxnQkFBZ0IsT0FBTyxNQUFBLENBQU8sb0JBQW9CLEVBQUUsSUFBQSxDQUFLLENBQUEsTUFBTyxHQUFBLENBQUksSUFBSSxDQUFBLEtBQU0sSUFBSSxLQUFLLE9BQU8sTUFBQSxDQUFPLG9CQUFvQixFQUFFLEtBQUEsQ0FBTSxDQUFBLE1BQU8sR0FBQSxDQUFJLElBQUksQ0FBQSxLQUFNLEtBQUEsQ0FBUyxLQUFLLE1BQU0sTUFBQSxDQUFPLElBQUksQ0FBQTtnQkFDM0wsSUFBSSxlQUFlO29CQUNqQixJQUFJLGdCQUFnQixvQkFBb0IsTUFBTSxHQUFHO3dCQUMvQ0EsS0FBSSxRQUFBLENBQVMsa0JBQWtCOzRCQUM3Qjt3QkFDRixDQUFDLENBQUM7b0JBQ0osT0FBQSxJQUFXLGNBQWMsTUFBQSxLQUFBLGdCQUFBLGlCQUFBLEtBQXNDO3dCQUM3REEsS0FBSSxRQUFBLENBQVMsYUFBYSxhQUFhLENBQUM7b0JBQzFDO2dCQUNGO1lBQ0Y7UUFDRixDQUFDO0lBQ0g7SUFDQSxPQUFPO0FBQ1Q7O0FDM0JPLFNBQVMsZ0JBQThHLEtBQUEsRUFBaUU7SUFDN0wsTUFBTSxFQUNKLFdBQUEsRUFDQSxVQUFBLEVBQ0EsR0FBQSxFQUNBLE9BQUEsRUFDRixHQUFJO0lBQ0osTUFBTSxFQUNKLE1BQUEsRUFDRixHQUFJO0lBQ0osTUFBTSxVQUFVO1FBQ2QsaUJBQWdCLGlOQUFBLEVBQWdGLEdBQWMsT0FBWCxXQUFXLEVBQUEsZ0JBQWlCO0lBQ2pJO0lBQ0EsTUFBTSx1QkFBdUIsQ0FBQyxTQUFtQixPQUFPLElBQUEsQ0FBSyxVQUFBLENBQVcsR0FBYyxPQUFYLFdBQVcsRUFBQSxFQUFHO0lBQ3pGLE1BQU0sa0JBQTRDO1FBQUM7UUFBc0I7UUFBNkI7UUFBZ0M7UUFBcUI7UUFBNEIsMEJBQTBCO0tBQUE7SUFDak4sTUFBTSxhQUFrSCxDQUFBLFVBQVM7UUFDL0gsSUFBSUMsZUFBYztRQUNsQixNQUFNLGdCQUF5QztZQUM3QyxzQkFBc0IsQ0FBQztRQUN6QjtRQUNBLE1BQU0sY0FBYztZQUNsQixHQUFJLEtBQUE7WUFDSjtZQUNBO1lBQ0E7UUFDRjtRQUNBLE1BQU0sV0FBVyxnQkFBZ0IsR0FBQSxDQUFJLENBQUEsUUFBUyxNQUFNLFdBQVcsQ0FBQztRQUNoRSxNQUFNLHdCQUF3QiwyQkFBMkIsV0FBVztRQUNwRSxNQUFNLHNCQUFzQix3QkFBd0IsV0FBVztRQUMvRCxPQUFPLENBQUEsU0FBUTtZQUNiLE9BQU8sQ0FBQSxXQUFVO2dCQUNmLElBQUksZ0pBQUMsV0FBQSxFQUFTLE1BQU0sR0FBRztvQkFDckIsT0FBTyxLQUFLLE1BQU07Z0JBQ3BCO2dCQUNBLElBQUksQ0FBQ0EsY0FBYTtvQkFDaEJBLGVBQWM7b0JBRWQsTUFBTSxRQUFBLENBQVMsSUFBSSxlQUFBLENBQWdCLG9CQUFBLENBQXFCLE1BQU0sQ0FBQztnQkFDakU7Z0JBQ0EsTUFBTSxnQkFBZ0I7b0JBQ3BCLEdBQUcsS0FBQTtvQkFDSDtnQkFDRjtnQkFDQSxNQUFNLGNBQWMsTUFBTSxRQUFBLENBQVM7Z0JBQ25DLE1BQU0sQ0FBQyxzQkFBc0IsbUJBQW1CLENBQUEsR0FBSSxzQkFBc0IsUUFBUSxlQUFlLFdBQVc7Z0JBQzVHLElBQUk7Z0JBQ0osSUFBSSxzQkFBc0I7b0JBQ3hCLE1BQU0sS0FBSyxNQUFNO2dCQUNuQixPQUFPO29CQUNMLE1BQU07Z0JBQ1I7Z0JBQ0EsSUFBSSxDQUFDLENBQUMsTUFBTSxRQUFBLENBQVMsQ0FBQSxDQUFFLFdBQVcsQ0FBQSxFQUFHO29CQUluQyxvQkFBb0IsUUFBUSxlQUFlLFdBQVc7b0JBQ3RELElBQUkscUJBQXFCLE1BQU0sS0FBSyxRQUFRLGtCQUFBLENBQW1CLE1BQU0sR0FBRzt3QkFHdEUsS0FBQSxNQUFXLFdBQVcsU0FBVTs0QkFDOUIsUUFBUSxRQUFRLGVBQWUsV0FBVzt3QkFDNUM7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsT0FBTztZQUNUO1FBQ0Y7SUFDRjtJQUNBLE9BQU87UUFDTDtRQUNBO0lBQ0Y7OztJQUNBLFNBQVMsYUFBYSxhQUFBLEVBRWxCO1FBQ0YsT0FBUSxNQUFNLEdBQUEsQ0FBSSxTQUFBLENBQVUsY0FBYyxZQUFZLENBQUEsQ0FBaUMsUUFBQSxDQUFTLGNBQWMsWUFBQSxFQUFxQjtZQUNqSSxXQUFXO1lBQ1gsY0FBYztRQUNoQixDQUFDO0lBQ0g7QUFDRjs7QVY3RE8sSUFBTSxpQkFBZ0MsYUFBQSxHQUFBLE9BQU87QUFpVTdDLElBQU0sYUFBYTtRQUFDLEVBQ3pCLGdCQUFBQyxtS0FBaUIsaUJBQUEsRUFDbkIsb0VBQXVCLENBQUM7V0FBMkI7UUFDakQsTUFBTTtRQUNOLE1BQUssR0FBQSxPQWFMLEVBQUcsT0FBQSxFQUFTO2tCQVpWLFNBQUEsRUFDQSxRQUFBLEVBQ0EsV0FBQSxFQUNBLGtCQUFBLEVBQ0EsaUJBQUEsRUFDQSx5QkFBQSxFQUNBLGNBQUEsRUFDQSxrQkFBQSxFQUNBLG9CQUFBLEVBQ0EsZUFBQSxFQUNBLGtCQUFBLEVBQ0Esb0JBQUEsRUFDRixHQWJVO1lBY1IsQ0FBQSxHQUFBLDBJQUFBLENBQUEsZ0JBQUEsQ0FBYztZQUNkLFdBQXVDLGtCQUFrQjtZQUN6RCxNQUFNLGdCQUFnQyxDQUFBLFFBQU87Z0JBQzNDLElBQUksa0xBQU8sS0FBWSxlQUFlLFFBQVEsSUFBSSx3Q0FBYSxlQUFlO29CQUM1RSxJQUFJLENBQUMsU0FBUyxRQUFBLENBQVMsSUFBSSxJQUFXLEdBQUc7d0JBQ3ZDLFFBQVEsS0FBQSxDQUFNLGFBQXFCLE9BQVIsSUFBSSxJQUFJLEVBQUEsOEJBQWdEO29CQUNyRjtnQkFDRjtnQkFDQSxPQUFPO1lBQ1Q7WUFDQSxPQUFPLE1BQUEsQ0FBTyxLQUFLO2dCQUNqQjtnQkFDQSxXQUFXLENBQUM7Z0JBQ1osaUJBQWlCO29CQUNmO29CQUNBO29CQUNBO29CQUNBO2dCQUNGO2dCQUNBLE1BQU0sQ0FBQztZQUNULENBQUM7WUFDRCxNQUFNLFlBQVksZUFBZTtnQkFDL0I7Z0JBQ0E7Z0JBQ0EsZ0JBQUFBO1lBQ0YsQ0FBQztZQUNELE1BQU0sRUFDSixtQkFBQSxFQUNBLHdCQUFBLEVBQ0Esa0JBQUEsRUFDQSwwQkFBQSxFQUNBLHFCQUFBLEVBQ0YsR0FBSTtZQUNKLFdBQVcsSUFBSSxJQUFBLEVBQU07Z0JBQ25CO2dCQUNBO1lBQ0YsQ0FBQztZQUNELE1BQU0sRUFDSixVQUFBLEVBQ0Esa0JBQUEsRUFDQSxhQUFBLEVBQ0EsY0FBQSxFQUNBLGVBQUEsRUFDQSxlQUFBLEVBQ0EsUUFBQSxFQUNBLHNCQUFBLEVBQ0YsR0FBSSxZQUFZO2dCQUNkO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO1lBQ0YsQ0FBQztZQUNELE1BQU0sRUFDSixPQUFBLEVBQ0EsU0FBUyxZQUFBLEVBQ1gsR0FBSSxXQUFXO2dCQUNiO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBLFFBQVE7b0JBQ047b0JBQ0E7b0JBQ0E7b0JBQ0E7b0JBQ0E7b0JBQ0E7Z0JBQ0Y7WUFDRixDQUFDO1lBQ0QsV0FBVyxJQUFJLElBQUEsRUFBTTtnQkFDbkI7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0EsZUFBZSxhQUFhLGFBQUE7Z0JBQzVCLG9CQUFvQixhQUFhLG9CQUFBO1lBQ25DLENBQUM7WUFDRCxXQUFXLElBQUksZUFBQSxFQUFpQixZQUFZO1lBQzVDLE1BQU0sRUFDSixVQUFBLEVBQ0EsU0FBUyxpQkFBQSxFQUNYLEdBQUksZ0JBQWdCO2dCQUNsQjtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtZQUNGLENBQUM7WUFDRCxXQUFXLElBQUksSUFBQSxFQUFNLGlCQUFpQjtZQUN0QyxXQUFXLEtBQUs7Z0JBQ2Q7Z0JBQ0E7WUFDRixDQUFDO1lBQ0QsTUFBTSxFQUNKLGtCQUFBLEVBQ0EsMEJBQUEsRUFDQSxxQkFBQSxFQUNBLHVCQUFBLEVBQ0Esd0JBQUEsRUFDQSxzQkFBQSxFQUNBLG9CQUFBLEVBQ0YsR0FBSSxjQUFjO2dCQUNoQjtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtZQUNGLENBQUM7WUFDRCxXQUFXLElBQUksSUFBQSxFQUFNO2dCQUNuQjtnQkFDQTtnQkFDQTtnQkFDQTtZQUNGLENBQUM7WUFDRCxPQUFPO2dCQUNMLE1BQU07Z0JBQ04sZ0JBQWUsWUFBQSxFQUFjLFVBQUEsRUFBWTsyQ0FFTCxZQUFZO29CQUQ5QyxNQUFNLFNBQVM7O29CQUNmLE1BQU0sNENBQWtCLFNBQUEsQ0FBQSw4QkFBc0IsaUNBQTdCLGlCQUFPLGVBQXNCLEdBQU0sQ0FBQztvQkFDckQsSUFBSSxrQkFBa0IsVUFBVSxHQUFHO3dCQUNqQyxXQUFXLFVBQVU7NEJBQ25CLE1BQU07NEJBQ04sUUFBUSxtQkFBbUIsY0FBYyxVQUFVOzRCQUNuRCxVQUFVLG1CQUFtQixjQUFjLFVBQVU7d0JBQ3ZELEdBQUcsdUJBQXVCLFlBQVksWUFBWSxDQUFDO29CQUNyRDtvQkFDQSxJQUFJLHFCQUFxQixVQUFVLEdBQUc7d0JBQ3BDLFdBQVcsVUFBVTs0QkFDbkIsTUFBTTs0QkFDTixRQUFRLHNCQUFzQjs0QkFDOUIsVUFBVSxzQkFBc0IsWUFBWTt3QkFDOUMsR0FBRyx1QkFBdUIsZUFBZSxZQUFZLENBQUM7b0JBQ3hEO29CQUNBLElBQUksMEJBQTBCLFVBQVUsR0FBRzt3QkFDekMsV0FBVyxVQUFVOzRCQUNuQixNQUFNOzRCQUNOLFFBQVEsMkJBQTJCLGNBQWMsVUFBVTs0QkFDM0QsVUFBVSwyQkFBMkIsY0FBYyxVQUFVO3dCQUMvRCxHQUFHLHVCQUF1QixZQUFZLFlBQVksQ0FBQztvQkFDckQ7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7OztBV25oQk8sSUFBTSxZQUEyQixhQUFBLEdBQUEsZUFBZSxXQUFXLENBQUMiLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE2NDk1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvcXVlcnkvcmVhY3QvaW5kZXgudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS9yZWFjdC9tb2R1bGUudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS91dGlscy9jYXBpdGFsaXplLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvcXVlcnkvdXRpbHMvY291bnRPYmplY3RLZXlzLnRzIiwiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MHJlZHV4anMvdG9vbGtpdC9zcmMvcXVlcnkvZW5kcG9pbnREZWZpbml0aW9ucy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL3F1ZXJ5L3RzSGVscGVycy50cyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDByZWR1eGpzL3Rvb2xraXQvc3JjL3F1ZXJ5L3JlYWN0L2J1aWxkSG9va3MudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS9yZWFjdC9jb25zdGFudHMudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS9yZWFjdC91c2VTZXJpYWxpemVkU3RhYmxlVmFsdWUudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS9yZWFjdC91c2VTaGFsbG93U3RhYmxlVmFsdWUudHMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwcmVkdXhqcy90b29sa2l0L3NyYy9xdWVyeS9yZWFjdC9BcGlQcm92aWRlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBtdXN0IHJlbWFpbiBoZXJlIHNvIHRoYXQgdGhlIGBtYW5nbGVFcnJvcnMuY2pzYCBidWlsZCBzY3JpcHRcbi8vIGRvZXMgbm90IGhhdmUgdG8gaW1wb3J0IHRoaXMgaW50byBlYWNoIHNvdXJjZSBmaWxlIGl0IHJld3JpdGVzLlxuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IHsgYnVpbGRDcmVhdGVBcGksIGNvcmVNb2R1bGUgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5JztcbmltcG9ydCB7IHJlYWN0SG9va3NNb2R1bGUsIHJlYWN0SG9va3NNb2R1bGVOYW1lIH0gZnJvbSAnLi9tb2R1bGUnO1xuZXhwb3J0ICogZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeSc7XG5leHBvcnQgeyBBcGlQcm92aWRlciB9IGZyb20gJy4vQXBpUHJvdmlkZXInO1xuY29uc3QgY3JlYXRlQXBpID0gLyogQF9fUFVSRV9fICovYnVpbGRDcmVhdGVBcGkoY29yZU1vZHVsZSgpLCByZWFjdEhvb2tzTW9kdWxlKCkpO1xuZXhwb3J0IHR5cGUgeyBUeXBlZFVzZU11dGF0aW9uUmVzdWx0LCBUeXBlZFVzZVF1ZXJ5SG9va1Jlc3VsdCwgVHlwZWRVc2VRdWVyeVN0YXRlUmVzdWx0LCBUeXBlZFVzZVF1ZXJ5U3Vic2NyaXB0aW9uUmVzdWx0LCBUeXBlZExhenlRdWVyeVRyaWdnZXIsIFR5cGVkVXNlTGF6eVF1ZXJ5LCBUeXBlZFVzZU11dGF0aW9uLCBUeXBlZE11dGF0aW9uVHJpZ2dlciwgVHlwZWRRdWVyeVN0YXRlU2VsZWN0b3IsIFR5cGVkVXNlUXVlcnlTdGF0ZSwgVHlwZWRVc2VRdWVyeSwgVHlwZWRVc2VRdWVyeVN1YnNjcmlwdGlvbiwgVHlwZWRVc2VMYXp5UXVlcnlTdWJzY3JpcHRpb24sIFR5cGVkVXNlUXVlcnlTdGF0ZU9wdGlvbnMsIFR5cGVkVXNlTGF6eVF1ZXJ5U3RhdGVSZXN1bHQsIFR5cGVkVXNlSW5maW5pdGVRdWVyeSwgVHlwZWRVc2VJbmZpbml0ZVF1ZXJ5SG9va1Jlc3VsdCwgVHlwZWRVc2VJbmZpbml0ZVF1ZXJ5U3RhdGVSZXN1bHQsIFR5cGVkVXNlSW5maW5pdGVRdWVyeVN1YnNjcmlwdGlvblJlc3VsdCwgVHlwZWRVc2VJbmZpbml0ZVF1ZXJ5U3RhdGVPcHRpb25zLCBUeXBlZEluZmluaXRlUXVlcnlTdGF0ZVNlbGVjdG9yLCBUeXBlZFVzZUluZmluaXRlUXVlcnlTdWJzY3JpcHRpb24sIFR5cGVkVXNlSW5maW5pdGVRdWVyeVN0YXRlLCBUeXBlZExhenlJbmZpbml0ZVF1ZXJ5VHJpZ2dlciB9IGZyb20gJy4vYnVpbGRIb29rcyc7XG5leHBvcnQgeyBVTklOSVRJQUxJWkVEX1ZBTFVFIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuZXhwb3J0IHsgY3JlYXRlQXBpLCByZWFjdEhvb2tzTW9kdWxlLCByZWFjdEhvb2tzTW9kdWxlTmFtZSB9OyIsImltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHR5cGUgeyBBcGksIEJhc2VRdWVyeUZuLCBFbmRwb2ludERlZmluaXRpb25zLCBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbiwgTW9kdWxlLCBNdXRhdGlvbkRlZmluaXRpb24sIFByZWZldGNoT3B0aW9ucywgUXVlcnlBcmdGcm9tLCBRdWVyeURlZmluaXRpb24sIFF1ZXJ5S2V5cyB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnknO1xuaW1wb3J0IHsgYmF0Y2ggYXMgcnJCYXRjaCwgdXNlRGlzcGF0Y2ggYXMgcnJVc2VEaXNwYXRjaCwgdXNlU2VsZWN0b3IgYXMgcnJVc2VTZWxlY3RvciwgdXNlU3RvcmUgYXMgcnJVc2VTdG9yZSB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIGFzIF9jcmVhdGVTZWxlY3RvciB9IGZyb20gJ3Jlc2VsZWN0JztcbmltcG9ydCB7IGlzSW5maW5pdGVRdWVyeURlZmluaXRpb24sIGlzTXV0YXRpb25EZWZpbml0aW9uLCBpc1F1ZXJ5RGVmaW5pdGlvbiB9IGZyb20gJy4uL2VuZHBvaW50RGVmaW5pdGlvbnMnO1xuaW1wb3J0IHsgc2FmZUFzc2lnbiB9IGZyb20gJy4uL3RzSGVscGVycyc7XG5pbXBvcnQgeyBjYXBpdGFsaXplLCBjb3VudE9iamVjdEtleXMgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IEluZmluaXRlUXVlcnlIb29rcywgTXV0YXRpb25Ib29rcywgUXVlcnlIb29rcyB9IGZyb20gJy4vYnVpbGRIb29rcyc7XG5pbXBvcnQgeyBidWlsZEhvb2tzIH0gZnJvbSAnLi9idWlsZEhvb2tzJztcbmltcG9ydCB0eXBlIHsgSG9va3NXaXRoVW5pcXVlTmFtZXMgfSBmcm9tICcuL25hbWVkSG9va3MnO1xuZXhwb3J0IGNvbnN0IHJlYWN0SG9va3NNb2R1bGVOYW1lID0gLyogQF9fUFVSRV9fICovU3ltYm9sKCk7XG5leHBvcnQgdHlwZSBSZWFjdEhvb2tzTW9kdWxlID0gdHlwZW9mIHJlYWN0SG9va3NNb2R1bGVOYW1lO1xuZGVjbGFyZSBtb2R1bGUgJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnknIHtcbiAgZXhwb3J0IGludGVyZmFjZSBBcGlNb2R1bGVzPFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBEZWZpbml0aW9ucyBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbnMsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgUmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgVGFnVHlwZXMgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICBbcmVhY3RIb29rc01vZHVsZU5hbWVdOiB7XG4gICAgICAvKipcbiAgICAgICAqICBFbmRwb2ludHMgYmFzZWQgb24gdGhlIGlucHV0IGVuZHBvaW50cyBwcm92aWRlZCB0byBgY3JlYXRlQXBpYCwgY29udGFpbmluZyBgc2VsZWN0YCwgYGhvb2tzYCBhbmQgYGFjdGlvbiBtYXRjaGVyc2AuXG4gICAgICAgKi9cbiAgICAgIGVuZHBvaW50czogeyBbSyBpbiBrZXlvZiBEZWZpbml0aW9uc106IERlZmluaXRpb25zW0tdIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55PiA/IFF1ZXJ5SG9va3M8RGVmaW5pdGlvbnNbS10+IDogRGVmaW5pdGlvbnNbS10gZXh0ZW5kcyBNdXRhdGlvbkRlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnk+ID8gTXV0YXRpb25Ib29rczxEZWZpbml0aW9uc1tLXT4gOiBEZWZpbml0aW9uc1tLXSBleHRlbmRzIEluZmluaXRlUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55PiA/IEluZmluaXRlUXVlcnlIb29rczxEZWZpbml0aW9uc1tLXT4gOiBuZXZlciB9O1xuICAgICAgLyoqXG4gICAgICAgKiBBIGhvb2sgdGhhdCBhY2NlcHRzIGEgc3RyaW5nIGVuZHBvaW50IG5hbWUsIGFuZCBwcm92aWRlcyBhIGNhbGxiYWNrIHRoYXQgd2hlbiBjYWxsZWQsIHByZS1mZXRjaGVzIHRoZSBkYXRhIGZvciB0aGF0IGVuZHBvaW50LlxuICAgICAgICovXG4gICAgICB1c2VQcmVmZXRjaDxFbmRwb2ludE5hbWUgZXh0ZW5kcyBRdWVyeUtleXM8RGVmaW5pdGlvbnM+PihlbmRwb2ludE5hbWU6IEVuZHBvaW50TmFtZSwgb3B0aW9ucz86IFByZWZldGNoT3B0aW9ucyk6IChhcmc6IFF1ZXJ5QXJnRnJvbTxEZWZpbml0aW9uc1tFbmRwb2ludE5hbWVdPiwgb3B0aW9ucz86IFByZWZldGNoT3B0aW9ucykgPT4gdm9pZDtcbiAgICB9ICYgSG9va3NXaXRoVW5pcXVlTmFtZXM8RGVmaW5pdGlvbnM+O1xuICB9XG59XG50eXBlIFJSID0gdHlwZW9mIGltcG9ydCgncmVhY3QtcmVkdXgnKTtcbmV4cG9ydCBpbnRlcmZhY2UgUmVhY3RIb29rc01vZHVsZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIGhvb2tzIGZyb20gUmVhY3QgUmVkdXggdG8gYmUgdXNlZFxuICAgKi9cbiAgaG9va3M/OiB7XG4gICAgLyoqXG4gICAgICogVGhlIHZlcnNpb24gb2YgdGhlIGB1c2VEaXNwYXRjaGAgaG9vayB0byBiZSB1c2VkXG4gICAgICovXG4gICAgdXNlRGlzcGF0Y2g6IFJSWyd1c2VEaXNwYXRjaCddO1xuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBgdXNlU2VsZWN0b3JgIGhvb2sgdG8gYmUgdXNlZFxuICAgICAqL1xuICAgIHVzZVNlbGVjdG9yOiBSUlsndXNlU2VsZWN0b3InXTtcbiAgICAvKipcbiAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgYHVzZVN0b3JlYCBob29rIHRvIGJlIHVzZWRcbiAgICAgKi9cbiAgICB1c2VTdG9yZTogUlJbJ3VzZVN0b3JlJ107XG4gIH07XG4gIC8qKlxuICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgYGJhdGNoZWRVcGRhdGVzYCBmdW5jdGlvbiB0byBiZSB1c2VkXG4gICAqL1xuICBiYXRjaD86IFJSWydiYXRjaCddO1xuICAvKipcbiAgICogRW5hYmxlcyBwZXJmb3JtaW5nIGFzeW5jaHJvbm91cyB0YXNrcyBpbW1lZGlhdGVseSB3aXRoaW4gYSByZW5kZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCB7XG4gICAqICAgYnVpbGRDcmVhdGVBcGksXG4gICAqICAgY29yZU1vZHVsZSxcbiAgICogICByZWFjdEhvb2tzTW9kdWxlXG4gICAqIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeS9yZWFjdCdcbiAgICpcbiAgICogY29uc3QgY3JlYXRlQXBpID0gYnVpbGRDcmVhdGVBcGkoXG4gICAqICAgY29yZU1vZHVsZSgpLFxuICAgKiAgIHJlYWN0SG9va3NNb2R1bGUoeyB1bnN0YWJsZV9fc2lkZUVmZmVjdHNJblJlbmRlcjogdHJ1ZSB9KVxuICAgKiApXG4gICAqIGBgYFxuICAgKi9cbiAgdW5zdGFibGVfX3NpZGVFZmZlY3RzSW5SZW5kZXI/OiBib29sZWFuO1xuICAvKipcbiAgICogQSBzZWxlY3RvciBjcmVhdG9yICh1c3VhbGx5IGZyb20gYHJlc2VsZWN0YCwgb3IgbWF0Y2hpbmcgdGhlIHNhbWUgc2lnbmF0dXJlKVxuICAgKi9cbiAgY3JlYXRlU2VsZWN0b3I/OiB0eXBlb2YgX2NyZWF0ZVNlbGVjdG9yO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtb2R1bGUgdGhhdCBnZW5lcmF0ZXMgcmVhY3QgaG9va3MgZnJvbSBlbmRwb2ludHMsIGZvciB1c2Ugd2l0aCBgYnVpbGRDcmVhdGVBcGlgLlxuICpcbiAqICBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IE15Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8UmVhY3RSZWR1eENvbnRleHRWYWx1ZSB8IG51bGw+KG51bGwpO1xuICogY29uc3QgY3VzdG9tQ3JlYXRlQXBpID0gYnVpbGRDcmVhdGVBcGkoXG4gKiAgIGNvcmVNb2R1bGUoKSxcbiAqICAgcmVhY3RIb29rc01vZHVsZSh7XG4gKiAgICAgaG9va3M6IHtcbiAqICAgICAgIHVzZURpc3BhdGNoOiBjcmVhdGVEaXNwYXRjaEhvb2soTXlDb250ZXh0KSxcbiAqICAgICAgIHVzZVNlbGVjdG9yOiBjcmVhdGVTZWxlY3Rvckhvb2soTXlDb250ZXh0KSxcbiAqICAgICAgIHVzZVN0b3JlOiBjcmVhdGVTdG9yZUhvb2soTXlDb250ZXh0KVxuICogICAgIH1cbiAqICAgfSlcbiAqICk7XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBBIG1vZHVsZSBmb3IgdXNlIHdpdGggYGJ1aWxkQ3JlYXRlQXBpYFxuICovXG5leHBvcnQgY29uc3QgcmVhY3RIb29rc01vZHVsZSA9ICh7XG4gIGJhdGNoID0gcnJCYXRjaCxcbiAgaG9va3MgPSB7XG4gICAgdXNlRGlzcGF0Y2g6IHJyVXNlRGlzcGF0Y2gsXG4gICAgdXNlU2VsZWN0b3I6IHJyVXNlU2VsZWN0b3IsXG4gICAgdXNlU3RvcmU6IHJyVXNlU3RvcmVcbiAgfSxcbiAgY3JlYXRlU2VsZWN0b3IgPSBfY3JlYXRlU2VsZWN0b3IsXG4gIHVuc3RhYmxlX19zaWRlRWZmZWN0c0luUmVuZGVyID0gZmFsc2UsXG4gIC4uLnJlc3Rcbn06IFJlYWN0SG9va3NNb2R1bGVPcHRpb25zID0ge30pOiBNb2R1bGU8UmVhY3RIb29rc01vZHVsZT4gPT4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IGhvb2tOYW1lcyA9IFsndXNlRGlzcGF0Y2gnLCAndXNlU2VsZWN0b3InLCAndXNlU3RvcmUnXSBhcyBjb25zdDtcbiAgICBsZXQgd2FybmVkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBob29rTmFtZSBvZiBob29rTmFtZXMpIHtcbiAgICAgIC8vIHdhcm4gZm9yIG9sZCBob29rIG9wdGlvbnNcbiAgICAgIGlmIChjb3VudE9iamVjdEtleXMocmVzdCkgPiAwKSB7XG4gICAgICAgIGlmICgocmVzdCBhcyBQYXJ0aWFsPHR5cGVvZiBob29rcz4pW2hvb2tOYW1lXSkge1xuICAgICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0FzIG9mIFJUSyAyLjAsIHRoZSBob29rcyBub3cgbmVlZCB0byBiZSBzcGVjaWZpZWQgYXMgb25lIG9iamVjdCwgcHJvdmlkZWQgdW5kZXIgYSBgaG9va3NgIGtleTonICsgJ1xcbmByZWFjdEhvb2tzTW9kdWxlKHsgaG9va3M6IHsgdXNlRGlzcGF0Y2gsIHVzZVNlbGVjdG9yLCB1c2VTdG9yZSB9IH0pYCcpO1xuICAgICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWlncmF0ZVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGhvb2tzW2hvb2tOYW1lXSA9IHJlc3RbaG9va05hbWVdO1xuICAgICAgfVxuICAgICAgLy8gdGhlbiBtYWtlIHN1cmUgd2UgaGF2ZSB0aGVtIGFsbFxuICAgICAgaWYgKHR5cGVvZiBob29rc1tob29rTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDM2KSA6IGBXaGVuIHVzaW5nIGN1c3RvbSBob29rcyBmb3IgY29udGV4dCwgYWxsICR7aG9va05hbWVzLmxlbmd0aH0gaG9va3MgbmVlZCB0byBiZSBwcm92aWRlZDogJHtob29rTmFtZXMuam9pbignLCAnKX0uXFxuSG9vayAke2hvb2tOYW1lfSB3YXMgZWl0aGVyIG5vdCBwcm92aWRlZCBvciBub3QgYSBmdW5jdGlvbi5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiByZWFjdEhvb2tzTW9kdWxlTmFtZSxcbiAgICBpbml0KGFwaSwge1xuICAgICAgc2VyaWFsaXplUXVlcnlBcmdzXG4gICAgfSwgY29udGV4dCkge1xuICAgICAgY29uc3QgYW55QXBpID0gYXBpIGFzIGFueSBhcyBBcGk8YW55LCBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBhbnksIGFueSwgUmVhY3RIb29rc01vZHVsZT47XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJ1aWxkUXVlcnlIb29rcyxcbiAgICAgICAgYnVpbGRJbmZpbml0ZVF1ZXJ5SG9va3MsXG4gICAgICAgIGJ1aWxkTXV0YXRpb25Ib29rLFxuICAgICAgICB1c2VQcmVmZXRjaFxuICAgICAgfSA9IGJ1aWxkSG9va3Moe1xuICAgICAgICBhcGksXG4gICAgICAgIG1vZHVsZU9wdGlvbnM6IHtcbiAgICAgICAgICBiYXRjaCxcbiAgICAgICAgICBob29rcyxcbiAgICAgICAgICB1bnN0YWJsZV9fc2lkZUVmZmVjdHNJblJlbmRlcixcbiAgICAgICAgICBjcmVhdGVTZWxlY3RvclxuICAgICAgICB9LFxuICAgICAgICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pO1xuICAgICAgc2FmZUFzc2lnbihhbnlBcGksIHtcbiAgICAgICAgdXNlUHJlZmV0Y2hcbiAgICAgIH0pO1xuICAgICAgc2FmZUFzc2lnbihjb250ZXh0LCB7XG4gICAgICAgIGJhdGNoXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluamVjdEVuZHBvaW50KGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbikge1xuICAgICAgICAgIGlmIChpc1F1ZXJ5RGVmaW5pdGlvbihkZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB1c2VRdWVyeSxcbiAgICAgICAgICAgICAgdXNlTGF6eVF1ZXJ5LFxuICAgICAgICAgICAgICB1c2VMYXp5UXVlcnlTdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgIHVzZVF1ZXJ5U3RhdGUsXG4gICAgICAgICAgICAgIHVzZVF1ZXJ5U3Vic2NyaXB0aW9uXG4gICAgICAgICAgICB9ID0gYnVpbGRRdWVyeUhvb2tzKGVuZHBvaW50TmFtZSk7XG4gICAgICAgICAgICBzYWZlQXNzaWduKGFueUFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSwge1xuICAgICAgICAgICAgICB1c2VRdWVyeSxcbiAgICAgICAgICAgICAgdXNlTGF6eVF1ZXJ5LFxuICAgICAgICAgICAgICB1c2VMYXp5UXVlcnlTdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgIHVzZVF1ZXJ5U3RhdGUsXG4gICAgICAgICAgICAgIHVzZVF1ZXJ5U3Vic2NyaXB0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIChhcGkgYXMgYW55KVtgdXNlJHtjYXBpdGFsaXplKGVuZHBvaW50TmFtZSl9UXVlcnlgXSA9IHVzZVF1ZXJ5O1xuICAgICAgICAgICAgKGFwaSBhcyBhbnkpW2B1c2VMYXp5JHtjYXBpdGFsaXplKGVuZHBvaW50TmFtZSl9UXVlcnlgXSA9IHVzZUxhenlRdWVyeTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTXV0YXRpb25EZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VNdXRhdGlvbiA9IGJ1aWxkTXV0YXRpb25Ib29rKGVuZHBvaW50TmFtZSk7XG4gICAgICAgICAgICBzYWZlQXNzaWduKGFueUFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSwge1xuICAgICAgICAgICAgICB1c2VNdXRhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAoYXBpIGFzIGFueSlbYHVzZSR7Y2FwaXRhbGl6ZShlbmRwb2ludE5hbWUpfU11dGF0aW9uYF0gPSB1c2VNdXRhdGlvbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzSW5maW5pdGVRdWVyeURlZmluaXRpb24oZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgdXNlSW5maW5pdGVRdWVyeSxcbiAgICAgICAgICAgICAgdXNlSW5maW5pdGVRdWVyeVN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgdXNlSW5maW5pdGVRdWVyeVN0YXRlXG4gICAgICAgICAgICB9ID0gYnVpbGRJbmZpbml0ZVF1ZXJ5SG9va3MoZW5kcG9pbnROYW1lKTtcbiAgICAgICAgICAgIHNhZmVBc3NpZ24oYW55QXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLCB7XG4gICAgICAgICAgICAgIHVzZUluZmluaXRlUXVlcnksXG4gICAgICAgICAgICAgIHVzZUluZmluaXRlUXVlcnlTdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgIHVzZUluZmluaXRlUXVlcnlTdGF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAoYXBpIGFzIGFueSlbYHVzZSR7Y2FwaXRhbGl6ZShlbmRwb2ludE5hbWUpfUluZmluaXRlUXVlcnlgXSA9IHVzZUluZmluaXRlUXVlcnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07IiwiZXhwb3J0IGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHN0clswXSwgc3RyWzBdLnRvVXBwZXJDYXNlKCkpO1xufSIsIi8vIEZhc3QgbWV0aG9kIGZvciBjb3VudGluZyBhbiBvYmplY3QncyBrZXlzXG4vLyB3aXRob3V0IHJlc29ydGluZyB0byBgT2JqZWN0LmtleXMob2JqKS5sZW5ndGhcbi8vIFdpbGwgdGhpcyBtYWtlIGEgYmlnIGRpZmZlcmVuY2UgaW4gcGVyZj8gUHJvYmFibHkgbm90XG4vLyBCdXQgd2UgY2FuIHNhdmUgYSBmZXcgYWxsb2NhdGlvbnMuXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3VudE9iamVjdEtleXMob2JqOiBSZWNvcmQ8YW55LCBhbnk+KSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAoY29uc3QgX2tleSBpbiBvYmopIHtcbiAgICBjb3VudCsrO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn0iLCJpbXBvcnQgdHlwZSB7IEFwaSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnknO1xuaW1wb3J0IHR5cGUgeyBTdGFuZGFyZFNjaGVtYVYxIH0gZnJvbSAnQHN0YW5kYXJkLXNjaGVtYS9zcGVjJztcbmltcG9ydCB0eXBlIHsgQmFzZVF1ZXJ5QXBpLCBCYXNlUXVlcnlBcmcsIEJhc2VRdWVyeUVycm9yLCBCYXNlUXVlcnlFeHRyYU9wdGlvbnMsIEJhc2VRdWVyeUZuLCBCYXNlUXVlcnlNZXRhLCBCYXNlUXVlcnlSZXN1bHQsIFF1ZXJ5UmV0dXJuVmFsdWUgfSBmcm9tICcuL2Jhc2VRdWVyeVR5cGVzJztcbmltcG9ydCB0eXBlIHsgQ2FjaGVDb2xsZWN0aW9uUXVlcnlFeHRyYU9wdGlvbnMgfSBmcm9tICcuL2NvcmUvYnVpbGRNaWRkbGV3YXJlL2NhY2hlQ29sbGVjdGlvbic7XG5pbXBvcnQgdHlwZSB7IENhY2hlTGlmZWN5Y2xlSW5maW5pdGVRdWVyeUV4dHJhT3B0aW9ucywgQ2FjaGVMaWZlY3ljbGVNdXRhdGlvbkV4dHJhT3B0aW9ucywgQ2FjaGVMaWZlY3ljbGVRdWVyeUV4dHJhT3B0aW9ucyB9IGZyb20gJy4vY29yZS9idWlsZE1pZGRsZXdhcmUvY2FjaGVMaWZlY3ljbGUnO1xuaW1wb3J0IHR5cGUgeyBRdWVyeUxpZmVjeWNsZUluZmluaXRlUXVlcnlFeHRyYU9wdGlvbnMsIFF1ZXJ5TGlmZWN5Y2xlTXV0YXRpb25FeHRyYU9wdGlvbnMsIFF1ZXJ5TGlmZWN5Y2xlUXVlcnlFeHRyYU9wdGlvbnMgfSBmcm9tICcuL2NvcmUvYnVpbGRNaWRkbGV3YXJlL3F1ZXJ5TGlmZWN5Y2xlJztcbmltcG9ydCB0eXBlIHsgSW5maW5pdGVEYXRhLCBJbmZpbml0ZVF1ZXJ5Q29uZmlnT3B0aW9ucywgUXVlcnlTdWJTdGF0ZSwgUm9vdFN0YXRlIH0gZnJvbSAnLi9jb3JlL2luZGV4JztcbmltcG9ydCB0eXBlIHsgU2VyaWFsaXplUXVlcnlBcmdzIH0gZnJvbSAnLi9kZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzJztcbmltcG9ydCB0eXBlIHsgTkVWRVIgfSBmcm9tICcuL2Zha2VCYXNlUXVlcnknO1xuaW1wb3J0IHR5cGUgeyBDYXN0QW55LCBIYXNSZXF1aXJlZFByb3BzLCBNYXliZVByb21pc2UsIE5vblVuZGVmaW5lZCwgT21pdEZyb21VbmlvbiwgVW53cmFwUHJvbWlzZSB9IGZyb20gJy4vdHNIZWxwZXJzJztcbmltcG9ydCB7IGlzTm90TnVsbGlzaCB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBOYW1lZFNjaGVtYUVycm9yIH0gZnJvbSAnLi9zdGFuZGFyZFNjaGVtYSc7XG5jb25zdCByYXdSZXN1bHRUeXBlID0gLyogQF9fUFVSRV9fICovU3ltYm9sKCk7XG5jb25zdCByZXN1bHRUeXBlID0gLyogQF9fUFVSRV9fICovU3ltYm9sKCk7XG5jb25zdCBiYXNlUXVlcnkgPSAvKiBAX19QVVJFX18gKi9TeW1ib2woKTtcbmV4cG9ydCBpbnRlcmZhY2UgU2NoZW1hRmFpbHVyZUluZm8ge1xuICBlbmRwb2ludDogc3RyaW5nO1xuICBhcmc6IGFueTtcbiAgdHlwZTogJ3F1ZXJ5JyB8ICdtdXRhdGlvbic7XG4gIHF1ZXJ5Q2FjaGVLZXk/OiBzdHJpbmc7XG59XG5leHBvcnQgdHlwZSBTY2hlbWFGYWlsdXJlSGFuZGxlciA9IChlcnJvcjogTmFtZWRTY2hlbWFFcnJvciwgaW5mbzogU2NoZW1hRmFpbHVyZUluZm8pID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBTY2hlbWFGYWlsdXJlQ29udmVydGVyPEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuPiA9IChlcnJvcjogTmFtZWRTY2hlbWFFcnJvciwgaW5mbzogU2NoZW1hRmFpbHVyZUluZm8pID0+IEJhc2VRdWVyeUVycm9yPEJhc2VRdWVyeT47XG5leHBvcnQgdHlwZSBFbmRwb2ludERlZmluaXRpb25XaXRoUXVlcnk8UXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBSZXN1bHRUeXBlLCBSYXdSZXN1bHRUeXBlIGV4dGVuZHMgQmFzZVF1ZXJ5UmVzdWx0PEJhc2VRdWVyeT4+ID0ge1xuICAvKipcbiAgICogYHF1ZXJ5YCBjYW4gYmUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgZWl0aGVyIGEgYHN0cmluZ2Agb3IgYW4gYG9iamVjdGAgd2hpY2ggaXMgcGFzc2VkIHRvIHlvdXIgYGJhc2VRdWVyeWAuIElmIHlvdSBhcmUgdXNpbmcgW2ZldGNoQmFzZVF1ZXJ5XSguL2ZldGNoQmFzZVF1ZXJ5KSwgdGhpcyBjYW4gcmV0dXJuIGVpdGhlciBhIGBzdHJpbmdgIG9yIGFuIGBvYmplY3RgIG9mIHByb3BlcnRpZXMgaW4gYEZldGNoQXJnc2AuIElmIHlvdSB1c2UgeW91ciBvd24gY3VzdG9tIFtgYmFzZVF1ZXJ5YF0oLi4vLi4vcnRrLXF1ZXJ5L3VzYWdlL2N1c3RvbWl6aW5nLXF1ZXJpZXMpLCB5b3UgY2FuIGN1c3RvbWl6ZSB0aGlzIGJlaGF2aW9yIHRvIHlvdXIgbGlraW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiAvLyBjb2RlYmxvY2stbWV0YSB0aXRsZT1cInF1ZXJ5IGV4YW1wbGVcIlxuICAgKlxuICAgKiBpbXBvcnQgeyBjcmVhdGVBcGksIGZldGNoQmFzZVF1ZXJ5IH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeS9yZWFjdCdcbiAgICogaW50ZXJmYWNlIFBvc3Qge1xuICAgKiAgIGlkOiBudW1iZXJcbiAgICogICBuYW1lOiBzdHJpbmdcbiAgICogfVxuICAgKiB0eXBlIFBvc3RzUmVzcG9uc2UgPSBQb3N0W11cbiAgICpcbiAgICogY29uc3QgYXBpID0gY3JlYXRlQXBpKHtcbiAgICogICBiYXNlUXVlcnk6IGZldGNoQmFzZVF1ZXJ5KHsgYmFzZVVybDogJy8nIH0pLFxuICAgKiAgIHRhZ1R5cGVzOiBbJ1Bvc3QnXSxcbiAgICogICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAgICogICAgIGdldFBvc3RzOiBidWlsZC5xdWVyeTxQb3N0c1Jlc3BvbnNlLCB2b2lkPih7XG4gICAqICAgICAgIC8vIGhpZ2hsaWdodC1zdGFydFxuICAgKiAgICAgICBxdWVyeTogKCkgPT4gJ3Bvc3RzJyxcbiAgICogICAgICAgLy8gaGlnaGxpZ2h0LWVuZFxuICAgKiAgICAgfSksXG4gICAqICAgICBhZGRQb3N0OiBidWlsZC5tdXRhdGlvbjxQb3N0LCBQYXJ0aWFsPFBvc3Q+Pih7XG4gICAqICAgICAgLy8gaGlnaGxpZ2h0LXN0YXJ0XG4gICAqICAgICAgcXVlcnk6IChib2R5KSA9PiAoe1xuICAgKiAgICAgICAgdXJsOiBgcG9zdHNgLFxuICAgKiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAqICAgICAgICBib2R5LFxuICAgKiAgICAgIH0pLFxuICAgKiAgICAgIC8vIGhpZ2hsaWdodC1lbmRcbiAgICogICAgICBpbnZhbGlkYXRlc1RhZ3M6IFt7IHR5cGU6ICdQb3N0JywgaWQ6ICdMSVNUJyB9XSxcbiAgICogICAgfSksXG4gICAqICAgfSlcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBxdWVyeShhcmc6IFF1ZXJ5QXJnKTogQmFzZVF1ZXJ5QXJnPEJhc2VRdWVyeT47XG4gIHF1ZXJ5Rm4/OiBuZXZlcjtcbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdG8gbWFuaXB1bGF0ZSB0aGUgZGF0YSByZXR1cm5lZCBieSBhIHF1ZXJ5IG9yIG11dGF0aW9uLlxuICAgKi9cbiAgdHJhbnNmb3JtUmVzcG9uc2U/KGJhc2VRdWVyeVJldHVyblZhbHVlOiBSYXdSZXN1bHRUeXBlLCBtZXRhOiBCYXNlUXVlcnlNZXRhPEJhc2VRdWVyeT4sIGFyZzogUXVlcnlBcmcpOiBSZXN1bHRUeXBlIHwgUHJvbWlzZTxSZXN1bHRUeXBlPjtcbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdG8gbWFuaXB1bGF0ZSB0aGUgZGF0YSByZXR1cm5lZCBieSBhIGZhaWxlZCBxdWVyeSBvciBtdXRhdGlvbi5cbiAgICovXG4gIHRyYW5zZm9ybUVycm9yUmVzcG9uc2U/KGJhc2VRdWVyeVJldHVyblZhbHVlOiBCYXNlUXVlcnlFcnJvcjxCYXNlUXVlcnk+LCBtZXRhOiBCYXNlUXVlcnlNZXRhPEJhc2VRdWVyeT4sIGFyZzogUXVlcnlBcmcpOiB1bmtub3duO1xuXG4gIC8qKlxuICAgKiBBIHNjaGVtYSBmb3IgdGhlIHJlc3VsdCAqYmVmb3JlKiBpdCdzIHBhc3NlZCB0byBgdHJhbnNmb3JtUmVzcG9uc2VgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBjb2RlYmxvY2stbWV0YSBuby10cmFuc3BpbGVcbiAgICogaW1wb3J0IHsgY3JlYXRlQXBpLCBmZXRjaEJhc2VRdWVyeSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnXG4gICAqIGltcG9ydCAqIGFzIHYgZnJvbSBcInZhbGlib3RcIlxuICAgKlxuICAgKiBjb25zdCBwb3N0U2NoZW1hID0gdi5vYmplY3QoeyBpZDogdi5udW1iZXIoKSwgbmFtZTogdi5zdHJpbmcoKSB9KVxuICAgKiB0eXBlIFBvc3QgPSB2LkluZmVyT3V0cHV0PHR5cGVvZiBwb3N0U2NoZW1hPlxuICAgKlxuICAgKiBjb25zdCBhcGkgPSBjcmVhdGVBcGkoe1xuICAgKiAgIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnLycgfSksXG4gICAqICAgZW5kcG9pbnRzOiAoYnVpbGQpID0+ICh7XG4gICAqICAgICBnZXRQb3N0TmFtZTogYnVpbGQucXVlcnk8UG9zdCwgeyBpZDogbnVtYmVyIH0+KHtcbiAgICogICAgICAgcXVlcnk6ICh7IGlkIH0pID0+IGAvcG9zdC8ke2lkfWAsXG4gICAqICAgICAgIHJhd1Jlc3BvbnNlU2NoZW1hOiBwb3N0U2NoZW1hLFxuICAgKiAgICAgICB0cmFuc2Zvcm1SZXNwb25zZTogKHBvc3QpID0+IHBvc3QubmFtZSxcbiAgICogICAgIH0pLFxuICAgKiAgIH0pXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgcmF3UmVzcG9uc2VTY2hlbWE/OiBTdGFuZGFyZFNjaGVtYVYxPFJhd1Jlc3VsdFR5cGU+O1xuXG4gIC8qKlxuICAgKiBBIHNjaGVtYSBmb3IgdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBieSB0aGUgYHF1ZXJ5YCBvciBgcXVlcnlGbmAsICpiZWZvcmUqIGl0J3MgcGFzc2VkIHRvIGB0cmFuc2Zvcm1FcnJvclJlc3BvbnNlYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgbm8tdHJhbnNwaWxlXG4gICAqIGltcG9ydCB7IGNyZWF0ZUFwaSwgZmV0Y2hCYXNlUXVlcnkgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5L3JlYWN0J1xuICAgKiBpbXBvcnQgKiBhcyB2IGZyb20gXCJ2YWxpYm90XCJcbiAgICogaW1wb3J0IHtjdXN0b21CYXNlUXVlcnksIGJhc2VRdWVyeUVycm9yU2NoZW1hfSBmcm9tIFwiLi9jdXN0b21CYXNlUXVlcnlcIlxuICAgKlxuICAgKiBjb25zdCBhcGkgPSBjcmVhdGVBcGkoe1xuICAgKiAgIGJhc2VRdWVyeTogY3VzdG9tQmFzZVF1ZXJ5LFxuICAgKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAgZ2V0UG9zdDogYnVpbGQucXVlcnk8UG9zdCwgeyBpZDogbnVtYmVyIH0+KHtcbiAgICogICAgICAgcXVlcnk6ICh7IGlkIH0pID0+IGAvcG9zdC8ke2lkfWAsXG4gICAqICAgICAgIHJhd0Vycm9yUmVzcG9uc2VTY2hlbWE6IGJhc2VRdWVyeUVycm9yU2NoZW1hLFxuICAgKiAgICAgICB0cmFuc2Zvcm1FcnJvclJlc3BvbnNlOiAoZXJyb3IpID0+IGVycm9yLmRhdGEsXG4gICAqICAgICB9KSxcbiAgICogICB9KVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHJhd0Vycm9yUmVzcG9uc2VTY2hlbWE/OiBTdGFuZGFyZFNjaGVtYVYxPEJhc2VRdWVyeUVycm9yPEJhc2VRdWVyeT4+O1xufTtcbmV4cG9ydCB0eXBlIEVuZHBvaW50RGVmaW5pdGlvbldpdGhRdWVyeUZuPFF1ZXJ5QXJnLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgUmVzdWx0VHlwZT4gPSB7XG4gIC8qKlxuICAgKiBDYW4gYmUgdXNlZCBpbiBwbGFjZSBvZiBgcXVlcnlgIGFzIGFuIGlubGluZSBmdW5jdGlvbiB0aGF0IGJ5cGFzc2VzIGBiYXNlUXVlcnlgIGNvbXBsZXRlbHkgZm9yIHRoZSBlbmRwb2ludC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgdGl0bGU9XCJCYXNpYyBxdWVyeUZuIGV4YW1wbGVcIlxuICAgKlxuICAgKiBpbXBvcnQgeyBjcmVhdGVBcGksIGZldGNoQmFzZVF1ZXJ5IH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeS9yZWFjdCdcbiAgICogaW50ZXJmYWNlIFBvc3Qge1xuICAgKiAgIGlkOiBudW1iZXJcbiAgICogICBuYW1lOiBzdHJpbmdcbiAgICogfVxuICAgKiB0eXBlIFBvc3RzUmVzcG9uc2UgPSBQb3N0W11cbiAgICpcbiAgICogY29uc3QgYXBpID0gY3JlYXRlQXBpKHtcbiAgICogICBiYXNlUXVlcnk6IGZldGNoQmFzZVF1ZXJ5KHsgYmFzZVVybDogJy8nIH0pLFxuICAgKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAgZ2V0UG9zdHM6IGJ1aWxkLnF1ZXJ5PFBvc3RzUmVzcG9uc2UsIHZvaWQ+KHtcbiAgICogICAgICAgcXVlcnk6ICgpID0+ICdwb3N0cycsXG4gICAqICAgICB9KSxcbiAgICogICAgIGZsaXBDb2luOiBidWlsZC5xdWVyeTwnaGVhZHMnIHwgJ3RhaWxzJywgdm9pZD4oe1xuICAgKiAgICAgICAvLyBoaWdobGlnaHQtc3RhcnRcbiAgICogICAgICAgcXVlcnlGbihhcmcsIHF1ZXJ5QXBpLCBleHRyYU9wdGlvbnMsIGJhc2VRdWVyeSkge1xuICAgKiAgICAgICAgIGNvbnN0IHJhbmRvbVZhbCA9IE1hdGgucmFuZG9tKClcbiAgICogICAgICAgICBpZiAocmFuZG9tVmFsIDwgMC40NSkge1xuICAgKiAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogJ2hlYWRzJyB9XG4gICAqICAgICAgICAgfVxuICAgKiAgICAgICAgIGlmIChyYW5kb21WYWwgPCAwLjkpIHtcbiAgICogICAgICAgICAgIHJldHVybiB7IGRhdGE6ICd0YWlscycgfVxuICAgKiAgICAgICAgIH1cbiAgICogICAgICAgICByZXR1cm4geyBlcnJvcjogeyBzdGF0dXM6IDUwMCwgc3RhdHVzVGV4dDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsIGRhdGE6IFwiQ29pbiBsYW5kZWQgb24gaXRzIGVkZ2UhXCIgfSB9XG4gICAqICAgICAgIH1cbiAgICogICAgICAgLy8gaGlnaGxpZ2h0LWVuZFxuICAgKiAgICAgfSlcbiAgICogICB9KVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHF1ZXJ5Rm4oYXJnOiBRdWVyeUFyZywgYXBpOiBCYXNlUXVlcnlBcGksIGV4dHJhT3B0aW9uczogQmFzZVF1ZXJ5RXh0cmFPcHRpb25zPEJhc2VRdWVyeT4sIGJhc2VRdWVyeTogKGFyZzogUGFyYW1ldGVyczxCYXNlUXVlcnk+WzBdKSA9PiBSZXR1cm5UeXBlPEJhc2VRdWVyeT4pOiBNYXliZVByb21pc2U8UXVlcnlSZXR1cm5WYWx1ZTxSZXN1bHRUeXBlLCBCYXNlUXVlcnlFcnJvcjxCYXNlUXVlcnk+LCBCYXNlUXVlcnlNZXRhPEJhc2VRdWVyeT4+PjtcbiAgcXVlcnk/OiBuZXZlcjtcbiAgdHJhbnNmb3JtUmVzcG9uc2U/OiBuZXZlcjtcbiAgdHJhbnNmb3JtRXJyb3JSZXNwb25zZT86IG5ldmVyO1xuICByYXdSZXNwb25zZVNjaGVtYT86IG5ldmVyO1xuICByYXdFcnJvclJlc3BvbnNlU2NoZW1hPzogbmV2ZXI7XG59O1xudHlwZSBCYXNlRW5kcG9pbnRUeXBlczxRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFJlc3VsdFR5cGU+ID0ge1xuICBRdWVyeUFyZzogUXVlcnlBcmc7XG4gIEJhc2VRdWVyeTogQmFzZVF1ZXJ5O1xuICBSZXN1bHRUeXBlOiBSZXN1bHRUeXBlO1xufTtcbmludGVyZmFjZSBDb21tb25FbmRwb2ludERlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBSZXN1bHRUeXBlPiB7XG4gIC8qKlxuICAgKiBBIHNjaGVtYSBmb3IgdGhlIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gdGhlIGBxdWVyeWAgb3IgYHF1ZXJ5Rm5gLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBjb2RlYmxvY2stbWV0YSBuby10cmFuc3BpbGVcbiAgICogaW1wb3J0IHsgY3JlYXRlQXBpLCBmZXRjaEJhc2VRdWVyeSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnXG4gICAqIGltcG9ydCAqIGFzIHYgZnJvbSBcInZhbGlib3RcIlxuICAgKlxuICAgKiBjb25zdCBhcGkgPSBjcmVhdGVBcGkoe1xuICAgKiAgIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnLycgfSksXG4gICAqICAgZW5kcG9pbnRzOiAoYnVpbGQpID0+ICh7XG4gICAqICAgICBnZXRQb3N0OiBidWlsZC5xdWVyeTxQb3N0LCB7IGlkOiBudW1iZXIgfT4oe1xuICAgKiAgICAgICBxdWVyeTogKHsgaWQgfSkgPT4gYC9wb3N0LyR7aWR9YCxcbiAgICogICAgICAgYXJnU2NoZW1hOiB2Lm9iamVjdCh7IGlkOiB2Lm51bWJlcigpIH0pLFxuICAgKiAgICAgfSksXG4gICAqICAgfSlcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBhcmdTY2hlbWE/OiBTdGFuZGFyZFNjaGVtYVYxPFF1ZXJ5QXJnPjtcblxuICAvKipcbiAgICogQSBzY2hlbWEgZm9yIHRoZSByZXN1bHQgKGluY2x1ZGluZyBgdHJhbnNmb3JtUmVzcG9uc2VgIGlmIHByb3ZpZGVkKS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgbm8tdHJhbnNwaWxlXG4gICAqIGltcG9ydCB7IGNyZWF0ZUFwaSwgZmV0Y2hCYXNlUXVlcnkgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5L3JlYWN0J1xuICAgKiBpbXBvcnQgKiBhcyB2IGZyb20gXCJ2YWxpYm90XCJcbiAgICpcbiAgICogY29uc3QgcG9zdFNjaGVtYSA9IHYub2JqZWN0KHsgaWQ6IHYubnVtYmVyKCksIG5hbWU6IHYuc3RyaW5nKCkgfSlcbiAgICogdHlwZSBQb3N0ID0gdi5JbmZlck91dHB1dDx0eXBlb2YgcG9zdFNjaGVtYT5cbiAgICpcbiAgICogY29uc3QgYXBpID0gY3JlYXRlQXBpKHtcbiAgICogICBiYXNlUXVlcnk6IGZldGNoQmFzZVF1ZXJ5KHsgYmFzZVVybDogJy8nIH0pLFxuICAgKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAgZ2V0UG9zdDogYnVpbGQucXVlcnk8UG9zdCwgeyBpZDogbnVtYmVyIH0+KHtcbiAgICogICAgICAgcXVlcnk6ICh7IGlkIH0pID0+IGAvcG9zdC8ke2lkfWAsXG4gICAqICAgICAgIHJlc3BvbnNlU2NoZW1hOiBwb3N0U2NoZW1hLFxuICAgKiAgICAgfSksXG4gICAqICAgfSlcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICByZXNwb25zZVNjaGVtYT86IFN0YW5kYXJkU2NoZW1hVjE8UmVzdWx0VHlwZT47XG5cbiAgLyoqXG4gICAqIEEgc2NoZW1hIGZvciB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGJ5IHRoZSBgcXVlcnlgIG9yIGBxdWVyeUZuYCAoaW5jbHVkaW5nIGB0cmFuc2Zvcm1FcnJvclJlc3BvbnNlYCBpZiBwcm92aWRlZCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIG5vLXRyYW5zcGlsZVxuICAgKiBpbXBvcnQgeyBjcmVhdGVBcGkgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5L3JlYWN0J1xuICAgKiBpbXBvcnQgKiBhcyB2IGZyb20gXCJ2YWxpYm90XCJcbiAgICogaW1wb3J0IHsgY3VzdG9tQmFzZVF1ZXJ5LCBiYXNlUXVlcnlFcnJvclNjaGVtYSB9IGZyb20gXCIuL2N1c3RvbUJhc2VRdWVyeVwiXG4gICAqXG4gICAqIGNvbnN0IGFwaSA9IGNyZWF0ZUFwaSh7XG4gICAqICAgYmFzZVF1ZXJ5OiBjdXN0b21CYXNlUXVlcnksXG4gICAqICAgZW5kcG9pbnRzOiAoYnVpbGQpID0+ICh7XG4gICAqICAgICBnZXRQb3N0OiBidWlsZC5xdWVyeTxQb3N0LCB7IGlkOiBudW1iZXIgfT4oe1xuICAgKiAgICAgICBxdWVyeTogKHsgaWQgfSkgPT4gYC9wb3N0LyR7aWR9YCxcbiAgICogICAgICAgZXJyb3JSZXNwb25zZVNjaGVtYTogYmFzZVF1ZXJ5RXJyb3JTY2hlbWEsXG4gICAqICAgICB9KSxcbiAgICogICB9KVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIGVycm9yUmVzcG9uc2VTY2hlbWE/OiBTdGFuZGFyZFNjaGVtYVYxPEJhc2VRdWVyeUVycm9yPEJhc2VRdWVyeT4+O1xuXG4gIC8qKlxuICAgKiBBIHNjaGVtYSBmb3IgdGhlIGBtZXRhYCBwcm9wZXJ0eSByZXR1cm5lZCBieSB0aGUgYHF1ZXJ5YCBvciBgcXVlcnlGbmAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIG5vLXRyYW5zcGlsZVxuICAgKiBpbXBvcnQgeyBjcmVhdGVBcGkgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5L3JlYWN0J1xuICAgKiBpbXBvcnQgKiBhcyB2IGZyb20gXCJ2YWxpYm90XCJcbiAgICogaW1wb3J0IHsgY3VzdG9tQmFzZVF1ZXJ5LCBiYXNlUXVlcnlNZXRhU2NoZW1hIH0gZnJvbSBcIi4vY3VzdG9tQmFzZVF1ZXJ5XCJcbiAgICpcbiAgICogY29uc3QgYXBpID0gY3JlYXRlQXBpKHtcbiAgICogICBiYXNlUXVlcnk6IGN1c3RvbUJhc2VRdWVyeSxcbiAgICogICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAgICogICAgIGdldFBvc3Q6IGJ1aWxkLnF1ZXJ5PFBvc3QsIHsgaWQ6IG51bWJlciB9Pih7XG4gICAqICAgICAgIHF1ZXJ5OiAoeyBpZCB9KSA9PiBgL3Bvc3QvJHtpZH1gLFxuICAgKiAgICAgICBtZXRhU2NoZW1hOiBiYXNlUXVlcnlNZXRhU2NoZW1hLFxuICAgKiAgICAgfSksXG4gICAqICAgfSlcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBtZXRhU2NoZW1hPzogU3RhbmRhcmRTY2hlbWFWMTxCYXNlUXVlcnlNZXRhPEJhc2VRdWVyeT4+O1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqXG4gICAqIE1vc3QgYXBwcyBzaG91bGQgbGVhdmUgdGhpcyBzZXR0aW5nIG9uLiBUaGUgb25seSB0aW1lIGl0IGNhbiBiZSBhIHBlcmZvcm1hbmNlIGlzc3VlXG4gICAqIGlzIGlmIGFuIEFQSSByZXR1cm5zIGV4dHJlbWVseSBsYXJnZSBhbW91bnRzIG9mIGRhdGEgKGUuZy4gMTAsMDAwIHJvd3MgcGVyIHJlcXVlc3QpIGFuZFxuICAgKiB5b3UncmUgdW5hYmxlIHRvIHBhZ2luYXRlIGl0LlxuICAgKlxuICAgKiBGb3IgZGV0YWlscyBvZiBob3cgdGhpcyB3b3JrcywgcGxlYXNlIHNlZSB0aGUgYmVsb3cuIFdoZW4gaXQgaXMgc2V0IHRvIGBmYWxzZWAsXG4gICAqIGV2ZXJ5IHJlcXVlc3Qgd2lsbCBjYXVzZSBzdWJzY3JpYmVkIGNvbXBvbmVudHMgdG8gcmVyZW5kZXIsIGV2ZW4gd2hlbiB0aGUgZGF0YSBoYXMgbm90IGNoYW5nZWQuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvb3RoZXItZXhwb3J0cyNjb3B5d2l0aHN0cnVjdHVyYWxzaGFyaW5nXG4gICAqL1xuICBzdHJ1Y3R1cmFsU2hhcmluZz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBhIHNjaGVtYSB2YWxpZGF0aW9uIGZhaWxzLlxuICAgKlxuICAgKiBHZXRzIGNhbGxlZCB3aXRoIGEgYE5hbWVkU2NoZW1hRXJyb3JgIGFuZCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgZW5kcG9pbnQgbmFtZSwgdGhlIHR5cGUgb2YgdGhlIGVuZHBvaW50LCB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBlbmRwb2ludCwgYW5kIHRoZSBxdWVyeSBjYWNoZSBrZXkgKGlmIGFwcGxpY2FibGUpLlxuICAgKlxuICAgKiBgTmFtZWRTY2hlbWFFcnJvcmAgaGFzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogLSBgaXNzdWVzYDogYW4gYXJyYXkgb2YgaXNzdWVzIHRoYXQgY2F1c2VkIHRoZSB2YWxpZGF0aW9uIHRvIGZhaWxcbiAgICogLSBgdmFsdWVgOiB0aGUgdmFsdWUgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSBzY2hlbWFcbiAgICogLSBgc2NoZW1hTmFtZWA6IHRoZSBuYW1lIG9mIHRoZSBzY2hlbWEgdGhhdCB3YXMgdXNlZCB0byB2YWxpZGF0ZSB0aGUgdmFsdWUgKGUuZy4gYGFyZ1NjaGVtYWApXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIG5vLXRyYW5zcGlsZVxuICAgKiBpbXBvcnQgeyBjcmVhdGVBcGkgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5L3JlYWN0J1xuICAgKiBpbXBvcnQgKiBhcyB2IGZyb20gXCJ2YWxpYm90XCJcbiAgICpcbiAgICogY29uc3QgYXBpID0gY3JlYXRlQXBpKHtcbiAgICogICBiYXNlUXVlcnk6IGZldGNoQmFzZVF1ZXJ5KHsgYmFzZVVybDogJy8nIH0pLFxuICAgKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAgZ2V0UG9zdDogYnVpbGQucXVlcnk8UG9zdCwgeyBpZDogbnVtYmVyIH0+KHtcbiAgICogICAgICAgcXVlcnk6ICh7IGlkIH0pID0+IGAvcG9zdC8ke2lkfWAsXG4gICAqICAgICAgIG9uU2NoZW1hRmFpbHVyZTogKGVycm9yLCBpbmZvKSA9PiB7XG4gICAqICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvciwgaW5mbylcbiAgICogICAgICAgfSxcbiAgICogICAgIH0pLFxuICAgKiAgIH0pXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgb25TY2hlbWFGYWlsdXJlPzogU2NoZW1hRmFpbHVyZUhhbmRsZXI7XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBzY2hlbWEgdmFsaWRhdGlvbiBmYWlsdXJlIGludG8gYW4gZXJyb3Igc2hhcGUgbWF0Y2hpbmcgYmFzZSBxdWVyeSBlcnJvcnMuXG4gICAqXG4gICAqIFdoZW4gbm90IHByb3ZpZGVkLCBzY2hlbWEgZmFpbHVyZXMgYXJlIHRyZWF0ZWQgYXMgZmF0YWwsIGFuZCBub3JtYWwgZXJyb3IgaGFuZGxpbmcgc3VjaCBhcyB0YWcgaW52YWxpZGF0aW9uIHdpbGwgbm90IGJlIGV4ZWN1dGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBjb2RlYmxvY2stbWV0YSBuby10cmFuc3BpbGVcbiAgICogaW1wb3J0IHsgY3JlYXRlQXBpIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeS9yZWFjdCdcbiAgICogaW1wb3J0ICogYXMgdiBmcm9tIFwidmFsaWJvdFwiXG4gICAqXG4gICAqIGNvbnN0IGFwaSA9IGNyZWF0ZUFwaSh7XG4gICAqICAgYmFzZVF1ZXJ5OiBmZXRjaEJhc2VRdWVyeSh7IGJhc2VVcmw6ICcvJyB9KSxcbiAgICogICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAgICogICAgIGdldFBvc3Q6IGJ1aWxkLnF1ZXJ5PFBvc3QsIHsgaWQ6IG51bWJlciB9Pih7XG4gICAqICAgICAgIHF1ZXJ5OiAoeyBpZCB9KSA9PiBgL3Bvc3QvJHtpZH1gLFxuICAgKiAgICAgICByZXNwb25zZVNjaGVtYTogdi5vYmplY3QoeyBpZDogdi5udW1iZXIoKSwgbmFtZTogdi5zdHJpbmcoKSB9KSxcbiAgICogICAgICAgY2F0Y2hTY2hlbWFGYWlsdXJlOiAoZXJyb3IsIGluZm8pID0+ICh7XG4gICAqICAgICAgICAgc3RhdHVzOiBcIkNVU1RPTV9FUlJPUlwiLFxuICAgKiAgICAgICAgIGVycm9yOiBlcnJvci5zY2hlbWFOYW1lICsgXCIgZmFpbGVkIHZhbGlkYXRpb25cIixcbiAgICogICAgICAgICBkYXRhOiBlcnJvci5pc3N1ZXMsXG4gICAqICAgICAgIH0pLFxuICAgKiAgICAgfSksXG4gICAqICAgfSksXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgY2F0Y2hTY2hlbWFGYWlsdXJlPzogU2NoZW1hRmFpbHVyZUNvbnZlcnRlcjxCYXNlUXVlcnk+O1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKlxuICAgKiBJZiBzZXQgdG8gYHRydWVgLCB3aWxsIHNraXAgc2NoZW1hIHZhbGlkYXRpb24gZm9yIHRoaXMgZW5kcG9pbnQuXG4gICAqIE92ZXJyaWRlcyB0aGUgZ2xvYmFsIHNldHRpbmcuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIG5vLXRyYW5zcGlsZVxuICAgKiBpbXBvcnQgeyBjcmVhdGVBcGkgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5L3JlYWN0J1xuICAgKiBpbXBvcnQgKiBhcyB2IGZyb20gXCJ2YWxpYm90XCJcbiAgICpcbiAgICogY29uc3QgYXBpID0gY3JlYXRlQXBpKHtcbiAgICogICBiYXNlUXVlcnk6IGZldGNoQmFzZVF1ZXJ5KHsgYmFzZVVybDogJy8nIH0pLFxuICAgKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAgZ2V0UG9zdDogYnVpbGQucXVlcnk8UG9zdCwgeyBpZDogbnVtYmVyIH0+KHtcbiAgICogICAgICAgcXVlcnk6ICh7IGlkIH0pID0+IGAvcG9zdC8ke2lkfWAsXG4gICAqICAgICAgIHJlc3BvbnNlU2NoZW1hOiB2Lm9iamVjdCh7IGlkOiB2Lm51bWJlcigpLCBuYW1lOiB2LnN0cmluZygpIH0pLFxuICAgKiAgICAgICBza2lwU2NoZW1hVmFsaWRhdGlvbjogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiLCAvLyBza2lwIHNjaGVtYSB2YWxpZGF0aW9uIGluIHRlc3RzLCBzaW5jZSB3ZSdsbCBiZSBtb2NraW5nIHRoZSByZXNwb25zZVxuICAgKiAgICAgfSksXG4gICAqICAgfSlcbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBza2lwU2NoZW1hVmFsaWRhdGlvbj86IGJvb2xlYW47XG59XG5leHBvcnQgdHlwZSBCYXNlRW5kcG9pbnREZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgUmVzdWx0VHlwZSwgUmF3UmVzdWx0VHlwZSBleHRlbmRzIEJhc2VRdWVyeVJlc3VsdDxCYXNlUXVlcnk+ID0gQmFzZVF1ZXJ5UmVzdWx0PEJhc2VRdWVyeT4+ID0gKChbQ2FzdEFueTxCYXNlUXVlcnlSZXN1bHQ8QmFzZVF1ZXJ5Piwge30+XSBleHRlbmRzIFtORVZFUl0gPyBuZXZlciA6IEVuZHBvaW50RGVmaW5pdGlvbldpdGhRdWVyeTxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZXN1bHRUeXBlLCBSYXdSZXN1bHRUeXBlPikgfCBFbmRwb2ludERlZmluaXRpb25XaXRoUXVlcnlGbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZXN1bHRUeXBlPikgJiBDb21tb25FbmRwb2ludERlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSwgUmVzdWx0VHlwZT4gJiB7XG4gIC8qIHBoYW50b20gdHlwZSAqL1xuICBbcmF3UmVzdWx0VHlwZV0/OiBSYXdSZXN1bHRUeXBlO1xuICAvKiBwaGFudG9tIHR5cGUgKi9cbiAgW3Jlc3VsdFR5cGVdPzogUmVzdWx0VHlwZTtcbiAgLyogcGhhbnRvbSB0eXBlICovXG4gIFtiYXNlUXVlcnldPzogQmFzZVF1ZXJ5O1xufSAmIEhhc1JlcXVpcmVkUHJvcHM8QmFzZVF1ZXJ5RXh0cmFPcHRpb25zPEJhc2VRdWVyeT4sIHtcbiAgZXh0cmFPcHRpb25zOiBCYXNlUXVlcnlFeHRyYU9wdGlvbnM8QmFzZVF1ZXJ5Pjtcbn0sIHtcbiAgZXh0cmFPcHRpb25zPzogQmFzZVF1ZXJ5RXh0cmFPcHRpb25zPEJhc2VRdWVyeT47XG59PjtcbmV4cG9ydCBlbnVtIERlZmluaXRpb25UeXBlIHtcbiAgcXVlcnkgPSAncXVlcnknLFxuICBtdXRhdGlvbiA9ICdtdXRhdGlvbicsXG4gIGluZmluaXRlcXVlcnkgPSAnaW5maW5pdGVxdWVyeScsXG59XG50eXBlIFRhZ0Rlc2NyaXB0aW9uQXJyYXk8VGFnVHlwZXMgZXh0ZW5kcyBzdHJpbmc+ID0gUmVhZG9ubHlBcnJheTxUYWdEZXNjcmlwdGlvbjxUYWdUeXBlcz4gfCB1bmRlZmluZWQgfCBudWxsPjtcbmV4cG9ydCB0eXBlIEdldFJlc3VsdERlc2NyaXB0aW9uRm48VGFnVHlwZXMgZXh0ZW5kcyBzdHJpbmcsIFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBFcnJvclR5cGUsIE1ldGFUeXBlPiA9IChyZXN1bHQ6IFJlc3VsdFR5cGUgfCB1bmRlZmluZWQsIGVycm9yOiBFcnJvclR5cGUgfCB1bmRlZmluZWQsIGFyZzogUXVlcnlBcmcsIG1ldGE6IE1ldGFUeXBlKSA9PiBUYWdEZXNjcmlwdGlvbkFycmF5PFRhZ1R5cGVzPjtcbmV4cG9ydCB0eXBlIEZ1bGxUYWdEZXNjcmlwdGlvbjxUYWdUeXBlPiA9IHtcbiAgdHlwZTogVGFnVHlwZTtcbiAgaWQ/OiBudW1iZXIgfCBzdHJpbmc7XG59O1xuZXhwb3J0IHR5cGUgVGFnRGVzY3JpcHRpb248VGFnVHlwZT4gPSBUYWdUeXBlIHwgRnVsbFRhZ0Rlc2NyaXB0aW9uPFRhZ1R5cGU+O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgUmVzdWx0RGVzY3JpcHRpb248VGFnVHlwZXMgZXh0ZW5kcyBzdHJpbmcsIFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBFcnJvclR5cGUsIE1ldGFUeXBlPiA9IFRhZ0Rlc2NyaXB0aW9uQXJyYXk8VGFnVHlwZXM+IHwgR2V0UmVzdWx0RGVzY3JpcHRpb25GbjxUYWdUeXBlcywgUmVzdWx0VHlwZSwgUXVlcnlBcmcsIEVycm9yVHlwZSwgTWV0YVR5cGU+O1xudHlwZSBRdWVyeVR5cGVzPFF1ZXJ5QXJnLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgVGFnVHlwZXMgZXh0ZW5kcyBzdHJpbmcsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IEJhc2VFbmRwb2ludFR5cGVzPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFJlc3VsdFR5cGU+ICYge1xuICAvKipcbiAgICogVGhlIGVuZHBvaW50IGRlZmluaXRpb24gdHlwZS4gVG8gYmUgdXNlZCB3aXRoIHNvbWUgaW50ZXJuYWwgZ2VuZXJpYyB0eXBlcy5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3QgdXNlTXlXcmFwcGVkSG9vazogVXNlUXVlcnk8dHlwZW9mIGFwaS5lbmRwb2ludHMucXVlcnkuVHlwZXMuUXVlcnlEZWZpbml0aW9uPiA9IC4uLlxuICAgKiBgYGBcbiAgICovXG4gIFF1ZXJ5RGVmaW5pdGlvbjogUXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aD47XG4gIFRhZ1R5cGVzOiBUYWdUeXBlcztcbiAgUmVkdWNlclBhdGg6IFJlZHVjZXJQYXRoO1xufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlFeHRyYU9wdGlvbnM8VGFnVHlwZXMgZXh0ZW5kcyBzdHJpbmcsIFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgUmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IGV4dGVuZHMgQ2FjaGVMaWZlY3ljbGVRdWVyeUV4dHJhT3B0aW9uczxSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZWR1Y2VyUGF0aD4sIFF1ZXJ5TGlmZWN5Y2xlUXVlcnlFeHRyYU9wdGlvbnM8UmVzdWx0VHlwZSwgUXVlcnlBcmcsIEJhc2VRdWVyeSwgUmVkdWNlclBhdGg+LCBDYWNoZUNvbGxlY3Rpb25RdWVyeUV4dHJhT3B0aW9ucyB7XG4gIHR5cGU6IERlZmluaXRpb25UeXBlLnF1ZXJ5O1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBxdWVyeWAgZW5kcG9pbnRzLiBEZXRlcm1pbmVzIHdoaWNoICd0YWcnIGlzIGF0dGFjaGVkIHRvIHRoZSBjYWNoZWQgZGF0YSByZXR1cm5lZCBieSB0aGUgcXVlcnkuXG4gICAqIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGFnIHR5cGUgc3RyaW5ncywgYW4gYXJyYXkgb2Ygb2JqZWN0cyBvZiB0YWcgdHlwZXMgd2l0aCBpZHMsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHN1Y2ggYW4gYXJyYXkuXG4gICAqIDEuICBgWydQb3N0J11gIC0gZXF1aXZhbGVudCB0byBgMmBcbiAgICogMi4gIGBbeyB0eXBlOiAnUG9zdCcgfV1gIC0gZXF1aXZhbGVudCB0byBgMWBcbiAgICogMy4gIGBbeyB0eXBlOiAnUG9zdCcsIGlkOiAxIH1dYFxuICAgKiA0LiAgYChyZXN1bHQsIGVycm9yLCBhcmcpID0+IFsnUG9zdCddYCAtIGVxdWl2YWxlbnQgdG8gYDVgXG4gICAqIDUuICBgKHJlc3VsdCwgZXJyb3IsIGFyZykgPT4gW3sgdHlwZTogJ1Bvc3QnIH1dYCAtIGVxdWl2YWxlbnQgdG8gYDRgXG4gICAqIDYuICBgKHJlc3VsdCwgZXJyb3IsIGFyZykgPT4gW3sgdHlwZTogJ1Bvc3QnLCBpZDogMSB9XWBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgdGl0bGU9XCJwcm92aWRlc1RhZ3MgZXhhbXBsZVwiXG4gICAqXG4gICAqIGltcG9ydCB7IGNyZWF0ZUFwaSwgZmV0Y2hCYXNlUXVlcnkgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5L3JlYWN0J1xuICAgKiBpbnRlcmZhY2UgUG9zdCB7XG4gICAqICAgaWQ6IG51bWJlclxuICAgKiAgIG5hbWU6IHN0cmluZ1xuICAgKiB9XG4gICAqIHR5cGUgUG9zdHNSZXNwb25zZSA9IFBvc3RbXVxuICAgKlxuICAgKiBjb25zdCBhcGkgPSBjcmVhdGVBcGkoe1xuICAgKiAgIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnLycgfSksXG4gICAqICAgdGFnVHlwZXM6IFsnUG9zdHMnXSxcbiAgICogICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAgICogICAgIGdldFBvc3RzOiBidWlsZC5xdWVyeTxQb3N0c1Jlc3BvbnNlLCB2b2lkPih7XG4gICAqICAgICAgIHF1ZXJ5OiAoKSA9PiAncG9zdHMnLFxuICAgKiAgICAgICAvLyBoaWdobGlnaHQtc3RhcnRcbiAgICogICAgICAgcHJvdmlkZXNUYWdzOiAocmVzdWx0KSA9PlxuICAgKiAgICAgICAgIHJlc3VsdFxuICAgKiAgICAgICAgICAgPyBbXG4gICAqICAgICAgICAgICAgICAgLi4ucmVzdWx0Lm1hcCgoeyBpZCB9KSA9PiAoeyB0eXBlOiAnUG9zdHMnIGFzIGNvbnN0LCBpZCB9KSksXG4gICAqICAgICAgICAgICAgICAgeyB0eXBlOiAnUG9zdHMnLCBpZDogJ0xJU1QnIH0sXG4gICAqICAgICAgICAgICAgIF1cbiAgICogICAgICAgICAgIDogW3sgdHlwZTogJ1Bvc3RzJywgaWQ6ICdMSVNUJyB9XSxcbiAgICogICAgICAgLy8gaGlnaGxpZ2h0LWVuZFxuICAgKiAgICAgfSlcbiAgICogICB9KVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHByb3ZpZGVzVGFncz86IFJlc3VsdERlc2NyaXB0aW9uPFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5RXJyb3I8QmFzZVF1ZXJ5PiwgQmFzZVF1ZXJ5TWV0YTxCYXNlUXVlcnk+PjtcbiAgLyoqXG4gICAqIE5vdCB0byBiZSB1c2VkLiBBIHF1ZXJ5IHNob3VsZCBub3QgaW52YWxpZGF0ZSB0YWdzIGluIHRoZSBjYWNoZS5cbiAgICovXG4gIGludmFsaWRhdGVzVGFncz86IG5ldmVyO1xuXG4gIC8qKlxuICAgKiBDYW4gYmUgcHJvdmlkZWQgdG8gcmV0dXJuIGEgY3VzdG9tIGNhY2hlIGtleSB2YWx1ZSBiYXNlZCBvbiB0aGUgcXVlcnkgYXJndW1lbnRzLlxuICAgKlxuICAgKiBUaGlzIGlzIHByaW1hcmlseSBpbnRlbmRlZCBmb3IgY2FzZXMgd2hlcmUgYSBub24tc2VyaWFsaXphYmxlIHZhbHVlIGlzIHBhc3NlZCBhcyBwYXJ0IG9mIHRoZSBxdWVyeSBhcmcgb2JqZWN0IGFuZCBzaG91bGQgYmUgZXhjbHVkZWQgZnJvbSB0aGUgY2FjaGUga2V5LiAgSXQgbWF5IGFsc28gYmUgdXNlZCBmb3IgY2FzZXMgd2hlcmUgYW4gZW5kcG9pbnQgc2hvdWxkIG9ubHkgaGF2ZSBhIHNpbmdsZSBjYWNoZSBlbnRyeSwgc3VjaCBhcyBhbiBpbmZpbml0ZSBsb2FkaW5nIC8gcGFnaW5hdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogVW5saWtlIHRoZSBgY3JlYXRlQXBpYCB2ZXJzaW9uIHdoaWNoIGNhbiBfb25seV8gcmV0dXJuIGEgc3RyaW5nLCB0aGlzIHBlci1lbmRwb2ludCBvcHRpb24gY2FuIGFsc28gcmV0dXJuIGFuIGFuIG9iamVjdCwgbnVtYmVyLCBvciBib29sZWFuLiAgSWYgaXQgcmV0dXJucyBhIHN0cmluZywgdGhhdCB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGNhY2hlIGtleSBkaXJlY3RseS4gIElmIGl0IHJldHVybnMgYW4gb2JqZWN0IC8gbnVtYmVyIC8gYm9vbGVhbiwgdGhhdCB2YWx1ZSB3aWxsIGJlIHBhc3NlZCB0byB0aGUgYnVpbHQtaW4gYGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3NgLiAgVGhpcyBzaW1wbGlmaWVzIHRoZSB1c2UgY2FzZSBvZiBzdHJpcHBpbmcgb3V0IGFyZ3MgeW91IGRvbid0IHdhbnQgaW5jbHVkZWQgaW4gdGhlIGNhY2hlIGtleS5cbiAgICpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgdGl0bGU9XCJzZXJpYWxpemVRdWVyeUFyZ3MgOiBleGNsdWRlIHZhbHVlXCJcbiAgICpcbiAgICogaW1wb3J0IHsgY3JlYXRlQXBpLCBmZXRjaEJhc2VRdWVyeSwgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnXG4gICAqIGludGVyZmFjZSBQb3N0IHtcbiAgICogICBpZDogbnVtYmVyXG4gICAqICAgbmFtZTogc3RyaW5nXG4gICAqIH1cbiAgICpcbiAgICogaW50ZXJmYWNlIE15QXBpQ2xpZW50IHtcbiAgICogICBmZXRjaFBvc3Q6IChpZDogc3RyaW5nKSA9PiBQcm9taXNlPFBvc3Q+XG4gICAqIH1cbiAgICpcbiAgICogY3JlYXRlQXBpKHtcbiAgICogIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnLycgfSksXG4gICAqICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAgICogICAgLy8gRXhhbXBsZTogYW4gZW5kcG9pbnQgd2l0aCBhbiBBUEkgY2xpZW50IHBhc3NlZCBpbiBhcyBhbiBhcmd1bWVudCxcbiAgICogICAgLy8gYnV0IG9ubHkgdGhlIGl0ZW0gSUQgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIGNhY2hlIGtleVxuICAgKiAgICBnZXRQb3N0OiBidWlsZC5xdWVyeTxQb3N0LCB7IGlkOiBzdHJpbmc7IGNsaWVudDogTXlBcGlDbGllbnQgfT4oe1xuICAgKiAgICAgIHF1ZXJ5Rm46IGFzeW5jICh7IGlkLCBjbGllbnQgfSkgPT4ge1xuICAgKiAgICAgICAgY29uc3QgcG9zdCA9IGF3YWl0IGNsaWVudC5mZXRjaFBvc3QoaWQpXG4gICAqICAgICAgICByZXR1cm4geyBkYXRhOiBwb3N0IH1cbiAgICogICAgICB9LFxuICAgKiAgICAgIC8vIGhpZ2hsaWdodC1zdGFydFxuICAgKiAgICAgIHNlcmlhbGl6ZVF1ZXJ5QXJnczogKHsgcXVlcnlBcmdzLCBlbmRwb2ludERlZmluaXRpb24sIGVuZHBvaW50TmFtZSB9KSA9PiB7XG4gICAqICAgICAgICBjb25zdCB7IGlkIH0gPSBxdWVyeUFyZ3NcbiAgICogICAgICAgIC8vIFRoaXMgY2FuIHJldHVybiBhIHN0cmluZywgYW4gb2JqZWN0LCBhIG51bWJlciwgb3IgYSBib29sZWFuLlxuICAgKiAgICAgICAgLy8gSWYgaXQgcmV0dXJucyBhbiBvYmplY3QsIG51bWJlciBvciBib29sZWFuLCB0aGF0IHZhbHVlXG4gICAqICAgICAgICAvLyB3aWxsIGJlIHNlcmlhbGl6ZWQgYXV0b21hdGljYWxseSB2aWEgYGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3NgXG4gICAqICAgICAgICByZXR1cm4geyBpZCB9IC8vIG9taXQgYGNsaWVudGAgZnJvbSB0aGUgY2FjaGUga2V5XG4gICAqXG4gICAqICAgICAgICAvLyBBbHRlcm5hdGVseSwgeW91IGNhbiB1c2UgYGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3NgIHlvdXJzZWxmOlxuICAgKiAgICAgICAgLy8gcmV0dXJuIGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3Moe1xuICAgKiAgICAgICAgLy8gICBlbmRwb2ludE5hbWUsXG4gICAqICAgICAgICAvLyAgIHF1ZXJ5QXJnczogeyBpZCB9LFxuICAgKiAgICAgICAgLy8gICBlbmRwb2ludERlZmluaXRpb25cbiAgICogICAgICAgIC8vIH0pXG4gICAqICAgICAgICAvLyBPciAgY3JlYXRlIGFuZCByZXR1cm4gYSBzdHJpbmcgeW91cnNlbGY6XG4gICAqICAgICAgICAvLyByZXR1cm4gYGdldFBvc3QoJHtpZH0pYFxuICAgKiAgICAgIH0sXG4gICAqICAgICAgLy8gaGlnaGxpZ2h0LWVuZFxuICAgKiAgICB9KSxcbiAgICogIH0pLFxuICAgKn0pXG4gICAqIGBgYFxuICAgKi9cbiAgc2VyaWFsaXplUXVlcnlBcmdzPzogU2VyaWFsaXplUXVlcnlBcmdzPFF1ZXJ5QXJnLCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgUmVjb3JkPGFueSwgYW55Pj47XG5cbiAgLyoqXG4gICAqIENhbiBiZSBwcm92aWRlZCB0byBtZXJnZSBhbiBpbmNvbWluZyByZXNwb25zZSB2YWx1ZSBpbnRvIHRoZSBjdXJyZW50IGNhY2hlIGRhdGEuXG4gICAqIElmIHN1cHBsaWVkLCBubyBhdXRvbWF0aWMgc3RydWN0dXJhbCBzaGFyaW5nIHdpbGwgYmUgYXBwbGllZCAtIGl0J3MgdXAgdG9cbiAgICogeW91IHRvIHVwZGF0ZSB0aGUgY2FjaGUgYXBwcm9wcmlhdGVseS5cbiAgICpcbiAgICogU2luY2UgUlRLUSBub3JtYWxseSByZXBsYWNlcyBjYWNoZSBlbnRyaWVzIHdpdGggdGhlIG5ldyByZXNwb25zZSwgeW91IHdpbGwgdXN1YWxseVxuICAgKiBuZWVkIHRvIHVzZSB0aGlzIHdpdGggdGhlIGBzZXJpYWxpemVRdWVyeUFyZ3NgIG9yIGBmb3JjZVJlZmV0Y2hgIG9wdGlvbnMgdG8ga2VlcFxuICAgKiBhbiBleGlzdGluZyBjYWNoZSBlbnRyeSBzbyB0aGF0IGl0IGNhbiBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBTaW5jZSB0aGlzIGlzIHdyYXBwZWQgd2l0aCBJbW1lciwgeW91IG1heSBlaXRoZXIgbXV0YXRlIHRoZSBgY3VycmVudENhY2hlVmFsdWVgIGRpcmVjdGx5LFxuICAgKiBvciByZXR1cm4gYSBuZXcgdmFsdWUsIGJ1dCBfbm90XyBib3RoIGF0IG9uY2UuXG4gICAqXG4gICAqIFdpbGwgb25seSBiZSBjYWxsZWQgaWYgdGhlIGV4aXN0aW5nIGBjdXJyZW50Q2FjaGVEYXRhYCBpcyBfbm90XyBgdW5kZWZpbmVkYCAtIG9uIGZpcnN0IHJlc3BvbnNlLFxuICAgKiB0aGUgY2FjaGUgZW50cnkgd2lsbCBqdXN0IHNhdmUgdGhlIHJlc3BvbnNlIGRhdGEgZGlyZWN0bHkuXG4gICAqXG4gICAqIFVzZWZ1bCBpZiB5b3UgZG9uJ3Qgd2FudCBhIG5ldyByZXF1ZXN0IHRvIGNvbXBsZXRlbHkgb3ZlcnJpZGUgdGhlIGN1cnJlbnQgY2FjaGUgdmFsdWUsXG4gICAqIG1heWJlIGJlY2F1c2UgeW91IGhhdmUgbWFudWFsbHkgdXBkYXRlZCBpdCBmcm9tIGFub3RoZXIgc291cmNlIGFuZCBkb24ndCB3YW50IHRob3NlXG4gICAqIHVwZGF0ZXMgdG8gZ2V0IGxvc3QuXG4gICAqXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIHRpdGxlPVwibWVyZ2U6IHBhZ2luYXRpb25cIlxuICAgKlxuICAgKiBpbXBvcnQgeyBjcmVhdGVBcGksIGZldGNoQmFzZVF1ZXJ5LCBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeS9yZWFjdCdcbiAgICogaW50ZXJmYWNlIFBvc3Qge1xuICAgKiAgIGlkOiBudW1iZXJcbiAgICogICBuYW1lOiBzdHJpbmdcbiAgICogfVxuICAgKlxuICAgKiBjcmVhdGVBcGkoe1xuICAgKiAgYmFzZVF1ZXJ5OiBmZXRjaEJhc2VRdWVyeSh7IGJhc2VVcmw6ICcvJyB9KSxcbiAgICogIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICBsaXN0SXRlbXM6IGJ1aWxkLnF1ZXJ5PHN0cmluZ1tdLCBudW1iZXI+KHtcbiAgICogICAgICBxdWVyeTogKHBhZ2VOdW1iZXIpID0+IGAvbGlzdEl0ZW1zP3BhZ2U9JHtwYWdlTnVtYmVyfWAsXG4gICAqICAgICAvLyBPbmx5IGhhdmUgb25lIGNhY2hlIGVudHJ5IGJlY2F1c2UgdGhlIGFyZyBhbHdheXMgbWFwcyB0byBvbmUgc3RyaW5nXG4gICAqICAgICBzZXJpYWxpemVRdWVyeUFyZ3M6ICh7IGVuZHBvaW50TmFtZSB9KSA9PiB7XG4gICAqICAgICAgIHJldHVybiBlbmRwb2ludE5hbWVcbiAgICogICAgICB9LFxuICAgKiAgICAgIC8vIEFsd2F5cyBtZXJnZSBpbmNvbWluZyBkYXRhIHRvIHRoZSBjYWNoZSBlbnRyeVxuICAgKiAgICAgIG1lcmdlOiAoY3VycmVudENhY2hlLCBuZXdJdGVtcykgPT4ge1xuICAgKiAgICAgICAgY3VycmVudENhY2hlLnB1c2goLi4ubmV3SXRlbXMpXG4gICAqICAgICAgfSxcbiAgICogICAgICAvLyBSZWZldGNoIHdoZW4gdGhlIHBhZ2UgYXJnIGNoYW5nZXNcbiAgICogICAgICBmb3JjZVJlZmV0Y2goeyBjdXJyZW50QXJnLCBwcmV2aW91c0FyZyB9KSB7XG4gICAqICAgICAgICByZXR1cm4gY3VycmVudEFyZyAhPT0gcHJldmlvdXNBcmdcbiAgICogICAgICB9LFxuICAgKiAgICB9KSxcbiAgICogIH0pLFxuICAgKn0pXG4gICAqIGBgYFxuICAgKi9cbiAgbWVyZ2U/KGN1cnJlbnRDYWNoZURhdGE6IFJlc3VsdFR5cGUsIHJlc3BvbnNlRGF0YTogUmVzdWx0VHlwZSwgb3RoZXJBcmdzOiB7XG4gICAgYXJnOiBRdWVyeUFyZztcbiAgICBiYXNlUXVlcnlNZXRhOiBCYXNlUXVlcnlNZXRhPEJhc2VRdWVyeT47XG4gICAgcmVxdWVzdElkOiBzdHJpbmc7XG4gICAgZnVsZmlsbGVkVGltZVN0YW1wOiBudW1iZXI7XG4gIH0pOiBSZXN1bHRUeXBlIHwgdm9pZDtcblxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBlbmRwb2ludCBzaG91bGQgZm9yY2UgYSByZWZldGNoIGluIGNhc2VzIHdoZXJlIGl0IG5vcm1hbGx5IHdvdWxkbid0LlxuICAgKiBUaGlzIGlzIHByaW1hcmlseSB1c2VmdWwgZm9yIFwiaW5maW5pdGUgc2Nyb2xsXCIgLyBwYWdpbmF0aW9uIHVzZSBjYXNlcyB3aGVyZVxuICAgKiBSVEtRIGlzIGtlZXBpbmcgYSBzaW5nbGUgY2FjaGUgZW50cnkgdGhhdCBpcyBhZGRlZCB0byBvdmVyIHRpbWUsIGluIGNvbWJpbmF0aW9uXG4gICAqIHdpdGggYHNlcmlhbGl6ZVF1ZXJ5QXJnc2AgcmV0dXJuaW5nIGEgZml4ZWQgY2FjaGUga2V5IGFuZCBhIGBtZXJnZWAgY2FsbGJhY2tcbiAgICogc2V0IHRvIGFkZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBjYWNoZSBlbnRyeSBlYWNoIHRpbWUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIHRpdGxlPVwiZm9yY2VSZWZyZXNoOiBwYWdpbmF0aW9uXCJcbiAgICpcbiAgICogaW1wb3J0IHsgY3JlYXRlQXBpLCBmZXRjaEJhc2VRdWVyeSwgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnXG4gICAqIGludGVyZmFjZSBQb3N0IHtcbiAgICogICBpZDogbnVtYmVyXG4gICAqICAgbmFtZTogc3RyaW5nXG4gICAqIH1cbiAgICpcbiAgICogY3JlYXRlQXBpKHtcbiAgICogIGJhc2VRdWVyeTogZmV0Y2hCYXNlUXVlcnkoeyBiYXNlVXJsOiAnLycgfSksXG4gICAqICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAgICogICAgbGlzdEl0ZW1zOiBidWlsZC5xdWVyeTxzdHJpbmdbXSwgbnVtYmVyPih7XG4gICAqICAgICAgcXVlcnk6IChwYWdlTnVtYmVyKSA9PiBgL2xpc3RJdGVtcz9wYWdlPSR7cGFnZU51bWJlcn1gLFxuICAgKiAgICAgLy8gT25seSBoYXZlIG9uZSBjYWNoZSBlbnRyeSBiZWNhdXNlIHRoZSBhcmcgYWx3YXlzIG1hcHMgdG8gb25lIHN0cmluZ1xuICAgKiAgICAgc2VyaWFsaXplUXVlcnlBcmdzOiAoeyBlbmRwb2ludE5hbWUgfSkgPT4ge1xuICAgKiAgICAgICByZXR1cm4gZW5kcG9pbnROYW1lXG4gICAqICAgICAgfSxcbiAgICogICAgICAvLyBBbHdheXMgbWVyZ2UgaW5jb21pbmcgZGF0YSB0byB0aGUgY2FjaGUgZW50cnlcbiAgICogICAgICBtZXJnZTogKGN1cnJlbnRDYWNoZSwgbmV3SXRlbXMpID0+IHtcbiAgICogICAgICAgIGN1cnJlbnRDYWNoZS5wdXNoKC4uLm5ld0l0ZW1zKVxuICAgKiAgICAgIH0sXG4gICAqICAgICAgLy8gUmVmZXRjaCB3aGVuIHRoZSBwYWdlIGFyZyBjaGFuZ2VzXG4gICAqICAgICAgZm9yY2VSZWZldGNoKHsgY3VycmVudEFyZywgcHJldmlvdXNBcmcgfSkge1xuICAgKiAgICAgICAgcmV0dXJuIGN1cnJlbnRBcmcgIT09IHByZXZpb3VzQXJnXG4gICAqICAgICAgfSxcbiAgICogICAgfSksXG4gICAqICB9KSxcbiAgICp9KVxuICAgKiBgYGBcbiAgICovXG4gIGZvcmNlUmVmZXRjaD8ocGFyYW1zOiB7XG4gICAgY3VycmVudEFyZzogUXVlcnlBcmcgfCB1bmRlZmluZWQ7XG4gICAgcHJldmlvdXNBcmc6IFF1ZXJ5QXJnIHwgdW5kZWZpbmVkO1xuICAgIHN0YXRlOiBSb290U3RhdGU8YW55LCBhbnksIHN0cmluZz47XG4gICAgZW5kcG9pbnRTdGF0ZT86IFF1ZXJ5U3ViU3RhdGU8YW55PjtcbiAgfSk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGVzZSBhcmUgYHVuZGVmaW5lZGAgYXQgcnVudGltZSwgcHVyZWx5IHRvIGJlIHVzZWQgaW4gVHlwZVNjcmlwdCBkZWNsYXJhdGlvbnMhXG4gICAqL1xuICBUeXBlcz86IFF1ZXJ5VHlwZXM8UXVlcnlBcmcsIEJhc2VRdWVyeSwgVGFnVHlwZXMsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoPjtcbn1cbmV4cG9ydCB0eXBlIFF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFRhZ1R5cGVzIGV4dGVuZHMgc3RyaW5nLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZyA9IHN0cmluZywgUmF3UmVzdWx0VHlwZSBleHRlbmRzIEJhc2VRdWVyeVJlc3VsdDxCYXNlUXVlcnk+ID0gQmFzZVF1ZXJ5UmVzdWx0PEJhc2VRdWVyeT4+ID0gQmFzZUVuZHBvaW50RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZXN1bHRUeXBlLCBSYXdSZXN1bHRUeXBlPiAmIFF1ZXJ5RXh0cmFPcHRpb25zPFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZWR1Y2VyUGF0aD47XG5leHBvcnQgdHlwZSBJbmZpbml0ZVF1ZXJ5VHlwZXM8UXVlcnlBcmcsIFBhZ2VQYXJhbSwgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFRhZ1R5cGVzIGV4dGVuZHMgc3RyaW5nLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gPSBCYXNlRW5kcG9pbnRUeXBlczxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZXN1bHRUeXBlPiAmIHtcbiAgLyoqXG4gICAqIFRoZSBlbmRwb2ludCBkZWZpbml0aW9uIHR5cGUuIFRvIGJlIHVzZWQgd2l0aCBzb21lIGludGVybmFsIGdlbmVyaWMgdHlwZXMuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHVzZU15V3JhcHBlZEhvb2s6IFVzZVF1ZXJ5PHR5cGVvZiBhcGkuZW5kcG9pbnRzLnF1ZXJ5LlR5cGVzLlF1ZXJ5RGVmaW5pdGlvbj4gPSAuLi5cbiAgICogYGBgXG4gICAqL1xuICBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjogSW5maW5pdGVRdWVyeURlZmluaXRpb248UXVlcnlBcmcsIFBhZ2VQYXJhbSwgQmFzZVF1ZXJ5LCBUYWdUeXBlcywgUmVzdWx0VHlwZSwgUmVkdWNlclBhdGg+O1xuICBUYWdUeXBlczogVGFnVHlwZXM7XG4gIFJlZHVjZXJQYXRoOiBSZWR1Y2VyUGF0aDtcbn07XG5leHBvcnQgaW50ZXJmYWNlIEluZmluaXRlUXVlcnlFeHRyYU9wdGlvbnM8VGFnVHlwZXMgZXh0ZW5kcyBzdHJpbmcsIFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBQYWdlUGFyYW0sIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gZXh0ZW5kcyBDYWNoZUxpZmVjeWNsZUluZmluaXRlUXVlcnlFeHRyYU9wdGlvbnM8SW5maW5pdGVEYXRhPFJlc3VsdFR5cGUsIFBhZ2VQYXJhbT4sIFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFJlZHVjZXJQYXRoPiwgUXVlcnlMaWZlY3ljbGVJbmZpbml0ZVF1ZXJ5RXh0cmFPcHRpb25zPEluZmluaXRlRGF0YTxSZXN1bHRUeXBlLCBQYWdlUGFyYW0+LCBRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZWR1Y2VyUGF0aD4sIENhY2hlQ29sbGVjdGlvblF1ZXJ5RXh0cmFPcHRpb25zIHtcbiAgdHlwZTogRGVmaW5pdGlvblR5cGUuaW5maW5pdGVxdWVyeTtcbiAgcHJvdmlkZXNUYWdzPzogUmVzdWx0RGVzY3JpcHRpb248VGFnVHlwZXMsIEluZmluaXRlRGF0YTxSZXN1bHRUeXBlLCBQYWdlUGFyYW0+LCBRdWVyeUFyZywgQmFzZVF1ZXJ5RXJyb3I8QmFzZVF1ZXJ5PiwgQmFzZVF1ZXJ5TWV0YTxCYXNlUXVlcnk+PjtcbiAgLyoqXG4gICAqIE5vdCB0byBiZSB1c2VkLiBBIHF1ZXJ5IHNob3VsZCBub3QgaW52YWxpZGF0ZSB0YWdzIGluIHRoZSBjYWNoZS5cbiAgICovXG4gIGludmFsaWRhdGVzVGFncz86IG5ldmVyO1xuXG4gIC8qKlxuICAgKiBSZXF1aXJlZCBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgaW5maW5pdGUgcXVlcnkgYmVoYXZpb3IuXG4gICAqIGBpbml0aWFsUGFnZVBhcmFtYCBhbmQgYGdldE5leHRQYWdlUGFyYW1gIGFyZSByZXF1aXJlZCwgdG9cbiAgICogZW5zdXJlIHRoZSBpbmZpbml0ZSBxdWVyeSBjYW4gcHJvcGVybHkgZmV0Y2ggdGhlIG5leHQgcGFnZSBvZiBkYXRhLlxuICAgKiBgaW5pdGlhbFBhZ2VQYXJhbWAgbWF5IGJlIHNwZWNpZmllZCB3aGVuIHVzaW5nIHRoZVxuICAgKiBlbmRwb2ludCwgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAqIGBtYXhQYWdlc2AgYW5kIGBnZXRQcmV2aW91c1BhZ2VQYXJhbWAgYXJlIGJvdGggb3B0aW9uYWwuXG4gICAqIFxuICAgKiBAZXhhbXBsZVxuICAgKiBcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgdGl0bGU9XCJpbmZpbml0ZVF1ZXJ5T3B0aW9ucyBleGFtcGxlXCJcbiAgICogaW1wb3J0IHsgY3JlYXRlQXBpLCBmZXRjaEJhc2VRdWVyeSwgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnXG4gICAqIFxuICAgKiB0eXBlIFBva2Vtb24gPSB7XG4gICAqICAgaWQ6IHN0cmluZ1xuICAgKiAgIG5hbWU6IHN0cmluZ1xuICAgKiB9XG4gICAqIFxuICAgKiBjb25zdCBwb2tlbW9uQXBpID0gY3JlYXRlQXBpKHtcbiAgICogICBiYXNlUXVlcnk6IGZldGNoQmFzZVF1ZXJ5KHsgYmFzZVVybDogJ2h0dHBzOi8vcG9rZWFwaS5jby9hcGkvdjIvJyB9KSxcbiAgICogICBlbmRwb2ludHM6IChidWlsZCkgPT4gKHtcbiAgICogICAgIGdldEluZmluaXRlUG9rZW1vbldpdGhNYXg6IGJ1aWxkLmluZmluaXRlUXVlcnk8UG9rZW1vbltdLCBzdHJpbmcsIG51bWJlcj4oe1xuICAgKiAgICAgICBpbmZpbml0ZVF1ZXJ5T3B0aW9uczoge1xuICAgKiAgICAgICAgIGluaXRpYWxQYWdlUGFyYW06IDAsXG4gICAqICAgICAgICAgbWF4UGFnZXM6IDMsXG4gICAqICAgICAgICAgZ2V0TmV4dFBhZ2VQYXJhbTogKGxhc3RQYWdlLCBhbGxQYWdlcywgbGFzdFBhZ2VQYXJhbSwgYWxsUGFnZVBhcmFtcykgPT5cbiAgICogICAgICAgICAgIGxhc3RQYWdlUGFyYW0gKyAxLFxuICAgKiAgICAgICAgIGdldFByZXZpb3VzUGFnZVBhcmFtOiAoXG4gICAqICAgICAgICAgICBmaXJzdFBhZ2UsXG4gICAqICAgICAgICAgICBhbGxQYWdlcyxcbiAgICogICAgICAgICAgIGZpcnN0UGFnZVBhcmFtLFxuICAgKiAgICAgICAgICAgYWxsUGFnZVBhcmFtcyxcbiAgICogICAgICAgICApID0+IHtcbiAgICogICAgICAgICAgIHJldHVybiBmaXJzdFBhZ2VQYXJhbSA+IDAgPyBmaXJzdFBhZ2VQYXJhbSAtIDEgOiB1bmRlZmluZWRcbiAgICogICAgICAgICB9LFxuICAgKiAgICAgICB9LFxuICAgKiAgICAgICBxdWVyeSh7cGFnZVBhcmFtfSkge1xuICAgKiAgICAgICAgIHJldHVybiBgaHR0cHM6Ly9leGFtcGxlLmNvbS9saXN0SXRlbXM/cGFnZT0ke3BhZ2VQYXJhbX1gXG4gICAqICAgICAgIH0sXG4gICAqICAgICB9KSxcbiAgICogICB9KSxcbiAgICogfSlcbiAgIFxuICAgKiBgYGBcbiAgICovXG4gIGluZmluaXRlUXVlcnlPcHRpb25zOiBJbmZpbml0ZVF1ZXJ5Q29uZmlnT3B0aW9uczxSZXN1bHRUeXBlLCBQYWdlUGFyYW0sIFF1ZXJ5QXJnPjtcblxuICAvKipcbiAgICogQ2FuIGJlIHByb3ZpZGVkIHRvIHJldHVybiBhIGN1c3RvbSBjYWNoZSBrZXkgdmFsdWUgYmFzZWQgb24gdGhlIHF1ZXJ5IGFyZ3VtZW50cy5cbiAgICpcbiAgICogVGhpcyBpcyBwcmltYXJpbHkgaW50ZW5kZWQgZm9yIGNhc2VzIHdoZXJlIGEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSBpcyBwYXNzZWQgYXMgcGFydCBvZiB0aGUgcXVlcnkgYXJnIG9iamVjdCBhbmQgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIGNhY2hlIGtleS4gIEl0IG1heSBhbHNvIGJlIHVzZWQgZm9yIGNhc2VzIHdoZXJlIGFuIGVuZHBvaW50IHNob3VsZCBvbmx5IGhhdmUgYSBzaW5nbGUgY2FjaGUgZW50cnksIHN1Y2ggYXMgYW4gaW5maW5pdGUgbG9hZGluZyAvIHBhZ2luYXRpb24gaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIFVubGlrZSB0aGUgYGNyZWF0ZUFwaWAgdmVyc2lvbiB3aGljaCBjYW4gX29ubHlfIHJldHVybiBhIHN0cmluZywgdGhpcyBwZXItZW5kcG9pbnQgb3B0aW9uIGNhbiBhbHNvIHJldHVybiBhbiBhbiBvYmplY3QsIG51bWJlciwgb3IgYm9vbGVhbi4gIElmIGl0IHJldHVybnMgYSBzdHJpbmcsIHRoYXQgdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBjYWNoZSBrZXkgZGlyZWN0bHkuICBJZiBpdCByZXR1cm5zIGFuIG9iamVjdCAvIG51bWJlciAvIGJvb2xlYW4sIHRoYXQgdmFsdWUgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGJ1aWx0LWluIGBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzYC4gIFRoaXMgc2ltcGxpZmllcyB0aGUgdXNlIGNhc2Ugb2Ygc3RyaXBwaW5nIG91dCBhcmdzIHlvdSBkb24ndCB3YW50IGluY2x1ZGVkIGluIHRoZSBjYWNoZSBrZXkuXG4gICAqXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIHRpdGxlPVwic2VyaWFsaXplUXVlcnlBcmdzIDogZXhjbHVkZSB2YWx1ZVwiXG4gICAqXG4gICAqIGltcG9ydCB7IGNyZWF0ZUFwaSwgZmV0Y2hCYXNlUXVlcnksIGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5L3JlYWN0J1xuICAgKiBpbnRlcmZhY2UgUG9zdCB7XG4gICAqICAgaWQ6IG51bWJlclxuICAgKiAgIG5hbWU6IHN0cmluZ1xuICAgKiB9XG4gICAqXG4gICAqIGludGVyZmFjZSBNeUFwaUNsaWVudCB7XG4gICAqICAgZmV0Y2hQb3N0OiAoaWQ6IHN0cmluZykgPT4gUHJvbWlzZTxQb3N0PlxuICAgKiB9XG4gICAqXG4gICAqIGNyZWF0ZUFwaSh7XG4gICAqICBiYXNlUXVlcnk6IGZldGNoQmFzZVF1ZXJ5KHsgYmFzZVVybDogJy8nIH0pLFxuICAgKiAgZW5kcG9pbnRzOiAoYnVpbGQpID0+ICh7XG4gICAqICAgIC8vIEV4YW1wbGU6IGFuIGVuZHBvaW50IHdpdGggYW4gQVBJIGNsaWVudCBwYXNzZWQgaW4gYXMgYW4gYXJndW1lbnQsXG4gICAqICAgIC8vIGJ1dCBvbmx5IHRoZSBpdGVtIElEIHNob3VsZCBiZSB1c2VkIGFzIHRoZSBjYWNoZSBrZXlcbiAgICogICAgZ2V0UG9zdDogYnVpbGQucXVlcnk8UG9zdCwgeyBpZDogc3RyaW5nOyBjbGllbnQ6IE15QXBpQ2xpZW50IH0+KHtcbiAgICogICAgICBxdWVyeUZuOiBhc3luYyAoeyBpZCwgY2xpZW50IH0pID0+IHtcbiAgICogICAgICAgIGNvbnN0IHBvc3QgPSBhd2FpdCBjbGllbnQuZmV0Y2hQb3N0KGlkKVxuICAgKiAgICAgICAgcmV0dXJuIHsgZGF0YTogcG9zdCB9XG4gICAqICAgICAgfSxcbiAgICogICAgICAvLyBoaWdobGlnaHQtc3RhcnRcbiAgICogICAgICBzZXJpYWxpemVRdWVyeUFyZ3M6ICh7IHF1ZXJ5QXJncywgZW5kcG9pbnREZWZpbml0aW9uLCBlbmRwb2ludE5hbWUgfSkgPT4ge1xuICAgKiAgICAgICAgY29uc3QgeyBpZCB9ID0gcXVlcnlBcmdzXG4gICAqICAgICAgICAvLyBUaGlzIGNhbiByZXR1cm4gYSBzdHJpbmcsIGFuIG9iamVjdCwgYSBudW1iZXIsIG9yIGEgYm9vbGVhbi5cbiAgICogICAgICAgIC8vIElmIGl0IHJldHVybnMgYW4gb2JqZWN0LCBudW1iZXIgb3IgYm9vbGVhbiwgdGhhdCB2YWx1ZVxuICAgKiAgICAgICAgLy8gd2lsbCBiZSBzZXJpYWxpemVkIGF1dG9tYXRpY2FsbHkgdmlhIGBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzYFxuICAgKiAgICAgICAgcmV0dXJuIHsgaWQgfSAvLyBvbWl0IGBjbGllbnRgIGZyb20gdGhlIGNhY2hlIGtleVxuICAgKlxuICAgKiAgICAgICAgLy8gQWx0ZXJuYXRlbHksIHlvdSBjYW4gdXNlIGBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzYCB5b3Vyc2VsZjpcbiAgICogICAgICAgIC8vIHJldHVybiBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICogICAgICAgIC8vICAgZW5kcG9pbnROYW1lLFxuICAgKiAgICAgICAgLy8gICBxdWVyeUFyZ3M6IHsgaWQgfSxcbiAgICogICAgICAgIC8vICAgZW5kcG9pbnREZWZpbml0aW9uXG4gICAqICAgICAgICAvLyB9KVxuICAgKiAgICAgICAgLy8gT3IgIGNyZWF0ZSBhbmQgcmV0dXJuIGEgc3RyaW5nIHlvdXJzZWxmOlxuICAgKiAgICAgICAgLy8gcmV0dXJuIGBnZXRQb3N0KCR7aWR9KWBcbiAgICogICAgICB9LFxuICAgKiAgICAgIC8vIGhpZ2hsaWdodC1lbmRcbiAgICogICAgfSksXG4gICAqICB9KSxcbiAgICp9KVxuICAgKiBgYGBcbiAgICovXG4gIHNlcmlhbGl6ZVF1ZXJ5QXJncz86IFNlcmlhbGl6ZVF1ZXJ5QXJnczxRdWVyeUFyZywgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IFJlY29yZDxhbnksIGFueT4+O1xuXG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlc2UgYXJlIGB1bmRlZmluZWRgIGF0IHJ1bnRpbWUsIHB1cmVseSB0byBiZSB1c2VkIGluIFR5cGVTY3JpcHQgZGVjbGFyYXRpb25zIVxuICAgKi9cbiAgVHlwZXM/OiBJbmZpbml0ZVF1ZXJ5VHlwZXM8UXVlcnlBcmcsIFBhZ2VQYXJhbSwgQmFzZVF1ZXJ5LCBUYWdUeXBlcywgUmVzdWx0VHlwZSwgUmVkdWNlclBhdGg+O1xufVxuZXhwb3J0IHR5cGUgSW5maW5pdGVRdWVyeURlZmluaXRpb248UXVlcnlBcmcsIFBhZ2VQYXJhbSwgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFRhZ1R5cGVzIGV4dGVuZHMgc3RyaW5nLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZyA9IHN0cmluZywgUmF3UmVzdWx0VHlwZSBleHRlbmRzIEJhc2VRdWVyeVJlc3VsdDxCYXNlUXVlcnk+ID0gQmFzZVF1ZXJ5UmVzdWx0PEJhc2VRdWVyeT4+ID1cbi8vIEluZmluaXRlIHF1ZXJ5IGVuZHBvaW50cyByZWNlaXZlIGB7cXVlcnlBcmcsIHBhZ2VQYXJhbX1gXG5CYXNlRW5kcG9pbnREZWZpbml0aW9uPEluZmluaXRlUXVlcnlDb21iaW5lZEFyZzxRdWVyeUFyZywgUGFnZVBhcmFtPiwgQmFzZVF1ZXJ5LCBSZXN1bHRUeXBlLCBSYXdSZXN1bHRUeXBlPiAmIEluZmluaXRlUXVlcnlFeHRyYU9wdGlvbnM8VGFnVHlwZXMsIFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBQYWdlUGFyYW0sIEJhc2VRdWVyeSwgUmVkdWNlclBhdGg+O1xudHlwZSBNdXRhdGlvblR5cGVzPFF1ZXJ5QXJnLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgVGFnVHlwZXMgZXh0ZW5kcyBzdHJpbmcsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IEJhc2VFbmRwb2ludFR5cGVzPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFJlc3VsdFR5cGU+ICYge1xuICAvKipcbiAgICogVGhlIGVuZHBvaW50IGRlZmluaXRpb24gdHlwZS4gVG8gYmUgdXNlZCB3aXRoIHNvbWUgaW50ZXJuYWwgZ2VuZXJpYyB0eXBlcy5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3QgdXNlTXlXcmFwcGVkSG9vazogVXNlTXV0YXRpb248dHlwZW9mIGFwaS5lbmRwb2ludHMucXVlcnkuVHlwZXMuTXV0YXRpb25EZWZpbml0aW9uPiA9IC4uLlxuICAgKiBgYGBcbiAgICovXG4gIE11dGF0aW9uRGVmaW5pdGlvbjogTXV0YXRpb25EZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aD47XG4gIFRhZ1R5cGVzOiBUYWdUeXBlcztcbiAgUmVkdWNlclBhdGg6IFJlZHVjZXJQYXRoO1xufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTXV0YXRpb25FeHRyYU9wdGlvbnM8VGFnVHlwZXMgZXh0ZW5kcyBzdHJpbmcsIFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgUmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IGV4dGVuZHMgQ2FjaGVMaWZlY3ljbGVNdXRhdGlvbkV4dHJhT3B0aW9uczxSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5LCBSZWR1Y2VyUGF0aD4sIFF1ZXJ5TGlmZWN5Y2xlTXV0YXRpb25FeHRyYU9wdGlvbnM8UmVzdWx0VHlwZSwgUXVlcnlBcmcsIEJhc2VRdWVyeSwgUmVkdWNlclBhdGg+IHtcbiAgdHlwZTogRGVmaW5pdGlvblR5cGUubXV0YXRpb247XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYG11dGF0aW9uYCBlbmRwb2ludHMuIERldGVybWluZXMgd2hpY2ggY2FjaGVkIGRhdGEgc2hvdWxkIGJlIGVpdGhlciByZS1mZXRjaGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgY2FjaGUuXG4gICAqIEV4cGVjdHMgdGhlIHNhbWUgc2hhcGVzIGFzIGBwcm92aWRlc1RhZ3NgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiAvLyBjb2RlYmxvY2stbWV0YSB0aXRsZT1cImludmFsaWRhdGVzVGFncyBleGFtcGxlXCJcbiAgICogaW1wb3J0IHsgY3JlYXRlQXBpLCBmZXRjaEJhc2VRdWVyeSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnXG4gICAqIGludGVyZmFjZSBQb3N0IHtcbiAgICogICBpZDogbnVtYmVyXG4gICAqICAgbmFtZTogc3RyaW5nXG4gICAqIH1cbiAgICogdHlwZSBQb3N0c1Jlc3BvbnNlID0gUG9zdFtdXG4gICAqXG4gICAqIGNvbnN0IGFwaSA9IGNyZWF0ZUFwaSh7XG4gICAqICAgYmFzZVF1ZXJ5OiBmZXRjaEJhc2VRdWVyeSh7IGJhc2VVcmw6ICcvJyB9KSxcbiAgICogICB0YWdUeXBlczogWydQb3N0cyddLFxuICAgKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAgZ2V0UG9zdHM6IGJ1aWxkLnF1ZXJ5PFBvc3RzUmVzcG9uc2UsIHZvaWQ+KHtcbiAgICogICAgICAgcXVlcnk6ICgpID0+ICdwb3N0cycsXG4gICAqICAgICAgIHByb3ZpZGVzVGFnczogKHJlc3VsdCkgPT5cbiAgICogICAgICAgICByZXN1bHRcbiAgICogICAgICAgICAgID8gW1xuICAgKiAgICAgICAgICAgICAgIC4uLnJlc3VsdC5tYXAoKHsgaWQgfSkgPT4gKHsgdHlwZTogJ1Bvc3RzJyBhcyBjb25zdCwgaWQgfSkpLFxuICAgKiAgICAgICAgICAgICAgIHsgdHlwZTogJ1Bvc3RzJywgaWQ6ICdMSVNUJyB9LFxuICAgKiAgICAgICAgICAgICBdXG4gICAqICAgICAgICAgICA6IFt7IHR5cGU6ICdQb3N0cycsIGlkOiAnTElTVCcgfV0sXG4gICAqICAgICB9KSxcbiAgICogICAgIGFkZFBvc3Q6IGJ1aWxkLm11dGF0aW9uPFBvc3QsIFBhcnRpYWw8UG9zdD4+KHtcbiAgICogICAgICAgcXVlcnkoYm9keSkge1xuICAgKiAgICAgICAgIHJldHVybiB7XG4gICAqICAgICAgICAgICB1cmw6IGBwb3N0c2AsXG4gICAqICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICogICAgICAgICAgIGJvZHksXG4gICAqICAgICAgICAgfVxuICAgKiAgICAgICB9LFxuICAgKiAgICAgICAvLyBoaWdobGlnaHQtc3RhcnRcbiAgICogICAgICAgaW52YWxpZGF0ZXNUYWdzOiBbeyB0eXBlOiAnUG9zdHMnLCBpZDogJ0xJU1QnIH1dLFxuICAgKiAgICAgICAvLyBoaWdobGlnaHQtZW5kXG4gICAqICAgICB9KSxcbiAgICogICB9KVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIGludmFsaWRhdGVzVGFncz86IFJlc3VsdERlc2NyaXB0aW9uPFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5RXJyb3I8QmFzZVF1ZXJ5PiwgQmFzZVF1ZXJ5TWV0YTxCYXNlUXVlcnk+PjtcbiAgLyoqXG4gICAqIE5vdCB0byBiZSB1c2VkLiBBIG11dGF0aW9uIHNob3VsZCBub3QgcHJvdmlkZSB0YWdzIHRvIHRoZSBjYWNoZS5cbiAgICovXG4gIHByb3ZpZGVzVGFncz86IG5ldmVyO1xuXG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlc2UgYXJlIGB1bmRlZmluZWRgIGF0IHJ1bnRpbWUsIHB1cmVseSB0byBiZSB1c2VkIGluIFR5cGVTY3JpcHQgZGVjbGFyYXRpb25zIVxuICAgKi9cbiAgVHlwZXM/OiBNdXRhdGlvblR5cGVzPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aD47XG59XG5leHBvcnQgdHlwZSBNdXRhdGlvbkRlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBUYWdUeXBlcyBleHRlbmRzIHN0cmluZywgUmVzdWx0VHlwZSwgUmVkdWNlclBhdGggZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsIFJhd1Jlc3VsdFR5cGUgZXh0ZW5kcyBCYXNlUXVlcnlSZXN1bHQ8QmFzZVF1ZXJ5PiA9IEJhc2VRdWVyeVJlc3VsdDxCYXNlUXVlcnk+PiA9IEJhc2VFbmRwb2ludERlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSwgUmVzdWx0VHlwZSwgUmF3UmVzdWx0VHlwZT4gJiBNdXRhdGlvbkV4dHJhT3B0aW9uczxUYWdUeXBlcywgUmVzdWx0VHlwZSwgUXVlcnlBcmcsIEJhc2VRdWVyeSwgUmVkdWNlclBhdGg+O1xuZXhwb3J0IHR5cGUgRW5kcG9pbnREZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgVGFnVHlwZXMgZXh0ZW5kcyBzdHJpbmcsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLCBQYWdlUGFyYW0gPSBhbnksIFJhd1Jlc3VsdFR5cGUgZXh0ZW5kcyBCYXNlUXVlcnlSZXN1bHQ8QmFzZVF1ZXJ5PiA9IEJhc2VRdWVyeVJlc3VsdDxCYXNlUXVlcnk+PiA9IFF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBUYWdUeXBlcywgUmVzdWx0VHlwZSwgUmVkdWNlclBhdGgsIFJhd1Jlc3VsdFR5cGU+IHwgTXV0YXRpb25EZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aCwgUmF3UmVzdWx0VHlwZT4gfCBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnksIFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aCwgUmF3UmVzdWx0VHlwZT47XG5leHBvcnQgdHlwZSBFbmRwb2ludERlZmluaXRpb25zID0gUmVjb3JkPHN0cmluZywgRW5kcG9pbnREZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueT4+O1xuZXhwb3J0IGZ1bmN0aW9uIGlzUXVlcnlEZWZpbml0aW9uKGU6IEVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+KTogZSBpcyBRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueT4ge1xuICByZXR1cm4gZS50eXBlID09PSBEZWZpbml0aW9uVHlwZS5xdWVyeTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc011dGF0aW9uRGVmaW5pdGlvbihlOiBFbmRwb2ludERlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55Pik6IGUgaXMgTXV0YXRpb25EZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+IHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gRGVmaW5pdGlvblR5cGUubXV0YXRpb247XG59XG5leHBvcnQgZnVuY3Rpb24gaXNJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbihlOiBFbmRwb2ludERlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55Pik6IGUgaXMgSW5maW5pdGVRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55PiB7XG4gIHJldHVybiBlLnR5cGUgPT09IERlZmluaXRpb25UeXBlLmluZmluaXRlcXVlcnk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBbnlRdWVyeURlZmluaXRpb24oZTogRW5kcG9pbnREZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4pOiBlIGlzIFF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+IHwgSW5maW5pdGVRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnk+IHtcbiAgcmV0dXJuIGlzUXVlcnlEZWZpbml0aW9uKGUpIHx8IGlzSW5maW5pdGVRdWVyeURlZmluaXRpb24oZSk7XG59XG5leHBvcnQgdHlwZSBFbmRwb2ludEJ1aWxkZXI8QmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFRhZ1R5cGVzIGV4dGVuZHMgc3RyaW5nLCBSZWR1Y2VyUGF0aCBleHRlbmRzIHN0cmluZz4gPSB7XG4gIC8qKlxuICAgKiBBbiBlbmRwb2ludCBkZWZpbml0aW9uIHRoYXQgcmV0cmlldmVzIGRhdGEsIGFuZCBtYXkgcHJvdmlkZSB0YWdzIHRvIHRoZSBjYWNoZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgdGl0bGU9XCJFeGFtcGxlIG9mIGFsbCBxdWVyeSBlbmRwb2ludCBvcHRpb25zXCJcbiAgICogY29uc3QgYXBpID0gY3JlYXRlQXBpKHtcbiAgICogIGJhc2VRdWVyeSxcbiAgICogIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICBnZXRQb3N0OiBidWlsZC5xdWVyeSh7XG4gICAqICAgICAgcXVlcnk6IChpZCkgPT4gKHsgdXJsOiBgcG9zdC8ke2lkfWAgfSksXG4gICAqICAgICAgLy8gUGljayBvdXQgZGF0YSBhbmQgcHJldmVudCBuZXN0ZWQgcHJvcGVydGllcyBpbiBhIGhvb2sgb3Igc2VsZWN0b3JcbiAgICogICAgICB0cmFuc2Zvcm1SZXNwb25zZTogKHJlc3BvbnNlKSA9PiByZXNwb25zZS5kYXRhLFxuICAgKiAgICAgIC8vIFBpY2sgb3V0IGVycm9yIGFuZCBwcmV2ZW50IG5lc3RlZCBwcm9wZXJ0aWVzIGluIGEgaG9vayBvciBzZWxlY3RvclxuICAgKiAgICAgIHRyYW5zZm9ybUVycm9yUmVzcG9uc2U6IChyZXNwb25zZSkgPT4gcmVzcG9uc2UuZXJyb3IsXG4gICAqICAgICAgLy8gYHJlc3VsdGAgaXMgdGhlIHNlcnZlciByZXNwb25zZVxuICAgKiAgICAgIHByb3ZpZGVzVGFnczogKHJlc3VsdCwgZXJyb3IsIGlkKSA9PiBbeyB0eXBlOiAnUG9zdCcsIGlkIH1dLFxuICAgKiAgICAgIC8vIHRyaWdnZXIgc2lkZSBlZmZlY3RzIG9yIG9wdGltaXN0aWMgdXBkYXRlc1xuICAgKiAgICAgIG9uUXVlcnlTdGFydGVkKGlkLCB7IGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmEsIHJlcXVlc3RJZCwgcXVlcnlGdWxmaWxsZWQsIGdldENhY2hlRW50cnksIHVwZGF0ZUNhY2hlZERhdGEgfSkge30sXG4gICAqICAgICAgLy8gaGFuZGxlIHN1YnNjcmlwdGlvbnMgZXRjXG4gICAqICAgICAgb25DYWNoZUVudHJ5QWRkZWQoaWQsIHsgZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYSwgcmVxdWVzdElkLCBjYWNoZUVudHJ5UmVtb3ZlZCwgY2FjaGVEYXRhTG9hZGVkLCBnZXRDYWNoZUVudHJ5LCB1cGRhdGVDYWNoZWREYXRhIH0pIHt9LFxuICAgKiAgICB9KSxcbiAgICogIH0pLFxuICAgKn0pO1xuICAgKmBgYFxuICAgKi9cbiAgcXVlcnk8UmVzdWx0VHlwZSwgUXVlcnlBcmcsIFJhd1Jlc3VsdFR5cGUgZXh0ZW5kcyBCYXNlUXVlcnlSZXN1bHQ8QmFzZVF1ZXJ5PiA9IEJhc2VRdWVyeVJlc3VsdDxCYXNlUXVlcnk+PihkZWZpbml0aW9uOiBPbWl0RnJvbVVuaW9uPFF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBUYWdUeXBlcywgUmVzdWx0VHlwZSwgUmVkdWNlclBhdGgsIFJhd1Jlc3VsdFR5cGU+LCAndHlwZSc+KTogUXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aCwgUmF3UmVzdWx0VHlwZT47XG5cbiAgLyoqXG4gICAqIEFuIGVuZHBvaW50IGRlZmluaXRpb24gdGhhdCBhbHRlcnMgZGF0YSBvbiB0aGUgc2VydmVyIG9yIHdpbGwgcG9zc2libHkgaW52YWxpZGF0ZSB0aGUgY2FjaGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIHRpdGxlPVwiRXhhbXBsZSBvZiBhbGwgbXV0YXRpb24gZW5kcG9pbnQgb3B0aW9uc1wiXG4gICAqIGNvbnN0IGFwaSA9IGNyZWF0ZUFwaSh7XG4gICAqICAgYmFzZVF1ZXJ5LFxuICAgKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICAgKiAgICAgdXBkYXRlUG9zdDogYnVpbGQubXV0YXRpb24oe1xuICAgKiAgICAgICBxdWVyeTogKHsgaWQsIC4uLnBhdGNoIH0pID0+ICh7IHVybDogYHBvc3QvJHtpZH1gLCBtZXRob2Q6ICdQQVRDSCcsIGJvZHk6IHBhdGNoIH0pLFxuICAgKiAgICAgICAvLyBQaWNrIG91dCBkYXRhIGFuZCBwcmV2ZW50IG5lc3RlZCBwcm9wZXJ0aWVzIGluIGEgaG9vayBvciBzZWxlY3RvclxuICAgKiAgICAgICB0cmFuc2Zvcm1SZXNwb25zZTogKHJlc3BvbnNlKSA9PiByZXNwb25zZS5kYXRhLFxuICAgKiAgICAgICAvLyBQaWNrIG91dCBlcnJvciBhbmQgcHJldmVudCBuZXN0ZWQgcHJvcGVydGllcyBpbiBhIGhvb2sgb3Igc2VsZWN0b3JcbiAgICogICAgICAgdHJhbnNmb3JtRXJyb3JSZXNwb25zZTogKHJlc3BvbnNlKSA9PiByZXNwb25zZS5lcnJvcixcbiAgICogICAgICAgLy8gYHJlc3VsdGAgaXMgdGhlIHNlcnZlciByZXNwb25zZVxuICAgKiAgICAgICBpbnZhbGlkYXRlc1RhZ3M6IChyZXN1bHQsIGVycm9yLCBpZCkgPT4gW3sgdHlwZTogJ1Bvc3QnLCBpZCB9XSxcbiAgICogICAgICAvLyB0cmlnZ2VyIHNpZGUgZWZmZWN0cyBvciBvcHRpbWlzdGljIHVwZGF0ZXNcbiAgICogICAgICBvblF1ZXJ5U3RhcnRlZChpZCwgeyBkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhLCByZXF1ZXN0SWQsIHF1ZXJ5RnVsZmlsbGVkLCBnZXRDYWNoZUVudHJ5IH0pIHt9LFxuICAgKiAgICAgIC8vIGhhbmRsZSBzdWJzY3JpcHRpb25zIGV0Y1xuICAgKiAgICAgIG9uQ2FjaGVFbnRyeUFkZGVkKGlkLCB7IGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmEsIHJlcXVlc3RJZCwgY2FjaGVFbnRyeVJlbW92ZWQsIGNhY2hlRGF0YUxvYWRlZCwgZ2V0Q2FjaGVFbnRyeSB9KSB7fSxcbiAgICogICAgIH0pLFxuICAgKiAgIH0pLFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICBtdXRhdGlvbjxSZXN1bHRUeXBlLCBRdWVyeUFyZywgUmF3UmVzdWx0VHlwZSBleHRlbmRzIEJhc2VRdWVyeVJlc3VsdDxCYXNlUXVlcnk+ID0gQmFzZVF1ZXJ5UmVzdWx0PEJhc2VRdWVyeT4+KGRlZmluaXRpb246IE9taXRGcm9tVW5pb248TXV0YXRpb25EZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aCwgUmF3UmVzdWx0VHlwZT4sICd0eXBlJz4pOiBNdXRhdGlvbkRlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSwgVGFnVHlwZXMsIFJlc3VsdFR5cGUsIFJlZHVjZXJQYXRoLCBSYXdSZXN1bHRUeXBlPjtcbiAgaW5maW5pdGVRdWVyeTxSZXN1bHRUeXBlLCBRdWVyeUFyZywgUGFnZVBhcmFtLCBSYXdSZXN1bHRUeXBlIGV4dGVuZHMgQmFzZVF1ZXJ5UmVzdWx0PEJhc2VRdWVyeT4gPSBCYXNlUXVlcnlSZXN1bHQ8QmFzZVF1ZXJ5Pj4oZGVmaW5pdGlvbjogT21pdEZyb21VbmlvbjxJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnksIFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aCwgUmF3UmVzdWx0VHlwZT4sICd0eXBlJz4pOiBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnksIFRhZ1R5cGVzLCBSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aCwgUmF3UmVzdWx0VHlwZT47XG59O1xuZXhwb3J0IHR5cGUgQXNzZXJ0VGFnVHlwZXMgPSA8VCBleHRlbmRzIEZ1bGxUYWdEZXNjcmlwdGlvbjxzdHJpbmc+Pih0OiBUKSA9PiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVByb3ZpZGVkQnk8UmVzdWx0VHlwZSwgUXVlcnlBcmcsIEVycm9yVHlwZSwgTWV0YVR5cGU+KGRlc2NyaXB0aW9uOiBSZXN1bHREZXNjcmlwdGlvbjxzdHJpbmcsIFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBFcnJvclR5cGUsIE1ldGFUeXBlPiB8IHVuZGVmaW5lZCwgcmVzdWx0OiBSZXN1bHRUeXBlIHwgdW5kZWZpbmVkLCBlcnJvcjogRXJyb3JUeXBlIHwgdW5kZWZpbmVkLCBxdWVyeUFyZzogUXVlcnlBcmcsIG1ldGE6IE1ldGFUeXBlIHwgdW5kZWZpbmVkLCBhc3NlcnRUYWdUeXBlczogQXNzZXJ0VGFnVHlwZXMpOiByZWFkb25seSBGdWxsVGFnRGVzY3JpcHRpb248c3RyaW5nPltdIHtcbiAgaWYgKGlzRnVuY3Rpb24oZGVzY3JpcHRpb24pKSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uKHJlc3VsdCBhcyBSZXN1bHRUeXBlLCBlcnJvciBhcyB1bmRlZmluZWQsIHF1ZXJ5QXJnLCBtZXRhIGFzIE1ldGFUeXBlKS5maWx0ZXIoaXNOb3ROdWxsaXNoKS5tYXAoZXhwYW5kVGFnRGVzY3JpcHRpb24pLm1hcChhc3NlcnRUYWdUeXBlcyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVzY3JpcHRpb24pKSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uLm1hcChleHBhbmRUYWdEZXNjcmlwdGlvbikubWFwKGFzc2VydFRhZ1R5cGVzKTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uPFQ+KHQ6IFQpOiB0IGlzIEV4dHJhY3Q8VCwgRnVuY3Rpb24+IHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZFRhZ0Rlc2NyaXB0aW9uKGRlc2NyaXB0aW9uOiBUYWdEZXNjcmlwdGlvbjxzdHJpbmc+KTogRnVsbFRhZ0Rlc2NyaXB0aW9uPHN0cmluZz4ge1xuICByZXR1cm4gdHlwZW9mIGRlc2NyaXB0aW9uID09PSAnc3RyaW5nJyA/IHtcbiAgICB0eXBlOiBkZXNjcmlwdGlvblxuICB9IDogZGVzY3JpcHRpb247XG59XG5leHBvcnQgdHlwZSBRdWVyeUFyZ0Zyb208RCBleHRlbmRzIEJhc2VFbmRwb2ludERlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55Pj4gPSBEIGV4dGVuZHMgQmFzZUVuZHBvaW50RGVmaW5pdGlvbjxpbmZlciBRQSwgYW55LCBhbnksIGFueT4gPyBRQSA6IG5ldmVyO1xuXG4vLyBKdXN0IGV4dHJhY3RpbmcgYFF1ZXJ5QXJnYCBmcm9tIGBCYXNlRW5kcG9pbnREZWZpbml0aW9uYFxuLy8gZG9lc24ndCBzdWZmaWNpZW50bHkgbWF0Y2ggaGVyZS5cbi8vIFdlIG5lZWQgdG8gZXhwbGljaXRseSBtYXRjaCBhZ2FpbnN0IGBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbmBcbmV4cG9ydCB0eXBlIEluZmluaXRlUXVlcnlBcmdGcm9tPEQgZXh0ZW5kcyBCYXNlRW5kcG9pbnREZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4+ID0gRCBleHRlbmRzIEluZmluaXRlUXVlcnlEZWZpbml0aW9uPGluZmVyIFFBLCBhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55PiA/IFFBIDogbmV2ZXI7XG5leHBvcnQgdHlwZSBRdWVyeUFyZ0Zyb21BbnlRdWVyeTxEIGV4dGVuZHMgQmFzZUVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+PiA9IEQgZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+ID8gSW5maW5pdGVRdWVyeUFyZ0Zyb208RD4gOiBEIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+ID8gUXVlcnlBcmdGcm9tPEQ+IDogbmV2ZXI7XG5leHBvcnQgdHlwZSBSZXN1bHRUeXBlRnJvbTxEIGV4dGVuZHMgQmFzZUVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+PiA9IEQgZXh0ZW5kcyBCYXNlRW5kcG9pbnREZWZpbml0aW9uPGFueSwgYW55LCBpbmZlciBSVCwgYW55PiA/IFJUIDogdW5rbm93bjtcbmV4cG9ydCB0eXBlIFJlZHVjZXJQYXRoRnJvbTxEIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueT4+ID0gRCBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGluZmVyIFJQLCBhbnksIGFueT4gPyBSUCA6IHVua25vd247XG5leHBvcnQgdHlwZSBUYWdUeXBlc0Zyb208RCBleHRlbmRzIEVuZHBvaW50RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+PiA9IEQgZXh0ZW5kcyBFbmRwb2ludERlZmluaXRpb248YW55LCBhbnksIGluZmVyIFRULCBhbnksIGFueSwgYW55LCBhbnk+ID8gVFQgOiB1bmtub3duO1xuZXhwb3J0IHR5cGUgUGFnZVBhcmFtRnJvbTxEIGV4dGVuZHMgSW5maW5pdGVRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55Pj4gPSBEIGV4dGVuZHMgSW5maW5pdGVRdWVyeURlZmluaXRpb248YW55LCBpbmZlciBQUCwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+ID8gUFAgOiB1bmtub3duO1xuZXhwb3J0IHR5cGUgSW5maW5pdGVRdWVyeUNvbWJpbmVkQXJnPFF1ZXJ5QXJnLCBQYWdlUGFyYW0+ID0ge1xuICBxdWVyeUFyZzogUXVlcnlBcmc7XG4gIHBhZ2VQYXJhbTogUGFnZVBhcmFtO1xufTtcbmV4cG9ydCB0eXBlIFRhZ1R5cGVzRnJvbUFwaTxUPiA9IFQgZXh0ZW5kcyBBcGk8YW55LCBhbnksIGFueSwgaW5mZXIgVGFnVHlwZXM+ID8gVGFnVHlwZXMgOiBuZXZlcjtcbmV4cG9ydCB0eXBlIERlZmluaXRpb25zRnJvbUFwaTxUPiA9IFQgZXh0ZW5kcyBBcGk8YW55LCBpbmZlciBEZWZpbml0aW9ucywgYW55LCBhbnk+ID8gRGVmaW5pdGlvbnMgOiBuZXZlcjtcbmV4cG9ydCB0eXBlIFRyYW5zZm9ybWVkUmVzcG9uc2U8TmV3RGVmaW5pdGlvbnMgZXh0ZW5kcyBFbmRwb2ludERlZmluaXRpb25zLCBLLCBSZXN1bHRUeXBlPiA9IEsgZXh0ZW5kcyBrZXlvZiBOZXdEZWZpbml0aW9ucyA/IE5ld0RlZmluaXRpb25zW0tdWyd0cmFuc2Zvcm1SZXNwb25zZSddIGV4dGVuZHMgdW5kZWZpbmVkID8gUmVzdWx0VHlwZSA6IFVud3JhcFByb21pc2U8UmV0dXJuVHlwZTxOb25VbmRlZmluZWQ8TmV3RGVmaW5pdGlvbnNbS11bJ3RyYW5zZm9ybVJlc3BvbnNlJ10+Pj4gOiBSZXN1bHRUeXBlO1xuZXhwb3J0IHR5cGUgT3ZlcnJpZGVSZXN1bHRUeXBlPERlZmluaXRpb24sIE5ld1Jlc3VsdFR5cGU+ID0gRGVmaW5pdGlvbiBleHRlbmRzIFF1ZXJ5RGVmaW5pdGlvbjxpbmZlciBRdWVyeUFyZywgaW5mZXIgQmFzZVF1ZXJ5LCBpbmZlciBUYWdUeXBlcywgYW55LCBpbmZlciBSZWR1Y2VyUGF0aD4gPyBRdWVyeURlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSwgVGFnVHlwZXMsIE5ld1Jlc3VsdFR5cGUsIFJlZHVjZXJQYXRoPiA6IERlZmluaXRpb24gZXh0ZW5kcyBNdXRhdGlvbkRlZmluaXRpb248aW5mZXIgUXVlcnlBcmcsIGluZmVyIEJhc2VRdWVyeSwgaW5mZXIgVGFnVHlwZXMsIGFueSwgaW5mZXIgUmVkdWNlclBhdGg+ID8gTXV0YXRpb25EZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFRhZ1R5cGVzLCBOZXdSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aD4gOiBEZWZpbml0aW9uIGV4dGVuZHMgSW5maW5pdGVRdWVyeURlZmluaXRpb248aW5mZXIgUXVlcnlBcmcsIGluZmVyIFBhZ2VQYXJhbSwgaW5mZXIgQmFzZVF1ZXJ5LCBpbmZlciBUYWdUeXBlcywgYW55LCBpbmZlciBSZWR1Y2VyUGF0aD4gPyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnksIFRhZ1R5cGVzLCBOZXdSZXN1bHRUeXBlLCBSZWR1Y2VyUGF0aD4gOiBuZXZlcjtcbmV4cG9ydCB0eXBlIFVwZGF0ZURlZmluaXRpb25zPERlZmluaXRpb25zIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9ucywgTmV3VGFnVHlwZXMgZXh0ZW5kcyBzdHJpbmcsIE5ld0RlZmluaXRpb25zIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9ucz4gPSB7IFtLIGluIGtleW9mIERlZmluaXRpb25zXTogRGVmaW5pdGlvbnNbS10gZXh0ZW5kcyBRdWVyeURlZmluaXRpb248aW5mZXIgUXVlcnlBcmcsIGluZmVyIEJhc2VRdWVyeSwgYW55LCBpbmZlciBSZXN1bHRUeXBlLCBpbmZlciBSZWR1Y2VyUGF0aD4gPyBRdWVyeURlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSwgTmV3VGFnVHlwZXMsIFRyYW5zZm9ybWVkUmVzcG9uc2U8TmV3RGVmaW5pdGlvbnMsIEssIFJlc3VsdFR5cGU+LCBSZWR1Y2VyUGF0aD4gOiBEZWZpbml0aW9uc1tLXSBleHRlbmRzIE11dGF0aW9uRGVmaW5pdGlvbjxpbmZlciBRdWVyeUFyZywgaW5mZXIgQmFzZVF1ZXJ5LCBhbnksIGluZmVyIFJlc3VsdFR5cGUsIGluZmVyIFJlZHVjZXJQYXRoPiA/IE11dGF0aW9uRGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBOZXdUYWdUeXBlcywgVHJhbnNmb3JtZWRSZXNwb25zZTxOZXdEZWZpbml0aW9ucywgSywgUmVzdWx0VHlwZT4sIFJlZHVjZXJQYXRoPiA6IERlZmluaXRpb25zW0tdIGV4dGVuZHMgSW5maW5pdGVRdWVyeURlZmluaXRpb248aW5mZXIgUXVlcnlBcmcsIGluZmVyIFBhZ2VQYXJhbSwgaW5mZXIgQmFzZVF1ZXJ5LCBhbnksIGluZmVyIFJlc3VsdFR5cGUsIGluZmVyIFJlZHVjZXJQYXRoPiA/IEluZmluaXRlUXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBQYWdlUGFyYW0sIEJhc2VRdWVyeSwgTmV3VGFnVHlwZXMsIFRyYW5zZm9ybWVkUmVzcG9uc2U8TmV3RGVmaW5pdGlvbnMsIEssIFJlc3VsdFR5cGU+LCBSZWR1Y2VyUGF0aD4gOiBuZXZlciB9OyIsImV4cG9ydCB0eXBlIElkPFQ+ID0geyBbSyBpbiBrZXlvZiBUXTogVFtLXSB9ICYge307XG5leHBvcnQgdHlwZSBXaXRoUmVxdWlyZWRQcm9wPFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IE9taXQ8VCwgSz4gJiBSZXF1aXJlZDxQaWNrPFQsIEs+PjtcbmV4cG9ydCB0eXBlIE92ZXJyaWRlPFQxLCBUMj4gPSBUMiBleHRlbmRzIGFueSA/IE9taXQ8VDEsIGtleW9mIFQyPiAmIFQyIDogbmV2ZXI7XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Q2FzdDxUPih2OiBhbnkpOiBhc3NlcnRzIHYgaXMgVCB7fVxuZXhwb3J0IGZ1bmN0aW9uIHNhZmVBc3NpZ248VCBleHRlbmRzIG9iamVjdD4odGFyZ2V0OiBULCAuLi5hcmdzOiBBcnJheTxQYXJ0aWFsPE5vSW5mZXI8VD4+Pik6IFQge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0YXJnZXQsIC4uLmFyZ3MpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBVbmlvbiB0eXBlIGAoQXxCKWAgdG8gYW4gaW50ZXJzZWN0aW9uIHR5cGUgYChBJkIpYFxuICovXG5leHBvcnQgdHlwZSBVbmlvblRvSW50ZXJzZWN0aW9uPFU+ID0gKFUgZXh0ZW5kcyBhbnkgPyAoazogVSkgPT4gdm9pZCA6IG5ldmVyKSBleHRlbmRzICgoazogaW5mZXIgSSkgPT4gdm9pZCkgPyBJIDogbmV2ZXI7XG5leHBvcnQgdHlwZSBOb25PcHRpb25hbEtleXM8VD4gPSB7IFtLIGluIGtleW9mIFRdLT86IHVuZGVmaW5lZCBleHRlbmRzIFRbS10gPyBuZXZlciA6IEsgfVtrZXlvZiBUXTtcbmV4cG9ydCB0eXBlIEhhc1JlcXVpcmVkUHJvcHM8VCwgVHJ1ZSwgRmFsc2U+ID0gTm9uT3B0aW9uYWxLZXlzPFQ+IGV4dGVuZHMgbmV2ZXIgPyBGYWxzZSA6IFRydWU7XG5leHBvcnQgdHlwZSBPcHRpb25hbElmQWxsUHJvcHNPcHRpb25hbDxUPiA9IEhhc1JlcXVpcmVkUHJvcHM8VCwgVCwgVCB8IG5ldmVyPjtcbmV4cG9ydCB0eXBlIE5vSW5mZXI8VD4gPSBbVF1bVCBleHRlbmRzIGFueSA/IDAgOiBuZXZlcl07XG5leHBvcnQgdHlwZSBOb25VbmRlZmluZWQ8VD4gPSBUIGV4dGVuZHMgdW5kZWZpbmVkID8gbmV2ZXIgOiBUO1xuZXhwb3J0IHR5cGUgVW53cmFwUHJvbWlzZTxUPiA9IFQgZXh0ZW5kcyBQcm9taXNlTGlrZTxpbmZlciBWPiA/IFYgOiBUO1xuZXhwb3J0IHR5cGUgTWF5YmVQcm9taXNlPFQ+ID0gVCB8IFByb21pc2VMaWtlPFQ+O1xuZXhwb3J0IHR5cGUgT21pdEZyb21VbmlvbjxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUIGV4dGVuZHMgYW55ID8gT21pdDxULCBLPiA6IG5ldmVyO1xuZXhwb3J0IHR5cGUgSXNBbnk8VCwgVHJ1ZSwgRmFsc2UgPSBuZXZlcj4gPSB0cnVlIHwgZmFsc2UgZXh0ZW5kcyAoVCBleHRlbmRzIG5ldmVyID8gdHJ1ZSA6IGZhbHNlKSA/IFRydWUgOiBGYWxzZTtcbmV4cG9ydCB0eXBlIENhc3RBbnk8VCwgQ2FzdFRvPiA9IElzQW55PFQsIENhc3RUbywgVD47IiwiaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSwgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHR5cGUgeyBTZWxlY3RvciwgVGh1bmtBY3Rpb24sIFRodW5rRGlzcGF0Y2gsIFVua25vd25BY3Rpb24gfSBmcm9tICdAcmVkdXhqcy90b29sa2l0JztcbmltcG9ydCB0eXBlIHsgQXBpLCBBcGlDb250ZXh0LCBBcGlFbmRwb2ludEluZmluaXRlUXVlcnksIEFwaUVuZHBvaW50TXV0YXRpb24sIEFwaUVuZHBvaW50UXVlcnksIEJhc2VRdWVyeUZuLCBDb3JlTW9kdWxlLCBFbmRwb2ludERlZmluaXRpb25zLCBJbmZpbml0ZVF1ZXJ5QWN0aW9uQ3JlYXRvclJlc3VsdCwgSW5maW5pdGVRdWVyeUFyZ0Zyb20sIEluZmluaXRlUXVlcnlEZWZpbml0aW9uLCBJbmZpbml0ZVF1ZXJ5UmVzdWx0U2VsZWN0b3JSZXN1bHQsIEluZmluaXRlUXVlcnlTdWJTdGF0ZSwgTXV0YXRpb25BY3Rpb25DcmVhdG9yUmVzdWx0LCBNdXRhdGlvbkRlZmluaXRpb24sIE11dGF0aW9uUmVzdWx0U2VsZWN0b3JSZXN1bHQsIFBhZ2VQYXJhbUZyb20sIFByZWZldGNoT3B0aW9ucywgUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0LCBRdWVyeUFyZ0Zyb20sIFF1ZXJ5Q2FjaGVLZXksIFF1ZXJ5RGVmaW5pdGlvbiwgUXVlcnlLZXlzLCBRdWVyeVJlc3VsdFNlbGVjdG9yUmVzdWx0LCBRdWVyeVN1YlN0YXRlLCBSZXN1bHRUeXBlRnJvbSwgUm9vdFN0YXRlLCBTZXJpYWxpemVRdWVyeUFyZ3MsIFNraXBUb2tlbiwgU3Vic2NyaXB0aW9uT3B0aW9ucywgVFNIZWxwZXJzSWQsIFRTSGVscGVyc05vSW5mZXIsIFRTSGVscGVyc092ZXJyaWRlIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeSc7XG5pbXBvcnQgeyBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzLCBRdWVyeVN0YXR1cywgc2tpcFRva2VuIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeSc7XG5pbXBvcnQgdHlwZSB7IERlcGVuZGVuY3lMaXN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZURlYnVnVmFsdWUsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgc2hhbGxvd0VxdWFsIH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHR5cGUgeyBTdWJzY3JpcHRpb25TZWxlY3RvcnMgfSBmcm9tICcuLi9jb3JlL2J1aWxkTWlkZGxld2FyZS9pbmRleCc7XG5pbXBvcnQgdHlwZSB7IEluZmluaXRlRGF0YSwgSW5maW5pdGVRdWVyeUNvbmZpZ09wdGlvbnMgfSBmcm9tICcuLi9jb3JlL2luZGV4JztcbmltcG9ydCB0eXBlIHsgVW5pbml0aWFsaXplZFZhbHVlIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgVU5JTklUSUFMSVpFRF9WQUxVRSB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB0eXBlIHsgUmVhY3RIb29rc01vZHVsZU9wdGlvbnMgfSBmcm9tICcuL21vZHVsZSc7XG5pbXBvcnQgeyB1c2VTdGFibGVRdWVyeUFyZ3MgfSBmcm9tICcuL3VzZVNlcmlhbGl6ZWRTdGFibGVWYWx1ZSc7XG5pbXBvcnQgeyB1c2VTaGFsbG93U3RhYmxlVmFsdWUgfSBmcm9tICcuL3VzZVNoYWxsb3dTdGFibGVWYWx1ZSc7XG5pbXBvcnQgdHlwZSB7IEluZmluaXRlUXVlcnlEaXJlY3Rpb24gfSBmcm9tICcuLi9jb3JlL2FwaVN0YXRlJztcbmltcG9ydCB7IGlzSW5maW5pdGVRdWVyeURlZmluaXRpb24gfSBmcm9tICcuLi9lbmRwb2ludERlZmluaXRpb25zJztcbmltcG9ydCB0eXBlIHsgU3RhcnRJbmZpbml0ZVF1ZXJ5QWN0aW9uQ3JlYXRvciB9IGZyb20gJy4uL2NvcmUvYnVpbGRJbml0aWF0ZSc7XG5cbi8vIENvcHktcGFzdGVkIGZyb20gUmVhY3QtUmVkdXhcbmNvbnN0IGNhblVzZURPTSA9ICgpID0+ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpO1xuY29uc3QgaXNET00gPSAvKiBAX19QVVJFX18gKi9jYW5Vc2VET00oKTtcblxuLy8gVW5kZXIgUmVhY3QgTmF0aXZlLCB3ZSBrbm93IHRoYXQgd2UgYWx3YXlzIHdhbnQgdG8gdXNlIHVzZUxheW91dEVmZmVjdFxuXG5jb25zdCBpc1J1bm5pbmdJblJlYWN0TmF0aXZlID0gKCkgPT4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZSc7XG5jb25zdCBpc1JlYWN0TmF0aXZlID0gLyogQF9fUFVSRV9fICovaXNSdW5uaW5nSW5SZWFjdE5hdGl2ZSgpO1xuY29uc3QgZ2V0VXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9ICgpID0+IGlzRE9NIHx8IGlzUmVhY3ROYXRpdmUgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5leHBvcnQgY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IC8qIEBfX1BVUkVfXyAqL2dldFVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKTtcbmV4cG9ydCB0eXBlIFF1ZXJ5SG9va3M8RGVmaW5pdGlvbiBleHRlbmRzIFF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4+ID0ge1xuICB1c2VRdWVyeTogVXNlUXVlcnk8RGVmaW5pdGlvbj47XG4gIHVzZUxhenlRdWVyeTogVXNlTGF6eVF1ZXJ5PERlZmluaXRpb24+O1xuICB1c2VRdWVyeVN1YnNjcmlwdGlvbjogVXNlUXVlcnlTdWJzY3JpcHRpb248RGVmaW5pdGlvbj47XG4gIHVzZUxhenlRdWVyeVN1YnNjcmlwdGlvbjogVXNlTGF6eVF1ZXJ5U3Vic2NyaXB0aW9uPERlZmluaXRpb24+O1xuICB1c2VRdWVyeVN0YXRlOiBVc2VRdWVyeVN0YXRlPERlZmluaXRpb24+O1xufTtcbmV4cG9ydCB0eXBlIEluZmluaXRlUXVlcnlIb29rczxEZWZpbml0aW9uIGV4dGVuZHMgSW5maW5pdGVRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnk+PiA9IHtcbiAgdXNlSW5maW5pdGVRdWVyeTogVXNlSW5maW5pdGVRdWVyeTxEZWZpbml0aW9uPjtcbiAgdXNlSW5maW5pdGVRdWVyeVN1YnNjcmlwdGlvbjogVXNlSW5maW5pdGVRdWVyeVN1YnNjcmlwdGlvbjxEZWZpbml0aW9uPjtcbiAgdXNlSW5maW5pdGVRdWVyeVN0YXRlOiBVc2VJbmZpbml0ZVF1ZXJ5U3RhdGU8RGVmaW5pdGlvbj47XG59O1xuZXhwb3J0IHR5cGUgTXV0YXRpb25Ib29rczxEZWZpbml0aW9uIGV4dGVuZHMgTXV0YXRpb25EZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55Pj4gPSB7XG4gIHVzZU11dGF0aW9uOiBVc2VNdXRhdGlvbjxEZWZpbml0aW9uPjtcbn07XG5cbi8qKlxuICogQSBSZWFjdCBob29rIHRoYXQgYXV0b21hdGljYWxseSB0cmlnZ2VycyBmZXRjaGVzIG9mIGRhdGEgZnJvbSBhbiBlbmRwb2ludCwgJ3N1YnNjcmliZXMnIHRoZSBjb21wb25lbnQgdG8gdGhlIGNhY2hlZCBkYXRhLCBhbmQgcmVhZHMgdGhlIHJlcXVlc3Qgc3RhdHVzIGFuZCBjYWNoZWQgZGF0YSBmcm9tIHRoZSBSZWR1eCBzdG9yZS4gVGhlIGNvbXBvbmVudCB3aWxsIHJlLXJlbmRlciBhcyB0aGUgbG9hZGluZyBzdGF0dXMgY2hhbmdlcyBhbmQgdGhlIGRhdGEgYmVjb21lcyBhdmFpbGFibGUuXG4gKlxuICogVGhlIHF1ZXJ5IGFyZyBpcyB1c2VkIGFzIGEgY2FjaGUga2V5LiBDaGFuZ2luZyB0aGUgcXVlcnkgYXJnIHdpbGwgdGVsbCB0aGUgaG9vayB0byByZS1mZXRjaCB0aGUgZGF0YSBpZiBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2FjaGUgYWxyZWFkeSwgYW5kIHRoZSBob29rIHdpbGwgcmV0dXJuIHRoZSBkYXRhIGZvciB0aGF0IHF1ZXJ5IGFyZyBvbmNlIGl0J3MgYXZhaWxhYmxlLlxuICpcbiAqIFRoaXMgaG9vayBjb21iaW5lcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBib3RoIFtgdXNlUXVlcnlTdGF0ZWBdKCN1c2VxdWVyeXN0YXRlKSBhbmQgW2B1c2VRdWVyeVN1YnNjcmlwdGlvbmBdKCN1c2VxdWVyeXN1YnNjcmlwdGlvbikgdG9nZXRoZXIsIGFuZCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGluIHRoZSBtYWpvcml0eSBvZiBzaXR1YXRpb25zLlxuICpcbiAqICMjIyMgRmVhdHVyZXNcbiAqXG4gKiAtIEF1dG9tYXRpY2FsbHkgdHJpZ2dlcnMgcmVxdWVzdHMgdG8gcmV0cmlldmUgZGF0YSBiYXNlZCBvbiB0aGUgaG9vayBhcmd1bWVudCBhbmQgd2hldGhlciBjYWNoZWQgZGF0YSBleGlzdHMgYnkgZGVmYXVsdFxuICogLSAnU3Vic2NyaWJlcycgdGhlIGNvbXBvbmVudCB0byBrZWVwIGNhY2hlZCBkYXRhIGluIHRoZSBzdG9yZSwgYW5kICd1bnN1YnNjcmliZXMnIHdoZW4gdGhlIGNvbXBvbmVudCB1bm1vdW50c1xuICogLSBBY2NlcHRzIHBvbGxpbmcvcmUtZmV0Y2hpbmcgb3B0aW9ucyB0byB0cmlnZ2VyIGF1dG9tYXRpYyByZS1mZXRjaGVzIHdoZW4gdGhlIGNvcnJlc3BvbmRpbmcgY3JpdGVyaWEgaXMgbWV0XG4gKiAtIFJldHVybnMgdGhlIGxhdGVzdCByZXF1ZXN0IHN0YXR1cyBhbmQgY2FjaGVkIGRhdGEgZnJvbSB0aGUgUmVkdXggc3RvcmVcbiAqIC0gUmUtcmVuZGVycyBhcyB0aGUgcmVxdWVzdCBzdGF0dXMgY2hhbmdlcyBhbmQgZGF0YSBiZWNvbWVzIGF2YWlsYWJsZVxuICovXG5leHBvcnQgdHlwZSBVc2VRdWVyeTxEIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4+ID0gPFIgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gVXNlUXVlcnlTdGF0ZURlZmF1bHRSZXN1bHQ8RD4+KGFyZzogUXVlcnlBcmdGcm9tPEQ+IHwgU2tpcFRva2VuLCBvcHRpb25zPzogVXNlUXVlcnlTdWJzY3JpcHRpb25PcHRpb25zICYgVXNlUXVlcnlTdGF0ZU9wdGlvbnM8RCwgUj4pID0+IFVzZVF1ZXJ5SG9va1Jlc3VsdDxELCBSPjtcbmV4cG9ydCB0eXBlIFR5cGVkVXNlUXVlcnk8UmVzdWx0VHlwZSwgUXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuPiA9IFVzZVF1ZXJ5PFF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBzdHJpbmcsIFJlc3VsdFR5cGUsIHN0cmluZz4+O1xuZXhwb3J0IHR5cGUgVXNlUXVlcnlIb29rUmVzdWx0PEQgZXh0ZW5kcyBRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55PiwgUiA9IFVzZVF1ZXJ5U3RhdGVEZWZhdWx0UmVzdWx0PEQ+PiA9IFVzZVF1ZXJ5U3RhdGVSZXN1bHQ8RCwgUj4gJiBVc2VRdWVyeVN1YnNjcmlwdGlvblJlc3VsdDxEPjtcblxuLyoqXG4gKiBIZWxwZXIgdHlwZSB0byBtYW51YWxseSB0eXBlIHRoZSByZXN1bHRcbiAqIG9mIHRoZSBgdXNlUXVlcnlgIGhvb2sgaW4gdXNlcmxhbmQgY29kZS5cbiAqL1xuZXhwb3J0IHR5cGUgVHlwZWRVc2VRdWVyeUhvb2tSZXN1bHQ8UmVzdWx0VHlwZSwgUXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBSID0gVXNlUXVlcnlTdGF0ZURlZmF1bHRSZXN1bHQ8UXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIHN0cmluZywgUmVzdWx0VHlwZSwgc3RyaW5nPj4+ID0gVHlwZWRVc2VRdWVyeVN0YXRlUmVzdWx0PFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBCYXNlUXVlcnksIFI+ICYgVHlwZWRVc2VRdWVyeVN1YnNjcmlwdGlvblJlc3VsdDxSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5PjtcbmV4cG9ydCB0eXBlIFVzZVF1ZXJ5U3Vic2NyaXB0aW9uT3B0aW9ucyA9IFN1YnNjcmlwdGlvbk9wdGlvbnMgJiB7XG4gIC8qKlxuICAgKiBQcmV2ZW50cyBhIHF1ZXJ5IGZyb20gYXV0b21hdGljYWxseSBydW5uaW5nLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBXaGVuIGBza2lwYCBpcyB0cnVlIChvciBgc2tpcFRva2VuYCBpcyBwYXNzZWQgaW4gYXMgYGFyZ2ApOlxuICAgKlxuICAgKiAtICoqSWYgdGhlIHF1ZXJ5IGhhcyBjYWNoZWQgZGF0YToqKlxuICAgKiAgICogVGhlIGNhY2hlZCBkYXRhICoqd2lsbCBub3QgYmUgdXNlZCoqIG9uIHRoZSBpbml0aWFsIGxvYWQsIGFuZCB3aWxsIGlnbm9yZSB1cGRhdGVzIGZyb20gYW55IGlkZW50aWNhbCBxdWVyeSB1bnRpbCB0aGUgYHNraXBgIGNvbmRpdGlvbiBpcyByZW1vdmVkXG4gICAqICAgKiBUaGUgcXVlcnkgd2lsbCBoYXZlIGEgc3RhdHVzIG9mIGB1bmluaXRpYWxpemVkYFxuICAgKiAgICogSWYgYHNraXA6IGZhbHNlYCBpcyBzZXQgYWZ0ZXIgdGhlIGluaXRpYWwgbG9hZCwgdGhlIGNhY2hlZCByZXN1bHQgd2lsbCBiZSB1c2VkXG4gICAqIC0gKipJZiB0aGUgcXVlcnkgZG9lcyBub3QgaGF2ZSBjYWNoZWQgZGF0YToqKlxuICAgKiAgICogVGhlIHF1ZXJ5IHdpbGwgaGF2ZSBhIHN0YXR1cyBvZiBgdW5pbml0aWFsaXplZGBcbiAgICogICAqIFRoZSBxdWVyeSB3aWxsIG5vdCBleGlzdCBpbiB0aGUgc3RhdGUgd2hlbiB2aWV3ZWQgd2l0aCB0aGUgZGV2IHRvb2xzXG4gICAqICAgKiBUaGUgcXVlcnkgd2lsbCBub3QgYXV0b21hdGljYWxseSBmZXRjaCBvbiBtb3VudFxuICAgKiAgICogVGhlIHF1ZXJ5IHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgcnVuIHdoZW4gYWRkaXRpb25hbCBjb21wb25lbnRzIHdpdGggdGhlIHNhbWUgcXVlcnkgYXJlIGFkZGVkIHRoYXQgZG8gcnVuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzeFxuICAgKiAvLyBjb2RlYmxvY2stbWV0YSBuby10cmFuc3BpbGUgdGl0bGU9XCJTa2lwIGV4YW1wbGVcIlxuICAgKiBjb25zdCBQb2tlbW9uID0gKHsgbmFtZSwgc2tpcCB9OiB7IG5hbWU6IHN0cmluZzsgc2tpcDogYm9vbGVhbiB9KSA9PiB7XG4gICAqICAgY29uc3QgeyBkYXRhLCBlcnJvciwgc3RhdHVzIH0gPSB1c2VHZXRQb2tlbW9uQnlOYW1lUXVlcnkobmFtZSwge1xuICAgKiAgICAgc2tpcCxcbiAgICogICB9KTtcbiAgICpcbiAgICogICByZXR1cm4gKFxuICAgKiAgICAgPGRpdj5cbiAgICogICAgICAge25hbWV9IC0ge3N0YXR1c31cbiAgICogICAgIDwvZGl2PlxuICAgKiAgICk7XG4gICAqIH07XG4gICAqIGBgYFxuICAgKi9cbiAgc2tpcD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLiBUaGlzIHNldHRpbmcgYWxsb3dzIHlvdSB0byBjb250cm9sIHdoZXRoZXIgaWYgYSBjYWNoZWQgcmVzdWx0IGlzIGFscmVhZHkgYXZhaWxhYmxlLCBSVEsgUXVlcnkgd2lsbCBvbmx5IHNlcnZlIGEgY2FjaGVkIHJlc3VsdCwgb3IgaWYgaXQgc2hvdWxkIGByZWZldGNoYCB3aGVuIHNldCB0byBgdHJ1ZWAgb3IgaWYgYW4gYWRlcXVhdGUgYW1vdW50IG9mIHRpbWUgaGFzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCBzdWNjZXNzZnVsIHF1ZXJ5IHJlc3VsdC5cbiAgICogLSBgZmFsc2VgIC0gV2lsbCBub3QgY2F1c2UgYSBxdWVyeSB0byBiZSBwZXJmb3JtZWQgX3VubGVzc18gaXQgZG9lcyBub3QgZXhpc3QgeWV0LlxuICAgKiAtIGB0cnVlYCAtIFdpbGwgYWx3YXlzIHJlZmV0Y2ggd2hlbiBhIG5ldyBzdWJzY3JpYmVyIHRvIGEgcXVlcnkgaXMgYWRkZWQuIEJlaGF2ZXMgdGhlIHNhbWUgYXMgY2FsbGluZyB0aGUgYHJlZmV0Y2hgIGNhbGxiYWNrIG9yIHBhc3NpbmcgYGZvcmNlUmVmZXRjaDogdHJ1ZWAgaW4gdGhlIGFjdGlvbiBjcmVhdG9yLlxuICAgKiAtIGBudW1iZXJgIC0gKipWYWx1ZSBpcyBpbiBzZWNvbmRzKiouIElmIGEgbnVtYmVyIGlzIHByb3ZpZGVkIGFuZCB0aGVyZSBpcyBhbiBleGlzdGluZyBxdWVyeSBpbiB0aGUgY2FjaGUsIGl0IHdpbGwgY29tcGFyZSB0aGUgY3VycmVudCB0aW1lIHZzIHRoZSBsYXN0IGZ1bGZpbGxlZCB0aW1lc3RhbXAsIGFuZCBvbmx5IHJlZmV0Y2ggaWYgZW5vdWdoIHRpbWUgaGFzIGVsYXBzZWQuXG4gICAqXG4gICAqIElmIHlvdSBzcGVjaWZ5IHRoaXMgb3B0aW9uIGFsb25nc2lkZSBgc2tpcDogdHJ1ZWAsIHRoaXMgKip3aWxsIG5vdCBiZSBldmFsdWF0ZWQqKiB1bnRpbCBgc2tpcGAgaXMgZmFsc2UuXG4gICAqL1xuICByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlPzogYm9vbGVhbiB8IG51bWJlcjtcbn07XG5cbi8qKlxuICogQSBSZWFjdCBob29rIHRoYXQgYXV0b21hdGljYWxseSB0cmlnZ2VycyBmZXRjaGVzIG9mIGRhdGEgZnJvbSBhbiBlbmRwb2ludCwgYW5kICdzdWJzY3JpYmVzJyB0aGUgY29tcG9uZW50IHRvIHRoZSBjYWNoZWQgZGF0YS5cbiAqXG4gKiBUaGUgcXVlcnkgYXJnIGlzIHVzZWQgYXMgYSBjYWNoZSBrZXkuIENoYW5naW5nIHRoZSBxdWVyeSBhcmcgd2lsbCB0ZWxsIHRoZSBob29rIHRvIHJlLWZldGNoIHRoZSBkYXRhIGlmIGl0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBjYWNoZSBhbHJlYWR5LlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGhvb2sgZG9lcyBub3QgcmV0dXJuIGEgcmVxdWVzdCBzdGF0dXMgb3IgY2FjaGVkIGRhdGEuIEZvciB0aGF0IHVzZS1jYXNlLCBzZWUgW2B1c2VRdWVyeWBdKCN1c2VxdWVyeSkgb3IgW2B1c2VRdWVyeVN0YXRlYF0oI3VzZXF1ZXJ5c3RhdGUpLlxuICpcbiAqICMjIyMgRmVhdHVyZXNcbiAqXG4gKiAtIEF1dG9tYXRpY2FsbHkgdHJpZ2dlcnMgcmVxdWVzdHMgdG8gcmV0cmlldmUgZGF0YSBiYXNlZCBvbiB0aGUgaG9vayBhcmd1bWVudCBhbmQgd2hldGhlciBjYWNoZWQgZGF0YSBleGlzdHMgYnkgZGVmYXVsdFxuICogLSAnU3Vic2NyaWJlcycgdGhlIGNvbXBvbmVudCB0byBrZWVwIGNhY2hlZCBkYXRhIGluIHRoZSBzdG9yZSwgYW5kICd1bnN1YnNjcmliZXMnIHdoZW4gdGhlIGNvbXBvbmVudCB1bm1vdW50c1xuICogLSBBY2NlcHRzIHBvbGxpbmcvcmUtZmV0Y2hpbmcgb3B0aW9ucyB0byB0cmlnZ2VyIGF1dG9tYXRpYyByZS1mZXRjaGVzIHdoZW4gdGhlIGNvcnJlc3BvbmRpbmcgY3JpdGVyaWEgaXMgbWV0XG4gKi9cbmV4cG9ydCB0eXBlIFVzZVF1ZXJ5U3Vic2NyaXB0aW9uPEQgZXh0ZW5kcyBRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55Pj4gPSAoYXJnOiBRdWVyeUFyZ0Zyb208RD4gfCBTa2lwVG9rZW4sIG9wdGlvbnM/OiBVc2VRdWVyeVN1YnNjcmlwdGlvbk9wdGlvbnMpID0+IFVzZVF1ZXJ5U3Vic2NyaXB0aW9uUmVzdWx0PEQ+O1xuZXhwb3J0IHR5cGUgVHlwZWRVc2VRdWVyeVN1YnNjcmlwdGlvbjxSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4+ID0gVXNlUXVlcnlTdWJzY3JpcHRpb248UXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIHN0cmluZywgUmVzdWx0VHlwZSwgc3RyaW5nPj47XG5leHBvcnQgdHlwZSBVc2VRdWVyeVN1YnNjcmlwdGlvblJlc3VsdDxEIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4+ID0gUGljazxRdWVyeUFjdGlvbkNyZWF0b3JSZXN1bHQ8RD4sICdyZWZldGNoJz47XG5cbi8qKlxuICogSGVscGVyIHR5cGUgdG8gbWFudWFsbHkgdHlwZSB0aGUgcmVzdWx0XG4gKiBvZiB0aGUgYHVzZVF1ZXJ5U3Vic2NyaXB0aW9uYCBob29rIGluIHVzZXJsYW5kIGNvZGUuXG4gKi9cbmV4cG9ydCB0eXBlIFR5cGVkVXNlUXVlcnlTdWJzY3JpcHRpb25SZXN1bHQ8UmVzdWx0VHlwZSwgUXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuPiA9IFVzZVF1ZXJ5U3Vic2NyaXB0aW9uUmVzdWx0PFF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBzdHJpbmcsIFJlc3VsdFR5cGUsIHN0cmluZz4+O1xuZXhwb3J0IHR5cGUgVXNlTGF6eVF1ZXJ5TGFzdFByb21pc2VJbmZvPEQgZXh0ZW5kcyBRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55Pj4gPSB7XG4gIGxhc3RBcmc6IFF1ZXJ5QXJnRnJvbTxEPjtcbn07XG5cbi8qKlxuICogQSBSZWFjdCBob29rIHNpbWlsYXIgdG8gW2B1c2VRdWVyeWBdKCN1c2VxdWVyeSksIGJ1dCB3aXRoIG1hbnVhbCBjb250cm9sIG92ZXIgd2hlbiB0aGUgZGF0YSBmZXRjaGluZyBvY2N1cnMuXG4gKlxuICogVGhpcyBob29rIGluY2x1ZGVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIFtgdXNlTGF6eVF1ZXJ5U3Vic2NyaXB0aW9uYF0oI3VzZWxhenlxdWVyeXN1YnNjcmlwdGlvbikuXG4gKlxuICogIyMjIyBGZWF0dXJlc1xuICpcbiAqIC0gTWFudWFsIGNvbnRyb2wgb3ZlciBmaXJpbmcgYSByZXF1ZXN0IHRvIHJldHJpZXZlIGRhdGFcbiAqIC0gJ1N1YnNjcmliZXMnIHRoZSBjb21wb25lbnQgdG8ga2VlcCBjYWNoZWQgZGF0YSBpbiB0aGUgc3RvcmUsIGFuZCAndW5zdWJzY3JpYmVzJyB3aGVuIHRoZSBjb21wb25lbnQgdW5tb3VudHNcbiAqIC0gUmV0dXJucyB0aGUgbGF0ZXN0IHJlcXVlc3Qgc3RhdHVzIGFuZCBjYWNoZWQgZGF0YSBmcm9tIHRoZSBSZWR1eCBzdG9yZVxuICogLSBSZS1yZW5kZXJzIGFzIHRoZSByZXF1ZXN0IHN0YXR1cyBjaGFuZ2VzIGFuZCBkYXRhIGJlY29tZXMgYXZhaWxhYmxlXG4gKiAtIEFjY2VwdHMgcG9sbGluZy9yZS1mZXRjaGluZyBvcHRpb25zIHRvIHRyaWdnZXIgYXV0b21hdGljIHJlLWZldGNoZXMgd2hlbiB0aGUgY29ycmVzcG9uZGluZyBjcml0ZXJpYSBpcyBtZXQgYW5kIHRoZSBmZXRjaCBoYXMgYmVlbiBtYW51YWxseSBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuICpcbiAqICMjIyMgTm90ZVxuICpcbiAqIFdoZW4gdGhlIHRyaWdnZXIgZnVuY3Rpb24gcmV0dXJuZWQgZnJvbSBhIExhenlRdWVyeSBpcyBjYWxsZWQsIGl0IGFsd2F5cyBpbml0aWF0ZXMgYSBuZXcgcmVxdWVzdCB0byB0aGUgc2VydmVyIGV2ZW4gaWYgdGhlcmUgaXMgY2FjaGVkIGRhdGEuIFNldCBgcHJlZmVyQ2FjaGVWYWx1ZWAodGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgZnVuY3Rpb24pIGFzIGB0cnVlYCBpZiB5b3Ugd2FudCBpdCB0byBpbW1lZGlhdGVseSByZXR1cm4gYSBjYWNoZWQgdmFsdWUgaWYgb25lIGV4aXN0cy5cbiAqL1xuZXhwb3J0IHR5cGUgVXNlTGF6eVF1ZXJ5PEQgZXh0ZW5kcyBRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55Pj4gPSA8UiBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4gPSBVc2VRdWVyeVN0YXRlRGVmYXVsdFJlc3VsdDxEPj4ob3B0aW9ucz86IFN1YnNjcmlwdGlvbk9wdGlvbnMgJiBPbWl0PFVzZVF1ZXJ5U3RhdGVPcHRpb25zPEQsIFI+LCAnc2tpcCc+KSA9PiBbTGF6eVF1ZXJ5VHJpZ2dlcjxEPiwgVXNlTGF6eVF1ZXJ5U3RhdGVSZXN1bHQ8RCwgUj4sIFVzZUxhenlRdWVyeUxhc3RQcm9taXNlSW5mbzxEPl07XG5leHBvcnQgdHlwZSBUeXBlZFVzZUxhenlRdWVyeTxSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4+ID0gVXNlTGF6eVF1ZXJ5PFF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBzdHJpbmcsIFJlc3VsdFR5cGUsIHN0cmluZz4+O1xuZXhwb3J0IHR5cGUgVXNlTGF6eVF1ZXJ5U3RhdGVSZXN1bHQ8RCBleHRlbmRzIFF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+LCBSID0gVXNlUXVlcnlTdGF0ZURlZmF1bHRSZXN1bHQ8RD4+ID0gVXNlUXVlcnlTdGF0ZVJlc3VsdDxELCBSPiAmIHtcbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgaG9vayBzdGF0ZSB0byBpdHMgaW5pdGlhbCBgdW5pbml0aWFsaXplZGAgc3RhdGUuXG4gICAqIFRoaXMgd2lsbCBhbHNvIHJlbW92ZSB0aGUgbGFzdCByZXN1bHQgZnJvbSB0aGUgY2FjaGUuXG4gICAqL1xuICByZXNldDogKCkgPT4gdm9pZDtcbn07XG5cbi8qKlxuICogSGVscGVyIHR5cGUgdG8gbWFudWFsbHkgdHlwZSB0aGUgcmVzdWx0XG4gKiBvZiB0aGUgYHVzZUxhenlRdWVyeWAgaG9vayBpbiB1c2VybGFuZCBjb2RlLlxuICovXG5leHBvcnQgdHlwZSBUeXBlZFVzZUxhenlRdWVyeVN0YXRlUmVzdWx0PFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgUiA9IFVzZVF1ZXJ5U3RhdGVEZWZhdWx0UmVzdWx0PFF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBzdHJpbmcsIFJlc3VsdFR5cGUsIHN0cmluZz4+PiA9IFVzZUxhenlRdWVyeVN0YXRlUmVzdWx0PFF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBzdHJpbmcsIFJlc3VsdFR5cGUsIHN0cmluZz4sIFI+O1xuZXhwb3J0IHR5cGUgTGF6eVF1ZXJ5VHJpZ2dlcjxEIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4+ID0ge1xuICAvKipcbiAgICogVHJpZ2dlcnMgYSBsYXp5IHF1ZXJ5LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIHdpbGwgc3RhcnQgYSBuZXcgcmVxdWVzdCBldmVuIGlmIHRoZXJlIGlzIGFscmVhZHkgYSB2YWx1ZSBpbiB0aGUgY2FjaGUuXG4gICAqIElmIHlvdSB3YW50IHRvIHVzZSB0aGUgY2FjaGUgdmFsdWUgYW5kIG9ubHkgc3RhcnQgYSByZXF1ZXN0IGlmIHRoZXJlIGlzIG5vIGNhY2hlIHZhbHVlLCBzZXQgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgdHJ1ZWAuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgZXJyb3Igb3Igc3VjY2VzcyBwYXlsb2FkIGltbWVkaWF0ZWx5IGFmdGVyIGEgbGF6eSBxdWVyeSwgeW91IGNhbiBjaGFpbiAudW53cmFwKCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIHRpdGxlPVwiVXNpbmcgLnVud3JhcCB3aXRoIGFzeW5jIGF3YWl0XCJcbiAgICogdHJ5IHtcbiAgICogICBjb25zdCBwYXlsb2FkID0gYXdhaXQgZ2V0VXNlckJ5SWQoMSkudW53cmFwKCk7XG4gICAqICAgY29uc29sZS5sb2coJ2Z1bGZpbGxlZCcsIHBheWxvYWQpXG4gICAqIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAqICAgY29uc29sZS5lcnJvcigncmVqZWN0ZWQnLCBlcnJvcik7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICAoYXJnOiBRdWVyeUFyZ0Zyb208RD4sIHByZWZlckNhY2hlVmFsdWU/OiBib29sZWFuKTogUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0PEQ+O1xufTtcbmV4cG9ydCB0eXBlIFR5cGVkTGF6eVF1ZXJ5VHJpZ2dlcjxSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4+ID0gTGF6eVF1ZXJ5VHJpZ2dlcjxRdWVyeURlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSwgc3RyaW5nLCBSZXN1bHRUeXBlLCBzdHJpbmc+PjtcblxuLyoqXG4gKiBBIFJlYWN0IGhvb2sgc2ltaWxhciB0byBbYHVzZVF1ZXJ5U3Vic2NyaXB0aW9uYF0oI3VzZXF1ZXJ5c3Vic2NyaXB0aW9uKSwgYnV0IHdpdGggbWFudWFsIGNvbnRyb2wgb3ZlciB3aGVuIHRoZSBkYXRhIGZldGNoaW5nIG9jY3Vycy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBob29rIGRvZXMgbm90IHJldHVybiBhIHJlcXVlc3Qgc3RhdHVzIG9yIGNhY2hlZCBkYXRhLiBGb3IgdGhhdCB1c2UtY2FzZSwgc2VlIFtgdXNlTGF6eVF1ZXJ5YF0oI3VzZWxhenlxdWVyeSkuXG4gKlxuICogIyMjIyBGZWF0dXJlc1xuICpcbiAqIC0gTWFudWFsIGNvbnRyb2wgb3ZlciBmaXJpbmcgYSByZXF1ZXN0IHRvIHJldHJpZXZlIGRhdGFcbiAqIC0gJ1N1YnNjcmliZXMnIHRoZSBjb21wb25lbnQgdG8ga2VlcCBjYWNoZWQgZGF0YSBpbiB0aGUgc3RvcmUsIGFuZCAndW5zdWJzY3JpYmVzJyB3aGVuIHRoZSBjb21wb25lbnQgdW5tb3VudHNcbiAqIC0gQWNjZXB0cyBwb2xsaW5nL3JlLWZldGNoaW5nIG9wdGlvbnMgdG8gdHJpZ2dlciBhdXRvbWF0aWMgcmUtZmV0Y2hlcyB3aGVuIHRoZSBjb3JyZXNwb25kaW5nIGNyaXRlcmlhIGlzIG1ldCBhbmQgdGhlIGZldGNoIGhhcyBiZWVuIG1hbnVhbGx5IGNhbGxlZCBhdCBsZWFzdCBvbmNlXG4gKi9cbmV4cG9ydCB0eXBlIFVzZUxhenlRdWVyeVN1YnNjcmlwdGlvbjxEIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4+ID0gKG9wdGlvbnM/OiBTdWJzY3JpcHRpb25PcHRpb25zKSA9PiByZWFkb25seSBbTGF6eVF1ZXJ5VHJpZ2dlcjxEPiwgUXVlcnlBcmdGcm9tPEQ+IHwgVW5pbml0aWFsaXplZFZhbHVlLCB7XG4gIHJlc2V0OiAoKSA9PiB2b2lkO1xufV07XG5leHBvcnQgdHlwZSBUeXBlZFVzZUxhenlRdWVyeVN1YnNjcmlwdGlvbjxSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4+ID0gVXNlTGF6eVF1ZXJ5U3Vic2NyaXB0aW9uPFF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBzdHJpbmcsIFJlc3VsdFR5cGUsIHN0cmluZz4+O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdHlwZSBRdWVyeVN0YXRlU2VsZWN0b3I8UiBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sIEQgZXh0ZW5kcyBRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55Pj4gPSAoc3RhdGU6IFVzZVF1ZXJ5U3RhdGVEZWZhdWx0UmVzdWx0PEQ+KSA9PiBSO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIGRlZmluZSBhIHN0cm9uZ2x5LXR5cGVkIHZlcnNpb24gb2ZcbiAqIHtAbGlua2NvZGUgUXVlcnlTdGF0ZVNlbGVjdG9yfSBmb3IgdXNlIHdpdGggYSBzcGVjaWZpYyBxdWVyeS5cbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBzY2VuYXJpb3Mgd2hlcmUgeW91IHdhbnQgdG8gY3JlYXRlIGEgXCJwcmUtdHlwZWRcIlxuICoge0BsaW5rY29kZSBVc2VRdWVyeVN0YXRlT3B0aW9ucy5zZWxlY3RGcm9tUmVzdWx0IHwgc2VsZWN0RnJvbVJlc3VsdH1cbiAqIGZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiA8Y2FwdGlvbj4jIyMjIF9fQ3JlYXRlIGEgc3Ryb25nbHktdHlwZWQgYHNlbGVjdEZyb21SZXN1bHRgIHNlbGVjdG9yIGZ1bmN0aW9uX188L2NhcHRpb24+XG4gKlxuICogYGBgdHN4XG4gKiBpbXBvcnQgdHlwZSB7IFR5cGVkUXVlcnlTdGF0ZVNlbGVjdG9yIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeS9yZWFjdCdcbiAqIGltcG9ydCB7IGNyZWF0ZUFwaSwgZmV0Y2hCYXNlUXVlcnkgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5L3JlYWN0J1xuICpcbiAqIHR5cGUgUG9zdCA9IHtcbiAqICAgaWQ6IG51bWJlclxuICogICB0aXRsZTogc3RyaW5nXG4gKiB9XG4gKlxuICogdHlwZSBQb3N0c0FwaVJlc3BvbnNlID0ge1xuICogICBwb3N0czogUG9zdFtdXG4gKiAgIHRvdGFsOiBudW1iZXJcbiAqICAgc2tpcDogbnVtYmVyXG4gKiAgIGxpbWl0OiBudW1iZXJcbiAqIH1cbiAqXG4gKiB0eXBlIFF1ZXJ5QXJndW1lbnQgPSBudW1iZXIgfCB1bmRlZmluZWRcbiAqXG4gKiB0eXBlIEJhc2VRdWVyeUZ1bmN0aW9uID0gUmV0dXJuVHlwZTx0eXBlb2YgZmV0Y2hCYXNlUXVlcnk+XG4gKlxuICogdHlwZSBTZWxlY3RlZFJlc3VsdCA9IFBpY2s8UG9zdHNBcGlSZXNwb25zZSwgJ3Bvc3RzJz5cbiAqXG4gKiBjb25zdCBwb3N0c0FwaVNsaWNlID0gY3JlYXRlQXBpKHtcbiAqICAgYmFzZVF1ZXJ5OiBmZXRjaEJhc2VRdWVyeSh7IGJhc2VVcmw6ICdodHRwczovL2R1bW15anNvbi5jb20vcG9zdHMnIH0pLFxuICogICByZWR1Y2VyUGF0aDogJ3Bvc3RzQXBpJyxcbiAqICAgdGFnVHlwZXM6IFsnUG9zdHMnXSxcbiAqICAgZW5kcG9pbnRzOiAoYnVpbGQpID0+ICh7XG4gKiAgICAgZ2V0UG9zdHM6IGJ1aWxkLnF1ZXJ5PFBvc3RzQXBpUmVzcG9uc2UsIFF1ZXJ5QXJndW1lbnQ+KHtcbiAqICAgICAgIHF1ZXJ5OiAobGltaXQgPSA1KSA9PiBgP2xpbWl0PSR7bGltaXR9JnNlbGVjdD10aXRsZWAsXG4gKiAgICAgfSksXG4gKiAgIH0pLFxuICogfSlcbiAqXG4gKiBjb25zdCB7IHVzZUdldFBvc3RzUXVlcnkgfSA9IHBvc3RzQXBpU2xpY2VcbiAqXG4gKiBmdW5jdGlvbiBQb3N0QnlJZCh7IGlkIH06IHsgaWQ6IG51bWJlciB9KSB7XG4gKiAgIGNvbnN0IHsgcG9zdCB9ID0gdXNlR2V0UG9zdHNRdWVyeSh1bmRlZmluZWQsIHtcbiAqICAgICBzZWxlY3RGcm9tUmVzdWx0OiAoc3RhdGUpID0+ICh7XG4gKiAgICAgICBwb3N0OiBzdGF0ZS5kYXRhPy5wb3N0cy5maW5kKChwb3N0KSA9PiBwb3N0LmlkID09PSBpZCksXG4gKiAgICAgfSksXG4gKiAgIH0pXG4gKlxuICogICByZXR1cm4gPGxpPntwb3N0Py50aXRsZX08L2xpPlxuICogfVxuICpcbiAqIGNvbnN0IEVNUFRZX0FSUkFZOiBQb3N0W10gPSBbXVxuICpcbiAqIGNvbnN0IHR5cGVkU2VsZWN0RnJvbVJlc3VsdDogVHlwZWRRdWVyeVN0YXRlU2VsZWN0b3I8XG4gKiAgIFBvc3RzQXBpUmVzcG9uc2UsXG4gKiAgIFF1ZXJ5QXJndW1lbnQsXG4gKiAgIEJhc2VRdWVyeUZ1bmN0aW9uLFxuICogICBTZWxlY3RlZFJlc3VsdFxuICogPiA9IChzdGF0ZSkgPT4gKHsgcG9zdHM6IHN0YXRlLmRhdGE/LnBvc3RzID8/IEVNUFRZX0FSUkFZIH0pXG4gKlxuICogZnVuY3Rpb24gUG9zdHNMaXN0KCkge1xuICogICBjb25zdCB7IHBvc3RzIH0gPSB1c2VHZXRQb3N0c1F1ZXJ5KHVuZGVmaW5lZCwge1xuICogICAgIHNlbGVjdEZyb21SZXN1bHQ6IHR5cGVkU2VsZWN0RnJvbVJlc3VsdCxcbiAqICAgfSlcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGRpdj5cbiAqICAgICAgIDx1bD5cbiAqICAgICAgICAge3Bvc3RzLm1hcCgocG9zdCkgPT4gKFxuICogICAgICAgICAgIDxQb3N0QnlJZCBrZXk9e3Bvc3QuaWR9IGlkPXtwb3N0LmlkfSAvPlxuICogICAgICAgICApKX1cbiAqICAgICAgIDwvdWw+XG4gKiAgICAgPC9kaXY+XG4gKiAgIClcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEB0ZW1wbGF0ZSBSZXN1bHRUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJlc3VsdCBgZGF0YWAgcmV0dXJuZWQgYnkgdGhlIHF1ZXJ5LlxuICogQHRlbXBsYXRlIFF1ZXJ5QXJndW1lbnRUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIGFyZ3VtZW50IHBhc3NlZCBpbnRvIHRoZSBxdWVyeS5cbiAqIEB0ZW1wbGF0ZSBCYXNlUXVlcnlGdW5jdGlvblR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgYmFzZSBxdWVyeSBmdW5jdGlvbiBiZWluZyB1c2VkLlxuICogQHRlbXBsYXRlIFNlbGVjdGVkUmVzdWx0VHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBzZWxlY3RlZCByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIF9fYHNlbGVjdEZyb21SZXN1bHRgX18gZnVuY3Rpb24uXG4gKlxuICogQHNpbmNlIDIuMy4wXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFR5cGVkUXVlcnlTdGF0ZVNlbGVjdG9yPFJlc3VsdFR5cGUsIFF1ZXJ5QXJndW1lbnRUeXBlLCBCYXNlUXVlcnlGdW5jdGlvblR5cGUgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgU2VsZWN0ZWRSZXN1bHRUeXBlIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiA9IFVzZVF1ZXJ5U3RhdGVEZWZhdWx0UmVzdWx0PFF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZ3VtZW50VHlwZSwgQmFzZVF1ZXJ5RnVuY3Rpb25UeXBlLCBzdHJpbmcsIFJlc3VsdFR5cGUsIHN0cmluZz4+PiA9IFF1ZXJ5U3RhdGVTZWxlY3RvcjxTZWxlY3RlZFJlc3VsdFR5cGUsIFF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZ3VtZW50VHlwZSwgQmFzZVF1ZXJ5RnVuY3Rpb25UeXBlLCBzdHJpbmcsIFJlc3VsdFR5cGUsIHN0cmluZz4+O1xuXG4vKipcbiAqIEEgUmVhY3QgaG9vayB0aGF0IHJlYWRzIHRoZSByZXF1ZXN0IHN0YXR1cyBhbmQgY2FjaGVkIGRhdGEgZnJvbSB0aGUgUmVkdXggc3RvcmUuIFRoZSBjb21wb25lbnQgd2lsbCByZS1yZW5kZXIgYXMgdGhlIGxvYWRpbmcgc3RhdHVzIGNoYW5nZXMgYW5kIHRoZSBkYXRhIGJlY29tZXMgYXZhaWxhYmxlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGhvb2sgZG9lcyBub3QgdHJpZ2dlciBmZXRjaGluZyBuZXcgZGF0YS4gRm9yIHRoYXQgdXNlLWNhc2UsIHNlZSBbYHVzZVF1ZXJ5YF0oI3VzZXF1ZXJ5KSBvciBbYHVzZVF1ZXJ5U3Vic2NyaXB0aW9uYF0oI3VzZXF1ZXJ5c3Vic2NyaXB0aW9uKS5cbiAqXG4gKiAjIyMjIEZlYXR1cmVzXG4gKlxuICogLSBSZXR1cm5zIHRoZSBsYXRlc3QgcmVxdWVzdCBzdGF0dXMgYW5kIGNhY2hlZCBkYXRhIGZyb20gdGhlIFJlZHV4IHN0b3JlXG4gKiAtIFJlLXJlbmRlcnMgYXMgdGhlIHJlcXVlc3Qgc3RhdHVzIGNoYW5nZXMgYW5kIGRhdGEgYmVjb21lcyBhdmFpbGFibGVcbiAqL1xuZXhwb3J0IHR5cGUgVXNlUXVlcnlTdGF0ZTxEIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4+ID0gPFIgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gVXNlUXVlcnlTdGF0ZURlZmF1bHRSZXN1bHQ8RD4+KGFyZzogUXVlcnlBcmdGcm9tPEQ+IHwgU2tpcFRva2VuLCBvcHRpb25zPzogVXNlUXVlcnlTdGF0ZU9wdGlvbnM8RCwgUj4pID0+IFVzZVF1ZXJ5U3RhdGVSZXN1bHQ8RCwgUj47XG5leHBvcnQgdHlwZSBUeXBlZFVzZVF1ZXJ5U3RhdGU8UmVzdWx0VHlwZSwgUXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuPiA9IFVzZVF1ZXJ5U3RhdGU8UXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBCYXNlUXVlcnksIHN0cmluZywgUmVzdWx0VHlwZSwgc3RyaW5nPj47XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCB0eXBlIFVzZVF1ZXJ5U3RhdGVPcHRpb25zPEQgZXh0ZW5kcyBRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55PiwgUiBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4+ID0ge1xuICAvKipcbiAgICogUHJldmVudHMgYSBxdWVyeSBmcm9tIGF1dG9tYXRpY2FsbHkgcnVubmluZy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogV2hlbiBza2lwIGlzIHRydWU6XG4gICAqXG4gICAqIC0gKipJZiB0aGUgcXVlcnkgaGFzIGNhY2hlZCBkYXRhOioqXG4gICAqICAgKiBUaGUgY2FjaGVkIGRhdGEgKip3aWxsIG5vdCBiZSB1c2VkKiogb24gdGhlIGluaXRpYWwgbG9hZCwgYW5kIHdpbGwgaWdub3JlIHVwZGF0ZXMgZnJvbSBhbnkgaWRlbnRpY2FsIHF1ZXJ5IHVudGlsIHRoZSBgc2tpcGAgY29uZGl0aW9uIGlzIHJlbW92ZWRcbiAgICogICAqIFRoZSBxdWVyeSB3aWxsIGhhdmUgYSBzdGF0dXMgb2YgYHVuaW5pdGlhbGl6ZWRgXG4gICAqICAgKiBJZiBgc2tpcDogZmFsc2VgIGlzIHNldCBhZnRlciBza2lwcGluZyB0aGUgaW5pdGlhbCBsb2FkLCB0aGUgY2FjaGVkIHJlc3VsdCB3aWxsIGJlIHVzZWRcbiAgICogLSAqKklmIHRoZSBxdWVyeSBkb2VzIG5vdCBoYXZlIGNhY2hlZCBkYXRhOioqXG4gICAqICAgKiBUaGUgcXVlcnkgd2lsbCBoYXZlIGEgc3RhdHVzIG9mIGB1bmluaXRpYWxpemVkYFxuICAgKiAgICogVGhlIHF1ZXJ5IHdpbGwgbm90IGV4aXN0IGluIHRoZSBzdGF0ZSB3aGVuIHZpZXdlZCB3aXRoIHRoZSBkZXYgdG9vbHNcbiAgICogICAqIFRoZSBxdWVyeSB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IGZldGNoIG9uIG1vdW50XG4gICAqICAgKiBUaGUgcXVlcnkgd2lsbCBub3QgYXV0b21hdGljYWxseSBydW4gd2hlbiBhZGRpdGlvbmFsIGNvbXBvbmVudHMgd2l0aCB0aGUgc2FtZSBxdWVyeSBhcmUgYWRkZWQgdGhhdCBkbyBydW5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgdGl0bGU9XCJTa2lwIGV4YW1wbGVcIlxuICAgKiBjb25zdCBQb2tlbW9uID0gKHsgbmFtZSwgc2tpcCB9OiB7IG5hbWU6IHN0cmluZzsgc2tpcDogYm9vbGVhbiB9KSA9PiB7XG4gICAqICAgY29uc3QgeyBkYXRhLCBlcnJvciwgc3RhdHVzIH0gPSB1c2VHZXRQb2tlbW9uQnlOYW1lUXVlcnkobmFtZSwge1xuICAgKiAgICAgc2tpcCxcbiAgICogICB9KTtcbiAgICpcbiAgICogICByZXR1cm4gKFxuICAgKiAgICAgPGRpdj5cbiAgICogICAgICAge25hbWV9IC0ge3N0YXR1c31cbiAgICogICAgIDwvZGl2PlxuICAgKiAgICk7XG4gICAqIH07XG4gICAqIGBgYFxuICAgKi9cbiAgc2tpcD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBgc2VsZWN0RnJvbVJlc3VsdGAgYWxsb3dzIHlvdSB0byBnZXQgYSBzcGVjaWZpYyBzZWdtZW50IGZyb20gYSBxdWVyeSByZXN1bHQgaW4gYSBwZXJmb3JtYW50IG1hbm5lci5cbiAgICogV2hlbiB1c2luZyB0aGlzIGZlYXR1cmUsIHRoZSBjb21wb25lbnQgd2lsbCBub3QgcmVyZW5kZXIgdW5sZXNzIHRoZSB1bmRlcmx5aW5nIGRhdGEgb2YgdGhlIHNlbGVjdGVkIGl0ZW0gaGFzIGNoYW5nZWQuXG4gICAqIElmIHRoZSBzZWxlY3RlZCBpdGVtIGlzIG9uZSBlbGVtZW50IGluIGEgbGFyZ2VyIGNvbGxlY3Rpb24sIGl0IHdpbGwgZGlzcmVnYXJkIGNoYW5nZXMgdG8gZWxlbWVudHMgaW4gdGhlIHNhbWUgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgdGl0bGU9XCJVc2luZyBzZWxlY3RGcm9tUmVzdWx0IHRvIGV4dHJhY3QgYSBzaW5nbGUgcmVzdWx0XCJcbiAgICogZnVuY3Rpb24gUG9zdHNMaXN0KCkge1xuICAgKiAgIGNvbnN0IHsgZGF0YTogcG9zdHMgfSA9IGFwaS51c2VHZXRQb3N0c1F1ZXJ5KCk7XG4gICAqXG4gICAqICAgcmV0dXJuIChcbiAgICogICAgIDx1bD5cbiAgICogICAgICAge3Bvc3RzPy5kYXRhPy5tYXAoKHBvc3QpID0+IChcbiAgICogICAgICAgICA8UG9zdEJ5SWQga2V5PXtwb3N0LmlkfSBpZD17cG9zdC5pZH0gLz5cbiAgICogICAgICAgKSl9XG4gICAqICAgICA8L3VsPlxuICAgKiAgICk7XG4gICAqIH1cbiAgICpcbiAgICogZnVuY3Rpb24gUG9zdEJ5SWQoeyBpZCB9OiB7IGlkOiBudW1iZXIgfSkge1xuICAgKiAgIC8vIFdpbGwgc2VsZWN0IHRoZSBwb3N0IHdpdGggdGhlIGdpdmVuIGlkLCBhbmQgd2lsbCBvbmx5IHJlcmVuZGVyIGlmIHRoZSBnaXZlbiBwb3N0cyBkYXRhIGNoYW5nZXNcbiAgICogICBjb25zdCB7IHBvc3QgfSA9IGFwaS51c2VHZXRQb3N0c1F1ZXJ5KHVuZGVmaW5lZCwge1xuICAgKiAgICAgc2VsZWN0RnJvbVJlc3VsdDogKHsgZGF0YSB9KSA9PiAoeyBwb3N0OiBkYXRhPy5maW5kKChwb3N0KSA9PiBwb3N0LmlkID09PSBpZCkgfSksXG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgcmV0dXJuIDxsaT57cG9zdD8ubmFtZX08L2xpPjtcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIHNlbGVjdEZyb21SZXN1bHQ/OiBRdWVyeVN0YXRlU2VsZWN0b3I8UiwgRD47XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIGRlZmluZSBhIFwicHJlLXR5cGVkXCIgdmVyc2lvbiBvZlxuICoge0BsaW5rY29kZSBVc2VRdWVyeVN0YXRlT3B0aW9uc30gd2l0aCBzcGVjaWZpYyBvcHRpb25zIGZvciBhIGdpdmVuIHF1ZXJ5LlxuICogVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBzZXR0aW5nIGRlZmF1bHQgcXVlcnkgYmVoYXZpb3JzIHN1Y2ggYXNcbiAqIHJlZmV0Y2hpbmcgc3RyYXRlZ2llcywgd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gYXMgbmVlZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiA8Y2FwdGlvbj4jIyMjIF9fQ3JlYXRlIGEgYHVzZVF1ZXJ5YCBob29rIHdpdGggZGVmYXVsdCBvcHRpb25zX188L2NhcHRpb24+XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB0eXBlIHtcbiAqICAgU3Vic2NyaXB0aW9uT3B0aW9ucyxcbiAqICAgVHlwZWRVc2VRdWVyeVN0YXRlT3B0aW9ucyxcbiAqIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeS9yZWFjdCdcbiAqIGltcG9ydCB7IGNyZWF0ZUFwaSwgZmV0Y2hCYXNlUXVlcnkgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5L3JlYWN0J1xuICpcbiAqIHR5cGUgUG9zdCA9IHtcbiAqICAgaWQ6IG51bWJlclxuICogICBuYW1lOiBzdHJpbmdcbiAqIH1cbiAqXG4gKiBjb25zdCBhcGkgPSBjcmVhdGVBcGkoe1xuICogICBiYXNlUXVlcnk6IGZldGNoQmFzZVF1ZXJ5KHsgYmFzZVVybDogJy8nIH0pLFxuICogICB0YWdUeXBlczogWydQb3N0J10sXG4gKiAgIGVuZHBvaW50czogKGJ1aWxkKSA9PiAoe1xuICogICAgIGdldFBvc3RzOiBidWlsZC5xdWVyeTxQb3N0W10sIHZvaWQ+KHtcbiAqICAgICAgIHF1ZXJ5OiAoKSA9PiAncG9zdHMnLFxuICogICAgIH0pLFxuICogICB9KSxcbiAqIH0pXG4gKlxuICogY29uc3QgeyB1c2VHZXRQb3N0c1F1ZXJ5IH0gPSBhcGlcbiAqXG4gKiBleHBvcnQgY29uc3QgdXNlR2V0UG9zdHNRdWVyeVdpdGhEZWZhdWx0cyA9IDxcbiAqICAgU2VsZWN0ZWRSZXN1bHQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICogPihcbiAqICAgb3ZlcnJpZGVPcHRpb25zOiBUeXBlZFVzZVF1ZXJ5U3RhdGVPcHRpb25zPFxuICogICAgIFBvc3RbXSxcbiAqICAgICB2b2lkLFxuICogICAgIFJldHVyblR5cGU8dHlwZW9mIGZldGNoQmFzZVF1ZXJ5PixcbiAqICAgICBTZWxlY3RlZFJlc3VsdFxuICogICA+ICZcbiAqICAgICBTdWJzY3JpcHRpb25PcHRpb25zLFxuICogKSA9PlxuICogICB1c2VHZXRQb3N0c1F1ZXJ5KHVuZGVmaW5lZCwge1xuICogICAgIC8vIEluc2VydCBkZWZhdWx0IG9wdGlvbnMgaGVyZVxuICpcbiAqICAgICByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlOiB0cnVlLFxuICogICAgIHJlZmV0Y2hPbkZvY3VzOiB0cnVlLFxuICogICAgIC4uLm92ZXJyaWRlT3B0aW9ucyxcbiAqICAgfSlcbiAqIGBgYFxuICpcbiAqIEB0ZW1wbGF0ZSBSZXN1bHRUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHJlc3VsdCBgZGF0YWAgcmV0dXJuZWQgYnkgdGhlIHF1ZXJ5LlxuICogQHRlbXBsYXRlIFF1ZXJ5QXJnIC0gVGhlIHR5cGUgb2YgdGhlIGFyZ3VtZW50IHBhc3NlZCBpbnRvIHRoZSBxdWVyeS5cbiAqIEB0ZW1wbGF0ZSBCYXNlUXVlcnkgLSBUaGUgdHlwZSBvZiB0aGUgYmFzZSBxdWVyeSBmdW5jdGlvbiBiZWluZyB1c2VkLlxuICogQHRlbXBsYXRlIFNlbGVjdGVkUmVzdWx0IC0gVGhlIHR5cGUgb2YgdGhlIHNlbGVjdGVkIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgX19gc2VsZWN0RnJvbVJlc3VsdGBfXyBmdW5jdGlvbi5cbiAqXG4gKiBAc2luY2UgMi4yLjhcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgVHlwZWRVc2VRdWVyeVN0YXRlT3B0aW9uczxSZXN1bHRUeXBlLCBRdWVyeUFyZywgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4sIFNlbGVjdGVkUmVzdWx0IGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiA9IFVzZVF1ZXJ5U3RhdGVEZWZhdWx0UmVzdWx0PFF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBzdHJpbmcsIFJlc3VsdFR5cGUsIHN0cmluZz4+PiA9IFVzZVF1ZXJ5U3RhdGVPcHRpb25zPFF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBzdHJpbmcsIFJlc3VsdFR5cGUsIHN0cmluZz4sIFNlbGVjdGVkUmVzdWx0PjtcbmV4cG9ydCB0eXBlIFVzZVF1ZXJ5U3RhdGVSZXN1bHQ8XyBleHRlbmRzIFF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+LCBSPiA9IFRTSGVscGVyc05vSW5mZXI8Uj47XG5cbi8qKlxuICogSGVscGVyIHR5cGUgdG8gbWFudWFsbHkgdHlwZSB0aGUgcmVzdWx0XG4gKiBvZiB0aGUgYHVzZVF1ZXJ5U3RhdGVgIGhvb2sgaW4gdXNlcmxhbmQgY29kZS5cbiAqL1xuZXhwb3J0IHR5cGUgVHlwZWRVc2VRdWVyeVN0YXRlUmVzdWx0PFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgUiA9IFVzZVF1ZXJ5U3RhdGVEZWZhdWx0UmVzdWx0PFF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBzdHJpbmcsIFJlc3VsdFR5cGUsIHN0cmluZz4+PiA9IFRTSGVscGVyc05vSW5mZXI8Uj47XG50eXBlIFVzZVF1ZXJ5U3RhdGVCYXNlUmVzdWx0PEQgZXh0ZW5kcyBRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55Pj4gPSBRdWVyeVN1YlN0YXRlPEQ+ICYge1xuICAvKipcbiAgICogV2hlcmUgYGRhdGFgIHRyaWVzIHRvIGhvbGQgZGF0YSBhcyBtdWNoIGFzIHBvc3NpYmxlLCBhbHNvIHJlLXVzaW5nXG4gICAqIGRhdGEgZnJvbSB0aGUgbGFzdCBhcmd1bWVudHMgcGFzc2VkIGludG8gdGhlIGhvb2ssIHRoaXMgcHJvcGVydHlcbiAgICogd2lsbCBhbHdheXMgY29udGFpbiB0aGUgcmVjZWl2ZWQgZGF0YSBmcm9tIHRoZSBxdWVyeSwgZm9yIHRoZSBjdXJyZW50IHF1ZXJ5IGFyZ3VtZW50cy5cbiAgICovXG4gIGN1cnJlbnREYXRhPzogUmVzdWx0VHlwZUZyb208RD47XG4gIC8qKlxuICAgKiBRdWVyeSBoYXMgbm90IHN0YXJ0ZWQgeWV0LlxuICAgKi9cbiAgaXNVbmluaXRpYWxpemVkOiBmYWxzZTtcbiAgLyoqXG4gICAqIFF1ZXJ5IGlzIGN1cnJlbnRseSBsb2FkaW5nIGZvciB0aGUgZmlyc3QgdGltZS4gTm8gZGF0YSB5ZXQuXG4gICAqL1xuICBpc0xvYWRpbmc6IGZhbHNlO1xuICAvKipcbiAgICogUXVlcnkgaXMgY3VycmVudGx5IGZldGNoaW5nLCBidXQgbWlnaHQgaGF2ZSBkYXRhIGZyb20gYW4gZWFybGllciByZXF1ZXN0LlxuICAgKi9cbiAgaXNGZXRjaGluZzogZmFsc2U7XG4gIC8qKlxuICAgKiBRdWVyeSBoYXMgZGF0YSBmcm9tIGEgc3VjY2Vzc2Z1bCBsb2FkLlxuICAgKi9cbiAgaXNTdWNjZXNzOiBmYWxzZTtcbiAgLyoqXG4gICAqIFF1ZXJ5IGlzIGN1cnJlbnRseSBpbiBcImVycm9yXCIgc3RhdGUuXG4gICAqL1xuICBpc0Vycm9yOiBmYWxzZTtcbn07XG50eXBlIFVzZVF1ZXJ5U3RhdGVEZWZhdWx0UmVzdWx0PEQgZXh0ZW5kcyBRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55Pj4gPSBUU0hlbHBlcnNJZDxUU0hlbHBlcnNPdmVycmlkZTxFeHRyYWN0PFVzZVF1ZXJ5U3RhdGVCYXNlUmVzdWx0PEQ+LCB7XG4gIHN0YXR1czogUXVlcnlTdGF0dXMudW5pbml0aWFsaXplZDtcbn0+LCB7XG4gIGlzVW5pbml0aWFsaXplZDogdHJ1ZTtcbn0+IHwgVFNIZWxwZXJzT3ZlcnJpZGU8VXNlUXVlcnlTdGF0ZUJhc2VSZXN1bHQ8RD4sIHtcbiAgaXNMb2FkaW5nOiB0cnVlO1xuICBpc0ZldGNoaW5nOiBib29sZWFuO1xuICBkYXRhOiB1bmRlZmluZWQ7XG59IHwgKHtcbiAgaXNTdWNjZXNzOiB0cnVlO1xuICBpc0ZldGNoaW5nOiB0cnVlO1xuICBlcnJvcjogdW5kZWZpbmVkO1xufSAmIFJlcXVpcmVkPFBpY2s8VXNlUXVlcnlTdGF0ZUJhc2VSZXN1bHQ8RD4sICdkYXRhJyB8ICdmdWxmaWxsZWRUaW1lU3RhbXAnPj4pIHwgKHtcbiAgaXNTdWNjZXNzOiB0cnVlO1xuICBpc0ZldGNoaW5nOiBmYWxzZTtcbiAgZXJyb3I6IHVuZGVmaW5lZDtcbn0gJiBSZXF1aXJlZDxQaWNrPFVzZVF1ZXJ5U3RhdGVCYXNlUmVzdWx0PEQ+LCAnZGF0YScgfCAnZnVsZmlsbGVkVGltZVN0YW1wJyB8ICdjdXJyZW50RGF0YSc+PikgfCAoe1xuICBpc0Vycm9yOiB0cnVlO1xufSAmIFJlcXVpcmVkPFBpY2s8VXNlUXVlcnlTdGF0ZUJhc2VSZXN1bHQ8RD4sICdlcnJvcic+Pik+PiAmIHtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIEluY2x1ZGVkIGZvciBjb21wbGV0ZW5lc3MsIGJ1dCBkaXNjb3VyYWdlZC5cbiAgICogUGxlYXNlIHVzZSB0aGUgYGlzTG9hZGluZ2AsIGBpc0ZldGNoaW5nYCwgYGlzU3VjY2Vzc2AsIGBpc0Vycm9yYFxuICAgKiBhbmQgYGlzVW5pbml0aWFsaXplZGAgZmxhZ3MgaW5zdGVhZFxuICAgKi9cbiAgc3RhdHVzOiBRdWVyeVN0YXR1cztcbn07XG5leHBvcnQgdHlwZSBMYXp5SW5maW5pdGVRdWVyeVRyaWdnZXI8RCBleHRlbmRzIEluZmluaXRlUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55Pj4gPSB7XG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhIGxhenkgcXVlcnkuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgd2lsbCBzdGFydCBhIG5ldyByZXF1ZXN0IGV2ZW4gaWYgdGhlcmUgaXMgYWxyZWFkeSBhIHZhbHVlIGluIHRoZSBjYWNoZS5cbiAgICogSWYgeW91IHdhbnQgdG8gdXNlIHRoZSBjYWNoZSB2YWx1ZSBhbmQgb25seSBzdGFydCBhIHJlcXVlc3QgaWYgdGhlcmUgaXMgbm8gY2FjaGUgdmFsdWUsIHNldCB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGB0cnVlYC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBlcnJvciBvciBzdWNjZXNzIHBheWxvYWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYSBsYXp5IHF1ZXJ5LCB5b3UgY2FuIGNoYWluIC51bndyYXAoKS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogLy8gY29kZWJsb2NrLW1ldGEgdGl0bGU9XCJVc2luZyAudW53cmFwIHdpdGggYXN5bmMgYXdhaXRcIlxuICAgKiB0cnkge1xuICAgKiAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCBnZXRVc2VyQnlJZCgxKS51bndyYXAoKTtcbiAgICogICBjb25zb2xlLmxvZygnZnVsZmlsbGVkJywgcGF5bG9hZClcbiAgICogfSBjYXRjaCAoZXJyb3IpIHtcbiAgICogICBjb25zb2xlLmVycm9yKCdyZWplY3RlZCcsIGVycm9yKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIChhcmc6IFF1ZXJ5QXJnRnJvbTxEPiwgZGlyZWN0aW9uOiBJbmZpbml0ZVF1ZXJ5RGlyZWN0aW9uKTogSW5maW5pdGVRdWVyeUFjdGlvbkNyZWF0b3JSZXN1bHQ8RD47XG59O1xuZXhwb3J0IHR5cGUgVHlwZWRMYXp5SW5maW5pdGVRdWVyeVRyaWdnZXI8UmVzdWx0VHlwZSwgUXVlcnlBcmcsIFBhZ2VQYXJhbSwgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4+ID0gTGF6eUluZmluaXRlUXVlcnlUcmlnZ2VyPEluZmluaXRlUXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBQYWdlUGFyYW0sIEJhc2VRdWVyeSwgc3RyaW5nLCBSZXN1bHRUeXBlLCBzdHJpbmc+PjtcbmV4cG9ydCB0eXBlIFVzZUluZmluaXRlUXVlcnlTdWJzY3JpcHRpb25PcHRpb25zPEQgZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4+ID0gU3Vic2NyaXB0aW9uT3B0aW9ucyAmIHtcbiAgLyoqXG4gICAqIFByZXZlbnRzIGEgcXVlcnkgZnJvbSBhdXRvbWF0aWNhbGx5IHJ1bm5pbmcuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFdoZW4gYHNraXBgIGlzIHRydWUgKG9yIGBza2lwVG9rZW5gIGlzIHBhc3NlZCBpbiBhcyBgYXJnYCk6XG4gICAqXG4gICAqIC0gKipJZiB0aGUgcXVlcnkgaGFzIGNhY2hlZCBkYXRhOioqXG4gICAqICAgKiBUaGUgY2FjaGVkIGRhdGEgKip3aWxsIG5vdCBiZSB1c2VkKiogb24gdGhlIGluaXRpYWwgbG9hZCwgYW5kIHdpbGwgaWdub3JlIHVwZGF0ZXMgZnJvbSBhbnkgaWRlbnRpY2FsIHF1ZXJ5IHVudGlsIHRoZSBgc2tpcGAgY29uZGl0aW9uIGlzIHJlbW92ZWRcbiAgICogICAqIFRoZSBxdWVyeSB3aWxsIGhhdmUgYSBzdGF0dXMgb2YgYHVuaW5pdGlhbGl6ZWRgXG4gICAqICAgKiBJZiBgc2tpcDogZmFsc2VgIGlzIHNldCBhZnRlciB0aGUgaW5pdGlhbCBsb2FkLCB0aGUgY2FjaGVkIHJlc3VsdCB3aWxsIGJlIHVzZWRcbiAgICogLSAqKklmIHRoZSBxdWVyeSBkb2VzIG5vdCBoYXZlIGNhY2hlZCBkYXRhOioqXG4gICAqICAgKiBUaGUgcXVlcnkgd2lsbCBoYXZlIGEgc3RhdHVzIG9mIGB1bmluaXRpYWxpemVkYFxuICAgKiAgICogVGhlIHF1ZXJ5IHdpbGwgbm90IGV4aXN0IGluIHRoZSBzdGF0ZSB3aGVuIHZpZXdlZCB3aXRoIHRoZSBkZXYgdG9vbHNcbiAgICogICAqIFRoZSBxdWVyeSB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IGZldGNoIG9uIG1vdW50XG4gICAqICAgKiBUaGUgcXVlcnkgd2lsbCBub3QgYXV0b21hdGljYWxseSBydW4gd2hlbiBhZGRpdGlvbmFsIGNvbXBvbmVudHMgd2l0aCB0aGUgc2FtZSBxdWVyeSBhcmUgYWRkZWQgdGhhdCBkbyBydW5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHN4XG4gICAqIC8vIGNvZGVibG9jay1tZXRhIG5vLXRyYW5zcGlsZSB0aXRsZT1cIlNraXAgZXhhbXBsZVwiXG4gICAqIGNvbnN0IFBva2Vtb24gPSAoeyBuYW1lLCBza2lwIH06IHsgbmFtZTogc3RyaW5nOyBza2lwOiBib29sZWFuIH0pID0+IHtcbiAgICogICBjb25zdCB7IGRhdGEsIGVycm9yLCBzdGF0dXMgfSA9IHVzZUdldFBva2Vtb25CeU5hbWVRdWVyeShuYW1lLCB7XG4gICAqICAgICBza2lwLFxuICAgKiAgIH0pO1xuICAgKlxuICAgKiAgIHJldHVybiAoXG4gICAqICAgICA8ZGl2PlxuICAgKiAgICAgICB7bmFtZX0gLSB7c3RhdHVzfVxuICAgKiAgICAgPC9kaXY+XG4gICAqICAgKTtcbiAgICogfTtcbiAgICogYGBgXG4gICAqL1xuICBza2lwPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuIFRoaXMgc2V0dGluZyBhbGxvd3MgeW91IHRvIGNvbnRyb2wgd2hldGhlciBpZiBhIGNhY2hlZCByZXN1bHQgaXMgYWxyZWFkeSBhdmFpbGFibGUsIFJUSyBRdWVyeSB3aWxsIG9ubHkgc2VydmUgYSBjYWNoZWQgcmVzdWx0LCBvciBpZiBpdCBzaG91bGQgYHJlZmV0Y2hgIHdoZW4gc2V0IHRvIGB0cnVlYCBvciBpZiBhbiBhZGVxdWF0ZSBhbW91bnQgb2YgdGltZSBoYXMgcGFzc2VkIHNpbmNlIHRoZSBsYXN0IHN1Y2Nlc3NmdWwgcXVlcnkgcmVzdWx0LlxuICAgKiAtIGBmYWxzZWAgLSBXaWxsIG5vdCBjYXVzZSBhIHF1ZXJ5IHRvIGJlIHBlcmZvcm1lZCBfdW5sZXNzXyBpdCBkb2VzIG5vdCBleGlzdCB5ZXQuXG4gICAqIC0gYHRydWVgIC0gV2lsbCBhbHdheXMgcmVmZXRjaCB3aGVuIGEgbmV3IHN1YnNjcmliZXIgdG8gYSBxdWVyeSBpcyBhZGRlZC4gQmVoYXZlcyB0aGUgc2FtZSBhcyBjYWxsaW5nIHRoZSBgcmVmZXRjaGAgY2FsbGJhY2sgb3IgcGFzc2luZyBgZm9yY2VSZWZldGNoOiB0cnVlYCBpbiB0aGUgYWN0aW9uIGNyZWF0b3IuXG4gICAqIC0gYG51bWJlcmAgLSAqKlZhbHVlIGlzIGluIHNlY29uZHMqKi4gSWYgYSBudW1iZXIgaXMgcHJvdmlkZWQgYW5kIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHF1ZXJ5IGluIHRoZSBjYWNoZSwgaXQgd2lsbCBjb21wYXJlIHRoZSBjdXJyZW50IHRpbWUgdnMgdGhlIGxhc3QgZnVsZmlsbGVkIHRpbWVzdGFtcCwgYW5kIG9ubHkgcmVmZXRjaCBpZiBlbm91Z2ggdGltZSBoYXMgZWxhcHNlZC5cbiAgICpcbiAgICogSWYgeW91IHNwZWNpZnkgdGhpcyBvcHRpb24gYWxvbmdzaWRlIGBza2lwOiB0cnVlYCwgdGhpcyAqKndpbGwgbm90IGJlIGV2YWx1YXRlZCoqIHVudGlsIGBza2lwYCBpcyBmYWxzZS5cbiAgICovXG4gIHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2U/OiBib29sZWFuIHwgbnVtYmVyO1xuICBpbml0aWFsUGFnZVBhcmFtPzogUGFnZVBhcmFtRnJvbTxEPjtcbn07XG5leHBvcnQgdHlwZSBUeXBlZFVzZUluZmluaXRlUXVlcnlTdWJzY3JpcHRpb248UmVzdWx0VHlwZSwgUXVlcnlBcmcsIFBhZ2VQYXJhbSwgQmFzZVF1ZXJ5IGV4dGVuZHMgQmFzZVF1ZXJ5Rm4+ID0gVXNlSW5maW5pdGVRdWVyeVN1YnNjcmlwdGlvbjxJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnksIHN0cmluZywgUmVzdWx0VHlwZSwgc3RyaW5nPj47XG5leHBvcnQgdHlwZSBVc2VJbmZpbml0ZVF1ZXJ5U3Vic2NyaXB0aW9uUmVzdWx0PEQgZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4+ID0gUGljazxJbmZpbml0ZVF1ZXJ5QWN0aW9uQ3JlYXRvclJlc3VsdDxEPiwgJ3JlZmV0Y2gnPiAmIHtcbiAgdHJpZ2dlcjogTGF6eUluZmluaXRlUXVlcnlUcmlnZ2VyPEQ+O1xuICBmZXRjaE5leHRQYWdlOiAoKSA9PiBJbmZpbml0ZVF1ZXJ5QWN0aW9uQ3JlYXRvclJlc3VsdDxEPjtcbiAgZmV0Y2hQcmV2aW91c1BhZ2U6ICgpID0+IEluZmluaXRlUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0PEQ+O1xufTtcblxuLyoqXG4gKiBIZWxwZXIgdHlwZSB0byBtYW51YWxseSB0eXBlIHRoZSByZXN1bHRcbiAqIG9mIHRoZSBgdXNlUXVlcnlTdWJzY3JpcHRpb25gIGhvb2sgaW4gdXNlcmxhbmQgY29kZS5cbiAqL1xuZXhwb3J0IHR5cGUgVHlwZWRVc2VJbmZpbml0ZVF1ZXJ5U3Vic2NyaXB0aW9uUmVzdWx0PFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBQYWdlUGFyYW0sIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuPiA9IFVzZUluZmluaXRlUXVlcnlTdWJzY3JpcHRpb25SZXN1bHQ8SW5maW5pdGVRdWVyeURlZmluaXRpb248UXVlcnlBcmcsIFBhZ2VQYXJhbSwgQmFzZVF1ZXJ5LCBzdHJpbmcsIFJlc3VsdFR5cGUsIHN0cmluZz4+O1xuZXhwb3J0IHR5cGUgSW5maW5pdGVRdWVyeVN0YXRlU2VsZWN0b3I8UiBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sIEQgZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4+ID0gKHN0YXRlOiBVc2VJbmZpbml0ZVF1ZXJ5U3RhdGVEZWZhdWx0UmVzdWx0PEQ+KSA9PiBSO1xuZXhwb3J0IHR5cGUgVHlwZWRJbmZpbml0ZVF1ZXJ5U3RhdGVTZWxlY3RvcjxSZXN1bHRUeXBlLCBRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgU2VsZWN0ZWRSZXN1bHQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gVXNlSW5maW5pdGVRdWVyeVN0YXRlRGVmYXVsdFJlc3VsdDxJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnksIHN0cmluZywgUmVzdWx0VHlwZSwgc3RyaW5nPj4+ID0gSW5maW5pdGVRdWVyeVN0YXRlU2VsZWN0b3I8U2VsZWN0ZWRSZXN1bHQsIEluZmluaXRlUXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBQYWdlUGFyYW0sIEJhc2VRdWVyeSwgc3RyaW5nLCBSZXN1bHRUeXBlLCBzdHJpbmc+PjtcblxuLyoqXG4gKiBBIFJlYWN0IGhvb2sgdGhhdCBhdXRvbWF0aWNhbGx5IHRyaWdnZXJzIGZldGNoZXMgb2YgZGF0YSBmcm9tIGFuIGVuZHBvaW50LCAnc3Vic2NyaWJlcycgdGhlIGNvbXBvbmVudCB0byB0aGUgY2FjaGVkIGRhdGEsIGFuZCByZWFkcyB0aGUgcmVxdWVzdCBzdGF0dXMgYW5kIGNhY2hlZCBkYXRhIGZyb20gdGhlIFJlZHV4IHN0b3JlLiBUaGUgY29tcG9uZW50IHdpbGwgcmUtcmVuZGVyIGFzIHRoZSBsb2FkaW5nIHN0YXR1cyBjaGFuZ2VzIGFuZCB0aGUgZGF0YSBiZWNvbWVzIGF2YWlsYWJsZS4gIEFkZGl0aW9uYWxseSwgaXQgd2lsbCBjYWNoZSBtdWx0aXBsZSBcInBhZ2VzXCIgd29ydGggb2YgcmVzcG9uc2VzIHdpdGhpbiBhIHNpbmdsZSBjYWNoZSBlbnRyeSwgYW5kIGFsbG93cyBmZXRjaGluZyBtb3JlIHBhZ2VzIGZvcndhcmRzIGFuZCBiYWNrd2FyZHMgZnJvbSB0aGUgY3VycmVudCBjYWNoZWQgcGFnZXMuXG4gKlxuICogVGhlIHF1ZXJ5IGFyZyBpcyB1c2VkIGFzIGEgY2FjaGUga2V5LiBDaGFuZ2luZyB0aGUgcXVlcnkgYXJnIHdpbGwgdGVsbCB0aGUgaG9vayB0byByZS1mZXRjaCB0aGUgZGF0YSBpZiBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2FjaGUgYWxyZWFkeSwgYW5kIHRoZSBob29rIHdpbGwgcmV0dXJuIHRoZSBkYXRhIGZvciB0aGF0IHF1ZXJ5IGFyZyBvbmNlIGl0J3MgYXZhaWxhYmxlLlxuICpcbiAqICBUaGUgYGRhdGFgIGZpZWxkIHdpbGwgYmUgYSBge3BhZ2VzOiBEYXRhW10sIHBhZ2VQYXJhbXM6IFBhZ2VQYXJhbVtdfWAgc3RydWN0dXJlIGNvbnRhaW5pbmcgYWxsIGZldGNoZWQgcGFnZSByZXNwb25zZXMgYW5kIHRoZSBjb3JyZXNwb25kaW5nIHBhZ2UgcGFyYW0gdmFsdWVzIGZvciBlYWNoIHBhZ2UuIFlvdSBtYXkgdXNlIHRoaXMgdG8gcmVuZGVyIGluZGl2aWR1YWwgcGFnZXMsIGNvbWJpbmUgYWxsIHBhZ2VzIGludG8gYSBzaW5nbGUgaW5maW5pdGUgbGlzdCwgb3Igb3RoZXIgZGlzcGxheSBsb2dpYyBhcyBuZWVkZWQuXG4gKlxuICogVGhpcyBob29rIGNvbWJpbmVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGJvdGggW2B1c2VJbmZpbml0ZVF1ZXJ5U3RhdGVgXSgjdXNlaW5maW5pdGVxdWVyeXN0YXRlKSBhbmQgW2B1c2VJbmZpbml0ZVF1ZXJ5U3Vic2NyaXB0aW9uYF0oI3VzZWluZmluaXRlcXVlcnlzdWJzY3JpcHRpb24pIHRvZ2V0aGVyLCBhbmQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiB0aGUgbWFqb3JpdHkgb2Ygc2l0dWF0aW9ucy5cbiAqXG4gKiBBcyB3aXRoIG5vcm1hbCBxdWVyeSBob29rcywgYHNraXBUb2tlbmAgaXMgYSB2YWxpZCBhcmd1bWVudCB0aGF0IHdpbGwgc2tpcCB0aGUgcXVlcnkgZnJvbSBleGVjdXRpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgdGhlIGluaXRpYWwgcmVxdWVzdCB3aWxsIHVzZSB0aGUgYGluaXRpYWxQYWdlUGFyYW1gIHZhbHVlIHRoYXQgd2FzIGRlZmluZWQgb24gdGhlIGluZmluaXRlIHF1ZXJ5IGVuZHBvaW50LiBJZiB5b3Ugd2FudCB0byBzdGFydCBmcm9tIGEgZGlmZmVyZW50IHZhbHVlLCB5b3UgY2FuIHBhc3MgYGluaXRpYWxQYWdlUGFyYW1gIGFzIHBhcnQgb2YgdGhlIGhvb2sgb3B0aW9ucyB0byBvdmVycmlkZSB0aGF0IGluaXRpYWwgcmVxdWVzdCB2YWx1ZS5cbiAqXG4gKiBVc2UgdGhlIHJldHVybmVkIGBmZXRjaE5leHRQYWdlYCBhbmQgYGZldGNoUHJldmlvdXNQYWdlYCBtZXRob2RzIG9uIHRoZSBob29rIHJlc3VsdCBvYmplY3QgdG8gdHJpZ2dlciBmZXRjaGVzIGZvcndhcmRzIGFuZCBiYWNrd2FyZHMuIFRoZXNlIHdpbGwgYWx3YXlzIGNhbGN1bGF0ZSB0aGUgbmV4dCBvciBwcmV2aW91cyBwYWdlIHBhcmFtIGJhc2VkIG9uIHRoZSBjdXJyZW50IGNhY2hlZCBwYWdlcyBhbmQgdGhlIHByb3ZpZGVkIGBnZXROZXh0L1ByZXZpb3VzUGFnZVBhcmFtYCBjYWxsYmFja3MgZGVmaW5lZCBpbiB0aGUgZW5kcG9pbnQuXG4gKlxuICpcbiAqICMjIyMgRmVhdHVyZXNcbiAqXG4gKiAtIEF1dG9tYXRpY2FsbHkgdHJpZ2dlcnMgcmVxdWVzdHMgdG8gcmV0cmlldmUgZGF0YSBiYXNlZCBvbiB0aGUgaG9vayBhcmd1bWVudCBhbmQgd2hldGhlciBjYWNoZWQgZGF0YSBleGlzdHMgYnkgZGVmYXVsdFxuICogLSAnU3Vic2NyaWJlcycgdGhlIGNvbXBvbmVudCB0byBrZWVwIGNhY2hlZCBkYXRhIGluIHRoZSBzdG9yZSwgYW5kICd1bnN1YnNjcmliZXMnIHdoZW4gdGhlIGNvbXBvbmVudCB1bm1vdW50c1xuICogLSBDYWNoZXMgbXVsdGlwbGUgcGFnZXMgd29ydGggb2YgcmVzcG9uc2VzLCBhbmQgcHJvdmlkZXMgbWV0aG9kcyB0byB0cmlnZ2VyIG1vcmUgcGFnZSBmZXRjaGVzIGZvcndhcmRzIGFuZCBiYWNrd2FyZHNcbiAqIC0gQWNjZXB0cyBwb2xsaW5nL3JlLWZldGNoaW5nIG9wdGlvbnMgdG8gdHJpZ2dlciBhdXRvbWF0aWMgcmUtZmV0Y2hlcyB3aGVuIHRoZSBjb3JyZXNwb25kaW5nIGNyaXRlcmlhIGlzIG1ldFxuICogLSBSZXR1cm5zIHRoZSBsYXRlc3QgcmVxdWVzdCBzdGF0dXMgYW5kIGNhY2hlZCBkYXRhIGZyb20gdGhlIFJlZHV4IHN0b3JlXG4gKiAtIFJlLXJlbmRlcnMgYXMgdGhlIHJlcXVlc3Qgc3RhdHVzIGNoYW5nZXMgYW5kIGRhdGEgYmVjb21lcyBhdmFpbGFibGVcbiAqL1xuZXhwb3J0IHR5cGUgVXNlSW5maW5pdGVRdWVyeTxEIGV4dGVuZHMgSW5maW5pdGVRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnk+PiA9IDxSIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiA9IFVzZUluZmluaXRlUXVlcnlTdGF0ZURlZmF1bHRSZXN1bHQ8RD4+KGFyZzogSW5maW5pdGVRdWVyeUFyZ0Zyb208RD4gfCBTa2lwVG9rZW4sIG9wdGlvbnM/OiBVc2VJbmZpbml0ZVF1ZXJ5U3Vic2NyaXB0aW9uT3B0aW9uczxEPiAmIFVzZUluZmluaXRlUXVlcnlTdGF0ZU9wdGlvbnM8RCwgUj4pID0+IFVzZUluZmluaXRlUXVlcnlIb29rUmVzdWx0PEQsIFI+ICYgUGljazxVc2VJbmZpbml0ZVF1ZXJ5U3Vic2NyaXB0aW9uUmVzdWx0PEQ+LCAnZmV0Y2hOZXh0UGFnZScgfCAnZmV0Y2hQcmV2aW91c1BhZ2UnPjtcbmV4cG9ydCB0eXBlIFR5cGVkVXNlSW5maW5pdGVRdWVyeTxSZXN1bHRUeXBlLCBRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbj4gPSBVc2VJbmZpbml0ZVF1ZXJ5PEluZmluaXRlUXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBQYWdlUGFyYW0sIEJhc2VRdWVyeSwgc3RyaW5nLCBSZXN1bHRUeXBlLCBzdHJpbmc+PjtcblxuLyoqXG4gKiBBIFJlYWN0IGhvb2sgdGhhdCByZWFkcyB0aGUgcmVxdWVzdCBzdGF0dXMgYW5kIGNhY2hlZCBkYXRhIGZyb20gdGhlIFJlZHV4IHN0b3JlLiBUaGUgY29tcG9uZW50IHdpbGwgcmUtcmVuZGVyIGFzIHRoZSBsb2FkaW5nIHN0YXR1cyBjaGFuZ2VzIGFuZCB0aGUgZGF0YSBiZWNvbWVzIGF2YWlsYWJsZS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBob29rIGRvZXMgbm90IHRyaWdnZXIgZmV0Y2hpbmcgbmV3IGRhdGEuIEZvciB0aGF0IHVzZS1jYXNlLCBzZWUgW2B1c2VJbmZpbml0ZVF1ZXJ5YF0oI3VzZWluZmluaXRlcXVlcnkpIG9yIFtgdXNlSW5maW5pdGVRdWVyeVN1YnNjcmlwdGlvbmBdKCN1c2VpbmZpbml0ZXF1ZXJ5c3Vic2NyaXB0aW9uKS5cbiAqXG4gKiAjIyMjIEZlYXR1cmVzXG4gKlxuICogLSBSZXR1cm5zIHRoZSBsYXRlc3QgcmVxdWVzdCBzdGF0dXMgYW5kIGNhY2hlZCBkYXRhIGZyb20gdGhlIFJlZHV4IHN0b3JlXG4gKiAtIFJlLXJlbmRlcnMgYXMgdGhlIHJlcXVlc3Qgc3RhdHVzIGNoYW5nZXMgYW5kIGRhdGEgYmVjb21lcyBhdmFpbGFibGVcbiAqL1xuZXhwb3J0IHR5cGUgVXNlSW5maW5pdGVRdWVyeVN0YXRlPEQgZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4+ID0gPFIgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gVXNlSW5maW5pdGVRdWVyeVN0YXRlRGVmYXVsdFJlc3VsdDxEPj4oYXJnOiBJbmZpbml0ZVF1ZXJ5QXJnRnJvbTxEPiB8IFNraXBUb2tlbiwgb3B0aW9ucz86IFVzZUluZmluaXRlUXVlcnlTdGF0ZU9wdGlvbnM8RCwgUj4pID0+IFVzZUluZmluaXRlUXVlcnlTdGF0ZVJlc3VsdDxELCBSPjtcbmV4cG9ydCB0eXBlIFR5cGVkVXNlSW5maW5pdGVRdWVyeVN0YXRlPFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBQYWdlUGFyYW0sIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuPiA9IFVzZUluZmluaXRlUXVlcnlTdGF0ZTxJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnksIHN0cmluZywgUmVzdWx0VHlwZSwgc3RyaW5nPj47XG5cbi8qKlxuICogQSBSZWFjdCBob29rIHRoYXQgYXV0b21hdGljYWxseSB0cmlnZ2VycyBmZXRjaGVzIG9mIGRhdGEgZnJvbSBhbiBlbmRwb2ludCwgYW5kICdzdWJzY3JpYmVzJyB0aGUgY29tcG9uZW50IHRvIHRoZSBjYWNoZWQgZGF0YS4gQWRkaXRpb25hbGx5LCBpdCB3aWxsIGNhY2hlIG11bHRpcGxlIFwicGFnZXNcIiB3b3J0aCBvZiByZXNwb25zZXMgd2l0aGluIGEgc2luZ2xlIGNhY2hlIGVudHJ5LCBhbmQgYWxsb3dzIGZldGNoaW5nIG1vcmUgcGFnZXMgZm9yd2FyZHMgYW5kIGJhY2t3YXJkcyBmcm9tIHRoZSBjdXJyZW50IGNhY2hlZCBwYWdlcy5cbiAqXG4gKiBUaGUgcXVlcnkgYXJnIGlzIHVzZWQgYXMgYSBjYWNoZSBrZXkuIENoYW5naW5nIHRoZSBxdWVyeSBhcmcgd2lsbCB0ZWxsIHRoZSBob29rIHRvIHJlLWZldGNoIHRoZSBkYXRhIGlmIGl0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBjYWNoZSBhbHJlYWR5LlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGhvb2sgZG9lcyBub3QgcmV0dXJuIGEgcmVxdWVzdCBzdGF0dXMgb3IgY2FjaGVkIGRhdGEuIEZvciB0aGF0IHVzZS1jYXNlLCBzZWUgW2B1c2VJbmZpbml0ZVF1ZXJ5YF0oI3VzZWluZmluaXRlcXVlcnkpIG9yIFtgdXNlSW5maW5pdGVRdWVyeVN0YXRlYF0oI3VzZWluZmluaXRlcXVlcnlzdGF0ZSkuXG4gKlxuICogIyMjIyBGZWF0dXJlc1xuICpcbiAqIC0gQXV0b21hdGljYWxseSB0cmlnZ2VycyByZXF1ZXN0cyB0byByZXRyaWV2ZSBkYXRhIGJhc2VkIG9uIHRoZSBob29rIGFyZ3VtZW50IGFuZCB3aGV0aGVyIGNhY2hlZCBkYXRhIGV4aXN0cyBieSBkZWZhdWx0XG4gKiAtICdTdWJzY3JpYmVzJyB0aGUgY29tcG9uZW50IHRvIGtlZXAgY2FjaGVkIGRhdGEgaW4gdGhlIHN0b3JlLCBhbmQgJ3Vuc3Vic2NyaWJlcycgd2hlbiB0aGUgY29tcG9uZW50IHVubW91bnRzXG4gKiAtIENhY2hlcyBtdWx0aXBsZSBwYWdlcyB3b3J0aCBvZiByZXNwb25zZXMsIGFuZCBwcm92aWRlcyBtZXRob2RzIHRvIHRyaWdnZXIgbW9yZSBwYWdlIGZldGNoZXMgZm9yd2FyZHMgYW5kIGJhY2t3YXJkc1xuICogLSBBY2NlcHRzIHBvbGxpbmcvcmUtZmV0Y2hpbmcgb3B0aW9ucyB0byB0cmlnZ2VyIGF1dG9tYXRpYyByZS1mZXRjaGVzIHdoZW4gdGhlIGNvcnJlc3BvbmRpbmcgY3JpdGVyaWEgaXMgbWV0XG4gKi9cbmV4cG9ydCB0eXBlIFVzZUluZmluaXRlUXVlcnlTdWJzY3JpcHRpb248RCBleHRlbmRzIEluZmluaXRlUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55Pj4gPSAoYXJnOiBJbmZpbml0ZVF1ZXJ5QXJnRnJvbTxEPiB8IFNraXBUb2tlbiwgb3B0aW9ucz86IFVzZUluZmluaXRlUXVlcnlTdWJzY3JpcHRpb25PcHRpb25zPEQ+KSA9PiBVc2VJbmZpbml0ZVF1ZXJ5U3Vic2NyaXB0aW9uUmVzdWx0PEQ+O1xuZXhwb3J0IHR5cGUgVXNlSW5maW5pdGVRdWVyeUhvb2tSZXN1bHQ8RCBleHRlbmRzIEluZmluaXRlUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55PiwgUiA9IFVzZUluZmluaXRlUXVlcnlTdGF0ZURlZmF1bHRSZXN1bHQ8RD4+ID0gVXNlSW5maW5pdGVRdWVyeVN0YXRlUmVzdWx0PEQsIFI+ICYgUGljazxVc2VJbmZpbml0ZVF1ZXJ5U3Vic2NyaXB0aW9uUmVzdWx0PEQ+LCAncmVmZXRjaCc+O1xuZXhwb3J0IHR5cGUgVHlwZWRVc2VJbmZpbml0ZVF1ZXJ5SG9va1Jlc3VsdDxSZXN1bHRUeXBlLCBRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgUiBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4gPSBVc2VJbmZpbml0ZVF1ZXJ5U3RhdGVEZWZhdWx0UmVzdWx0PEluZmluaXRlUXVlcnlEZWZpbml0aW9uPFF1ZXJ5QXJnLCBQYWdlUGFyYW0sIEJhc2VRdWVyeSwgc3RyaW5nLCBSZXN1bHRUeXBlLCBzdHJpbmc+Pj4gPSBVc2VJbmZpbml0ZVF1ZXJ5SG9va1Jlc3VsdDxJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnksIHN0cmluZywgUmVzdWx0VHlwZSwgc3RyaW5nPiwgUj47XG5leHBvcnQgdHlwZSBVc2VJbmZpbml0ZVF1ZXJ5U3RhdGVPcHRpb25zPEQgZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4sIFIgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PiA9IHtcbiAgLyoqXG4gICAqIFByZXZlbnRzIGEgcXVlcnkgZnJvbSBhdXRvbWF0aWNhbGx5IHJ1bm5pbmcuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFdoZW4gc2tpcCBpcyB0cnVlOlxuICAgKlxuICAgKiAtICoqSWYgdGhlIHF1ZXJ5IGhhcyBjYWNoZWQgZGF0YToqKlxuICAgKiAgICogVGhlIGNhY2hlZCBkYXRhICoqd2lsbCBub3QgYmUgdXNlZCoqIG9uIHRoZSBpbml0aWFsIGxvYWQsIGFuZCB3aWxsIGlnbm9yZSB1cGRhdGVzIGZyb20gYW55IGlkZW50aWNhbCBxdWVyeSB1bnRpbCB0aGUgYHNraXBgIGNvbmRpdGlvbiBpcyByZW1vdmVkXG4gICAqICAgKiBUaGUgcXVlcnkgd2lsbCBoYXZlIGEgc3RhdHVzIG9mIGB1bmluaXRpYWxpemVkYFxuICAgKiAgICogSWYgYHNraXA6IGZhbHNlYCBpcyBzZXQgYWZ0ZXIgc2tpcHBpbmcgdGhlIGluaXRpYWwgbG9hZCwgdGhlIGNhY2hlZCByZXN1bHQgd2lsbCBiZSB1c2VkXG4gICAqIC0gKipJZiB0aGUgcXVlcnkgZG9lcyBub3QgaGF2ZSBjYWNoZWQgZGF0YToqKlxuICAgKiAgICogVGhlIHF1ZXJ5IHdpbGwgaGF2ZSBhIHN0YXR1cyBvZiBgdW5pbml0aWFsaXplZGBcbiAgICogICAqIFRoZSBxdWVyeSB3aWxsIG5vdCBleGlzdCBpbiB0aGUgc3RhdGUgd2hlbiB2aWV3ZWQgd2l0aCB0aGUgZGV2IHRvb2xzXG4gICAqICAgKiBUaGUgcXVlcnkgd2lsbCBub3QgYXV0b21hdGljYWxseSBmZXRjaCBvbiBtb3VudFxuICAgKiAgICogVGhlIHF1ZXJ5IHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgcnVuIHdoZW4gYWRkaXRpb25hbCBjb21wb25lbnRzIHdpdGggdGhlIHNhbWUgcXVlcnkgYXJlIGFkZGVkIHRoYXQgZG8gcnVuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIHRpdGxlPVwiU2tpcCBleGFtcGxlXCJcbiAgICogY29uc3QgUG9rZW1vbiA9ICh7IG5hbWUsIHNraXAgfTogeyBuYW1lOiBzdHJpbmc7IHNraXA6IGJvb2xlYW4gfSkgPT4ge1xuICAgKiAgIGNvbnN0IHsgZGF0YSwgZXJyb3IsIHN0YXR1cyB9ID0gdXNlR2V0UG9rZW1vbkJ5TmFtZVF1ZXJ5KG5hbWUsIHtcbiAgICogICAgIHNraXAsXG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgcmV0dXJuIChcbiAgICogICAgIDxkaXY+XG4gICAqICAgICAgIHtuYW1lfSAtIHtzdGF0dXN9XG4gICAqICAgICA8L2Rpdj5cbiAgICogICApO1xuICAgKiB9O1xuICAgKiBgYGBcbiAgICovXG4gIHNraXA/OiBib29sZWFuO1xuICAvKipcbiAgICogYHNlbGVjdEZyb21SZXN1bHRgIGFsbG93cyB5b3UgdG8gZ2V0IGEgc3BlY2lmaWMgc2VnbWVudCBmcm9tIGEgcXVlcnkgcmVzdWx0IGluIGEgcGVyZm9ybWFudCBtYW5uZXIuXG4gICAqIFdoZW4gdXNpbmcgdGhpcyBmZWF0dXJlLCB0aGUgY29tcG9uZW50IHdpbGwgbm90IHJlcmVuZGVyIHVubGVzcyB0aGUgdW5kZXJseWluZyBkYXRhIG9mIHRoZSBzZWxlY3RlZCBpdGVtIGhhcyBjaGFuZ2VkLlxuICAgKiBJZiB0aGUgc2VsZWN0ZWQgaXRlbSBpcyBvbmUgZWxlbWVudCBpbiBhIGxhcmdlciBjb2xsZWN0aW9uLCBpdCB3aWxsIGRpc3JlZ2FyZCBjaGFuZ2VzIHRvIGVsZW1lbnRzIGluIHRoZSBzYW1lIGNvbGxlY3Rpb24uXG4gICAqIE5vdGUgdGhhdCB0aGlzIHNob3VsZCBhbHdheXMgcmV0dXJuIGFuIG9iamVjdCAobm90IGEgcHJpbWl0aXZlKSwgYXMgUlRLUSBhZGRzIGZpZWxkcyB0byB0aGUgcmV0dXJuIHZhbHVlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiAvLyBjb2RlYmxvY2stbWV0YSB0aXRsZT1cIlVzaW5nIHNlbGVjdEZyb21SZXN1bHQgdG8gZXh0cmFjdCBhIHNpbmdsZSByZXN1bHRcIlxuICAgKiBmdW5jdGlvbiBQb3N0c0xpc3QoKSB7XG4gICAqICAgY29uc3QgeyBkYXRhOiBwb3N0cyB9ID0gYXBpLnVzZUdldFBvc3RzUXVlcnkoKTtcbiAgICpcbiAgICogICByZXR1cm4gKFxuICAgKiAgICAgPHVsPlxuICAgKiAgICAgICB7cG9zdHM/LmRhdGE/Lm1hcCgocG9zdCkgPT4gKFxuICAgKiAgICAgICAgIDxQb3N0QnlJZCBrZXk9e3Bvc3QuaWR9IGlkPXtwb3N0LmlkfSAvPlxuICAgKiAgICAgICApKX1cbiAgICogICAgIDwvdWw+XG4gICAqICAgKTtcbiAgICogfVxuICAgKlxuICAgKiBmdW5jdGlvbiBQb3N0QnlJZCh7IGlkIH06IHsgaWQ6IG51bWJlciB9KSB7XG4gICAqICAgLy8gV2lsbCBzZWxlY3QgdGhlIHBvc3Qgd2l0aCB0aGUgZ2l2ZW4gaWQsIGFuZCB3aWxsIG9ubHkgcmVyZW5kZXIgaWYgdGhlIGdpdmVuIHBvc3RzIGRhdGEgY2hhbmdlc1xuICAgKiAgIGNvbnN0IHsgcG9zdCB9ID0gYXBpLnVzZUdldFBvc3RzUXVlcnkodW5kZWZpbmVkLCB7XG4gICAqICAgICBzZWxlY3RGcm9tUmVzdWx0OiAoeyBkYXRhIH0pID0+ICh7IHBvc3Q6IGRhdGE/LmZpbmQoKHBvc3QpID0+IHBvc3QuaWQgPT09IGlkKSB9KSxcbiAgICogICB9KTtcbiAgICpcbiAgICogICByZXR1cm4gPGxpPntwb3N0Py5uYW1lfTwvbGk+O1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgc2VsZWN0RnJvbVJlc3VsdD86IEluZmluaXRlUXVlcnlTdGF0ZVNlbGVjdG9yPFIsIEQ+O1xufTtcbmV4cG9ydCB0eXBlIFR5cGVkVXNlSW5maW5pdGVRdWVyeVN0YXRlT3B0aW9uczxSZXN1bHRUeXBlLCBRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgU2VsZWN0ZWRSZXN1bHQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gVXNlSW5maW5pdGVRdWVyeVN0YXRlRGVmYXVsdFJlc3VsdDxJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnksIHN0cmluZywgUmVzdWx0VHlwZSwgc3RyaW5nPj4+ID0gVXNlSW5maW5pdGVRdWVyeVN0YXRlT3B0aW9uczxJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnksIHN0cmluZywgUmVzdWx0VHlwZSwgc3RyaW5nPiwgU2VsZWN0ZWRSZXN1bHQ+O1xuZXhwb3J0IHR5cGUgVXNlSW5maW5pdGVRdWVyeVN0YXRlUmVzdWx0PEQgZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4sIFIgPSBVc2VJbmZpbml0ZVF1ZXJ5U3RhdGVEZWZhdWx0UmVzdWx0PEQ+PiA9IFRTSGVscGVyc05vSW5mZXI8Uj47XG5leHBvcnQgdHlwZSBUeXBlZFVzZUluZmluaXRlUXVlcnlTdGF0ZVJlc3VsdDxSZXN1bHRUeXBlLCBRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbiwgUiA9IFVzZUluZmluaXRlUXVlcnlTdGF0ZURlZmF1bHRSZXN1bHQ8SW5maW5pdGVRdWVyeURlZmluaXRpb248UXVlcnlBcmcsIFBhZ2VQYXJhbSwgQmFzZVF1ZXJ5LCBzdHJpbmcsIFJlc3VsdFR5cGUsIHN0cmluZz4+PiA9IFVzZUluZmluaXRlUXVlcnlTdGF0ZVJlc3VsdDxJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxRdWVyeUFyZywgUGFnZVBhcmFtLCBCYXNlUXVlcnksIHN0cmluZywgUmVzdWx0VHlwZSwgc3RyaW5nPiwgUj47XG50eXBlIFVzZUluZmluaXRlUXVlcnlTdGF0ZUJhc2VSZXN1bHQ8RCBleHRlbmRzIEluZmluaXRlUXVlcnlEZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55Pj4gPSBJbmZpbml0ZVF1ZXJ5U3ViU3RhdGU8RD4gJiB7XG4gIC8qKlxuICAgKiBXaGVyZSBgZGF0YWAgdHJpZXMgdG8gaG9sZCBkYXRhIGFzIG11Y2ggYXMgcG9zc2libGUsIGFsc28gcmUtdXNpbmdcbiAgICogZGF0YSBmcm9tIHRoZSBsYXN0IGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgaG9vaywgdGhpcyBwcm9wZXJ0eVxuICAgKiB3aWxsIGFsd2F5cyBjb250YWluIHRoZSByZWNlaXZlZCBkYXRhIGZyb20gdGhlIHF1ZXJ5LCBmb3IgdGhlIGN1cnJlbnQgcXVlcnkgYXJndW1lbnRzLlxuICAgKi9cbiAgY3VycmVudERhdGE/OiBJbmZpbml0ZURhdGE8UmVzdWx0VHlwZUZyb208RD4sIFBhZ2VQYXJhbUZyb208RD4+O1xuICAvKipcbiAgICogUXVlcnkgaGFzIG5vdCBzdGFydGVkIHlldC5cbiAgICovXG4gIGlzVW5pbml0aWFsaXplZDogZmFsc2U7XG4gIC8qKlxuICAgKiBRdWVyeSBpcyBjdXJyZW50bHkgbG9hZGluZyBmb3IgdGhlIGZpcnN0IHRpbWUuIE5vIGRhdGEgeWV0LlxuICAgKi9cbiAgaXNMb2FkaW5nOiBmYWxzZTtcbiAgLyoqXG4gICAqIFF1ZXJ5IGlzIGN1cnJlbnRseSBmZXRjaGluZywgYnV0IG1pZ2h0IGhhdmUgZGF0YSBmcm9tIGFuIGVhcmxpZXIgcmVxdWVzdC5cbiAgICovXG4gIGlzRmV0Y2hpbmc6IGZhbHNlO1xuICAvKipcbiAgICogUXVlcnkgaGFzIGRhdGEgZnJvbSBhIHN1Y2Nlc3NmdWwgbG9hZC5cbiAgICovXG4gIGlzU3VjY2VzczogZmFsc2U7XG4gIC8qKlxuICAgKiBRdWVyeSBpcyBjdXJyZW50bHkgaW4gXCJlcnJvclwiIHN0YXRlLlxuICAgKi9cbiAgaXNFcnJvcjogZmFsc2U7XG4gIGhhc05leHRQYWdlOiBmYWxzZTtcbiAgaGFzUHJldmlvdXNQYWdlOiBmYWxzZTtcbiAgaXNGZXRjaGluZ05leHRQYWdlOiBmYWxzZTtcbiAgaXNGZXRjaGluZ1ByZXZpb3VzUGFnZTogZmFsc2U7XG59O1xudHlwZSBVc2VJbmZpbml0ZVF1ZXJ5U3RhdGVEZWZhdWx0UmVzdWx0PEQgZXh0ZW5kcyBJbmZpbml0ZVF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4+ID0gVFNIZWxwZXJzSWQ8VFNIZWxwZXJzT3ZlcnJpZGU8RXh0cmFjdDxVc2VJbmZpbml0ZVF1ZXJ5U3RhdGVCYXNlUmVzdWx0PEQ+LCB7XG4gIHN0YXR1czogUXVlcnlTdGF0dXMudW5pbml0aWFsaXplZDtcbn0+LCB7XG4gIGlzVW5pbml0aWFsaXplZDogdHJ1ZTtcbn0+IHwgVFNIZWxwZXJzT3ZlcnJpZGU8VXNlSW5maW5pdGVRdWVyeVN0YXRlQmFzZVJlc3VsdDxEPiwge1xuICBpc0xvYWRpbmc6IHRydWU7XG4gIGlzRmV0Y2hpbmc6IGJvb2xlYW47XG4gIGRhdGE6IHVuZGVmaW5lZDtcbn0gfCAoe1xuICBpc1N1Y2Nlc3M6IHRydWU7XG4gIGlzRmV0Y2hpbmc6IHRydWU7XG4gIGVycm9yOiB1bmRlZmluZWQ7XG59ICYgUmVxdWlyZWQ8UGljazxVc2VJbmZpbml0ZVF1ZXJ5U3RhdGVCYXNlUmVzdWx0PEQ+LCAnZGF0YScgfCAnZnVsZmlsbGVkVGltZVN0YW1wJz4+KSB8ICh7XG4gIGlzU3VjY2VzczogdHJ1ZTtcbiAgaXNGZXRjaGluZzogZmFsc2U7XG4gIGVycm9yOiB1bmRlZmluZWQ7XG59ICYgUmVxdWlyZWQ8UGljazxVc2VJbmZpbml0ZVF1ZXJ5U3RhdGVCYXNlUmVzdWx0PEQ+LCAnZGF0YScgfCAnZnVsZmlsbGVkVGltZVN0YW1wJyB8ICdjdXJyZW50RGF0YSc+PikgfCAoe1xuICBpc0Vycm9yOiB0cnVlO1xufSAmIFJlcXVpcmVkPFBpY2s8VXNlSW5maW5pdGVRdWVyeVN0YXRlQmFzZVJlc3VsdDxEPiwgJ2Vycm9yJz4+KT4+ICYge1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgSW5jbHVkZWQgZm9yIGNvbXBsZXRlbmVzcywgYnV0IGRpc2NvdXJhZ2VkLlxuICAgKiBQbGVhc2UgdXNlIHRoZSBgaXNMb2FkaW5nYCwgYGlzRmV0Y2hpbmdgLCBgaXNTdWNjZXNzYCwgYGlzRXJyb3JgXG4gICAqIGFuZCBgaXNVbmluaXRpYWxpemVkYCBmbGFncyBpbnN0ZWFkXG4gICAqL1xuICBzdGF0dXM6IFF1ZXJ5U3RhdHVzO1xufTtcbmV4cG9ydCB0eXBlIE11dGF0aW9uU3RhdGVTZWxlY3RvcjxSIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiwgRCBleHRlbmRzIE11dGF0aW9uRGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+PiA9IChzdGF0ZTogTXV0YXRpb25SZXN1bHRTZWxlY3RvclJlc3VsdDxEPikgPT4gUjtcbmV4cG9ydCB0eXBlIFVzZU11dGF0aW9uU3RhdGVPcHRpb25zPEQgZXh0ZW5kcyBNdXRhdGlvbkRlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55PiwgUiBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4+ID0ge1xuICBzZWxlY3RGcm9tUmVzdWx0PzogTXV0YXRpb25TdGF0ZVNlbGVjdG9yPFIsIEQ+O1xuICBmaXhlZENhY2hlS2V5Pzogc3RyaW5nO1xufTtcbmV4cG9ydCB0eXBlIFVzZU11dGF0aW9uU3RhdGVSZXN1bHQ8RCBleHRlbmRzIE11dGF0aW9uRGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+LCBSPiA9IFRTSGVscGVyc05vSW5mZXI8Uj4gJiB7XG4gIG9yaWdpbmFsQXJncz86IFF1ZXJ5QXJnRnJvbTxEPjtcbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgaG9vayBzdGF0ZSB0byBpdHMgaW5pdGlhbCBgdW5pbml0aWFsaXplZGAgc3RhdGUuXG4gICAqIFRoaXMgd2lsbCBhbHNvIHJlbW92ZSB0aGUgbGFzdCByZXN1bHQgZnJvbSB0aGUgY2FjaGUuXG4gICAqL1xuICByZXNldDogKCkgPT4gdm9pZDtcbn07XG5cbi8qKlxuICogSGVscGVyIHR5cGUgdG8gbWFudWFsbHkgdHlwZSB0aGUgcmVzdWx0XG4gKiBvZiB0aGUgYHVzZU11dGF0aW9uYCBob29rIGluIHVzZXJsYW5kIGNvZGUuXG4gKi9cbmV4cG9ydCB0eXBlIFR5cGVkVXNlTXV0YXRpb25SZXN1bHQ8UmVzdWx0VHlwZSwgUXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuLCBSID0gTXV0YXRpb25SZXN1bHRTZWxlY3RvclJlc3VsdDxNdXRhdGlvbkRlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSwgc3RyaW5nLCBSZXN1bHRUeXBlLCBzdHJpbmc+Pj4gPSBVc2VNdXRhdGlvblN0YXRlUmVzdWx0PE11dGF0aW9uRGVmaW5pdGlvbjxRdWVyeUFyZywgQmFzZVF1ZXJ5LCBzdHJpbmcsIFJlc3VsdFR5cGUsIHN0cmluZz4sIFI+O1xuXG4vKipcbiAqIEEgUmVhY3QgaG9vayB0aGF0IGxldHMgeW91IHRyaWdnZXIgYW4gdXBkYXRlIHJlcXVlc3QgZm9yIGEgZ2l2ZW4gZW5kcG9pbnQsIGFuZCBzdWJzY3JpYmVzIHRoZSBjb21wb25lbnQgdG8gcmVhZCB0aGUgcmVxdWVzdCBzdGF0dXMgZnJvbSB0aGUgUmVkdXggc3RvcmUuIFRoZSBjb21wb25lbnQgd2lsbCByZS1yZW5kZXIgYXMgdGhlIGxvYWRpbmcgc3RhdHVzIGNoYW5nZXMuXG4gKlxuICogIyMjIyBGZWF0dXJlc1xuICpcbiAqIC0gTWFudWFsIGNvbnRyb2wgb3ZlciBmaXJpbmcgYSByZXF1ZXN0IHRvIGFsdGVyIGRhdGEgb24gdGhlIHNlcnZlciBvciBwb3NzaWJseSBpbnZhbGlkYXRlIHRoZSBjYWNoZVxuICogLSAnU3Vic2NyaWJlcycgdGhlIGNvbXBvbmVudCB0byBrZWVwIGNhY2hlZCBkYXRhIGluIHRoZSBzdG9yZSwgYW5kICd1bnN1YnNjcmliZXMnIHdoZW4gdGhlIGNvbXBvbmVudCB1bm1vdW50c1xuICogLSBSZXR1cm5zIHRoZSBsYXRlc3QgcmVxdWVzdCBzdGF0dXMgYW5kIGNhY2hlZCBkYXRhIGZyb20gdGhlIFJlZHV4IHN0b3JlXG4gKiAtIFJlLXJlbmRlcnMgYXMgdGhlIHJlcXVlc3Qgc3RhdHVzIGNoYW5nZXMgYW5kIGRhdGEgYmVjb21lcyBhdmFpbGFibGVcbiAqL1xuZXhwb3J0IHR5cGUgVXNlTXV0YXRpb248RCBleHRlbmRzIE11dGF0aW9uRGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnk+PiA9IDxSIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiA9IE11dGF0aW9uUmVzdWx0U2VsZWN0b3JSZXN1bHQ8RD4+KG9wdGlvbnM/OiBVc2VNdXRhdGlvblN0YXRlT3B0aW9uczxELCBSPikgPT4gcmVhZG9ubHkgW011dGF0aW9uVHJpZ2dlcjxEPiwgVXNlTXV0YXRpb25TdGF0ZVJlc3VsdDxELCBSPl07XG5leHBvcnQgdHlwZSBUeXBlZFVzZU11dGF0aW9uPFJlc3VsdFR5cGUsIFF1ZXJ5QXJnLCBCYXNlUXVlcnkgZXh0ZW5kcyBCYXNlUXVlcnlGbj4gPSBVc2VNdXRhdGlvbjxNdXRhdGlvbkRlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSwgc3RyaW5nLCBSZXN1bHRUeXBlLCBzdHJpbmc+PjtcbmV4cG9ydCB0eXBlIE11dGF0aW9uVHJpZ2dlcjxEIGV4dGVuZHMgTXV0YXRpb25EZWZpbml0aW9uPGFueSwgYW55LCBhbnksIGFueT4+ID0ge1xuICAvKipcbiAgICogVHJpZ2dlcnMgdGhlIG11dGF0aW9uIGFuZCByZXR1cm5zIGEgUHJvbWlzZS5cbiAgICogQHJlbWFya3NcbiAgICogSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBlcnJvciBvciBzdWNjZXNzIHBheWxvYWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYSBtdXRhdGlvbiwgeW91IGNhbiBjaGFpbiAudW53cmFwKCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIC8vIGNvZGVibG9jay1tZXRhIHRpdGxlPVwiVXNpbmcgLnVud3JhcCB3aXRoIGFzeW5jIGF3YWl0XCJcbiAgICogdHJ5IHtcbiAgICogICBjb25zdCBwYXlsb2FkID0gYXdhaXQgYWRkUG9zdCh7IGlkOiAxLCBuYW1lOiAnRXhhbXBsZScgfSkudW53cmFwKCk7XG4gICAqICAgY29uc29sZS5sb2coJ2Z1bGZpbGxlZCcsIHBheWxvYWQpXG4gICAqIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAqICAgY29uc29sZS5lcnJvcigncmVqZWN0ZWQnLCBlcnJvcik7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICAoYXJnOiBRdWVyeUFyZ0Zyb208RD4pOiBNdXRhdGlvbkFjdGlvbkNyZWF0b3JSZXN1bHQ8RD47XG59O1xuZXhwb3J0IHR5cGUgVHlwZWRNdXRhdGlvblRyaWdnZXI8UmVzdWx0VHlwZSwgUXVlcnlBcmcsIEJhc2VRdWVyeSBleHRlbmRzIEJhc2VRdWVyeUZuPiA9IE11dGF0aW9uVHJpZ2dlcjxNdXRhdGlvbkRlZmluaXRpb248UXVlcnlBcmcsIEJhc2VRdWVyeSwgc3RyaW5nLCBSZXN1bHRUeXBlLCBzdHJpbmc+PjtcblxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCBgZGVmYXVsdFF1ZXJ5U3RhdGVTZWxlY3RvcmAgdG8gYmUgdXNlZCBpbiBgdXNlUXVlcnlgLlxuICogV2Ugd2FudCB0aGUgaW5pdGlhbCByZW5kZXIgdG8gYWxyZWFkeSBjb21lIGJhY2sgd2l0aFxuICogYHsgaXNVbmluaXRpYWxpemVkOiBmYWxzZSwgaXNGZXRjaGluZzogdHJ1ZSwgaXNMb2FkaW5nOiB0cnVlIH1gXG4gKiB0byBwcmV2ZW50IHRoYXQgdGhlIGxpYnJhcnkgdXNlciBoYXMgdG8gZG8gYW4gYWRkaXRpb25hbCBjaGVjayBmb3IgYGlzVW5pbml0aWFsaXplZGAvXG4gKi9cbmNvbnN0IG5vUGVuZGluZ1F1ZXJ5U3RhdGVTZWxlY3RvcjogUXVlcnlTdGF0ZVNlbGVjdG9yPGFueSwgYW55PiA9IHNlbGVjdGVkID0+IHtcbiAgaWYgKHNlbGVjdGVkLmlzVW5pbml0aWFsaXplZCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zZWxlY3RlZCxcbiAgICAgIGlzVW5pbml0aWFsaXplZDogZmFsc2UsXG4gICAgICBpc0ZldGNoaW5nOiB0cnVlLFxuICAgICAgaXNMb2FkaW5nOiBzZWxlY3RlZC5kYXRhICE9PSB1bmRlZmluZWQgPyBmYWxzZSA6IHRydWUsXG4gICAgICBzdGF0dXM6IFF1ZXJ5U3RhdHVzLnBlbmRpbmdcbiAgICB9IGFzIGFueTtcbiAgfVxuICByZXR1cm4gc2VsZWN0ZWQ7XG59O1xuZnVuY3Rpb24gcGljazxULCBLIGV4dGVuZHMga2V5b2YgVD4ob2JqOiBULCAuLi5rZXlzOiBLW10pOiBQaWNrPFQsIEs+IHtcbiAgY29uc3QgcmV0OiBhbnkgPSB7fTtcbiAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5jb25zdCBDT01NT05fSE9PS19ERUJVR19GSUVMRFMgPSBbJ2RhdGEnLCAnc3RhdHVzJywgJ2lzTG9hZGluZycsICdpc1N1Y2Nlc3MnLCAnaXNFcnJvcicsICdlcnJvciddIGFzIGNvbnN0O1xudHlwZSBHZW5lcmljUHJlZmV0Y2hUaHVuayA9IChlbmRwb2ludE5hbWU6IGFueSwgYXJnOiBhbnksIG9wdGlvbnM6IFByZWZldGNoT3B0aW9ucykgPT4gVGh1bmtBY3Rpb248dm9pZCwgYW55LCBhbnksIFVua25vd25BY3Rpb24+O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gb3B0cy5hcGkgLSBBbiBBUEkgd2l0aCBkZWZpbmVkIGVuZHBvaW50cyB0byBjcmVhdGUgaG9va3MgZm9yXG4gKiBAcGFyYW0gb3B0cy5tb2R1bGVPcHRpb25zLmJhdGNoIC0gVGhlIHZlcnNpb24gb2YgdGhlIGBiYXRjaGVkVXBkYXRlc2AgZnVuY3Rpb24gdG8gYmUgdXNlZFxuICogQHBhcmFtIG9wdHMubW9kdWxlT3B0aW9ucy51c2VEaXNwYXRjaCAtIFRoZSB2ZXJzaW9uIG9mIHRoZSBgdXNlRGlzcGF0Y2hgIGhvb2sgdG8gYmUgdXNlZFxuICogQHBhcmFtIG9wdHMubW9kdWxlT3B0aW9ucy51c2VTZWxlY3RvciAtIFRoZSB2ZXJzaW9uIG9mIHRoZSBgdXNlU2VsZWN0b3JgIGhvb2sgdG8gYmUgdXNlZFxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgZnVuY3Rpb25zIHRvIGdlbmVyYXRlIGhvb2tzIGJhc2VkIG9uIGFuIGVuZHBvaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEhvb2tzPERlZmluaXRpb25zIGV4dGVuZHMgRW5kcG9pbnREZWZpbml0aW9ucz4oe1xuICBhcGksXG4gIG1vZHVsZU9wdGlvbnM6IHtcbiAgICBiYXRjaCxcbiAgICBob29rczoge1xuICAgICAgdXNlRGlzcGF0Y2gsXG4gICAgICB1c2VTZWxlY3RvcixcbiAgICAgIHVzZVN0b3JlXG4gICAgfSxcbiAgICB1bnN0YWJsZV9fc2lkZUVmZmVjdHNJblJlbmRlcixcbiAgICBjcmVhdGVTZWxlY3RvclxuICB9LFxuICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gIGNvbnRleHRcbn06IHtcbiAgYXBpOiBBcGk8YW55LCBEZWZpbml0aW9ucywgYW55LCBhbnksIENvcmVNb2R1bGU+O1xuICBtb2R1bGVPcHRpb25zOiBSZXF1aXJlZDxSZWFjdEhvb2tzTW9kdWxlT3B0aW9ucz47XG4gIHNlcmlhbGl6ZVF1ZXJ5QXJnczogU2VyaWFsaXplUXVlcnlBcmdzPGFueT47XG4gIGNvbnRleHQ6IEFwaUNvbnRleHQ8RGVmaW5pdGlvbnM+O1xufSkge1xuICBjb25zdCB1c2VQb3NzaWJseUltbWVkaWF0ZUVmZmVjdDogKGVmZmVjdDogKCkgPT4gdm9pZCB8IHVuZGVmaW5lZCwgZGVwcz86IERlcGVuZGVuY3lMaXN0KSA9PiB2b2lkID0gdW5zdGFibGVfX3NpZGVFZmZlY3RzSW5SZW5kZXIgPyBjYiA9PiBjYigpIDogdXNlRWZmZWN0O1xuICByZXR1cm4ge1xuICAgIGJ1aWxkUXVlcnlIb29rcyxcbiAgICBidWlsZEluZmluaXRlUXVlcnlIb29rcyxcbiAgICBidWlsZE11dGF0aW9uSG9vayxcbiAgICB1c2VQcmVmZXRjaFxuICB9O1xuICBmdW5jdGlvbiBxdWVyeVN0YXRlUHJlU2VsZWN0b3IoY3VycmVudFN0YXRlOiBRdWVyeVJlc3VsdFNlbGVjdG9yUmVzdWx0PGFueT4sIGxhc3RSZXN1bHQ6IFVzZVF1ZXJ5U3RhdGVEZWZhdWx0UmVzdWx0PGFueT4gfCB1bmRlZmluZWQsIHF1ZXJ5QXJnczogYW55KTogVXNlUXVlcnlTdGF0ZURlZmF1bHRSZXN1bHQ8YW55PiB7XG4gICAgLy8gaWYgd2UgaGFkIGEgbGFzdCByZXN1bHQgYW5kIHRoZSBjdXJyZW50IHJlc3VsdCBpcyB1bmluaXRpYWxpemVkLFxuICAgIC8vIHdlIG1pZ2h0IGhhdmUgY2FsbGVkIGBhcGkudXRpbC5yZXNldEFwaVN0YXRlYFxuICAgIC8vIGluIHRoaXMgY2FzZSwgcmVzZXQgdGhlIGhvb2tcbiAgICBpZiAobGFzdFJlc3VsdD8uZW5kcG9pbnROYW1lICYmIGN1cnJlbnRTdGF0ZS5pc1VuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9ID0gbGFzdFJlc3VsdDtcbiAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgICAgaWYgKHF1ZXJ5QXJncyAhPT0gc2tpcFRva2VuICYmIHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAgICAgIHF1ZXJ5QXJnczogbGFzdFJlc3VsdC5vcmlnaW5hbEFyZ3MsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KSA9PT0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgcXVlcnlBcmdzLFxuICAgICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICAgIGVuZHBvaW50TmFtZVxuICAgICAgfSkpIGxhc3RSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gZGF0YSBpcyB0aGUgbGFzdCBrbm93biBnb29kIHJlcXVlc3QgcmVzdWx0IHdlIGhhdmUgdHJhY2tlZCAtIG9yIGlmIG5vbmUgaGFzIGJlZW4gdHJhY2tlZCB5ZXQgdGhlIGxhc3QgZ29vZCByZXN1bHQgZm9yIHRoZSBjdXJyZW50IGFyZ3NcbiAgICBsZXQgZGF0YSA9IGN1cnJlbnRTdGF0ZS5pc1N1Y2Nlc3MgPyBjdXJyZW50U3RhdGUuZGF0YSA6IGxhc3RSZXN1bHQ/LmRhdGE7XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkgZGF0YSA9IGN1cnJlbnRTdGF0ZS5kYXRhO1xuICAgIGNvbnN0IGhhc0RhdGEgPSBkYXRhICE9PSB1bmRlZmluZWQ7XG5cbiAgICAvLyBpc0ZldGNoaW5nID0gdHJ1ZSBhbnkgdGltZSBhIHJlcXVlc3QgaXMgaW4gZmxpZ2h0XG4gICAgY29uc3QgaXNGZXRjaGluZyA9IGN1cnJlbnRTdGF0ZS5pc0xvYWRpbmc7XG5cbiAgICAvLyBpc0xvYWRpbmcgPSB0cnVlIG9ubHkgd2hlbiBsb2FkaW5nIHdoaWxlIG5vIGRhdGEgaXMgcHJlc2VudCB5ZXQgKGluaXRpYWwgbG9hZCB3aXRoIG5vIGRhdGEgaW4gdGhlIGNhY2hlKVxuICAgIGNvbnN0IGlzTG9hZGluZyA9ICghbGFzdFJlc3VsdCB8fCBsYXN0UmVzdWx0LmlzTG9hZGluZyB8fCBsYXN0UmVzdWx0LmlzVW5pbml0aWFsaXplZCkgJiYgIWhhc0RhdGEgJiYgaXNGZXRjaGluZztcblxuICAgIC8vIGlzU3VjY2VzcyA9IHRydWUgd2hlbiBkYXRhIGlzIHByZXNlbnQgYW5kIHdlJ3JlIG5vdCByZWZldGNoaW5nIGFmdGVyIGFuIGVycm9yLlxuICAgIC8vIFRoYXQgaW5jbHVkZXMgY2FzZXMgd2hlcmUgdGhlIF9jdXJyZW50XyBpdGVtIGlzIGVpdGhlciBhY3RpdmVseVxuICAgIC8vIGZldGNoaW5nIG9yIGFib3V0IHRvIGZldGNoIGR1ZSB0byBhbiB1bmluaXRpYWxpemVkIGVudHJ5LlxuICAgIGNvbnN0IGlzU3VjY2VzcyA9IGN1cnJlbnRTdGF0ZS5pc1N1Y2Nlc3MgfHwgaGFzRGF0YSAmJiAoaXNGZXRjaGluZyAmJiAhbGFzdFJlc3VsdD8uaXNFcnJvciB8fCBjdXJyZW50U3RhdGUuaXNVbmluaXRpYWxpemVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY3VycmVudFN0YXRlLFxuICAgICAgZGF0YSxcbiAgICAgIGN1cnJlbnREYXRhOiBjdXJyZW50U3RhdGUuZGF0YSxcbiAgICAgIGlzRmV0Y2hpbmcsXG4gICAgICBpc0xvYWRpbmcsXG4gICAgICBpc1N1Y2Nlc3NcbiAgICB9IGFzIFVzZVF1ZXJ5U3RhdGVEZWZhdWx0UmVzdWx0PGFueT47XG4gIH1cbiAgZnVuY3Rpb24gaW5maW5pdGVRdWVyeVN0YXRlUHJlU2VsZWN0b3IoY3VycmVudFN0YXRlOiBJbmZpbml0ZVF1ZXJ5UmVzdWx0U2VsZWN0b3JSZXN1bHQ8YW55PiwgbGFzdFJlc3VsdDogVXNlSW5maW5pdGVRdWVyeVN0YXRlRGVmYXVsdFJlc3VsdDxhbnk+IHwgdW5kZWZpbmVkLCBxdWVyeUFyZ3M6IGFueSk6IFVzZUluZmluaXRlUXVlcnlTdGF0ZURlZmF1bHRSZXN1bHQ8YW55PiB7XG4gICAgLy8gaWYgd2UgaGFkIGEgbGFzdCByZXN1bHQgYW5kIHRoZSBjdXJyZW50IHJlc3VsdCBpcyB1bmluaXRpYWxpemVkLFxuICAgIC8vIHdlIG1pZ2h0IGhhdmUgY2FsbGVkIGBhcGkudXRpbC5yZXNldEFwaVN0YXRlYFxuICAgIC8vIGluIHRoaXMgY2FzZSwgcmVzZXQgdGhlIGhvb2tcbiAgICBpZiAobGFzdFJlc3VsdD8uZW5kcG9pbnROYW1lICYmIGN1cnJlbnRTdGF0ZS5pc1VuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9ID0gbGFzdFJlc3VsdDtcbiAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgICAgaWYgKHF1ZXJ5QXJncyAhPT0gc2tpcFRva2VuICYmIHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAgICAgIHF1ZXJ5QXJnczogbGFzdFJlc3VsdC5vcmlnaW5hbEFyZ3MsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KSA9PT0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgcXVlcnlBcmdzLFxuICAgICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICAgIGVuZHBvaW50TmFtZVxuICAgICAgfSkpIGxhc3RSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gZGF0YSBpcyB0aGUgbGFzdCBrbm93biBnb29kIHJlcXVlc3QgcmVzdWx0IHdlIGhhdmUgdHJhY2tlZCAtIG9yIGlmIG5vbmUgaGFzIGJlZW4gdHJhY2tlZCB5ZXQgdGhlIGxhc3QgZ29vZCByZXN1bHQgZm9yIHRoZSBjdXJyZW50IGFyZ3NcbiAgICBsZXQgZGF0YSA9IGN1cnJlbnRTdGF0ZS5pc1N1Y2Nlc3MgPyBjdXJyZW50U3RhdGUuZGF0YSA6IGxhc3RSZXN1bHQ/LmRhdGE7XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkgZGF0YSA9IGN1cnJlbnRTdGF0ZS5kYXRhO1xuICAgIGNvbnN0IGhhc0RhdGEgPSBkYXRhICE9PSB1bmRlZmluZWQ7XG5cbiAgICAvLyBpc0ZldGNoaW5nID0gdHJ1ZSBhbnkgdGltZSBhIHJlcXVlc3QgaXMgaW4gZmxpZ2h0XG4gICAgY29uc3QgaXNGZXRjaGluZyA9IGN1cnJlbnRTdGF0ZS5pc0xvYWRpbmc7XG4gICAgLy8gaXNMb2FkaW5nID0gdHJ1ZSBvbmx5IHdoZW4gbG9hZGluZyB3aGlsZSBubyBkYXRhIGlzIHByZXNlbnQgeWV0IChpbml0aWFsIGxvYWQgd2l0aCBubyBkYXRhIGluIHRoZSBjYWNoZSlcbiAgICBjb25zdCBpc0xvYWRpbmcgPSAoIWxhc3RSZXN1bHQgfHwgbGFzdFJlc3VsdC5pc0xvYWRpbmcgfHwgbGFzdFJlc3VsdC5pc1VuaW5pdGlhbGl6ZWQpICYmICFoYXNEYXRhICYmIGlzRmV0Y2hpbmc7XG4gICAgLy8gaXNTdWNjZXNzID0gdHJ1ZSB3aGVuIGRhdGEgaXMgcHJlc2VudFxuICAgIGNvbnN0IGlzU3VjY2VzcyA9IGN1cnJlbnRTdGF0ZS5pc1N1Y2Nlc3MgfHwgaXNGZXRjaGluZyAmJiBoYXNEYXRhO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jdXJyZW50U3RhdGUsXG4gICAgICBkYXRhLFxuICAgICAgY3VycmVudERhdGE6IGN1cnJlbnRTdGF0ZS5kYXRhLFxuICAgICAgaXNGZXRjaGluZyxcbiAgICAgIGlzTG9hZGluZyxcbiAgICAgIGlzU3VjY2Vzc1xuICAgIH0gYXMgVXNlSW5maW5pdGVRdWVyeVN0YXRlRGVmYXVsdFJlc3VsdDxhbnk+O1xuICB9XG4gIGZ1bmN0aW9uIHVzZVByZWZldGNoPEVuZHBvaW50TmFtZSBleHRlbmRzIFF1ZXJ5S2V5czxEZWZpbml0aW9ucz4+KGVuZHBvaW50TmFtZTogRW5kcG9pbnROYW1lLCBkZWZhdWx0T3B0aW9ucz86IFByZWZldGNoT3B0aW9ucykge1xuICAgIGNvbnN0IGRpc3BhdGNoID0gdXNlRGlzcGF0Y2g8VGh1bmtEaXNwYXRjaDxhbnksIGFueSwgVW5rbm93bkFjdGlvbj4+KCk7XG4gICAgY29uc3Qgc3RhYmxlRGVmYXVsdE9wdGlvbnMgPSB1c2VTaGFsbG93U3RhYmxlVmFsdWUoZGVmYXVsdE9wdGlvbnMpO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoYXJnOiBhbnksIG9wdGlvbnM/OiBQcmVmZXRjaE9wdGlvbnMpID0+IGRpc3BhdGNoKChhcGkudXRpbC5wcmVmZXRjaCBhcyBHZW5lcmljUHJlZmV0Y2hUaHVuaykoZW5kcG9pbnROYW1lLCBhcmcsIHtcbiAgICAgIC4uLnN0YWJsZURlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pKSwgW2VuZHBvaW50TmFtZSwgZGlzcGF0Y2gsIHN0YWJsZURlZmF1bHRPcHRpb25zXSk7XG4gIH1cbiAgZnVuY3Rpb24gdXNlUXVlcnlTdWJzY3JpcHRpb25Db21tb25JbXBsPFQgZXh0ZW5kcyBRdWVyeUFjdGlvbkNyZWF0b3JSZXN1bHQ8YW55PiB8IEluZmluaXRlUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0PGFueT4+KGVuZHBvaW50TmFtZTogc3RyaW5nLCBhcmc6IHVua25vd24gfCBTa2lwVG9rZW4sIHtcbiAgICByZWZldGNoT25SZWNvbm5lY3QsXG4gICAgcmVmZXRjaE9uRm9jdXMsXG4gICAgcmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZSxcbiAgICBza2lwID0gZmFsc2UsXG4gICAgcG9sbGluZ0ludGVydmFsID0gMCxcbiAgICBza2lwUG9sbGluZ0lmVW5mb2N1c2VkID0gZmFsc2UsXG4gICAgLi4ucmVzdFxuICB9OiBVc2VRdWVyeVN1YnNjcmlwdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluaXRpYXRlXG4gICAgfSA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSBhcyBBcGlFbmRwb2ludFF1ZXJ5PFF1ZXJ5RGVmaW5pdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT4sIERlZmluaXRpb25zPjtcbiAgICBjb25zdCBkaXNwYXRjaCA9IHVzZURpc3BhdGNoPFRodW5rRGlzcGF0Y2g8YW55LCBhbnksIFVua25vd25BY3Rpb24+PigpO1xuXG4gICAgLy8gVE9ETzogQ2hhbmdlIHRoaXMgdG8gYHVzZVJlZjxTdWJzY3JpcHRpb25TZWxlY3RvcnM+KHVuZGVmaW5lZClgIGFmdGVyIHVwZ3JhZGluZyB0byBSZWFjdCAxOS5cbiAgICBjb25zdCBzdWJzY3JpcHRpb25TZWxlY3RvcnNSZWYgPSB1c2VSZWY8U3Vic2NyaXB0aW9uU2VsZWN0b3JzIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICAgIGlmICghc3Vic2NyaXB0aW9uU2VsZWN0b3JzUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IHJldHVybmVkVmFsdWUgPSBkaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLmludGVybmFsX2dldFJUS1FTdWJzY3JpcHRpb25zKCkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXR1cm5lZFZhbHVlICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcmV0dXJuZWRWYWx1ZT8udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzcpIDogYFdhcm5pbmc6IE1pZGRsZXdhcmUgZm9yIFJUSy1RdWVyeSBBUEkgYXQgcmVkdWNlclBhdGggXCIke2FwaS5yZWR1Y2VyUGF0aH1cIiBoYXMgbm90IGJlZW4gYWRkZWQgdG8gdGhlIHN0b3JlLlxuICAgIFlvdSBtdXN0IGFkZCB0aGUgbWlkZGxld2FyZSBmb3IgUlRLLVF1ZXJ5IHRvIGZ1bmN0aW9uIGNvcnJlY3RseSFgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3Vic2NyaXB0aW9uU2VsZWN0b3JzUmVmLmN1cnJlbnQgPSByZXR1cm5lZFZhbHVlIGFzIHVua25vd24gYXMgU3Vic2NyaXB0aW9uU2VsZWN0b3JzO1xuICAgIH1cbiAgICBjb25zdCBzdGFibGVBcmcgPSB1c2VTdGFibGVRdWVyeUFyZ3Moc2tpcCA/IHNraXBUb2tlbiA6IGFyZyxcbiAgICAvLyBFdmVuIGlmIHRoZSB1c2VyIHByb3ZpZGVkIGEgcGVyLWVuZHBvaW50IGBzZXJpYWxpemVRdWVyeUFyZ3NgIHdpdGhcbiAgICAvLyBhIGNvbnNpc3RlbnQgcmV0dXJuIHZhbHVlLCBfaGVyZV8gd2Ugd2FudCB0byB1c2UgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAvLyBzbyB3ZSBjYW4gdGVsbCBpZiBfYW55dGhpbmdfIGFjdHVhbGx5IGNoYW5nZWQuIE90aGVyd2lzZSwgd2UgY2FuIGVuZCB1cFxuICAgIC8vIHdpdGggYSBjYXNlIHdoZXJlIHRoZSBxdWVyeSBhcmdzIGRpZCBjaGFuZ2UgYnV0IHRoZSBzZXJpYWxpemF0aW9uIGRvZXNuJ3QsXG4gICAgLy8gYW5kIHRoZW4gd2UgbmV2ZXIgdHJ5IHRvIGluaXRpYXRlIGEgcmVmZXRjaC5cbiAgICBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzLCBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXSwgZW5kcG9pbnROYW1lKTtcbiAgICBjb25zdCBzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zID0gdXNlU2hhbGxvd1N0YWJsZVZhbHVlKHtcbiAgICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICAgIHJlZmV0Y2hPbkZvY3VzLFxuICAgICAgcG9sbGluZ0ludGVydmFsLFxuICAgICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZFxuICAgIH0pO1xuICAgIGNvbnN0IGluaXRpYWxQYWdlUGFyYW0gPSAocmVzdCBhcyBVc2VJbmZpbml0ZVF1ZXJ5U3Vic2NyaXB0aW9uT3B0aW9uczxhbnk+KS5pbml0aWFsUGFnZVBhcmFtO1xuICAgIGNvbnN0IHN0YWJsZUluaXRpYWxQYWdlUGFyYW0gPSB1c2VTaGFsbG93U3RhYmxlVmFsdWUoaW5pdGlhbFBhZ2VQYXJhbSk7XG5cbiAgICAvKipcbiAgICAgKiBAdG9kbyBDaGFuZ2UgdGhpcyB0byBgdXNlUmVmPFF1ZXJ5QWN0aW9uQ3JlYXRvclJlc3VsdDxhbnk+Pih1bmRlZmluZWQpYCBhZnRlciB1cGdyYWRpbmcgdG8gUmVhY3QgMTkuXG4gICAgICovXG4gICAgY29uc3QgcHJvbWlzZVJlZiA9IHVzZVJlZjxUIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICAgIGxldCB7XG4gICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgcmVxdWVzdElkXG4gICAgfSA9IHByb21pc2VSZWYuY3VycmVudCB8fCB7fTtcblxuICAgIC8vIEhBQ0sgV2UndmUgc2F2ZWQgdGhlIG1pZGRsZXdhcmUgc3Vic2NyaXB0aW9uIGxvb2t1cCBjYWxsYmFja3MgaW50byBhIHJlZixcbiAgICAvLyBzbyB3ZSBjYW4gZGlyZWN0bHkgY2hlY2sgaGVyZSBpZiB0aGUgc3Vic2NyaXB0aW9uIGV4aXN0cyBmb3IgdGhpcyBxdWVyeS5cbiAgICBsZXQgY3VycmVudFJlbmRlckhhc1N1YnNjcmlwdGlvbiA9IGZhbHNlO1xuICAgIGlmIChxdWVyeUNhY2hlS2V5ICYmIHJlcXVlc3RJZCkge1xuICAgICAgY3VycmVudFJlbmRlckhhc1N1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvblNlbGVjdG9yc1JlZi5jdXJyZW50LmlzUmVxdWVzdFN1YnNjcmliZWQocXVlcnlDYWNoZUtleSwgcmVxdWVzdElkKTtcbiAgICB9XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uUmVtb3ZlZCA9ICFjdXJyZW50UmVuZGVySGFzU3Vic2NyaXB0aW9uICYmIHByb21pc2VSZWYuY3VycmVudCAhPT0gdW5kZWZpbmVkO1xuICAgIHVzZVBvc3NpYmx5SW1tZWRpYXRlRWZmZWN0KCgpOiB2b2lkIHwgdW5kZWZpbmVkID0+IHtcbiAgICAgIGlmIChzdWJzY3JpcHRpb25SZW1vdmVkKSB7XG4gICAgICAgIHByb21pc2VSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LCBbc3Vic2NyaXB0aW9uUmVtb3ZlZF0pO1xuICAgIHVzZVBvc3NpYmx5SW1tZWRpYXRlRWZmZWN0KCgpOiB2b2lkIHwgdW5kZWZpbmVkID0+IHtcbiAgICAgIGNvbnN0IGxhc3RQcm9taXNlID0gcHJvbWlzZVJlZi5jdXJyZW50O1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3JlbW92ZU1lT25Db21waWxhdGlvbicpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBvbmx5IHByZXNlbnQgdG8gZW5mb3JjZSB0aGUgcnVsZSBvZiBob29rcyB0byBrZWVwIGBpc1N1YnNjcmliZWRgIGluIHRoZSBkZXBlbmRlbmN5IGFycmF5XG4gICAgICAgIGNvbnNvbGUubG9nKHN1YnNjcmlwdGlvblJlbW92ZWQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YWJsZUFyZyA9PT0gc2tpcFRva2VuKSB7XG4gICAgICAgIGxhc3RQcm9taXNlPy51bnN1YnNjcmliZSgpO1xuICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhc3RTdWJzY3JpcHRpb25PcHRpb25zID0gcHJvbWlzZVJlZi5jdXJyZW50Py5zdWJzY3JpcHRpb25PcHRpb25zO1xuICAgICAgaWYgKCFsYXN0UHJvbWlzZSB8fCBsYXN0UHJvbWlzZS5hcmcgIT09IHN0YWJsZUFyZykge1xuICAgICAgICBsYXN0UHJvbWlzZT8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IGRpc3BhdGNoKGluaXRpYXRlKHN0YWJsZUFyZywge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnM6IHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMsXG4gICAgICAgICAgZm9yY2VSZWZldGNoOiByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlLFxuICAgICAgICAgIC4uLihpc0luZmluaXRlUXVlcnlEZWZpbml0aW9uKGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdKSA/IHtcbiAgICAgICAgICAgIGluaXRpYWxQYWdlUGFyYW06IHN0YWJsZUluaXRpYWxQYWdlUGFyYW1cbiAgICAgICAgICB9IDoge30pXG4gICAgICAgIH0pKTtcbiAgICAgICAgcHJvbWlzZVJlZi5jdXJyZW50ID0gcHJvbWlzZSBhcyBUO1xuICAgICAgfSBlbHNlIGlmIChzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zICE9PSBsYXN0U3Vic2NyaXB0aW9uT3B0aW9ucykge1xuICAgICAgICBsYXN0UHJvbWlzZS51cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zKHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sIFtkaXNwYXRjaCwgaW5pdGlhdGUsIHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UsIHN0YWJsZUFyZywgc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucywgc3Vic2NyaXB0aW9uUmVtb3ZlZCwgc3RhYmxlSW5pdGlhbFBhZ2VQYXJhbSwgZW5kcG9pbnROYW1lXSk7XG4gICAgcmV0dXJuIFtwcm9taXNlUmVmLCBkaXNwYXRjaCwgaW5pdGlhdGUsIHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnNdIGFzIGNvbnN0O1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkVXNlUXVlcnlTdGF0ZShlbmRwb2ludE5hbWU6IHN0cmluZywgcHJlU2VsZWN0b3I6IHR5cGVvZiBxdWVyeVN0YXRlUHJlU2VsZWN0b3IgfCB0eXBlb2YgaW5maW5pdGVRdWVyeVN0YXRlUHJlU2VsZWN0b3IpIHtcbiAgICBjb25zdCB1c2VRdWVyeVN0YXRlID0gKGFyZzogYW55LCB7XG4gICAgICBza2lwID0gZmFsc2UsXG4gICAgICBzZWxlY3RGcm9tUmVzdWx0XG4gICAgfTogVXNlUXVlcnlTdGF0ZU9wdGlvbnM8YW55LCBhbnk+IHwgVXNlSW5maW5pdGVRdWVyeVN0YXRlT3B0aW9uczxhbnksIGFueT4gPSB7fSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxlY3RcbiAgICAgIH0gPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0gYXMgQXBpRW5kcG9pbnRRdWVyeTxRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnk+LCBEZWZpbml0aW9ucz47XG4gICAgICBjb25zdCBzdGFibGVBcmcgPSB1c2VTdGFibGVRdWVyeUFyZ3Moc2tpcCA/IHNraXBUb2tlbiA6IGFyZywgc2VyaWFsaXplUXVlcnlBcmdzLCBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXSwgZW5kcG9pbnROYW1lKTtcbiAgICAgIHR5cGUgQXBpUm9vdFN0YXRlID0gUGFyYW1ldGVyczxSZXR1cm5UeXBlPHR5cGVvZiBzZWxlY3Q+PlswXTtcbiAgICAgIGNvbnN0IGxhc3RWYWx1ZSA9IHVzZVJlZjxhbnk+KHVuZGVmaW5lZCk7XG4gICAgICBjb25zdCBzZWxlY3REZWZhdWx0UmVzdWx0OiBTZWxlY3RvcjxBcGlSb290U3RhdGUsIGFueSwgW2FueV0+ID0gdXNlTWVtbygoKSA9PlxuICAgICAgLy8gTm9ybWFsbHkgdHMtaWdub3JlcyBhcmUgYmFkIGFuZCBzaG91bGQgYmUgYXZvaWRlZCwgYnV0IHdlJ3JlXG4gICAgICAvLyBhbHJlYWR5IGNhc3RpbmcgdGhpcyBzZWxlY3RvciB0byBiZSBgU2VsZWN0b3I8YW55PmAgYW55d2F5LFxuICAgICAgLy8gc28gdGhlIGluY29uc2lzdGVuY2llcyBkb24ndCBtYXR0ZXIgaGVyZVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY3JlYXRlU2VsZWN0b3IoW1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgc2VsZWN0KHN0YWJsZUFyZyksIChfOiBBcGlSb290U3RhdGUsIGxhc3RSZXN1bHQ6IGFueSkgPT4gbGFzdFJlc3VsdCwgKF86IEFwaVJvb3RTdGF0ZSkgPT4gc3RhYmxlQXJnXSwgcHJlU2VsZWN0b3IsIHtcbiAgICAgICAgbWVtb2l6ZU9wdGlvbnM6IHtcbiAgICAgICAgICByZXN1bHRFcXVhbGl0eUNoZWNrOiBzaGFsbG93RXF1YWxcbiAgICAgICAgfVxuICAgICAgfSksIFtzZWxlY3QsIHN0YWJsZUFyZ10pO1xuICAgICAgY29uc3QgcXVlcnlTZWxlY3RvcjogU2VsZWN0b3I8QXBpUm9vdFN0YXRlLCBhbnksIFthbnldPiA9IHVzZU1lbW8oKCkgPT4gc2VsZWN0RnJvbVJlc3VsdCA/IGNyZWF0ZVNlbGVjdG9yKFtzZWxlY3REZWZhdWx0UmVzdWx0XSwgc2VsZWN0RnJvbVJlc3VsdCwge1xuICAgICAgICBkZXZNb2RlQ2hlY2tzOiB7XG4gICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiAnbmV2ZXInXG4gICAgICAgIH1cbiAgICAgIH0pIDogc2VsZWN0RGVmYXVsdFJlc3VsdCwgW3NlbGVjdERlZmF1bHRSZXN1bHQsIHNlbGVjdEZyb21SZXN1bHRdKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHVzZVNlbGVjdG9yKChzdGF0ZTogUm9vdFN0YXRlPERlZmluaXRpb25zLCBhbnksIGFueT4pID0+IHF1ZXJ5U2VsZWN0b3Ioc3RhdGUsIGxhc3RWYWx1ZS5jdXJyZW50KSwgc2hhbGxvd0VxdWFsKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmU8Um9vdFN0YXRlPERlZmluaXRpb25zLCBhbnksIGFueT4+KCk7XG4gICAgICBjb25zdCBuZXdMYXN0VmFsdWUgPSBzZWxlY3REZWZhdWx0UmVzdWx0KHN0b3JlLmdldFN0YXRlKCksIGxhc3RWYWx1ZS5jdXJyZW50KTtcbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsYXN0VmFsdWUuY3VycmVudCA9IG5ld0xhc3RWYWx1ZTtcbiAgICAgIH0sIFtuZXdMYXN0VmFsdWVdKTtcbiAgICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gICAgfTtcbiAgICByZXR1cm4gdXNlUXVlcnlTdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiB1c2VQcm9taXNlUmVmVW5zdWJzY3JpYmVPblVubW91bnQocHJvbWlzZVJlZjogUmVhY3QuUmVmT2JqZWN0PHtcbiAgICB1bnN1YnNjcmliZT86ICgpID0+IHZvaWQ7XG4gIH0gfCB1bmRlZmluZWQ+KSB7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHByb21pc2VSZWYuY3VycmVudD8udW5zdWJzY3JpYmU/LigpXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgICAgO1xuICAgICAgICAocHJvbWlzZVJlZi5jdXJyZW50IGFzIGFueSkgPSB1bmRlZmluZWQ7XG4gICAgICB9O1xuICAgIH0sIFtwcm9taXNlUmVmXSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVmZXRjaE9yRXJyb3JJZlVubW91bnRlZDxUIGV4dGVuZHMgUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0PGFueT4gfCBJbmZpbml0ZVF1ZXJ5QWN0aW9uQ3JlYXRvclJlc3VsdDxhbnk+Pihwcm9taXNlUmVmOiBSZWFjdC5SZWZPYmplY3Q8VCB8IHVuZGVmaW5lZD4pOiBUIHtcbiAgICBpZiAoIXByb21pc2VSZWYuY3VycmVudCkgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMigzOCkgOiAnQ2Fubm90IHJlZmV0Y2ggYSBxdWVyeSB0aGF0IGhhcyBub3QgYmVlbiBzdGFydGVkIHlldC4nKTtcbiAgICByZXR1cm4gcHJvbWlzZVJlZi5jdXJyZW50LnJlZmV0Y2goKSBhcyBUO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkUXVlcnlIb29rcyhlbmRwb2ludE5hbWU6IHN0cmluZyk6IFF1ZXJ5SG9va3M8YW55PiB7XG4gICAgY29uc3QgdXNlUXVlcnlTdWJzY3JpcHRpb246IFVzZVF1ZXJ5U3Vic2NyaXB0aW9uPGFueT4gPSAoYXJnOiBhbnksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgY29uc3QgW3Byb21pc2VSZWZdID0gdXNlUXVlcnlTdWJzY3JpcHRpb25Db21tb25JbXBsPFF1ZXJ5QWN0aW9uQ3JlYXRvclJlc3VsdDxhbnk+PihlbmRwb2ludE5hbWUsIGFyZywgb3B0aW9ucyk7XG4gICAgICB1c2VQcm9taXNlUmVmVW5zdWJzY3JpYmVPblVubW91bnQocHJvbWlzZVJlZik7XG4gICAgICByZXR1cm4gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtZXRob2QgdG8gbWFudWFsbHkgcmVmZXRjaCBkYXRhIGZvciB0aGUgcXVlcnlcbiAgICAgICAgICovXG4gICAgICAgIHJlZmV0Y2g6ICgpID0+IHJlZmV0Y2hPckVycm9ySWZVbm1vdW50ZWQocHJvbWlzZVJlZilcbiAgICAgIH0pLCBbcHJvbWlzZVJlZl0pO1xuICAgIH07XG4gICAgY29uc3QgdXNlTGF6eVF1ZXJ5U3Vic2NyaXB0aW9uOiBVc2VMYXp5UXVlcnlTdWJzY3JpcHRpb248YW55PiA9ICh7XG4gICAgICByZWZldGNoT25SZWNvbm5lY3QsXG4gICAgICByZWZldGNoT25Gb2N1cyxcbiAgICAgIHBvbGxpbmdJbnRlcnZhbCA9IDAsXG4gICAgICBza2lwUG9sbGluZ0lmVW5mb2N1c2VkID0gZmFsc2VcbiAgICB9ID0ge30pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5pdGlhdGVcbiAgICAgIH0gPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0gYXMgQXBpRW5kcG9pbnRRdWVyeTxRdWVyeURlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnk+LCBEZWZpbml0aW9ucz47XG4gICAgICBjb25zdCBkaXNwYXRjaCA9IHVzZURpc3BhdGNoPFRodW5rRGlzcGF0Y2g8YW55LCBhbnksIFVua25vd25BY3Rpb24+PigpO1xuICAgICAgY29uc3QgW2FyZywgc2V0QXJnXSA9IHVzZVN0YXRlPGFueT4oVU5JTklUSUFMSVpFRF9WQUxVRSk7XG5cbiAgICAgIC8vIFRPRE86IENoYW5nZSB0aGlzIHRvIGB1c2VSZWY8UXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0PGFueT4+KHVuZGVmaW5lZClgIGFmdGVyIHVwZ3JhZGluZyB0byBSZWFjdCAxOS5cbiAgICAgIC8qKlxuICAgICAgICogQHRvZG8gQ2hhbmdlIHRoaXMgdG8gYHVzZVJlZjxRdWVyeUFjdGlvbkNyZWF0b3JSZXN1bHQ8YW55Pj4odW5kZWZpbmVkKWAgYWZ0ZXIgdXBncmFkaW5nIHRvIFJlYWN0IDE5LlxuICAgICAgICovXG4gICAgICBjb25zdCBwcm9taXNlUmVmID0gdXNlUmVmPFF1ZXJ5QWN0aW9uQ3JlYXRvclJlc3VsdDxhbnk+IHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICAgICAgY29uc3Qgc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyA9IHVzZVNoYWxsb3dTdGFibGVWYWx1ZSh7XG4gICAgICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICAgICAgcmVmZXRjaE9uRm9jdXMsXG4gICAgICAgIHBvbGxpbmdJbnRlcnZhbCxcbiAgICAgICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZFxuICAgICAgfSk7XG4gICAgICB1c2VQb3NzaWJseUltbWVkaWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhc3RTdWJzY3JpcHRpb25PcHRpb25zID0gcHJvbWlzZVJlZi5jdXJyZW50Py5zdWJzY3JpcHRpb25PcHRpb25zO1xuICAgICAgICBpZiAoc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyAhPT0gbGFzdFN1YnNjcmlwdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQ/LnVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMoc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0sIFtzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zXSk7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb25PcHRpb25zUmVmID0gdXNlUmVmKHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMpO1xuICAgICAgdXNlUG9zc2libHlJbW1lZGlhdGVFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdWJzY3JpcHRpb25PcHRpb25zUmVmLmN1cnJlbnQgPSBzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zO1xuICAgICAgfSwgW3N0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnNdKTtcbiAgICAgIGNvbnN0IHRyaWdnZXIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoYXJnOiBhbnksIHByZWZlckNhY2hlVmFsdWUgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcHJvbWlzZTogUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0PGFueT47XG4gICAgICAgIGJhdGNoKCgpID0+IHtcbiAgICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQ/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcHJvbWlzZVJlZi5jdXJyZW50ID0gcHJvbWlzZSA9IGRpc3BhdGNoKGluaXRpYXRlKGFyZywge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9uczogc3Vic2NyaXB0aW9uT3B0aW9uc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgZm9yY2VSZWZldGNoOiAhcHJlZmVyQ2FjaGVWYWx1ZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBzZXRBcmcoYXJnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlITtcbiAgICAgIH0sIFtkaXNwYXRjaCwgaW5pdGlhdGVdKTtcbiAgICAgIGNvbnN0IHJlc2V0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAocHJvbWlzZVJlZi5jdXJyZW50Py5xdWVyeUNhY2hlS2V5KSB7XG4gICAgICAgICAgZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5yZW1vdmVRdWVyeVJlc3VsdCh7XG4gICAgICAgICAgICBxdWVyeUNhY2hlS2V5OiBwcm9taXNlUmVmLmN1cnJlbnQ/LnF1ZXJ5Q2FjaGVLZXkgYXMgUXVlcnlDYWNoZUtleVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSwgW2Rpc3BhdGNoXSk7XG5cbiAgICAgIC8qIGNsZWFudXAgb24gdW5tb3VudCAqL1xuICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBwcm9taXNlUmVmPy5jdXJyZW50Py51bnN1YnNjcmliZSgpO1xuICAgICAgICB9O1xuICAgICAgfSwgW10pO1xuXG4gICAgICAvKiBpZiBcImNsZWFudXAgb24gdW5tb3VudFwiIHdhcyB0cmlnZ2VyZWQgZnJvbSBhIGZhc3QgcmVmcmVzaCwgd2Ugd2FudCB0byByZWluc3RhdGUgdGhlIHF1ZXJ5ICovXG4gICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoYXJnICE9PSBVTklOSVRJQUxJWkVEX1ZBTFVFICYmICFwcm9taXNlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICB0cmlnZ2VyKGFyZywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIFthcmcsIHRyaWdnZXJdKTtcbiAgICAgIHJldHVybiB1c2VNZW1vKCgpID0+IFt0cmlnZ2VyLCBhcmcsIHtcbiAgICAgICAgcmVzZXRcbiAgICAgIH1dIGFzIGNvbnN0LCBbdHJpZ2dlciwgYXJnLCByZXNldF0pO1xuICAgIH07XG4gICAgY29uc3QgdXNlUXVlcnlTdGF0ZTogVXNlUXVlcnlTdGF0ZTxhbnk+ID0gYnVpbGRVc2VRdWVyeVN0YXRlKGVuZHBvaW50TmFtZSwgcXVlcnlTdGF0ZVByZVNlbGVjdG9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgdXNlUXVlcnlTdGF0ZSxcbiAgICAgIHVzZVF1ZXJ5U3Vic2NyaXB0aW9uLFxuICAgICAgdXNlTGF6eVF1ZXJ5U3Vic2NyaXB0aW9uLFxuICAgICAgdXNlTGF6eVF1ZXJ5KG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgW3RyaWdnZXIsIGFyZywge1xuICAgICAgICAgIHJlc2V0XG4gICAgICAgIH1dID0gdXNlTGF6eVF1ZXJ5U3Vic2NyaXB0aW9uKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBxdWVyeVN0YXRlUmVzdWx0cyA9IHVzZVF1ZXJ5U3RhdGUoYXJnLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBza2lwOiBhcmcgPT09IFVOSU5JVElBTElaRURfVkFMVUVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGluZm8gPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgICAgbGFzdEFyZzogYXJnXG4gICAgICAgIH0pLCBbYXJnXSk7XG4gICAgICAgIHJldHVybiB1c2VNZW1vKCgpID0+IFt0cmlnZ2VyLCB7XG4gICAgICAgICAgLi4ucXVlcnlTdGF0ZVJlc3VsdHMsXG4gICAgICAgICAgcmVzZXRcbiAgICAgICAgfSwgaW5mb10sIFt0cmlnZ2VyLCBxdWVyeVN0YXRlUmVzdWx0cywgcmVzZXQsIGluZm9dKTtcbiAgICAgIH0sXG4gICAgICB1c2VRdWVyeShhcmcsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcXVlcnlTdWJzY3JpcHRpb25SZXN1bHRzID0gdXNlUXVlcnlTdWJzY3JpcHRpb24oYXJnLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcXVlcnlTdGF0ZVJlc3VsdHMgPSB1c2VRdWVyeVN0YXRlKGFyZywge1xuICAgICAgICAgIHNlbGVjdEZyb21SZXN1bHQ6IGFyZyA9PT0gc2tpcFRva2VuIHx8IG9wdGlvbnM/LnNraXAgPyB1bmRlZmluZWQgOiBub1BlbmRpbmdRdWVyeVN0YXRlU2VsZWN0b3IsXG4gICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGVidWdWYWx1ZSA9IHBpY2socXVlcnlTdGF0ZVJlc3VsdHMsIC4uLkNPTU1PTl9IT09LX0RFQlVHX0ZJRUxEUyk7XG4gICAgICAgIHVzZURlYnVnVmFsdWUoZGVidWdWYWx1ZSk7XG4gICAgICAgIHJldHVybiB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgICAgLi4ucXVlcnlTdGF0ZVJlc3VsdHMsXG4gICAgICAgICAgLi4ucXVlcnlTdWJzY3JpcHRpb25SZXN1bHRzXG4gICAgICAgIH0pLCBbcXVlcnlTdGF0ZVJlc3VsdHMsIHF1ZXJ5U3Vic2NyaXB0aW9uUmVzdWx0c10pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRJbmZpbml0ZVF1ZXJ5SG9va3MoZW5kcG9pbnROYW1lOiBzdHJpbmcpOiBJbmZpbml0ZVF1ZXJ5SG9va3M8YW55PiB7XG4gICAgY29uc3QgdXNlSW5maW5pdGVRdWVyeVN1YnNjcmlwdGlvbjogVXNlSW5maW5pdGVRdWVyeVN1YnNjcmlwdGlvbjxhbnk+ID0gKGFyZzogYW55LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGNvbnN0IFtwcm9taXNlUmVmLCBkaXNwYXRjaCwgaW5pdGlhdGUsIHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnNdID0gdXNlUXVlcnlTdWJzY3JpcHRpb25Db21tb25JbXBsPEluZmluaXRlUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0PGFueT4+KGVuZHBvaW50TmFtZSwgYXJnLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbk9wdGlvbnNSZWYgPSB1c2VSZWYoc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyk7XG4gICAgICB1c2VQb3NzaWJseUltbWVkaWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnNSZWYuY3VycmVudCA9IHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnM7XG4gICAgICB9LCBbc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9uc10pO1xuICAgICAgY29uc3QgdHJpZ2dlcjogTGF6eUluZmluaXRlUXVlcnlUcmlnZ2VyPGFueT4gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoYXJnOiB1bmtub3duLCBkaXJlY3Rpb246ICdmb3J3YXJkJyB8ICdiYWNrd2FyZCcpIHtcbiAgICAgICAgbGV0IHByb21pc2U6IEluZmluaXRlUXVlcnlBY3Rpb25DcmVhdG9yUmVzdWx0PGFueT47XG4gICAgICAgIGJhdGNoKCgpID0+IHtcbiAgICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQ/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcHJvbWlzZVJlZi5jdXJyZW50ID0gcHJvbWlzZSA9IGRpc3BhdGNoKChpbml0aWF0ZSBhcyBTdGFydEluZmluaXRlUXVlcnlBY3Rpb25DcmVhdG9yPGFueT4pKGFyZywge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9uczogc3Vic2NyaXB0aW9uT3B0aW9uc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgZGlyZWN0aW9uXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UhO1xuICAgICAgfSwgW3Byb21pc2VSZWYsIGRpc3BhdGNoLCBpbml0aWF0ZV0pO1xuICAgICAgdXNlUHJvbWlzZVJlZlVuc3Vic2NyaWJlT25Vbm1vdW50KHByb21pc2VSZWYpO1xuICAgICAgY29uc3Qgc3RhYmxlQXJnID0gdXNlU3RhYmxlUXVlcnlBcmdzKG9wdGlvbnMuc2tpcCA/IHNraXBUb2tlbiA6IGFyZyxcbiAgICAgIC8vIEV2ZW4gaWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBwZXItZW5kcG9pbnQgYHNlcmlhbGl6ZVF1ZXJ5QXJnc2Agd2l0aFxuICAgICAgLy8gYSBjb25zaXN0ZW50IHJldHVybiB2YWx1ZSwgX2hlcmVfIHdlIHdhbnQgdG8gdXNlIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAvLyBzbyB3ZSBjYW4gdGVsbCBpZiBfYW55dGhpbmdfIGFjdHVhbGx5IGNoYW5nZWQuIE90aGVyd2lzZSwgd2UgY2FuIGVuZCB1cFxuICAgICAgLy8gd2l0aCBhIGNhc2Ugd2hlcmUgdGhlIHF1ZXJ5IGFyZ3MgZGlkIGNoYW5nZSBidXQgdGhlIHNlcmlhbGl6YXRpb24gZG9lc24ndCxcbiAgICAgIC8vIGFuZCB0aGVuIHdlIG5ldmVyIHRyeSB0byBpbml0aWF0ZSBhIHJlZmV0Y2guXG4gICAgICBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzLCBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXSwgZW5kcG9pbnROYW1lKTtcbiAgICAgIGNvbnN0IHJlZmV0Y2ggPSB1c2VDYWxsYmFjaygoKSA9PiByZWZldGNoT3JFcnJvcklmVW5tb3VudGVkKHByb21pc2VSZWYpLCBbcHJvbWlzZVJlZl0pO1xuICAgICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBmZXRjaE5leHRQYWdlID0gKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0cmlnZ2VyKHN0YWJsZUFyZywgJ2ZvcndhcmQnKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmV0Y2hQcmV2aW91c1BhZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRyaWdnZXIoc3RhYmxlQXJnLCAnYmFja3dhcmQnKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmlnZ2VyLFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgbWV0aG9kIHRvIG1hbnVhbGx5IHJlZmV0Y2ggZGF0YSBmb3IgdGhlIHF1ZXJ5XG4gICAgICAgICAgICovXG4gICAgICAgICAgcmVmZXRjaCxcbiAgICAgICAgICBmZXRjaE5leHRQYWdlLFxuICAgICAgICAgIGZldGNoUHJldmlvdXNQYWdlXG4gICAgICAgIH07XG4gICAgICB9LCBbcmVmZXRjaCwgdHJpZ2dlciwgc3RhYmxlQXJnXSk7XG4gICAgfTtcbiAgICBjb25zdCB1c2VJbmZpbml0ZVF1ZXJ5U3RhdGU6IFVzZUluZmluaXRlUXVlcnlTdGF0ZTxhbnk+ID0gYnVpbGRVc2VRdWVyeVN0YXRlKGVuZHBvaW50TmFtZSwgaW5maW5pdGVRdWVyeVN0YXRlUHJlU2VsZWN0b3IpO1xuICAgIHJldHVybiB7XG4gICAgICB1c2VJbmZpbml0ZVF1ZXJ5U3RhdGUsXG4gICAgICB1c2VJbmZpbml0ZVF1ZXJ5U3Vic2NyaXB0aW9uLFxuICAgICAgdXNlSW5maW5pdGVRdWVyeShhcmcsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlZmV0Y2gsXG4gICAgICAgICAgZmV0Y2hOZXh0UGFnZSxcbiAgICAgICAgICBmZXRjaFByZXZpb3VzUGFnZVxuICAgICAgICB9ID0gdXNlSW5maW5pdGVRdWVyeVN1YnNjcmlwdGlvbihhcmcsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBxdWVyeVN0YXRlUmVzdWx0cyA9IHVzZUluZmluaXRlUXVlcnlTdGF0ZShhcmcsIHtcbiAgICAgICAgICBzZWxlY3RGcm9tUmVzdWx0OiBhcmcgPT09IHNraXBUb2tlbiB8fCBvcHRpb25zPy5za2lwID8gdW5kZWZpbmVkIDogbm9QZW5kaW5nUXVlcnlTdGF0ZVNlbGVjdG9yLFxuICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRlYnVnVmFsdWUgPSBwaWNrKHF1ZXJ5U3RhdGVSZXN1bHRzLCAuLi5DT01NT05fSE9PS19ERUJVR19GSUVMRFMsICdoYXNOZXh0UGFnZScsICdoYXNQcmV2aW91c1BhZ2UnKTtcbiAgICAgICAgdXNlRGVidWdWYWx1ZShkZWJ1Z1ZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgICAuLi5xdWVyeVN0YXRlUmVzdWx0cyxcbiAgICAgICAgICBmZXRjaE5leHRQYWdlLFxuICAgICAgICAgIGZldGNoUHJldmlvdXNQYWdlLFxuICAgICAgICAgIHJlZmV0Y2hcbiAgICAgICAgfSksIFtxdWVyeVN0YXRlUmVzdWx0cywgZmV0Y2hOZXh0UGFnZSwgZmV0Y2hQcmV2aW91c1BhZ2UsIHJlZmV0Y2hdKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkTXV0YXRpb25Ib29rKG5hbWU6IHN0cmluZyk6IFVzZU11dGF0aW9uPGFueT4ge1xuICAgIHJldHVybiAoe1xuICAgICAgc2VsZWN0RnJvbVJlc3VsdCxcbiAgICAgIGZpeGVkQ2FjaGVLZXlcbiAgICB9ID0ge30pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2VsZWN0LFxuICAgICAgICBpbml0aWF0ZVxuICAgICAgfSA9IGFwaS5lbmRwb2ludHNbbmFtZV0gYXMgQXBpRW5kcG9pbnRNdXRhdGlvbjxNdXRhdGlvbkRlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55LCBhbnk+LCBEZWZpbml0aW9ucz47XG4gICAgICBjb25zdCBkaXNwYXRjaCA9IHVzZURpc3BhdGNoPFRodW5rRGlzcGF0Y2g8YW55LCBhbnksIFVua25vd25BY3Rpb24+PigpO1xuICAgICAgY29uc3QgW3Byb21pc2UsIHNldFByb21pc2VdID0gdXNlU3RhdGU8TXV0YXRpb25BY3Rpb25DcmVhdG9yUmVzdWx0PGFueT4+KCk7XG4gICAgICB1c2VFZmZlY3QoKCkgPT4gKCkgPT4ge1xuICAgICAgICBpZiAoIXByb21pc2U/LmFyZy5maXhlZENhY2hlS2V5KSB7XG4gICAgICAgICAgcHJvbWlzZT8ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfSwgW3Byb21pc2VdKTtcbiAgICAgIGNvbnN0IHRyaWdnZXJNdXRhdGlvbiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChhcmc6IFBhcmFtZXRlcnM8dHlwZW9mIGluaXRpYXRlPlsnMCddKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBkaXNwYXRjaChpbml0aWF0ZShhcmcsIHtcbiAgICAgICAgICBmaXhlZENhY2hlS2V5XG4gICAgICAgIH0pKTtcbiAgICAgICAgc2V0UHJvbWlzZShwcm9taXNlKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9LCBbZGlzcGF0Y2gsIGluaXRpYXRlLCBmaXhlZENhY2hlS2V5XSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3RJZFxuICAgICAgfSA9IHByb21pc2UgfHwge307XG4gICAgICBjb25zdCBzZWxlY3REZWZhdWx0UmVzdWx0ID0gdXNlTWVtbygoKSA9PiBzZWxlY3Qoe1xuICAgICAgICBmaXhlZENhY2hlS2V5LFxuICAgICAgICByZXF1ZXN0SWQ6IHByb21pc2U/LnJlcXVlc3RJZFxuICAgICAgfSksIFtmaXhlZENhY2hlS2V5LCBwcm9taXNlLCBzZWxlY3RdKTtcbiAgICAgIGNvbnN0IG11dGF0aW9uU2VsZWN0b3IgPSB1c2VNZW1vKCgpOiBTZWxlY3RvcjxSb290U3RhdGU8RGVmaW5pdGlvbnMsIGFueSwgYW55PiwgYW55PiA9PiBzZWxlY3RGcm9tUmVzdWx0ID8gY3JlYXRlU2VsZWN0b3IoW3NlbGVjdERlZmF1bHRSZXN1bHRdLCBzZWxlY3RGcm9tUmVzdWx0KSA6IHNlbGVjdERlZmF1bHRSZXN1bHQsIFtzZWxlY3RGcm9tUmVzdWx0LCBzZWxlY3REZWZhdWx0UmVzdWx0XSk7XG4gICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB1c2VTZWxlY3RvcihtdXRhdGlvblNlbGVjdG9yLCBzaGFsbG93RXF1YWwpO1xuICAgICAgY29uc3Qgb3JpZ2luYWxBcmdzID0gZml4ZWRDYWNoZUtleSA9PSBudWxsID8gcHJvbWlzZT8uYXJnLm9yaWdpbmFsQXJncyA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IHJlc2V0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBiYXRjaCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICAgIHNldFByb21pc2UodW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZpeGVkQ2FjaGVLZXkpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlTXV0YXRpb25SZXN1bHQoe1xuICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIGZpeGVkQ2FjaGVLZXlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgW2Rpc3BhdGNoLCBmaXhlZENhY2hlS2V5LCBwcm9taXNlLCByZXF1ZXN0SWRdKTtcbiAgICAgIGNvbnN0IGRlYnVnVmFsdWUgPSBwaWNrKGN1cnJlbnRTdGF0ZSwgLi4uQ09NTU9OX0hPT0tfREVCVUdfRklFTERTLCAnZW5kcG9pbnROYW1lJyk7XG4gICAgICB1c2VEZWJ1Z1ZhbHVlKGRlYnVnVmFsdWUpO1xuICAgICAgY29uc3QgZmluYWxTdGF0ZSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgLi4uY3VycmVudFN0YXRlLFxuICAgICAgICBvcmlnaW5hbEFyZ3MsXG4gICAgICAgIHJlc2V0XG4gICAgICB9KSwgW2N1cnJlbnRTdGF0ZSwgb3JpZ2luYWxBcmdzLCByZXNldF0pO1xuICAgICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gW3RyaWdnZXJNdXRhdGlvbiwgZmluYWxTdGF0ZV0gYXMgY29uc3QsIFt0cmlnZ2VyTXV0YXRpb24sIGZpbmFsU3RhdGVdKTtcbiAgICB9O1xuICB9XG59IiwiZXhwb3J0IGNvbnN0IFVOSU5JVElBTElaRURfVkFMVUUgPSBTeW1ib2woKTtcbmV4cG9ydCB0eXBlIFVuaW5pdGlhbGl6ZWRWYWx1ZSA9IHR5cGVvZiBVTklOSVRJQUxJWkVEX1ZBTFVFOyIsImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHR5cGUgeyBTZXJpYWxpemVRdWVyeUFyZ3MgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0L3F1ZXJ5JztcbmltcG9ydCB0eXBlIHsgRW5kcG9pbnREZWZpbml0aW9uIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeSc7XG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlUXVlcnlBcmdzPFQ+KHF1ZXJ5QXJnczogVCwgc2VyaWFsaXplOiBTZXJpYWxpemVRdWVyeUFyZ3M8YW55PiwgZW5kcG9pbnREZWZpbml0aW9uOiBFbmRwb2ludERlZmluaXRpb248YW55LCBhbnksIGFueSwgYW55PiwgZW5kcG9pbnROYW1lOiBzdHJpbmcpIHtcbiAgY29uc3QgaW5jb21pbmcgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgcXVlcnlBcmdzLFxuICAgIHNlcmlhbGl6ZWQ6IHR5cGVvZiBxdWVyeUFyZ3MgPT0gJ29iamVjdCcgPyBzZXJpYWxpemUoe1xuICAgICAgcXVlcnlBcmdzLFxuICAgICAgZW5kcG9pbnREZWZpbml0aW9uLFxuICAgICAgZW5kcG9pbnROYW1lXG4gICAgfSkgOiBxdWVyeUFyZ3NcbiAgfSksIFtxdWVyeUFyZ3MsIHNlcmlhbGl6ZSwgZW5kcG9pbnREZWZpbml0aW9uLCBlbmRwb2ludE5hbWVdKTtcbiAgY29uc3QgY2FjaGUgPSB1c2VSZWYoaW5jb21pbmcpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjYWNoZS5jdXJyZW50LnNlcmlhbGl6ZWQgIT09IGluY29taW5nLnNlcmlhbGl6ZWQpIHtcbiAgICAgIGNhY2hlLmN1cnJlbnQgPSBpbmNvbWluZztcbiAgICB9XG4gIH0sIFtpbmNvbWluZ10pO1xuICByZXR1cm4gY2FjaGUuY3VycmVudC5zZXJpYWxpemVkID09PSBpbmNvbWluZy5zZXJpYWxpemVkID8gY2FjaGUuY3VycmVudC5xdWVyeUFyZ3MgOiBxdWVyeUFyZ3M7XG59IiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBzaGFsbG93RXF1YWwgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5leHBvcnQgZnVuY3Rpb24gdXNlU2hhbGxvd1N0YWJsZVZhbHVlPFQ+KHZhbHVlOiBUKSB7XG4gIGNvbnN0IGNhY2hlID0gdXNlUmVmKHZhbHVlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNoYWxsb3dFcXVhbChjYWNoZS5jdXJyZW50LCB2YWx1ZSkpIHtcbiAgICAgIGNhY2hlLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG4gIH0sIFt2YWx1ZV0pO1xuICByZXR1cm4gc2hhbGxvd0VxdWFsKGNhY2hlLmN1cnJlbnQsIHZhbHVlKSA/IGNhY2hlLmN1cnJlbnQgOiB2YWx1ZTtcbn0iLCJpbXBvcnQgeyBjb25maWd1cmVTdG9yZSwgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IHR5cGUgeyBDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIHsgUmVhY3RSZWR1eENvbnRleHRWYWx1ZSB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IFByb3ZpZGVyLCBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IHNldHVwTGlzdGVuZXJzIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdC9xdWVyeSc7XG5pbXBvcnQgdHlwZSB7IEFwaSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnknO1xuXG4vKipcbiAqIENhbiBiZSB1c2VkIGFzIGEgYFByb3ZpZGVyYCBpZiB5b3UgKipkbyBub3QgYWxyZWFkeSBoYXZlIGEgUmVkdXggc3RvcmUqKi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiAvLyBjb2RlYmxvY2stbWV0YSBuby10cmFuc3BpbGUgdGl0bGU9XCJCYXNpYyB1c2FnZSAtIHdyYXAgeW91ciBBcHAgd2l0aCBBcGlQcm92aWRlclwiXG4gKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG4gKiBpbXBvcnQgeyBBcGlQcm92aWRlciB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQvcXVlcnkvcmVhY3QnO1xuICogaW1wb3J0IHsgUG9rZW1vbiB9IGZyb20gJy4vZmVhdHVyZXMvUG9rZW1vbic7XG4gKlxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICByZXR1cm4gKFxuICogICAgIDxBcGlQcm92aWRlciBhcGk9e2FwaX0+XG4gKiAgICAgICA8UG9rZW1vbiAvPlxuICogICAgIDwvQXBpUHJvdmlkZXI+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrc1xuICogVXNpbmcgdGhpcyB0b2dldGhlciB3aXRoIGFuIGV4aXN0aW5nIHJlZHV4IHN0b3JlLCBib3RoIHdpbGxcbiAqIGNvbmZsaWN0IHdpdGggZWFjaCBvdGhlciAtIHBsZWFzZSB1c2UgdGhlIHRyYWRpdGlvbmFsIHJlZHV4IHNldHVwXG4gKiBpbiB0aGF0IGNhc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBBcGlQcm92aWRlcihwcm9wczoge1xuICBjaGlsZHJlbjogYW55O1xuICBhcGk6IEFwaTxhbnksIHt9LCBhbnksIGFueT47XG4gIHNldHVwTGlzdGVuZXJzPzogUGFyYW1ldGVyczx0eXBlb2Ygc2V0dXBMaXN0ZW5lcnM+WzFdIHwgZmFsc2U7XG4gIGNvbnRleHQ/OiBDb250ZXh0PFJlYWN0UmVkdXhDb250ZXh0VmFsdWUgfCBudWxsPjtcbn0pIHtcbiAgY29uc3QgY29udGV4dCA9IHByb3BzLmNvbnRleHQgfHwgUmVhY3RSZWR1eENvbnRleHQ7XG4gIGNvbnN0IGV4aXN0aW5nQ29udGV4dCA9IHVzZUNvbnRleHQoY29udGV4dCk7XG4gIGlmIChleGlzdGluZ0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzUpIDogJ0V4aXN0aW5nIFJlZHV4IGNvbnRleHQgZGV0ZWN0ZWQuIElmIHlvdSBhbHJlYWR5IGhhdmUgYSBzdG9yZSBzZXQgdXAsIHBsZWFzZSB1c2UgdGhlIHRyYWRpdGlvbmFsIFJlZHV4IHNldHVwLicpO1xuICB9XG4gIGNvbnN0IFtzdG9yZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjb25maWd1cmVTdG9yZSh7XG4gICAgcmVkdWNlcjoge1xuICAgICAgW3Byb3BzLmFwaS5yZWR1Y2VyUGF0aF06IHByb3BzLmFwaS5yZWR1Y2VyXG4gICAgfSxcbiAgICBtaWRkbGV3YXJlOiBnRE0gPT4gZ0RNKCkuY29uY2F0KHByb3BzLmFwaS5taWRkbGV3YXJlKVxuICB9KSk7XG4gIC8vIEFkZHMgdGhlIGV2ZW50IGxpc3RlbmVycyBmb3Igb25saW5lL29mZmxpbmUvZm9jdXMvZXRjXG4gIHVzZUVmZmVjdCgoKTogdW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpID0+IHByb3BzLnNldHVwTGlzdGVuZXJzID09PSBmYWxzZSA/IHVuZGVmaW5lZCA6IHNldHVwTGlzdGVuZXJzKHN0b3JlLmRpc3BhdGNoLCBwcm9wcy5zZXR1cExpc3RlbmVycyksIFtwcm9wcy5zZXR1cExpc3RlbmVycywgc3RvcmUuZGlzcGF0Y2hdKTtcbiAgcmV0dXJuIDxQcm92aWRlciBzdG9yZT17c3RvcmV9IGNvbnRleHQ9e2NvbnRleHR9PlxuICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgIDwvUHJvdmlkZXI+O1xufSJdLCJuYW1lcyI6WyJfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJzaGFsbG93RXF1YWwiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VNZW1vIiwic2hhbGxvd0VxdWFsIiwiYXJnIiwicHJvbWlzZSIsIl9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIiwiX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UiLCJ1c2VFZmZlY3QiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FNay9CVSxRQUFRLElBQUksYUFBYTtBTi8rQm5DLFNBQVMsZ0JBQWdCLGtCQUFrQjtBQ0QzQyxTQUFTLFNBQVMsU0FBUyxlQUFlLGVBQWUsZUFBZSxlQUFlLFlBQVksa0JBQWtCO0FBQ3JILFNBQVMsa0JBQWtCLHVCQUF1QjtBS0VsRCxTQUFTLGFBQWEsZUFBZSxhQUFBQyxZQUFXLGlCQUFpQixXQUFBQyxVQUFTLFVBQUFDLFNBQVEsZ0JBQWdCOztBSUxsRyxTQUFTLGdCQUFnQiwwQkFBMEJXLGdDQUErQjs7Ozs7O0FSQTNFLFNBQVMsV0FBVyxHQUFBLEVBQWE7SUFDdEMsT0FBTyxJQUFJLE9BQUEsQ0FBUSxHQUFBLENBQUksQ0FBQyxDQUFBLEVBQUcsR0FBQSxDQUFJLENBQUMsQ0FBQSxDQUFFLFdBQUEsQ0FBWSxDQUFDO0FBQ2pEOztBQ0dPLFNBQVMsZ0JBQWdCLEdBQUEsRUFBdUI7SUFDckQsSUFBSSxRQUFRO0lBQ1osSUFBQSxNQUFXLFFBQVEsSUFBSztRQUN0QjtJQUNGO0lBQ0EsT0FBTztBQUNUOztBQ28wQk8sU0FBUyxrQkFBa0IsQ0FBQSxFQUE4RztJQUM5SSxPQUFPLEVBQUUsSUFBQSxLQUFTLFFBQUEsU0FBQTtBQUNwQjtBQUNPLFNBQVMscUJBQXFCLENBQUEsRUFBaUg7SUFDcEosT0FBTyxFQUFFLElBQUEsS0FBUyxXQUFBLFlBQUE7QUFDcEI7QUFDTyxTQUFTLDBCQUEwQixDQUFBLEVBQTJIO0lBQ25LLE9BQU8sRUFBRSxJQUFBLEtBQVMsZ0JBQUEsaUJBQUE7QUFDcEI7O0FDbjFCTyxTQUFTLFdBQTZCLE1BQUE7SUFBQSxJQUFBLElBQUEsT0FBQSxVQUFBLFFBQUEsT0FBQSxVQUFBLE9BQUEsSUFBQSxPQUFBLFFBQUEsT0FBQSxHQUFBLE9BQUEsTUFBQTtRQUFjLEtBQWQsT0FBQSxLQUFBLFNBQUEsQ0FBQSxLQUFjLEVBQXFDOztJQUM5RixPQUFPLE9BQU8sTUFBQSxDQUFPLFFBQVEsR0FBRyxJQUFJO0FBQ3RDOzs7Ozs7QUVOTyxJQUFNLHNCQUFzQixPQUFPOztBQ0duQyxTQUFTLG1CQUFzQixTQUFBLEVBQWMsU0FBQSxFQUFvQyxrQkFBQSxFQUE0RCxZQUFBLEVBQXNCO0lBQ3hLLE1BQU0sV0FBVyw0S0FBQTtnREFBUSxJQUFBLENBQU87Z0JBQzlCO2dCQUNBLFlBQVksT0FBTyxhQUFhLFdBQVcsVUFBVTtvQkFDbkQ7b0JBQ0E7b0JBQ0E7Z0JBQ0YsQ0FBQyxJQUFJO1lBQ1AsQ0FBQTsrQ0FBSTtRQUFDO1FBQVc7UUFBVztRQUFvQixZQUFZO0tBQUM7SUFDNUQsTUFBTSxRQUFRLDJLQUFBLEVBQU8sUUFBUTtJQUM3QixDQUFBLEdBQUEsNkpBQUEsQ0FBQSxZQUFBO3dDQUFVLE1BQU07WUFDZCxJQUFJLE1BQU0sT0FBQSxDQUFRLFVBQUEsS0FBZSxTQUFTLFVBQUEsRUFBWTtnQkFDcEQsTUFBTSxPQUFBLEdBQVU7WUFDbEI7UUFDRjt1Q0FBRztRQUFDLFFBQVE7S0FBQztJQUNiLE9BQU8sTUFBTSxPQUFBLENBQVEsVUFBQSxLQUFlLFNBQVMsVUFBQSxHQUFhLE1BQU0sT0FBQSxDQUFRLFNBQUEsR0FBWTtBQUN0Rjs7O0FDakJPLFNBQVMsc0JBQXlCLEtBQUEsRUFBVTtJQUNqRCxNQUFNLDBLQUFRUixTQUFBQSxFQUFPLEtBQUs7c0tBQzFCRCxZQUFBQTs0Q0FBVSxNQUFNO1lBQ2QsSUFBSSxFQUFDLCtLQUFBLEVBQWEsTUFBTSxPQUFBLEVBQVMsS0FBSyxHQUFHO2dCQUN2QyxNQUFNLE9BQUEsR0FBVTtZQUNsQjtRQUNGOzJDQUFHO1FBQUMsS0FBSztLQUFDO0lBQ1YsdUtBQU8sZ0JBQUEsRUFBYSxNQUFNLE9BQUEsRUFBUyxLQUFLLElBQUksTUFBTSxPQUFBLEdBQVU7QUFDOUQ7O0FIU0EsSUFBTSxZQUFZLElBQU0sQ0FBQyxDQUFBLENBQUUsT0FBTyxXQUFXLGVBQWUsT0FBTyxPQUFPLFFBQUEsS0FBYSxlQUFlLE9BQU8sT0FBTyxRQUFBLENBQVMsYUFBQSxLQUFrQixXQUFBO0FBQy9JLElBQU0sUUFBdUIsYUFBQSxHQUFBLFVBQVU7QUFJdkMsSUFBTSx5QkFBeUIsSUFBTSxPQUFPLGNBQWMsZUFBZSxVQUFVLE9BQUEsS0FBWTtBQUMvRixJQUFNLGdCQUErQixhQUFBLEdBQUEsdUJBQXVCO0FBQzVELElBQU0sK0JBQStCLElBQU0sU0FBUyw4S0FBZ0Isa0JBQUEsaUtBQWtCRSxZQUFBQTtBQUMvRSxJQUFNLDRCQUEyQyxhQUFBLEdBQUEsNkJBQTZCO0FBZ3pCckYsSUFBTSw4QkFBNEQsQ0FBQSxhQUFZO0lBQzVFLElBQUksU0FBUyxlQUFBLEVBQWlCO1FBQzVCLE9BQU87WUFDTCxHQUFHLFFBQUE7WUFDSCxpQkFBaUI7WUFDakIsWUFBWTtZQUNaLFdBQVcsU0FBUyxJQUFBLEtBQVMsS0FBQSxJQUFZLFFBQVE7WUFDakQsNExBQVEsY0FBQSxDQUFZLE9BQUE7UUFDdEI7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVMsS0FBMkIsR0FBQTtJQUFBLElBQUEsSUFBQSxPQUFBLFVBQUEsUUFBVyxBQUFYLE9BQUEsVUFBQSxPQUFBLElBQUEsT0FBQSxRQUFBLE9BQUEsR0FBQSxPQUFBLE1BQUE7YUFBQSxPQUFBLEtBQUEsU0FBQSxDQUFBLEtBQVcsRUFBdUI7O0lBQ3BFLE1BQU0sTUFBVyxDQUFDO0lBQ2xCLEtBQUssT0FBQSxDQUFRLENBQUEsUUFBTztRQUNsQixHQUFBLENBQUksR0FBRyxDQUFBLEdBQUksR0FBQSxDQUFJLEdBQUcsQ0FBQTtJQUNwQixDQUFDO0lBQ0QsT0FBTztBQUNUO0FBQ0EsSUFBTSwyQkFBMkI7SUFBQztJQUFRO0lBQVU7SUFBYTtJQUFhO0lBQVcsT0FBTztDQUFBO0FBV3pGLFNBQVMsZ0JBY2hCLEVBS0c7VUFsQkQsR0FBQSxFQUNBLGVBQWUsRUFDYixLQUFBLEVBQ0EsT0FBTyxFQUNMLFdBQUEsRUFDQSxXQUFBLEVBQ0EsUUFBQSxFQUNGLEVBQ0EsNkJBQUEsRUFDQSxjQUFBLEVBQ0YsRUFDQSxrQkFBQSxFQUNBLE9BQUEsRUFDRixHQWRvRTtJQW9CbEUsTUFBTSw2QkFBOEYsZ0NBQWdDLENBQUEsS0FBTSxHQUFHLElBQUlBLDBLQUFBQTtJQUNqSixPQUFPO1FBQ0w7UUFDQTtRQUNBO1FBQ0E7SUFDRjs7O0lBQ0EsU0FBUyxzQkFBc0IsWUFBQSxFQUE4QyxVQUFBLEVBQXlELFNBQUEsRUFBaUQ7UUFJckwsNEJBQUksNENBQVksWUFBQSxLQUFnQixhQUFhLGVBQUEsRUFBaUI7WUFDNUQsTUFBTSxFQUNKLFlBQUEsRUFDRixHQUFJO1lBQ0osTUFBTSxxQkFBcUIsUUFBUSxtQkFBQSxDQUFvQixZQUFZLENBQUE7WUFDbkUsSUFBSSxjQUFjLGdNQUFBLElBQWEsbUJBQW1CO2dCQUNoRCxXQUFXLFdBQVcsWUFBQTtnQkFDdEI7Z0JBQ0E7WUFDRixDQUFDLE1BQU0sbUJBQW1CO2dCQUN4QjtnQkFDQTtnQkFDQTtZQUNGLENBQUMsRUFBRyxDQUFBLGFBQWEsS0FBQTtRQUNuQjtRQUdBLElBQUksT0FBTyxhQUFhLFNBQUEsR0FBWSxhQUFhLElBQUEsMkRBQU8sV0FBWSxJQUFBO1FBQ3BFLElBQUksU0FBUyxLQUFBLEVBQVcsQ0FBQSxPQUFPLGFBQWEsSUFBQTtRQUM1QyxNQUFNLFVBQVUsU0FBUyxLQUFBO1FBR3pCLE1BQU0sYUFBYSxhQUFhLFNBQUE7UUFHaEMsTUFBTSxZQUFBLENBQWEsQ0FBQyxjQUFjLFdBQVcsU0FBQSxJQUFhLFdBQVcsZUFBQSxLQUFvQixDQUFDLFdBQVc7UUFLckcsTUFBTSxZQUFZLGFBQWEsU0FBQSxJQUFhLFdBQUEsQ0FBWSxjQUFjLDBEQUFDLFdBQVksT0FBQSxLQUFXLGFBQWEsZUFBQTtRQUMzRyxPQUFPO1lBQ0wsR0FBRyxZQUFBO1lBQ0g7WUFDQSxhQUFhLGFBQWEsSUFBQTtZQUMxQjtZQUNBO1lBQ0E7UUFDRjtJQUNGO0lBQ0EsU0FBUyw4QkFBOEIsWUFBQSxFQUFzRCxVQUFBLEVBQWlFLFNBQUEsRUFBeUQ7UUFJck4sNkRBQUksV0FBWSxZQUFBLEtBQWdCLGFBQWEsZUFBQSxFQUFpQjtZQUM1RCxNQUFNLEVBQ0osWUFBQSxFQUNGLEdBQUk7WUFDSixNQUFNLHFCQUFxQixRQUFRLG1CQUFBLENBQW9CLFlBQVksQ0FBQTtZQUNuRSxJQUFJLGtNQUFjLFlBQUEsSUFBYSxtQkFBbUI7Z0JBQ2hELFdBQVcsV0FBVyxZQUFBO2dCQUN0QjtnQkFDQTtZQUNGLENBQUMsTUFBTSxtQkFBbUI7Z0JBQ3hCO2dCQUNBO2dCQUNBO1lBQ0YsQ0FBQyxFQUFHLENBQUEsYUFBYSxLQUFBO1FBQ25CO1FBR0EsSUFBSSxPQUFPLGFBQWEsU0FBQSxHQUFZLGFBQWEsSUFBQSwyREFBTyxXQUFZLElBQUE7UUFDcEUsSUFBSSxTQUFTLEtBQUEsRUFBVyxDQUFBLE9BQU8sYUFBYSxJQUFBO1FBQzVDLE1BQU0sVUFBVSxTQUFTLEtBQUE7UUFHekIsTUFBTSxhQUFhLGFBQWEsU0FBQTtRQUVoQyxNQUFNLFlBQUEsQ0FBYSxDQUFDLGNBQWMsV0FBVyxTQUFBLElBQWEsV0FBVyxlQUFBLEtBQW9CLENBQUMsV0FBVztRQUVyRyxNQUFNLFlBQVksYUFBYSxTQUFBLElBQWEsY0FBYztRQUMxRCxPQUFPO1lBQ0wsR0FBRyxZQUFBO1lBQ0g7WUFDQSxhQUFhLGFBQWEsSUFBQTtZQUMxQjtZQUNBO1lBQ0E7UUFDRjtJQUNGO0lBQ0EsU0FBUyxZQUF5RCxZQUFBLEVBQTRCLGNBQUEsRUFBa0M7UUFDOUgsTUFBTSxXQUFXLFlBQW9EO1FBQ3JFLE1BQU0sdUJBQXVCLHNCQUFzQixjQUFjO1FBQ2pFLHlLQUFPLGNBQUE7a0RBQVksQ0FBQyxLQUFVLFVBQThCLFNBQVUsSUFBSSxJQUFBLENBQUssUUFBQSxDQUFrQyxjQUFjLEtBQUs7b0JBQ2xJLEdBQUcsb0JBQUE7b0JBQ0gsR0FBRyxPQUFBO2dCQUNMLENBQUMsQ0FBQztpREFBRztZQUFDO1lBQWM7WUFBVSxvQkFBb0I7U0FBQztJQUNyRDtJQUNBLFNBQVMsK0JBQWdILFlBQUEsRUFBc0IsR0FBQTtjQUM3SSxrQkFBQSxFQUNBLGNBQUEsRUFDQSx5QkFBQSxFQUNBLE9BQU8sS0FBQSxFQUNQLGtCQUFrQixDQUFBLEVBQ2xCLHlCQUF5QixLQUFBLEVBQ3pCLEdBQUcsTUFDTCxHQVJ5SyxpRUFReEksQ0FBQyxHQUFHO1FBQ25DLE1BQU0sRUFDSixRQUFBLEVBQ0YsR0FBSSxJQUFJLFNBQUEsQ0FBVSxZQUFZLENBQUE7UUFDOUIsTUFBTSxXQUFXLFlBQW9EO1FBR3JFLE1BQU0sNEJBQTJCQywwS0FBQUEsRUFBMEMsS0FBQSxDQUFTO1FBQ3BGLElBQUksQ0FBQyx5QkFBeUIsT0FBQSxFQUFTO1lBQ3JDLE1BQU0sZ0JBQWdCLFNBQVMsSUFBSSxlQUFBLENBQWdCLDZCQUFBLENBQThCLENBQUM7WUFDbEYsd0NBQTJDO2dCQUN6QyxJQUFJLE9BQU8sa0JBQWtCLFlBQVksc0VBQU8sY0FBZSxJQUFBLE1BQVMsVUFBVTtvQkFDaEYsTUFBTSxJQUFJLE1BQU0sUUFBUSxJQUFJLGFBQWEsYUFBZSx3QkFBd0IsRUFBRSxBQUFJLHlEQUF3RSxPQUFmLElBQUksV0FBVyxFQUFBO2dCQUVoSztZQUNGO1lBQ0EseUJBQXlCLE9BQUEsR0FBVTtRQUNyQztRQUNBLE1BQU0sWUFBWSxtQkFBbUIsMkxBQU8sWUFBQSxHQUFZLEtBQUEscUVBQUE7UUFBQSx3RUFBQTtRQUFBLDBFQUFBO1FBQUEsNkVBQUE7UUFBQSwrQ0FBQTs0TEFNeEQsNEJBQUEsRUFBMkIsUUFBUSxtQkFBQSxDQUFvQixZQUFZLENBQUEsRUFBRztRQUN0RSxNQUFNLDRCQUE0QixzQkFBc0I7WUFDdEQ7WUFDQTtZQUNBO1lBQ0E7UUFDRixDQUFDO1FBQ0QsTUFBTSxtQkFBb0IsS0FBa0QsZ0JBQUE7UUFDNUUsTUFBTSx5QkFBeUIsc0JBQXNCLGdCQUFnQjtRQUtyRSxNQUFNLCtLQUFhQSxTQUFBQSxFQUFzQixLQUFBLENBQVM7UUFDbEQsSUFBSSxFQUNGLGFBQUEsRUFDQSxTQUFBLEVBQ0YsR0FBSSxXQUFXLE9BQUEsSUFBVyxDQUFDO1FBSTNCLElBQUksK0JBQStCO1FBQ25DLElBQUksaUJBQWlCLFdBQVc7WUFDOUIsK0JBQStCLHlCQUF5QixPQUFBLENBQVEsbUJBQUEsQ0FBb0IsZUFBZSxTQUFTO1FBQzlHO1FBQ0EsTUFBTSxzQkFBc0IsQ0FBQyxnQ0FBZ0MsV0FBVyxPQUFBLEtBQVksS0FBQTtRQUNwRjtvRkFBMkIsTUFBd0I7Z0JBQ2pELElBQUkscUJBQXFCO29CQUN2QixXQUFXLE9BQUEsR0FBVSxLQUFBO2dCQUN2QjtZQUNGO21GQUFHO1lBQUMsbUJBQW1CO1NBQUM7UUFDeEI7b0ZBQTJCLE1BQXdCO29CQVdqQjtnQkFWaEMsTUFBTSxjQUFjLFdBQVcsT0FBQTtnQkFDL0IsSUFBSSxPQUFPLFlBQVksZUFBZSxRQUFRLElBQUksYUFBYSx5QkFBeUI7O2dCQUl4RixJQUFJLGtNQUFjLFlBQUEsRUFBVztvQkFDM0Isd0JBQUEsa0NBQUEsWUFBYSxXQUFBLENBQVk7b0JBQ3pCLFdBQVcsT0FBQSxHQUFVLEtBQUE7b0JBQ3JCO2dCQUNGO2dCQUNBLE1BQU0sNERBQXFDLE9BQUEsNEVBQVMsbUJBQUE7Z0JBQ3BELElBQUksQ0FBQyxlQUFlLFlBQVksR0FBQSxLQUFRLFdBQVc7b0JBQ2pELHdCQUFBLGtDQUFBLFlBQWEsV0FBQSxDQUFZO29CQUN6QixNQUFNLFVBQVUsU0FBUyxTQUFTLFdBQVc7d0JBQzNDLHFCQUFxQjt3QkFDckIsY0FBYzt3QkFDZCxHQUFJLDBCQUEwQixRQUFRLG1CQUFBLENBQW9CLFlBQVksQ0FBQyxJQUFJOzRCQUN6RSxrQkFBa0I7d0JBQ3BCLElBQUksQ0FBQyxDQUFBO29CQUNQLENBQUMsQ0FBQztvQkFDRixXQUFXLE9BQUEsR0FBVTtnQkFDdkIsT0FBQSxJQUFXLDhCQUE4Qix5QkFBeUI7b0JBQ2hFLFlBQVkseUJBQUEsQ0FBMEIseUJBQXlCO2dCQUNqRTtZQUNGO21GQUFHO1lBQUM7WUFBVTtZQUFVO1lBQTJCO1lBQVc7WUFBMkI7WUFBcUI7WUFBd0IsWUFBWTtTQUFDO1FBQ25KLE9BQU87WUFBQztZQUFZO1lBQVU7WUFBVSx5QkFBeUI7U0FBQTtJQUNuRTtJQUNBLFNBQVMsbUJBQW1CLFlBQUEsRUFBc0IsV0FBQSxFQUFrRjtRQUNsSSxNQUFNLGdCQUFnQixTQUFDO2dCQUFVLEVBQy9CLE9BQU8sS0FBQSxFQUNQLGdCQUFBLEVBQ0Ysb0VBQTZFLENBQUMsTUFBTTtZQUNsRixNQUFNLEVBQ0osTUFBQSxFQUNGLEdBQUksSUFBSSxTQUFBLENBQVUsWUFBWSxDQUFBO1lBQzlCLE1BQU0sWUFBWSxtQkFBbUIsMkxBQU8sWUFBQSxHQUFZLEtBQUssb0JBQW9CLFFBQVEsbUJBQUEsQ0FBb0IsWUFBWSxDQUFBLEVBQUcsWUFBWTtZQUV4SSxNQUFNLDhLQUFZQSxTQUFBQSxFQUFZLEtBQUEsQ0FBUztZQUN2QyxNQUFNLHdMQUEwREMsVUFBQUE7NkZBQVEsSUFBQSwrREFBQTtvQkFBQSw4REFBQTtvQkFBQSwyQ0FBQTtvQkFBQSxhQUFBO29CQUt4RSxlQUFlO3dCQUFBLGFBQUE7d0JBRWYsT0FBTyxTQUFTOzt5R0FBRyxDQUFDLEdBQWlCLGFBQW9COzs7eUdBQVksQ0FBQyxJQUFvQjs7cUJBQVMsRUFBRyxhQUFhO3dCQUNqSCxnQkFBZ0I7NEJBQ2QsaUxBQXFCQyxnQkFBQUE7d0JBQ3ZCO29CQUNGLENBQUM7NEZBQUc7Z0JBQUM7Z0JBQVEsU0FBUzthQUFDO1lBQ3ZCLE1BQU0sa0xBQW9ERCxVQUFBQTt1RkFBUSxJQUFNLG1CQUFtQixlQUFlO3dCQUFDLG1CQUFtQjtxQkFBQSxFQUFHLGtCQUFrQjt3QkFDakosZUFBZTs0QkFDYix1QkFBdUI7d0JBQ3pCO29CQUNGLENBQUMsSUFBSTtzRkFBcUI7Z0JBQUM7Z0JBQXFCLGdCQUFnQjthQUFDO1lBQ2pFLE1BQU0sZUFBZTt5RkFBWSxDQUFDLFFBQTRDLGNBQWMsT0FBTyxVQUFVLE9BQU87cVBBQUdDLGVBQVk7WUFDbkksTUFBTSxRQUFRLFNBQTJDO1lBQ3pELE1BQU0sZUFBZSxvQkFBb0IsTUFBTSxRQUFBLENBQVMsR0FBRyxVQUFVLE9BQU87WUFDNUU7eUZBQTBCLE1BQU07b0JBQzlCLFVBQVUsT0FBQSxHQUFVO2dCQUN0Qjt3RkFBRztnQkFBQyxZQUFZO2FBQUM7WUFDakIsT0FBTztRQUNUO1FBQ0EsT0FBTztJQUNUO0lBQ0EsU0FBUyxrQ0FBa0MsVUFBQSxFQUUzQjswS0FDZEgsWUFBQUE7dUVBQVUsTUFBTTtnQkFDZDsrRUFBTyxNQUFNOzRCQUNYLGlDQUFBO3lCQUFBLHNCQUFBLFdBQVcsT0FBQSxjQUFYLDJDQUFBLGtDQUFBLG9CQUFvQixXQUFBLEdBQWMsV0FBbEMsc0RBQUEscUNBQUE7d0JBR0MsV0FBVyxPQUFBLEdBQWtCLEtBQUE7b0JBQ2hDOztZQUNGO3NFQUFHO1lBQUMsVUFBVTtTQUFDO0lBQ2pCO0lBQ0EsU0FBUywwQkFBMkcsVUFBQSxFQUErQztRQUNqSyxJQUFJLENBQUMsV0FBVyxPQUFBLENBQVMsQ0FBQSxNQUFNLElBQUksTUFBTSxRQUFRLElBQUksYUFBYSxhQUFlLHlCQUF5QixDQUFNLENBQUosc0RBQTJEO1FBQ3ZLLE9BQU8sV0FBVyxPQUFBLENBQVEsT0FBQSxDQUFRO0lBQ3BDO0lBQ0EsU0FBUyxnQkFBZ0IsWUFBQSxFQUF1QztRQUM5RCxNQUFNLHVCQUFrRCxTQUFDO2dCQUFVLDJFQUFVLENBQUMsTUFBTTtZQUNsRixNQUFNLENBQUMsVUFBVSxDQUFBLEdBQUksK0JBQThELGNBQWMsS0FBSyxPQUFPO1lBQzdHLGtDQUFrQyxVQUFVO1lBQzVDLHlLQUFPRSxVQUFBQTs0RUFBUSxJQUFBLENBQU87d0JBQUE7O1NBQUEsR0FJcEIsT0FBQTt3RkFBUyxJQUFNLDBCQUEwQixVQUFVOztvQkFDckQsQ0FBQTsyRUFBSTtnQkFBQyxVQUFVO2FBQUM7UUFDbEI7UUFDQSxNQUFNLDJCQUEwRDtnQkFBQyxFQUMvRCxrQkFBQSxFQUNBLGNBQUEsRUFDQSxrQkFBa0IsQ0FBQSxFQUNsQix5QkFBeUIsS0FBQSxFQUMzQixvRUFBSSxDQUFDLE1BQU07WUFDVCxNQUFNLEVBQ0osUUFBQSxFQUNGLEdBQUksSUFBSSxTQUFBLENBQVUsWUFBWSxDQUFBO1lBQzlCLE1BQU0sV0FBVyxZQUFvRDtZQUNyRSxNQUFNLENBQUMsS0FBSyxNQUFNLENBQUEscUtBQUksV0FBQSxFQUFjLG1CQUFtQjtZQU12RCxNQUFNLGlCQUFhRCx1S0FBQUEsRUFBa0QsS0FBQSxDQUFTO1lBQzlFLE1BQU0sNEJBQTRCLHNCQUFzQjtnQkFDdEQ7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7WUFDRixDQUFDO1lBQ0Q7a0dBQTJCLE1BQU07d0JBQ0M7b0JBQWhDLE1BQU0sNERBQXFDLE9BQUEsNEVBQVMsbUJBQUE7b0JBQ3BELElBQUksOEJBQThCLHlCQUF5Qjs0QkFDekQ7eUJBQUEsdUJBQUEsV0FBVyxPQUFBLGNBQVgsMkNBQUEscUJBQW9CLHlCQUFBLENBQTBCLHlCQUF5QjtvQkFDekU7Z0JBQ0Y7aUdBQUc7Z0JBQUMseUJBQXlCO2FBQUM7WUFDOUIsTUFBTSwyTEFBeUJBLFNBQUFBLEVBQU8seUJBQXlCO1lBQy9EO2tHQUEyQixNQUFNO29CQUMvQix1QkFBdUIsT0FBQSxHQUFVO2dCQUNuQztpR0FBRztnQkFBQyx5QkFBeUI7YUFBQztZQUM5QixNQUFNLDRLQUFVLGNBQUE7NEZBQVksU0FBVUcsSUFBQUE7MkNBQVUsaUVBQW1CLE9BQU87b0JBQ3hFLElBQUk7b0JBQ0o7b0dBQU0sTUFBTTtnQ0FDVjs2QkFBQSxzQkFBQSxXQUFXLE9BQUEsY0FBWCwwQ0FBQSxvQkFBb0IsV0FBQSxDQUFZOzRCQUNoQyxXQUFXLE9BQUEsR0FBVSxVQUFVLFNBQVMsU0FBU0EsTUFBSztnQ0FDcEQscUJBQXFCLHVCQUF1QixPQUFBO2dDQUM1QyxjQUFjLENBQUM7NEJBQ2pCLENBQUMsQ0FBQzs0QkFDRixPQUFPQSxJQUFHO3dCQUNaLENBQUM7O29CQUNELE9BQU87Z0JBQ1Q7MkZBQUc7Z0JBQUM7Z0JBQVUsUUFBUTthQUFDO1lBQ3ZCLE1BQU0sMEtBQVEsY0FBQTswRkFBWSxNQUFNOztvQkFDOUIsc0NBQWUsT0FBQSx3REFBWCxvQkFBb0IsYUFBQSxFQUFlOzRCQUVwQjt3QkFEakIsU0FBUyxJQUFJLGVBQUEsQ0FBZ0IsaUJBQUEsQ0FBa0I7NEJBQzdDLGFBQUEscUNBQTBCLE9BQUEsOEVBQVMsYUFBQTt3QkFDckMsQ0FBQyxDQUFDO29CQUNKO2dCQUNGO3lGQUFHO2dCQUFDLFFBQVE7YUFBQzs4S0FHYkosWUFBQUE7a0ZBQVUsTUFBTTtvQkFDZDswRkFBTyxNQUFNO2dDQUNYOzRCQUFBLHVCQUFBLGtDQUFBLHNCQUFBLFdBQVksT0FBQSxjQUFaLDBDQUFBLG9CQUFxQixXQUFBLENBQVk7d0JBQ25DOztnQkFDRjtpRkFBRyxDQUFDLENBQUM7OEtBR0xBLFlBQUFBO2tGQUFVLE1BQU07b0JBQ2QsSUFBSSxRQUFRLHVCQUF1QixDQUFDLFdBQVcsT0FBQSxFQUFTO3dCQUN0RCxRQUFRLEtBQUssSUFBSTtvQkFDbkI7Z0JBQ0Y7aUZBQUc7Z0JBQUM7Z0JBQUssT0FBTzthQUFDO1lBQ2pCLHlLQUFPRSxVQUFBQTtnRkFBUSxJQUFNO3dCQUFDO3dCQUFTO3dCQUFLOzRCQUNsQzt3QkFDRixDQUFDO3FCQUFBOytFQUFZO2dCQUFDO2dCQUFTO2dCQUFLLEtBQUs7YUFBQztRQUNwQztRQUNBLE1BQU0sZ0JBQW9DLG1CQUFtQixjQUFjLHFCQUFxQjtRQUNoRyxPQUFPO1lBQ0w7WUFDQTtZQUNBO1lBQ0EsY0FBYSxPQUFBLEVBQVM7Z0JBQ3BCLE1BQU0sQ0FBQyxTQUFTLEtBQUssRUFDbkIsS0FBQSxFQUNELENBQUEsR0FBSSx5QkFBeUIsT0FBTztnQkFDckMsTUFBTSxvQkFBb0IsY0FBYyxLQUFLO29CQUMzQyxHQUFHLE9BQUE7b0JBQ0gsTUFBTSxRQUFRO2dCQUNoQixDQUFDO2dCQUNELE1BQU0seUtBQU9BLFVBQUFBO2lFQUFRLElBQUEsQ0FBTzs0QkFDMUIsU0FBUzt3QkFDWCxDQUFBO2dFQUFJO29CQUFDLEdBQUc7aUJBQUM7Z0JBQ1QsUUFBT0EsMktBQUFBOzJEQUFRLElBQU07NEJBQUM7NEJBQVM7Z0NBQzdCLEdBQUcsaUJBQUE7Z0NBQ0g7NEJBQ0Y7NEJBQUcsSUFBSTt5QkFBQTswREFBRztvQkFBQztvQkFBUztvQkFBbUI7b0JBQU8sSUFBSTtpQkFBQztZQUNyRDtZQUNBLFVBQVMsR0FBQSxFQUFLLE9BQUEsRUFBUztnQkFDckIsTUFBTSwyQkFBMkIscUJBQXFCLEtBQUssT0FBTztnQkFDbEUsTUFBTSxvQkFBb0IsY0FBYyxLQUFLO29CQUMzQyxrQkFBa0IsNExBQVEsWUFBQSx1REFBYSxRQUFTLElBQUEsSUFBTyxLQUFBLElBQVk7b0JBQ25FLEdBQUcsT0FBQTtnQkFDTCxDQUFDO2dCQUNELE1BQU0sYUFBYSxLQUFLLG1CQUFtQixHQUFHLHdCQUF3QjtnQkFDdEUsQ0FBQSxHQUFBLDZKQUFBLENBQUEsZ0JBQUEsRUFBYyxVQUFVO2dCQUN4QixRQUFPQSwyS0FBQUE7MkRBQVEsSUFBQSxDQUFPOzRCQUNwQixHQUFHLGlCQUFBOzRCQUNILEdBQUcsd0JBQUE7d0JBQ0wsQ0FBQTswREFBSTtvQkFBQztvQkFBbUIsd0JBQXdCO2lCQUFDO1lBQ25EO1FBQ0Y7SUFDRjtJQUNBLFNBQVMsd0JBQXdCLFlBQUEsRUFBK0M7UUFDOUUsTUFBTSwrQkFBa0UsU0FBQztnQkFBVSwyRUFBVSxDQUFDLE1BQU07WUFDbEcsTUFBTSxDQUFDLFlBQVksVUFBVSxVQUFVLHlCQUF5QixDQUFBLEdBQUksK0JBQXNFLGNBQWMsS0FBSyxPQUFPO1lBQ3BLLE1BQU0sMkxBQXlCRCxTQUFBQSxFQUFPLHlCQUF5QjtZQUMvRDs4R0FBMkIsTUFBTTtvQkFDL0IsdUJBQXVCLE9BQUEsR0FBVTtnQkFDbkM7NkdBQUc7Z0JBQUMseUJBQXlCO2FBQUM7WUFDOUIsTUFBTSw0S0FBeUMsY0FBQTt3R0FBWSxTQUFVRyxJQUFBQSxFQUFjLFNBQUEsRUFBbUM7b0JBQ3BILElBQUk7b0JBQ0o7Z0hBQU0sTUFBTTtnQ0FDVjs2QkFBQSxzQkFBQSxXQUFXLE9BQUEsY0FBWCwwQ0FBQSxvQkFBb0IsV0FBQSxDQUFZOzRCQUNoQyxXQUFXLE9BQUEsR0FBVSxVQUFVLFNBQVUsU0FBa0RBLE1BQUs7Z0NBQzlGLHFCQUFxQix1QkFBdUIsT0FBQTtnQ0FDNUM7NEJBQ0YsQ0FBQyxDQUFDO3dCQUNKLENBQUM7O29CQUNELE9BQU87Z0JBQ1Q7dUdBQUc7Z0JBQUM7Z0JBQVk7Z0JBQVUsUUFBUTthQUFDO1lBQ25DLGtDQUFrQyxVQUFVO1lBQzVDLE1BQU0sWUFBWSxtQkFBbUIsUUFBUSxJQUFBLHVMQUFPLFlBQUEsR0FBWSxLQUFBLHFFQUFBO1lBQUEsd0VBQUE7WUFBQSwwRUFBQTtZQUFBLDZFQUFBO1lBQUEsK0NBQUE7K0xBTWhFLDZCQUFBLEVBQTJCLFFBQVEsbUJBQUEsQ0FBb0IsWUFBWSxDQUFBLEVBQUc7WUFDdEUsTUFBTSw0S0FBVSxjQUFBO3dHQUFZLElBQU0sMEJBQTBCLFVBQVU7dUdBQUc7Z0JBQUMsVUFBVTthQUFDO1lBQ3JGLE9BQU9GLDRLQUFBQTs0RkFBUSxNQUFNO29CQUNuQixNQUFNO2tIQUFnQixNQUFNOzRCQUMxQixPQUFPLFFBQVEsV0FBVyxTQUFTO3dCQUNyQzs7b0JBQ0EsTUFBTTtzSEFBb0IsTUFBTTs0QkFDOUIsT0FBTyxRQUFRLFdBQVcsVUFBVTt3QkFDdEM7O29CQUNBLE9BQU87d0JBQ0w7d0JBQUE7O1dBQUEsR0FJQTt3QkFDQTt3QkFDQTtvQkFDRjtnQkFDRjsyRkFBRztnQkFBQztnQkFBUztnQkFBUyxTQUFTO2FBQUM7UUFDbEM7UUFDQSxNQUFNLHdCQUFvRCxtQkFBbUIsY0FBYyw2QkFBNkI7UUFDeEgsT0FBTztZQUNMO1lBQ0E7WUFDQSxrQkFBaUIsR0FBQSxFQUFLLE9BQUEsRUFBUztnQkFDN0IsTUFBTSxFQUNKLE9BQUEsRUFDQSxhQUFBLEVBQ0EsaUJBQUEsRUFDRixHQUFJLDZCQUE2QixLQUFLLE9BQU87Z0JBQzdDLE1BQU0sb0JBQW9CLHNCQUFzQixLQUFLO29CQUNuRCxrQkFBa0IsNExBQVEsWUFBQSx1REFBYSxRQUFTLElBQUEsSUFBTyxLQUFBLElBQVk7b0JBQ25FLEdBQUcsT0FBQTtnQkFDTCxDQUFDO2dCQUNELE1BQU0sYUFBYSxLQUFLLG1CQUFtQixHQUFHLDBCQUEwQixlQUFlLGlCQUFpQjtnQkFDeEcsQ0FBQSxHQUFBLDZKQUFBLENBQUEsZ0JBQUEsRUFBYyxVQUFVO2dCQUN4QixPQUFPQSw0S0FBQUE7bUVBQVEsSUFBQSxDQUFPOzRCQUNwQixHQUFHLGlCQUFBOzRCQUNIOzRCQUNBOzRCQUNBO3dCQUNGLENBQUE7a0VBQUk7b0JBQUM7b0JBQW1CO29CQUFlO29CQUFtQixPQUFPO2lCQUFDO1lBQ3BFO1FBQ0Y7SUFDRjtJQUNBLFNBQVMsa0JBQWtCLElBQUEsRUFBZ0M7UUFDekQsT0FBTztnQkFBQyxFQUNOLGdCQUFBLEVBQ0EsYUFBQSxFQUNGLG9FQUFJLENBQUMsTUFBTTtZQUNULE1BQU0sRUFDSixNQUFBLEVBQ0EsUUFBQSxFQUNGLEdBQUksSUFBSSxTQUFBLENBQVUsSUFBSSxDQUFBO1lBQ3RCLE1BQU0sV0FBVyxZQUFvRDtZQUNyRSxNQUFNLENBQUMsU0FBUyxVQUFVLENBQUEsSUFBSSw0S0FBQSxDQUEyQzs4S0FDekVGLFlBQUFBOzJEQUFVO21FQUFNLE1BQU07NEJBQ3BCLElBQUksb0RBQUMsUUFBUyxHQUFBLENBQUksYUFBQSxHQUFlO2dDQUMvQixvQkFBQSw4QkFBQSxRQUFTLEtBQUEsQ0FBTTs0QkFDakI7d0JBQ0Y7OzBEQUFHO2dCQUFDLE9BQU87YUFBQztZQUNaLE1BQU0sbUJBQWtCLCtLQUFBOzZFQUFZLFNBQVUsR0FBQSxFQUF1QztvQkFDbkYsTUFBTUssV0FBVSxTQUFTLFNBQVMsS0FBSzt3QkFDckM7b0JBQ0YsQ0FBQyxDQUFDO29CQUNGLFdBQVdBLFFBQU87b0JBQ2xCLE9BQU9BO2dCQUNUOzRFQUFHO2dCQUFDO2dCQUFVO2dCQUFVLGFBQWE7YUFBQztZQUN0QyxNQUFNLEVBQ0osU0FBQSxFQUNGLEdBQUksV0FBVyxDQUFDO1lBQ2hCLE1BQU0sdUJBQXNCSCwyS0FBQUE7OEVBQVEsSUFBTSxPQUFPO3dCQUMvQzt3QkFDQSxTQUFBLG9EQUFXLFFBQVMsU0FBQTtvQkFDdEIsQ0FBQzs2RUFBRztnQkFBQztnQkFBZTtnQkFBUyxNQUFNO2FBQUM7WUFDcEMsTUFBTSxxTEFBbUJBLFVBQUFBOzJFQUFRLElBQXVELG1CQUFtQixlQUFlO3dCQUFDLG1CQUFtQjtxQkFBQSxFQUFHLGdCQUFnQixJQUFJOzBFQUFxQjtnQkFBQztnQkFBa0IsbUJBQW1CO2FBQUM7WUFDak8sTUFBTSxlQUFlLFlBQVksK0tBQWtCQyxlQUFZO1lBQy9ELE1BQU0sZUFBZSxpQkFBaUIseURBQU8sUUFBUyxHQUFBLENBQUksWUFBQSxHQUFlLEtBQUE7WUFDekUsTUFBTSwwS0FBUSxjQUFBO21FQUFZLE1BQU07b0JBQzlCOzJFQUFNLE1BQU07NEJBQ1YsSUFBSSxTQUFTO2dDQUNYLFdBQVcsS0FBQSxDQUFTOzRCQUN0Qjs0QkFDQSxJQUFJLGVBQWU7Z0NBQ2pCLFNBQVMsSUFBSSxlQUFBLENBQWdCLG9CQUFBLENBQXFCO29DQUNoRDtvQ0FDQTtnQ0FDRixDQUFDLENBQUM7NEJBQ0o7d0JBQ0YsQ0FBQzs7Z0JBQ0g7a0VBQUc7Z0JBQUM7Z0JBQVU7Z0JBQWU7Z0JBQVMsU0FBUzthQUFDO1lBQ2hELE1BQU0sYUFBYSxLQUFLLGNBQWMsR0FBRywwQkFBMEIsY0FBYztZQUNqRixDQUFBLEdBQUEsNkpBQUEsQ0FBQSxnQkFBQSxFQUFjLFVBQVU7WUFDeEIsTUFBTSxpQkFBYUQsd0tBQUFBO3FFQUFRLElBQUEsQ0FBTzt3QkFDaEMsR0FBRyxZQUFBO3dCQUNIO3dCQUNBO29CQUNGLENBQUE7b0VBQUk7Z0JBQUM7Z0JBQWM7Z0JBQWMsS0FBSzthQUFDO1lBQ3ZDLFFBQU9BLDJLQUFBQTt5REFBUSxJQUFNO3dCQUFDO3dCQUFpQixVQUFVO3FCQUFBO3dEQUFZO2dCQUFDO2dCQUFpQixVQUFVO2FBQUM7UUFDNUY7SUFDRjtBQUNGOztBTDExQ08sSUFBTSx1QkFBc0MsYUFBQSxHQUFBLE9BQU87QUEwRm5ELElBQU0sbUJBQW1CO1FBQUMsRUFDL0IscUtBQVEsUUFBQSxFQUNSLFFBQVE7UUFDTiwwS0FBYSxjQUFBO1FBQ2IseUtBQWEsZUFBQTtRQUNiLHVLQUFVLFdBQUE7SUFDWixDQUFBLEVBQ0Esa0tBQWlCLGlCQUFBLEVBQ2pCLGdDQUFnQyxLQUFBLEVBQ2hDLEdBQUcsTUFDTCxvRUFBNkIsQ0FBQyxNQUFnQztJQUM1RCxJQUFJLFFBQVEsSUFBSSxhQUFhLFdBQWM7UUFDekMsTUFBTSxZQUFZO1lBQUM7WUFBZTtZQUFlLFVBQVU7U0FBQTtRQUMzRCxJQUFJLFNBQVM7UUFDYixLQUFBLE1BQVcsWUFBWSxVQUFXO1lBRWhDLElBQUksZ0JBQWdCLElBQUksSUFBSSxHQUFHO2dCQUM3QixJQUFLLElBQUEsQ0FBK0IsUUFBUSxDQUFBLEVBQUc7b0JBQzdDLElBQUksQ0FBQyxRQUFRO3dCQUNYLFFBQVEsSUFBQSxDQUFLLHVLQUE0Szt3QkFDekwsU0FBUztvQkFDWDtnQkFDRjtnQkFHQSxLQUFBLENBQU0sUUFBUSxDQUFBLEdBQUksSUFBQSxDQUFLLFFBQVEsQ0FBQTtZQUNqQztZQUVBLElBQUksT0FBTyxLQUFBLENBQU0sUUFBUSxDQUFBLEtBQU0sWUFBWTtnQkFDekMsTUFBTSxJQUFJLE1BQU0sUUFBUSxJQUFJLGFBQWEsYUFBZUkseUJBQXdCLENBQU0sQ0FBSixrREFBZ0QsVUFBVSxNQUFNLEVBQUEsdUNBQStCLFVBQVUsSUFBQSxDQUFLLElBQUksQ0FBQyxFQUFBLFlBQW1CLE9BQVIsUUFBUSxFQUFBLDJCQUE2QztZQUN2UTtRQUNGO0lBQ0Y7SUFDQSxPQUFPO1FBQ0wsTUFBTTtRQUNOLE1BQUssR0FBQSxPQUVMLEVBQUcsT0FBQSxFQUFTO2tCQURWLGtCQUFBLEVBQ0YsR0FGVTtZQUdSLE1BQU0sU0FBUztZQUNmLE1BQU0sRUFDSixlQUFBLEVBQ0EsdUJBQUEsRUFDQSxpQkFBQSxFQUNBLFdBQUEsRUFDRixHQUFJLFdBQVc7Z0JBQ2I7Z0JBQ0EsZUFBZTtvQkFDYjtvQkFDQTtvQkFDQTtvQkFDQTtnQkFDRjtnQkFDQTtnQkFDQTtZQUNGLENBQUM7WUFDRCxXQUFXLFFBQVE7Z0JBQ2pCO1lBQ0YsQ0FBQztZQUNELFdBQVcsU0FBUztnQkFDbEI7WUFDRixDQUFDO1lBQ0QsT0FBTztnQkFDTCxnQkFBZSxZQUFBLEVBQWMsVUFBQSxFQUFZO29CQUN2QyxJQUFJLGtCQUFrQixVQUFVLEdBQUc7d0JBQ2pDLE1BQU0sRUFDSixRQUFBLEVBQ0EsWUFBQSxFQUNBLHdCQUFBLEVBQ0EsYUFBQSxFQUNBLG9CQUFBLEVBQ0YsR0FBSSxnQkFBZ0IsWUFBWTt3QkFDaEMsV0FBVyxPQUFPLFNBQUEsQ0FBVSxZQUFZLENBQUEsRUFBRzs0QkFDekM7NEJBQ0E7NEJBQ0E7NEJBQ0E7NEJBQ0E7d0JBQ0YsQ0FBQzt3QkFDQSxHQUFBLENBQVksTUFBOEIsT0FBeEIsV0FBVyxZQUFZLENBQUMsRUFBQSxNQUFPLEdBQUEsR0FBSTt3QkFDckQsR0FBQSxDQUFZLFVBQWtDLE9BQXhCLFdBQVcsWUFBWSxDQUFDLEVBQUEsTUFBTyxHQUFBLEdBQUk7b0JBQzVEO29CQUNBLElBQUkscUJBQXFCLFVBQVUsR0FBRzt3QkFDcEMsTUFBTSxjQUFjLGtCQUFrQixZQUFZO3dCQUNsRCxXQUFXLE9BQU8sU0FBQSxDQUFVLFlBQVksQ0FBQSxFQUFHOzRCQUN6Qzt3QkFDRixDQUFDO3dCQUNBLEdBQUEsQ0FBWSxNQUE4QixPQUF4QixXQUFXLFlBQVksQ0FBQyxFQUFBLFNBQVUsR0FBQSxHQUFJO29CQUMzRCxPQUFBLElBQVcsMEJBQTBCLFVBQVUsR0FBRzt3QkFDaEQsTUFBTSxFQUNKLGdCQUFBLEVBQ0EsNEJBQUEsRUFDQSxxQkFBQSxFQUNGLEdBQUksd0JBQXdCLFlBQVk7d0JBQ3hDLFdBQVcsT0FBTyxTQUFBLENBQVUsWUFBWSxDQUFBLEVBQUc7NEJBQ3pDOzRCQUNBOzRCQUNBO3dCQUNGLENBQUM7d0JBQ0EsR0FBQSxDQUFZLE1BQThCLE9BQXhCLE9BQXVDLElBQTVCLFlBQVksQ0FBQyxFQUFBLGlCQUFlLEdBQUk7b0JBQ2hFO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7Ozs7Ozs7O0FTMUtPLFNBQVMsWUFBWSxLQUFBLEVBS3pCO0lBQ0QsTUFBTSxVQUFVLE1BQU0sT0FBQSxpS0FBVyxvQkFBQTtJQUNqQyxNQUFNLG1CQUFrQiw4S0FBQSxFQUFXLE9BQU87SUFDMUMsSUFBSSxpQkFBaUI7UUFDbkIsTUFBTSxJQUFJLE1BQU0sUUFBUSxJQUFJLGFBQWEsYUFBZUMseUJBQXdCLENBQU0sQ0FBSiw2R0FBa0g7SUFDdE07SUFDQSxNQUFNLENBQUMsS0FBSyxDQUFBLGlLQUFVLFdBQUE7Z0NBQVMsdU1BQU0saUJBQUEsRUFBZTtnQkFDbEQsU0FBUztvQkFDUCxDQUFDLE1BQU0sR0FBQSxDQUFJLFdBQVcsQ0FBQSxFQUFHLE1BQU0sR0FBQSxDQUFJLE9BQUE7Z0JBQ3JDO2dCQUNBLFVBQUE7NENBQVksQ0FBQSxNQUFPLElBQUksRUFBRSxNQUFBLENBQU8sTUFBTSxHQUFBLENBQUksVUFBVTs7WUFDdEQsQ0FBQyxDQUFDOztLQUVGQyw2S0FBQUE7a0NBQVUsSUFBZ0MsTUFBTSxjQUFBLEtBQW1CLFFBQVEsS0FBQSw0TEFBWSxpQkFBQSxFQUFlLE1BQU0sUUFBQSxFQUFVLE1BQU0sY0FBYztpQ0FBRztRQUFDLE1BQU0sY0FBQTtRQUFnQixNQUFNLFFBQVE7S0FBQztJQUNuTCxPQUFPLGFBQUEsR0FBQSw2SkFBQSxDQUFBLGdCQUFBLDhKQUFDLFdBQUEsRUFBQTtRQUFTO1FBQWM7SUFBQSxHQUMxQixNQUFNLFFBQ1Q7QUFDSjs7QVZqREEsSUFBTSxZQUEyQixhQUFBLEdBQUEsQ0FBQSxHQUFBLG1MQUFBLENBQUEsaUJBQUEsMExBQWUsYUFBQSxDQUFXLElBQUcsaUJBQWlCLENBQUMiLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE3MzcyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsImZpbGUiOiJ0dXJib3BhY2s6Ly8vW3Byb2plY3RdL25vZGVfbW9kdWxlcy9AY2FwYWNpdG9yL2NvcmUvZGlzdC9pbmRleC5qcyIsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzLyU0MGNhcGFjaXRvci9jb3JlL2J1aWxkL3V0aWwuanMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwY2FwYWNpdG9yL2NvcmUvYnVpbGQvcnVudGltZS5qcyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDBjYXBhY2l0b3IvY29yZS9idWlsZC9nbG9iYWwuanMiLCJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvJTQwY2FwYWNpdG9yL2NvcmUvYnVpbGQvd2ViLXBsdWdpbi5qcyIsImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy8lNDBjYXBhY2l0b3IvY29yZS9idWlsZC9jb3JlLXBsdWdpbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBFeGNlcHRpb25Db2RlO1xuKGZ1bmN0aW9uIChFeGNlcHRpb25Db2RlKSB7XG4gICAgLyoqXG4gICAgICogQVBJIGlzIG5vdCBpbXBsZW1lbnRlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgdXN1YWxseSBtZWFucyB0aGUgQVBJIGNhbid0IGJlIHVzZWQgYmVjYXVzZSBpdCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yXG4gICAgICogdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gICAgICovXG4gICAgRXhjZXB0aW9uQ29kZVtcIlVuaW1wbGVtZW50ZWRcIl0gPSBcIlVOSU1QTEVNRU5URURcIjtcbiAgICAvKipcbiAgICAgKiBBUEkgaXMgbm90IGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWVhbnMgdGhlIEFQSSBjYW4ndCBiZSB1c2VkIHJpZ2h0IG5vdyBiZWNhdXNlOlxuICAgICAqICAgLSBpdCBpcyBjdXJyZW50bHkgbWlzc2luZyBhIHByZXJlcXVpc2l0ZSwgc3VjaCBhcyBuZXR3b3JrIGNvbm5lY3Rpdml0eVxuICAgICAqICAgLSBpdCByZXF1aXJlcyBhIHBhcnRpY3VsYXIgcGxhdGZvcm0gb3IgYnJvd3NlciB2ZXJzaW9uXG4gICAgICovXG4gICAgRXhjZXB0aW9uQ29kZVtcIlVuYXZhaWxhYmxlXCJdID0gXCJVTkFWQUlMQUJMRVwiO1xufSkoRXhjZXB0aW9uQ29kZSB8fCAoRXhjZXB0aW9uQ29kZSA9IHt9KSk7XG5leHBvcnQgY2xhc3MgQ2FwYWNpdG9yRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUsIGRhdGEpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IGdldFBsYXRmb3JtSWQgPSAod2luKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAod2luID09PSBudWxsIHx8IHdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luLmFuZHJvaWRCcmlkZ2UpIHtcbiAgICAgICAgcmV0dXJuICdhbmRyb2lkJztcbiAgICB9XG4gICAgZWxzZSBpZiAoKF9iID0gKF9hID0gd2luID09PSBudWxsIHx8IHdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luLndlYmtpdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lc3NhZ2VIYW5kbGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmJyaWRnZSkge1xuICAgICAgICByZXR1cm4gJ2lvcyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJ3dlYic7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiaW1wb3J0IHsgQ2FwYWNpdG9yRXhjZXB0aW9uLCBnZXRQbGF0Zm9ybUlkLCBFeGNlcHRpb25Db2RlIH0gZnJvbSAnLi91dGlsJztcbmV4cG9ydCBjb25zdCBjcmVhdGVDYXBhY2l0b3IgPSAod2luKSA9PiB7XG4gICAgY29uc3QgY2FwQ3VzdG9tUGxhdGZvcm0gPSB3aW4uQ2FwYWNpdG9yQ3VzdG9tUGxhdGZvcm0gfHwgbnVsbDtcbiAgICBjb25zdCBjYXAgPSB3aW4uQ2FwYWNpdG9yIHx8IHt9O1xuICAgIGNvbnN0IFBsdWdpbnMgPSAoY2FwLlBsdWdpbnMgPSBjYXAuUGx1Z2lucyB8fCB7fSk7XG4gICAgY29uc3QgZ2V0UGxhdGZvcm0gPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBjYXBDdXN0b21QbGF0Zm9ybSAhPT0gbnVsbCA/IGNhcEN1c3RvbVBsYXRmb3JtLm5hbWUgOiBnZXRQbGF0Zm9ybUlkKHdpbik7XG4gICAgfTtcbiAgICBjb25zdCBpc05hdGl2ZVBsYXRmb3JtID0gKCkgPT4gZ2V0UGxhdGZvcm0oKSAhPT0gJ3dlYic7XG4gICAgY29uc3QgaXNQbHVnaW5BdmFpbGFibGUgPSAocGx1Z2luTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBwbHVnaW4gPSByZWdpc3RlcmVkUGx1Z2lucy5nZXQocGx1Z2luTmFtZSk7XG4gICAgICAgIGlmIChwbHVnaW4gPT09IG51bGwgfHwgcGx1Z2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwbHVnaW4ucGxhdGZvcm1zLmhhcyhnZXRQbGF0Zm9ybSgpKSkge1xuICAgICAgICAgICAgLy8gSlMgaW1wbGVtZW50YXRpb24gYXZhaWxhYmxlIGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybS5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRQbHVnaW5IZWFkZXIocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgICAgIC8vIE5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBhdmFpbGFibGUuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBnZXRQbHVnaW5IZWFkZXIgPSAocGx1Z2luTmFtZSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBjYXAuUGx1Z2luSGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbmQoKGgpID0+IGgubmFtZSA9PT0gcGx1Z2luTmFtZSk7IH07XG4gICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoZXJyKSA9PiB3aW4uY29uc29sZS5lcnJvcihlcnIpO1xuICAgIGNvbnN0IHJlZ2lzdGVyZWRQbHVnaW5zID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHJlZ2lzdGVyUGx1Z2luID0gKHBsdWdpbk5hbWUsIGpzSW1wbGVtZW50YXRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJlZFBsdWdpbiA9IHJlZ2lzdGVyZWRQbHVnaW5zLmdldChwbHVnaW5OYW1lKTtcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRQbHVnaW4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ2FwYWNpdG9yIHBsdWdpbiBcIiR7cGx1Z2luTmFtZX1cIiBhbHJlYWR5IHJlZ2lzdGVyZWQuIENhbm5vdCByZWdpc3RlciBwbHVnaW5zIHR3aWNlLmApO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRQbHVnaW4ucHJveHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGxhdGZvcm0gPSBnZXRQbGF0Zm9ybSgpO1xuICAgICAgICBjb25zdCBwbHVnaW5IZWFkZXIgPSBnZXRQbHVnaW5IZWFkZXIocGx1Z2luTmFtZSk7XG4gICAgICAgIGxldCBqc0ltcGxlbWVudGF0aW9uO1xuICAgICAgICBjb25zdCBsb2FkUGx1Z2luSW1wbGVtZW50YXRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWpzSW1wbGVtZW50YXRpb24gJiYgcGxhdGZvcm0gaW4ganNJbXBsZW1lbnRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBqc0ltcGxlbWVudGF0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGpzSW1wbGVtZW50YXRpb25zW3BsYXRmb3JtXSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAoanNJbXBsZW1lbnRhdGlvbiA9IGF3YWl0IGpzSW1wbGVtZW50YXRpb25zW3BsYXRmb3JtXSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoanNJbXBsZW1lbnRhdGlvbiA9IGpzSW1wbGVtZW50YXRpb25zW3BsYXRmb3JtXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjYXBDdXN0b21QbGF0Zm9ybSAhPT0gbnVsbCAmJiAhanNJbXBsZW1lbnRhdGlvbiAmJiAnd2ViJyBpbiBqc0ltcGxlbWVudGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGpzSW1wbGVtZW50YXRpb24gPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YganNJbXBsZW1lbnRhdGlvbnNbJ3dlYiddID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChqc0ltcGxlbWVudGF0aW9uID0gYXdhaXQganNJbXBsZW1lbnRhdGlvbnNbJ3dlYiddKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChqc0ltcGxlbWVudGF0aW9uID0ganNJbXBsZW1lbnRhdGlvbnNbJ3dlYiddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBqc0ltcGxlbWVudGF0aW9uO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjcmVhdGVQbHVnaW5NZXRob2QgPSAoaW1wbCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmIChwbHVnaW5IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRob2RIZWFkZXIgPSBwbHVnaW5IZWFkZXIgPT09IG51bGwgfHwgcGx1Z2luSGVhZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwbHVnaW5IZWFkZXIubWV0aG9kcy5maW5kKChtKSA9PiBwcm9wID09PSBtLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2RIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZEhlYWRlci5ydHlwZSA9PT0gJ3Byb21pc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG9wdGlvbnMpID0+IGNhcC5uYXRpdmVQcm9taXNlKHBsdWdpbk5hbWUsIHByb3AudG9TdHJpbmcoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG9wdGlvbnMsIGNhbGxiYWNrKSA9PiBjYXAubmF0aXZlQ2FsbGJhY2socGx1Z2luTmFtZSwgcHJvcC50b1N0cmluZygpLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW1wbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gaW1wbFtwcm9wXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJpbmQoaW1wbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW1wbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoX2IgPSBpbXBsW3Byb3BdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmluZChpbXBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDYXBhY2l0b3JFeGNlcHRpb24oYFwiJHtwbHVnaW5OYW1lfVwiIHBsdWdpbiBpcyBub3QgaW1wbGVtZW50ZWQgb24gJHtwbGF0Zm9ybX1gLCBFeGNlcHRpb25Db2RlLlVuaW1wbGVtZW50ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjcmVhdGVQbHVnaW5NZXRob2RXcmFwcGVyID0gKHByb3ApID0+IHtcbiAgICAgICAgICAgIGxldCByZW1vdmU7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gbG9hZFBsdWdpbkltcGxlbWVudGF0aW9uKCkudGhlbigoaW1wbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbiA9IGNyZWF0ZVBsdWdpbk1ldGhvZChpbXBsLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gZm4oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUgPSBwID09PSBudWxsIHx8IHAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHAucmVtb3ZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2FwYWNpdG9yRXhjZXB0aW9uKGBcIiR7cGx1Z2luTmFtZX0uJHtwcm9wfSgpXCIgaXMgbm90IGltcGxlbWVudGVkIG9uICR7cGxhdGZvcm19YCwgRXhjZXB0aW9uQ29kZS5VbmltcGxlbWVudGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAnYWRkTGlzdGVuZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHAucmVtb3ZlID0gYXN5bmMgKCkgPT4gcmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFNvbWUgZmxhaXIg4pyoXG4gICAgICAgICAgICB3cmFwcGVyLnRvU3RyaW5nID0gKCkgPT4gYCR7cHJvcC50b1N0cmluZygpfSgpIHsgW2NhcGFjaXRvciBjb2RlXSB9YDtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3cmFwcGVyLCAnbmFtZScsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvcCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZExpc3RlbmVyID0gY3JlYXRlUGx1Z2luTWV0aG9kV3JhcHBlcignYWRkTGlzdGVuZXInKTtcbiAgICAgICAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSBjcmVhdGVQbHVnaW5NZXRob2RXcmFwcGVyKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICBjb25zdCBhZGRMaXN0ZW5lck5hdGl2ZSA9IChldmVudE5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYWxsID0gYWRkTGlzdGVuZXIoeyBldmVudE5hbWUgfSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrSWQgPSBhd2FpdCBjYWxsO1xuICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0lkLFxuICAgICAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IGNhbGwudGhlbigoKSA9PiByZXNvbHZlKHsgcmVtb3ZlIH0pKSk7XG4gICAgICAgICAgICBwLnJlbW92ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVzaW5nIGFkZExpc3RlbmVyKCkgd2l0aG91dCAnYXdhaXQnIGlzIGRlcHJlY2F0ZWQuYCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgICAgICBnZXQoXywgcHJvcCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwMDMwXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyQkdHlwZW9mJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvSlNPTic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gKHt9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWRkTGlzdGVuZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbkhlYWRlciA/IGFkZExpc3RlbmVyTmF0aXZlIDogYWRkTGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlbW92ZUxpc3RlbmVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVMaXN0ZW5lcjtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVQbHVnaW5NZXRob2RXcmFwcGVyKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBQbHVnaW5zW3BsdWdpbk5hbWVdID0gcHJveHk7XG4gICAgICAgIHJlZ2lzdGVyZWRQbHVnaW5zLnNldChwbHVnaW5OYW1lLCB7XG4gICAgICAgICAgICBuYW1lOiBwbHVnaW5OYW1lLFxuICAgICAgICAgICAgcHJveHksXG4gICAgICAgICAgICBwbGF0Zm9ybXM6IG5ldyBTZXQoWy4uLk9iamVjdC5rZXlzKGpzSW1wbGVtZW50YXRpb25zKSwgLi4uKHBsdWdpbkhlYWRlciA/IFtwbGF0Zm9ybV0gOiBbXSldKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm94eTtcbiAgICB9O1xuICAgIC8vIEFkZCBpbiBjb252ZXJ0RmlsZVNyYyBmb3Igd2ViLCBpdCB3aWxsIGFscmVhZHkgYmUgYXZhaWxhYmxlIGluIG5hdGl2ZSBjb250ZXh0XG4gICAgaWYgKCFjYXAuY29udmVydEZpbGVTcmMpIHtcbiAgICAgICAgY2FwLmNvbnZlcnRGaWxlU3JjID0gKGZpbGVQYXRoKSA9PiBmaWxlUGF0aDtcbiAgICB9XG4gICAgY2FwLmdldFBsYXRmb3JtID0gZ2V0UGxhdGZvcm07XG4gICAgY2FwLmhhbmRsZUVycm9yID0gaGFuZGxlRXJyb3I7XG4gICAgY2FwLmlzTmF0aXZlUGxhdGZvcm0gPSBpc05hdGl2ZVBsYXRmb3JtO1xuICAgIGNhcC5pc1BsdWdpbkF2YWlsYWJsZSA9IGlzUGx1Z2luQXZhaWxhYmxlO1xuICAgIGNhcC5yZWdpc3RlclBsdWdpbiA9IHJlZ2lzdGVyUGx1Z2luO1xuICAgIGNhcC5FeGNlcHRpb24gPSBDYXBhY2l0b3JFeGNlcHRpb247XG4gICAgY2FwLkRFQlVHID0gISFjYXAuREVCVUc7XG4gICAgY2FwLmlzTG9nZ2luZ0VuYWJsZWQgPSAhIWNhcC5pc0xvZ2dpbmdFbmFibGVkO1xuICAgIHJldHVybiBjYXA7XG59O1xuZXhwb3J0IGNvbnN0IGluaXRDYXBhY2l0b3JHbG9iYWwgPSAod2luKSA9PiAod2luLkNhcGFjaXRvciA9IGNyZWF0ZUNhcGFjaXRvcih3aW4pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ1bnRpbWUuanMubWFwIiwiaW1wb3J0IHsgaW5pdENhcGFjaXRvckdsb2JhbCB9IGZyb20gJy4vcnVudGltZSc7XG5leHBvcnQgY29uc3QgQ2FwYWNpdG9yID0gLyojX19QVVJFX18qLyBpbml0Q2FwYWNpdG9yR2xvYmFsKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuICAgID8gZ2xvYmFsVGhpc1xuICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gc2VsZlxuICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IHdpbmRvd1xuICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gZ2xvYmFsXG4gICAgICAgICAgICAgICAgOiB7fSk7XG5leHBvcnQgY29uc3QgcmVnaXN0ZXJQbHVnaW4gPSBDYXBhY2l0b3IucmVnaXN0ZXJQbHVnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWwuanMubWFwIiwiaW1wb3J0IHsgQ2FwYWNpdG9yIH0gZnJvbSAnLi9nbG9iYWwnO1xuaW1wb3J0IHsgRXhjZXB0aW9uQ29kZSB9IGZyb20gJy4vdXRpbCc7XG4vKipcbiAqIEJhc2UgY2xhc3Mgd2ViIHBsdWdpbnMgc2hvdWxkIGV4dGVuZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlBsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgICAgIHRoaXMucmV0YWluZWRFdmVudEFyZ3VtZW50cyA9IHt9O1xuICAgICAgICB0aGlzLndpbmRvd0xpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyRnVuYykge1xuICAgICAgICBsZXQgZmlyc3RMaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgICAgICAgZmlyc3RMaXN0ZW5lciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXS5wdXNoKGxpc3RlbmVyRnVuYyk7XG4gICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgYWRkZWQgYSB3aW5kb3cgbGlzdGVuZXIgZm9yIHRoaXMgZXZlbnQgYW5kIGl0IHJlcXVpcmVzIG9uZSxcbiAgICAgICAgLy8gZ28gYWhlYWQgYW5kIGFkZCBpdFxuICAgICAgICBjb25zdCB3aW5kb3dMaXN0ZW5lciA9IHRoaXMud2luZG93TGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICAgIGlmICh3aW5kb3dMaXN0ZW5lciAmJiAhd2luZG93TGlzdGVuZXIucmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgdGhpcy5hZGRXaW5kb3dMaXN0ZW5lcih3aW5kb3dMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZFJldGFpbmVkQXJndW1lbnRzRm9yRXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1vdmUgPSBhc3luYyAoKSA9PiB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXJGdW5jKTtcbiAgICAgICAgY29uc3QgcCA9IFByb21pc2UucmVzb2x2ZSh7IHJlbW92ZSB9KTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBpbiB0aGlzLndpbmRvd0xpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVXaW5kb3dMaXN0ZW5lcih0aGlzLndpbmRvd0xpc3RlbmVyc1tsaXN0ZW5lcl0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2luZG93TGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIG5vdGlmeUxpc3RlbmVycyhldmVudE5hbWUsIGRhdGEsIHJldGFpblVudGlsQ29uc3VtZWQpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGlmIChyZXRhaW5VbnRpbENvbnN1bWVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFyZ3MgPSB0aGlzLnJldGFpbmVkRXZlbnRBcmd1bWVudHNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRhaW5lZEV2ZW50QXJndW1lbnRzW2V2ZW50TmFtZV0gPSBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZGF0YSkpO1xuICAgIH1cbiAgICBoYXNMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICEhKChfYSA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpO1xuICAgIH1cbiAgICByZWdpc3RlcldpbmRvd0xpc3RlbmVyKHdpbmRvd0V2ZW50TmFtZSwgcGx1Z2luRXZlbnROYW1lKSB7XG4gICAgICAgIHRoaXMud2luZG93TGlzdGVuZXJzW3BsdWdpbkV2ZW50TmFtZV0gPSB7XG4gICAgICAgICAgICByZWdpc3RlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgIHdpbmRvd0V2ZW50TmFtZSxcbiAgICAgICAgICAgIHBsdWdpbkV2ZW50TmFtZSxcbiAgICAgICAgICAgIGhhbmRsZXI6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKHBsdWdpbkV2ZW50TmFtZSwgZXZlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdW5pbXBsZW1lbnRlZChtc2cgPSAnbm90IGltcGxlbWVudGVkJykge1xuICAgICAgICByZXR1cm4gbmV3IENhcGFjaXRvci5FeGNlcHRpb24obXNnLCBFeGNlcHRpb25Db2RlLlVuaW1wbGVtZW50ZWQpO1xuICAgIH1cbiAgICB1bmF2YWlsYWJsZShtc2cgPSAnbm90IGF2YWlsYWJsZScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYXBhY2l0b3IuRXhjZXB0aW9uKG1zZywgRXhjZXB0aW9uQ29kZS5VbmF2YWlsYWJsZSk7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXJGdW5jKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lckZ1bmMpO1xuICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBtb3JlIGxpc3RlbmVycyBmb3IgdGhpcyB0eXBlIG9mIGV2ZW50LFxuICAgICAgICAvLyByZW1vdmUgdGhlIHdpbmRvdyBsaXN0ZW5lclxuICAgICAgICBpZiAoIXRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVdpbmRvd0xpc3RlbmVyKHRoaXMud2luZG93TGlzdGVuZXJzW2V2ZW50TmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFdpbmRvd0xpc3RlbmVyKGhhbmRsZSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihoYW5kbGUud2luZG93RXZlbnROYW1lLCBoYW5kbGUuaGFuZGxlcik7XG4gICAgICAgIGhhbmRsZS5yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVtb3ZlV2luZG93TGlzdGVuZXIoaGFuZGxlKSB7XG4gICAgICAgIGlmICghaGFuZGxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoaGFuZGxlLndpbmRvd0V2ZW50TmFtZSwgaGFuZGxlLmhhbmRsZXIpO1xuICAgICAgICBoYW5kbGUucmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBzZW5kUmV0YWluZWRBcmd1bWVudHNGb3JFdmVudChldmVudE5hbWUpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMucmV0YWluZWRFdmVudEFyZ3VtZW50c1tldmVudE5hbWVdO1xuICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5yZXRhaW5lZEV2ZW50QXJndW1lbnRzW2V2ZW50TmFtZV07XG4gICAgICAgIGFyZ3MuZm9yRWFjaCgoYXJnKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhldmVudE5hbWUsIGFyZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYi1wbHVnaW4uanMubWFwIiwiaW1wb3J0IHsgcmVnaXN0ZXJQbHVnaW4gfSBmcm9tICcuL2dsb2JhbCc7XG5pbXBvcnQgeyBXZWJQbHVnaW4gfSBmcm9tICcuL3dlYi1wbHVnaW4nO1xuZXhwb3J0IGNvbnN0IFdlYlZpZXcgPSAvKiNfX1BVUkVfXyovIHJlZ2lzdGVyUGx1Z2luKCdXZWJWaWV3Jyk7XG4vKioqKioqKiogRU5EIFdFQiBWSUVXIFBMVUdJTiAqKioqKioqKi9cbi8qKioqKioqKiBDT09LSUVTIFBMVUdJTiAqKioqKioqKi9cbi8qKlxuICogU2FmZWx5IHdlYiBlbmNvZGUgYSBzdHJpbmcgdmFsdWUgKGluc3BpcmVkIGJ5IGpzLWNvb2tpZSlcbiAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyB2YWx1ZSB0byBlbmNvZGVcbiAqL1xuY29uc3QgZW5jb2RlID0gKHN0cikgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgICAucmVwbGFjZSgvJSgyWzM0NkJdfDVFfDYwfDdDKS9nLCBkZWNvZGVVUklDb21wb25lbnQpXG4gICAgLnJlcGxhY2UoL1soKV0vZywgZXNjYXBlKTtcbi8qKlxuICogU2FmZWx5IHdlYiBkZWNvZGUgYSBzdHJpbmcgdmFsdWUgKGluc3BpcmVkIGJ5IGpzLWNvb2tpZSlcbiAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyB2YWx1ZSB0byBkZWNvZGVcbiAqL1xuY29uc3QgZGVjb2RlID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoLyglW1xcZEEtRl17Mn0pKy9naSwgZGVjb2RlVVJJQ29tcG9uZW50KTtcbmV4cG9ydCBjbGFzcyBDYXBhY2l0b3JDb29raWVzUGx1Z2luV2ViIGV4dGVuZHMgV2ViUGx1Z2luIHtcbiAgICBhc3luYyBnZXRDb29raWVzKCkge1xuICAgICAgICBjb25zdCBjb29raWVzID0gZG9jdW1lbnQuY29va2llO1xuICAgICAgICBjb25zdCBjb29raWVNYXAgPSB7fTtcbiAgICAgICAgY29va2llcy5zcGxpdCgnOycpLmZvckVhY2goKGNvb2tpZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvb2tpZS5sZW5ndGggPD0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBSZXBsYWNlIGZpcnN0IFwiPVwiIHdpdGggQ0FQX0NPT0tJRSB0byBwcmV2ZW50IHNwbGl0dGluZyBvbiBhZGRpdGlvbmFsIFwiPVwiXG4gICAgICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gY29va2llLnJlcGxhY2UoLz0vLCAnQ0FQX0NPT0tJRScpLnNwbGl0KCdDQVBfQ09PS0lFJyk7XG4gICAgICAgICAgICBrZXkgPSBkZWNvZGUoa2V5KS50cmltKCk7XG4gICAgICAgICAgICB2YWx1ZSA9IGRlY29kZSh2YWx1ZSkudHJpbSgpO1xuICAgICAgICAgICAgY29va2llTWFwW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb29raWVNYXA7XG4gICAgfVxuICAgIGFzeW5jIHNldENvb2tpZShvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTYWZlbHkgRW5jb2RlZCBLZXkvVmFsdWVcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRLZXkgPSBlbmNvZGUob3B0aW9ucy5rZXkpO1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZFZhbHVlID0gZW5jb2RlKG9wdGlvbnMudmFsdWUpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gJiBzYW5pdGl6ZSBvcHRpb25zXG4gICAgICAgICAgICBjb25zdCBleHBpcmVzID0gYDsgZXhwaXJlcz0keyhvcHRpb25zLmV4cGlyZXMgfHwgJycpLnJlcGxhY2UoJ2V4cGlyZXM9JywgJycpfWA7IC8vIERlZmF1bHQgaXMgXCI7IGV4cGlyZXM9XCJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSAob3B0aW9ucy5wYXRoIHx8ICcvJykucmVwbGFjZSgncGF0aD0nLCAnJyk7IC8vIERlZmF1bHQgaXMgXCJwYXRoPS9cIlxuICAgICAgICAgICAgY29uc3QgZG9tYWluID0gb3B0aW9ucy51cmwgIT0gbnVsbCAmJiBvcHRpb25zLnVybC5sZW5ndGggPiAwID8gYGRvbWFpbj0ke29wdGlvbnMudXJsfWAgOiAnJztcbiAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke2VuY29kZWRLZXl9PSR7ZW5jb2RlZFZhbHVlIHx8ICcnfSR7ZXhwaXJlc307IHBhdGg9JHtwYXRofTsgJHtkb21haW59O2A7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUNvb2tpZShvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtvcHRpb25zLmtleX09OyBNYXgtQWdlPTBgO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjbGVhckNvb2tpZXMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb29raWVzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7JykgfHwgW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvb2tpZSBvZiBjb29raWVzKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLnJlcGxhY2UoL14gKy8sICcnKS5yZXBsYWNlKC89LiovLCBgPTtleHBpcmVzPSR7bmV3IERhdGUoKS50b1VUQ1N0cmluZygpfTtwYXRoPS9gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY2xlYXJBbGxDb29raWVzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGVhckNvb2tpZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY29uc3QgQ2FwYWNpdG9yQ29va2llcyA9IHJlZ2lzdGVyUGx1Z2luKCdDYXBhY2l0b3JDb29raWVzJywge1xuICAgIHdlYjogKCkgPT4gbmV3IENhcGFjaXRvckNvb2tpZXNQbHVnaW5XZWIoKSxcbn0pO1xuLy8gVVRJTElUWSBGVU5DVElPTlNcbi8qKlxuICogUmVhZCBpbiBhIEJsb2IgdmFsdWUgYW5kIHJldHVybiBpdCBhcyBhIGJhc2U2NCBzdHJpbmdcbiAqIEBwYXJhbSBibG9iIFRoZSBibG9iIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBiYXNlNjQgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQmxvYkFzQmFzZTY0ID0gYXN5bmMgKGJsb2IpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGJhc2U2NFN0cmluZyA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICAgIC8vIHJlbW92ZSBwcmVmaXggXCJkYXRhOmFwcGxpY2F0aW9uL3BkZjtiYXNlNjQsXCJcbiAgICAgICAgcmVzb2x2ZShiYXNlNjRTdHJpbmcuaW5kZXhPZignLCcpID49IDAgPyBiYXNlNjRTdHJpbmcuc3BsaXQoJywnKVsxXSA6IGJhc2U2NFN0cmluZyk7XG4gICAgfTtcbiAgICByZWFkZXIub25lcnJvciA9IChlcnJvcikgPT4gcmVqZWN0KGVycm9yKTtcbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbn0pO1xuLyoqXG4gKiBOb3JtYWxpemUgYW4gSHR0cEhlYWRlcnMgbWFwIGJ5IGxvd2VyY2FzaW5nIGFsbCBvZiB0aGUgdmFsdWVzXG4gKiBAcGFyYW0gaGVhZGVycyBUaGUgSHR0cEhlYWRlcnMgb2JqZWN0IHRvIG5vcm1hbGl6ZVxuICovXG5jb25zdCBub3JtYWxpemVIdHRwSGVhZGVycyA9IChoZWFkZXJzID0ge30pID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcbiAgICBjb25zdCBsb3dlcmVkS2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpLm1hcCgoaykgPT4gay50b0xvY2FsZUxvd2VyQ2FzZSgpKTtcbiAgICBjb25zdCBub3JtYWxpemVkID0gbG93ZXJlZEtleXMucmVkdWNlKChhY2MsIGtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgYWNjW2tleV0gPSBoZWFkZXJzW29yaWdpbmFsS2V5c1tpbmRleF1dO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbn07XG4vKipcbiAqIEJ1aWxkcyBhIHN0cmluZyBvZiB1cmwgcGFyYW1ldGVycyB0aGF0XG4gKiBAcGFyYW0gcGFyYW1zIEEgbWFwIG9mIHVybCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gc2hvdWxkRW5jb2RlIHRydWUgaWYgeW91IHNob3VsZCBlbmNvZGVVUklDb21wb25lbnQoKSB0aGUgdmFsdWVzICh0cnVlIGJ5IGRlZmF1bHQpXG4gKi9cbmNvbnN0IGJ1aWxkVXJsUGFyYW1zID0gKHBhcmFtcywgc2hvdWxkRW5jb2RlID0gdHJ1ZSkgPT4ge1xuICAgIGlmICghcGFyYW1zKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBvdXRwdXQgPSBPYmplY3QuZW50cmllcyhwYXJhbXMpLnJlZHVjZSgoYWNjdW11bGF0b3IsIGVudHJ5KSA9PiB7XG4gICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGVudHJ5O1xuICAgICAgICBsZXQgZW5jb2RlZFZhbHVlO1xuICAgICAgICBsZXQgaXRlbTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpdGVtID0gJyc7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChzdHIpID0+IHtcbiAgICAgICAgICAgICAgICBlbmNvZGVkVmFsdWUgPSBzaG91bGRFbmNvZGUgPyBlbmNvZGVVUklDb21wb25lbnQoc3RyKSA6IHN0cjtcbiAgICAgICAgICAgICAgICBpdGVtICs9IGAke2tleX09JHtlbmNvZGVkVmFsdWV9JmA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGxhc3QgY2hhcmFjdGVyIHdpbGwgYWx3YXlzIGJlIFwiJlwiIHNvIHNsaWNlIGl0IG9mZlxuICAgICAgICAgICAgaXRlbS5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmNvZGVkVmFsdWUgPSBzaG91bGRFbmNvZGUgPyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICBpdGVtID0gYCR7a2V5fT0ke2VuY29kZWRWYWx1ZX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHthY2N1bXVsYXRvcn0mJHtpdGVtfWA7XG4gICAgfSwgJycpO1xuICAgIC8vIFJlbW92ZSBpbml0aWFsIFwiJlwiIGZyb20gdGhlIHJlZHVjZVxuICAgIHJldHVybiBvdXRwdXQuc3Vic3RyKDEpO1xufTtcbi8qKlxuICogQnVpbGQgdGhlIFJlcXVlc3RJbml0IG9iamVjdCBiYXNlZCBvbiB0aGUgb3B0aW9ucyBwYXNzZWQgaW50byB0aGUgaW5pdGlhbCByZXF1ZXN0XG4gKiBAcGFyYW0gb3B0aW9ucyBUaGUgSHR0cCBwbHVnaW4gb3B0aW9uc1xuICogQHBhcmFtIGV4dHJhIEFueSBleHRyYSBSZXF1ZXN0SW5pdCB2YWx1ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGJ1aWxkUmVxdWVzdEluaXQgPSAob3B0aW9ucywgZXh0cmEgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IE9iamVjdC5hc3NpZ24oeyBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLCBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMgfSwgZXh0cmEpO1xuICAgIC8vIEdldCB0aGUgY29udGVudC10eXBlXG4gICAgY29uc3QgaGVhZGVycyA9IG5vcm1hbGl6ZUh0dHBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgY29uc3QgdHlwZSA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8ICcnO1xuICAgIC8vIElmIGJvZHkgaXMgYWxyZWFkeSBhIHN0cmluZywgdGhlbiBwYXNzIGl0IHRocm91Z2ggYXMtaXMuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG91dHB1dC5ib2R5ID0gb3B0aW9ucy5kYXRhO1xuICAgIH1cbiAgICAvLyBCdWlsZCByZXF1ZXN0IGluaXRpYWxpemVycyBiYXNlZCBvZmYgb2YgY29udGVudC10eXBlXG4gICAgZWxzZSBpZiAodHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLmRhdGEgfHwge30pKSB7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5ib2R5ID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuaW5jbHVkZXMoJ211bHRpcGFydC9mb3JtLWRhdGEnKSB8fCBvcHRpb25zLmRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob3B0aW9ucy5kYXRhKSkge1xuICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kKGtleSwgb3B0aW9ucy5kYXRhW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5ib2R5ID0gZm9ybTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKG91dHB1dC5oZWFkZXJzKTtcbiAgICAgICAgaGVhZGVycy5kZWxldGUoJ2NvbnRlbnQtdHlwZScpOyAvLyBjb250ZW50LXR5cGUgd2lsbCBiZSBzZXQgYnkgYHdpbmRvdy5mZXRjaGAgdG8gaW5jbHVkeSBib3VuZGFyeVxuICAgICAgICBvdXRwdXQuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSB8fCB0eXBlb2Ygb3B0aW9ucy5kYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvdXRwdXQuYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuLy8gV0VCIElNUExFTUVOVEFUSU9OXG5leHBvcnQgY2xhc3MgQ2FwYWNpdG9ySHR0cFBsdWdpbldlYiBleHRlbmRzIFdlYlBsdWdpbiB7XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhbiBIdHRwIHJlcXVlc3QgZ2l2ZW4gYSBzZXQgb2Ygb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gYnVpbGQgdGhlIEhUVFAgcmVxdWVzdFxuICAgICAqL1xuICAgIGFzeW5jIHJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXF1ZXN0SW5pdCA9IGJ1aWxkUmVxdWVzdEluaXQob3B0aW9ucywgb3B0aW9ucy53ZWJGZXRjaEV4dHJhKTtcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gYnVpbGRVcmxQYXJhbXMob3B0aW9ucy5wYXJhbXMsIG9wdGlvbnMuc2hvdWxkRW5jb2RlVXJsUGFyYW1zKTtcbiAgICAgICAgY29uc3QgdXJsID0gdXJsUGFyYW1zID8gYCR7b3B0aW9ucy51cmx9PyR7dXJsUGFyYW1zfWAgOiBvcHRpb25zLnVybDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHJlcXVlc3RJbml0KTtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJyc7XG4gICAgICAgIC8vIERlZmF1bHQgdG8gJ3RleHQnIHJlc3BvbnNlVHlwZSBzbyBubyBwYXJzaW5nIGhhcHBlbnNcbiAgICAgICAgbGV0IHsgcmVzcG9uc2VUeXBlID0gJ3RleHQnIH0gPSByZXNwb25zZS5vayA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgLy8gSWYgdGhlIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBpcyBqc29uLCBmb3JjZSB0aGUgcmVzcG9uc2UgdG8gYmUganNvblxuICAgICAgICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgcmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBsZXQgYmxvYjtcbiAgICAgICAgc3dpdGNoIChyZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5YnVmZmVyJzpcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgICAgICAgICAgIGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGF3YWl0IHJlYWRCbG9iQXNCYXNlNjQoYmxvYik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydCBmZXRjaCBoZWFkZXJzIHRvIENhcGFjaXRvciBIdHRwSGVhZGVyc1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIEh0dHAgR0VUIHJlcXVlc3QgZ2l2ZW4gYSBzZXQgb2Ygb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gYnVpbGQgdGhlIEhUVFAgcmVxdWVzdFxuICAgICAqL1xuICAgIGFzeW5jIGdldChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBtZXRob2Q6ICdHRVQnIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhbiBIdHRwIFBPU1QgcmVxdWVzdCBnaXZlbiBhIHNldCBvZiBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBidWlsZCB0aGUgSFRUUCByZXF1ZXN0XG4gICAgICovXG4gICAgYXN5bmMgcG9zdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBtZXRob2Q6ICdQT1NUJyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYW4gSHR0cCBQVVQgcmVxdWVzdCBnaXZlbiBhIHNldCBvZiBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBidWlsZCB0aGUgSFRUUCByZXF1ZXN0XG4gICAgICovXG4gICAgYXN5bmMgcHV0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG1ldGhvZDogJ1BVVCcgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIEh0dHAgUEFUQ0ggcmVxdWVzdCBnaXZlbiBhIHNldCBvZiBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBidWlsZCB0aGUgSFRUUCByZXF1ZXN0XG4gICAgICovXG4gICAgYXN5bmMgcGF0Y2gob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgbWV0aG9kOiAnUEFUQ0gnIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhbiBIdHRwIERFTEVURSByZXF1ZXN0IGdpdmVuIGEgc2V0IG9mIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGJ1aWxkIHRoZSBIVFRQIHJlcXVlc3RcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgbWV0aG9kOiAnREVMRVRFJyB9KSk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IENhcGFjaXRvckh0dHAgPSByZWdpc3RlclBsdWdpbignQ2FwYWNpdG9ySHR0cCcsIHtcbiAgICB3ZWI6ICgpID0+IG5ldyBDYXBhY2l0b3JIdHRwUGx1Z2luV2ViKCksXG59KTtcbi8qKioqKioqKiBFTkQgSFRUUCBQTFVHSU4gKioqKioqKiovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLXBsdWdpbnMuanMubWFwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQVUsSUFBQyxjQUFjO0FBQ3pCLENBQUMsU0FBVSxhQUFhLEVBQUU7SUFDMUI7Ozs7O0tBS0EsR0FDSSxhQUFhLENBQUMsZUFBZSxDQUFDLEdBQUcsZUFBZSxDQUFDO0lBQ3JEOzs7Ozs7S0FNQSxHQUNJLGFBQWEsQ0FBQyxhQUFhLENBQUMsR0FBRyxhQUFhLENBQUM7QUFDakQsQ0FBQyxFQUFFLGFBQWEsSUFBQSxDQUFL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LENBQUM7SUFDN0YsQ0FBSztBQUNMLENBQUM7QUFDVyxNQUFDLGFBQWEsR0FBRyxjQUFjLENBQUMsZUFBZSxFQUFFO0lBQ3pELEdBQUcsRUFBRSxJQUFNLElBQUksc0JBQXNCLEVBQUU7QUFDM0MsQ0FBQyxFQUFFIiwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxNzk0NiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9yZWR1eC1wZXJzaXN0L2VzL2ludGVncmF0aW9uL3JlYWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxuXG5leHBvcnQgdmFyIFBlcnNpc3RHYXRlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUGVyc2lzdEdhdGUsIF9QdXJlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQZXJzaXN0R2F0ZSgpIHtcbiAgICB2YXIgX2dldFByb3RvdHlwZU9mMjtcblxuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQZXJzaXN0R2F0ZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX2dldFByb3RvdHlwZU9mMiA9IF9nZXRQcm90b3R5cGVPZihQZXJzaXN0R2F0ZSkpLmNhbGwuYXBwbHkoX2dldFByb3RvdHlwZU9mMiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN0YXRlXCIsIHtcbiAgICAgIGJvb3RzdHJhcHBlZDogZmFsc2VcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfdW5zdWJzY3JpYmVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJoYW5kbGVQZXJzaXN0b3JTdGF0ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGVyc2lzdG9yID0gX3RoaXMucHJvcHMucGVyc2lzdG9yO1xuXG4gICAgICB2YXIgX3BlcnNpc3RvciRnZXRTdGF0ZSA9IHBlcnNpc3Rvci5nZXRTdGF0ZSgpLFxuICAgICAgICAgIGJvb3RzdHJhcHBlZCA9IF9wZXJzaXN0b3IkZ2V0U3RhdGUuYm9vdHN0cmFwcGVkO1xuXG4gICAgICBpZiAoYm9vdHN0cmFwcGVkKSB7XG4gICAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkJlZm9yZUxpZnQpIHtcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoX3RoaXMucHJvcHMub25CZWZvcmVMaWZ0KCkpLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgYm9vdHN0cmFwcGVkOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBib290c3RyYXBwZWQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLl91bnN1YnNjcmliZSAmJiBfdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQZXJzaXN0R2F0ZSwgW3tcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB0aGlzLl91bnN1YnNjcmliZSA9IHRoaXMucHJvcHMucGVyc2lzdG9yLnN1YnNjcmliZSh0aGlzLmhhbmRsZVBlcnNpc3RvclN0YXRlKTtcbiAgICAgIHRoaXMuaGFuZGxlUGVyc2lzdG9yU3RhdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB0aGlzLl91bnN1YnNjcmliZSAmJiB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLmNoaWxkcmVuID09PSAnZnVuY3Rpb24nICYmIHRoaXMucHJvcHMubG9hZGluZykgY29uc29sZS5lcnJvcigncmVkdXgtcGVyc2lzdDogUGVyc2lzdEdhdGUgZXhwZWN0cyBlaXRoZXIgYSBmdW5jdGlvbiBjaGlsZCBvciBsb2FkaW5nIHByb3AsIGJ1dCBub3QgYm90aC4gVGhlIGxvYWRpbmcgcHJvcCB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5jaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLnN0YXRlLmJvb3RzdHJhcHBlZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLmJvb3RzdHJhcHBlZCA/IHRoaXMucHJvcHMuY2hpbGRyZW4gOiB0aGlzLnByb3BzLmxvYWRpbmc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBlcnNpc3RHYXRlO1xufShQdXJlQ29tcG9uZW50KTtcblxuX2RlZmluZVByb3BlcnR5KFBlcnNpc3RHYXRlLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBsb2FkaW5nOiBudWxsXG59KTsiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBc0ZVO0FBbEVWLG1SQUE4QywyQ0FBMkM7QUFwQnpGLFNBQVMsUUFBUSxHQUFHO0lBQUksSUFBSSxPQUFPLFdBQVcsY0FBYyxPQUFPLE9BQU8sUUFBUSxLQUFLLFVBQVU7UUFBRSxVQUFVLFNBQVMsUUFBUSxHQUFHO1lBQUksT0FBTyxPQUFPO1FBQUs7SUFBRyxPQUFPO1FBQUUsVUFBVSxTQUFTLFFBQVEsR0FBRztZQUFJLE9BQU8sT0FBTyxPQUFPLFdBQVcsY0FBYyxJQUFJLFdBQVcsS0FBSyxVQUFVLFFBQVEsT0FBTyxTQUFTLEdBQUcsV0FBVyxPQUFPO1FBQUs7SUFBRztJQUFFLE9BQU8sUUFBUTtBQUFNO0FBRTlWLFNBQVMsZ0JBQWdCLFFBQVEsRUFBRSxXQUFXO0lBQUksSUFBSSxDQUFDLENBQUMsb0JBQW9CLFdBQVcsR0FBRztRQUFFLE1BQU0sSUFBSSxVQUFVO0lBQXNDO0FBQUU7QUFFeEosU0FBUyxrQkFBa0IsTUFBTSxFQUFFLEtBQUs7SUFBSSxJQUFLLElBQUksSUFBSSxHQUFHLElBQUksTUFBTSxNQUFNLEVBQUUsSUFBSztRQUFFLElBQUksYUFBYSxLQUFLLENBQUMsRUFBRTtRQUFFLFdBQVcsVUFBVSxHQUFHLFdBQVcsVUFBVSxJQUFJO1FBQU8sV0FBVyxZQUFZLEdBQUc7UUFBTSxJQUFJLFdBQVcsWUFBWSxXQUFXLFFBQVEsR0FBRztRQUFNLE9BQU8sY0FBYyxDQUFDLFFBQVEsV0FBVyxHQUFHLEVBQUU7SUFBYTtBQUFFO0FBRTVULFNBQVMsYUFBYSxXQUFXLEVBQUUsVUFBVSxFQUFFLFdBQVc7SUFBSSxJQUFJLFlBQVksa0JBQWtCLFlBQVksU0FBUyxFQUFFO0lBQWEsSUFBSSxhQUFhLGtCQUFrQixhQUFhO0lBQWMsT0FBTztBQUFhO0FBRXROLFNBQVMsMkJBQTJCLElBQUksRUFBRSxJQUFJO0lBQUksSUFBSSxRQUFRLENBQUMsUUFBUSxVQUFVLFlBQVksT0FBTyxTQUFTLFVBQVUsR0FBRztRQUFFLE9BQU87SUFBTTtJQUFFLE9BQU8sdUJBQXVCO0FBQU87QUFFaEwsU0FBUyxnQkFBZ0IsQ0FBQztJQUFJLGtCQUFrQixPQUFPLGNBQWMsR0FBRyxPQUFPLGNBQWMsR0FBRyxTQUFTLGdCQUFnQixDQUFDO1FBQUksT0FBTyxFQUFFLFNBQVMsSUFBSSxPQUFPLGNBQWMsQ0FBQztJQUFJO0lBQUcsT0FBTyxnQkFBZ0I7QUFBSTtBQUU1TSxTQUFTLHVCQUF1QixJQUFJO0lBQUksSUFBSSxTQUFTLEtBQUssR0FBRztRQUFFLE1BQU0sSUFBSSxlQUFlO0lBQThEO0lBQUUsT0FBTztBQUFNO0FBRXJLLFNBQVMsVUFBVSxRQUFRLEVBQUUsVUFBVTtJQUFJLElBQUksT0FBTyxlQUFlLGNBQWMsZUFBZSxNQUFNO1FBQUUsTUFBTSxJQUFJLFVBQVU7SUFBdUQ7SUFBRSxTQUFTLFNBQVMsR0FBRyxPQUFPLE1BQU0sQ0FBQyxjQUFjLFdBQVcsU0FBUyxFQUFFO1FBQUUsYUFBYTtZQUFFLE9BQU87WUFBVSxVQUFVO1lBQU0sY0FBYztRQUFLO0lBQUU7SUFBSSxJQUFJLFlBQVksZ0JBQWdCLFVBQVU7QUFBYTtBQUVoWSxTQUFTLGdCQUFnQixDQUFDLEVBQUUsQ0FBQztJQUFJLGtCQUFrQixPQUFPLGNBQWMsSUFBSSxTQUFTLGdCQUFnQixDQUFDLEVBQUUsQ0FBQztRQUFJLEVBQUUsU0FBUyxHQUFHO1FBQUcsT0FBTztJQUFHO0lBQUcsT0FBTyxnQkFBZ0IsR0FBRztBQUFJO0FBRXpLLFNBQVMsZ0JBQWdCLEdBQUcsRUFBRSxHQUFHLEVBQUUsS0FBSztJQUFJLElBQUksT0FBTyxLQUFLO1FBQUUsT0FBTyxjQUFjLENBQUMsS0FBSyxLQUFLO1lBQUUsT0FBTztZQUFPLFlBQVk7WUFBTSxjQUFjO1lBQU0sVUFBVTtRQUFLO0lBQUksT0FBTztRQUFFLEdBQUcsQ0FBQyxJQUFJLEdBQUc7SUFBTztJQUFFLE9BQU87QUFBSzs7QUFJek0sSUFBSSxjQUNYLFdBQVcsR0FDWCxTQUFVLGNBQWM7SUFDdEIsVUFBVSxhQUFhO0lBRXZCLFNBQVM7UUFDUCxJQUFJO1FBRUosSUFBSTtRQUVKLGdCQUFnQixJQUFJLEVBQUU7UUFFdEIsSUFBSyxJQUFJLE9BQU8sVUFBVSxNQUFNLEVBQUUsT0FBTyxJQUFJLE1BQU0sT0FBTyxPQUFPLEdBQUcsT0FBTyxNQUFNLE9BQVE7WUFDdkYsSUFBSSxDQUFDLEtBQUssR0FBRyxTQUFTLENBQUMsS0FBSztRQUM5QjtRQUVBLFFBQVEsMkJBQTJCLElBQUksRUFBRSxDQUFDLG1CQUFtQixnQkFBZ0IsWUFBWSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsa0JBQWtCO1lBQUMsSUFBSTtTQUFDLENBQUMsTUFBTSxDQUFDO1FBRXRJLGdCQUFnQix1QkFBdUIsUUFBUSxTQUFTO1lBQ3RELGNBQWM7UUFDaEI7UUFFQSxnQkFBZ0IsdUJBQXVCLFFBQVEsZ0JBQWdCLEtBQUs7UUFFcEUsZ0JBQWdCLHVCQUF1QixRQUFRLHdCQUF3QjtZQUNyRSxJQUFJLFlBQVksTUFBTSxLQUFLLENBQUMsU0FBUztZQUVyQyxJQUFJLHNCQUFzQixVQUFVLFFBQVEsSUFDeEMsZUFBZSxvQkFBb0IsWUFBWTtZQUVuRCxJQUFJLGNBQWM7Z0JBQ2hCLElBQUksTUFBTSxLQUFLLENBQUMsWUFBWSxFQUFFO29CQUM1QixRQUFRLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxZQUFZLElBQUksT0FBTyxDQUFDO3dCQUNsRCxPQUFPLE1BQU0sUUFBUSxDQUFDOzRCQUNwQixjQUFjO3dCQUNoQjtvQkFDRjtnQkFDRixPQUFPO29CQUNMLE1BQU0sUUFBUSxDQUFDO3dCQUNiLGNBQWM7b0JBQ2hCO2dCQUNGO2dCQUVBLE1BQU0sWUFBWSxJQUFJLE1BQU0sWUFBWTtZQUMxQztRQUNGO1FBRUEsT0FBTztJQUNUO0lBRUEsYUFBYSxhQUFhO1FBQUM7WUFDekIsS0FBSztZQUNMLE9BQU8sU0FBUztnQkFDZCxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsb0JBQW9CO2dCQUM1RSxJQUFJLENBQUMsb0JBQW9CO1lBQzNCO1FBQ0Y7UUFBRztZQUNELEtBQUs7WUFDTCxPQUFPLFNBQVM7Z0JBQ2QsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWTtZQUN4QztRQUNGO1FBQUc7WUFDRCxLQUFLO1lBQ0wsT0FBTyxTQUFTO2dCQUNkLHdDQUEyQztvQkFDekMsSUFBSSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxLQUFLLGNBQWMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsUUFBUSxLQUFLLENBQUM7Z0JBQ3JGO2dCQUVBLElBQUksT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsS0FBSyxZQUFZO29CQUM3QyxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWTtnQkFDcEQ7Z0JBRUEsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU87WUFDM0U7UUFDRjtLQUFFO0lBRUYsT0FBTztBQUNULEVBQUUsNkpBQUEsQ0FBQSxnQkFBYTtBQUVmLGdCQUFnQixhQUFhLGdCQUFnQjtJQUMzQyxVQUFVO0lBQ1YsU0FBUztBQUNYIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE4MTA5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Rpc2FibGUtc21vb3RoLXNjcm9sbC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gJy4uLy4uL3V0aWxzL3dhcm4tb25jZSdcblxuLyoqXG4gKiBSdW4gZnVuY3Rpb24gd2l0aCBgc2Nyb2xsLWJlaGF2aW9yOiBhdXRvYCBhcHBsaWVkIHRvIGA8aHRtbC8+YC5cbiAqIFRoaXMgY3NzIGNoYW5nZSB3aWxsIGJlIHJldmVydGVkIGFmdGVyIHRoZSBmdW5jdGlvbiBmaW5pc2hlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVTbW9vdGhTY3JvbGxEdXJpbmdSb3V0ZVRyYW5zaXRpb24oXG4gIGZuOiAoKSA9PiB2b2lkLFxuICBvcHRpb25zOiB7IGRvbnRGb3JjZUxheW91dD86IGJvb2xlYW47IG9ubHlIYXNoQ2hhbmdlPzogYm9vbGVhbiB9ID0ge31cbikge1xuICAvLyBpZiBvbmx5IHRoZSBoYXNoIGlzIGNoYW5nZWQsIHdlIGRvbid0IG5lZWQgdG8gZGlzYWJsZSBzbW9vdGggc2Nyb2xsaW5nXG4gIC8vIHdlIG9ubHkgY2FyZSB0byBwcmV2ZW50IHNtb290aCBzY3JvbGxpbmcgd2hlbiBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2UgdG8gYXZvaWQgamFycmluZyBVWFxuICBpZiAob3B0aW9ucy5vbmx5SGFzaENoYW5nZSkge1xuICAgIGZuKClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGh0bWxFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gIGNvbnN0IGhhc0RhdGFBdHRyaWJ1dGUgPSBodG1sRWxlbWVudC5kYXRhc2V0LnNjcm9sbEJlaGF2aW9yID09PSAnc21vb3RoJ1xuXG4gIC8vIFNpbmNlIHRoaXMgaXMgYSBicmVha2luZyBjaGFuZ2UsIHRoaXMgaXMgdGVtcG9yYXJpbHkgZmxhZ2dlZFxuICAvLyBhbmQgd2lsbCBiZSBmYWxzZSBieSBkZWZhdWx0LlxuICAvLyBJbiB0aGUgbmV4dCBtYWpvciAodjE2KSwgdGhpcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZW5hYmxlZFxuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVpFX1JPVVRFUl9TQ1JPTEwpIHtcbiAgICBpZiAoIWhhc0RhdGFBdHRyaWJ1dGUpIHtcbiAgICAgIC8vIE5vIHNtb290aCBzY3JvbGxpbmcgY29uZmlndXJlZCwgcnVuIGRpcmVjdGx5IHdpdGhvdXQgc3R5bGUgbWFuaXB1bGF0aW9uXG4gICAgICBmbigpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gT2xkIGJlaGF2aW9yOiBhbHdheXMgbWFuaXB1bGF0ZSBzdHlsZXMsIGJ1dCB3YXJuIGFib3V0IHVwY29taW5nIGNoYW5nZVxuXG4gICAgLy8gV2FybiBpZiBzbW9vdGggc2Nyb2xsaW5nIGlzIGRldGVjdGVkIGJ1dCBubyBkYXRhIGF0dHJpYnV0ZSBpcyBwcmVzZW50XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgICFoYXNEYXRhQXR0cmlidXRlICYmXG4gICAgICBnZXRDb21wdXRlZFN0eWxlKGh0bWxFbGVtZW50KS5zY3JvbGxCZWhhdmlvciA9PT0gJ3Ntb290aCdcbiAgICApIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICAnRGV0ZWN0ZWQgYHNjcm9sbC1iZWhhdmlvcjogc21vb3RoYCBvbiB0aGUgYDxodG1sPmAgZWxlbWVudC4gSW4gYSBmdXR1cmUgdmVyc2lvbiwgJyArXG4gICAgICAgICAgJ05leHQuanMgd2lsbCBubyBsb25nZXIgYXV0b21hdGljYWxseSBkaXNhYmxlIHNtb290aCBzY3JvbGxpbmcgZHVyaW5nIHJvdXRlIHRyYW5zaXRpb25zLiAnICtcbiAgICAgICAgICAnVG8gcHJlcGFyZSBmb3IgdGhpcyBjaGFuZ2UsIGFkZCBgZGF0YS1zY3JvbGwtYmVoYXZpb3I9XCJzbW9vdGhcImAgdG8geW91ciA8aHRtbD4gZWxlbWVudC4gJyArXG4gICAgICAgICAgJ0xlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL21pc3NpbmctZGF0YS1zY3JvbGwtYmVoYXZpb3InXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgLy8gUHJvY2VlZCB3aXRoIHRlbXBvcmFyaWx5IGRpc2FibGluZyBzbW9vdGggc2Nyb2xsaW5nXG4gIGNvbnN0IGV4aXN0aW5nID0gaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3JcbiAgaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSAnYXV0bydcbiAgaWYgKCFvcHRpb25zLmRvbnRGb3JjZUxheW91dCkge1xuICAgIC8vIEluIENocm9tZS1iYXNlZCBicm93c2VycyB3ZSBuZWVkIHRvIGZvcmNlIHJlZmxvdyBiZWZvcmUgY2FsbGluZyBgc2Nyb2xsVG9gLlxuICAgIC8vIE90aGVyd2lzZSBpdCB3aWxsIG5vdCBwaWNrdXAgdGhlIGNoYW5nZSBpbiBzY3JvbGxCZWhhdmlvclxuICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzQwNzE5I2lzc3VlY29tbWVudC0xMzM2MjQ4MDQyXG4gICAgaHRtbEVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKVxuICB9XG4gIGZuKClcbiAgaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBleGlzdGluZ1xufVxuIl0sIm5hbWVzIjpbImRpc2FibGVTbW9vdGhTY3JvbGxEdXJpbmdSb3V0ZVRyYW5zaXRpb24iLCJmbiIsIm9wdGlvbnMiLCJvbmx5SGFzaENoYW5nZSIsImh0bWxFbGVtZW50IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJoYXNEYXRhQXR0cmlidXRlIiwiZGF0YXNldCIsInNjcm9sbEJlaGF2aW9yIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9PUFRJTUlaRV9ST1VURVJfU0NST0xMIiwiTk9ERV9FTlYiLCJnZXRDb21wdXRlZFN0eWxlIiwid2Fybk9uY2UiLCJleGlzdGluZyIsInN0eWxlIiwiZG9udEZvcmNlTGF5b3V0IiwiZ2V0Q2xpZW50UmVjdHMiXSwibWFwcGluZ3MiOiJBQXVCTVUsUUFBUUMsR0FBRyxDQUFDQyw2QkFBNkIsRUFBRTs7Ozs7K0JBakJqQ1osNENBQUFBOzs7ZUFBQUE7OzswQkFOUztBQU1sQixTQUFTQSx5Q0FDZEMsRUFBYyxFQUNkQyxPQUFxRTtJQUFyRUEsSUFBQUEsWUFBQUEsS0FBQUEsR0FBQUEsVUFBbUUsQ0FBQztJQUVwRSx5RUFBeUU7SUFDekUsNkZBQTZGO0lBQzdGLElBQUlBLFFBQVFDLGNBQWMsRUFBRTtRQUMxQkY7UUFDQTtJQUNGO0lBRUEsTUFBTUcsY0FBY0MsU0FBU0MsZUFBZTtJQUM1QyxNQUFNQyxtQkFBbUJILFlBQVlJLE9BQU8sQ0FBQ0MsY0FBYyxLQUFLO0lBRWhFLCtEQUErRDtJQUMvRCxnQ0FBZ0M7SUFDaEMsOERBQThEO0lBQzlEOztTQU1PO1FBQ0wseUVBQXlFO1FBRXpFLHdFQUF3RTtRQUN4RSxJQUNFQyxRQUFRQyxHQUFHLENBQUNFLFFBQVEsZ0NBQUssaUJBQ3pCLENBQUNOLG9CQUNETyxpQkFBaUJWLGFBQWFLLGNBQWMsS0FBSyxVQUNqRDtZQUNBTSxDQUFBQSxHQUFBQSxVQUFBQSxRQUFRLEVBQ04sc0ZBQ0UsNkZBQ0EsNkZBQ0E7UUFFTjtJQUNGO0lBRUEsc0RBQXNEO0lBQ3RELE1BQU1DLFdBQVdaLFlBQVlhLEtBQUssQ0FBQ1IsY0FBYztJQUNqREwsWUFBWWEsS0FBSyxDQUFDUixjQUFjLEdBQUc7SUFDbkMsSUFBSSxDQUFDUCxRQUFRZ0IsZUFBZSxFQUFFO1FBQzVCLDhFQUE4RTtRQUM5RSw0REFBNEQ7UUFDNUQseUZBQXlGO1FBQ3pGZCxZQUFZZSxjQUFjO0lBQzVCO0lBQ0FsQjtJQUNBRyxZQUFZYSxLQUFLLENBQUNSLGNBQWMsR0FBR087QUFDckMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTgxNjEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvYmZjYWNoZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuXG4vLyBXaGVuIHRoZSBmbGFnIGlzIGRpc2FibGVkLCBvbmx5IHRyYWNrIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRyZWVcbmNvbnN0IE1BWF9CRl9DQUNIRV9FTlRSSUVTID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CRl9DQUNIRSA/IDMgOiAxXG5cbmV4cG9ydCB0eXBlIFJvdXRlckJGQ2FjaGVFbnRyeSA9IHtcbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgc3RhdGVLZXk6IHN0cmluZ1xuICAvLyBUaGUgZW50cmllcyBmb3JtIGEgbGlua2VkIGxpc3QsIHNvcnRlZCBpbiBvcmRlciBvZiBtb3N0IHJlY2VudGx5IGFjdGl2ZS5cbiAgbmV4dDogUm91dGVyQkZDYWNoZUVudHJ5IHwgbnVsbFxufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBtb3N0IHJlY2VudCBOIHRyZWVzIChGbGlnaHRSb3V0ZXJTdGF0ZXMpIHRoYXQgd2VyZSBhY3RpdmVcbiAqIGF0IGEgY2VydGFpbiBzZWdtZW50IGxldmVsLiBFLmcuIGZvciBhIHNlZ21lbnQgXCIvYS9iL1twYXJhbV1cIiwgdGhpcyBob29rXG4gKiB0cmFja3MgdGhlIGxhc3QgTiBwYXJhbSB2YWx1ZXMgdGhhdCB0aGUgcm91dGVyIHJlbmRlcmVkIGZvciBOLlxuICpcbiAqIFRoZSByZXN1bHQgb2YgdGhpcyBob29rIHByZWNpc2VseSBkZXRlcm1pbmVzIHRoZSBudW1iZXIgYW5kIG9yZGVyIG9mXG4gKiB0cmVlcyB0aGF0IGFyZSByZW5kZXJlZCBpbiBwYXJhbGxlbCBhdCB0aGVpciBzZWdtZW50IGxldmVsLlxuICpcbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgY2FjaGUgaXMgdG8gd2UgY2FuIHByZXNlcnZlIHRoZSBSZWFjdCBhbmQgRE9NIHN0YXRlIG9mXG4gKiBzb21lIG51bWJlciBvZiBpbmFjdGl2ZSB0cmVlcywgYnkgcmVuZGVyaW5nIHRoZW0gaW4gYW4gPEFjdGl2aXR5PiBib3VuZGFyeS5cbiAqIFRoYXQgbWVhbnMgaXQgd291bGQgbm90IG1ha2Ugc2Vuc2UgZm9yIHRoZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGNhY2hlIHRvIGJlXG4gKiBhbnkgbG9uZ2VyIHRoYW4gdGhlIGxpZmV0aW1lIG9mIHRoZSBSZWFjdCB0cmVlOyBlLmcuIGlmIHRoZSBob29rIHdlcmVcbiAqIHVubW91bnRlZCwgdGhlbiB0aGUgUmVhY3QgdHJlZSB3b3VsZCBiZSwgdG9vLiBTbywgd2UgdXNlIFJlYWN0IHN0YXRlIHRvXG4gKiBtYW5hZ2UgaXQuXG4gKlxuICogTm90ZSB0aGF0IHdlIGRvbid0IHN0b3JlIHRoZSBSU0MgZGF0YSBmb3IgdGhlIGNhY2hlIGVudHJpZXMgaW4gdGhpcyBob29rIOKAlFxuICogdGhlIGRhdGEgZm9yIGluYWN0aXZlIHNlZ21lbnRzIGlzIHN0b3JlZCBpbiB0aGUgcGFyZW50IENhY2hlTm9kZSwgd2hpY2hcbiAqICpkb2VzKiBoYXZlIGEgbG9uZ2VyIGxpZmV0aW1lIHRoYW4gdGhlIFJlYWN0IHRyZWUuIFRoaXMgaG9vayBvbmx5IGRldGVybWluZXNcbiAqIHdoaWNoIG9mIHRob3NlIHRyZWVzIHNob3VsZCBoYXZlIHRoZWlyICpzdGF0ZSogcHJlc2VydmVkLCBieSA8QWN0aXZpdHk+LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVyQkZDYWNoZShcbiAgYWN0aXZlVHJlZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIGFjdGl2ZVN0YXRlS2V5OiBzdHJpbmdcbik6IFJvdXRlckJGQ2FjaGVFbnRyeSB7XG4gIC8vIFRoZSBjdXJyZW50bHkgYWN0aXZlIGVudHJ5LiBUaGUgZW50cmllcyBmb3JtIGEgbGlua2VkIGxpc3QsIHNvcnRlZCBpblxuICAvLyBvcmRlciBvZiBtb3N0IHJlY2VudGx5IGFjdGl2ZS4gVGhpcyBhbGxvd3MgdXMgdG8gcmV1c2UgcGFydHMgb2YgdGhlIGxpc3RcbiAgLy8gd2l0aG91dCBjbG9uaW5nLCB1bmxlc3MgdGhlcmUncyBhIHJlb3JkZXJpbmcgb3IgcmVtb3ZhbC5cbiAgLy8gVE9ETzogT25jZSB3ZSBzdGFydCB0cmFja2luZyBiYWNrL2ZvcndhcmQgaGlzdG9yeSBhdCBlYWNoIHJvdXRlIGxldmVsLFxuICAvLyB3ZSBzaG91bGQgdXNlIHRoZSBoaXN0b3J5IG9yZGVyIGluc3RlYWQuIEluIG90aGVyIHdvcmRzLCB3aGVuIHRyYXZlcnNpbmdcbiAgLy8gdG8gYW4gZXhpc3RpbmcgZW50cnkgYXMgYSByZXN1bHQgb2YgYSBwb3BzdGF0ZSBldmVudCwgd2Ugc2hvdWxkIG1haW50YWluXG4gIC8vIHRoZSBleGlzdGluZyBvcmRlciBpbnN0ZWFkIG9mIG1vdmluZyBpdCB0byB0aGUgZnJvbnQgb2YgdGhlIGxpc3QuIEkgdGhpbmtcbiAgLy8gYW4gaW5pdGlhbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGNvdWxkIGJlIHRvIHBhc3MgYW4gaW5jcmVtZW50aW5nIGlkXG4gIC8vIHRvIGhpc3RvcnkucHVzaFN0YXRlL3JlcGxhY2VTdGF0ZSwgdGhlbiB1c2UgdGhhdCBoZXJlIGZvciBvcmRlcmluZy5cbiAgY29uc3QgW3ByZXZBY3RpdmVFbnRyeSwgc2V0UHJldkFjdGl2ZUVudHJ5XSA9IHVzZVN0YXRlPFJvdXRlckJGQ2FjaGVFbnRyeT4oXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3QgaW5pdGlhbEVudHJ5OiBSb3V0ZXJCRkNhY2hlRW50cnkgPSB7XG4gICAgICAgIHRyZWU6IGFjdGl2ZVRyZWUsXG4gICAgICAgIHN0YXRlS2V5OiBhY3RpdmVTdGF0ZUtleSxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbml0aWFsRW50cnlcbiAgICB9XG4gIClcblxuICBpZiAocHJldkFjdGl2ZUVudHJ5LnRyZWUgPT09IGFjdGl2ZVRyZWUpIHtcbiAgICAvLyBGYXN0IHBhdGguIFRoZSBhY3RpdmUgdHJlZSBoYXNuJ3QgY2hhbmdlZCwgc28gd2UgY2FuIHJldXNlIHRoZVxuICAgIC8vIGV4aXN0aW5nIHN0YXRlLlxuICAgIHJldHVybiBwcmV2QWN0aXZlRW50cnlcbiAgfVxuXG4gIC8vIFRoZSByb3V0ZSB0cmVlIGNoYW5nZWQuIE5vdGUgdGhhdCB0aGlzIGRvZXNuJ3QgbWVhbiB0aGF0IHRoZSB0cmVlIGNoYW5nZWRcbiAgLy8gKmF0IHRoaXMgbGV2ZWwqIOKAlCB0aGUgY2hhbmdlIG1heSBiZSBkdWUgdG8gYSBjaGlsZCByb3V0ZS4gRWl0aGVyIHdheSwgd2VcbiAgLy8gbmVlZCB0byBlaXRoZXIgYWRkIG9yIHVwZGF0ZSB0aGUgcm91dGVyIHRyZWUgaW4gdGhlIGJmY2FjaGUuXG4gIC8vXG4gIC8vIFRoZSByZXN0IG9mIHRoZSBjb2RlIGxvb2tzIG1vcmUgY29tcGxpY2F0ZWQgdGhhbiBpdCBhY3R1YWxseSBpcyBiZWNhdXNlIHdlXG4gIC8vIGNhbid0IG11dGF0ZSB0aGUgc3RhdGUgaW4gcGxhY2U7IHdlIGhhdmUgdG8gY29weS1vbi13cml0ZS5cblxuICAvLyBDcmVhdGUgYSBuZXcgZW50cnkgZm9yIHRoZSBhY3RpdmUgY2FjaGUga2V5LiBUaGlzIGlzIHRoZSBoZWFkIG9mIHRoZSBuZXdcbiAgLy8gbGlua2VkIGxpc3QuXG4gIGNvbnN0IG5ld0FjdGl2ZUVudHJ5OiBSb3V0ZXJCRkNhY2hlRW50cnkgPSB7XG4gICAgdHJlZTogYWN0aXZlVHJlZSxcbiAgICBzdGF0ZUtleTogYWN0aXZlU3RhdGVLZXksXG4gICAgbmV4dDogbnVsbCxcbiAgfVxuXG4gIC8vIFdlIG5lZWQgdG8gYXBwZW5kIHRoZSBvbGQgbGlzdCBvbnRvIHRoZSBuZXcgbGlzdC4gSWYgdGhlIGhlYWQgb2YgdGhlIG5ld1xuICAvLyBsaXN0IHdhcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIGNhY2hlLCB0aGVuIHdlJ2xsIG5lZWQgdG8gY2xvbmUgZXZlcnl0aGluZ1xuICAvLyB0aGF0IGNhbWUgYmVmb3JlIGl0LiBUaGVuIHdlIGNhbiByZXVzZSB0aGUgcmVzdC5cbiAgbGV0IG4gPSAxXG4gIGxldCBvbGRFbnRyeTogUm91dGVyQkZDYWNoZUVudHJ5IHwgbnVsbCA9IHByZXZBY3RpdmVFbnRyeVxuICBsZXQgY2xvbmVkRW50cnk6IFJvdXRlckJGQ2FjaGVFbnRyeSA9IG5ld0FjdGl2ZUVudHJ5XG4gIHdoaWxlIChvbGRFbnRyeSAhPT0gbnVsbCAmJiBuIDwgTUFYX0JGX0NBQ0hFX0VOVFJJRVMpIHtcbiAgICBpZiAob2xkRW50cnkuc3RhdGVLZXkgPT09IGFjdGl2ZVN0YXRlS2V5KSB7XG4gICAgICAvLyBGYXN0IHBhdGguIFRoaXMgZW50cnkgaW4gdGhlIG9sZCBsaXN0IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGtleSB0aGF0XG4gICAgICAvLyBpcyBub3cgYWN0aXZlLiBXZSd2ZSBhbHJlYWR5IHBsYWNlZCBhIGNsb25lIG9mIHRoaXMgZW50cnkgYXQgdGhlIGZyb250XG4gICAgICAvLyBvZiB0aGUgbmV3IGxpc3QuIFdlIGNhbiByZXVzZSB0aGUgcmVzdCBvZiB0aGUgb2xkIGxpc3Qgd2l0aG91dCBjbG9uaW5nLlxuICAgICAgLy8gTk9URTogV2UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCBldmljdGlvbiBpbiB0aGlzIGNhc2UgYmVjYXVzZSB3ZVxuICAgICAgLy8gaGF2ZW4ndCBpbmNyZWFzZWQgdGhlIHNpemUgb2YgdGhlIGNhY2hlLCBhbmQgd2UgYXNzdW1lIHRoZSBtYXggc2l6ZVxuICAgICAgLy8gaXMgY29uc3RhbnQgYWNyb3NzIHJlbmRlcnMuIElmIHdlIHdlcmUgdG8gY2hhbmdlIGl0IHRvIGEgZHluYW1pYyBsaW1pdCxcbiAgICAgIC8vIHRoZW4gdGhlIGltcGxlbWVudGF0aW9uIHdvdWxkIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhhdC5cbiAgICAgIGNsb25lZEVudHJ5Lm5leHQgPSBvbGRFbnRyeS5uZXh0XG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDbG9uZSB0aGUgZW50cnkgYW5kIGFwcGVuZCBpdCB0byB0aGUgbGlzdC5cbiAgICAgIG4rK1xuICAgICAgY29uc3QgZW50cnk6IFJvdXRlckJGQ2FjaGVFbnRyeSA9IHtcbiAgICAgICAgdHJlZTogb2xkRW50cnkudHJlZSxcbiAgICAgICAgc3RhdGVLZXk6IG9sZEVudHJ5LnN0YXRlS2V5LFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgfVxuICAgICAgY2xvbmVkRW50cnkubmV4dCA9IGVudHJ5XG4gICAgICBjbG9uZWRFbnRyeSA9IGVudHJ5XG4gICAgfVxuICAgIG9sZEVudHJ5ID0gb2xkRW50cnkubmV4dFxuICB9XG5cbiAgc2V0UHJldkFjdGl2ZUVudHJ5KG5ld0FjdGl2ZUVudHJ5KVxuICByZXR1cm4gbmV3QWN0aXZlRW50cnlcbn1cbiJdLCJuYW1lcyI6WyJ1c2VSb3V0ZXJCRkNhY2hlIiwiTUFYX0JGX0NBQ0hFX0VOVFJJRVMiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CRl9DQUNIRSIsImFjdGl2ZVRyZWUiLCJhY3RpdmVTdGF0ZUtleSIsInByZXZBY3RpdmVFbnRyeSIsInNldFByZXZBY3RpdmVFbnRyeSIsInVzZVN0YXRlIiwiaW5pdGlhbEVudHJ5IiwidHJlZSIsInN0YXRlS2V5IiwibmV4dCIsIm5ld0FjdGl2ZUVudHJ5IiwibiIsIm9sZEVudHJ5IiwiY2xvbmVkRW50cnkiLCJlbnRyeSJdLCJtYXBwaW5ncyI6IkFBSTZCRSxRQUFRQyxHQUFHLENBQUNDLHNCQUFzQjs7Ozs7K0JBNkIvQ0osb0JBQUFBOzs7ZUFBQUE7Ozt1QkFoQ1M7QUFFekIsa0VBQWtFO0FBQ2xFLE1BQU1DLDZEQUE0RCwwQkFBSTtBQTZCL0QsU0FBU0QsaUJBQ2RLLFVBQTZCLEVBQzdCQyxjQUFzQjtJQUV0Qix3RUFBd0U7SUFDeEUsMkVBQTJFO0lBQzNFLDJEQUEyRDtJQUMzRCx5RUFBeUU7SUFDekUsMkVBQTJFO0lBQzNFLDJFQUEyRTtJQUMzRSw0RUFBNEU7SUFDNUUsd0VBQXdFO0lBQ3hFLHNFQUFzRTtJQUN0RSxNQUFNLENBQUNDLGlCQUFpQkMsbUJBQW1CLEdBQUdDLENBQUFBLEdBQUFBLE9BQUFBLFFBQVEsRUFDcEQ7UUFDRSxNQUFNQyxlQUFtQztZQUN2Q0MsTUFBTU47WUFDTk8sVUFBVU47WUFDVk8sTUFBTTtRQUNSO1FBQ0EsT0FBT0g7SUFDVDtJQUdGLElBQUlILGdCQUFnQkksSUFBSSxLQUFLTixZQUFZO1FBQ3ZDLGlFQUFpRTtRQUNqRSxrQkFBa0I7UUFDbEIsT0FBT0U7SUFDVDtJQUVBLDRFQUE0RTtJQUM1RSwyRUFBMkU7SUFDM0UsK0RBQStEO0lBQy9ELEVBQUU7SUFDRiw2RUFBNkU7SUFDN0UsNkRBQTZEO0lBRTdELDJFQUEyRTtJQUMzRSxlQUFlO0lBQ2YsTUFBTU8saUJBQXFDO1FBQ3pDSCxNQUFNTjtRQUNOTyxVQUFVTjtRQUNWTyxNQUFNO0lBQ1I7SUFFQSwyRUFBMkU7SUFDM0UsNkVBQTZFO0lBQzdFLG1EQUFtRDtJQUNuRCxJQUFJRSxJQUFJO0lBQ1IsSUFBSUMsV0FBc0NUO0lBQzFDLElBQUlVLGNBQWtDSDtJQUN0QyxNQUFPRSxhQUFhLFFBQVFELElBQUlkLHFCQUFzQjtRQUNwRCxJQUFJZSxTQUFTSixRQUFRLEtBQUtOLGdCQUFnQjtZQUN4Qyx5RUFBeUU7WUFDekUseUVBQXlFO1lBQ3pFLDBFQUEwRTtZQUMxRSxzRUFBc0U7WUFDdEUsc0VBQXNFO1lBQ3RFLDBFQUEwRTtZQUMxRSwwREFBMEQ7WUFDMURXLFlBQVlKLElBQUksR0FBR0csU0FBU0gsSUFBSTtZQUNoQztRQUNGLE9BQU87WUFDTCw2Q0FBNkM7WUFDN0NFO1lBQ0EsTUFBTUcsUUFBNEI7Z0JBQ2hDUCxNQUFNSyxTQUFTTCxJQUFJO2dCQUNuQkMsVUFBVUksU0FBU0osUUFBUTtnQkFDM0JDLE1BQU07WUFDUjtZQUNBSSxZQUFZSixJQUFJLEdBQUdLO1lBQ25CRCxjQUFjQztRQUNoQjtRQUNBRixXQUFXQSxTQUFTSCxJQUFJO0lBQzFCO0lBRUFMLG1CQUFtQk07SUFDbkIsT0FBT0E7QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxODI1NywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9sYXlvdXQtcm91dGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHR5cGUge1xuICBDYWNoZU5vZGUsXG4gIExhenlDYWNoZU5vZGUsXG4gIExvYWRpbmdNb2R1bGVEYXRhLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB0eXBlIHtcbiAgRmxpZ2h0Um91dGVyU3RhdGUsXG4gIEZsaWdodFNlZ21lbnRQYXRoLFxufSBmcm9tICcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB0eXBlIHsgRXJyb3JDb21wb25lbnQgfSBmcm9tICcuL2Vycm9yLWJvdW5kYXJ5J1xuaW1wb3J0IHtcbiAgQUNUSU9OX1NFUlZFUl9QQVRDSCxcbiAgdHlwZSBGb2N1c0FuZFNjcm9sbFJlZixcbn0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcydcblxuaW1wb3J0IFJlYWN0LCB7XG4gIHVzZUNvbnRleHQsXG4gIHVzZSxcbiAgc3RhcnRUcmFuc2l0aW9uLFxuICBTdXNwZW5zZSxcbiAgdXNlRGVmZXJyZWRWYWx1ZSxcbiAgdHlwZSBKU1gsXG59IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSdcbmltcG9ydCB7XG4gIExheW91dFJvdXRlckNvbnRleHQsXG4gIEdsb2JhbExheW91dFJvdXRlckNvbnRleHQsXG4gIFRlbXBsYXRlQ29udGV4dCxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBmZXRjaFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQgeyB1bnJlc29sdmVkVGhlbmFibGUgfSBmcm9tICcuL3VucmVzb2x2ZWQtdGhlbmFibGUnXG5pbXBvcnQgeyBFcnJvckJvdW5kYXJ5IH0gZnJvbSAnLi9lcnJvci1ib3VuZGFyeSdcbmltcG9ydCB7IG1hdGNoU2VnbWVudCB9IGZyb20gJy4vbWF0Y2gtc2VnbWVudHMnXG5pbXBvcnQgeyBkaXNhYmxlU21vb3RoU2Nyb2xsRHVyaW5nUm91dGVUcmFuc2l0aW9uIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZGlzYWJsZS1zbW9vdGgtc2Nyb2xsJ1xuaW1wb3J0IHsgUmVkaXJlY3RCb3VuZGFyeSB9IGZyb20gJy4vcmVkaXJlY3QtYm91bmRhcnknXG5pbXBvcnQgeyBIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSB9IGZyb20gJy4vaHR0cC1hY2Nlc3MtZmFsbGJhY2svZXJyb3ItYm91bmRhcnknXG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXJDYWNoZUtleSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvY3JlYXRlLXJvdXRlci1jYWNoZS1rZXknXG5pbXBvcnQgeyBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlJ1xuaW1wb3J0IHsgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24gfSBmcm9tICcuL3VzZS1hY3Rpb24tcXVldWUnXG5pbXBvcnQgeyB1c2VSb3V0ZXJCRkNhY2hlLCB0eXBlIFJvdXRlckJGQ2FjaGVFbnRyeSB9IGZyb20gJy4vYmZjYWNoZSdcbmltcG9ydCB7IG5vcm1hbGl6ZUFwcFBhdGggfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hcHAtcGF0aHMnXG5cbmNvbnN0IEFjdGl2aXR5ID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CRl9DQUNIRVxuICA/IChyZXF1aXJlKCdyZWFjdCcpIGFzIHR5cGVvZiBpbXBvcnQoJ3JlYWN0JykpLnVuc3RhYmxlX0FjdGl2aXR5XG4gIDogbnVsbCFcblxuLyoqXG4gKiBBZGQgcmVmZXRjaCBtYXJrZXIgdG8gcm91dGVyIHN0YXRlIGF0IHRoZSBwb2ludCBvZiB0aGUgY3VycmVudCBsYXlvdXQgc2VnbWVudC5cbiAqIFRoaXMgZW5zdXJlcyB0aGUgcmVzcG9uc2UgcmV0dXJuZWQgaXMgbm90IGZ1cnRoZXIgZG93biB0aGFuIHRoZSBjdXJyZW50IGxheW91dCBzZWdtZW50LlxuICovXG5mdW5jdGlvbiB3YWxrQWRkUmVmZXRjaChcbiAgc2VnbWVudFBhdGhUb1dhbGs6IEZsaWdodFNlZ21lbnRQYXRoIHwgdW5kZWZpbmVkLFxuICB0cmVlVG9SZWNyZWF0ZTogRmxpZ2h0Um91dGVyU3RhdGVcbik6IEZsaWdodFJvdXRlclN0YXRlIHtcbiAgaWYgKHNlZ21lbnRQYXRoVG9XYWxrKSB7XG4gICAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVLZXldID0gc2VnbWVudFBhdGhUb1dhbGtcbiAgICBjb25zdCBpc0xhc3QgPSBzZWdtZW50UGF0aFRvV2Fsay5sZW5ndGggPT09IDJcblxuICAgIGlmIChtYXRjaFNlZ21lbnQodHJlZVRvUmVjcmVhdGVbMF0sIHNlZ21lbnQpKSB7XG4gICAgICBpZiAodHJlZVRvUmVjcmVhdGVbMV0uaGFzT3duUHJvcGVydHkocGFyYWxsZWxSb3V0ZUtleSkpIHtcbiAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgIGNvbnN0IHN1YlRyZWUgPSB3YWxrQWRkUmVmZXRjaChcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzFdW3BhcmFsbGVsUm91dGVLZXldXG4gICAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0cmVlVG9SZWNyZWF0ZVswXSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4udHJlZVRvUmVjcmVhdGVbMV0sXG4gICAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogW1xuICAgICAgICAgICAgICAgIHN1YlRyZWVbMF0sXG4gICAgICAgICAgICAgICAgc3ViVHJlZVsxXSxcbiAgICAgICAgICAgICAgICBzdWJUcmVlWzJdLFxuICAgICAgICAgICAgICAgICdyZWZldGNoJyxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB0cmVlVG9SZWNyZWF0ZVswXSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi50cmVlVG9SZWNyZWF0ZVsxXSxcbiAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogd2Fsa0FkZFJlZmV0Y2goXG4gICAgICAgICAgICAgIHNlZ21lbnRQYXRoVG9XYWxrLnNsaWNlKDIpLFxuICAgICAgICAgICAgICB0cmVlVG9SZWNyZWF0ZVsxXVtwYXJhbGxlbFJvdXRlS2V5XVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9LFxuICAgICAgICBdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRyZWVUb1JlY3JlYXRlXG59XG5cbmNvbnN0IF9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSA9IChcbiAgUmVhY3RET00gYXMgYW55XG4pLl9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERVxuXG4vLyBUT0RPLUFQUDogUmVwbGFjZSB3aXRoIG5ldyBSZWFjdCBBUEkgZm9yIGZpbmRpbmcgZG9tIG5vZGVzIHdpdGhvdXQgYSBgcmVmYCB3aGVuIGF2YWlsYWJsZVxuLyoqXG4gKiBXcmFwcyBSZWFjdERPTS5maW5kRE9NTm9kZSB3aXRoIGFkZGl0aW9uYWwgbG9naWMgdG8gaGlkZSBSZWFjdCBTdHJpY3QgTW9kZSB3YXJuaW5nXG4gKi9cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKFxuICBpbnN0YW5jZTogUmVhY3QuUmVhY3RJbnN0YW5jZSB8IG51bGwgfCB1bmRlZmluZWRcbik6IEVsZW1lbnQgfCBUZXh0IHwgbnVsbCB7XG4gIC8vIFRyZWUtc2hha2UgZm9yIHNlcnZlciBidW5kbGVcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbFxuXG4gIC8vIF9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERS5maW5kRE9NTm9kZSBpcyBudWxsIGR1cmluZyBtb2R1bGUgaW5pdC5cbiAgLy8gV2UgbmVlZCB0byBsYXppbHkgcmVmZXJlbmNlIGl0LlxuICBjb25zdCBpbnRlcm5hbF9yZWFjdERPTWZpbmRET01Ob2RlID1cbiAgICBfX0RPTV9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUuZmluZERPTU5vZGVcbiAgcmV0dXJuIGludGVybmFsX3JlYWN0RE9NZmluZERPTU5vZGUoaW5zdGFuY2UpXG59XG5cbmNvbnN0IHJlY3RQcm9wZXJ0aWVzID0gW1xuICAnYm90dG9tJyxcbiAgJ2hlaWdodCcsXG4gICdsZWZ0JyxcbiAgJ3JpZ2h0JyxcbiAgJ3RvcCcsXG4gICd3aWR0aCcsXG4gICd4JyxcbiAgJ3knLFxuXSBhcyBjb25zdFxuLyoqXG4gKiBDaGVjayBpZiBhIEhUTUxFbGVtZW50IGlzIGhpZGRlbiBvciBmaXhlZC9zdGlja3kgcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gc2hvdWxkU2tpcEVsZW1lbnQoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgLy8gd2UgaWdub3JlIGZpeGVkIG9yIHN0aWNreSBwb3NpdGlvbmVkIGVsZW1lbnRzIHNpbmNlIHRoZXknbGwgbGlrZWx5IHBhc3MgdGhlIFwiaW4tdmlld3BvcnRcIiBjaGVja1xuICAvLyBhbmQgd2lsbCByZXN1bHQgaW4gYSBzaXR1YXRpb24gd2UgYmFpbCBvbiBzY3JvbGwgYmVjYXVzZSBvZiBzb21ldGhpbmcgbGlrZSBhIGZpeGVkIG5hdixcbiAgLy8gZXZlbiB0aG91Z2ggdGhlIGFjdHVhbCBwYWdlIGNvbnRlbnQgaXMgb2Zmc2NyZWVuXG4gIGlmIChbJ3N0aWNreScsICdmaXhlZCddLmluY2x1ZGVzKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdTa2lwcGluZyBhdXRvLXNjcm9sbCBiZWhhdmlvciBkdWUgdG8gYHBvc2l0aW9uOiBzdGlja3lgIG9yIGBwb3NpdGlvbjogZml4ZWRgIG9uIGVsZW1lbnQ6JyxcbiAgICAgICAgZWxlbWVudFxuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gVXNlcyBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCB0byBjaGVjayBpZiB0aGUgZWxlbWVudCBpcyBoaWRkZW4gaW5zdGVhZCBvZiBgb2Zmc2V0UGFyZW50YFxuICAvLyBiZWNhdXNlIGBvZmZzZXRQYXJlbnRgIGRvZXNuJ3QgY29uc2lkZXIgZG9jdW1lbnQvYm9keVxuICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICByZXR1cm4gcmVjdFByb3BlcnRpZXMuZXZlcnkoKGl0ZW0pID0+IHJlY3RbaXRlbV0gPT09IDApXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHRvcCBjb3JuZXIgb2YgdGhlIEhUTUxFbGVtZW50IGlzIGluIHRoZSB2aWV3cG9ydC5cbiAqL1xuZnVuY3Rpb24gdG9wT2ZFbGVtZW50SW5WaWV3cG9ydChlbGVtZW50OiBIVE1MRWxlbWVudCwgdmlld3BvcnRIZWlnaHQ6IG51bWJlcikge1xuICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICByZXR1cm4gcmVjdC50b3AgPj0gMCAmJiByZWN0LnRvcCA8PSB2aWV3cG9ydEhlaWdodFxufVxuXG4vKipcbiAqIEZpbmQgdGhlIERPTSBub2RlIGZvciBhIGhhc2ggZnJhZ21lbnQuXG4gKiBJZiBgdG9wYCB0aGUgcGFnZSBoYXMgdG8gc2Nyb2xsIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UuIFRoaXMgbWlycm9ycyB0aGUgYnJvd3NlcidzIGJlaGF2aW9yLlxuICogSWYgdGhlIGhhc2ggZnJhZ21lbnQgaXMgYW4gaWQsIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIGVsZW1lbnQgd2l0aCB0aGF0IGlkLlxuICogSWYgdGhlIGhhc2ggZnJhZ21lbnQgaXMgYSBuYW1lLCB0aGUgcGFnZSBoYXMgdG8gc2Nyb2xsIHRvIHRoZSBmaXJzdCBlbGVtZW50IHdpdGggdGhhdCBuYW1lLlxuICovXG5mdW5jdGlvbiBnZXRIYXNoRnJhZ21lbnREb21Ob2RlKGhhc2hGcmFnbWVudDogc3RyaW5nKSB7XG4gIC8vIElmIHRoZSBoYXNoIGZyYWdtZW50IGlzIGB0b3BgIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZS5cbiAgaWYgKGhhc2hGcmFnbWVudCA9PT0gJ3RvcCcpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keVxuICB9XG5cbiAgLy8gSWYgdGhlIGhhc2ggZnJhZ21lbnQgaXMgYW4gaWQsIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIGVsZW1lbnQgd2l0aCB0aGF0IGlkLlxuICByZXR1cm4gKFxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2hGcmFnbWVudCkgPz9cbiAgICAvLyBJZiB0aGUgaGFzaCBmcmFnbWVudCBpcyBhIG5hbWUsIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCB0aGF0IG5hbWUuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoaGFzaEZyYWdtZW50KVswXVxuICApXG59XG5pbnRlcmZhY2UgU2Nyb2xsQW5kRm9jdXNIYW5kbGVyUHJvcHMge1xuICBmb2N1c0FuZFNjcm9sbFJlZjogRm9jdXNBbmRTY3JvbGxSZWZcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxuICBzZWdtZW50UGF0aDogRmxpZ2h0U2VnbWVudFBhdGhcbn1cbmNsYXNzIElubmVyU2Nyb2xsQW5kRm9jdXNIYW5kbGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFNjcm9sbEFuZEZvY3VzSGFuZGxlclByb3BzPiB7XG4gIGhhbmRsZVBvdGVudGlhbFNjcm9sbCA9ICgpID0+IHtcbiAgICAvLyBIYW5kbGUgc2Nyb2xsIGFuZCBmb2N1cywgaXQncyBvbmx5IGFwcGxpZWQgb25jZSBpbiB0aGUgZmlyc3QgdXNlRWZmZWN0IHRoYXQgdHJpZ2dlcnMgdGhhdCBjaGFuZ2VkLlxuICAgIGNvbnN0IHsgZm9jdXNBbmRTY3JvbGxSZWYsIHNlZ21lbnRQYXRoIH0gPSB0aGlzLnByb3BzXG5cbiAgICBpZiAoZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkpIHtcbiAgICAgIC8vIHNlZ21lbnRQYXRocyBpcyBhbiBhcnJheSBvZiBzZWdtZW50IHBhdGhzIHRoYXQgc2hvdWxkIGJlIHNjcm9sbGVkIHRvXG4gICAgICAvLyBpZiB0aGUgY3VycmVudCBzZWdtZW50IHBhdGggaXMgbm90IGluIHRoZSBhcnJheSwgdGhlIHNjcm9sbCBpcyBub3QgYXBwbGllZFxuICAgICAgLy8gdW5sZXNzIHRoZSBhcnJheSBpcyBlbXB0eSwgaW4gd2hpY2ggY2FzZSB0aGUgc2Nyb2xsIGlzIGFsd2F5cyBhcHBsaWVkXG4gICAgICBpZiAoXG4gICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLnNlZ21lbnRQYXRocy5sZW5ndGggIT09IDAgJiZcbiAgICAgICAgIWZvY3VzQW5kU2Nyb2xsUmVmLnNlZ21lbnRQYXRocy5zb21lKChzY3JvbGxSZWZTZWdtZW50UGF0aCkgPT5cbiAgICAgICAgICBzZWdtZW50UGF0aC5ldmVyeSgoc2VnbWVudCwgaW5kZXgpID0+XG4gICAgICAgICAgICBtYXRjaFNlZ21lbnQoc2VnbWVudCwgc2Nyb2xsUmVmU2VnbWVudFBhdGhbaW5kZXhdKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsZXQgZG9tTm9kZTpcbiAgICAgICAgfCBSZXR1cm5UeXBlPHR5cGVvZiBnZXRIYXNoRnJhZ21lbnREb21Ob2RlPlxuICAgICAgICB8IFJldHVyblR5cGU8dHlwZW9mIGZpbmRET01Ob2RlPiA9IG51bGxcbiAgICAgIGNvbnN0IGhhc2hGcmFnbWVudCA9IGZvY3VzQW5kU2Nyb2xsUmVmLmhhc2hGcmFnbWVudFxuXG4gICAgICBpZiAoaGFzaEZyYWdtZW50KSB7XG4gICAgICAgIGRvbU5vZGUgPSBnZXRIYXNoRnJhZ21lbnREb21Ob2RlKGhhc2hGcmFnbWVudClcbiAgICAgIH1cblxuICAgICAgLy8gYGZpbmRET01Ob2RlYCBpcyB0cmlja3kgYmVjYXVzZSBpdCByZXR1cm5zIGp1c3QgdGhlIGZpcnN0IGNoaWxkIGlmIHRoZSBjb21wb25lbnQgaXMgYSBmcmFnbWVudC5cbiAgICAgIC8vIFRoaXMgYWxyZWFkeSBjYXVzZWQgYSBidWcgd2hlcmUgdGhlIGZpcnN0IGNoaWxkIHdhcyBhIDxsaW5rLz4gaW4gaGVhZC5cbiAgICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICBkb21Ob2RlID0gZmluZERPTU5vZGUodGhpcylcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gRE9NIG5vZGUgdGhpcyBsYXlvdXQtcm91dGVyIGxldmVsIGlzIHNraXBwZWQuIEl0J2xsIGJlIGhhbmRsZWQgaGlnaGVyLXVwIGluIHRoZSB0cmVlLlxuICAgICAgaWYgKCEoZG9tTm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBWZXJpZnkgaWYgdGhlIGVsZW1lbnQgaXMgYSBIVE1MRWxlbWVudCBhbmQgaWYgd2Ugd2FudCB0byBjb25zaWRlciBpdCBmb3Igc2Nyb2xsIGJlaGF2aW9yLlxuICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgc2tpcHBlZCwgdHJ5IHRvIHNlbGVjdCB0aGUgbmV4dCBzaWJsaW5nIGFuZCB0cnkgYWdhaW4uXG4gICAgICB3aGlsZSAoIShkb21Ob2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHx8IHNob3VsZFNraXBFbGVtZW50KGRvbU5vZGUpKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGRvbU5vZGUucGFyZW50RWxlbWVudD8ubG9jYWxOYW1lID09PSAnaGVhZCcpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFdlIGVudGVyIHRoaXMgc3RhdGUgd2hlbiBtZXRhZGF0YSB3YXMgcmVuZGVyZWQgYXMgcGFydCBvZiB0aGUgcGFnZSBvciB2aWEgTmV4dC5qcy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYWx3YXlzIGEgYnVnIGluIE5leHQuanMgYW5kIGNhdXNlZCBieSBSZWFjdCBob2lzdGluZyBtZXRhZGF0YS5cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcmVwbGFjZSBgZmluZERPTU5vZGVgIGluIGZhdm9yIG9mIEZyYWdtZW50IFJlZnMgKHdoZW4gYXZhaWxhYmxlKSBzbyB0aGF0IHdlIGNhbiBza2lwIG92ZXIgbWV0YWRhdGEuXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm8gc2libGluZ3MgZm91bmQgdGhhdCBtYXRjaCB0aGUgY3JpdGVyaWEgYXJlIGZvdW5kLCBzbyBoYW5kbGUgc2Nyb2xsIGhpZ2hlciB1cCBpbiB0aGUgdHJlZSBpbnN0ZWFkLlxuICAgICAgICBpZiAoZG9tTm9kZS5uZXh0RWxlbWVudFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBkb21Ob2RlID0gZG9tTm9kZS5uZXh0RWxlbWVudFNpYmxpbmdcbiAgICAgIH1cblxuICAgICAgLy8gU3RhdGUgaXMgbXV0YXRlZCB0byBlbnN1cmUgdGhhdCB0aGUgZm9jdXMgYW5kIHNjcm9sbCBpcyBhcHBsaWVkIG9ubHkgb25jZS5cbiAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLmFwcGx5ID0gZmFsc2VcbiAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLmhhc2hGcmFnbWVudCA9IG51bGxcbiAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLnNlZ21lbnRQYXRocyA9IFtdXG5cbiAgICAgIGRpc2FibGVTbW9vdGhTY3JvbGxEdXJpbmdSb3V0ZVRyYW5zaXRpb24oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAvLyBJbiBjYXNlIG9mIGhhc2ggc2Nyb2xsLCB3ZSBvbmx5IG5lZWQgdG8gc2Nyb2xsIHRoZSBlbGVtZW50IGludG8gdmlld1xuICAgICAgICAgIGlmIChoYXNoRnJhZ21lbnQpIHtcbiAgICAgICAgICAgIDsoZG9tTm9kZSBhcyBIVE1MRWxlbWVudCkuc2Nyb2xsSW50b1ZpZXcoKVxuXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgdmlld3BvcnQgaGVpZ2h0IGJlY2F1c2UgcmVhZGluZyBgY2xpZW50SGVpZ2h0YCBjYXVzZXMgYSByZWZsb3csXG4gICAgICAgICAgLy8gYW5kIGl0IHdvbid0IGNoYW5nZSBkdXJpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgICAgICBjb25zdCBodG1sRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICAgICAgICAgIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID0gaHRtbEVsZW1lbnQuY2xpZW50SGVpZ2h0XG5cbiAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCdzIHRvcCBlZGdlIGlzIGFscmVhZHkgaW4gdGhlIHZpZXdwb3J0LCBleGl0IGVhcmx5LlxuICAgICAgICAgIGlmICh0b3BPZkVsZW1lbnRJblZpZXdwb3J0KGRvbU5vZGUgYXMgSFRNTEVsZW1lbnQsIHZpZXdwb3J0SGVpZ2h0KSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0cnkgc2Nyb2xsaW5nIGdvIHRoZSB0b3Agb2YgdGhlIGRvY3VtZW50IHRvIGJlIGJhY2t3YXJkIGNvbXBhdGlibGUgd2l0aCBwYWdlc1xuICAgICAgICAgIC8vIHNjcm9sbEludG9WaWV3KCkgY2FsbGVkIG9uIGA8aHRtbC8+YCBlbGVtZW50IHNjcm9sbHMgaG9yaXpvbnRhbGx5IG9uIGNocm9tZSBhbmQgZmlyZWZveCAodGhhdCBzaG91bGRuJ3QgaGFwcGVuKVxuICAgICAgICAgIC8vIFdlIGNvdWxkIHVzZSBpdCB0byBzY3JvbGwgaG9yaXpvbnRhbGx5IGZvbGxvd2luZyBSVEwgYnV0IHRoYXQgYWxzbyBzZWVtcyB0byBiZSBicm9rZW4gLSBpdCB3aWxsIGFsd2F5cyBzY3JvbGwgbGVmdFxuICAgICAgICAgIC8vIHNjcm9sbExlZnQgPSAwIGFsc28gc2VlbXMgdG8gaWdub3JlIFJUTCBhbmQgbWFudWFsbHkgY2hlY2tpbmcgZm9yIFJUTCBpcyB0b28gbXVjaCBoYXNzbGUgc28gd2Ugd2lsbCBzY3JvbGwganVzdCB2ZXJ0aWNhbGx5XG4gICAgICAgICAgaHRtbEVsZW1lbnQuc2Nyb2xsVG9wID0gMFxuXG4gICAgICAgICAgLy8gU2Nyb2xsIHRvIGRvbU5vZGUgaWYgZG9tTm9kZSBpcyBub3QgaW4gdmlld3BvcnQgd2hlbiBzY3JvbGxlZCB0byB0b3Agb2YgZG9jdW1lbnRcbiAgICAgICAgICBpZiAoIXRvcE9mRWxlbWVudEluVmlld3BvcnQoZG9tTm9kZSBhcyBIVE1MRWxlbWVudCwgdmlld3BvcnRIZWlnaHQpKSB7XG4gICAgICAgICAgICAvLyBTY3JvbGwgaW50byB2aWV3IGRvZXNuJ3Qgc2Nyb2xsIGhvcml6b250YWxseSBieSBkZWZhdWx0IHdoZW4gbm90IG5lZWRlZFxuICAgICAgICAgICAgOyhkb21Ob2RlIGFzIEhUTUxFbGVtZW50KS5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2Ugd2lsbCBmb3JjZSBsYXlvdXQgYnkgcXVlcnlpbmcgZG9tTm9kZSBwb3NpdGlvblxuICAgICAgICAgIGRvbnRGb3JjZUxheW91dDogdHJ1ZSxcbiAgICAgICAgICBvbmx5SGFzaENoYW5nZTogZm9jdXNBbmRTY3JvbGxSZWYub25seUhhc2hDaGFuZ2UsXG4gICAgICAgIH1cbiAgICAgIClcblxuICAgICAgLy8gTXV0YXRlIGFmdGVyIHNjcm9sbGluZyBzbyB0aGF0IGl0IGNhbiBiZSByZWFkIGJ5IGBkaXNhYmxlU21vb3RoU2Nyb2xsRHVyaW5nUm91dGVUcmFuc2l0aW9uYFxuICAgICAgZm9jdXNBbmRTY3JvbGxSZWYub25seUhhc2hDaGFuZ2UgPSBmYWxzZVxuXG4gICAgICAvLyBTZXQgZm9jdXMgb24gdGhlIGVsZW1lbnRcbiAgICAgIGRvbU5vZGUuZm9jdXMoKVxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuaGFuZGxlUG90ZW50aWFsU2Nyb2xsKClcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAvLyBCZWNhdXNlIHRoaXMgcHJvcGVydHkgaXMgb3ZlcndyaXR0ZW4gaW4gaGFuZGxlUG90ZW50aWFsU2Nyb2xsIGl0J3MgZmluZSB0byBhbHdheXMgcnVuIGl0IHdoZW4gdHJ1ZSBhcyBpdCdsbCBiZSBzZXQgdG8gZmFsc2UgZm9yIHN1YnNlcXVlbnQgcmVuZGVycy5cbiAgICBpZiAodGhpcy5wcm9wcy5mb2N1c0FuZFNjcm9sbFJlZi5hcHBseSkge1xuICAgICAgdGhpcy5oYW5kbGVQb3RlbnRpYWxTY3JvbGwoKVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlblxuICB9XG59XG5cbmZ1bmN0aW9uIFNjcm9sbEFuZEZvY3VzSGFuZGxlcih7XG4gIHNlZ21lbnRQYXRoLFxuICBjaGlsZHJlbixcbn06IHtcbiAgc2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoXG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcbn0pIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dClcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgZ2xvYmFsIGxheW91dCByb3V0ZXIgbm90IG1vdW50ZWQnKVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8SW5uZXJTY3JvbGxBbmRGb2N1c0hhbmRsZXJcbiAgICAgIHNlZ21lbnRQYXRoPXtzZWdtZW50UGF0aH1cbiAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmPXtjb250ZXh0LmZvY3VzQW5kU2Nyb2xsUmVmfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0lubmVyU2Nyb2xsQW5kRm9jdXNIYW5kbGVyPlxuICApXG59XG5cbi8qKlxuICogSW5uZXJMYXlvdXRSb3V0ZXIgaGFuZGxlcyByZW5kZXJpbmcgdGhlIHByb3ZpZGVkIHNlZ21lbnQgYmFzZWQgb24gdGhlIGNhY2hlLlxuICovXG5mdW5jdGlvbiBJbm5lckxheW91dFJvdXRlcih7XG4gIHRyZWUsXG4gIHNlZ21lbnRQYXRoLFxuICBjYWNoZU5vZGUsXG4gIHVybCxcbn06IHtcbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgc2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoXG4gIGNhY2hlTm9kZTogQ2FjaGVOb2RlXG4gIHVybDogc3RyaW5nXG59KSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEdsb2JhbExheW91dFJvdXRlckNvbnRleHQpXG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IGdsb2JhbCBsYXlvdXQgcm91dGVyIG5vdCBtb3VudGVkJylcbiAgfVxuXG4gIGNvbnN0IHsgdHJlZTogZnVsbFRyZWUgfSA9IGNvbnRleHRcblxuICAvLyBgcnNjYCByZXByZXNlbnRzIHRoZSByZW5kZXJhYmxlIG5vZGUgZm9yIHRoaXMgc2VnbWVudC5cblxuICAvLyBJZiB0aGlzIHNlZ21lbnQgaGFzIGEgYHByZWZldGNoUnNjYCwgaXQncyB0aGUgc3RhdGljYWxseSBwcmVmZXRjaGVkIGRhdGEuXG4gIC8vIFdlIHNob3VsZCB1c2UgdGhhdCBvbiBpbml0aWFsIHJlbmRlciBpbnN0ZWFkIG9mIGByc2NgLiBUaGVuIHdlJ2xsIHN3aXRjaFxuICAvLyB0byBgcnNjYCB3aGVuIHRoZSBkeW5hbWljIHJlc3BvbnNlIHN0cmVhbXMgaW4uXG4gIC8vXG4gIC8vIElmIG5vIHByZWZldGNoIGRhdGEgaXMgYXZhaWxhYmxlLCB0aGVuIHdlIGdvIHN0cmFpZ2h0IHRvIHJlbmRlcmluZyBgcnNjYC5cbiAgY29uc3QgcmVzb2x2ZWRQcmVmZXRjaFJzYyA9XG4gICAgY2FjaGVOb2RlLnByZWZldGNoUnNjICE9PSBudWxsID8gY2FjaGVOb2RlLnByZWZldGNoUnNjIDogY2FjaGVOb2RlLnJzY1xuXG4gIC8vIFdlIHVzZSBgdXNlRGVmZXJyZWRWYWx1ZWAgdG8gaGFuZGxlIHN3aXRjaGluZyBiZXR3ZWVuIHRoZSBwcmVmZXRjaGVkIGFuZFxuICAvLyBmaW5hbCB2YWx1ZXMuIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgcmV0dXJuZWQgb24gaW5pdGlhbCByZW5kZXIsIHRoZW4gaXRcbiAgLy8gcmUtcmVuZGVycyB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgY29uc3QgcnNjOiBhbnkgPSB1c2VEZWZlcnJlZFZhbHVlKGNhY2hlTm9kZS5yc2MsIHJlc29sdmVkUHJlZmV0Y2hSc2MpXG5cbiAgLy8gYHJzY2AgaXMgZWl0aGVyIGEgUmVhY3Qgbm9kZSBvciBhIHByb21pc2UgZm9yIGEgUmVhY3Qgbm9kZSwgZXhjZXB0IHdlXG4gIC8vIHNwZWNpYWwgY2FzZSBgbnVsbGAgdG8gcmVwcmVzZW50IHRoYXQgdGhpcyBzZWdtZW50J3MgZGF0YSBpcyBtaXNzaW5nLiBJZlxuICAvLyBpdCdzIGEgcHJvbWlzZSwgd2UgbmVlZCB0byB1bndyYXAgaXQgc28gd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0aGVcbiAgLy8gZGF0YSBpcyBtaXNzaW5nLlxuICBjb25zdCByZXNvbHZlZFJzYzogUmVhY3QuUmVhY3ROb2RlID1cbiAgICB0eXBlb2YgcnNjID09PSAnb2JqZWN0JyAmJiByc2MgIT09IG51bGwgJiYgdHlwZW9mIHJzYy50aGVuID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHVzZShyc2MpXG4gICAgICA6IHJzY1xuXG4gIGlmICghcmVzb2x2ZWRSc2MpIHtcbiAgICAvLyBUaGUgZGF0YSBmb3IgdGhpcyBzZWdtZW50IGlzIG5vdCBhdmFpbGFibGUsIGFuZCB0aGVyZSdzIG5vIHBlbmRpbmdcbiAgICAvLyBuYXZpZ2F0aW9uIHRoYXQgd2lsbCBiZSBhYmxlIHRvIGZ1bGZpbGwgaXQuIFdlIG5lZWQgdG8gZmV0Y2ggbW9yZSBmcm9tXG4gICAgLy8gdGhlIHNlcnZlciBhbmQgcGF0Y2ggdGhlIGNhY2hlLlxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbHJlYWR5IGEgcGVuZGluZyByZXF1ZXN0LlxuICAgIGxldCBsYXp5RGF0YSA9IGNhY2hlTm9kZS5sYXp5RGF0YVxuICAgIGlmIChsYXp5RGF0YSA9PT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBSb3V0ZXIgc3RhdGUgd2l0aCByZWZldGNoIG1hcmtlciBhZGRlZFxuICAgICAgICovXG4gICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICBjb25zdCByZWZldGNoVHJlZSA9IHdhbGtBZGRSZWZldGNoKFsnJywgLi4uc2VnbWVudFBhdGhdLCBmdWxsVHJlZSlcbiAgICAgIGNvbnN0IGluY2x1ZGVOZXh0VXJsID0gaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKGZ1bGxUcmVlKVxuICAgICAgY29uc3QgbmF2aWdhdGVkQXQgPSBEYXRlLm5vdygpXG4gICAgICBjYWNoZU5vZGUubGF6eURhdGEgPSBsYXp5RGF0YSA9IGZldGNoU2VydmVyUmVzcG9uc2UoXG4gICAgICAgIG5ldyBVUkwodXJsLCBsb2NhdGlvbi5vcmlnaW4pLFxuICAgICAgICB7XG4gICAgICAgICAgZmxpZ2h0Um91dGVyU3RhdGU6IHJlZmV0Y2hUcmVlLFxuICAgICAgICAgIG5leHRVcmw6IGluY2x1ZGVOZXh0VXJsID8gY29udGV4dC5uZXh0VXJsIDogbnVsbCxcbiAgICAgICAgfVxuICAgICAgKS50aGVuKChzZXJ2ZXJSZXNwb25zZSkgPT4ge1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgIGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6IEFDVElPTl9TRVJWRVJfUEFUQ0gsXG4gICAgICAgICAgICBwcmV2aW91c1RyZWU6IGZ1bGxUcmVlLFxuICAgICAgICAgICAgc2VydmVyUmVzcG9uc2UsXG4gICAgICAgICAgICBuYXZpZ2F0ZWRBdCxcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiBzZXJ2ZXJSZXNwb25zZVxuICAgICAgfSlcblxuICAgICAgLy8gU3VzcGVuZCB3aGlsZSB3YWl0aW5nIGZvciBsYXp5RGF0YSB0byByZXNvbHZlXG4gICAgICB1c2UobGF6eURhdGEpXG4gICAgfVxuICAgIC8vIFN1c3BlbmQgaW5maW5pdGVseSBhcyBgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZWAgd2lsbCBjYXVzZSBhIGRpZmZlcmVudCBwYXJ0IG9mIHRoZSB0cmVlIHRvIGJlIHJlbmRlcmVkLlxuICAgIC8vIEEgZmFsc2V5IGByZXNvbHZlZFJzY2AgaW5kaWNhdGVzIG1pc3NpbmcgZGF0YSAtLSB3ZSBzaG91bGQgbm90IGNvbW1pdCB0aGF0IGJyYW5jaCwgYW5kIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIGRhdGEgdG8gYXJyaXZlLlxuICAgIHVzZSh1bnJlc29sdmVkVGhlbmFibGUpIGFzIG5ldmVyXG4gIH1cblxuICAvLyBJZiB3ZSBnZXQgdG8gdGhpcyBwb2ludCwgdGhlbiB3ZSBrbm93IHdlIGhhdmUgc29tZXRoaW5nIHdlIGNhbiByZW5kZXIuXG4gIGNvbnN0IHN1YnRyZWUgPSAoXG4gICAgLy8gVGhlIGxheW91dCByb3V0ZXIgY29udGV4dCBuYXJyb3dzIGRvd24gdHJlZSBhbmQgY2hpbGROb2RlcyBhdCBlYWNoIGxldmVsLlxuICAgIDxMYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyXG4gICAgICB2YWx1ZT17e1xuICAgICAgICBwYXJlbnRUcmVlOiB0cmVlLFxuICAgICAgICBwYXJlbnRDYWNoZU5vZGU6IGNhY2hlTm9kZSxcbiAgICAgICAgcGFyZW50U2VnbWVudFBhdGg6IHNlZ21lbnRQYXRoLFxuXG4gICAgICAgIC8vIFRPRE8tQVBQOiBvdmVycmlkaW5nIG9mIHVybCBmb3IgcGFyYWxsZWwgcm91dGVzXG4gICAgICAgIHVybDogdXJsLFxuICAgICAgfX1cbiAgICA+XG4gICAgICB7cmVzb2x2ZWRSc2N9XG4gICAgPC9MYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICApXG4gIC8vIEVuc3VyZSByb290IGxheW91dCBpcyBub3Qgd3JhcHBlZCBpbiBhIGRpdiBhcyB0aGUgcm9vdCBsYXlvdXQgcmVuZGVycyBgPGh0bWw+YFxuICByZXR1cm4gc3VidHJlZVxufVxuXG4vKipcbiAqIFJlbmRlcnMgc3VzcGVuc2UgYm91bmRhcnkgd2l0aCB0aGUgcHJvdmlkZWQgXCJsb2FkaW5nXCIgcHJvcGVydHkgYXMgdGhlIGZhbGxiYWNrLlxuICogSWYgbm8gbG9hZGluZyBwcm9wZXJ0eSBpcyBwcm92aWRlZCBpdCByZW5kZXJzIHRoZSBjaGlsZHJlbiB3aXRob3V0IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gKi9cbmZ1bmN0aW9uIExvYWRpbmdCb3VuZGFyeSh7XG4gIGxvYWRpbmcsXG4gIGNoaWxkcmVuLFxufToge1xuICBsb2FkaW5nOiBMb2FkaW5nTW9kdWxlRGF0YSB8IFByb21pc2U8TG9hZGluZ01vZHVsZURhdGE+XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcbn0pOiBKU1guRWxlbWVudCB7XG4gIC8vIElmIGxvYWRpbmcgaXMgYSBwcm9taXNlLCB1bndyYXAgaXQuIFRoaXMgaGFwcGVucyBpbiBjYXNlcyB3aGVyZSB3ZSBoYXZlbid0XG4gIC8vIHlldCByZWNlaXZlZCB0aGUgbG9hZGluZyBkYXRhIGZyb20gdGhlIHNlcnZlciDigJQgd2hpY2ggaW5jbHVkZXMgd2hldGhlciBvclxuICAvLyBub3QgdGhpcyBsYXlvdXQgaGFzIGEgbG9hZGluZyBjb21wb25lbnQgYXQgYWxsLlxuICAvL1xuICAvLyBJdCdzIE9LIHRvIHN1c3BlbmQgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZSB0aGUgZmFsbGJhY2sgYmVjYXVzZSB0aGlzXG4gIC8vIHByb21pc2Ugd2lsbCByZXNvbHZlIHNpbXVsdGFuZW91c2x5IHdpdGggdGhlIGRhdGEgZm9yIHRoZSBzZWdtZW50IGl0c2VsZi5cbiAgLy8gU28gaXQgd2lsbCBuZXZlciBzdXNwZW5kIGZvciBsb25nZXIgdGhhbiBpdCB3b3VsZCBoYXZlIGlmIHdlIGRpZG4ndCB1c2VcbiAgLy8gYSBTdXNwZW5zZSBmYWxsYmFjayBhdCBhbGwuXG4gIGxldCBsb2FkaW5nTW9kdWxlRGF0YVxuICBpZiAoXG4gICAgdHlwZW9mIGxvYWRpbmcgPT09ICdvYmplY3QnICYmXG4gICAgbG9hZGluZyAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiAobG9hZGluZyBhcyBhbnkpLnRoZW4gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgY29uc3QgcHJvbWlzZUZvckxvYWRpbmcgPSBsb2FkaW5nIGFzIFByb21pc2U8TG9hZGluZ01vZHVsZURhdGE+XG4gICAgbG9hZGluZ01vZHVsZURhdGEgPSB1c2UocHJvbWlzZUZvckxvYWRpbmcpXG4gIH0gZWxzZSB7XG4gICAgbG9hZGluZ01vZHVsZURhdGEgPSBsb2FkaW5nIGFzIExvYWRpbmdNb2R1bGVEYXRhXG4gIH1cblxuICBpZiAobG9hZGluZ01vZHVsZURhdGEpIHtcbiAgICBjb25zdCBsb2FkaW5nUnNjID0gbG9hZGluZ01vZHVsZURhdGFbMF1cbiAgICBjb25zdCBsb2FkaW5nU3R5bGVzID0gbG9hZGluZ01vZHVsZURhdGFbMV1cbiAgICBjb25zdCBsb2FkaW5nU2NyaXB0cyA9IGxvYWRpbmdNb2R1bGVEYXRhWzJdXG4gICAgcmV0dXJuIChcbiAgICAgIDxTdXNwZW5zZVxuICAgICAgICBmYWxsYmFjaz17XG4gICAgICAgICAgPD5cbiAgICAgICAgICAgIHtsb2FkaW5nU3R5bGVzfVxuICAgICAgICAgICAge2xvYWRpbmdTY3JpcHRzfVxuICAgICAgICAgICAge2xvYWRpbmdSc2N9XG4gICAgICAgICAgPC8+XG4gICAgICAgIH1cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9TdXNwZW5zZT5cbiAgICApXG4gIH1cblxuICByZXR1cm4gPD57Y2hpbGRyZW59PC8+XG59XG5cbmZ1bmN0aW9uIFJlbmRlckNoaWxkcmVuKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pIHtcbiAgcmV0dXJuIDw+e2NoaWxkcmVufTwvPlxufVxuXG4vKipcbiAqIE91dGVyTGF5b3V0Um91dGVyIGhhbmRsZXMgdGhlIGN1cnJlbnQgc2VnbWVudCBhcyB3ZWxsIGFzIDxPZmZzY3JlZW4+IHJlbmRlcmluZyBvZiBvdGhlciBzZWdtZW50cy5cbiAqIEl0IGNhbiBiZSByZW5kZXJlZCBuZXh0IHRvIGVhY2ggb3RoZXIgd2l0aCBhIGRpZmZlcmVudCBgcGFyYWxsZWxSb3V0ZXJLZXlgLCBhbGxvd2luZyBmb3IgUGFyYWxsZWwgcm91dGVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBPdXRlckxheW91dFJvdXRlcih7XG4gIHBhcmFsbGVsUm91dGVyS2V5LFxuICBlcnJvcixcbiAgZXJyb3JTdHlsZXMsXG4gIGVycm9yU2NyaXB0cyxcbiAgdGVtcGxhdGVTdHlsZXMsXG4gIHRlbXBsYXRlU2NyaXB0cyxcbiAgdGVtcGxhdGUsXG4gIG5vdEZvdW5kLFxuICBmb3JiaWRkZW4sXG4gIHVuYXV0aG9yaXplZCxcbiAgZ3JhY2VmdWxseURlZ3JhZGUsXG4gIHNlZ21lbnRWaWV3Qm91bmRhcmllcyxcbn06IHtcbiAgcGFyYWxsZWxSb3V0ZXJLZXk6IHN0cmluZ1xuICBlcnJvcjogRXJyb3JDb21wb25lbnQgfCB1bmRlZmluZWRcbiAgZXJyb3JTdHlsZXM6IFJlYWN0LlJlYWN0Tm9kZSB8IHVuZGVmaW5lZFxuICBlcnJvclNjcmlwdHM6IFJlYWN0LlJlYWN0Tm9kZSB8IHVuZGVmaW5lZFxuICB0ZW1wbGF0ZVN0eWxlczogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkXG4gIHRlbXBsYXRlU2NyaXB0czogUmVhY3QuUmVhY3ROb2RlIHwgdW5kZWZpbmVkXG4gIHRlbXBsYXRlOiBSZWFjdC5SZWFjdE5vZGVcbiAgbm90Rm91bmQ6IFJlYWN0LlJlYWN0Tm9kZSB8IHVuZGVmaW5lZFxuICBmb3JiaWRkZW46IFJlYWN0LlJlYWN0Tm9kZSB8IHVuZGVmaW5lZFxuICB1bmF1dGhvcml6ZWQ6IFJlYWN0LlJlYWN0Tm9kZSB8IHVuZGVmaW5lZFxuICBncmFjZWZ1bGx5RGVncmFkZT86IGJvb2xlYW5cbiAgc2VnbWVudFZpZXdCb3VuZGFyaWVzPzogUmVhY3QuUmVhY3ROb2RlXG59KSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KExheW91dFJvdXRlckNvbnRleHQpXG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IGV4cGVjdGVkIGxheW91dCByb3V0ZXIgdG8gYmUgbW91bnRlZCcpXG4gIH1cblxuICBjb25zdCB7IHBhcmVudFRyZWUsIHBhcmVudENhY2hlTm9kZSwgcGFyZW50U2VnbWVudFBhdGgsIHVybCB9ID0gY29udGV4dFxuXG4gIC8vIEdldCB0aGUgQ2FjaGVOb2RlIGZvciB0aGlzIHNlZ21lbnQgYnkgcmVhZGluZyBpdCBmcm9tIHRoZSBwYXJlbnQgc2VnbWVudCdzXG4gIC8vIGNoaWxkIG1hcC5cbiAgY29uc3QgcGFyZW50UGFyYWxsZWxSb3V0ZXMgPSBwYXJlbnRDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXNcbiAgbGV0IHNlZ21lbnRNYXAgPSBwYXJlbnRQYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZXJLZXkpXG4gIC8vIElmIHRoZSBwYXJhbGxlbCByb3V0ZXIgY2FjaGUgbm9kZSBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC5cbiAgLy8gVGhpcyB3cml0ZXMgdG8gdGhlIGNhY2hlIHdoZW4gdGhlcmUgaXMgbm8gaXRlbSBpbiB0aGUgY2FjaGUgeWV0LiBJdCBuZXZlciAqb3ZlcndyaXRlcyogZXhpc3RpbmcgY2FjaGUgaXRlbXMgd2hpY2ggaXMgd2h5IGl0J3Mgc2FmZSBpbiBjb25jdXJyZW50IG1vZGUuXG4gIGlmICghc2VnbWVudE1hcCkge1xuICAgIHNlZ21lbnRNYXAgPSBuZXcgTWFwKClcbiAgICBwYXJlbnRQYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZXJLZXksIHNlZ21lbnRNYXApXG4gIH1cbiAgY29uc3QgcGFyZW50VHJlZVNlZ21lbnQgPSBwYXJlbnRUcmVlWzBdXG4gIGNvbnN0IHNlZ21lbnRQYXRoID1cbiAgICBwYXJlbnRTZWdtZW50UGF0aCA9PT0gbnVsbFxuICAgICAgPyAvLyBUT0RPOiBUaGUgcm9vdCBzZWdtZW50IHZhbHVlIGlzIGN1cnJlbnRseSBvbWl0dGVkIGZyb20gdGhlIHNlZ21lbnRcbiAgICAgICAgLy8gcGF0aC4gVGhpcyBoYXMgbGVkIHRvIGEgYnVuY2ggb2Ygc3BlY2lhbCBjYXNlcyBzY2F0dGVyZWQgdGhyb3VnaG91dFxuICAgICAgICAvLyB0aGUgY29kZS4gV2Ugc2hvdWxkIGNsZWFuIHRoaXMgdXAuXG4gICAgICAgIFtwYXJhbGxlbFJvdXRlcktleV1cbiAgICAgIDogcGFyZW50U2VnbWVudFBhdGguY29uY2F0KFtwYXJlbnRUcmVlU2VnbWVudCwgcGFyYWxsZWxSb3V0ZXJLZXldKVxuXG4gIC8vIFRoZSBcInN0YXRlXCIga2V5IG9mIGEgc2VnbWVudCBpcyB0aGUgb25lIHBhc3NlZCB0byBSZWFjdCDigJQgaXQgcmVwcmVzZW50cyB0aGVcbiAgLy8gaWRlbnRpdHkgb2YgdGhlIFVJIHRyZWUuIFdoZW5ldmVyIHRoZSBzdGF0ZSBrZXkgY2hhbmdlcywgdGhlIHRyZWUgaXNcbiAgLy8gcmVjcmVhdGVkIGFuZCB0aGUgc3RhdGUgaXMgcmVzZXQuIEluIHRoZSBBcHAgUm91dGVyIG1vZGVsLCBzZWFyY2ggcGFyYW1zIGRvXG4gIC8vIG5vdCBjYXVzZSBzdGF0ZSB0byBiZSBsb3N0LCBzbyB0d28gc2VnbWVudHMgd2l0aCB0aGUgc2FtZSBzZWdtZW50IHBhdGggYnV0XG4gIC8vIGRpZmZlcmVudCBzZWFyY2ggcGFyYW1zIHNob3VsZCBoYXZlIHRoZSBzYW1lIHN0YXRlIGtleS5cbiAgLy9cbiAgLy8gVGhlIFwiY2FjaGVcIiBrZXkgb2YgYSBzZWdtZW50LCBob3dldmVyLCAqZG9lcyogaW5jbHVkZSB0aGUgc2VhcmNoIHBhcmFtcywgaWZcbiAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBzZWdtZW50IGFjY2Vzc2VkIHRoZSBzZWFyY2ggcGFyYW1zIG9uIHRoZSBzZXJ2ZXIuXG4gIC8vIChUaGlzIG9ubHkgYXBwbGllcyB0byBwYWdlIHNlZ21lbnRzOyBsYXlvdXQgc2VnbWVudHMgY2Fubm90IGFjY2VzcyBzZWFyY2hcbiAgLy8gcGFyYW1zIG9uIHRoZSBzZXJ2ZXIuKVxuICBjb25zdCBhY3RpdmVUcmVlID0gcGFyZW50VHJlZVsxXVtwYXJhbGxlbFJvdXRlcktleV1cbiAgY29uc3QgYWN0aXZlU2VnbWVudCA9IGFjdGl2ZVRyZWVbMF1cbiAgY29uc3QgYWN0aXZlU3RhdGVLZXkgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShhY3RpdmVTZWdtZW50LCB0cnVlKSAvLyBubyBzZWFyY2ggcGFyYW1zXG5cbiAgLy8gQXQgZWFjaCBsZXZlbCBvZiB0aGUgcm91dGUgdHJlZSwgbm90IG9ubHkgZG8gd2UgcmVuZGVyIHRoZSBjdXJyZW50bHlcbiAgLy8gYWN0aXZlIHNlZ21lbnQg4oCUIHdlIGFsc28gcmVuZGVyIHRoZSBsYXN0IE4gc2VnbWVudHMgdGhhdCB3ZXJlIGFjdGl2ZSBhdFxuICAvLyB0aGlzIGxldmVsIGluc2lkZSBhIGhpZGRlbiA8QWN0aXZpdHk+IGJvdW5kYXJ5LCB0byBwcmVzZXJ2ZSB0aGVpciBzdGF0ZVxuICAvLyBpZiBvciB3aGVuIHRoZSB1c2VyIG5hdmlnYXRlcyB0byB0aGVtIGFnYWluLlxuICAvL1xuICAvLyBiZmNhY2hlRW50cnkgaXMgYSBsaW5rZWQgbGlzdCBvZiBGbGlnaHRSb3V0ZXJTdGF0ZXMuXG4gIGxldCBiZmNhY2hlRW50cnk6IFJvdXRlckJGQ2FjaGVFbnRyeSB8IG51bGwgPSB1c2VSb3V0ZXJCRkNhY2hlKFxuICAgIGFjdGl2ZVRyZWUsXG4gICAgYWN0aXZlU3RhdGVLZXlcbiAgKVxuICBsZXQgY2hpbGRyZW46IEFycmF5PFJlYWN0LlJlYWN0Tm9kZT4gPSBbXVxuICBkbyB7XG4gICAgY29uc3QgdHJlZSA9IGJmY2FjaGVFbnRyeS50cmVlXG4gICAgY29uc3Qgc3RhdGVLZXkgPSBiZmNhY2hlRW50cnkuc3RhdGVLZXlcbiAgICBjb25zdCBzZWdtZW50ID0gdHJlZVswXVxuICAgIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudClcblxuICAgIC8vIFJlYWQgc2VnbWVudCBwYXRoIGZyb20gdGhlIHBhcmFsbGVsIHJvdXRlciBjYWNoZSBub2RlLlxuICAgIGxldCBjYWNoZU5vZGUgPSBzZWdtZW50TWFwLmdldChjYWNoZUtleSlcbiAgICBpZiAoY2FjaGVOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFdoZW4gZGF0YSBpcyBub3QgYXZhaWxhYmxlIGR1cmluZyByZW5kZXJpbmcgY2xpZW50LXNpZGUgd2UgbmVlZCB0byBmZXRjaFxuICAgICAgLy8gaXQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgY29uc3QgbmV3TGF6eUNhY2hlTm9kZTogTGF6eUNhY2hlTm9kZSA9IHtcbiAgICAgICAgbGF6eURhdGE6IG51bGwsXG4gICAgICAgIHJzYzogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hSc2M6IG51bGwsXG4gICAgICAgIGhlYWQ6IG51bGwsXG4gICAgICAgIHByZWZldGNoSGVhZDogbnVsbCxcbiAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgbG9hZGluZzogbnVsbCxcbiAgICAgICAgbmF2aWdhdGVkQXQ6IC0xLFxuICAgICAgfVxuXG4gICAgICAvLyBGbGlnaHQgZGF0YSBmZXRjaCBraWNrZWQgb2ZmIGR1cmluZyByZW5kZXIgYW5kIHB1dCBpbnRvIHRoZSBjYWNoZS5cbiAgICAgIGNhY2hlTm9kZSA9IG5ld0xhenlDYWNoZU5vZGVcbiAgICAgIHNlZ21lbnRNYXAuc2V0KGNhY2hlS2V5LCBuZXdMYXp5Q2FjaGVOb2RlKVxuICAgIH1cblxuICAgIC8qXG4gICAgLSBFcnJvciBib3VuZGFyeVxuICAgICAgLSBPbmx5IHJlbmRlcnMgZXJyb3IgYm91bmRhcnkgaWYgZXJyb3IgY29tcG9uZW50IGlzIHByb3ZpZGVkLlxuICAgICAgLSBSZW5kZXJlZCBmb3IgZWFjaCBzZWdtZW50IHRvIGVuc3VyZSB0aGV5IGhhdmUgdGhlaXIgb3duIGVycm9yIHN0YXRlLlxuICAgICAgLSBXaGVuIGdyYWNlZnVsbHkgZGVncmFkZSBmb3IgYm90cywgc2tpcCByZW5kZXJpbmcgZXJyb3IgYm91bmRhcnkuXG4gICAgLSBMb2FkaW5nIGJvdW5kYXJ5XG4gICAgICAtIE9ubHkgcmVuZGVycyBzdXNwZW5zZSBib3VuZGFyeSBpZiBsb2FkaW5nIGNvbXBvbmVudHMgaXMgcHJvdmlkZWQuXG4gICAgICAtIFJlbmRlcmVkIGZvciBlYWNoIHNlZ21lbnQgdG8gZW5zdXJlIHRoZXkgaGF2ZSB0aGVpciBvd24gbG9hZGluZyBzdGF0ZS5cbiAgICAgIC0gUGFzc2VkIHRvIHRoZSByb3V0ZXIgZHVyaW5nIHJlbmRlcmluZyB0byBlbnN1cmUgaXQgY2FuIGJlIGltbWVkaWF0ZWx5IHJlbmRlcmVkIHdoZW4gc3VzcGVuZGluZyBvbiBhIEZsaWdodCBmZXRjaC5cbiAgKi9cblxuICAgIGNvbnN0IEVycm9yQm91bmRhcnlDb21wb25lbnQgPSBncmFjZWZ1bGx5RGVncmFkZVxuICAgICAgPyBSZW5kZXJDaGlsZHJlblxuICAgICAgOiBFcnJvckJvdW5kYXJ5XG5cbiAgICBsZXQgc2VnbWVudEJvdW5kYXJ5VHJpZ2dlck5vZGU6IFJlYWN0LlJlYWN0Tm9kZSA9IG51bGxcbiAgICBsZXQgc2VnbWVudFZpZXdTdGF0ZU5vZGU6IFJlYWN0LlJlYWN0Tm9kZSA9IG51bGxcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBwcm9jZXNzLmVudi5fX05FWFRfREVWVE9PTF9TRUdNRU5UX0VYUExPUkVSXG4gICAgKSB7XG4gICAgICBjb25zdCB7IFNlZ21lbnRCb3VuZGFyeVRyaWdnZXJOb2RlLCBTZWdtZW50Vmlld1N0YXRlTm9kZSB9ID1cbiAgICAgICAgcmVxdWlyZSgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL3NlZ21lbnQtZXhwbG9yZXItbm9kZScpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9zZWdtZW50LWV4cGxvcmVyLW5vZGUnKVxuXG4gICAgICBjb25zdCBwYWdlUHJlZml4ID0gbm9ybWFsaXplQXBwUGF0aCh1cmwpXG4gICAgICBzZWdtZW50Vmlld1N0YXRlTm9kZSA9IChcbiAgICAgICAgPFNlZ21lbnRWaWV3U3RhdGVOb2RlIGtleT17cGFnZVByZWZpeH0gcGFnZT17cGFnZVByZWZpeH0gLz5cbiAgICAgIClcblxuICAgICAgc2VnbWVudEJvdW5kYXJ5VHJpZ2dlck5vZGUgPSAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPFNlZ21lbnRCb3VuZGFyeVRyaWdnZXJOb2RlIC8+XG4gICAgICAgIDwvPlxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFRPRE86IFRoZSBsb2FkaW5nIG1vZHVsZSBkYXRhIGZvciBhIHNlZ21lbnQgaXMgc3RvcmVkIG9uIHRoZSBwYXJlbnQsIHRoZW5cbiAgICAvLyBhcHBsaWVkIHRvIGVhY2ggb2YgdGhhdCBwYXJlbnQgc2VnbWVudCdzIHBhcmFsbGVsIHJvdXRlIHNsb3RzLiBJbiB0aGVcbiAgICAvLyBzaW1wbGUgY2FzZSB3aGVyZSB0aGVyZSdzIG9ubHkgb25lIHBhcmFsbGVsIHJvdXRlICh0aGUgYGNoaWxkcmVuYCBzbG90KSxcbiAgICAvLyB0aGlzIGlzIG5vIGRpZmZlcmVudCBmcm9tIGlmIHRoZSBsb2FkaW5nIG1vZHVsZSBkYXRhIHdoZXJlIHN0b3JlZCBvbiB0aGVcbiAgICAvLyBjaGlsZCBkaXJlY3RseS4gQnV0IEknbSBub3Qgc3VyZSB0aGlzIGFjdHVhbGx5IG1ha2VzIHNlbnNlIHdoZW4gdGhlcmUgYXJlXG4gICAgLy8gbXVsdGlwbGUgcGFyYWxsZWwgcm91dGVzLiBJdCdzIG5vdCBhIGh1Z2UgaXNzdWUgYmVjYXVzZSB5b3UgYWx3YXlzIGhhdmVcbiAgICAvLyB0aGUgb3B0aW9uIHRvIGRlZmluZSBhIG5hcnJvd2VyIGxvYWRpbmcgYm91bmRhcnkgZm9yIGEgcGFydGljdWxhciBzbG90LiBCdXRcbiAgICAvLyB0aGlzIHNvcnQgb2Ygc21lbGxzIGxpa2UgYW4gaW1wbGVtZW50YXRpb24gYWNjaWRlbnQgdG8gbWUuXG4gICAgY29uc3QgbG9hZGluZ01vZHVsZURhdGEgPSBwYXJlbnRDYWNoZU5vZGUubG9hZGluZ1xuICAgIGxldCBjaGlsZCA9IChcbiAgICAgIDxUZW1wbGF0ZUNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAga2V5PXtzdGF0ZUtleX1cbiAgICAgICAgdmFsdWU9e1xuICAgICAgICAgIDxTY3JvbGxBbmRGb2N1c0hhbmRsZXIgc2VnbWVudFBhdGg9e3NlZ21lbnRQYXRofT5cbiAgICAgICAgICAgIDxFcnJvckJvdW5kYXJ5Q29tcG9uZW50XG4gICAgICAgICAgICAgIGVycm9yQ29tcG9uZW50PXtlcnJvcn1cbiAgICAgICAgICAgICAgZXJyb3JTdHlsZXM9e2Vycm9yU3R5bGVzfVxuICAgICAgICAgICAgICBlcnJvclNjcmlwdHM9e2Vycm9yU2NyaXB0c31cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPExvYWRpbmdCb3VuZGFyeSBsb2FkaW5nPXtsb2FkaW5nTW9kdWxlRGF0YX0+XG4gICAgICAgICAgICAgICAgPEhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5XG4gICAgICAgICAgICAgICAgICBub3RGb3VuZD17bm90Rm91bmR9XG4gICAgICAgICAgICAgICAgICBmb3JiaWRkZW49e2ZvcmJpZGRlbn1cbiAgICAgICAgICAgICAgICAgIHVuYXV0aG9yaXplZD17dW5hdXRob3JpemVkfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxSZWRpcmVjdEJvdW5kYXJ5PlxuICAgICAgICAgICAgICAgICAgICA8SW5uZXJMYXlvdXRSb3V0ZXJcbiAgICAgICAgICAgICAgICAgICAgICB1cmw9e3VybH1cbiAgICAgICAgICAgICAgICAgICAgICB0cmVlPXt0cmVlfVxuICAgICAgICAgICAgICAgICAgICAgIGNhY2hlTm9kZT17Y2FjaGVOb2RlfVxuICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRQYXRoPXtzZWdtZW50UGF0aH1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAge3NlZ21lbnRCb3VuZGFyeVRyaWdnZXJOb2RlfVxuICAgICAgICAgICAgICAgICAgPC9SZWRpcmVjdEJvdW5kYXJ5PlxuICAgICAgICAgICAgICAgIDwvSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnk+XG4gICAgICAgICAgICAgIDwvTG9hZGluZ0JvdW5kYXJ5PlxuICAgICAgICAgICAgPC9FcnJvckJvdW5kYXJ5Q29tcG9uZW50PlxuICAgICAgICAgICAge3NlZ21lbnRWaWV3U3RhdGVOb2RlfVxuICAgICAgICAgIDwvU2Nyb2xsQW5kRm9jdXNIYW5kbGVyPlxuICAgICAgICB9XG4gICAgICA+XG4gICAgICAgIHt0ZW1wbGF0ZVN0eWxlc31cbiAgICAgICAge3RlbXBsYXRlU2NyaXB0c31cbiAgICAgICAge3RlbXBsYXRlfVxuICAgICAgPC9UZW1wbGF0ZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnN0IHsgU2VnbWVudFN0YXRlUHJvdmlkZXIgfSA9XG4gICAgICAgIHJlcXVpcmUoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9zZWdtZW50LWV4cGxvcmVyLW5vZGUnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvc2VnbWVudC1leHBsb3Jlci1ub2RlJylcblxuICAgICAgY2hpbGQgPSAoXG4gICAgICAgIDxTZWdtZW50U3RhdGVQcm92aWRlciBrZXk9e3N0YXRlS2V5fT5cbiAgICAgICAgICB7Y2hpbGR9XG4gICAgICAgICAge3NlZ21lbnRWaWV3Qm91bmRhcmllc31cbiAgICAgICAgPC9TZWdtZW50U3RhdGVQcm92aWRlcj5cbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CRl9DQUNIRSkge1xuICAgICAgY2hpbGQgPSAoXG4gICAgICAgIDxBY3Rpdml0eVxuICAgICAgICAgIGtleT17c3RhdGVLZXl9XG4gICAgICAgICAgbW9kZT17c3RhdGVLZXkgPT09IGFjdGl2ZVN0YXRlS2V5ID8gJ3Zpc2libGUnIDogJ2hpZGRlbid9XG4gICAgICAgID5cbiAgICAgICAgICB7Y2hpbGR9XG4gICAgICAgIDwvQWN0aXZpdHk+XG4gICAgICApXG4gICAgfVxuXG4gICAgY2hpbGRyZW4ucHVzaChjaGlsZClcblxuICAgIGJmY2FjaGVFbnRyeSA9IGJmY2FjaGVFbnRyeS5uZXh0XG4gIH0gd2hpbGUgKGJmY2FjaGVFbnRyeSAhPT0gbnVsbClcblxuICByZXR1cm4gY2hpbGRyZW5cbn1cbiJdLCJuYW1lcyI6WyJPdXRlckxheW91dFJvdXRlciIsIkFjdGl2aXR5IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9ST1VURVJfQkZfQ0FDSEUiLCJyZXF1aXJlIiwidW5zdGFibGVfQWN0aXZpdHkiLCJ3YWxrQWRkUmVmZXRjaCIsInNlZ21lbnRQYXRoVG9XYWxrIiwidHJlZVRvUmVjcmVhdGUiLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZUtleSIsImlzTGFzdCIsImxlbmd0aCIsIm1hdGNoU2VnbWVudCIsImhhc093blByb3BlcnR5Iiwic3ViVHJlZSIsInVuZGVmaW5lZCIsInNsaWNlIiwiX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFIiwiUmVhY3RET00iLCJmaW5kRE9NTm9kZSIsImluc3RhbmNlIiwid2luZG93IiwiaW50ZXJuYWxfcmVhY3RET01maW5kRE9NTm9kZSIsInJlY3RQcm9wZXJ0aWVzIiwic2hvdWxkU2tpcEVsZW1lbnQiLCJlbGVtZW50IiwiaW5jbHVkZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJOT0RFX0VOViIsImNvbnNvbGUiLCJ3YXJuIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImV2ZXJ5IiwiaXRlbSIsInRvcE9mRWxlbWVudEluVmlld3BvcnQiLCJ2aWV3cG9ydEhlaWdodCIsInRvcCIsImdldEhhc2hGcmFnbWVudERvbU5vZGUiLCJoYXNoRnJhZ21lbnQiLCJkb2N1bWVudCIsImJvZHkiLCJnZXRFbGVtZW50QnlJZCIsImdldEVsZW1lbnRzQnlOYW1lIiwiSW5uZXJTY3JvbGxBbmRGb2N1c0hhbmRsZXIiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbXBvbmVudERpZE1vdW50IiwiaGFuZGxlUG90ZW50aWFsU2Nyb2xsIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJvcHMiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImFwcGx5IiwicmVuZGVyIiwiY2hpbGRyZW4iLCJzZWdtZW50UGF0aCIsInNlZ21lbnRQYXRocyIsInNvbWUiLCJzY3JvbGxSZWZTZWdtZW50UGF0aCIsImluZGV4IiwiZG9tTm9kZSIsIkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsInBhcmVudEVsZW1lbnQiLCJsb2NhbE5hbWUiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJkaXNhYmxlU21vb3RoU2Nyb2xsRHVyaW5nUm91dGVUcmFuc2l0aW9uIiwic2Nyb2xsSW50b1ZpZXciLCJodG1sRWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudEhlaWdodCIsInNjcm9sbFRvcCIsImRvbnRGb3JjZUxheW91dCIsIm9ubHlIYXNoQ2hhbmdlIiwiZm9jdXMiLCJTY3JvbGxBbmRGb2N1c0hhbmRsZXIiLCJjb250ZXh0IiwidXNlQ29udGV4dCIsIkdsb2JhbExheW91dFJvdXRlckNvbnRleHQiLCJFcnJvciIsIklubmVyTGF5b3V0Um91dGVyIiwidHJlZSIsImNhY2hlTm9kZSIsInVybCIsImZ1bGxUcmVlIiwicmVzb2x2ZWRQcmVmZXRjaFJzYyIsInByZWZldGNoUnNjIiwicnNjIiwidXNlRGVmZXJyZWRWYWx1ZSIsInJlc29sdmVkUnNjIiwidGhlbiIsInVzZSIsImxhenlEYXRhIiwicmVmZXRjaFRyZWUiLCJpbmNsdWRlTmV4dFVybCIsImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsIm5hdmlnYXRlZEF0IiwiRGF0ZSIsIm5vdyIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImZsaWdodFJvdXRlclN0YXRlIiwibmV4dFVybCIsInNlcnZlclJlc3BvbnNlIiwic3RhcnRUcmFuc2l0aW9uIiwiZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24iLCJ0eXBlIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsInByZXZpb3VzVHJlZSIsInVucmVzb2x2ZWRUaGVuYWJsZSIsInN1YnRyZWUiLCJMYXlvdXRSb3V0ZXJDb250ZXh0IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInBhcmVudFRyZWUiLCJwYXJlbnRDYWNoZU5vZGUiLCJwYXJlbnRTZWdtZW50UGF0aCIsIkxvYWRpbmdCb3VuZGFyeSIsImxvYWRpbmciLCJsb2FkaW5nTW9kdWxlRGF0YSIsInByb21pc2VGb3JMb2FkaW5nIiwibG9hZGluZ1JzYyIsImxvYWRpbmdTdHlsZXMiLCJsb2FkaW5nU2NyaXB0cyIsIlN1c3BlbnNlIiwiZmFsbGJhY2siLCJSZW5kZXJDaGlsZHJlbiIsInBhcmFsbGVsUm91dGVyS2V5IiwiZXJyb3IiLCJlcnJvclN0eWxlcyIsImVycm9yU2NyaXB0cyIsInRlbXBsYXRlU3R5bGVzIiwidGVtcGxhdGVTY3JpcHRzIiwidGVtcGxhdGUiLCJub3RGb3VuZCIsImZvcmJpZGRlbiIsInVuYXV0aG9yaXplZCIsImdyYWNlZnVsbHlEZWdyYWRlIiwic2VnbWVudFZpZXdCb3VuZGFyaWVzIiwicGFyZW50UGFyYWxsZWxSb3V0ZXMiLCJwYXJhbGxlbFJvdXRlcyIsInNlZ21lbnRNYXAiLCJnZXQiLCJNYXAiLCJzZXQiLCJwYXJlbnRUcmVlU2VnbWVudCIsImNvbmNhdCIsImFjdGl2ZVRyZWUiLCJhY3RpdmVTZWdtZW50IiwiYWN0aXZlU3RhdGVLZXkiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsImJmY2FjaGVFbnRyeSIsInVzZVJvdXRlckJGQ2FjaGUiLCJzdGF0ZUtleSIsImNhY2hlS2V5IiwibmV3TGF6eUNhY2hlTm9kZSIsImhlYWQiLCJwcmVmZXRjaEhlYWQiLCJFcnJvckJvdW5kYXJ5Q29tcG9uZW50IiwiRXJyb3JCb3VuZGFyeSIsInNlZ21lbnRCb3VuZGFyeVRyaWdnZXJOb2RlIiwic2VnbWVudFZpZXdTdGF0ZU5vZGUiLCJfX05FWFRfREVWVE9PTF9TRUdNRU5UX0VYUExPUkVSIiwiU2VnbWVudEJvdW5kYXJ5VHJpZ2dlck5vZGUiLCJTZWdtZW50Vmlld1N0YXRlTm9kZSIsInBhZ2VQcmVmaXgiLCJub3JtYWxpemVBcHBQYXRoIiwicGFnZSIsImNoaWxkIiwiVGVtcGxhdGVDb250ZXh0IiwiZXJyb3JDb21wb25lbnQiLCJIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSIsIlJlZGlyZWN0Qm91bmRhcnkiLCJTZWdtZW50U3RhdGVQcm92aWRlciIsIm1vZGUiLCJwdXNoIiwibmV4dCJdLCJtYXBwaW5ncyI6IkFBNENpQkUsUUFBUUMsR0FBRyxDQUFDQyxzQkFBc0I7QUE1Q25EOzs7OzsrQkE4ZUE7OztDQUdDLEdBQ0QsV0FBQTs7O2VBQXdCSjs7Ozs7O29DQW5lakI7aUVBU0E7bUVBQ2M7K0NBS2Q7cUNBQzZCO29DQUNEOytCQUNMOytCQUNEO3FDQUM0QjtrQ0FDeEI7Z0NBQ1U7c0NBQ047bURBQ2E7Z0NBQ1Y7eUJBQ2tCOzBCQUN6QjtBQUVqQyxNQUFNQyxpREFDREksUUFBUSxTQUFvQ0MsU0FDN0MsUUFEOEQ7QUFHbEU7OztDQUdDLEdBQ0QsU0FBU0MsZUFDUEMsaUJBQWdELEVBQ2hEQyxjQUFpQztJQUVqQyxJQUFJRCxtQkFBbUI7UUFDckIsTUFBTSxDQUFDRSxTQUFTQyxpQkFBaUIsR0FBR0g7UUFDcEMsTUFBTUksU0FBU0osa0JBQWtCSyxNQUFNLEtBQUs7UUFFNUMsSUFBSUMsQ0FBQUEsR0FBQUEsZUFBQUEsWUFBWSxFQUFDTCxjQUFjLENBQUMsRUFBRSxFQUFFQyxVQUFVO1lBQzVDLElBQUlELGNBQWMsQ0FBQyxFQUFFLENBQUNNLGNBQWMsQ0FBQ0osbUJBQW1CO2dCQUN0RCxJQUFJQyxRQUFRO29CQUNWLE1BQU1JLFVBQVVULGVBQ2RVLFdBQ0FSLGNBQWMsQ0FBQyxFQUFFLENBQUNFLGlCQUFpQjtvQkFFckMsT0FBTzt3QkFDTEYsY0FBYyxDQUFDLEVBQUU7d0JBQ2pCOzRCQUNFLEdBQUdBLGNBQWMsQ0FBQyxFQUFF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QUFBQTs7b0JBQ0VMO29CQUNBOUI7O2VBRndCZTtRQUsvQjtRQUVBLElBQUk1SixRQUFRQyxHQUFHLENBQUNDLHNCQUFzQixFQUFFOztRQVd4Q3FELFNBQVMySCxJQUFJLENBQUNQO1FBRWRqQixlQUFlQSxhQUFheUIsSUFBSTtJQUNsQyxRQUFTekIsaUJBQWlCLEtBQUs7SUFFL0IsT0FBT25HO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTg3OTMsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0LCB0eXBlIEpTWCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVGVtcGxhdGVDb250ZXh0IH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJlbmRlckZyb21UZW1wbGF0ZUNvbnRleHQoKTogSlNYLkVsZW1lbnQge1xuICBjb25zdCBjaGlsZHJlbiA9IHVzZUNvbnRleHQoVGVtcGxhdGVDb250ZXh0KVxuICByZXR1cm4gPD57Y2hpbGRyZW59PC8+XG59XG4iXSwibmFtZXMiOlsiUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCIsImNoaWxkcmVuIiwidXNlQ29udGV4dCIsIlRlbXBsYXRlQ29udGV4dCJdLCJtYXBwaW5ncyI6Ijs7OytCQUtBLFdBQUE7OztlQUF3QkE7Ozs7O2lFQUhvQjsrQ0FDWjtBQUVqQixTQUFTQTtJQUN0QixNQUFNQyxXQUFXQyxDQUFBQSxHQUFBQSxPQUFBQSxVQUFVLEVBQUNDLCtCQUFBQSxlQUFlO0lBQzNDLE9BQUEsV0FBQSxHQUFPLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQSxZQUFBLFFBQUEsRUFBQTtrQkFBR0Y7O0FBQ1oiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTg4MjUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIEludmFyaWFudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIG9wdGlvbnM/OiBFcnJvck9wdGlvbnMpIHtcbiAgICBzdXBlcihcbiAgICAgIGBJbnZhcmlhbnQ6ICR7bWVzc2FnZS5lbmRzV2l0aCgnLicpID8gbWVzc2FnZSA6IG1lc3NhZ2UgKyAnLid9IFRoaXMgaXMgYSBidWcgaW4gTmV4dC5qcy5gLFxuICAgICAgb3B0aW9uc1xuICAgIClcbiAgICB0aGlzLm5hbWUgPSAnSW52YXJpYW50RXJyb3InXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJJbnZhcmlhbnRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwib3B0aW9ucyIsImVuZHNXaXRoIiwibmFtZSJdLCJtYXBwaW5ncyI6Ijs7OytCQUFhQSxrQkFBQUE7OztlQUFBQTs7O0FBQU4sTUFBTUEsdUJBQXVCQztJQUNsQ0MsWUFBWUMsT0FBZSxFQUFFQyxPQUFzQixDQUFFO1FBQ25ELEtBQUssQ0FDRixnQkFBYUQsQ0FBQUEsUUFBUUUsUUFBUSxDQUFDLE9BQU9GLFVBQVVBLFVBQVUsR0FBRSxJQUFFLDhCQUM5REM7UUFFRixJQUFJLENBQUNFLElBQUksR0FBRztJQUNkO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTg4NDYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBSZWZsZWN0QWRhcHRlciB7XG4gIHN0YXRpYyBnZXQ8VCBleHRlbmRzIG9iamVjdD4oXG4gICAgdGFyZ2V0OiBULFxuICAgIHByb3A6IHN0cmluZyB8IHN5bWJvbCxcbiAgICByZWNlaXZlcjogdW5rbm93blxuICApOiBhbnkge1xuICAgIGNvbnN0IHZhbHVlID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdmFsdWUuYmluZCh0YXJnZXQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBzdGF0aWMgc2V0PFQgZXh0ZW5kcyBvYmplY3Q+KFxuICAgIHRhcmdldDogVCxcbiAgICBwcm9wOiBzdHJpbmcgfCBzeW1ib2wsXG4gICAgdmFsdWU6IGFueSxcbiAgICByZWNlaXZlcjogYW55XG4gICk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcilcbiAgfVxuXG4gIHN0YXRpYyBoYXM8VCBleHRlbmRzIG9iamVjdD4odGFyZ2V0OiBULCBwcm9wOiBzdHJpbmcgfCBzeW1ib2wpOiBib29sZWFuIHtcbiAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKVxuICB9XG5cbiAgc3RhdGljIGRlbGV0ZVByb3BlcnR5PFQgZXh0ZW5kcyBvYmplY3Q+KFxuICAgIHRhcmdldDogVCxcbiAgICBwcm9wOiBzdHJpbmcgfCBzeW1ib2xcbiAgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKVxuICB9XG59XG4iXSwibmFtZXMiOlsiUmVmbGVjdEFkYXB0ZXIiLCJnZXQiLCJ0YXJnZXQiLCJwcm9wIiwicmVjZWl2ZXIiLCJ2YWx1ZSIsIlJlZmxlY3QiLCJiaW5kIiwic2V0IiwiaGFzIiwiZGVsZXRlUHJvcGVydHkiXSwibWFwcGluZ3MiOiI7OzsrQkFBYUEsa0JBQUFBOzs7ZUFBQUE7OztBQUFOLE1BQU1BO0lBQ1gsT0FBT0MsSUFDTEMsTUFBUyxFQUNUQyxJQUFxQixFQUNyQkMsUUFBaUIsRUFDWjtRQUNMLE1BQU1DLFFBQVFDLFFBQVFMLEdBQUcsQ0FBQ0MsUUFBUUMsTUFBTUM7UUFDeEMsSUFBSSxPQUFPQyxVQUFVLFlBQVk7WUFDL0IsT0FBT0EsTUFBTUUsSUFBSSxDQUFDTDtRQUNwQjtRQUVBLE9BQU9HO0lBQ1Q7SUFFQSxPQUFPRyxJQUNMTixNQUFTLEVBQ1RDLElBQXFCLEVBQ3JCRSxLQUFVLEVBQ1ZELFFBQWEsRUFDSjtRQUNULE9BQU9FLFFBQVFFLEdBQUcsQ0FBQ04sUUFBUUMsTUFBTUUsT0FBT0Q7SUFDMUM7SUFFQSxPQUFPSyxJQUFzQlAsTUFBUyxFQUFFQyxJQUFxQixFQUFXO1FBQ3RFLE9BQU9HLFFBQVFHLEdBQUcsQ0FBQ1AsUUFBUUM7SUFDN0I7SUFFQSxPQUFPTyxlQUNMUixNQUFTLEVBQ1RDLElBQXFCLEVBQ1o7UUFDVCxPQUFPRyxRQUFRSSxjQUFjLENBQUNSLFFBQVFDO0lBQ3hDO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTg4NzksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi91dGlscy9yZWZsZWN0LXV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgcmVnZXggd2lsbCBoYXZlIGZhc3QgbmVnYXRpdmVzIG1lYW5pbmcgdmFsaWQgaWRlbnRpZmllcnMgbWF5IG5vdCBwYXNzXG4vLyB0aGlzIHRlc3QuIEhvd2V2ZXIgdGhpcyBpcyBvbmx5IHVzZWQgZHVyaW5nIHN0YXRpYyBnZW5lcmF0aW9uIHRvIHByb3ZpZGUgaGludHNcbi8vIGFib3V0IHdoeSBhIHBhZ2UgYmFpbGVkIG91dCBvZiBzb21lIG9yIGFsbCBwcmVyZW5kZXJpbmcgYW5kIHdlIGNhbiB1c2UgYnJhY2tldCBub3RhdGlvblxuLy8gZm9yIGV4YW1wbGUgd2hpbGUgYOCyoF/gsqBgIGlzIGEgdmFsaWQgaWRlbnRpZmllciBpdCdzIG9rIHRvIHByaW50IGBzZWFyY2hQYXJhbXNbJ+CyoF/gsqAnXWBcbi8vIGV2ZW4gaWYgdGhpcyB3b3VsZCBoYXZlIGJlZW4gZmluZSB0b28gYHNlYXJjaFBhcmFtcy7gsqBf4LKgYFxuY29uc3QgaXNEZWZpbml0ZWx5QVZhbGlkSWRlbnRpZmllciA9IC9eW0EtWmEtel8kXVtBLVphLXowLTlfJF0qJC9cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3ModGFyZ2V0OiBzdHJpbmcsIHByb3A6IHN0cmluZykge1xuICBpZiAoaXNEZWZpbml0ZWx5QVZhbGlkSWRlbnRpZmllci50ZXN0KHByb3ApKSB7XG4gICAgcmV0dXJuIGBcXGAke3RhcmdldH0uJHtwcm9wfVxcYGBcbiAgfVxuICByZXR1cm4gYFxcYCR7dGFyZ2V0fVske0pTT04uc3RyaW5naWZ5KHByb3ApfV1cXGBgXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHkoXG4gIHRhcmdldDogc3RyaW5nLFxuICBwcm9wOiBzdHJpbmdcbikge1xuICBjb25zdCBzdHJpbmdpZmllZFByb3AgPSBKU09OLnN0cmluZ2lmeShwcm9wKVxuICByZXR1cm4gYFxcYFJlZmxlY3QuaGFzKCR7dGFyZ2V0fSwgJHtzdHJpbmdpZmllZFByb3B9KVxcYCwgXFxgJHtzdHJpbmdpZmllZFByb3B9IGluICR7dGFyZ2V0fVxcYCwgb3Igc2ltaWxhcmBcbn1cblxuZXhwb3J0IGNvbnN0IHdlbGxLbm93blByb3BlcnRpZXMgPSBuZXcgU2V0KFtcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZicsXG4gICd0b0xvY2FsZVN0cmluZycsXG5cbiAgLy8gUHJvbWlzZSBwcm90b3R5cGVcbiAgLy8gZmFsbHRocm91Z2hcbiAgJ3RoZW4nLFxuICAnY2F0Y2gnLFxuICAnZmluYWxseScsXG5cbiAgLy8gUmVhY3QgUHJvbWlzZSBleHRlbnNpb25cbiAgLy8gZmFsbHRocm91Z2hcbiAgJ3N0YXR1cycsXG5cbiAgLy8gUmVhY3QgaW50cm9zcGVjdGlvblxuICAnZGlzcGxheU5hbWUnLFxuICAnX2RlYnVnSW5mbycsXG5cbiAgLy8gQ29tbW9uIHRlc3RlZCBwcm9wZXJ0aWVzXG4gIC8vIGZhbGx0aHJvdWdoXG4gICd0b0pTT04nLFxuICAnJCR0eXBlb2YnLFxuICAnX19lc01vZHVsZScsXG5dKVxuIl0sIm5hbWVzIjpbImRlc2NyaWJlSGFzQ2hlY2tpbmdTdHJpbmdQcm9wZXJ0eSIsImRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MiLCJ3ZWxsS25vd25Qcm9wZXJ0aWVzIiwiaXNEZWZpbml0ZWx5QVZhbGlkSWRlbnRpZmllciIsInRhcmdldCIsInByb3AiLCJ0ZXN0IiwiSlNPTiIsInN0cmluZ2lmeSIsInN0cmluZ2lmaWVkUHJvcCIsIlNldCJdLCJtYXBwaW5ncyI6IkFBQUEsNkVBQTZFO0FBQzdFLGlGQUFpRjtBQUNqRiwwRkFBMEY7QUFDMUYsdUZBQXVGO0FBQ3ZGLDJEQUEyRDs7Ozs7Ozs7Ozs7Ozs7OztJQVUzQ0EsaUNBQWlDLEVBQUE7ZUFBakNBOztJQVBBQyw0QkFBNEIsRUFBQTtlQUE1QkE7O0lBZUhDLG1CQUFtQixFQUFBO2VBQW5CQTs7O0FBakJiLE1BQU1DLCtCQUErQjtBQUU5QixTQUFTRiw2QkFBNkJHLE1BQWMsRUFBRUMsSUFBWTtJQUN2RSxJQUFJRiw2QkFBNkJHLElBQUksQ0FBQ0QsT0FBTztRQUMzQyxPQUFRLE1BQUlELFNBQU8sTUFBR0MsT0FBSztJQUM3QjtJQUNBLE9BQVEsTUFBSUQsU0FBTyxNQUFHRyxLQUFLQyxTQUFTLENBQUNILFFBQU07QUFDN0M7QUFFTyxTQUFTTCxrQ0FDZEksTUFBYyxFQUNkQyxJQUFZO0lBRVosTUFBTUksa0JBQWtCRixLQUFLQyxTQUFTLENBQUNIO0lBQ3ZDLE9BQVEsa0JBQWdCRCxTQUFPLE9BQUlLLGtCQUFnQixVQUFTQSxrQkFBZ0IsU0FBTUwsU0FBTztBQUMzRjtBQUVPLE1BQU1GLHNCQUFzQixJQUFJUSxJQUFJO0lBQ3pDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUVBLG9CQUFvQjtJQUNwQixjQUFjO0lBQ2Q7SUFDQTtJQUNBO0lBRUEsMEJBQTBCO0lBQzFCLGNBQWM7SUFDZDtJQUVBLHNCQUFzQjtJQUN0QjtJQUNBO0lBRUEsMkJBQTJCO0lBQzNCLGNBQWM7SUFDZDtJQUNBO0lBQ0E7Q0FDRCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxODk1MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvcmVxdWVzdC9zZWFyY2gtcGFyYW1zLmJyb3dzZXIuZGV2LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgU2VhcmNoUGFyYW1zIH0gZnJvbSAnLi4vLi4vc2VydmVyL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcydcblxuaW1wb3J0IHsgUmVmbGVjdEFkYXB0ZXIgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlZmxlY3QnXG5pbXBvcnQge1xuICBkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzLFxuICBkZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHksXG4gIHdlbGxLbm93blByb3BlcnRpZXMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvdXRpbHMvcmVmbGVjdC11dGlscydcblxuaW50ZXJmYWNlIENhY2hlTGlmZXRpbWUge31cbmNvbnN0IENhY2hlZFNlYXJjaFBhcmFtcyA9IG5ldyBXZWFrTWFwPENhY2hlTGlmZXRpbWUsIFByb21pc2U8U2VhcmNoUGFyYW1zPj4oKVxuXG5mdW5jdGlvbiBtYWtlVW50cmFja2VkRXhvdGljU2VhcmNoUGFyYW1zV2l0aERldldhcm5pbmdzKFxuICB1bmRlcmx5aW5nU2VhcmNoUGFyYW1zOiBTZWFyY2hQYXJhbXNcbik6IFByb21pc2U8U2VhcmNoUGFyYW1zPiB7XG4gIGNvbnN0IGNhY2hlZFNlYXJjaFBhcmFtcyA9IENhY2hlZFNlYXJjaFBhcmFtcy5nZXQodW5kZXJseWluZ1NlYXJjaFBhcmFtcylcbiAgaWYgKGNhY2hlZFNlYXJjaFBhcmFtcykge1xuICAgIHJldHVybiBjYWNoZWRTZWFyY2hQYXJhbXNcbiAgfVxuXG4gIGNvbnN0IHByb3hpZWRQcm9wZXJ0aWVzID0gbmV3IFNldDxzdHJpbmc+KClcbiAgY29uc3QgdW5wcm94aWVkUHJvcGVydGllczogQXJyYXk8c3RyaW5nPiA9IFtdXG5cbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKVxuXG4gIE9iamVjdC5rZXlzKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBpZiAod2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkpIHtcbiAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgICB1bnByb3hpZWRQcm9wZXJ0aWVzLnB1c2gocHJvcClcbiAgICB9IGVsc2Uge1xuICAgICAgcHJveGllZFByb3BlcnRpZXMuYWRkKHByb3ApXG4gICAgICA7KHByb21pc2UgYXMgYW55KVtwcm9wXSA9IHVuZGVybHlpbmdTZWFyY2hQYXJhbXNbcHJvcF1cbiAgICB9XG4gIH0pXG5cbiAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhd2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkgJiZcbiAgICAgICAgICAocHJveGllZFByb3BlcnRpZXMuaGFzKHByb3ApIHx8XG4gICAgICAgICAgICAvLyBXZSBhcmUgYWNjZXNzaW5nIGEgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGV4aXN0IG9uIHRoZSBwcm9taXNlIG5vclxuICAgICAgICAgICAgLy8gdGhlIHVuZGVybHlpbmcgc2VhcmNoUGFyYW1zLlxuICAgICAgICAgICAgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKSA9PT0gZmFsc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKCdzZWFyY2hQYXJhbXMnLCBwcm9wKVxuICAgICAgICAgIHdhcm5Gb3JTeW5jQWNjZXNzKGV4cHJlc3Npb24pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBwcm94aWVkUHJvcGVydGllcy5kZWxldGUocHJvcClcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcilcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICF3ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSAmJlxuICAgICAgICAgIChwcm94aWVkUHJvcGVydGllcy5oYXMocHJvcCkgfHxcbiAgICAgICAgICAgIC8vIFdlIGFyZSBhY2Nlc3NpbmcgYSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHByb21pc2Ugbm9yXG4gICAgICAgICAgICAvLyB0aGUgdW5kZXJseWluZyBzZWFyY2hQYXJhbXMuXG4gICAgICAgICAgICBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApID09PSBmYWxzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGRlc2NyaWJlSGFzQ2hlY2tpbmdTdHJpbmdQcm9wZXJ0eShcbiAgICAgICAgICAgICdzZWFyY2hQYXJhbXMnLFxuICAgICAgICAgICAgcHJvcFxuICAgICAgICAgIClcbiAgICAgICAgICB3YXJuRm9yU3luY0FjY2VzcyhleHByZXNzaW9uKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKVxuICAgIH0sXG4gICAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIHdhcm5Gb3JTeW5jU3ByZWFkKClcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxuICAgIH0sXG4gIH0pXG5cbiAgQ2FjaGVkU2VhcmNoUGFyYW1zLnNldCh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCBwcm94aWVkUHJvbWlzZSlcbiAgcmV0dXJuIHByb3hpZWRQcm9taXNlXG59XG5cbi8vIFNpbWlsYXIgdG8gYG1ha2VVbnRyYWNrZWRFeG90aWNTZWFyY2hQYXJhbXNXaXRoRGV2V2FybmluZ3NgLCBidXQganVzdCBsb2dnaW5nXG4vLyB0aGUgc3luYyBhY2Nlc3Mgd2l0aG91dCBhY3R1YWxseSBkZWZpbmluZyB0aGUgc2VhcmNoIHBhcmFtcyBvbiB0aGUgcHJvbWlzZS5cbmZ1bmN0aW9uIG1ha2VVbnRyYWNrZWRTZWFyY2hQYXJhbXNXaXRoRGV2V2FybmluZ3MoXG4gIHVuZGVybHlpbmdTZWFyY2hQYXJhbXM6IFNlYXJjaFBhcmFtc1xuKTogUHJvbWlzZTxTZWFyY2hQYXJhbXM+IHtcbiAgY29uc3QgY2FjaGVkU2VhcmNoUGFyYW1zID0gQ2FjaGVkU2VhcmNoUGFyYW1zLmdldCh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKVxuICBpZiAoY2FjaGVkU2VhcmNoUGFyYW1zKSB7XG4gICAgcmV0dXJuIGNhY2hlZFNlYXJjaFBhcmFtc1xuICB9XG5cbiAgY29uc3QgcHJveGllZFByb3BlcnRpZXMgPSBuZXcgU2V0PHN0cmluZz4oKVxuICBjb25zdCB1bnByb3hpZWRQcm9wZXJ0aWVzOiBBcnJheTxzdHJpbmc+ID0gW11cbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKVxuXG4gIE9iamVjdC5rZXlzKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBpZiAod2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkpIHtcbiAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgICB1bnByb3hpZWRQcm9wZXJ0aWVzLnB1c2gocHJvcClcbiAgICB9IGVsc2Uge1xuICAgICAgcHJveGllZFByb3BlcnRpZXMuYWRkKHByb3ApXG4gICAgfVxuICB9KVxuXG4gIGNvbnN0IHByb3hpZWRQcm9taXNlID0gbmV3IFByb3h5KHByb21pc2UsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXdlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApICYmXG4gICAgICAgICAgKHByb3hpZWRQcm9wZXJ0aWVzLmhhcyhwcm9wKSB8fFxuICAgICAgICAgICAgLy8gV2UgYXJlIGFjY2Vzc2luZyBhIHByb3BlcnR5IHRoYXQgZG9lc24ndCBleGlzdCBvbiB0aGUgcHJvbWlzZSBub3JcbiAgICAgICAgICAgIC8vIHRoZSB1bmRlcmx5aW5nIHNlYXJjaFBhcmFtcy5cbiAgICAgICAgICAgIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCkgPT09IGZhbHNlKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2Vzcygnc2VhcmNoUGFyYW1zJywgcHJvcClcbiAgICAgICAgICB3YXJuRm9yU3luY0FjY2VzcyhleHByZXNzaW9uKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcHJveGllZFByb3BlcnRpZXMuZGVsZXRlKHByb3ApXG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpXG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhd2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkgJiZcbiAgICAgICAgICAocHJveGllZFByb3BlcnRpZXMuaGFzKHByb3ApIHx8XG4gICAgICAgICAgICAvLyBXZSBhcmUgYWNjZXNzaW5nIGEgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGV4aXN0IG9uIHRoZSBwcm9taXNlIG5vclxuICAgICAgICAgICAgLy8gdGhlIHVuZGVybHlpbmcgc2VhcmNoUGFyYW1zLlxuICAgICAgICAgICAgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKSA9PT0gZmFsc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHkoXG4gICAgICAgICAgICAnc2VhcmNoUGFyYW1zJyxcbiAgICAgICAgICAgIHByb3BcbiAgICAgICAgICApXG4gICAgICAgICAgd2FybkZvclN5bmNBY2Nlc3MoZXhwcmVzc2lvbilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcClcbiAgICB9LFxuICAgIG93bktleXModGFyZ2V0KSB7XG4gICAgICB3YXJuRm9yU3luY1NwcmVhZCgpXG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbiAgICB9LFxuICB9KVxuXG4gIENhY2hlZFNlYXJjaFBhcmFtcy5zZXQodW5kZXJseWluZ1NlYXJjaFBhcmFtcywgcHJveGllZFByb21pc2UpXG4gIHJldHVybiBwcm94aWVkUHJvbWlzZVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yU3luY0FjY2VzcyhleHByZXNzaW9uOiBzdHJpbmcpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICBgQSBzZWFyY2hQYXJhbSBwcm9wZXJ0eSB3YXMgYWNjZXNzZWQgZGlyZWN0bHkgd2l0aCAke2V4cHJlc3Npb259LiBgICtcbiAgICAgIGBcXGBzZWFyY2hQYXJhbXNcXGAgc2hvdWxkIGJlIHVud3JhcHBlZCB3aXRoIFxcYFJlYWN0LnVzZSgpXFxgIGJlZm9yZSBhY2Nlc3NpbmcgaXRzIHByb3BlcnRpZXMuIGAgK1xuICAgICAgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYFxuICApXG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JTeW5jU3ByZWFkKCkge1xuICBjb25zb2xlLmVycm9yKFxuICAgIGBUaGUga2V5cyBvZiBcXGBzZWFyY2hQYXJhbXNcXGAgd2VyZSBhY2Nlc3NlZCBkaXJlY3RseS4gYCArXG4gICAgICBgXFxgc2VhcmNoUGFyYW1zXFxgIHNob3VsZCBiZSB1bndyYXBwZWQgd2l0aCBcXGBSZWFjdC51c2UoKVxcYCBiZWZvcmUgYWNjZXNzaW5nIGl0cyBwcm9wZXJ0aWVzLiBgICtcbiAgICAgIGBMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9zeW5jLWR5bmFtaWMtYXBpc2BcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zRnJvbUNsaWVudChcbiAgdW5kZXJseWluZ1NlYXJjaFBhcmFtczogU2VhcmNoUGFyYW1zXG4pOiBQcm9taXNlPFNlYXJjaFBhcmFtcz4ge1xuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0RZTkFNSUNfSU8pIHtcbiAgICByZXR1cm4gbWFrZVVudHJhY2tlZFNlYXJjaFBhcmFtc1dpdGhEZXZXYXJuaW5ncyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKVxuICB9XG5cbiAgcmV0dXJuIG1ha2VVbnRyYWNrZWRFeG90aWNTZWFyY2hQYXJhbXNXaXRoRGV2V2FybmluZ3ModW5kZXJseWluZ1NlYXJjaFBhcmFtcylcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXNGcm9tQ2xpZW50IiwiQ2FjaGVkU2VhcmNoUGFyYW1zIiwiV2Vha01hcCIsIm1ha2VVbnRyYWNrZWRFeG90aWNTZWFyY2hQYXJhbXNXaXRoRGV2V2FybmluZ3MiLCJ1bmRlcmx5aW5nU2VhcmNoUGFyYW1zIiwiY2FjaGVkU2VhcmNoUGFyYW1zIiwiZ2V0IiwicHJveGllZFByb3BlcnRpZXMiLCJTZXQiLCJ1bnByb3hpZWRQcm9wZXJ0aWVzIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJwcm9wIiwid2VsbEtub3duUHJvcGVydGllcyIsImhhcyIsInB1c2giLCJhZGQiLCJwcm94aWVkUHJvbWlzZSIsIlByb3h5IiwidGFyZ2V0IiwicmVjZWl2ZXIiLCJSZWZsZWN0IiwiZXhwcmVzc2lvbiIsImRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MiLCJ3YXJuRm9yU3luY0FjY2VzcyIsIlJlZmxlY3RBZGFwdGVyIiwic2V0IiwidmFsdWUiLCJkZWxldGUiLCJkZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHkiLCJvd25LZXlzIiwid2FybkZvclN5bmNTcHJlYWQiLCJtYWtlVW50cmFja2VkU2VhcmNoUGFyYW1zV2l0aERldldhcm5pbmdzIiwiY29uc29sZSIsImVycm9yIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9EWU5BTUlDX0lPIl0sIm1hcHBpbmdzIjoiQUFtTE11QyxRQUFRQyxHQUFHLENBQUNDLGlCQUFpQixFQUFFOzs7OzsrQkFIckJ6QyxzQ0FBQUE7OztlQUFBQTs7O3lCQTlLZTs4QkFLeEI7QUFHUCxNQUFNQyxxQkFBcUIsSUFBSUM7QUFFL0IsU0FBU0MsK0NBQ1BDLHNCQUFvQztJQUVwQyxNQUFNQyxxQkFBcUJKLG1CQUFtQkssR0FBRyxD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WTtZQUNBLE9BQU9WLFFBQVFTLE9BQU8sQ0FBQ1g7UUFDekI7SUFDRjtJQUVBdEIsbUJBQW1CNkIsR0FBRyxDQUFDMUIsd0JBQXdCaUI7SUFDL0MsT0FBT0E7QUFDVDtBQUVBLFNBQVNPLGtCQUFrQkYsVUFBa0I7SUFDM0NXLFFBQVFDLEtBQUssQ0FDVix1REFBb0RaLGFBQVcsT0FDN0QsNEZBQ0E7QUFFUDtBQUVBLFNBQVNTO0lBQ1BFLFFBQVFDLEtBQUssQ0FDVix3REFDRSw0RkFDQTtBQUVQO0FBRU8sU0FBU3RDLG1DQUNkSSxzQkFBb0M7SUFFcEM7O0lBSUEsT0FBT0QsK0NBQStDQztBQUN4RCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxOTA5OSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvcmVxdWVzdC9zZWFyY2gtcGFyYW1zLmJyb3dzZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGNyZWF0ZVJlbmRlclNlYXJjaFBhcmFtc0Zyb21DbGllbnQgPVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50J1xuICAgID8gKFxuICAgICAgICByZXF1aXJlKCcuL3NlYXJjaC1wYXJhbXMuYnJvd3Nlci5kZXYnKSBhcyB0eXBlb2YgaW1wb3J0KCcuL3NlYXJjaC1wYXJhbXMuYnJvd3Nlci5kZXYnKVxuICAgICAgKS5jcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXNGcm9tQ2xpZW50XG4gICAgOiAoXG4gICAgICAgIHJlcXVpcmUoJy4vc2VhcmNoLXBhcmFtcy5icm93c2VyLnByb2QnKSBhcyB0eXBlb2YgaW1wb3J0KCcuL3NlYXJjaC1wYXJhbXMuYnJvd3Nlci5wcm9kJylcbiAgICAgICkuY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zRnJvbUNsaWVudFxuIl0sIm5hbWVzIjpbImNyZWF0ZVJlbmRlclNlYXJjaFBhcmFtc0Zyb21DbGllbnQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFDRUMsUUFBUUMsR0FBRyxDQUFDQyxRQUFRLEtBQUs7Ozs7OytCQURkSCxzQ0FBQUE7OztlQUFBQTs7O0FBQU4sTUFBTUEsNEVBR0xJLFFBQVEsMEhBQ1JKLGtDQUFrQyxHQUVsQ0ksUUFBUSxnQ0FDUkosa0NBQWtDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE5MTI0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9yZXF1ZXN0L3BhcmFtcy5icm93c2VyLmRldi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFBhcmFtcyB9IGZyb20gJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcydcblxuaW1wb3J0IHsgUmVmbGVjdEFkYXB0ZXIgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlZmxlY3QnXG5pbXBvcnQgeyBJbnZhcmlhbnRFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaW52YXJpYW50LWVycm9yJ1xuaW1wb3J0IHtcbiAgZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcyxcbiAgd2VsbEtub3duUHJvcGVydGllcyxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi91dGlscy9yZWZsZWN0LXV0aWxzJ1xuXG5pbnRlcmZhY2UgQ2FjaGVMaWZldGltZSB7fVxuY29uc3QgQ2FjaGVkUGFyYW1zID0gbmV3IFdlYWtNYXA8Q2FjaGVMaWZldGltZSwgUHJvbWlzZTxQYXJhbXM+PigpXG5cbmZ1bmN0aW9uIG1ha2VEeW5hbWljYWxseVRyYWNrZWRFeG90aWNQYXJhbXNXaXRoRGV2V2FybmluZ3MoXG4gIHVuZGVybHlpbmdQYXJhbXM6IFBhcmFtc1xuKTogUHJvbWlzZTxQYXJhbXM+IHtcbiAgY29uc3QgY2FjaGVkUGFyYW1zID0gQ2FjaGVkUGFyYW1zLmdldCh1bmRlcmx5aW5nUGFyYW1zKVxuICBpZiAoY2FjaGVkUGFyYW1zKSB7XG4gICAgcmV0dXJuIGNhY2hlZFBhcmFtc1xuICB9XG5cbiAgLy8gV2UgZG9uJ3QgdXNlIG1ha2VSZXNvbHZlZFJlYWN0UHJvbWlzZSBoZXJlIGJlY2F1c2UgcGFyYW1zXG4gIC8vIHN1cHBvcnRzIGNvcHlpbmcgd2l0aCBzcHJlYWQgYW5kIHdlIGRvbid0IHdhbnQgdG8gdW5uZWNlc3NhcmlseVxuICAvLyBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHdpdGggc3ByZWFkYWJsZSBwcm9wZXJ0aWVzIG9mIFJlYWN0UHJvbWlzZS5cbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nUGFyYW1zKVxuXG4gIGNvbnN0IHByb3hpZWRQcm9wZXJ0aWVzID0gbmV3IFNldDxzdHJpbmc+KClcbiAgY29uc3QgdW5wcm94aWVkUHJvcGVydGllczogQXJyYXk8c3RyaW5nPiA9IFtdXG5cbiAgT2JqZWN0LmtleXModW5kZXJseWluZ1BhcmFtcykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIGlmICh3ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBjYW5ub3QgYmUgc2hhZG93ZWQgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgdGhlXG4gICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICB9IGVsc2Uge1xuICAgICAgcHJveGllZFByb3BlcnRpZXMuYWRkKHByb3ApXG4gICAgICA7KHByb21pc2UgYXMgYW55KVtwcm9wXSA9IHVuZGVybHlpbmdQYXJhbXNbcHJvcF1cbiAgICB9XG4gIH0pXG5cbiAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBXZSBhcmUgYWNjZXNzaW5nIGEgcHJvcGVydHkgdGhhdCB3YXMgcHJveGllZCB0byB0aGUgcHJvbWlzZSBpbnN0YW5jZVxuICAgICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmhhcyhwcm9wKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcygncGFyYW1zJywgcHJvcClcbiAgICAgICAgICB3YXJuRm9yU3luY0FjY2VzcyhleHByZXNzaW9uKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcHJveGllZFByb3BlcnRpZXMuZGVsZXRlKHByb3ApXG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKVxuICAgIH0sXG4gICAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIHdhcm5Gb3JFbnVtZXJhdGlvbih1bnByb3hpZWRQcm9wZXJ0aWVzKVxuICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG4gICAgfSxcbiAgfSlcblxuICBDYWNoZWRQYXJhbXMuc2V0KHVuZGVybHlpbmdQYXJhbXMsIHByb3hpZWRQcm9taXNlKVxuICByZXR1cm4gcHJveGllZFByb21pc2Vcbn1cblxuLy8gU2ltaWxhciB0byBgbWFrZUR5bmFtaWNhbGx5VHJhY2tlZEV4b3RpY1BhcmFtc1dpdGhEZXZXYXJuaW5nc2AsIGJ1dCBqdXN0XG4vLyBsb2dnaW5nIHRoZSBzeW5jIGFjY2VzcyB3aXRob3V0IGFjdHVhbGx5IGRlZmluaW5nIHRoZSBwYXJhbXMgb24gdGhlIHByb21pc2UuXG5mdW5jdGlvbiBtYWtlRHluYW1pY2FsbHlUcmFja2VkUGFyYW1zV2l0aERldldhcm5pbmdzKFxuICB1bmRlcmx5aW5nUGFyYW1zOiBQYXJhbXNcbik6IFByb21pc2U8UGFyYW1zPiB7XG4gIGNvbnN0IGNhY2hlZFBhcmFtcyA9IENhY2hlZFBhcmFtcy5nZXQodW5kZXJseWluZ1BhcmFtcylcbiAgaWYgKGNhY2hlZFBhcmFtcykge1xuICAgIHJldHVybiBjYWNoZWRQYXJhbXNcbiAgfVxuXG4gIC8vIFdlIGRvbid0IHVzZSBtYWtlUmVzb2x2ZWRSZWFjdFByb21pc2UgaGVyZSBiZWNhdXNlIHBhcmFtc1xuICAvLyBzdXBwb3J0cyBjb3B5aW5nIHdpdGggc3ByZWFkIGFuZCB3ZSBkb24ndCB3YW50IHRvIHVubmVjZXNzYXJpbHlcbiAgLy8gaW5zdHJ1bWVudCB0aGUgcHJvbWlzZSB3aXRoIHNwcmVhZGFibGUgcHJvcGVydGllcyBvZiBSZWFjdFByb21pc2UuXG4gIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZXJseWluZ1BhcmFtcylcblxuICBjb25zdCBwcm94aWVkUHJvcGVydGllcyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIGNvbnN0IHVucHJveGllZFByb3BlcnRpZXM6IEFycmF5PHN0cmluZz4gPSBbXVxuXG4gIE9iamVjdC5rZXlzKHVuZGVybHlpbmdQYXJhbXMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBpZiAod2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkpIHtcbiAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmFkZChwcm9wKVxuICAgIH1cbiAgfSlcblxuICBjb25zdCBwcm94aWVkUHJvbWlzZSA9IG5ldyBQcm94eShwcm9taXNlLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIFdlIGFyZSBhY2Nlc3NpbmcgYSBwcm9wZXJ0eSB0aGF0IHdhcyBwcm94aWVkIHRvIHRoZSBwcm9taXNlIGluc3RhbmNlXG4gICAgICAgICAgcHJveGllZFByb3BlcnRpZXMuaGFzKHByb3ApXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKCdwYXJhbXMnLCBwcm9wKVxuICAgICAgICAgIHdhcm5Gb3JTeW5jQWNjZXNzKGV4cHJlc3Npb24pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBwcm94aWVkUHJvcGVydGllcy5kZWxldGUocHJvcClcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpXG4gICAgfSxcbiAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgd2FybkZvckVudW1lcmF0aW9uKHVucHJveGllZFByb3BlcnRpZXMpXG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbiAgICB9LFxuICB9KVxuXG4gIENhY2hlZFBhcmFtcy5zZXQodW5kZXJseWluZ1BhcmFtcywgcHJveGllZFByb21pc2UpXG4gIHJldHVybiBwcm94aWVkUHJvbWlzZVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yU3luY0FjY2VzcyhleHByZXNzaW9uOiBzdHJpbmcpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICBgQSBwYXJhbSBwcm9wZXJ0eSB3YXMgYWNjZXNzZWQgZGlyZWN0bHkgd2l0aCAke2V4cHJlc3Npb259LiBcXGBwYXJhbXNcXGAgaXMgbm93IGEgUHJvbWlzZSBhbmQgc2hvdWxkIGJlIHVud3JhcHBlZCB3aXRoIFxcYFJlYWN0LnVzZSgpXFxgIGJlZm9yZSBhY2Nlc3NpbmcgcHJvcGVydGllcyBvZiB0aGUgdW5kZXJseWluZyBwYXJhbXMgb2JqZWN0LiBJbiB0aGlzIHZlcnNpb24gb2YgTmV4dC5qcyBkaXJlY3QgYWNjZXNzIHRvIHBhcmFtIHByb3BlcnRpZXMgaXMgc3RpbGwgc3VwcG9ydGVkIHRvIGZhY2lsaXRhdGUgbWlncmF0aW9uIGJ1dCBpbiBhIGZ1dHVyZSB2ZXJzaW9uIHlvdSB3aWxsIGJlIHJlcXVpcmVkIHRvIHVud3JhcCBcXGBwYXJhbXNcXGAgd2l0aCBcXGBSZWFjdC51c2UoKVxcYC5gXG4gIClcbn1cblxuZnVuY3Rpb24gd2FybkZvckVudW1lcmF0aW9uKG1pc3NpbmdQcm9wZXJ0aWVzOiBBcnJheTxzdHJpbmc+KSB7XG4gIGlmIChtaXNzaW5nUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICBjb25zdCBkZXNjcmliZWRNaXNzaW5nUHJvcGVydGllcyA9XG4gICAgICBkZXNjcmliZUxpc3RPZlByb3BlcnR5TmFtZXMobWlzc2luZ1Byb3BlcnRpZXMpXG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGBwYXJhbXMgYXJlIGJlaW5nIGVudW1lcmF0ZWQgaW5jb21wbGV0ZWx5IG1pc3NpbmcgdGhlc2UgcHJvcGVydGllczogJHtkZXNjcmliZWRNaXNzaW5nUHJvcGVydGllc30uIGAgK1xuICAgICAgICBgXFxgcGFyYW1zXFxgIHNob3VsZCBiZSB1bndyYXBwZWQgd2l0aCBcXGBSZWFjdC51c2UoKVxcYCBiZWZvcmUgdXNpbmcgaXRzIHZhbHVlLiBgICtcbiAgICAgICAgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYFxuICAgIClcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgYHBhcmFtcyBhcmUgYmVpbmcgZW51bWVyYXRlZC4gYCArXG4gICAgICAgIGBcXGBwYXJhbXNcXGAgc2hvdWxkIGJlIHVud3JhcHBlZCB3aXRoIFxcYFJlYWN0LnVzZSgpXFxgIGJlZm9yZSB1c2luZyBpdHMgdmFsdWUuIGAgK1xuICAgICAgICBgTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3luYy1keW5hbWljLWFwaXNgXG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzOiBBcnJheTxzdHJpbmc+KSB7XG4gIHN3aXRjaCAocHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICB0aHJvdyBuZXcgSW52YXJpYW50RXJyb3IoXG4gICAgICAgICdFeHBlY3RlZCBkZXNjcmliZUxpc3RPZlByb3BlcnR5TmFtZXMgdG8gYmUgY2FsbGVkIHdpdGggYSBub24tZW1wdHkgbGlzdCBvZiBzdHJpbmdzLidcbiAgICAgIClcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gYFxcYCR7cHJvcGVydGllc1swXX1cXGBgXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGBcXGAke3Byb3BlcnRpZXNbMF19XFxgIGFuZCBcXGAke3Byb3BlcnRpZXNbMV19XFxgYFxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGxldCBkZXNjcmlwdGlvbiA9ICcnXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGRlc2NyaXB0aW9uICs9IGBcXGAke3Byb3BlcnRpZXNbaV19XFxgLCBgXG4gICAgICB9XG4gICAgICBkZXNjcmlwdGlvbiArPSBgLCBhbmQgXFxgJHtwcm9wZXJ0aWVzW3Byb3BlcnRpZXMubGVuZ3RoIC0gMV19XFxgYFxuICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZW5kZXJQYXJhbXNGcm9tQ2xpZW50KFxuICBjbGllbnRQYXJhbXM6IFBhcmFtc1xuKTogUHJvbWlzZTxQYXJhbXM+IHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9EWU5BTUlDX0lPKSB7XG4gICAgcmV0dXJuIG1ha2VEeW5hbWljYWxseVRyYWNrZWRQYXJhbXNXaXRoRGV2V2FybmluZ3MoY2xpZW50UGFyYW1zKVxuICB9XG5cbiAgcmV0dXJuIG1ha2VEeW5hbWljYWxseVRyYWNrZWRFeG90aWNQYXJhbXNXaXRoRGV2V2FybmluZ3MoY2xpZW50UGFyYW1zKVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQiLCJDYWNoZWRQYXJhbXMiLCJXZWFrTWFwIiwibWFrZUR5bmFtaWNhbGx5VHJhY2tlZEV4b3RpY1BhcmFtc1dpdGhEZXZXYXJuaW5ncyIsInVuZGVybHlpbmdQYXJhbXMiLCJjYWNoZWRQYXJhbXMiLCJnZXQiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwcm94aWVkUHJvcGVydGllcyIsIlNldCIsInVucHJveGllZFByb3BlcnRpZXMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInByb3AiLCJ3ZWxsS25vd25Qcm9wZXJ0aWVzIiwiaGFzIiwiYWRkIiwicHJveGllZFByb21pc2UiLCJQcm94eSIsInRhcmdldCIsInJlY2VpdmVyIiwiZXhwcmVzc2lvbiIsImRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MiLCJ3YXJuRm9yU3luY0FjY2VzcyIsIlJlZmxlY3RBZGFwdGVyIiwic2V0IiwidmFsdWUiLCJkZWxldGUiLCJvd25LZXlzIiwid2FybkZvckVudW1lcmF0aW9uIiwiUmVmbGVjdCIsIm1ha2VEeW5hbWljYWxseVRyYWNrZWRQYXJhbXNXaXRoRGV2V2FybmluZ3MiLCJjb25zb2xlIiwiZXJyb3IiLCJtaXNzaW5nUHJvcGVydGllcyIsImxlbmd0aCIsImRlc2NyaWJlZE1pc3NpbmdQcm9wZXJ0aWVzIiwiZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzIiwicHJvcGVydGllcyIsIkludmFyaWFudEVycm9yIiwiZGVzY3JpcHRpb24iLCJpIiwiY2xpZW50UGFyYW1zIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9EWU5BTUlDX0lPIl0sIm1hcHBpbmdzIjoiQUEyS004QyxRQUFRQyxHQUFHLENBQUNDLGlCQUFpQixFQUFFOzs7OzsrQkFIckJoRCxnQ0FBQUE7OztlQUFBQTs7O3lCQXRLZTtnQ0FDQTs4QkFJeEI7QUFHUCxNQUFNQyxlQUFlLElBQUlDO0FBRXpCLFNBQVNDLGtEQUNQQyxnQkFBd0I7SUFFeEIsTUFBTUMsZUFBZUosYUFBYUssR0FBRyxDQUFDRjtJQUN0QyxJQUFJQyxjQUFjO1FBQ2hCLE9BQU9BO0lBQ1Q7SUFFQSw0REFBNEQ7SUFDNUQsa0VBQWtFO0lBQ2xFLHFFQUFxRTtJQUNyRSxNQUFNRSxVQUFVQyxRQUFRQyxPQUFPLENBQUNMO0lBRWhDLE1BQU1NLG9CQUFvQixJQUFJQztJQUM5QixNQUFNQyxzQkFBcUMsRUFBRTtJQUU3Q0MsT0FBT0MsSUFBSSxDQUFDVixrQkFBa0JXLE9BQU8sQ0FBQyxDQUFDQztRQUNyQyxJQUFJQyxjQUFBQSxtQkFBbUIsQ0FBQ0MsR0FBRyxDQUFDRixPQUFPO1FBQ2pDLGtFQUFrRTtRQUNsRSxrRUFBa0U7UUFDcEUsT0FBTztZQUNMTixrQkFBa0JTLEdBQUcsQ0FBQ0g7WUFDcEJULE9BQWUsQ0FBQ1MsS0FBSyxHQUFHWixnQkFBZ0IsQ0FBQ1ksS0FBSztRQUNsRDtJQUNGO0lBRUEsTUFBTUksaUJBQWlCLElBQUlDLE1BQU1kLFNBQVM7UUFDeENELEtBQUlnQixNQUFNLEVBQUVOLElBQUksRUFBRU8sUUFBUTtZQUN4QixJQUFJLE9BQU9QLFNBQVMsVUFBVTtnQkFDNUIsSUFDRSxBQUNBTixrQkFBa0JRLEdBQUcsQ0FBQ0YsT0FDdEIsMENBRnVFO29CQUd2RSxNQUFNUSxhQUFhQyxDQUFBQSxHQUFBQSxjQUFBQSw0QkFBNEIsRUFBQyxVQUFVVDtvQkFDMURVLGtCQUFrQkY7Z0JBQ3BCO1lBQ0Y7WUFDQSxPQUFPRyxTQUFBQSxjQUFjLENBQUNyQixHQUFHLENBQUNnQixRQUFRTixNQUFNTztRQUMxQztRQUNBSyxLQUFJTixNQUFNLEVBQUVOLElBQUksRUFBRWEsS0FBSyxFQUFFTixRQUFRO1lBQy9CLElBQUksT0FBT1AsU0FBUyxVQUFVO2dCQUM1Qk4sa0JBQWtCb0IsTUFBTSxDQUFDZDtZQUMzQjtZQUNBLE9BQU9XLFNBQUFBLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDTixRQUFRTixNQUFNYSxPQUFPTjtRQUNqRDtRQUNBUSxTQUFRVCxNQUFNO1lBQ1pVLG1CQUFtQnBCO1lBQ25CLE9BQU9xQixRQUFRRixPQUFPLENBQUNUO1FBQ3pCO0lBQ0Y7SUFFQXJCLGFBQWEyQixHQUFHLENBQUN4QixrQkFBa0JnQjtJQUNuQyxPQUFPQTtBQUNUO0FBRUEsMkVBQTJFO0FBQzNFLCtFQUErRTtBQUMvRSxTQUFTYyw0Q0FDUDlCLGdCQUF3QjtJQUV4QixNQUFNQyxlQUFlSixhQUFhSyxHQUFHLENBQUNGO0lBQ3RDLElBQUlDLGNBQWM7UUFDaEIsT0FBT0E7SUFDVDtJQUVBLDREQUE0RDtJQUM1RCxrRUFBa0U7SUFDbEUscUVBQXFFO0lBQ3JFLE1BQU1FLFVBQVVDLFFBQVFDLE9BQU8sQ0FBQ0w7SUFFaEMsTUFBTU0sb0JBQW9CLElBQUlDO0lBQzlCLE1BQU1DLHNCQUFxQyxFQUFFO0lBRTdDQyxPQUFPQyxJQUFJLENBQUNWLGtCQUFrQlcsT0FBTyxDQUFDLENBQUNDO1FBQ3JDLElBQUlDLGNBQUFBLG1CQUFtQixDQUFDQyxHQUFHLENBQUNGLE9BQU87UUFDakMsa0VBQWtFO1FBQ2xFLGtFQUFrRTtRQUNwRSxPQUFPO1lBQ0xOLGtCQUFrQlMsR0FBRyxDQUFDSDtRQUN4QjtJQUNGO0lBRUEsTUFBTUksaUJBQWlCLElBQUlDLE1BQU1kLFNBQVM7UUFDeENELEtBQUlnQixNQUFNLEVBQUVOLElBQUksRUFBRU8sUUFBUTtZQUN4QixJQUFJLE9BQU9QLFNBQVMsVUFBVTtnQkFDNUIsSUFDRSxBQUNBTixrQkFBa0JRLEdBQUcsQ0FBQ0YsT0FDdEIsMENBRnVFO29CQUd2RSxNQUFNUSxhQUFhQyxDQUFBQSxHQUFBQSxjQUFBQSw0QkFBNEIsRUFBQyxVQUFVVDtvQkFDMURVLGtCQUFrQkY7Z0JBQ3BCO1lBQ0Y7WUFDQSxPQUFPRyxTQUFBQSxjQUFjLENBQUNyQixHQUFHLENBQUNnQixRQUFRTixNQUFNTztRQUMxQztRQUNBSyxLQUFJTixNQUFNLEVBQUVOLElBQUksRUFBRWEsS0FBSyxFQUFFTixRQUFRO1lBQy9CLElBQUksT0FBT1AsU0FBUyxVQUFVO2dCQUM1Qk4sa0JBQWtCb0IsTUFBTSxDQUFDZDtZQUMzQjtZQUNBLE9BQU9XLFNBQUFBLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDTixRQUFRTixNQUFNYSxPQUFPTjtRQUNqRDtRQUNBUSxTQUFRVCxNQUFNO1lBQ1pVLG1CQUFtQnBCO1lBQ25CLE9BQU9xQixRQUFRRixPQUFPLENBQUNUO1FBQ3pCO0lBQ0Y7SUFFQXJCLGFBQWEyQixHQUFHLENBQUN4QixrQkFBa0JnQjtJQUNuQyxPQUFPQTtBQUNUO0FBRUEsU0FBU00sa0JBQWtCRixVQUFrQjtJQUMzQ1csUUFBUUMsS0FBSyxDQUNWLGlEQUE4Q1osYUFBVztBQUU5RDtBQUVBLFNBQVNRLG1CQUFtQkssaUJBQWdDO0lBQzFELElBQUlBLGtCQUFrQkMsTUFBTSxFQUFFO1FBQzVCLE1BQU1DLDZCQUNKQyw0QkFBNEJIO1FBQzlCRixRQUFRQyxLQUFLLENBQ1Ysd0VBQXFFRyw2QkFBMkIsT0FDOUYsNkVBQ0E7SUFFUCxPQUFPO1FBQ0xKLFFBQVFDLEtBQUssQ0FDVixrQ0FDRSw2RUFDQTtJQUVQO0FBQ0Y7QUFFQSxTQUFTSSw0QkFBNEJDLFVBQXlCO0lBQzVELE9BQVFBLFdBQVdILE1BQU07UUFDdkIsS0FBSztZQUNILE1BQU0sT0FBQSxjQUVMLENBRkssSUFBSUksZ0JBQUFBLGNBQWMsQ0FDdEIsd0ZBREkscUJBQUE7dUJBQUE7NEJBQUE7OEJBQUE7WUFFTjtRQUNGLEtBQUs7WUFDSCxPQUFRLE1BQUlELFVBQVUsQ0FBQyxFQUFFLEdBQUM7UUFDNUIsS0FBSztZQUNILE9BQVEsTUFBSUEsVUFBVSxDQUFDLEVBQUUsR0FBQyxZQUFXQSxVQUFVLENBQUMsRUFBRSxHQUFDO1FBQ3JEO1lBQVM7Z0JBQ1AsSUFBSUUsY0FBYztnQkFDbEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILFdBQVdILE1BQU0sR0FBRyxHQUFHTSxJQUFLO29CQUM5Q0QsZUFBZ0IsTUFBSUYsVUFBVSxDQUFDRyxFQUFFLEdBQUM7Z0JBQ3BDO2dCQUNBRCxlQUFnQixZQUFVRixVQUFVLENBQUNBLFdBQVdILE1BQU0sR0FBRyxFQUFFLEdBQUM7Z0JBQzVELE9BQU9LO1lBQ1Q7SUFDRjtBQUNGO0FBRU8sU0FBUzNDLDZCQUNkNkMsWUFBb0I7SUFFcEI7O0lBSUEsT0FBTzFDLGtEQUFrRDBDO0FBQzNEIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE5MjgwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9yZXF1ZXN0L3BhcmFtcy5icm93c2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjcmVhdGVSZW5kZXJQYXJhbXNGcm9tQ2xpZW50ID1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCdcbiAgICA/IChyZXF1aXJlKCcuL3BhcmFtcy5icm93c2VyLmRldicpIGFzIHR5cGVvZiBpbXBvcnQoJy4vcGFyYW1zLmJyb3dzZXIuZGV2JykpXG4gICAgICAgIC5jcmVhdGVSZW5kZXJQYXJhbXNGcm9tQ2xpZW50XG4gICAgOiAoXG4gICAgICAgIHJlcXVpcmUoJy4vcGFyYW1zLmJyb3dzZXIucHJvZCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4vcGFyYW1zLmJyb3dzZXIucHJvZCcpXG4gICAgICApLmNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnRcbiJdLCJuYW1lcyI6WyJjcmVhdGVSZW5kZXJQYXJhbXNGcm9tQ2xpZW50IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQ0VDLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLOzs7OzsrQkFEZEgsZ0NBQUFBOzs7ZUFBQUE7OztBQUFOLE1BQU1BLHNFQUVOSSxRQUFRLG1IQUNOSiw0QkFBNEIsR0FFN0JJLFFBQVEseUJBQ1JKLDRCQUE0QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxOTMwNSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvY3JlYXRlLWRlZHVwZWQtYnktY2FsbHNpdGUtc2VydmVyLWVycm9yLWxvZ2dlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcblxuY29uc3QgZXJyb3JSZWY6IHsgY3VycmVudDogbnVsbCB8IEVycm9yIH0gPSB7IGN1cnJlbnQ6IG51bGwgfVxuXG4vLyBSZWFjdC5jYWNoZSBpcyBjdXJyZW50bHkgb25seSBhdmFpbGFibGUgaW4gY2FuYXJ5L2V4cGVyaW1lbnRhbCBSZWFjdCBjaGFubmVscy5cbmNvbnN0IGNhY2hlID1cbiAgdHlwZW9mIFJlYWN0LmNhY2hlID09PSAnZnVuY3Rpb24nXG4gICAgPyBSZWFjdC5jYWNoZVxuICAgIDogKGZuOiAoa2V5OiB1bmtub3duKSA9PiB2b2lkKSA9PiBmblxuXG4vLyBXaGVuIER5bmFtaWMgSU8gaXMgZW5hYmxlZCwgd2UgcmVjb3JkIHRoZXNlIGFzIGVycm9ycyBzbyB0aGF0IHRoZXlcbi8vIGFyZSBjYXB0dXJlZCBieSB0aGUgZGV2IG92ZXJsYXkgYXMgaXQncyBtb3JlIGNyaXRpY2FsIHRvIGZpeCB0aGVzZVxuLy8gd2hlbiBlbmFibGVkLlxuY29uc3QgbG9nRXJyb3JPcldhcm4gPSBwcm9jZXNzLmVudi5fX05FWFRfRFlOQU1JQ19JT1xuICA/IGNvbnNvbGUuZXJyb3JcbiAgOiBjb25zb2xlLndhcm5cblxuLy8gV2UgZG9uJ3Qgd2FudCB0byBkZWR1cGUgYWNyb3NzIHJlcXVlc3RzLlxuLy8gVGhlIGRldmVsb3BlciBtaWdodCd2ZSBqdXN0IGF0dGVtcHRlZCB0byBmaXggdGhlIHdhcm5pbmcgc28gd2Ugc2hvdWxkIHdhcm4gYWdhaW4gaWYgaXQgc3RpbGwgaGFwcGVucy5cbmNvbnN0IGZsdXNoQ3VycmVudEVycm9ySWZOZXcgPSBjYWNoZShcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAtLSBjYWNoZSBrZXlcbiAgKGtleTogdW5rbm93bikgPT4ge1xuICAgIHRyeSB7XG4gICAgICBsb2dFcnJvck9yV2FybihlcnJvclJlZi5jdXJyZW50KVxuICAgIH0gZmluYWxseSB7XG4gICAgICBlcnJvclJlZi5jdXJyZW50ID0gbnVsbFxuICAgIH1cbiAgfVxuKVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGxvZ3MgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IGlzIGRlZHVwZWQgYnkgdGhlIHVzZXJsYW5kXG4gKiBjYWxsc2l0ZS5cbiAqIFRoaXMgcmVxdWlyZXMgbm8gaW5kaXJlY3Rpb24gYmV0d2VlbiB0aGUgY2FsbCBvZiB0aGlzIGZ1bmN0aW9uIGFuZCB0aGUgdXNlcmxhbmRcbiAqIGNhbGxzaXRlIGkuZS4gdGhlcmUncyBvbmx5IGEgc2luZ2xlIGxpYnJhcnkgZnJhbWUgYWJvdmUgdGhpcy5cbiAqIERvIG5vdCB1c2Ugb24gdGhlIENsaWVudCB3aGVyZSBzb3VyY2VtYXBzIGFuZCBpZ25vcmUgbGlzdGluZyBtaWdodCBiZSBlbmFibGVkLlxuICogT25seSB1c2UgdGhhdCBmb3Igd2FybmluZ3MgbmVlZCBhIGZpeCBpbmRlcGVuZGVudCBvZiB0aGUgY2FsbHN0YWNrLlxuICpcbiAqIEBwYXJhbSBnZXRNZXNzYWdlXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldjxBcmdzIGV4dGVuZHMgYW55W10+KFxuICBnZXRNZXNzYWdlOiAoLi4uYXJnczogQXJncykgPT4gRXJyb3Jcbikge1xuICByZXR1cm4gZnVuY3Rpb24gbG9nRGVkdXBlZEVycm9yKC4uLmFyZ3M6IEFyZ3MpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2V0TWVzc2FnZSguLi5hcmdzKVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnN0IGNhbGxTdGFja0ZyYW1lcyA9IG5ldyBFcnJvcigpLnN0YWNrPy5zcGxpdCgnXFxuJylcbiAgICAgIGlmIChjYWxsU3RhY2tGcmFtZXMgPT09IHVuZGVmaW5lZCB8fCBjYWxsU3RhY2tGcmFtZXMubGVuZ3RoIDwgNCkge1xuICAgICAgICBsb2dFcnJvck9yV2FybihtZXNzYWdlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXJyb3I6XG4gICAgICAgIC8vICAgbG9nRGVkdXBlZEVycm9yXG4gICAgICAgIC8vICAgYXN5bmNBcGlCZWluZ0FjY2Vzc2VkU3luY2hyb25vdXNseVxuICAgICAgICAvLyAgIDx1c2VybGFuZCBjYWxsc2l0ZT5cbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3MgaWYgc291cmNlbWFwcyB3aXRoIGlnbm9yZSBsaXN0cyBhcmUgZW5hYmxlZC5cbiAgICAgICAgY29uc3Qga2V5ID0gY2FsbFN0YWNrRnJhbWVzWzRdXG4gICAgICAgIGVycm9yUmVmLmN1cnJlbnQgPSBtZXNzYWdlXG4gICAgICAgIGZsdXNoQ3VycmVudEVycm9ySWZOZXcoa2V5KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dFcnJvck9yV2FybihtZXNzYWdlKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYiLCJlcnJvclJlZiIsImN1cnJlbnQiLCJjYWNoZSIsIlJlYWN0IiwiZm4iLCJsb2dFcnJvck9yV2FybiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfRFlOQU1JQ19JTyIsImNvbnNvbGUiLCJlcnJvciIsIndhcm4iLCJmbHVzaEN1cnJlbnRFcnJvcklmTmV3Iiwia2V5IiwiZ2V0TWVzc2FnZSIsImxvZ0RlZHVwZWRFcnJvciIsImFyZ3MiLCJtZXNzYWdlIiwiTk9ERV9FTlYiLCJjYWxsU3RhY2tGcmFtZXMiLCJFcnJvciIsInN0YWNrIiwic3BsaXQiLCJ1bmRlZmluZWQiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiJBQWF1Qk8sUUFBUUMsR0FBRyxDQUFDQyxpQkFBaUI7Ozs7OytCQTRCcENULCtDQUFBQTs7O2VBQUFBOzs7K0RBekNPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFdkIsTUFBTUMsV0FBc0M7SUFBRUMsU0FBUztBQUFLO0FBRTVELGlGQUFpRjtBQUNqRixNQUFNQyxRQUNKLE9BQU9DLE9BQU1ELEtBQUssS0FBSyxhQUNuQkMsT0FBTUQsS0FBSyxHQUNYLENBQUNFLEtBQStCQTtBQUV0QyxxRUFBcUU7QUFDckUscUVBQXFFO0FBQ3JFLGdCQUFnQjtBQUNoQixNQUFNQyx1REFDRkksUUFBUUMsS0FBSyxhQUNiRCxRQUFRRSxJQUFJO0FBRWhCLDJDQUEyQztBQUMzQyx3R0FBd0c7QUFDeEcsTUFBTUMseUJBQXlCVixNQUM3QixBQUNBLENBQUNXLHlFQUR5RTtJQUV4RSxJQUFJO1FBQ0ZSLGVBQWVMLFNBQVNDLE9BQU87SUFDakMsU0FBVTtRQUNSRCxTQUFTQyxPQUFPLEdBQUc7SUFDckI7QUFDRjtBQWNLLFNBQVNGLDRDQUNkZSxVQUFvQztJQUVwQyxPQUFPLFNBQVNDOztZQUFtQkMsdUJBQUgsS0FBYTs7UUFDM0MsTUFBTUMsVUFBVUgsY0FBY0U7UUFFOUIsSUFBSVYsUUFBUUMsR0FBRyxDQUFDVyxRQUFRLEtBQUssV0FBYztnQkFDakI7WUFBeEIsTUFBTUMsa0JBQUFBLENBQWtCLFNBQUEsSUFBSUMsUUFBUUMsS0FBSyxLQUFBLE9BQUEsS0FBQSxJQUFqQixPQUFtQkMsS0FBSyxDQUFDO1lBQ2pELElBQUlILG9CQUFvQkksYUFBYUosZ0JBQWdCSyxNQUFNLEdBQUcsR0FBRztnQkFDL0RuQixlQUFlWTtZQUNqQixPQUFPO2dCQUNMLFNBQVM7Z0JBQ1Qsb0JBQW9CO2dCQUNwQix1Q0FBdUM7Z0JBQ3ZDLHdCQUF3QjtnQkFDeEIsaUVBQWlFO2dCQUNqRSxNQUFNSixNQUFNTSxlQUFlLENBQUMsRUFBRTtnQkFDOUJuQixTQUFTQyxPQUFPLEdBQUdnQjtnQkFDbkJMLHVCQUF1QkM7WUFDekI7UUFDRixPQUFPOztJQUdUO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTk0MDcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL2FwcC1yZW5kZXIvYWZ0ZXItdGFzay1hc3luYy1zdG9yYWdlLWluc3RhbmNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQWZ0ZXJUYXNrQXN5bmNTdG9yYWdlIH0gZnJvbSAnLi9hZnRlci10YXNrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQgeyBjcmVhdGVBc3luY0xvY2FsU3RvcmFnZSB9IGZyb20gJy4vYXN5bmMtbG9jYWwtc3RvcmFnZSdcblxuZXhwb3J0IGNvbnN0IGFmdGVyVGFza0FzeW5jU3RvcmFnZUluc3RhbmNlOiBBZnRlclRhc2tBc3luY1N0b3JhZ2UgPVxuICBjcmVhdGVBc3luY0xvY2FsU3RvcmFnZSgpXG4iXSwibmFtZXMiOlsiYWZ0ZXJUYXNrQXN5bmNTdG9yYWdlSW5zdGFuY2UiLCJjcmVhdGVBc3luY0xvY2FsU3RvcmFnZSJdLCJtYXBwaW5ncyI6Ijs7OytCQUdhQSxpQ0FBQUE7OztlQUFBQTs7O21DQUYyQjtBQUVqQyxNQUFNQSxnQ0FDWEMsQ0FBQUEsR0FBQUEsbUJBQUFBLHVCQUF1QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxOTQyNCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvYXBwLXJlbmRlci9hZnRlci10YXNrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBBc3luY0xvY2FsU3RvcmFnZSB9IGZyb20gJ2FzeW5jX2hvb2tzJ1xuXG4vLyBTaGFyZSB0aGUgaW5zdGFuY2UgbW9kdWxlIGluIHRoZSBuZXh0LXNoYXJlZCBsYXllclxuaW1wb3J0IHsgYWZ0ZXJUYXNrQXN5bmNTdG9yYWdlSW5zdGFuY2UgYXMgYWZ0ZXJUYXNrQXN5bmNTdG9yYWdlIH0gZnJvbSAnLi9hZnRlci10YXNrLWFzeW5jLXN0b3JhZ2UtaW5zdGFuY2UnIHdpdGggeyAndHVyYm9wYWNrLXRyYW5zaXRpb24nOiAnbmV4dC1zaGFyZWQnIH1cbmltcG9ydCB0eXBlIHsgV29ya1VuaXRTdG9yZSB9IGZyb20gJy4vd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQWZ0ZXJUYXNrU3RvcmUge1xuICAvKiogVGhlIHBoYXNlIGluIHdoaWNoIHRoZSB0b3Btb3N0IGBhZnRlcmAgd2FzIGNhbGxlZC5cbiAgICpcbiAgICogTk9URTogQ2FuIGJlIHVuZGVmaW5lZCB3aGVuIHJ1bm5pbmcgYGdlbmVyYXRlU3RhdGljUGFyYW1zYCxcbiAgICogd2hlcmUgd2Ugb25seSBoYXZlIGEgYHdvcmtTdG9yZWAsIG5vIGB3b3JrVW5pdFN0b3JlYC5cbiAgICovXG4gIHJlYWRvbmx5IHJvb3RUYXNrU3Bhd25QaGFzZTogV29ya1VuaXRTdG9yZVsncGhhc2UnXSB8IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgdHlwZSBBZnRlclRhc2tBc3luY1N0b3JhZ2UgPSBBc3luY0xvY2FsU3RvcmFnZTxBZnRlclRhc2tTdG9yZT5cblxuZXhwb3J0IHsgYWZ0ZXJUYXNrQXN5bmNTdG9yYWdlIH1cbiJdLCJuYW1lcyI6WyJhZnRlclRhc2tBc3luY1N0b3JhZ2UiXSwibWFwcGluZ3MiOiI7OzsrQkFpQlNBLHlCQUFBQTs7O2VBQUFBLCtCQUFBQSw2QkFBcUI7OzsrQ0FkeUMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTk0NDAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL3JlcXVlc3QvdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3RhdGljR2VuQmFpbG91dEVycm9yIH0gZnJvbSAnLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvc3RhdGljLWdlbmVyYXRpb24tYmFpbG91dCdcbmltcG9ydCB7IGFmdGVyVGFza0FzeW5jU3RvcmFnZSB9IGZyb20gJy4uL2FwcC1yZW5kZXIvYWZ0ZXItdGFzay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHR5cGUgeyBXb3JrU3RvcmUgfSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcblxuZXhwb3J0IGZ1bmN0aW9uIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3IoXG4gIHJvdXRlOiBzdHJpbmcsXG4gIGV4cHJlc3Npb246IHN0cmluZ1xuKTogbmV2ZXIge1xuICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKFxuICAgIGBSb3V0ZSAke3JvdXRlfSBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCAke2V4cHJlc3Npb259LiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zdGF0aWMtYW5kLWR5bmFtaWMjZHluYW1pYy1yZW5kZXJpbmdgXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKFxuICByb3V0ZTogc3RyaW5nLFxuICBleHByZXNzaW9uOiBzdHJpbmdcbik6IG5ldmVyIHtcbiAgdGhyb3cgbmV3IFN0YXRpY0dlbkJhaWxvdXRFcnJvcihcbiAgICBgUm91dGUgJHtyb3V0ZX0gd2l0aCBcXGBkeW5hbWljID0gXCJlcnJvclwiXFxgIGNvdWxkbid0IGJlIHJlbmRlcmVkIHN0YXRpY2FsbHkgYmVjYXVzZSBpdCB1c2VkICR7ZXhwcmVzc2lvbn0uIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3N0YXRpYy1hbmQtZHluYW1pYyNkeW5hbWljLXJlbmRlcmluZ2BcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dGb3JTZWFyY2hQYXJhbXNBY2Nlc3NJblVzZUNhY2hlKFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZSxcbiAgY29uc3RydWN0b3JPcHQ6IEZ1bmN0aW9uXG4pOiBuZXZlciB7XG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgIGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gdXNlZCBcInNlYXJjaFBhcmFtc1wiIGluc2lkZSBcInVzZSBjYWNoZVwiLiBBY2Nlc3NpbmcgRHluYW1pYyBkYXRhIHNvdXJjZXMgaW5zaWRlIGEgY2FjaGUgc2NvcGUgaXMgbm90IHN1cHBvcnRlZC4gSWYgeW91IG5lZWQgdGhpcyBkYXRhIGluc2lkZSBhIGNhY2hlZCBmdW5jdGlvbiB1c2UgXCJzZWFyY2hQYXJhbXNcIiBvdXRzaWRlIG9mIHRoZSBjYWNoZWQgZnVuY3Rpb24gYW5kIHBhc3MgdGhlIHJlcXVpcmVkIGR5bmFtaWMgZGF0YSBpbiBhcyBhbiBhcmd1bWVudC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LXJlcXVlc3QtaW4tdXNlLWNhY2hlYFxuICApXG5cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIGNvbnN0cnVjdG9yT3B0KVxuICB3b3JrU3RvcmUuaW52YWxpZER5bmFtaWNVc2FnZUVycm9yID8/PSBlcnJvclxuXG4gIHRocm93IGVycm9yXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlcXVlc3RBUElDYWxsYWJsZUluc2lkZUFmdGVyKCkge1xuICBjb25zdCBhZnRlclRhc2tTdG9yZSA9IGFmdGVyVGFza0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIHJldHVybiBhZnRlclRhc2tTdG9yZT8ucm9vdFRhc2tTcGF3blBoYXNlID09PSAnYWN0aW9uJ1xufVxuIl0sIm5hbWVzIjpbImlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXIiLCJ0aHJvd0ZvclNlYXJjaFBhcmFtc0FjY2Vzc0luVXNlQ2FjaGUiLCJ0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yIiwidGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IiLCJyb3V0ZSIsImV4cHJlc3Npb24iLCJTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJ3b3JrU3RvcmUiLCJjb25zdHJ1Y3Rvck9wdCIsImVycm9yIiwiRXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImludmFsaWREeW5hbWljVXNhZ2VFcnJvciIsImFmdGVyVGFza1N0b3JlIiwiYWZ0ZXJUYXNrQXN5bmNTdG9yYWdlIiwiZ2V0U3RvcmUiLCJyb290VGFza1NwYXduUGhhc2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7SUFvQ2dCQSwrQkFBK0IsRUFBQTtlQUEvQkE7O0lBZEFDLG9DQUFvQyxFQUFBO2VBQXBDQTs7SUFsQkFDLHFDQUFxQyxFQUFBO2VBQXJDQTs7SUFTQUMscURBQXFELEVBQUE7ZUFBckRBOzs7eUNBYnNCOytDQUNBO0FBRy9CLFNBQVNELHNDQUNkRSxLQUFhLEVBQ2JDLFVBQWtCO0lBRWxCLE1BQU0sT0FBQSxjQUVMLENBRkssSUFBSUMseUJBQUFBLHFCQUFxQixDQUM3QixBQUFDLE1BQU0sVUFBRUYsT0FBTSxpREFBaUQsV0FBRUMsWUFBVywwSEFBMEgsQ0FBQyxLQURwTSxxQkFBQTtlQUFBO29CQUFBO3NCQUFBO0lBRU47QUFDRjtBQUVPLFNBQVNGLHNEQUNkQyxLQUFhLEVBQ2JDLFVBQWtCO0lBRWxCLE1BQU0sT0FBQSxjQUVMLENBRkssSUFBSUMseUJBQUFBLHFCQUFxQixDQUM3QixBQUFDLE1BQU0sVUFBRUYsT0FBTSw0RUFBNEUsVUFBRUMsWUFBVywwSEFBMEgsQ0FBQyxLQUQvTixxQkFBQTtlQUFBO29CQUFBO3NCQUFBO0lBRU47QUFDRjtBQUVPLFNBQVNKLHFDQUNkTSxTQUFvQixFQUNwQkMsY0FBd0I7UUFPeEJEO0lBTEEsTUFBTUUsUUFBUSxPQUFBLGNBRWIsQ0FGYSxJQUFJQyxNQUNoQixBQUFDLE1BQU0sVUFBRUgsVUFBVUgsS0FBSyxFQUFDLG9WQUFvVixDQUFDLEtBRGxXLHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFFZDtJQUVBTSxNQUFNQyxpQkFBaUIsQ0FBQ0YsT0FBT0Q7OzhLQUNyQkksd0JBQXdCLEdBQUtIO0lBRXZDLE1BQU1BO0FBQ1I7QUFFTyxTQUFTVDtJQUNkLE1BQU1hLGlCQUFpQkMsK0JBQUFBLHFCQUFxQixDQUFDQyxRQUFRO0lBQ3JELE9BQU9GLENBQUFBLGtCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxlQUFnQkcsa0JBQWtCLE1BQUs7QUFDaEQiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTk1MDcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFdvcmtTdG9yZSB9IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuXG5pbXBvcnQgeyBSZWZsZWN0QWRhcHRlciB9IGZyb20gJy4uL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0J1xuaW1wb3J0IHtcbiAgdGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24sXG4gIHBvc3Rwb25lV2l0aFRyYWNraW5nLFxuICB0cmFja0R5bmFtaWNEYXRhSW5EeW5hbWljUmVuZGVyLFxuICBhbm5vdGF0ZUR5bmFtaWNBY2Nlc3MsXG4gIHRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2LFxufSBmcm9tICcuLi9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nJ1xuXG5pbXBvcnQge1xuICB3b3JrVW5pdEFzeW5jU3RvcmFnZSxcbiAgdHlwZSBQcmVyZW5kZXJTdG9yZSxcbiAgdHlwZSBQcmVyZW5kZXJTdG9yZUxlZ2FjeSxcbiAgdHlwZSBQcmVyZW5kZXJTdG9yZVBQUixcbiAgdHlwZSBQcmVyZW5kZXJTdG9yZU1vZGVybixcbn0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLXVuaXQtYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB7IEludmFyaWFudEVycm9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3InXG5pbXBvcnQgeyBtYWtlSGFuZ2luZ1Byb21pc2UgfSBmcm9tICcuLi9keW5hbWljLXJlbmRlcmluZy11dGlscydcbmltcG9ydCB7IGNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYgfSBmcm9tICcuLi9jcmVhdGUtZGVkdXBlZC1ieS1jYWxsc2l0ZS1zZXJ2ZXItZXJyb3ItbG9nZ2VyJ1xuaW1wb3J0IHtcbiAgZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcyxcbiAgZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5LFxuICB3ZWxsS25vd25Qcm9wZXJ0aWVzLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL3V0aWxzL3JlZmxlY3QtdXRpbHMnXG5pbXBvcnQge1xuICB0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcixcbiAgdGhyb3dGb3JTZWFyY2hQYXJhbXNBY2Nlc3NJblVzZUNhY2hlLFxufSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHsgc2NoZWR1bGVJbW1lZGlhdGUgfSBmcm9tICcuLi8uLi9saWIvc2NoZWR1bGVyJ1xuXG5leHBvcnQgdHlwZSBTZWFyY2hQYXJhbXMgPSB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkIH1cblxuLyoqXG4gKiBJbiB0aGlzIHZlcnNpb24gb2YgTmV4dC5qcyB0aGUgYHBhcmFtc2AgcHJvcCBwYXNzZWQgdG8gTGF5b3V0cywgUGFnZXMsIGFuZCBvdGhlciBTZWdtZW50cyBpcyBhIFByb21pc2UuXG4gKiBIb3dldmVyIHRvIGZhY2lsaXRhdGUgbWlncmF0aW9uIHRvIHRoaXMgbmV3IFByb21pc2UgdHlwZSB5b3UgY2FuIGN1cnJlbnRseSBzdGlsbCBhY2Nlc3MgcGFyYW1zIGRpcmVjdGx5IG9uIHRoZSBQcm9taXNlIGluc3RhbmNlIHBhc3NlZCB0byB0aGVzZSBTZWdtZW50cy5cbiAqIFRoZSBgVW5zYWZlVW53cmFwcGVkU2VhcmNoUGFyYW1zYCB0eXBlIGlzIGF2YWlsYWJsZSBpZiB5b3UgbmVlZCB0byB0ZW1wb3JhcmlseSBhY2Nlc3MgdGhlIHVuZGVybHlpbmcgcGFyYW1zIHdpdGhvdXQgZmlyc3QgYXdhaXRpbmcgb3IgYHVzZWBpbmcgdGhlIFByb21pc2UuXG4gKlxuICogSW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBOZXh0LmpzIHRoZSBgcGFyYW1zYCBwcm9wIHdpbGwgYmUgYSBwbGFpbiBQcm9taXNlIGFuZCB0aGlzIHR5cGUgd2lsbCBiZSByZW1vdmVkLlxuICpcbiAqIFR5cGljYWxseSBpbnN0YW5jZXMgb2YgYHBhcmFtc2AgY2FuIGJlIHVwZGF0ZWQgYXV0b21hdGljYWxseSB0byBiZSB0cmVhdGVkIGFzIGEgUHJvbWlzZSBieSBhIGNvZGVtb2QgcHVibGlzaGVkIGFsb25nc2lkZSB0aGlzIE5leHQuanMgdmVyc2lvbiBob3dldmVyIGlmIHlvdVxuICogaGF2ZSBub3QgeWV0IHJ1biB0aGUgY29kZW1vZCBvZiB0aGUgY29kZW1vZCBjYW5ub3QgZGV0ZWN0IGNlcnRhaW4gaW5zdGFuY2VzIG9mIGBwYXJhbXNgIHVzYWdlIHlvdSBzaG91bGQgZmlyc3QgdHJ5IHRvIHJlZmFjdG9yIHlvdXIgY29kZSB0byBhd2FpdCBgcGFyYW1zYC5cbiAqXG4gKiBJZiByZWZhY3RvcmluZyBpcyBub3QgcG9zc2libGUgYnV0IHlvdSBzdGlsbCB3YW50IHRvIGJlIGFibGUgdG8gYWNjZXNzIHBhcmFtcyBkaXJlY3RseSB3aXRob3V0IHR5cGVzY3JpcHQgZXJyb3JzIHlvdSBjYW4gY2FzdCB0aGUgcGFyYW1zIFByb21pc2UgdG8gdGhpcyB0eXBlXG4gKlxuICogYGBgdHN4XG4gKiB0eXBlIFByb3BzID0geyBzZWFyY2hQYXJhbXM6IFByb21pc2U8eyBmb286IHN0cmluZyB9PiB9XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gUGFnZShwcm9wczogUHJvcHMpIHtcbiAqICBjb25zdCB7IHNlYXJjaFBhcmFtcyB9ID0gKHByb3BzLnNlYXJjaFBhcmFtcyBhcyB1bmtub3duIGFzIFVuc2FmZVVud3JhcHBlZFNlYXJjaFBhcmFtczx0eXBlb2YgcHJvcHMuc2VhcmNoUGFyYW1zPilcbiAqICByZXR1cm4gLi4uXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGlzIHR5cGUgaXMgbWFya2VkIGRlcHJlY2F0ZWQgdG8gaGVscCBpZGVudGlmeSBpdCBhcyB0YXJnZXQgZm9yIHJlZmFjdG9yaW5nIGF3YXkuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IHR5cGUgVW5zYWZlVW53cmFwcGVkU2VhcmNoUGFyYW1zPFA+ID1cbiAgUCBleHRlbmRzIFByb21pc2U8aW5mZXIgVT4gPyBPbWl0PFUsICd0aGVuJyB8ICdzdGF0dXMnIHwgJ3ZhbHVlJz4gOiBuZXZlclxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFyYW1zRnJvbUNsaWVudChcbiAgdW5kZXJseWluZ1NlYXJjaFBhcmFtczogU2VhcmNoUGFyYW1zLFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZVxuKSB7XG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgc3dpdGNoICh3b3JrVW5pdFN0b3JlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgICBjYXNlICdwcmVyZW5kZXItY2xpZW50JzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLWxlZ2FjeSc6XG4gICAgICAgIHJldHVybiBjcmVhdGVQcmVyZW5kZXJTZWFyY2hQYXJhbXMod29ya1N0b3JlLCB3b3JrVW5pdFN0b3JlKVxuICAgICAgZGVmYXVsdDpcbiAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXModW5kZXJseWluZ1NlYXJjaFBhcmFtcywgd29ya1N0b3JlKVxufVxuXG4vLyBnZW5lcmF0ZU1ldGFkYXRhIGFsd2F5cyBydW5zIGluIFJTQyBjb250ZXh0IHNvIGl0IGlzIGVxdWl2YWxlbnQgdG8gYSBTZXJ2ZXIgUGFnZSBDb21wb25lbnRcbmV4cG9ydCBjb25zdCBjcmVhdGVTZXJ2ZXJTZWFyY2hQYXJhbXNGb3JNZXRhZGF0YSA9XG4gIGNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0ZvclNlcnZlclBhZ2VcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0ZvclNlcnZlclBhZ2UoXG4gIHVuZGVybHlpbmdTZWFyY2hQYXJhbXM6IFNlYXJjaFBhcmFtcyxcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmVcbik6IFByb21pc2U8U2VhcmNoUGFyYW1zPiB7XG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgc3dpdGNoICh3b3JrVW5pdFN0b3JlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgICBjYXNlICdwcmVyZW5kZXItY2xpZW50JzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLWxlZ2FjeSc6XG4gICAgICAgIHJldHVybiBjcmVhdGVQcmVyZW5kZXJTZWFyY2hQYXJhbXMod29ya1N0b3JlLCB3b3JrVW5pdFN0b3JlKVxuICAgICAgZGVmYXVsdDpcbiAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXModW5kZXJseWluZ1NlYXJjaFBhcmFtcywgd29ya1N0b3JlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zRm9yQ2xpZW50UGFnZShcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmVcbik6IFByb21pc2U8U2VhcmNoUGFyYW1zPiB7XG4gIGlmICh3b3JrU3RvcmUuZm9yY2VTdGF0aWMpIHtcbiAgICAvLyBXaGVuIHVzaW5nIGZvcmNlU3RhdGljIHdlIG92ZXJyaWRlIGFsbCBvdGhlciBsb2dpYyBhbmQgYWx3YXlzIGp1c3QgcmV0dXJuIGFuIGVtcHR5XG4gICAgLy8gZGljdGlvbmFyeSBvYmplY3QuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSlcbiAgfVxuXG4gIGNvbnN0IHByZXJlbmRlclN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICBpZiAoXG4gICAgcHJlcmVuZGVyU3RvcmUgJiZcbiAgICAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcicgfHxcbiAgICAgIHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItY2xpZW50JylcbiAgKSB7XG4gICAgLy8gZHluYW1pY0lPIFByZXJlbmRlclxuICAgIC8vIFdlJ3JlIHByZXJlbmRlcmluZyBpbiBhIG1vZGUgdGhhdCBhYm9ydHMgKGR5bmFtaWNJTykgYW5kIHNob3VsZCBzdGFsbFxuICAgIC8vIHRoZSBwcm9taXNlIHRvIGVuc3VyZSB0aGUgUlNDIHNpZGUgaXMgY29uc2lkZXJlZCBkeW5hbWljXG4gICAgcmV0dXJuIG1ha2VIYW5naW5nUHJvbWlzZShwcmVyZW5kZXJTdG9yZS5yZW5kZXJTaWduYWwsICdgc2VhcmNoUGFyYW1zYCcpXG4gIH1cbiAgLy8gV2UncmUgcHJlcmVuZGVyaW5nIGluIGEgbW9kZSB0aGF0IGRvZXMgbm90IGFib3J0cy4gV2UgcmVzb2x2ZSB0aGUgcHJvbWlzZSB3aXRob3V0XG4gIC8vIGFueSB0cmFja2luZyBiZWNhdXNlIHdlJ3JlIGp1c3QgdHJhbnNwb3J0aW5nIGEgdmFsdWUgZnJvbSBzZXJ2ZXIgdG8gY2xpZW50IHdoZXJlIHRoZSB0cmFja2luZ1xuICAvLyB3aWxsIGJlIGFwcGxpZWQuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByZXJlbmRlclNlYXJjaFBhcmFtcyhcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmUsXG4gIHByZXJlbmRlclN0b3JlOiBQcmVyZW5kZXJTdG9yZVxuKTogUHJvbWlzZTxTZWFyY2hQYXJhbXM+IHtcbiAgaWYgKHdvcmtTdG9yZS5mb3JjZVN0YXRpYykge1xuICAgIC8vIFdoZW4gdXNpbmcgZm9yY2VTdGF0aWMgd2Ugb3ZlcnJpZGUgYWxsIG90aGVyIGxvZ2ljIGFuZCBhbHdheXMganVzdCByZXR1cm4gYW4gZW1wdHlcbiAgICAvLyBkaWN0aW9uYXJ5IG9iamVjdC5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KVxuICB9XG5cbiAgc3dpdGNoIChwcmVyZW5kZXJTdG9yZS50eXBlKSB7XG4gICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICBjYXNlICdwcmVyZW5kZXItY2xpZW50JzpcbiAgICAgIC8vIFdlIGFyZSBpbiBhIGR5bmFtaWNJTyAoUFBSIG9yIG90aGVyd2lzZSkgcHJlcmVuZGVyXG4gICAgICByZXR1cm4gbWFrZUhhbmdpbmdTZWFyY2hQYXJhbXMocHJlcmVuZGVyU3RvcmUpXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFRoZSByZW1haW5pbmcgY2FzZXMgYXJlIHByZXJlbmRlci1wcHIgYW5kIHByZXJlbmRlci1sZWdhY3lcbiAgICAgIC8vIFdlIGFyZSBpbiBhIGxlZ2FjeSBzdGF0aWMgZ2VuZXJhdGlvbiBhbmQgbmVlZCB0byBpbnRlcnJ1cHQgdGhlIHByZXJlbmRlclxuICAgICAgLy8gd2hlbiBzZWFyY2ggcGFyYW1zIGFyZSBhY2Nlc3NlZC5cbiAgICAgIHJldHVybiBtYWtlRXJyb3JpbmdFeG90aWNTZWFyY2hQYXJhbXMod29ya1N0b3JlLCBwcmVyZW5kZXJTdG9yZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXMoXG4gIHVuZGVybHlpbmdTZWFyY2hQYXJhbXM6IFNlYXJjaFBhcmFtcyxcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmVcbik6IFByb21pc2U8U2VhcmNoUGFyYW1zPiB7XG4gIGlmICh3b3JrU3RvcmUuZm9yY2VTdGF0aWMpIHtcbiAgICAvLyBXaGVuIHVzaW5nIGZvcmNlU3RhdGljIHdlIG92ZXJyaWRlIGFsbCBvdGhlciBsb2dpYyBhbmQgYWx3YXlzIGp1c3QgcmV0dXJuIGFuIGVtcHR5XG4gICAgLy8gZGljdGlvbmFyeSBvYmplY3QuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSlcbiAgfSBlbHNlIHtcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJlxuICAgICAgIXdvcmtTdG9yZS5pc1ByZWZldGNoUmVxdWVzdFxuICAgICkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9EWU5BTUlDX0lPKSB7XG4gICAgICAgIHJldHVybiBtYWtlVW50cmFja2VkU2VhcmNoUGFyYW1zV2l0aERldldhcm5pbmdzKFxuICAgICAgICAgIHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsXG4gICAgICAgICAgd29ya1N0b3JlXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1ha2VEeW5hbWljYWxseVRyYWNrZWRFeG90aWNTZWFyY2hQYXJhbXNXaXRoRGV2V2FybmluZ3MoXG4gICAgICAgIHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsXG4gICAgICAgIHdvcmtTdG9yZVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0RZTkFNSUNfSU8pIHtcbiAgICAgICAgcmV0dXJuIG1ha2VVbnRyYWNrZWRTZWFyY2hQYXJhbXModW5kZXJseWluZ1NlYXJjaFBhcmFtcylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1ha2VVbnRyYWNrZWRFeG90aWNTZWFyY2hQYXJhbXModW5kZXJseWluZ1NlYXJjaFBhcmFtcywgd29ya1N0b3JlKVxuICAgIH1cbiAgfVxufVxuXG5pbnRlcmZhY2UgQ2FjaGVMaWZldGltZSB7fVxuY29uc3QgQ2FjaGVkU2VhcmNoUGFyYW1zID0gbmV3IFdlYWtNYXA8Q2FjaGVMaWZldGltZSwgUHJvbWlzZTxTZWFyY2hQYXJhbXM+PigpXG5cbmNvbnN0IENhY2hlZFNlYXJjaFBhcmFtc0ZvclVzZUNhY2hlID0gbmV3IFdlYWtNYXA8XG4gIENhY2hlTGlmZXRpbWUsXG4gIFByb21pc2U8U2VhcmNoUGFyYW1zPlxuPigpXG5cbmZ1bmN0aW9uIG1ha2VIYW5naW5nU2VhcmNoUGFyYW1zKFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVNb2Rlcm5cbik6IFByb21pc2U8U2VhcmNoUGFyYW1zPiB7XG4gIGNvbnN0IGNhY2hlZFNlYXJjaFBhcmFtcyA9IENhY2hlZFNlYXJjaFBhcmFtcy5nZXQocHJlcmVuZGVyU3RvcmUpXG4gIGlmIChjYWNoZWRTZWFyY2hQYXJhbXMpIHtcbiAgICByZXR1cm4gY2FjaGVkU2VhcmNoUGFyYW1zXG4gIH1cblxuICBjb25zdCBwcm9taXNlID0gbWFrZUhhbmdpbmdQcm9taXNlPFNlYXJjaFBhcmFtcz4oXG4gICAgcHJlcmVuZGVyU3RvcmUucmVuZGVyU2lnbmFsLFxuICAgICdgc2VhcmNoUGFyYW1zYCdcbiAgKVxuXG4gIGNvbnN0IHByb3hpZWRQcm9taXNlID0gbmV3IFByb3h5KHByb21pc2UsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgaWYgKE9iamVjdC5oYXNPd24ocHJvbWlzZSwgcHJvcCkpIHtcbiAgICAgICAgLy8gVGhlIHByb21pc2UgaGFzIHRoaXMgcHJvcGVydHkgZGlyZWN0bHkuIHdlIG11c3QgcmV0dXJuIGl0LlxuICAgICAgICAvLyBXZSBrbm93IGl0IGlzbid0IGEgZHluYW1pYyBhY2Nlc3MgYmVjYXVzZSBpdCBjYW4gb25seSBiZSBzb21ldGhpbmdcbiAgICAgICAgLy8gdGhhdCB3YXMgcHJldmlvdXNseSB3cml0dGVuIHRvIHRoZSBwcm9taXNlIGFuZCB0aHVzIG5vdCBhbiB1bmRlcmx5aW5nIHNlYXJjaFBhcmFtIHZhbHVlXG4gICAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgJ3RoZW4nOiB7XG4gICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9XG4gICAgICAgICAgICAnYGF3YWl0IHNlYXJjaFBhcmFtc2AsIGBzZWFyY2hQYXJhbXMudGhlbmAsIG9yIHNpbWlsYXInXG4gICAgICAgICAgYW5ub3RhdGVEeW5hbWljQWNjZXNzKGV4cHJlc3Npb24sIHByZXJlbmRlclN0b3JlKVxuICAgICAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzdGF0dXMnOiB7XG4gICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9XG4gICAgICAgICAgICAnYHVzZShzZWFyY2hQYXJhbXMpYCwgYHNlYXJjaFBhcmFtcy5zdGF0dXNgLCBvciBzaW1pbGFyJ1xuICAgICAgICAgIGFubm90YXRlRHluYW1pY0FjY2VzcyhleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZSlcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfSlcblxuICBDYWNoZWRTZWFyY2hQYXJhbXMuc2V0KHByZXJlbmRlclN0b3JlLCBwcm94aWVkUHJvbWlzZSlcbiAgcmV0dXJuIHByb3hpZWRQcm9taXNlXG59XG5cbmZ1bmN0aW9uIG1ha2VFcnJvcmluZ0V4b3RpY1NlYXJjaFBhcmFtcyhcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmUsXG4gIHByZXJlbmRlclN0b3JlOiBQcmVyZW5kZXJTdG9yZUxlZ2FjeSB8IFByZXJlbmRlclN0b3JlUFBSXG4pOiBQcm9taXNlPFNlYXJjaFBhcmFtcz4ge1xuICBjb25zdCBjYWNoZWRTZWFyY2hQYXJhbXMgPSBDYWNoZWRTZWFyY2hQYXJhbXMuZ2V0KHdvcmtTdG9yZSlcbiAgaWYgKGNhY2hlZFNlYXJjaFBhcmFtcykge1xuICAgIHJldHVybiBjYWNoZWRTZWFyY2hQYXJhbXNcbiAgfVxuXG4gIGNvbnN0IHVuZGVybHlpbmdTZWFyY2hQYXJhbXMgPSB7fVxuICAvLyBGb3Igc2VhcmNoIHBhcmFtcyB3ZSBkb24ndCBjb25zdHJ1Y3QgYSBSZWFjdFByb21pc2UgYmVjYXVzZSB3ZSB3YW50IHRvIGludGVycnVwdFxuICAvLyByZW5kZXJpbmcgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IHdhcyBub3Qgc2V0IGZyb20gb3V0c2lkZSBhbmQgc28gd2Ugb25seSB3YW50XG4gIC8vIHRvIGhhdmUgcHJvcGVydGllcyBsaWtlIHZhbHVlIGFuZCBzdGF0dXMgaWYgUmVhY3Qgc2V0cyB0aGVtLlxuICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpXG5cbiAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093bihwcm9taXNlLCBwcm9wKSkge1xuICAgICAgICAvLyBUaGUgcHJvbWlzZSBoYXMgdGhpcyBwcm9wZXJ0eSBkaXJlY3RseS4gd2UgbXVzdCByZXR1cm4gaXQuXG4gICAgICAgIC8vIFdlIGtub3cgaXQgaXNuJ3QgYSBkeW5hbWljIGFjY2VzcyBiZWNhdXNlIGl0IGNhbiBvbmx5IGJlIHNvbWV0aGluZ1xuICAgICAgICAvLyB0aGF0IHdhcyBwcmV2aW91c2x5IHdyaXR0ZW4gdG8gdGhlIHByb21pc2UgYW5kIHRodXMgbm90IGFuIHVuZGVybHlpbmcgc2VhcmNoUGFyYW0gdmFsdWVcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgY2FzZSAndGhlbic6IHtcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uID1cbiAgICAgICAgICAgICdgYXdhaXQgc2VhcmNoUGFyYW1zYCwgYHNlYXJjaFBhcmFtcy50aGVuYCwgb3Igc2ltaWxhcidcbiAgICAgICAgICBpZiAod29ya1N0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICAgICAgdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IoXG4gICAgICAgICAgICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgICAgZXhwcmVzc2lvblxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0gZWxzZSBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgICAgICAgICAgICAgd29ya1N0b3JlLnJvdXRlLFxuICAgICAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICAgICBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTGVnYWN5IFByZXJlbmRlclxuICAgICAgICAgICAgdGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24oXG4gICAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgIHdvcmtTdG9yZSxcbiAgICAgICAgICAgICAgcHJlcmVuZGVyU3RvcmVcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3RhdHVzJzoge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPVxuICAgICAgICAgICAgJ2B1c2Uoc2VhcmNoUGFyYW1zKWAsIGBzZWFyY2hQYXJhbXMuc3RhdHVzYCwgb3Igc2ltaWxhcidcbiAgICAgICAgICBpZiAod29ya1N0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICAgICAgdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IoXG4gICAgICAgICAgICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgICAgZXhwcmVzc2lvblxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0gZWxzZSBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgICAgICAgICAgICAgd29ya1N0b3JlLnJvdXRlLFxuICAgICAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICAgICBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTGVnYWN5IFByZXJlbmRlclxuICAgICAgICAgICAgdGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24oXG4gICAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgIHdvcmtTdG9yZSxcbiAgICAgICAgICAgICAgcHJlcmVuZGVyU3RvcmVcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycgJiYgIXdlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcyhcbiAgICAgICAgICAgICAgJ3NlYXJjaFBhcmFtcycsXG4gICAgICAgICAgICAgIHByb3BcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGlmICh3b3JrU3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICAgICAgICAgIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKFxuICAgICAgICAgICAgICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICAgICAgICAgIC8vIFBQUiBQcmVyZW5kZXIgKG5vIGR5bmFtaWNJTylcbiAgICAgICAgICAgICAgcG9zdHBvbmVXaXRoVHJhY2tpbmcoXG4gICAgICAgICAgICAgICAgd29ya1N0b3JlLnJvdXRlLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIExlZ2FjeSBQcmVyZW5kZXJcbiAgICAgICAgICAgICAgdGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24oXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICB3b3JrU3RvcmUsXG4gICAgICAgICAgICAgICAgcHJlcmVuZGVyU3RvcmVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIC8vIFdlIGRvbid0IGV4cGVjdCBrZXkgY2hlY2tpbmcgdG8gYmUgdXNlZCBleGNlcHQgZm9yIHRlc3RpbmcgdGhlIGV4aXN0ZW5jZSBvZlxuICAgICAgLy8gc2VhcmNoUGFyYW1zIHNvIHdlIG1ha2UgYWxsIGhhcyB0ZXN0cyB0cmlnZ2VyIGR5bmFtaWMuIHRoaXMgbWVhbnMgdGhhdCBgcHJvbWlzZS50aGVuYFxuICAgICAgLy8gY2FuIHJlc29sdmUgdG8gdGhlIHRoZW4gZnVuY3Rpb24gb24gdGhlIFByb21pc2UgcHJvdG90eXBlIGJ1dCAndGhlbicgaW4gcHJvbWlzZSB3aWxsIGFzc3VtZVxuICAgICAgLy8geW91IGFyZSB0ZXN0aW5nIHdoZXRoZXIgdGhlIHNlYXJjaFBhcmFtcyBoYXMgYSAndGhlbicgcHJvcGVydHkuXG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHkoXG4gICAgICAgICAgJ3NlYXJjaFBhcmFtcycsXG4gICAgICAgICAgcHJvcFxuICAgICAgICApXG4gICAgICAgIGlmICh3b3JrU3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICAgICAgdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IoXG4gICAgICAgICAgICB3b3JrU3RvcmUucm91dGUsXG4gICAgICAgICAgICBleHByZXNzaW9uXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJykge1xuICAgICAgICAgIC8vIFBQUiBQcmVyZW5kZXIgKG5vIGR5bmFtaWNJTylcbiAgICAgICAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgICAgICAgICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTGVnYWN5IFByZXJlbmRlclxuICAgICAgICAgIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKFxuICAgICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHdvcmtTdG9yZSxcbiAgICAgICAgICAgIHByZXJlbmRlclN0b3JlXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmhhcyh0YXJnZXQsIHByb3ApXG4gICAgfSxcbiAgICBvd25LZXlzKCkge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9XG4gICAgICAgICdgey4uLnNlYXJjaFBhcmFtc31gLCBgT2JqZWN0LmtleXMoc2VhcmNoUGFyYW1zKWAsIG9yIHNpbWlsYXInXG4gICAgICBpZiAod29ya1N0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICB0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcihcbiAgICAgICAgICB3b3JrU3RvcmUucm91dGUsXG4gICAgICAgICAgZXhwcmVzc2lvblxuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJykge1xuICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgIHBvc3Rwb25lV2l0aFRyYWNraW5nKFxuICAgICAgICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgIHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMZWdhY3kgUHJlcmVuZGVyXG4gICAgICAgIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKGV4cHJlc3Npb24sIHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpXG4gICAgICB9XG4gICAgfSxcbiAgfSlcblxuICBDYWNoZWRTZWFyY2hQYXJhbXMuc2V0KHdvcmtTdG9yZSwgcHJveGllZFByb21pc2UpXG4gIHJldHVybiBwcm94aWVkUHJvbWlzZVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSB2YXJpYXRpb24gb2YgYG1ha2VFcnJvcmluZ0V4b3RpY1NlYXJjaFBhcmFtc2AgdGhhdCBhbHdheXMgdGhyb3dzIGFuXG4gKiBlcnJvciBvbiBhY2Nlc3MsIGJlY2F1c2UgYWNjZXNzaW5nIHNlYXJjaFBhcmFtcyBpbnNpZGUgb2YgYFwidXNlIGNhY2hlXCJgIGlzXG4gKiBub3QgYWxsb3dlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFcnJvcmluZ0V4b3RpY1NlYXJjaFBhcmFtc0ZvclVzZUNhY2hlKFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZVxuKTogUHJvbWlzZTxTZWFyY2hQYXJhbXM+IHtcbiAgY29uc3QgY2FjaGVkU2VhcmNoUGFyYW1zID0gQ2FjaGVkU2VhcmNoUGFyYW1zRm9yVXNlQ2FjaGUuZ2V0KHdvcmtTdG9yZSlcbiAgaWYgKGNhY2hlZFNlYXJjaFBhcmFtcykge1xuICAgIHJldHVybiBjYWNoZWRTZWFyY2hQYXJhbXNcbiAgfVxuXG4gIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoe30pXG5cbiAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duKHByb21pc2UsIHByb3ApKSB7XG4gICAgICAgIC8vIFRoZSBwcm9taXNlIGhhcyB0aGlzIHByb3BlcnR5IGRpcmVjdGx5LiB3ZSBtdXN0IHJldHVybiBpdC4gV2Uga25vdyBpdFxuICAgICAgICAvLyBpc24ndCBhIGR5bmFtaWMgYWNjZXNzIGJlY2F1c2UgaXQgY2FuIG9ubHkgYmUgc29tZXRoaW5nIHRoYXQgd2FzXG4gICAgICAgIC8vIHByZXZpb3VzbHkgd3JpdHRlbiB0byB0aGUgcHJvbWlzZSBhbmQgdGh1cyBub3QgYW4gdW5kZXJseWluZ1xuICAgICAgICAvLyBzZWFyY2hQYXJhbSB2YWx1ZVxuICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIChwcm9wID09PSAndGhlbicgfHwgIXdlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93Rm9yU2VhcmNoUGFyYW1zQWNjZXNzSW5Vc2VDYWNoZSh3b3JrU3RvcmUsIGdldClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgIH0sXG4gICAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICAvLyBXZSBkb24ndCBleHBlY3Qga2V5IGNoZWNraW5nIHRvIGJlIHVzZWQgZXhjZXB0IGZvciB0ZXN0aW5nIHRoZSBleGlzdGVuY2Ugb2ZcbiAgICAgIC8vIHNlYXJjaFBhcmFtcyBzbyB3ZSBtYWtlIGFsbCBoYXMgdGVzdHMgdGhyb3cgYW4gZXJyb3IuIHRoaXMgbWVhbnMgdGhhdCBgcHJvbWlzZS50aGVuYFxuICAgICAgLy8gY2FuIHJlc29sdmUgdG8gdGhlIHRoZW4gZnVuY3Rpb24gb24gdGhlIFByb21pc2UgcHJvdG90eXBlIGJ1dCAndGhlbicgaW4gcHJvbWlzZSB3aWxsIGFzc3VtZVxuICAgICAgLy8geW91IGFyZSB0ZXN0aW5nIHdoZXRoZXIgdGhlIHNlYXJjaFBhcmFtcyBoYXMgYSAndGhlbicgcHJvcGVydHkuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAocHJvcCA9PT0gJ3RoZW4nIHx8ICF3ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSlcbiAgICAgICkge1xuICAgICAgICB0aHJvd0ZvclNlYXJjaFBhcmFtc0FjY2Vzc0luVXNlQ2FjaGUod29ya1N0b3JlLCBoYXMpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5oYXModGFyZ2V0LCBwcm9wKVxuICAgIH0sXG4gICAgb3duS2V5czogZnVuY3Rpb24gb3duS2V5cygpIHtcbiAgICAgIHRocm93Rm9yU2VhcmNoUGFyYW1zQWNjZXNzSW5Vc2VDYWNoZSh3b3JrU3RvcmUsIG93bktleXMpXG4gICAgfSxcbiAgfSlcblxuICBDYWNoZWRTZWFyY2hQYXJhbXNGb3JVc2VDYWNoZS5zZXQod29ya1N0b3JlLCBwcm94aWVkUHJvbWlzZSlcbiAgcmV0dXJuIHByb3hpZWRQcm9taXNlXG59XG5cbmZ1bmN0aW9uIG1ha2VVbnRyYWNrZWRFeG90aWNTZWFyY2hQYXJhbXMoXG4gIHVuZGVybHlpbmdTZWFyY2hQYXJhbXM6IFNlYXJjaFBhcmFtcyxcbiAgc3RvcmU6IFdvcmtTdG9yZVxuKTogUHJvbWlzZTxTZWFyY2hQYXJhbXM+IHtcbiAgY29uc3QgY2FjaGVkU2VhcmNoUGFyYW1zID0gQ2FjaGVkU2VhcmNoUGFyYW1zLmdldCh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKVxuICBpZiAoY2FjaGVkU2VhcmNoUGFyYW1zKSB7XG4gICAgcmV0dXJuIGNhY2hlZFNlYXJjaFBhcmFtc1xuICB9XG5cbiAgLy8gV2UgZG9uJ3QgdXNlIG1ha2VSZXNvbHZlZFJlYWN0UHJvbWlzZSBoZXJlIGJlY2F1c2Ugc2VhcmNoUGFyYW1zXG4gIC8vIHN1cHBvcnRzIGNvcHlpbmcgd2l0aCBzcHJlYWQgYW5kIHdlIGRvbid0IHdhbnQgdG8gdW5uZWNlc3NhcmlseVxuICAvLyBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHdpdGggc3ByZWFkYWJsZSBwcm9wZXJ0aWVzIG9mIFJlYWN0UHJvbWlzZS5cbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKVxuICBDYWNoZWRTZWFyY2hQYXJhbXMuc2V0KHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHByb21pc2UpXG5cbiAgT2JqZWN0LmtleXModW5kZXJseWluZ1NlYXJjaFBhcmFtcykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIGlmICghd2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBwcm9wLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBjb25zdCB3b3JrVW5pdFN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICAgICAgICAgIHRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIoc3RvcmUsIHdvcmtVbml0U3RvcmUpXG4gICAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdTZWFyY2hQYXJhbXNbcHJvcF1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIG1ha2VVbnRyYWNrZWRTZWFyY2hQYXJhbXMoXG4gIHVuZGVybHlpbmdTZWFyY2hQYXJhbXM6IFNlYXJjaFBhcmFtc1xuKTogUHJvbWlzZTxTZWFyY2hQYXJhbXM+IHtcbiAgY29uc3QgY2FjaGVkU2VhcmNoUGFyYW1zID0gQ2FjaGVkU2VhcmNoUGFyYW1zLmdldCh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKVxuICBpZiAoY2FjaGVkU2VhcmNoUGFyYW1zKSB7XG4gICAgcmV0dXJuIGNhY2hlZFNlYXJjaFBhcmFtc1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKVxuICBDYWNoZWRTZWFyY2hQYXJhbXMuc2V0KHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHByb21pc2UpXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gbWFrZUR5bmFtaWNhbGx5VHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtc1dpdGhEZXZXYXJuaW5ncyhcbiAgdW5kZXJseWluZ1NlYXJjaFBhcmFtczogU2VhcmNoUGFyYW1zLFxuICBzdG9yZTogV29ya1N0b3JlXG4pOiBQcm9taXNlPFNlYXJjaFBhcmFtcz4ge1xuICBjb25zdCBjYWNoZWRTZWFyY2hQYXJhbXMgPSBDYWNoZWRTZWFyY2hQYXJhbXMuZ2V0KHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpXG4gIGlmIChjYWNoZWRTZWFyY2hQYXJhbXMpIHtcbiAgICByZXR1cm4gY2FjaGVkU2VhcmNoUGFyYW1zXG4gIH1cblxuICBjb25zdCBwcm94aWVkUHJvcGVydGllcyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIGNvbnN0IHVucHJveGllZFByb3BlcnRpZXM6IEFycmF5PHN0cmluZz4gPSBbXVxuXG4gIC8vIFdlIGhhdmUgYW4gdW5mb3J0dW5hdGUgc2VxdWVuY2Ugb2YgZXZlbnRzIHRoYXQgcmVxdWlyZXMgdGhpcyBpbml0aWFsaXphdGlvbiBsb2dpYy4gV2Ugd2FudCB0byBpbnN0cnVtZW50IHRoZSB1bmRlcmx5aW5nXG4gIC8vIHNlYXJjaFBhcmFtcyBvYmplY3QgdG8gZGV0ZWN0IGlmIHlvdSBhcmUgYWNjZXNzaW5nIHZhbHVlcyBpbiBkZXYuIFRoaXMgaXMgdXNlZCBmb3Igd2FybmluZ3MgYW5kIGZvciB0aGluZ3MgbGlrZSB0aGUgc3RhdGljIHByZXJlbmRlclxuICAvLyBpbmRpY2F0b3IuIEhvd2V2ZXIgd2hlbiB3ZSBwYXNzIHRoaXMgcHJveHkgdG8gb3VyIFByb21pc2UucmVzb2x2ZSgpIGJlbG93IHRoZSBWTSBjaGVja3MgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGEgcHJvbWlzZSBieSBsb29raW5nXG4gIC8vIGF0IHRoZSBgLnRoZW5gIHByb3BlcnR5LiBUbyBvdXIgZHluYW1pYyB0cmFja2luZyBsb2dpYyB0aGlzIGlzIGluZGlzdGluZ3Vpc2hhYmxlIGZyb20gYSBgdGhlbmAgc2VhcmNoUGFyYW0gYW5kIHNvIHdlIHdvdWxkIG5vcm1hbGx5IHRyaWdnZXJcbiAgLy8gZHluYW1pYyB0cmFja2luZy4gSG93ZXZlciB3ZSBrbm93IHRoYXQgdGhpcyAudGhlbiBpcyBub3QgcmVhbCBkeW5hbWljIGFjY2VzcywgaXQncyBqdXN0IGhvdyB0aGVuYWJsZXMgcmVzb2x2ZSBpbiBzZXF1ZW5jZS4gU28gd2UgaW50cm9kdWNlXG4gIC8vIHRoaXMgaW5pdGlhbGl6YXRpb24gY29uY2VwdCBzbyB3ZSBvbWl0IHRoZSBkeW5hbWljIGNoZWNrIHVudGlsIGFmdGVyIHdlJ3ZlIGNvbnN0cnVjdGVkIG91ciByZXNvbHZlZCBwcm9taXNlLlxuICBsZXQgcHJvbWlzZUluaXRpYWxpemVkID0gZmFsc2VcbiAgY29uc3QgcHJveGllZFVuZGVybHlpbmcgPSBuZXcgUHJveHkodW5kZXJseWluZ1NlYXJjaFBhcmFtcywge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnICYmIHByb21pc2VJbml0aWFsaXplZCkge1xuICAgICAgICBpZiAoc3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MoJ3NlYXJjaFBhcmFtcycsIHByb3ApXG4gICAgICAgICAgdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IoXG4gICAgICAgICAgICBzdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgIGV4cHJlc3Npb25cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgICAgICAgdHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlcihzdG9yZSwgd29ya1VuaXRTdG9yZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcilcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHN0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHkoXG4gICAgICAgICAgICAnc2VhcmNoUGFyYW1zJyxcbiAgICAgICAgICAgIHByb3BcbiAgICAgICAgICApXG4gICAgICAgICAgdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IoXG4gICAgICAgICAgICBzdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgIGV4cHJlc3Npb25cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApXG4gICAgfSxcbiAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgaWYgKHN0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID1cbiAgICAgICAgICAnYHsuLi5zZWFyY2hQYXJhbXN9YCwgYE9iamVjdC5rZXlzKHNlYXJjaFBhcmFtcylgLCBvciBzaW1pbGFyJ1xuICAgICAgICB0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcihcbiAgICAgICAgICBzdG9yZS5yb3V0ZSxcbiAgICAgICAgICBleHByZXNzaW9uXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxuICAgIH0sXG4gIH0pXG5cbiAgLy8gV2UgZG9uJ3QgdXNlIG1ha2VSZXNvbHZlZFJlYWN0UHJvbWlzZSBoZXJlIGJlY2F1c2Ugc2VhcmNoUGFyYW1zXG4gIC8vIHN1cHBvcnRzIGNvcHlpbmcgd2l0aCBzcHJlYWQgYW5kIHdlIGRvbid0IHdhbnQgdG8gdW5uZWNlc3NhcmlseVxuICAvLyBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHdpdGggc3ByZWFkYWJsZSBwcm9wZXJ0aWVzIG9mIFJlYWN0UHJvbWlzZS5cbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFNlYXJjaFBhcmFtcz4oKHJlc29sdmUpID0+XG4gICAgc2NoZWR1bGVJbW1lZGlhdGUoKCkgPT4gcmVzb2x2ZSh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKSlcbiAgKVxuICBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgIHByb21pc2VJbml0aWFsaXplZCA9IHRydWVcbiAgfSlcblxuICBPYmplY3Qua2V5cyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgaWYgKHdlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBzaGFkb3dlZCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSB0aGVcbiAgICAgIC8vIHRydWUgdW5kZXJseWluZyB2YWx1ZSBmb3IgUHJvbWlzZXMgdG8gd29yayBjb3JyZWN0bHkgYXQgcnVudGltZVxuICAgICAgdW5wcm94aWVkUHJvcGVydGllcy5wdXNoKHByb3ApXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmFkZChwcm9wKVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBwcm94aWVkVW5kZXJseWluZ1twcm9wXVxuICAgICAgICB9LFxuICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgcHJvcCwge1xuICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIGNvbnN0IHByb3hpZWRQcm9taXNlID0gbmV3IFByb3h5KHByb21pc2UsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgaWYgKHByb3AgPT09ICd0aGVuJyAmJiBzdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgc2VhcmNoUGFyYW1zLnRoZW5gJ1xuICAgICAgICB0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcihcbiAgICAgICAgICBzdG9yZS5yb3V0ZSxcbiAgICAgICAgICBleHByZXNzaW9uXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICF3ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSAmJlxuICAgICAgICAgIChwcm94aWVkUHJvcGVydGllcy5oYXMocHJvcCkgfHxcbiAgICAgICAgICAgIC8vIFdlIGFyZSBhY2Nlc3NpbmcgYSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHByb21pc2Ugbm9yXG4gICAgICAgICAgICAvLyB0aGUgdW5kZXJseWluZyBzZWFyY2hQYXJhbXMuXG4gICAgICAgICAgICBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApID09PSBmYWxzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MoJ3NlYXJjaFBhcmFtcycsIHByb3ApXG4gICAgICAgICAgc3luY0lPRGV2KHN0b3JlLnJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcHJveGllZFByb3BlcnRpZXMuZGVsZXRlKHByb3ApXG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpXG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhd2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkgJiZcbiAgICAgICAgICAocHJveGllZFByb3BlcnRpZXMuaGFzKHByb3ApIHx8XG4gICAgICAgICAgICAvLyBXZSBhcmUgYWNjZXNzaW5nIGEgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGV4aXN0IG9uIHRoZSBwcm9taXNlIG5vclxuICAgICAgICAgICAgLy8gdGhlIHVuZGVybHlpbmcgc2VhcmNoUGFyYW1zLlxuICAgICAgICAgICAgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKSA9PT0gZmFsc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHkoXG4gICAgICAgICAgICAnc2VhcmNoUGFyYW1zJyxcbiAgICAgICAgICAgIHByb3BcbiAgICAgICAgICApXG4gICAgICAgICAgc3luY0lPRGV2KHN0b3JlLnJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKVxuICAgIH0sXG4gICAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYE9iamVjdC5rZXlzKHNlYXJjaFBhcmFtcylgIG9yIHNpbWlsYXInXG4gICAgICBzeW5jSU9EZXYoc3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHVucHJveGllZFByb3BlcnRpZXMpXG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbiAgICB9LFxuICB9KVxuXG4gIENhY2hlZFNlYXJjaFBhcmFtcy5zZXQodW5kZXJseWluZ1NlYXJjaFBhcmFtcywgcHJveGllZFByb21pc2UpXG4gIHJldHVybiBwcm94aWVkUHJvbWlzZVxufVxuXG4vLyBTaW1pbGFyIHRvIGBtYWtlRHluYW1pY2FsbHlUcmFja2VkRXhvdGljU2VhcmNoUGFyYW1zV2l0aERldldhcm5pbmdzYCwgYnV0XG4vLyBqdXN0IGxvZ2dpbmcgdGhlIHN5bmMgYWNjZXNzIHdpdGhvdXQgYWN0dWFsbHkgZGVmaW5pbmcgdGhlIHNlYXJjaCBwYXJhbXMgb25cbi8vIHRoZSBwcm9taXNlLlxuZnVuY3Rpb24gbWFrZVVudHJhY2tlZFNlYXJjaFBhcmFtc1dpdGhEZXZXYXJuaW5ncyhcbiAgdW5kZXJseWluZ1NlYXJjaFBhcmFtczogU2VhcmNoUGFyYW1zLFxuICBzdG9yZTogV29ya1N0b3JlXG4pOiBQcm9taXNlPFNlYXJjaFBhcmFtcz4ge1xuICBjb25zdCBjYWNoZWRTZWFyY2hQYXJhbXMgPSBDYWNoZWRTZWFyY2hQYXJhbXMuZ2V0KHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpXG4gIGlmIChjYWNoZWRTZWFyY2hQYXJhbXMpIHtcbiAgICByZXR1cm4gY2FjaGVkU2VhcmNoUGFyYW1zXG4gIH1cblxuICBjb25zdCBwcm94aWVkUHJvcGVydGllcyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIGNvbnN0IHVucHJveGllZFByb3BlcnRpZXM6IEFycmF5PHN0cmluZz4gPSBbXVxuICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpXG5cbiAgT2JqZWN0LmtleXModW5kZXJseWluZ1NlYXJjaFBhcmFtcykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIGlmICh3ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBjYW5ub3QgYmUgc2hhZG93ZWQgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgdGhlXG4gICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgIHVucHJveGllZFByb3BlcnRpZXMucHVzaChwcm9wKVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm94aWVkUHJvcGVydGllcy5hZGQocHJvcClcbiAgICB9XG4gIH0pXG5cbiAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhd2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkgJiZcbiAgICAgICAgICAocHJveGllZFByb3BlcnRpZXMuaGFzKHByb3ApIHx8XG4gICAgICAgICAgICAvLyBXZSBhcmUgYWNjZXNzaW5nIGEgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGV4aXN0IG9uIHRoZSBwcm9taXNlIG5vclxuICAgICAgICAgICAgLy8gdGhlIHVuZGVybHlpbmcgc2VhcmNoUGFyYW1zLlxuICAgICAgICAgICAgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKSA9PT0gZmFsc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKCdzZWFyY2hQYXJhbXMnLCBwcm9wKVxuICAgICAgICAgIHdhcm5Gb3JTeW5jQWNjZXNzKHN0b3JlLnJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcHJveGllZFByb3BlcnRpZXMuZGVsZXRlKHByb3ApXG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpXG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhd2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkgJiZcbiAgICAgICAgICAocHJveGllZFByb3BlcnRpZXMuaGFzKHByb3ApIHx8XG4gICAgICAgICAgICAvLyBXZSBhcmUgYWNjZXNzaW5nIGEgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGV4aXN0IG9uIHRoZSBwcm9taXNlIG5vclxuICAgICAgICAgICAgLy8gdGhlIHVuZGVybHlpbmcgc2VhcmNoUGFyYW1zLlxuICAgICAgICAgICAgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKSA9PT0gZmFsc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHkoXG4gICAgICAgICAgICAnc2VhcmNoUGFyYW1zJyxcbiAgICAgICAgICAgIHByb3BcbiAgICAgICAgICApXG4gICAgICAgICAgd2FybkZvclN5bmNBY2Nlc3Moc3RvcmUucm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApXG4gICAgfSxcbiAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgT2JqZWN0LmtleXMoc2VhcmNoUGFyYW1zKWAgb3Igc2ltaWxhcidcbiAgICAgIHdhcm5Gb3JJbmNvbXBsZXRlRW51bWVyYXRpb24oc3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHVucHJveGllZFByb3BlcnRpZXMpXG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbiAgICB9LFxuICB9KVxuXG4gIENhY2hlZFNlYXJjaFBhcmFtcy5zZXQodW5kZXJseWluZ1NlYXJjaFBhcmFtcywgcHJveGllZFByb21pc2UpXG4gIHJldHVybiBwcm94aWVkUHJvbWlzZVxufVxuXG5mdW5jdGlvbiBzeW5jSU9EZXYoXG4gIHJvdXRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGV4cHJlc3Npb246IHN0cmluZyxcbiAgbWlzc2luZ1Byb3BlcnRpZXM/OiBBcnJheTxzdHJpbmc+XG4pIHtcbiAgLy8gSW4gYWxsIGNhc2VzIHdlIHdhcm4gbm9ybWFsbHlcbiAgaWYgKG1pc3NpbmdQcm9wZXJ0aWVzICYmIG1pc3NpbmdQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICB3YXJuRm9ySW5jb21wbGV0ZUVudW1lcmF0aW9uKHJvdXRlLCBleHByZXNzaW9uLCBtaXNzaW5nUHJvcGVydGllcylcbiAgfSBlbHNlIHtcbiAgICB3YXJuRm9yU3luY0FjY2Vzcyhyb3V0ZSwgZXhwcmVzc2lvbilcbiAgfVxuXG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGlmIChcbiAgICB3b3JrVW5pdFN0b3JlICYmXG4gICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAncmVxdWVzdCcgJiZcbiAgICB3b3JrVW5pdFN0b3JlLnByZXJlbmRlclBoYXNlID09PSB0cnVlXG4gICkge1xuICAgIC8vIFdoZW4gd2UncmUgcmVuZGVyaW5nIGR5bmFtaWNhbGx5IGluIGRldiB3ZSBuZWVkIHRvIGFkdmFuY2Ugb3V0IG9mIHRoZVxuICAgIC8vIFByZXJlbmRlciBlbnZpcm9ubWVudCB3aGVuIHdlIHJlYWQgUmVxdWVzdCBkYXRhIHN5bmNocm9ub3VzbHlcbiAgICBjb25zdCByZXF1ZXN0U3RvcmUgPSB3b3JrVW5pdFN0b3JlXG4gICAgdHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYocmVxdWVzdFN0b3JlKVxuICB9XG59XG5cbmNvbnN0IHdhcm5Gb3JTeW5jQWNjZXNzID0gY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldihcbiAgY3JlYXRlU2VhcmNoQWNjZXNzRXJyb3JcbilcblxuY29uc3Qgd2FybkZvckluY29tcGxldGVFbnVtZXJhdGlvbiA9XG4gIGNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYoY3JlYXRlSW5jb21wbGV0ZUVudW1lcmF0aW9uRXJyb3IpXG5cbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaEFjY2Vzc0Vycm9yKFxuICByb3V0ZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBleHByZXNzaW9uOiBzdHJpbmdcbikge1xuICBjb25zdCBwcmVmaXggPSByb3V0ZSA/IGBSb3V0ZSBcIiR7cm91dGV9XCIgYCA6ICdUaGlzIHJvdXRlICdcbiAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICBgJHtwcmVmaXh9dXNlZCAke2V4cHJlc3Npb259LiBgICtcbiAgICAgIGBcXGBzZWFyY2hQYXJhbXNcXGAgc2hvdWxkIGJlIGF3YWl0ZWQgYmVmb3JlIHVzaW5nIGl0cyBwcm9wZXJ0aWVzLiBgICtcbiAgICAgIGBMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9zeW5jLWR5bmFtaWMtYXBpc2BcbiAgKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVJbmNvbXBsZXRlRW51bWVyYXRpb25FcnJvcihcbiAgcm91dGU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgZXhwcmVzc2lvbjogc3RyaW5nLFxuICBtaXNzaW5nUHJvcGVydGllczogQXJyYXk8c3RyaW5nPlxuKSB7XG4gIGNvbnN0IHByZWZpeCA9IHJvdXRlID8gYFJvdXRlIFwiJHtyb3V0ZX1cIiBgIDogJ1RoaXMgcm91dGUgJ1xuICByZXR1cm4gbmV3IEVycm9yKFxuICAgIGAke3ByZWZpeH11c2VkICR7ZXhwcmVzc2lvbn0uIGAgK1xuICAgICAgYFxcYHNlYXJjaFBhcmFtc1xcYCBzaG91bGQgYmUgYXdhaXRlZCBiZWZvcmUgdXNpbmcgaXRzIHByb3BlcnRpZXMuIGAgK1xuICAgICAgYFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyB3ZXJlIG5vdCBhdmFpbGFibGUgdGhyb3VnaCBlbnVtZXJhdGlvbiBgICtcbiAgICAgIGBiZWNhdXNlIHRoZXkgY29uZmxpY3Qgd2l0aCBidWlsdGluIG9yIHdlbGwta25vd24gcHJvcGVydHkgbmFtZXM6IGAgK1xuICAgICAgYCR7ZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzKG1pc3NpbmdQcm9wZXJ0aWVzKX0uIGAgK1xuICAgICAgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYFxuICApXG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzOiBBcnJheTxzdHJpbmc+KSB7XG4gIHN3aXRjaCAocHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICB0aHJvdyBuZXcgSW52YXJpYW50RXJyb3IoXG4gICAgICAgICdFeHBlY3RlZCBkZXNjcmliZUxpc3RPZlByb3BlcnR5TmFtZXMgdG8gYmUgY2FsbGVkIHdpdGggYSBub24tZW1wdHkgbGlzdCBvZiBzdHJpbmdzLidcbiAgICAgIClcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gYFxcYCR7cHJvcGVydGllc1swXX1cXGBgXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGBcXGAke3Byb3BlcnRpZXNbMF19XFxgIGFuZCBcXGAke3Byb3BlcnRpZXNbMV19XFxgYFxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGxldCBkZXNjcmlwdGlvbiA9ICcnXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGRlc2NyaXB0aW9uICs9IGBcXGAke3Byb3BlcnRpZXNbaV19XFxgLCBgXG4gICAgICB9XG4gICAgICBkZXNjcmlwdGlvbiArPSBgLCBhbmQgXFxgJHtwcm9wZXJ0aWVzW3Byb3BlcnRpZXMubGVuZ3RoIC0gMV19XFxgYFxuICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zRm9yQ2xpZW50UGFnZSIsImNyZWF0ZVNlYXJjaFBhcmFtc0Zyb21DbGllbnQiLCJjcmVhdGVTZXJ2ZXJTZWFyY2hQYXJhbXNGb3JNZXRhZGF0YSIsImNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0ZvclNlcnZlclBhZ2UiLCJtYWtlRXJyb3JpbmdFeG90aWNTZWFyY2hQYXJhbXNGb3JVc2VDYWNoZSIsInVuZGVybHlpbmdTZWFyY2hQYXJhbXMiLCJ3b3JrU3RvcmUiLCJ3b3JrVW5pdFN0b3JlIiwid29ya1VuaXRBc3luY1N0b3JhZ2UiLCJnZXRTdG9yZSIsInR5cGUiLCJjcmVhdGVQcmVyZW5kZXJTZWFyY2hQYXJhbXMiLCJjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXMiLCJmb3JjZVN0YXRpYyIsIlByb21pc2UiLCJyZXNvbHZlIiwicHJlcmVuZGVyU3RvcmUiLCJtYWtlSGFuZ2luZ1Byb21pc2UiLCJyZW5kZXJTaWduYWwiLCJtYWtlSGFuZ2luZ1NlYXJjaFBhcmFtcyIsIm1ha2VFcnJvcmluZ0V4b3RpY1NlYXJjaFBhcmFtcyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImlzUHJlZmV0Y2hSZXF1ZXN0IiwiX19ORVhUX0RZTkFNSUNfSU8iLCJtYWtlVW50cmFja2VkU2VhcmNoUGFyYW1zV2l0aERldldhcm5pbmdzIiwibWFrZUR5bmFtaWNhbGx5VHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtc1dpdGhEZXZXYXJuaW5ncyIsIm1ha2VVbnRyYWNrZWRTZWFyY2hQYXJhbXMiLCJtYWtlVW50cmFja2VkRXhvdGljU2VhcmNoUGFyYW1zIiwiQ2FjaGVkU2VhcmNoUGFyYW1zIiwiV2Vha01hcCIsIkNhY2hlZFNlYXJjaFBhcmFtc0ZvclVzZUNhY2hlIiwiY2FjaGVkU2VhcmNoUGFyYW1zIiwiZ2V0IiwicHJvbWlzZSIsInByb3hpZWRQcm9taXNlIiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwicmVjZWl2ZXIiLCJPYmplY3QiLCJoYXNPd24iLCJSZWZsZWN0QWRhcHRlciIsImV4cHJlc3Npb24iLCJhbm5vdGF0ZUR5bmFtaWNBY2Nlc3MiLCJzZXQiLCJkeW5hbWljU2hvdWxkRXJyb3IiLCJ0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvciIsInJvdXRlIiwicG9zdHBvbmVXaXRoVHJhY2tpbmciLCJkeW5hbWljVHJhY2tpbmciLCJ0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbiIsIndlbGxLbm93blByb3BlcnRpZXMiLCJoYXMiLCJkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzIiwiZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5Iiwib3duS2V5cyIsInRocm93Rm9yU2VhcmNoUGFyYW1zQWNjZXNzSW5Vc2VDYWNoZSIsInN0b3JlIiwia2V5cyIsImZvckVhY2giLCJkZWZpbmVQcm9wZXJ0eSIsInRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInByb3hpZWRQcm9wZXJ0aWVzIiwiU2V0IiwidW5wcm94aWVkUHJvcGVydGllcyIsInByb21pc2VJbml0aWFsaXplZCIsInByb3hpZWRVbmRlcmx5aW5nIiwiUmVmbGVjdCIsInNjaGVkdWxlSW1tZWRpYXRlIiwidGhlbiIsInB1c2giLCJhZGQiLCJuZXdWYWx1ZSIsInN5bmNJT0RldiIsImRlbGV0ZSIsIndhcm5Gb3JTeW5jQWNjZXNzIiwid2FybkZvckluY29tcGxldGVFbnVtZXJhdGlvbiIsIm1pc3NpbmdQcm9wZXJ0aWVzIiwibGVuZ3RoIiwicHJlcmVuZGVyUGhhc2UiLCJyZXF1ZXN0U3RvcmUiLCJ0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldiIsImNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYiLCJjcmVhdGVTZWFyY2hBY2Nlc3NFcnJvciIsImNyZWF0ZUluY29tcGxldGVFbnVtZXJhdGlvbkVycm9yIiwicHJlZml4IiwiRXJyb3IiLCJkZXNjcmliZUxpc3RPZlByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0aWVzIiwiSW52YXJpYW50RXJyb3IiLCJkZXNjcmlwdGlvbiIsImkiXSwibWFwcGluZ3MiOiJBQW1LTXFCLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTNEVnZCLHdDQUF3QyxFQUFBO2VBQXhDQTs7SUExQ0FDLDRCQUE0QixFQUFBO2VBQTVCQTs7SUFvQkhDLG1DQUFtQyxFQUFBO2VBQW5DQTs7SUFHR0MscUNBQXFDLEVBQUE7ZUFBckNBOztJQXdVQUMseUNBQXlDLEVBQUE7ZUFBekNBOzs7eUJBM1plO2tDQU94Qjs4Q0FRQTtnQ0FDd0I7dUNBQ0k7MERBQ3lCOzhCQUtyRDt1QkFJQTsyQkFDMkI7QUFnQzNCLFNBQVNILDZCQUNkSSxzQkFBb0MsRUFDcENDLFNBQW9CO0lBRXBCLE1BQU1DLGdCQUFnQkMsOEJBQUFBLG9CQUFvQixDQUFDQyxRQUFRO0lBQ25ELElBQUlGLGVBQWU7UUFDakIsT0FBUUEsY0FBY0csSUFBSTtZQUN4QixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNILE9BQU9DLDRCQUE0QkwsV0FBV0M7WUFDaEQ7UUFFRjtJQUNGO0lBQ0EsT0FBT0sseUJBQXlCUCx3QkFBd0JDO0FBQzFEO0FBR08sTUFBTUosc0NBQ1hDO0FBRUssU0FBU0Esc0NBQ2RFLHNCQUFvQyxFQUNwQ0MsU0FBb0I7SUFFcEIsTUFB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YSxJQUFLO29CQUM5Q0QsZUFBZSxBQUFDLEVBQUUsU0FBRUYsVUFBVSxDQUFDRyxFQUFFLEVBQUMsSUFBSSxDQUFDO2dCQUN6QztnQkFDQUQsZUFBZSxBQUFDLFFBQVEsU0FBRUYsVUFBVSxDQUFDQSxXQUFXVixNQUFNLEdBQUcsRUFBRSxFQUFDLEVBQUUsQ0FBQztnQkFDL0QsT0FBT1k7WUFDVDtJQUNGO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjAwODYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL2FwcC1yZW5kZXIvZHluYW1pYy1hY2Nlc3MtYXN5bmMtc3RvcmFnZS1pbnN0YW5jZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVBc3luY0xvY2FsU3RvcmFnZSB9IGZyb20gJy4vYXN5bmMtbG9jYWwtc3RvcmFnZSdcbmltcG9ydCB0eXBlIHsgRHluYW1pY0FjY2Vzc1N0b3JhZ2UgfSBmcm9tICcuL2R5bmFtaWMtYWNjZXNzLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5cbmV4cG9ydCBjb25zdCBkeW5hbWljQWNjZXNzQXN5bmNTdG9yYWdlSW5zdGFuY2U6IER5bmFtaWNBY2Nlc3NTdG9yYWdlID1cbiAgY3JlYXRlQXN5bmNMb2NhbFN0b3JhZ2UoKVxuIl0sIm5hbWVzIjpbImR5bmFtaWNBY2Nlc3NBc3luY1N0b3JhZ2VJbnN0YW5jZSIsImNyZWF0ZUFzeW5jTG9jYWxTdG9yYWdlIl0sIm1hcHBpbmdzIjoiOzs7K0JBR2FBLHFDQUFBQTs7O2VBQUFBOzs7bUNBSDJCO0FBR2pDLE1BQU1BLG9DQUNYQyxDQUFBQSxHQUFBQSxtQkFBQUEsdUJBQXVCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDIwMTAzLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NlcnZlci9hcHAtcmVuZGVyL2R5bmFtaWMtYWNjZXNzLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBBc3luY0xvY2FsU3RvcmFnZSB9IGZyb20gJ2FzeW5jX2hvb2tzJ1xuXG4vLyBTaGFyZSB0aGUgaW5zdGFuY2UgbW9kdWxlIGluIHRoZSBuZXh0LXNoYXJlZCBsYXllclxuaW1wb3J0IHsgZHluYW1pY0FjY2Vzc0FzeW5jU3RvcmFnZUluc3RhbmNlIH0gZnJvbSAnLi9keW5hbWljLWFjY2Vzcy1hc3luYy1zdG9yYWdlLWluc3RhbmNlJyB3aXRoIHsgJ3R1cmJvcGFjay10cmFuc2l0aW9uJzogJ25leHQtc2hhcmVkJyB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHluYW1pY0FjY2Vzc0FzeW5jU3RvcmUge1xuICByZWFkb25seSBhYm9ydENvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlclxufVxuXG5leHBvcnQgdHlwZSBEeW5hbWljQWNjZXNzU3RvcmFnZSA9IEFzeW5jTG9jYWxTdG9yYWdlPER5bmFtaWNBY2Nlc3NBc3luY1N0b3JlPlxuZXhwb3J0IHsgZHluYW1pY0FjY2Vzc0FzeW5jU3RvcmFnZUluc3RhbmNlIGFzIGR5bmFtaWNBY2Nlc3NBc3luY1N0b3JhZ2UgfVxuIl0sIm5hbWVzIjpbImR5bmFtaWNBY2Nlc3NBc3luY1N0b3JhZ2UiLCJkeW5hbWljQWNjZXNzQXN5bmNTdG9yYWdlSW5zdGFuY2UiXSwibWFwcGluZ3MiOiI7OzsrQkFVOENBLDZCQUFBQTs7O2VBQXJDQyxtQ0FBQUEsaUNBQWlDOzs7bURBUFEiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjAxMTksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL3JlcXVlc3QvcGFyYW1zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgV29ya1N0b3JlIH0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQgdHlwZSB7IEZhbGxiYWNrUm91dGVQYXJhbXMgfSBmcm9tICcuL2ZhbGxiYWNrLXBhcmFtcydcblxuaW1wb3J0IHsgUmVmbGVjdEFkYXB0ZXIgfSBmcm9tICcuLi93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvcmVmbGVjdCdcbmltcG9ydCB7XG4gIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uLFxuICBwb3N0cG9uZVdpdGhUcmFja2luZyxcbiAgdHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYsXG59IGZyb20gJy4uL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcnXG5cbmltcG9ydCB7XG4gIHdvcmtVbml0QXN5bmNTdG9yYWdlLFxuICB0eXBlIFByZXJlbmRlclN0b3JlLFxuICB0eXBlIFByZXJlbmRlclN0b3JlUFBSLFxuICB0eXBlIFByZXJlbmRlclN0b3JlTGVnYWN5LFxuICB0eXBlIFByZXJlbmRlclN0b3JlTW9kZXJuLFxufSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHsgSW52YXJpYW50RXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2ludmFyaWFudC1lcnJvcidcbmltcG9ydCB7XG4gIGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MsXG4gIHdlbGxLbm93blByb3BlcnRpZXMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvdXRpbHMvcmVmbGVjdC11dGlscydcbmltcG9ydCB7IG1ha2VIYW5naW5nUHJvbWlzZSB9IGZyb20gJy4uL2R5bmFtaWMtcmVuZGVyaW5nLXV0aWxzJ1xuaW1wb3J0IHsgY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldiB9IGZyb20gJy4uL2NyZWF0ZS1kZWR1cGVkLWJ5LWNhbGxzaXRlLXNlcnZlci1lcnJvci1sb2dnZXInXG5pbXBvcnQgeyBzY2hlZHVsZUltbWVkaWF0ZSB9IGZyb20gJy4uLy4uL2xpYi9zY2hlZHVsZXInXG5pbXBvcnQgeyBkeW5hbWljQWNjZXNzQXN5bmNTdG9yYWdlIH0gZnJvbSAnLi4vYXBwLXJlbmRlci9keW5hbWljLWFjY2Vzcy1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuXG5leHBvcnQgdHlwZSBQYXJhbVZhbHVlID0gc3RyaW5nIHwgQXJyYXk8c3RyaW5nPiB8IHVuZGVmaW5lZFxuZXhwb3J0IHR5cGUgUGFyYW1zID0gUmVjb3JkPHN0cmluZywgUGFyYW1WYWx1ZT5cblxuLyoqXG4gKiBJbiB0aGlzIHZlcnNpb24gb2YgTmV4dC5qcyB0aGUgYHBhcmFtc2AgcHJvcCBwYXNzZWQgdG8gTGF5b3V0cywgUGFnZXMsIGFuZCBvdGhlciBTZWdtZW50cyBpcyBhIFByb21pc2UuXG4gKiBIb3dldmVyIHRvIGZhY2lsaXRhdGUgbWlncmF0aW9uIHRvIHRoaXMgbmV3IFByb21pc2UgdHlwZSB5b3UgY2FuIGN1cnJlbnRseSBzdGlsbCBhY2Nlc3MgcGFyYW1zIGRpcmVjdGx5IG9uIHRoZSBQcm9taXNlIGluc3RhbmNlIHBhc3NlZCB0byB0aGVzZSBTZWdtZW50cy5cbiAqIFRoZSBgVW5zYWZlVW53cmFwcGVkUGFyYW1zYCB0eXBlIGlzIGF2YWlsYWJsZSBpZiB5b3UgbmVlZCB0byB0ZW1wb3JhcmlseSBhY2Nlc3MgdGhlIHVuZGVybHlpbmcgcGFyYW1zIHdpdGhvdXQgZmlyc3QgYXdhaXRpbmcgb3IgYHVzZWBpbmcgdGhlIFByb21pc2UuXG4gKlxuICogSW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBOZXh0LmpzIHRoZSBgcGFyYW1zYCBwcm9wIHdpbGwgYmUgYSBwbGFpbiBQcm9taXNlIGFuZCB0aGlzIHR5cGUgd2lsbCBiZSByZW1vdmVkLlxuICpcbiAqIFR5cGljYWxseSBpbnN0YW5jZXMgb2YgYHBhcmFtc2AgY2FuIGJlIHVwZGF0ZWQgYXV0b21hdGljYWxseSB0byBiZSB0cmVhdGVkIGFzIGEgUHJvbWlzZSBieSBhIGNvZGVtb2QgcHVibGlzaGVkIGFsb25nc2lkZSB0aGlzIE5leHQuanMgdmVyc2lvbiBob3dldmVyIGlmIHlvdVxuICogaGF2ZSBub3QgeWV0IHJ1biB0aGUgY29kZW1vZCBvZiB0aGUgY29kZW1vZCBjYW5ub3QgZGV0ZWN0IGNlcnRhaW4gaW5zdGFuY2VzIG9mIGBwYXJhbXNgIHVzYWdlIHlvdSBzaG91bGQgZmlyc3QgdHJ5IHRvIHJlZmFjdG9yIHlvdXIgY29kZSB0byBhd2FpdCBgcGFyYW1zYC5cbiAqXG4gKiBJZiByZWZhY3RvcmluZyBpcyBub3QgcG9zc2libGUgYnV0IHlvdSBzdGlsbCB3YW50IHRvIGJlIGFibGUgdG8gYWNjZXNzIHBhcmFtcyBkaXJlY3RseSB3aXRob3V0IHR5cGVzY3JpcHQgZXJyb3JzIHlvdSBjYW4gY2FzdCB0aGUgcGFyYW1zIFByb21pc2UgdG8gdGhpcyB0eXBlXG4gKlxuICogYGBgdHN4XG4gKiB0eXBlIFByb3BzID0geyBwYXJhbXM6IFByb21pc2U8eyBpZDogc3RyaW5nIH0+fVxuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIExheW91dChwcm9wczogUHJvcHMpIHtcbiAqICBjb25zdCBkaXJlY3RQYXJhbXMgPSAocHJvcHMucGFyYW1zIGFzIHVua25vd24gYXMgVW5zYWZlVW53cmFwcGVkUGFyYW1zPHR5cGVvZiBwcm9wcy5wYXJhbXM+KVxuICogIHJldHVybiAuLi5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoaXMgdHlwZSBpcyBtYXJrZWQgZGVwcmVjYXRlZCB0byBoZWxwIGlkZW50aWZ5IGl0IGFzIHRhcmdldCBmb3IgcmVmYWN0b3JpbmcgYXdheS5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgdHlwZSBVbnNhZmVVbndyYXBwZWRQYXJhbXM8UD4gPVxuICBQIGV4dGVuZHMgUHJvbWlzZTxpbmZlciBVPiA/IE9taXQ8VSwgJ3RoZW4nIHwgJ3N0YXR1cycgfCAndmFsdWUnPiA6IG5ldmVyXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYXJhbXNGcm9tQ2xpZW50KFxuICB1bmRlcmx5aW5nUGFyYW1zOiBQYXJhbXMsXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlXG4pIHtcbiAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVByZXJlbmRlclBhcmFtcyh1bmRlcmx5aW5nUGFyYW1zLCB3b3JrU3RvcmUsIHdvcmtVbml0U3RvcmUpXG4gICAgICBkZWZhdWx0OlxuICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVJlbmRlclBhcmFtcyh1bmRlcmx5aW5nUGFyYW1zLCB3b3JrU3RvcmUpXG59XG5cbi8vIGdlbmVyYXRlTWV0YWRhdGEgYWx3YXlzIHJ1bnMgaW4gUlNDIGNvbnRleHQgc28gaXQgaXMgZXF1aXZhbGVudCB0byBhIFNlcnZlciBQYWdlIENvbXBvbmVudFxuZXhwb3J0IHR5cGUgQ3JlYXRlU2VydmVyUGFyYW1zRm9yTWV0YWRhdGEgPSB0eXBlb2YgY3JlYXRlU2VydmVyUGFyYW1zRm9yTWV0YWRhdGFcbmV4cG9ydCBjb25zdCBjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JNZXRhZGF0YSA9IGNyZWF0ZVNlcnZlclBhcmFtc0ZvclNlcnZlclNlZ21lbnRcblxuLy8gcm91dGVzIGFsd2F5cyBydW5zIGluIFJTQyBjb250ZXh0IHNvIGl0IGlzIGVxdWl2YWxlbnQgdG8gYSBTZXJ2ZXIgUGFnZSBDb21wb25lbnRcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JSb3V0ZShcbiAgdW5kZXJseWluZ1BhcmFtczogUGFyYW1zLFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZVxuKSB7XG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgc3dpdGNoICh3b3JrVW5pdFN0b3JlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgICBjYXNlICdwcmVyZW5kZXItY2xpZW50JzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLWxlZ2FjeSc6XG4gICAgICAgIHJldHVybiBjcmVhdGVQcmVyZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlLCB3b3JrVW5pdFN0b3JlKVxuICAgICAgZGVmYXVsdDpcbiAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVSZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VydmVyUGFyYW1zRm9yU2VydmVyU2VnbWVudChcbiAgdW5kZXJseWluZ1BhcmFtczogUGFyYW1zLFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZVxuKTogUHJvbWlzZTxQYXJhbXM+IHtcbiAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVByZXJlbmRlclBhcmFtcyh1bmRlcmx5aW5nUGFyYW1zLCB3b3JrU3RvcmUsIHdvcmtVbml0U3RvcmUpXG4gICAgICBkZWZhdWx0OlxuICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVJlbmRlclBhcmFtcyh1bmRlcmx5aW5nUGFyYW1zLCB3b3JrU3RvcmUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcmVyZW5kZXJQYXJhbXNGb3JDbGllbnRTZWdtZW50KFxuICB1bmRlcmx5aW5nUGFyYW1zOiBQYXJhbXMsXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlXG4pOiBQcm9taXNlPFBhcmFtcz4ge1xuICBjb25zdCBwcmVyZW5kZXJTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgaWYgKFxuICAgIHByZXJlbmRlclN0b3JlICYmXG4gICAgKHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXInIHx8XG4gICAgICBwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLWNsaWVudCcpXG4gICkge1xuICAgIGNvbnN0IGZhbGxiYWNrUGFyYW1zID0gd29ya1N0b3JlLmZhbGxiYWNrUm91dGVQYXJhbXNcbiAgICBpZiAoZmFsbGJhY2tQYXJhbXMpIHtcbiAgICAgIGZvciAobGV0IGtleSBpbiB1bmRlcmx5aW5nUGFyYW1zKSB7XG4gICAgICAgIGlmIChmYWxsYmFja1BhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICAgIC8vIFRoaXMgcGFyYW1zIG9iamVjdCBoYXMgb25lIG9mIG1vcmUgZmFsbGJhY2sgcGFyYW1zIHNvIHdlIG5lZWQgdG8gY29uc2lkZXJcbiAgICAgICAgICAvLyB0aGUgYXdhaXRpbmcgb2YgdGhpcyBwYXJhbXMgb2JqZWN0IFwiZHluYW1pY1wiLiBTaW5jZSB3ZSBhcmUgaW4gZHluYW1pY0lPIG1vZGVcbiAgICAgICAgICAvLyB3ZSBlbmNvZGUgdGhpcyBhcyBhIHByb21pc2UgdGhhdCBuZXZlciByZXNvbHZlc1xuICAgICAgICAgIHJldHVybiBtYWtlSGFuZ2luZ1Byb21pc2UocHJlcmVuZGVyU3RvcmUucmVuZGVyU2lnbmFsLCAnYHBhcmFtc2AnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFdlJ3JlIHByZXJlbmRlcmluZyBpbiBhIG1vZGUgdGhhdCBkb2VzIG5vdCBhYm9ydC4gV2UgcmVzb2x2ZSB0aGUgcHJvbWlzZSB3aXRob3V0XG4gIC8vIGFueSB0cmFja2luZyBiZWNhdXNlIHdlJ3JlIGp1c3QgdHJhbnNwb3J0aW5nIGEgdmFsdWUgZnJvbSBzZXJ2ZXIgdG8gY2xpZW50IHdoZXJlIHRoZSB0cmFja2luZ1xuICAvLyB3aWxsIGJlIGFwcGxpZWQuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZXJseWluZ1BhcmFtcylcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJlcmVuZGVyUGFyYW1zKFxuICB1bmRlcmx5aW5nUGFyYW1zOiBQYXJhbXMsXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlLFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVcbik6IFByb21pc2U8UGFyYW1zPiB7XG4gIGNvbnN0IGZhbGxiYWNrUGFyYW1zID0gd29ya1N0b3JlLmZhbGxiYWNrUm91dGVQYXJhbXNcbiAgaWYgKGZhbGxiYWNrUGFyYW1zKSB7XG4gICAgbGV0IGhhc1NvbWVGYWxsYmFja1BhcmFtcyA9IGZhbHNlXG4gICAgZm9yIChjb25zdCBrZXkgaW4gdW5kZXJseWluZ1BhcmFtcykge1xuICAgICAgaWYgKGZhbGxiYWNrUGFyYW1zLmhhcyhrZXkpKSB7XG4gICAgICAgIGhhc1NvbWVGYWxsYmFja1BhcmFtcyA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzU29tZUZhbGxiYWNrUGFyYW1zKSB7XG4gICAgICAvLyBwYXJhbXMgbmVlZCB0byBiZSB0cmVhdGVkIGFzIGR5bmFtaWMgYmVjYXVzZSB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBmYWxsYmFjayBwYXJhbVxuICAgICAgc3dpdGNoIChwcmVyZW5kZXJTdG9yZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgICAgICAgIC8vIFdlIGFyZSBpbiBhIGR5bmFtaWNJTyBwcmVyZW5kZXJcbiAgICAgICAgICByZXR1cm4gbWFrZUhhbmdpbmdQYXJhbXModW5kZXJseWluZ1BhcmFtcywgcHJlcmVuZGVyU3RvcmUpXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcmluZ0V4b3RpY1BhcmFtcyhcbiAgICAgICAgICAgIHVuZGVybHlpbmdQYXJhbXMsXG4gICAgICAgICAgICBmYWxsYmFja1BhcmFtcyxcbiAgICAgICAgICAgIHdvcmtTdG9yZSxcbiAgICAgICAgICAgIHByZXJlbmRlclN0b3JlXG4gICAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdlIGRvbid0IGhhdmUgYW55IGZhbGxiYWNrIHBhcmFtcyBzbyB3ZSBoYXZlIGFuIGVudGlyZWx5IHN0YXRpYyBzYWZlIHBhcmFtcyBvYmplY3RcbiAgcmV0dXJuIG1ha2VVbnRyYWNrZWRFeG90aWNQYXJhbXModW5kZXJseWluZ1BhcmFtcylcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyUGFyYW1zKFxuICB1bmRlcmx5aW5nUGFyYW1zOiBQYXJhbXMsXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlXG4pOiBQcm9taXNlPFBhcmFtcz4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgIXdvcmtTdG9yZS5pc1ByZWZldGNoUmVxdWVzdCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfRFlOQU1JQ19JTykge1xuICAgICAgcmV0dXJuIG1ha2VEeW5hbWljYWxseVRyYWNrZWRQYXJhbXNXaXRoRGV2V2FybmluZ3MoXG4gICAgICAgIHVuZGVybHlpbmdQYXJhbXMsXG4gICAgICAgIHdvcmtTdG9yZVxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBtYWtlRHluYW1pY2FsbHlUcmFja2VkRXhvdGljUGFyYW1zV2l0aERldldhcm5pbmdzKFxuICAgICAgdW5kZXJseWluZ1BhcmFtcyxcbiAgICAgIHdvcmtTdG9yZVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0RZTkFNSUNfSU8pIHtcbiAgICAgIHJldHVybiBtYWtlVW50cmFja2VkUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMpXG4gICAgfVxuXG4gICAgcmV0dXJuIG1ha2VVbnRyYWNrZWRFeG90aWNQYXJhbXModW5kZXJseWluZ1BhcmFtcylcbiAgfVxufVxuXG5pbnRlcmZhY2UgQ2FjaGVMaWZldGltZSB7fVxuY29uc3QgQ2FjaGVkUGFyYW1zID0gbmV3IFdlYWtNYXA8Q2FjaGVMaWZldGltZSwgUHJvbWlzZTxQYXJhbXM+PigpXG5cbmNvbnN0IGZhbGxiYWNrUGFyYW1zUHJveHlIYW5kbGVyOiBQcm94eUhhbmRsZXI8UHJvbWlzZTxQYXJhbXM+PiA9IHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgIGlmIChwcm9wID09PSAndGhlbicgfHwgcHJvcCA9PT0gJ2NhdGNoJyB8fCBwcm9wID09PSAnZmluYWxseScpIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtwcm9wXTogKC4uLmFyZ3M6IHVua25vd25bXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0b3JlID0gZHluYW1pY0FjY2Vzc0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG5cbiAgICAgICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgIHN0b3JlLmFib3J0Q29udHJvbGxlci5hYm9ydChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKGBBY2Nlc3NlZCBmYWxsYmFjayBcXGBwYXJhbXNcXGAgZHVyaW5nIHByZXJlbmRlcmluZy5gKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXcgUHJveHkoXG4gICAgICAgICAgICBvcmlnaW5hbE1ldGhvZC5hcHBseSh0YXJnZXQsIGFyZ3MpLFxuICAgICAgICAgICAgZmFsbGJhY2tQYXJhbXNQcm94eUhhbmRsZXJcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICB9W3Byb3BdXG4gICAgfVxuXG4gICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICB9LFxufVxuXG5mdW5jdGlvbiBtYWtlSGFuZ2luZ1BhcmFtcyhcbiAgdW5kZXJseWluZ1BhcmFtczogUGFyYW1zLFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVNb2Rlcm5cbik6IFByb21pc2U8UGFyYW1zPiB7XG4gIGNvbnN0IGNhY2hlZFBhcmFtcyA9IENhY2hlZFBhcmFtcy5nZXQodW5kZXJseWluZ1BhcmFtcylcbiAgaWYgKGNhY2hlZFBhcmFtcykge1xuICAgIHJldHVybiBjYWNoZWRQYXJhbXNcbiAgfVxuXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJveHkoXG4gICAgbWFrZUhhbmdpbmdQcm9taXNlPFBhcmFtcz4ocHJlcmVuZGVyU3RvcmUucmVuZGVyU2lnbmFsLCAnYHBhcmFtc2AnKSxcbiAgICBmYWxsYmFja1BhcmFtc1Byb3h5SGFuZGxlclxuICApXG5cbiAgQ2FjaGVkUGFyYW1zLnNldCh1bmRlcmx5aW5nUGFyYW1zLCBwcm9taXNlKVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIG1ha2VFcnJvcmluZ0V4b3RpY1BhcmFtcyhcbiAgdW5kZXJseWluZ1BhcmFtczogUGFyYW1zLFxuICBmYWxsYmFja1BhcmFtczogRmFsbGJhY2tSb3V0ZVBhcmFtcyxcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmUsXG4gIHByZXJlbmRlclN0b3JlOiBQcmVyZW5kZXJTdG9yZVBQUiB8IFByZXJlbmRlclN0b3JlTGVnYWN5XG4pOiBQcm9taXNlPFBhcmFtcz4ge1xuICBjb25zdCBjYWNoZWRQYXJhbXMgPSBDYWNoZWRQYXJhbXMuZ2V0KHVuZGVybHlpbmdQYXJhbXMpXG4gIGlmIChjYWNoZWRQYXJhbXMpIHtcbiAgICByZXR1cm4gY2FjaGVkUGFyYW1zXG4gIH1cblxuICBjb25zdCBhdWdtZW50ZWRVbmRlcmx5aW5nID0geyAuLi51bmRlcmx5aW5nUGFyYW1zIH1cblxuICAvLyBXZSBkb24ndCB1c2UgbWFrZVJlc29sdmVkUmVhY3RQcm9taXNlIGhlcmUgYmVjYXVzZSBwYXJhbXNcbiAgLy8gc3VwcG9ydHMgY29weWluZyB3aXRoIHNwcmVhZCBhbmQgd2UgZG9uJ3Qgd2FudCB0byB1bm5lY2Vzc2FyaWx5XG4gIC8vIGluc3RydW1lbnQgdGhlIHByb21pc2Ugd2l0aCBzcHJlYWRhYmxlIHByb3BlcnRpZXMgb2YgUmVhY3RQcm9taXNlLlxuICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGF1Z21lbnRlZFVuZGVybHlpbmcpXG4gIENhY2hlZFBhcmFtcy5zZXQodW5kZXJseWluZ1BhcmFtcywgcHJvbWlzZSlcblxuICBPYmplY3Qua2V5cyh1bmRlcmx5aW5nUGFyYW1zKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgaWYgKHdlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBzaGFkb3dlZCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSB0aGVcbiAgICAgIC8vIHRydWUgdW5kZXJseWluZyB2YWx1ZSBmb3IgUHJvbWlzZXMgdG8gd29yayBjb3JyZWN0bHkgYXQgcnVudGltZVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmFsbGJhY2tQYXJhbXMuaGFzKHByb3ApKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhdWdtZW50ZWRVbmRlcmx5aW5nLCBwcm9wLCB7XG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MoJ3BhcmFtcycsIHByb3ApXG4gICAgICAgICAgICAvLyBJbiBtb3N0IGR5bmFtaWMgQVBJcyB3ZSBhbHNvIHRocm93IGlmIGBkeW5hbWljID0gXCJlcnJvclwiYCBob3dldmVyXG4gICAgICAgICAgICAvLyBmb3IgcGFyYW1zIGlzIG9ubHkgZHluYW1pYyB3aGVuIHdlJ3JlIGdlbmVyYXRpbmcgYSBmYWxsYmFjayBzaGVsbFxuICAgICAgICAgICAgLy8gYW5kIGV2ZW4gd2hlbiBgZHluYW1pYyA9IFwiZXJyb3JcImAgd2Ugc3RpbGwgc3VwcG9ydCBnZW5lcmF0aW5nIGR5bmFtaWNcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHNoZWxsc1xuICAgICAgICAgICAgLy8gVE9ETyByZW1vdmUgdGhpcyBjb21tZW50IHdoZW4gZHluYW1pY0lPIGlzIHRoZSBkZWZhdWx0IHNpbmNlIHRoZXJlXG4gICAgICAgICAgICAvLyB3aWxsIGJlIG5vIGBkeW5hbWljID0gXCJlcnJvclwiYFxuICAgICAgICAgICAgaWYgKHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJykge1xuICAgICAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgICAgIHBvc3Rwb25lV2l0aFRyYWNraW5nKFxuICAgICAgICAgICAgICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBMZWdhY3kgUHJlcmVuZGVyXG4gICAgICAgICAgICAgIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgd29ya1N0b3JlLFxuICAgICAgICAgICAgICAgIHByZXJlbmRlclN0b3JlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBwcm9wLCB7XG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MoJ3BhcmFtcycsIHByb3ApXG4gICAgICAgICAgICAvLyBJbiBtb3N0IGR5bmFtaWMgQVBJcyB3ZSBhbHNvIHRocm93IGlmIGBkeW5hbWljID0gXCJlcnJvclwiYCBob3dldmVyXG4gICAgICAgICAgICAvLyBmb3IgcGFyYW1zIGlzIG9ubHkgZHluYW1pYyB3aGVuIHdlJ3JlIGdlbmVyYXRpbmcgYSBmYWxsYmFjayBzaGVsbFxuICAgICAgICAgICAgLy8gYW5kIGV2ZW4gd2hlbiBgZHluYW1pYyA9IFwiZXJyb3JcImAgd2Ugc3RpbGwgc3VwcG9ydCBnZW5lcmF0aW5nIGR5bmFtaWNcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHNoZWxsc1xuICAgICAgICAgICAgLy8gVE9ETyByZW1vdmUgdGhpcyBjb21tZW50IHdoZW4gZHluYW1pY0lPIGlzIHRoZSBkZWZhdWx0IHNpbmNlIHRoZXJlXG4gICAgICAgICAgICAvLyB3aWxsIGJlIG5vIGBkeW5hbWljID0gXCJlcnJvclwiYFxuICAgICAgICAgICAgaWYgKHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJykge1xuICAgICAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgICAgIHBvc3Rwb25lV2l0aFRyYWNraW5nKFxuICAgICAgICAgICAgICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBMZWdhY3kgUHJlcmVuZGVyXG4gICAgICAgICAgICAgIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgd29ya1N0b3JlLFxuICAgICAgICAgICAgICAgIHByZXJlbmRlclN0b3JlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIDsocHJvbWlzZSBhcyBhbnkpW3Byb3BdID0gdW5kZXJseWluZ1BhcmFtc1twcm9wXVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiBtYWtlVW50cmFja2VkRXhvdGljUGFyYW1zKHVuZGVybHlpbmdQYXJhbXM6IFBhcmFtcyk6IFByb21pc2U8UGFyYW1zPiB7XG4gIGNvbnN0IGNhY2hlZFBhcmFtcyA9IENhY2hlZFBhcmFtcy5nZXQodW5kZXJseWluZ1BhcmFtcylcbiAgaWYgKGNhY2hlZFBhcmFtcykge1xuICAgIHJldHVybiBjYWNoZWRQYXJhbXNcbiAgfVxuXG4gIC8vIFdlIGRvbid0IHVzZSBtYWtlUmVzb2x2ZWRSZWFjdFByb21pc2UgaGVyZSBiZWNhdXNlIHBhcmFtc1xuICAvLyBzdXBwb3J0cyBjb3B5aW5nIHdpdGggc3ByZWFkIGFuZCB3ZSBkb24ndCB3YW50IHRvIHVubmVjZXNzYXJpbHlcbiAgLy8gaW5zdHJ1bWVudCB0aGUgcHJvbWlzZSB3aXRoIHNwcmVhZGFibGUgcHJvcGVydGllcyBvZiBSZWFjdFByb21pc2UuXG4gIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZXJseWluZ1BhcmFtcylcbiAgQ2FjaGVkUGFyYW1zLnNldCh1bmRlcmx5aW5nUGFyYW1zLCBwcm9taXNlKVxuXG4gIE9iamVjdC5rZXlzKHVuZGVybHlpbmdQYXJhbXMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBpZiAod2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkpIHtcbiAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgfSBlbHNlIHtcbiAgICAgIDsocHJvbWlzZSBhcyBhbnkpW3Byb3BdID0gdW5kZXJseWluZ1BhcmFtc1twcm9wXVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiBtYWtlVW50cmFja2VkUGFyYW1zKHVuZGVybHlpbmdQYXJhbXM6IFBhcmFtcyk6IFByb21pc2U8UGFyYW1zPiB7XG4gIGNvbnN0IGNhY2hlZFBhcmFtcyA9IENhY2hlZFBhcmFtcy5nZXQodW5kZXJseWluZ1BhcmFtcylcbiAgaWYgKGNhY2hlZFBhcmFtcykge1xuICAgIHJldHVybiBjYWNoZWRQYXJhbXNcbiAgfVxuXG4gIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZXJseWluZ1BhcmFtcylcbiAgQ2FjaGVkUGFyYW1zLnNldCh1bmRlcmx5aW5nUGFyYW1zLCBwcm9taXNlKVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIG1ha2VEeW5hbWljYWxseVRyYWNrZWRFeG90aWNQYXJhbXNXaXRoRGV2V2FybmluZ3MoXG4gIHVuZGVybHlpbmdQYXJhbXM6IFBhcmFtcyxcbiAgc3RvcmU6IFdvcmtTdG9yZVxuKTogUHJvbWlzZTxQYXJhbXM+IHtcbiAgY29uc3QgY2FjaGVkUGFyYW1zID0gQ2FjaGVkUGFyYW1zLmdldCh1bmRlcmx5aW5nUGFyYW1zKVxuICBpZiAoY2FjaGVkUGFyYW1zKSB7XG4gICAgcmV0dXJuIGNhY2hlZFBhcmFtc1xuICB9XG5cbiAgLy8gV2UgZG9uJ3QgdXNlIG1ha2VSZXNvbHZlZFJlYWN0UHJvbWlzZSBoZXJlIGJlY2F1c2UgcGFyYW1zXG4gIC8vIHN1cHBvcnRzIGNvcHlpbmcgd2l0aCBzcHJlYWQgYW5kIHdlIGRvbid0IHdhbnQgdG8gdW5uZWNlc3NhcmlseVxuICAvLyBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHdpdGggc3ByZWFkYWJsZSBwcm9wZXJ0aWVzIG9mIFJlYWN0UHJvbWlzZS5cbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFBhcmFtcz4oKHJlc29sdmUpID0+XG4gICAgc2NoZWR1bGVJbW1lZGlhdGUoKCkgPT4gcmVzb2x2ZSh1bmRlcmx5aW5nUGFyYW1zKSlcbiAgKVxuXG4gIGNvbnN0IHByb3hpZWRQcm9wZXJ0aWVzID0gbmV3IFNldDxzdHJpbmc+KClcbiAgY29uc3QgdW5wcm94aWVkUHJvcGVydGllczogQXJyYXk8c3RyaW5nPiA9IFtdXG5cbiAgT2JqZWN0LmtleXModW5kZXJseWluZ1BhcmFtcykuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIGlmICh3ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBjYW5ub3QgYmUgc2hhZG93ZWQgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgdGhlXG4gICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgIHVucHJveGllZFByb3BlcnRpZXMucHVzaChwcm9wKVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm94aWVkUHJvcGVydGllcy5hZGQocHJvcClcbiAgICAgIDsocHJvbWlzZSBhcyBhbnkpW3Byb3BdID0gdW5kZXJseWluZ1BhcmFtc1twcm9wXVxuICAgIH1cbiAgfSlcblxuICBjb25zdCBwcm94aWVkUHJvbWlzZSA9IG5ldyBQcm94eShwcm9taXNlLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIFdlIGFyZSBhY2Nlc3NpbmcgYSBwcm9wZXJ0eSB0aGF0IHdhcyBwcm94aWVkIHRvIHRoZSBwcm9taXNlIGluc3RhbmNlXG4gICAgICAgICAgcHJveGllZFByb3BlcnRpZXMuaGFzKHByb3ApXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKCdwYXJhbXMnLCBwcm9wKVxuICAgICAgICAgIHN5bmNJT0RldihzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmRlbGV0ZShwcm9wKVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLnNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcilcbiAgICB9LFxuICAgIG93bktleXModGFyZ2V0KSB7XG4gICAgICBjb25zdCBleHByZXNzaW9uID0gJ2AuLi5wYXJhbXNgIG9yIHNpbWlsYXIgZXhwcmVzc2lvbidcbiAgICAgIHN5bmNJT0RldihzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbiwgdW5wcm94aWVkUHJvcGVydGllcylcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxuICAgIH0sXG4gIH0pXG5cbiAgQ2FjaGVkUGFyYW1zLnNldCh1bmRlcmx5aW5nUGFyYW1zLCBwcm94aWVkUHJvbWlzZSlcbiAgcmV0dXJuIHByb3hpZWRQcm9taXNlXG59XG5cbi8vIFNpbWlsYXIgdG8gYG1ha2VEeW5hbWljYWxseVRyYWNrZWRFeG90aWNQYXJhbXNXaXRoRGV2V2FybmluZ3NgLCBidXQganVzdFxuLy8gbG9nZ2luZyB0aGUgc3luYyBhY2Nlc3Mgd2l0aG91dCBhY3R1YWxseSBkZWZpbmluZyB0aGUgcGFyYW1zIG9uIHRoZSBwcm9taXNlLlxuZnVuY3Rpb24gbWFrZUR5bmFtaWNhbGx5VHJhY2tlZFBhcmFtc1dpdGhEZXZXYXJuaW5ncyhcbiAgdW5kZXJseWluZ1BhcmFtczogUGFyYW1zLFxuICBzdG9yZTogV29ya1N0b3JlXG4pOiBQcm9taXNlPFBhcmFtcz4ge1xuICBjb25zdCBjYWNoZWRQYXJhbXMgPSBDYWNoZWRQYXJhbXMuZ2V0KHVuZGVybHlpbmdQYXJhbXMpXG4gIGlmIChjYWNoZWRQYXJhbXMpIHtcbiAgICByZXR1cm4gY2FjaGVkUGFyYW1zXG4gIH1cblxuICAvLyBXZSBkb24ndCB1c2UgbWFrZVJlc29sdmVkUmVhY3RQcm9taXNlIGhlcmUgYmVjYXVzZSBwYXJhbXNcbiAgLy8gc3VwcG9ydHMgY29weWluZyB3aXRoIHNwcmVhZCBhbmQgd2UgZG9uJ3Qgd2FudCB0byB1bm5lY2Vzc2FyaWx5XG4gIC8vIGluc3RydW1lbnQgdGhlIHByb21pc2Ugd2l0aCBzcHJlYWRhYmxlIHByb3BlcnRpZXMgb2YgUmVhY3RQcm9taXNlLlxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8UGFyYW1zPigocmVzb2x2ZSkgPT5cbiAgICBzY2hlZHVsZUltbWVkaWF0ZSgoKSA9PiByZXNvbHZlKHVuZGVybHlpbmdQYXJhbXMpKVxuICApXG5cbiAgY29uc3QgcHJveGllZFByb3BlcnRpZXMgPSBuZXcgU2V0PHN0cmluZz4oKVxuICBjb25zdCB1bnByb3hpZWRQcm9wZXJ0aWVzOiBBcnJheTxzdHJpbmc+ID0gW11cblxuICBPYmplY3Qua2V5cyh1bmRlcmx5aW5nUGFyYW1zKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgaWYgKHdlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBzaGFkb3dlZCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSB0aGVcbiAgICAgIC8vIHRydWUgdW5kZXJseWluZyB2YWx1ZSBmb3IgUHJvbWlzZXMgdG8gd29yayBjb3JyZWN0bHkgYXQgcnVudGltZVxuICAgICAgdW5wcm94aWVkUHJvcGVydGllcy5wdXNoKHByb3ApXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmFkZChwcm9wKVxuICAgIH1cbiAgfSlcblxuICBjb25zdCBwcm94aWVkUHJvbWlzZSA9IG5ldyBQcm94eShwcm9taXNlLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIFdlIGFyZSBhY2Nlc3NpbmcgYSBwcm9wZXJ0eSB0aGF0IHdhcyBwcm94aWVkIHRvIHRoZSBwcm9taXNlIGluc3RhbmNlXG4gICAgICAgICAgcHJveGllZFByb3BlcnRpZXMuaGFzKHByb3ApXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKCdwYXJhbXMnLCBwcm9wKVxuICAgICAgICAgIHdhcm5Gb3JTeW5jQWNjZXNzKHN0b3JlLnJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcHJveGllZFByb3BlcnRpZXMuZGVsZXRlKHByb3ApXG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKVxuICAgIH0sXG4gICAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYC4uLnBhcmFtc2Agb3Igc2ltaWxhciBleHByZXNzaW9uJ1xuICAgICAgd2FybkZvckluY29tcGxldGVFbnVtZXJhdGlvbihzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbiwgdW5wcm94aWVkUHJvcGVydGllcylcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxuICAgIH0sXG4gIH0pXG5cbiAgQ2FjaGVkUGFyYW1zLnNldCh1bmRlcmx5aW5nUGFyYW1zLCBwcm94aWVkUHJvbWlzZSlcbiAgcmV0dXJuIHByb3hpZWRQcm9taXNlXG59XG5cbmZ1bmN0aW9uIHN5bmNJT0RldihcbiAgcm91dGU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgZXhwcmVzc2lvbjogc3RyaW5nLFxuICBtaXNzaW5nUHJvcGVydGllcz86IEFycmF5PHN0cmluZz5cbikge1xuICBjb25zdCB3b3JrVW5pdFN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICBpZiAoXG4gICAgd29ya1VuaXRTdG9yZSAmJlxuICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3JlcXVlc3QnICYmXG4gICAgd29ya1VuaXRTdG9yZS5wcmVyZW5kZXJQaGFzZSA9PT0gdHJ1ZVxuICApIHtcbiAgICAvLyBXaGVuIHdlJ3JlIHJlbmRlcmluZyBkeW5hbWljYWxseSBpbiBkZXYgd2UgbmVlZCB0byBhZHZhbmNlIG91dCBvZiB0aGVcbiAgICAvLyBQcmVyZW5kZXIgZW52aXJvbm1lbnQgd2hlbiB3ZSByZWFkIFJlcXVlc3QgZGF0YSBzeW5jaHJvbm91c2x5XG4gICAgY29uc3QgcmVxdWVzdFN0b3JlID0gd29ya1VuaXRTdG9yZVxuICAgIHRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2KHJlcXVlc3RTdG9yZSlcbiAgfVxuICAvLyBJbiBhbGwgY2FzZXMgd2Ugd2FybiBub3JtYWxseVxuICBpZiAobWlzc2luZ1Byb3BlcnRpZXMgJiYgbWlzc2luZ1Byb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgIHdhcm5Gb3JJbmNvbXBsZXRlRW51bWVyYXRpb24ocm91dGUsIGV4cHJlc3Npb24sIG1pc3NpbmdQcm9wZXJ0aWVzKVxuICB9IGVsc2Uge1xuICAgIHdhcm5Gb3JTeW5jQWNjZXNzKHJvdXRlLCBleHByZXNzaW9uKVxuICB9XG59XG5cbmNvbnN0IHdhcm5Gb3JTeW5jQWNjZXNzID0gY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldihcbiAgY3JlYXRlUGFyYW1zQWNjZXNzRXJyb3JcbilcblxuY29uc3Qgd2FybkZvckluY29tcGxldGVFbnVtZXJhdGlvbiA9XG4gIGNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYoY3JlYXRlSW5jb21wbGV0ZUVudW1lcmF0aW9uRXJyb3IpXG5cbmZ1bmN0aW9uIGNyZWF0ZVBhcmFtc0FjY2Vzc0Vycm9yKFxuICByb3V0ZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBleHByZXNzaW9uOiBzdHJpbmdcbikge1xuICBjb25zdCBwcmVmaXggPSByb3V0ZSA/IGBSb3V0ZSBcIiR7cm91dGV9XCIgYCA6ICdUaGlzIHJvdXRlICdcbiAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICBgJHtwcmVmaXh9dXNlZCAke2V4cHJlc3Npb259LiBgICtcbiAgICAgIGBcXGBwYXJhbXNcXGAgc2hvdWxkIGJlIGF3YWl0ZWQgYmVmb3JlIHVzaW5nIGl0cyBwcm9wZXJ0aWVzLiBgICtcbiAgICAgIGBMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9zeW5jLWR5bmFtaWMtYXBpc2BcbiAgKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVJbmNvbXBsZXRlRW51bWVyYXRpb25FcnJvcihcbiAgcm91dGU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgZXhwcmVzc2lvbjogc3RyaW5nLFxuICBtaXNzaW5nUHJvcGVydGllczogQXJyYXk8c3RyaW5nPlxuKSB7XG4gIGNvbnN0IHByZWZpeCA9IHJvdXRlID8gYFJvdXRlIFwiJHtyb3V0ZX1cIiBgIDogJ1RoaXMgcm91dGUgJ1xuICByZXR1cm4gbmV3IEVycm9yKFxuICAgIGAke3ByZWZpeH11c2VkICR7ZXhwcmVzc2lvbn0uIGAgK1xuICAgICAgYFxcYHBhcmFtc1xcYCBzaG91bGQgYmUgYXdhaXRlZCBiZWZvcmUgdXNpbmcgaXRzIHByb3BlcnRpZXMuIGAgK1xuICAgICAgYFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyB3ZXJlIG5vdCBhdmFpbGFibGUgdGhyb3VnaCBlbnVtZXJhdGlvbiBgICtcbiAgICAgIGBiZWNhdXNlIHRoZXkgY29uZmxpY3Qgd2l0aCBidWlsdGluIHByb3BlcnR5IG5hbWVzOiBgICtcbiAgICAgIGAke2Rlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyhtaXNzaW5nUHJvcGVydGllcyl9LiBgICtcbiAgICAgIGBMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9zeW5jLWR5bmFtaWMtYXBpc2BcbiAgKVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZUxpc3RPZlByb3BlcnR5TmFtZXMocHJvcGVydGllczogQXJyYXk8c3RyaW5nPikge1xuICBzd2l0Y2ggKHByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgdGhyb3cgbmV3IEludmFyaWFudEVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzIHRvIGJlIGNhbGxlZCB3aXRoIGEgbm9uLWVtcHR5IGxpc3Qgb2Ygc3RyaW5ncy4nXG4gICAgICApXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGBcXGAke3Byb3BlcnRpZXNbMF19XFxgYFxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBgXFxgJHtwcm9wZXJ0aWVzWzBdfVxcYCBhbmQgXFxgJHtwcm9wZXJ0aWVzWzFdfVxcYGBcbiAgICBkZWZhdWx0OiB7XG4gICAgICBsZXQgZGVzY3JpcHRpb24gPSAnJ1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBkZXNjcmlwdGlvbiArPSBgXFxgJHtwcm9wZXJ0aWVzW2ldfVxcYCwgYFxuICAgICAgfVxuICAgICAgZGVzY3JpcHRpb24gKz0gYCwgYW5kIFxcYCR7cHJvcGVydGllc1twcm9wZXJ0aWVzLmxlbmd0aCAtIDFdfVxcYGBcbiAgICAgIHJldHVybiBkZXNjcmlwdGlvblxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZVBhcmFtc0Zyb21DbGllbnQiLCJjcmVhdGVQcmVyZW5kZXJQYXJhbXNGb3JDbGllbnRTZWdtZW50IiwiY3JlYXRlU2VydmVyUGFyYW1zRm9yTWV0YWRhdGEiLCJjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JSb3V0ZSIsImNyZWF0ZVNlcnZlclBhcmFtc0ZvclNlcnZlclNlZ21lbnQiLCJ1bmRlcmx5aW5nUGFyYW1zIiwid29ya1N0b3JlIiwid29ya1VuaXRTdG9yZSIsIndvcmtVbml0QXN5bmNTdG9yYWdlIiwiZ2V0U3RvcmUiLCJ0eXBlIiwiY3JlYXRlUHJlcmVuZGVyUGFyYW1zIiwiY3JlYXRlUmVuZGVyUGFyYW1zIiwicHJlcmVuZGVyU3RvcmUiLCJmYWxsYmFja1BhcmFtcyIsImZhbGxiYWNrUm91dGVQYXJhbXMiLCJrZXkiLCJoYXMiLCJtYWtlSGFuZ2luZ1Byb21pc2UiLCJyZW5kZXJTaWduYWwiLCJQcm9taXNlIiwicmVzb2x2ZSIsImhhc1NvbWVGYWxsYmFja1BhcmFtcyIsIm1ha2VIYW5naW5nUGFyYW1zIiwibWFrZUVycm9yaW5nRXhvdGljUGFyYW1zIiwibWFrZVVudHJhY2tlZEV4b3RpY1BhcmFtcyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImlzUHJlZmV0Y2hSZXF1ZXN0IiwiX19ORVhUX0RZTkFNSUNfSU8iLCJtYWtlRHluYW1pY2FsbHlUcmFja2VkUGFyYW1zV2l0aERldldhcm5pbmdzIiwibWFrZUR5bmFtaWNhbGx5VHJhY2tlZEV4b3RpY1BhcmFtc1dpdGhEZXZXYXJuaW5ncyIsIm1ha2VVbnRyYWNrZWRQYXJhbXMiLCJDYWNoZWRQYXJhbXMiLCJXZWFrTWFwIiwiZmFsbGJhY2tQYXJhbXNQcm94eUhhbmRsZXIiLCJnZXQiLCJ0YXJnZXQiLCJwcm9wIiwicmVjZWl2ZXIiLCJvcmlnaW5hbE1ldGhvZCIsIlJlZmxlY3RBZGFwdGVyIiwiYXJncyIsInN0b3JlIiwiZHluYW1pY0FjY2Vzc0FzeW5jU3RvcmFnZSIsImFib3J0Q29udHJvbGxlciIsImFib3J0IiwiRXJyb3IiLCJQcm94eSIsImFwcGx5IiwiY2FjaGVkUGFyYW1zIiwicHJvbWlzZSIsInNldCIsImF1Z21lbnRlZFVuZGVybHlpbmciLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsIndlbGxLbm93blByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cHJlc3Npb24iLCJkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzIiwicG9zdHBvbmVXaXRoVHJhY2tpbmciLCJyb3V0ZSIsImR5bmFtaWNUcmFja2luZyIsInRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uIiwiZW51bWVyYWJsZSIsIm5ld1ZhbHVlIiwidmFsdWUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsInNjaGVkdWxlSW1tZWRpYXRlIiwicHJveGllZFByb3BlcnRpZXMiLCJTZXQiLCJ1bnByb3hpZWRQcm9wZXJ0aWVzIiwicHVzaCIsImFkZCIsInByb3hpZWRQcm9taXNlIiwic3luY0lPRGV2IiwiZGVsZXRlIiwib3duS2V5cyIsIlJlZmxlY3QiLCJ3YXJuRm9yU3luY0FjY2VzcyIsIndhcm5Gb3JJbmNvbXBsZXRlRW51bWVyYXRpb24iLCJtaXNzaW5nUHJvcGVydGllcyIsInByZXJlbmRlclBoYXNlIiwicmVxdWVzdFN0b3JlIiwidHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYiLCJsZW5ndGgiLCJjcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2IiwiY3JlYXRlUGFyYW1zQWNjZXNzRXJyb3IiLCJjcmVhdGVJbmNvbXBsZXRlRW51bWVyYXRpb25FcnJvciIsInByZWZpeCIsImRlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyIsInByb3BlcnRpZXMiLCJJbnZhcmlhbnRFcnJvciIsImRlc2NyaXB0aW9uIiwiaSJdLCJtYXBwaW5ncyI6IkFBNkxNMEIsUUFBUUMsR0FBRyxDQUFDQyxRQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBbklWNUIsc0JBQXNCLEVBQUE7ZUFBdEJBOztJQThEQUMscUNBQXFDLEVB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Q0FBQztnQkFDekM7Z0JBQ0FELGVBQWUsQUFBQyxRQUFRLFNBQUVGLFVBQVUsQ0FBQ0EsV0FBV04sTUFBTSxHQUFHLEVBQUUsRUFBQyxFQUFFLENBQUM7Z0JBQy9ELE9BQU9RO1lBQ1Q7SUFDRjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDIwNTU0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL2NsaWVudC1wYWdlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHR5cGUgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgSW52YXJpYW50RXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2ludmFyaWFudC1lcnJvcidcblxuaW1wb3J0IHR5cGUgeyBQYXJhbXMgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnXG5cbi8qKlxuICogV2hlbiB0aGUgUGFnZSBpcyBhIGNsaWVudCBjb21wb25lbnQgd2Ugc2VuZCB0aGUgcGFyYW1zIGFuZCBzZWFyY2hQYXJhbXMgdG8gdGhpcyBjbGllbnQgd3JhcHBlclxuICogd2hlcmUgdGhleSBhcmUgdHVybmVkIGludG8gZHluYW1pY2FsbHkgdHJhY2tlZCB2YWx1ZXMgYmVmb3JlIGJlaW5nIHBhc3NlZCB0byB0aGUgYWN0dWFsIFBhZ2UgY29tcG9uZW50LlxuICpcbiAqIGFkZGl0aW9uYWxseSB3ZSBtYXkgc2VuZCBwcm9taXNlcyByZXByZXNlbnRpbmcgdGhlIHBhcmFtcyBhbmQgc2VhcmNoUGFyYW1zLiBXZSBkb24ndCBldmVyIHVzZSB0aGVzZSBwYXNzZWRcbiAqIHZhbHVlcyBidXQgaXQgY2FuIGJlIG5lY2Vzc2FyeSBmb3IgdGhlIHNlbmRlciB0byBzZW5kIGEgUHJvbWlzZSB0aGF0IGRvZXNuJ3QgcmVzb2x2ZSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMuXG4gKiBJdCBpcyB1cCB0byB0aGUgY2FsbGVyIHRvIGRlY2lkZSBpZiB0aGUgcHJvbWlzZXMgYXJlIG5lZWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENsaWVudFBhZ2VSb290KHtcbiAgQ29tcG9uZW50LFxuICBzZWFyY2hQYXJhbXMsXG4gIHBhcmFtcyxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBwcm9taXNlcyxcbn06IHtcbiAgQ29tcG9uZW50OiBSZWFjdC5Db21wb25lbnRUeXBlPGFueT5cbiAgc2VhcmNoUGFyYW1zOiBQYXJzZWRVcmxRdWVyeVxuICBwYXJhbXM6IFBhcmFtc1xuICBwcm9taXNlcz86IEFycmF5PFByb21pc2U8YW55Pj5cbn0pIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgeyB3b3JrQXN5bmNTdG9yYWdlIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJylcblxuICAgIGxldCBjbGllbnRTZWFyY2hQYXJhbXM6IFByb21pc2U8UGFyc2VkVXJsUXVlcnk+XG4gICAgbGV0IGNsaWVudFBhcmFtczogUHJvbWlzZTxQYXJhbXM+XG4gICAgLy8gV2UgYXJlIGdvaW5nIHRvIGluc3RydW1lbnQgdGhlIHNlYXJjaFBhcmFtcyBwcm9wIHdpdGggdHJhY2tpbmcgZm9yIHRoZVxuICAgIC8vIGFwcHJvcHJpYXRlIGNvbnRleHQuIFdlIHdyYXAgZGlmZmVyZW50bHkgaW4gcHJlcmVuZGVyaW5nIHZzIHJlbmRlcmluZ1xuICAgIGNvbnN0IHN0b3JlID0gd29ya0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gICAgaWYgKCFzdG9yZSkge1xuICAgICAgdGhyb3cgbmV3IEludmFyaWFudEVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgd29ya1N0b3JlIHRvIGV4aXN0IHdoZW4gaGFuZGxpbmcgc2VhcmNoUGFyYW1zIGluIGEgY2xpZW50IFBhZ2UuJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHsgY3JlYXRlU2VhcmNoUGFyYW1zRnJvbUNsaWVudCB9ID1cbiAgICAgIHJlcXVpcmUoJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3NlYXJjaC1wYXJhbXMnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9zZWFyY2gtcGFyYW1zJylcbiAgICBjbGllbnRTZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXNGcm9tQ2xpZW50KHNlYXJjaFBhcmFtcywgc3RvcmUpXG5cbiAgICBjb25zdCB7IGNyZWF0ZVBhcmFtc0Zyb21DbGllbnQgfSA9XG4gICAgICByZXF1aXJlKCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnKVxuICAgIGNsaWVudFBhcmFtcyA9IGNyZWF0ZVBhcmFtc0Zyb21DbGllbnQocGFyYW1zLCBzdG9yZSlcblxuICAgIHJldHVybiA8Q29tcG9uZW50IHBhcmFtcz17Y2xpZW50UGFyYW1zfSBzZWFyY2hQYXJhbXM9e2NsaWVudFNlYXJjaFBhcmFtc30gLz5cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7IGNyZWF0ZVJlbmRlclNlYXJjaFBhcmFtc0Zyb21DbGllbnQgfSA9XG4gICAgICByZXF1aXJlKCcuLi9yZXF1ZXN0L3NlYXJjaC1wYXJhbXMuYnJvd3NlcicpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcy5icm93c2VyJylcbiAgICBjb25zdCBjbGllbnRTZWFyY2hQYXJhbXMgPSBjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXNGcm9tQ2xpZW50KHNlYXJjaFBhcmFtcylcbiAgICBjb25zdCB7IGNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQgfSA9XG4gICAgICByZXF1aXJlKCcuLi9yZXF1ZXN0L3BhcmFtcy5icm93c2VyJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vcmVxdWVzdC9wYXJhbXMuYnJvd3NlcicpXG4gICAgY29uc3QgY2xpZW50UGFyYW1zID0gY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudChwYXJhbXMpXG5cbiAgICByZXR1cm4gPENvbXBvbmVudCBwYXJhbXM9e2NsaWVudFBhcmFtc30gc2VhcmNoUGFyYW1zPXtjbGllbnRTZWFyY2hQYXJhbXN9IC8+XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJDbGllbnRQYWdlUm9vdCIsIkNvbXBvbmVudCIsInNlYXJjaFBhcmFtcyIsInBhcmFtcyIsInByb21pc2VzIiwid2luZG93Iiwid29ya0FzeW5jU3RvcmFnZSIsInJlcXVpcmUiLCJjbGllbnRTZWFyY2hQYXJhbXMiLCJjbGllbnRQYXJhbXMiLCJzdG9yZSIsImdldFN0b3JlIiwiSW52YXJpYW50RXJyb3IiLCJjcmVhdGVTZWFyY2hQYXJhbXNGcm9tQ2xpZW50IiwiY3JlYXRlUGFyYW1zRnJvbUNsaWVudCIsImNyZWF0ZVJlbmRlclNlYXJjaFBhcmFtc0Zyb21DbGllbnQiLCJjcmVhdGVSZW5kZXJQYXJhbXNGcm9tQ2xpZW50Il0sIm1hcHBpbmdzIjoiOzs7K0JBZWdCQSxrQkFBQUE7OztlQUFBQTs7OztnQ0FaZTtBQVl4QixTQUFTQSxlQUFlLEtBVzlCO0lBWDhCLElBQUEsRUFDN0JDLFNBQVMsRUFDVEMsWUFBWSxFQUNaQyxNQUFNLEVBQ04sQUFDQUMsUUFBUSxFQU1ULEdBWDhCLGdEQUlnQztJQVE3RCxJQUFJLE9BQU9DLFdBQVcsYUFBYTtRQUNqQyxNQUFNLEVBQUVDLGdCQUFnQixFQUFFLEdBQ3hCQyxRQUFRO1FBRVYsSUFBSUM7UUFDSixJQUFJQztRQUNKLHlFQUF5RTtRQUN6RSx3RUFBd0U7UUFDeEUsTUFBTUMsUUFBUUosaUJBQWlCSyxRQUFRO1FBQ3ZDLElBQUksQ0FBQ0QsT0FBTztZQUNWLE1BQU0sT0FBQSxjQUVMLENBRkssSUFBSUUsZ0JBQUFBLGNBQWMsQ0FDdEIsNkVBREkscUJBQUE7dUJBQUE7NEJBQUE7OEJBQUE7WUFFTjtRQUNGO1FBRUEsTUFBTSxFQUFFQyw0QkFBNEIsRUFBRSxHQUNwQ04sUUFBUTtRQUNWQyxxQkFBcUJLLDZCQUE2QlgsY0FBY1E7UUFFaEUsTUFBTSxFQUFFSSxzQkFBc0IsRUFBRSxHQUM5QlAsUUFBUTtRQUNWRSxlQUFlSyx1QkFBdUJYLFFBQVFPO1FBRTlDLE9BQUEsV0FBQSxHQUFPLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ1QsV0FBQUE7WUFBVUUsUUFBUU07WUFBY1AsY0FBY007O0lBQ3hELE9BQU87UUFDTCxNQUFNLEVBQUVPLGtDQUFrQyxFQUFFLEdBQzFDUixRQUFRO1FBQ1YsTUFBTUMscUJBQXFCTyxtQ0FBbUNiO1FBQzlELE1BQU0sRUFBRWMsNEJBQTRCLEVBQUUsR0FDcENULFFBQVE7UUFDVixNQUFNRSxlQUFlTyw2QkFBNkJiO1FBRWxELE9BQUEsV0FBQSxHQUFPLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ0YsV0FBQUE7WUFBVUUsUUFBUU07WUFBY1AsY0FBY007O0lBQ3hEO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjA2MTMsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXNlZ21lbnQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyBJbnZhcmlhbnRFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaW52YXJpYW50LWVycm9yJ1xuXG5pbXBvcnQgdHlwZSB7IFBhcmFtcyB9IGZyb20gJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcydcblxuLyoqXG4gKiBXaGVuIHRoZSBQYWdlIGlzIGEgY2xpZW50IGNvbXBvbmVudCB3ZSBzZW5kIHRoZSBwYXJhbXMgdG8gdGhpcyBjbGllbnQgd3JhcHBlclxuICogd2hlcmUgdGhleSBhcmUgdHVybmVkIGludG8gZHluYW1pY2FsbHkgdHJhY2tlZCB2YWx1ZXMgYmVmb3JlIGJlaW5nIHBhc3NlZCB0byB0aGUgYWN0dWFsIFNlZ21lbnQgY29tcG9uZW50LlxuICpcbiAqIGFkZGl0aW9uYWxseSB3ZSBtYXkgc2VuZCBhIHByb21pc2UgcmVwcmVzZW50aW5nIHBhcmFtcy4gV2UgZG9uJ3QgZXZlciB1c2UgdGhpcyBwYXNzZWRcbiAqIHZhbHVlIGJ1dCBpdCBjYW4gYmUgbmVjZXNzYXJ5IGZvciB0aGUgc2VuZGVyIHRvIHNlbmQgYSBQcm9taXNlIHRoYXQgZG9lc24ndCByZXNvbHZlIGluIGNlcnRhaW4gc2l0dWF0aW9uc1xuICogc3VjaCBhcyB3aGVuIGR5bmFtaWNJTyBpcyBlbmFibGVkLiBJdCBpcyB1cCB0byB0aGUgY2FsbGVyIHRvIGRlY2lkZSBpZiB0aGUgcHJvbWlzZXMgYXJlIG5lZWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENsaWVudFNlZ21lbnRSb290KHtcbiAgQ29tcG9uZW50LFxuICBzbG90cyxcbiAgcGFyYW1zLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHByb21pc2UsXG59OiB7XG4gIENvbXBvbmVudDogUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+XG4gIHNsb3RzOiB7IFtrZXk6IHN0cmluZ106IFJlYWN0LlJlYWN0Tm9kZSB9XG4gIHBhcmFtczogUGFyYW1zXG4gIHByb21pc2U/OiBQcm9taXNlPGFueT5cbn0pIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgeyB3b3JrQXN5bmNTdG9yYWdlIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJylcblxuICAgIGxldCBjbGllbnRQYXJhbXM6IFByb21pc2U8UGFyYW1zPlxuICAgIC8vIFdlIGFyZSBnb2luZyB0byBpbnN0cnVtZW50IHRoZSBzZWFyY2hQYXJhbXMgcHJvcCB3aXRoIHRyYWNraW5nIGZvciB0aGVcbiAgICAvLyBhcHByb3ByaWF0ZSBjb250ZXh0LiBXZSB3cmFwIGRpZmZlcmVudGx5IGluIHByZXJlbmRlcmluZyB2cyByZW5kZXJpbmdcbiAgICBjb25zdCBzdG9yZSA9IHdvcmtBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICAgIGlmICghc3RvcmUpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhcmlhbnRFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIHdvcmtTdG9yZSB0byBleGlzdCB3aGVuIGhhbmRsaW5nIHBhcmFtcyBpbiBhIGNsaWVudCBzZWdtZW50IHN1Y2ggYXMgYSBMYXlvdXQgb3IgVGVtcGxhdGUuJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHsgY3JlYXRlUGFyYW1zRnJvbUNsaWVudCB9ID1cbiAgICAgIHJlcXVpcmUoJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcycpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcycpXG4gICAgY2xpZW50UGFyYW1zID0gY3JlYXRlUGFyYW1zRnJvbUNsaWVudChwYXJhbXMsIHN0b3JlKVxuXG4gICAgcmV0dXJuIDxDb21wb25lbnQgey4uLnNsb3RzfSBwYXJhbXM9e2NsaWVudFBhcmFtc30gLz5cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7IGNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQgfSA9XG4gICAgICByZXF1aXJlKCcuLi9yZXF1ZXN0L3BhcmFtcy5icm93c2VyJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vcmVxdWVzdC9wYXJhbXMuYnJvd3NlcicpXG4gICAgY29uc3QgY2xpZW50UGFyYW1zID0gY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudChwYXJhbXMpXG4gICAgcmV0dXJuIDxDb21wb25lbnQgey4uLnNsb3RzfSBwYXJhbXM9e2NsaWVudFBhcmFtc30gLz5cbiAgfVxufVxuIl0sIm5hbWVzIjpbIkNsaWVudFNlZ21lbnRSb290IiwiQ29tcG9uZW50Iiwic2xvdHMiLCJwYXJhbXMiLCJwcm9taXNlIiwid2luZG93Iiwid29ya0FzeW5jU3RvcmFnZSIsInJlcXVpcmUiLCJjbGllbnRQYXJhbXMiLCJzdG9yZSIsImdldFN0b3JlIiwiSW52YXJpYW50RXJyb3IiLCJjcmVhdGVQYXJhbXNGcm9tQ2xpZW50IiwiY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudCJdLCJtYXBwaW5ncyI6Ijs7OytCQWNnQkEscUJBQUFBOzs7ZUFBQUE7Ozs7Z0NBWmU7QUFZeEIsU0FBU0Esa0JBQWtCLEtBV2pDO0lBWGlDLElBQUEsRUFDaENDLFNBQVMsRUFDVEMsS0FBSyxFQUNMQyxNQUFNLEVBRU5DLEFBREEsT0FDTyxFQU1SLEdBWGlDLGlEQUk2QjtJQVE3RCxJQUFJLE9BQU9DLFdBQVcsYUFBYTtRQUNqQyxNQUFNLEVBQUVDLGdCQUFnQixFQUFFLEdBQ3hCQyxRQUFRO1FBRVYsSUFBSUM7UUFDSix5RUFBeUU7UUFDekUsd0VBQXdFO1FBQ3hFLE1BQU1DLFFBQVFILGlCQUFpQkksUUFBUTtRQUN2QyxJQUFJLENBQUNELE9BQU87WUFDVixNQUFNLE9BQUEsY0FFTCxDQUZLLElBQUlFLGdCQUFBQSxjQUFjLENBQ3RCLHVHQURJLHFCQUFBO3VCQUFBOzRCQUFBOzhCQUFBO1lBRU47UUFDRjtRQUVBLE1BQU0sRUFBRUMsc0JBQXNCLEVBQUUsR0FDOUJMLFFBQVE7UUFDVkMsZUFBZUksdUJBQXVCVCxRQUFRTTtRQUU5QyxPQUFBLFdBQUEsR0FBTyxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNSLFdBQUFBO1lBQVcsR0FBR0MsS0FBSztZQUFFQyxRQUFRSzs7SUFDdkMsT0FBTztRQUNMLE1BQU0sRUFBRUssNEJBQTRCLEVBQUUsR0FDcENOLFFBQVE7UUFDVixNQUFNQyxlQUFlSyw2QkFBNkJWO1FBQ2xELE9BQUEsV0FBQSxHQUFPLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ0YsV0FBQUE7WUFBVyxHQUFHQyxLQUFLO1lBQUVDLFFBQVFLOztJQUN2QztBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDIwNjY3LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL2xpYi9tZXRhZGF0YS9nZW5lcmF0ZS9pY29uLW1hcmsudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG4vLyBUaGlzIGlzIGEgY2xpZW50IGNvbXBvbmVudCB0aGF0IG9ubHkgcmVuZGVycyBkdXJpbmcgU1NSLFxuLy8gYnV0IHdpbGwgYmUgcmVwbGFjZWQgZHVyaW5nIHN0cmVhbWluZyB3aXRoIGFuIGljb24gaW5zZXJ0aW9uIHNjcmlwdCB0YWcuXG4vLyBXZSBkb24ndCB3YW50IGl0IHRvIGJlIHByZXNlbnRlZCBhbnl3aGVyZSBzbyBpdCdzIG9ubHkgdmlzaWJsZSBkdXJpbmcgc3RyZWFtaW5nLFxuLy8gcmlnaHQgYWZ0ZXIgdGhlIGljb24gbWV0YSB0YWdzIHNvIHRoYXQgYnJvd3NlciBjYW4gcGljayBpdCB1cCBhcyBzb29uIGFzIGl0J3MgcmVuZGVyZWQuXG4vLyBOb3RlOiB3ZSBkb24ndCBqdXN0IGVtaXQgdGhlIHNjcmlwdCBoZXJlIGJlY2F1c2Ugd2Ugb25seSBuZWVkIHRoZSBzY3JpcHQgaWYgaXQncyBub3QgaW4gdGhlIGhlYWQsXG4vLyBhbmQgd2UgbmVlZCBpdCB0byBiZSBob2lzdGFibGUgYWxvbmdzaWRlIHRoZSBvdGhlciBtZXRhZGF0YSBidXQgc3luYyBzY3JpcHRzIGFyZSBub3QgaG9pc3RhYmxlLlxuZXhwb3J0IGNvbnN0IEljb25NYXJrID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHJldHVybiA8bWV0YSBuYW1lPVwiwqtueHQtaWNvbsK7XCIgLz5cbn1cbiJdLCJuYW1lcyI6WyJJY29uTWFyayIsIndpbmRvdyIsIm1ldGEiLCJuYW1lIl0sIm1hcHBpbmdzIjoiOzs7K0JBUWFBLFlBQUFBOzs7ZUFBQUE7Ozs7QUFBTixNQUFNQSxXQUFXO0lBQ3RCLElBQUksT0FBT0MsV0FBVyxhQUFhO1FBQ2pDLE9BQU87SUFDVDtJQUNBLE9BQUEsV0FBQSxHQUFPLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ0MsUUFBQUE7UUFBS0MsTUFBSzs7QUFDcEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjA2OTEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvY2xpZW50L2NvbXBvbmVudHMvbWV0YWRhdGEvYXN5bmMtbWV0YWRhdGEudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyBTdXNwZW5zZSwgdXNlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgdHlwZSB7IFN0cmVhbWluZ01ldGFkYXRhUmVzb2x2ZWRTdGF0ZSB9IGZyb20gJy4vdHlwZXMnXG5cbmZ1bmN0aW9uIE1ldGFkYXRhT3V0bGV0KHtcbiAgcHJvbWlzZSxcbn06IHtcbiAgcHJvbWlzZTogUHJvbWlzZTxTdHJlYW1pbmdNZXRhZGF0YVJlc29sdmVkU3RhdGU+XG59KSB7XG4gIGNvbnN0IHsgZXJyb3IsIGRpZ2VzdCB9ID0gdXNlKHByb21pc2UpXG4gIGlmIChlcnJvcikge1xuICAgIGlmIChkaWdlc3QpIHtcbiAgICAgIC8vIFRoZSBlcnJvciB3aWxsIGxvc2UgaXRzIG9yaWdpbmFsIGRpZ2VzdCBhZnRlciBwYXNzaW5nIGZyb20gc2VydmVyIGxheWVyIHRvIGNsaWVudCBsYXllcu+8m1xuICAgICAgLy8gV2UgcmVjb3ZlciB0aGUgZGlnZXN0IHByb3BlcnR5IGhlcmUgdG8gb3ZlcnJpZGUgdGhlIFJlYWN0IGNyZWF0ZWQgb25lIGlmIG9yaWdpbmFsIGRpZ2VzdCBleGlzdHMuXG4gICAgICA7KGVycm9yIGFzIGFueSkuZGlnZXN0ID0gZGlnZXN0XG4gICAgfVxuICAgIHRocm93IGVycm9yXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEFzeW5jTWV0YWRhdGFPdXRsZXQoe1xuICBwcm9taXNlLFxufToge1xuICBwcm9taXNlOiBQcm9taXNlPFN0cmVhbWluZ01ldGFkYXRhUmVzb2x2ZWRTdGF0ZT5cbn0pIHtcbiAgcmV0dXJuIChcbiAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e251bGx9PlxuICAgICAgPE1ldGFkYXRhT3V0bGV0IHByb21pc2U9e3Byb21pc2V9IC8+XG4gICAgPC9TdXNwZW5zZT5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIkFzeW5jTWV0YWRhdGFPdXRsZXQiLCJNZXRhZGF0YU91dGxldCIsInByb21pc2UiLCJlcnJvciIsImRpZ2VzdCIsInVzZSIsIlN1c3BlbnNlIiwiZmFsbGJhY2siXSwibWFwcGluZ3MiOiI7OzsrQkFzQmdCQSx1QkFBQUE7OztlQUFBQTs7Ozt1QkFwQmM7QUFHOUIsU0FBU0MsZUFBZSxLQUl2QjtJQUp1QixJQUFBLEVBQ3RCQyxPQUFPLEVBR1IsR0FKdUI7SUFLdEIsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxPQUFBQSxHQUFHLEVBQUNIO0lBQzlCLElBQUlDLE9BQU87UUFDVCxJQUFJQyxRQUFRO1lBQ1YsMkZBQTJGO1lBQzNGLG1HQUFtRzs7WUFDakdELE1BQWNDLE1BQU0sR0FBR0E7UUFDM0I7UUFDQSxNQUFNRDtJQUNSO0lBQ0EsT0FBTztBQUNUO0FBRU8sU0FBU0gsb0JBQW9CLEtBSW5DO0lBSm1DLElBQUEsRUFDbENFLE9BQU8sRUFHUixHQUptQztJQUtsQyxPQUFBLFdBQUEsR0FDRSxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNJLE9BQUFBLFFBQVEsRUFBQTtRQUFDQyxVQUFVO2tCQUNsQixXQUFBLEdBQUEsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDTixnQkFBQUE7WUFBZUMsU0FBU0E7OztBQUcvQiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyMDczOCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9jbGllbnQvY29tcG9uZW50cy9tZXRhZGF0YS9tZXRhZGF0YS1ib3VuZGFyeS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7XG4gIE1FVEFEQVRBX0JPVU5EQVJZX05BTUUsXG4gIFZJRVdQT1JUX0JPVU5EQVJZX05BTUUsXG4gIE9VVExFVF9CT1VOREFSWV9OQU1FLFxufSBmcm9tICcuLi8uLi8uLi9saWIvbWV0YWRhdGEvbWV0YWRhdGEtY29uc3RhbnRzJ1xuXG4vLyBXZSB1c2UgYSBuYW1lc3BhY2Ugb2JqZWN0IHRvIGFsbG93IHVzIHRvIHJlY292ZXIgdGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uXG4vLyBhdCBydW50aW1lIGV2ZW4gd2hlbiBwcm9kdWN0aW9uIGJ1bmRsaW5nL21pbmlmaWNhdGlvbiBpcyB1c2VkLlxuY29uc3QgTmFtZVNwYWNlID0ge1xuICBbTUVUQURBVEFfQk9VTkRBUllfTkFNRV06IGZ1bmN0aW9uICh7XG4gICAgY2hpbGRyZW4sXG4gIH06IHtcbiAgICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG4gIH0pIHtcbiAgICByZXR1cm4gY2hpbGRyZW5cbiAgfSxcbiAgW1ZJRVdQT1JUX0JPVU5EQVJZX05BTUVdOiBmdW5jdGlvbiAoe1xuICAgIGNoaWxkcmVuLFxuICB9OiB7XG4gICAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxuICB9KSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuXG4gIH0sXG4gIFtPVVRMRVRfQk9VTkRBUllfTkFNRV06IGZ1bmN0aW9uICh7XG4gICAgY2hpbGRyZW4sXG4gIH06IHtcbiAgICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG4gIH0pIHtcbiAgICByZXR1cm4gY2hpbGRyZW5cbiAgfSxcbn1cblxuZXhwb3J0IGNvbnN0IE1ldGFkYXRhQm91bmRhcnkgPVxuICAvLyBXZSB1c2Ugc2xpY2UoMCkgdG8gdHJpY2sgdGhlIGJ1bmRsZXIgaW50byBub3QgaW5saW5pbmcvbWluaWZ5aW5nIHRoZSBmdW5jdGlvblxuICAvLyBzbyBpdCByZXRhaW5zIHRoZSBuYW1lIGluZmVycmVkIGZyb20gdGhlIG5hbWVzcGFjZSBvYmplY3RcbiAgTmFtZVNwYWNlW01FVEFEQVRBX0JPVU5EQVJZX05BTUUuc2xpY2UoMCkgYXMgdHlwZW9mIE1FVEFEQVRBX0JPVU5EQVJZX05BTUVdXG5cbmV4cG9ydCBjb25zdCBWaWV3cG9ydEJvdW5kYXJ5ID1cbiAgLy8gV2UgdXNlIHNsaWNlKDApIHRvIHRyaWNrIHRoZSBidW5kbGVyIGludG8gbm90IGlubGluaW5nL21pbmlmeWluZyB0aGUgZnVuY3Rpb25cbiAgLy8gc28gaXQgcmV0YWlucyB0aGUgbmFtZSBpbmZlcnJlZCBmcm9tIHRoZSBuYW1lc3BhY2Ugb2JqZWN0XG4gIE5hbWVTcGFjZVtWSUVXUE9SVF9CT1VOREFSWV9OQU1FLnNsaWNlKDApIGFzIHR5cGVvZiBWSUVXUE9SVF9CT1VOREFSWV9OQU1FXVxuXG5leHBvcnQgY29uc3QgT3V0bGV0Qm91bmRhcnkgPVxuICAvLyBXZSB1c2Ugc2xpY2UoMCkgdG8gdHJpY2sgdGhlIGJ1bmRsZXIgaW50byBub3QgaW5saW5pbmcvbWluaWZ5aW5nIHRoZSBmdW5jdGlvblxuICAvLyBzbyBpdCByZXRhaW5zIHRoZSBuYW1lIGluZmVycmVkIGZyb20gdGhlIG5hbWVzcGFjZSBvYmplY3RcbiAgTmFtZVNwYWNlW09VVExFVF9CT1VOREFSWV9OQU1FLnNsaWNlKDApIGFzIHR5cGVvZiBPVVRMRVRfQk9VTkRBUllfTkFNRV1cbiJdLCJuYW1lcyI6WyJNZXRhZGF0YUJvdW5kYXJ5IiwiT3V0bGV0Qm91bmRhcnkiLCJWaWV3cG9ydEJvdW5kYXJ5IiwiTmFtZVNwYWNlIiwiTUVUQURBVEFfQk9VTkRBUllfTkFNRSIsImNoaWxkcmVuIiwiVklFV1BPUlRfQk9VTkRBUllfTkFNRSIsIk9VVExFVF9CT1VOREFSWV9OQU1FIiwic2xpY2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztJQWtDYUEsZ0JBQWdCLEVBQUE7ZUFBaEJBOztJQVVBQyxjQUFjLEVBQUE7ZUFBZEE7O0lBTEFDLGdCQUFnQixFQUFBO2VBQWhCQTs7O21DQWpDTjtBQUVQLDRFQUE0RTtBQUM1RSxpRUFBaUU7QUFDakUsTUFBTUMsWUFBWTtJQUNoQixDQUFDQyxtQkFBQUEsc0JBQXNCLENBQUMsRUFBRSxTQUFVLEtBSW5DO1FBSm1DLElBQUEsRUFDbENDLFFBQVEsRUFHVCxHQUptQztRQUtsQyxPQUFPQTtJQUNUO0lBQ0EsQ0FBQ0MsbUJBQUFBLHNCQUFzQixDQUFDLEVBQUUsU0FBVSxLQUluQztRQUptQyxJQUFBLEVBQ2xDRCxRQUFRLEVBR1QsR0FKbUM7UUFLbEMsT0FBT0E7SUFDVDtJQUNBLENBQUNFLG1CQUFBQSxvQkFBb0IsQ0FBQyxFQUFFLFNBQVUsS0FJakM7UUFKaUMsSUFBQSxFQUNoQ0YsUUFBUSxFQUdULEdBSmlDO1FBS2hDLE9BQU9BO0lBQ1Q7QUFDRjtBQUVPLE1BQU1MLG1CQUNYLEFBQ0EsNERBQTRELG9CQURvQjtBQUVoRkcsU0FBUyxDQUFDQyxtQkFBQUEsc0JBQXNCLENBQUNJLEtBQUssQ0FBQyxHQUFvQztBQUV0RSxNQUFNTixtQkFDWCxBQUNBLDREQUE0RCxvQkFEb0I7QUFFaEZDLFNBQVMsQ0FBQ0csbUJBQUFBLHNCQUFzQixDQUFDRSxLQUFLLENBQUMsR0FBb0M7QUFFdEUsTUFBTVAsaUJBQ1gsQUFDQSw0REFBNEQsb0JBRG9CO0FBRWhGRSxTQUFTLENBQUNJLG1CQUFBQSxvQkFBb0IsQ0FBQ0MsS0FBSyxDQUFDLEdBQWtDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX1dCn0=