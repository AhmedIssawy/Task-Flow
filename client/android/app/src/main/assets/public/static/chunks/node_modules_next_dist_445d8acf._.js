(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var _global_process, _global_process1;
module.exports = ((_global_process = ("TURBOPACK ident replacement", globalThis).process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = ("TURBOPACK ident replacement", globalThis).process) == null ? void 0 : _global_process1.env) === 'object' ? ("TURBOPACK ident replacement", globalThis).process : __turbopack_context__.r("[project]/node_modules/next/dist/compiled/process/browser.js [app-client] (ecmascript)"); //# sourceMappingURL=process.js.map
}}),
"[project]/node_modules/next/dist/build/polyfills/polyfill-module.js [app-client] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
"trimStart" in String.prototype || (String.prototype.trimStart = String.prototype.trimLeft), "trimEnd" in String.prototype || (String.prototype.trimEnd = String.prototype.trimRight), "description" in Symbol.prototype || Object.defineProperty(Symbol.prototype, "description", {
    configurable: !0,
    get: function() {
        var t = /\((.*)\)/.exec(this.toString());
        return t ? t[1] : void 0;
    }
}), Array.prototype.flat || (Array.prototype.flat = function(t, r) {
    return r = this.concat.apply([], this), t > 1 && r.some(Array.isArray) ? r.flat(t - 1) : r;
}, Array.prototype.flatMap = function(t, r) {
    return this.map(t, r).flat();
}), Promise.prototype.finally || (Promise.prototype.finally = function(t) {
    if ("function" != typeof t) return this.then(t, t);
    var r = this.constructor || Promise;
    return this.then(function(n) {
        return r.resolve(t()).then(function() {
            return n;
        });
    }, function(n) {
        return r.resolve(t()).then(function() {
            throw n;
        });
    });
}), Object.fromEntries || (Object.fromEntries = function(t) {
    return Array.from(t).reduce(function(t, r) {
        return t[r[0]] = r[1], t;
    }, {});
}), Array.prototype.at || (Array.prototype.at = function(t) {
    var r = Math.trunc(t) || 0;
    if (r < 0 && (r += this.length), !(r < 0 || r >= this.length)) return this[r];
}), Object.hasOwn || (Object.hasOwn = function(t, r) {
    if (null == t) throw new TypeError("Cannot convert undefined or null to object");
    return Object.prototype.hasOwnProperty.call(Object(t), r);
}), "canParse" in URL || (URL.canParse = function(t, r) {
    try {
        return !!new URL(t, r);
    } catch (t) {
        return !1;
    }
});
}}),
"[project]/node_modules/next/dist/shared/lib/is-plain-object.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getObjectClassLabel: null,
    isPlainObject: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getObjectClassLabel: function() {
        return getObjectClassLabel;
    },
    isPlainObject: function() {
        return isPlainObject;
    }
});
function getObjectClassLabel(value) {
    return Object.prototype.toString.call(value);
}
function isPlainObject(value) {
    if (getObjectClassLabel(value) !== '[object Object]') {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    /**
   * this used to be previously:
   *
   * `return prototype === null || prototype === Object.prototype`
   *
   * but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.
   *
   * It was changed to the current implementation since it's resilient to serialization.
   */ return prototype === null || prototype.hasOwnProperty('isPrototypeOf');
} //# sourceMappingURL=is-plain-object.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// This has to be a shared module which is shared between client component error boundary and dynamic component
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    BailoutToCSRError: null,
    isBailoutToCSRError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    BailoutToCSRError: function() {
        return BailoutToCSRError;
    },
    isBailoutToCSRError: function() {
        return isBailoutToCSRError;
    }
});
const BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING';
class BailoutToCSRError extends Error {
    constructor(reason){
        super("Bail out to client-side rendering: " + reason), this.reason = reason, this.digest = BAILOUT_TO_CSR;
    }
}
function isBailoutToCSRError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err)) {
        return false;
    }
    return err.digest === BAILOUT_TO_CSR;
} //# sourceMappingURL=bailout-to-csr.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/error-source.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    decorateServerError: null,
    getErrorSource: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    decorateServerError: function() {
        return decorateServerError;
    },
    getErrorSource: function() {
        return getErrorSource;
    }
});
const symbolError = Symbol.for('NextjsError');
function getErrorSource(error) {
    return error[symbolError] || null;
}
function decorateServerError(error, type) {
    Object.defineProperty(error, symbolError, {
        writable: false,
        enumerable: false,
        configurable: false,
        value: type
    });
} //# sourceMappingURL=error-source.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "HeadManagerContext", {
    enumerable: true,
    get: function() {
        return HeadManagerContext;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const HeadManagerContext = _react.default.createContext({});
if ("TURBOPACK compile-time truthy", 1) {
    HeadManagerContext.displayName = 'HeadManagerContext';
} //# sourceMappingURL=head-manager-context.shared-runtime.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    PathParamsContext: null,
    PathnameContext: null,
    SearchParamsContext: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    PathParamsContext: function() {
        return PathParamsContext;
    },
    PathnameContext: function() {
        return PathnameContext;
    },
    SearchParamsContext: function() {
        return SearchParamsContext;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
const SearchParamsContext = (0, _react.createContext)(null);
const PathnameContext = (0, _react.createContext)(null);
const PathParamsContext = (0, _react.createContext)(null);
if ("TURBOPACK compile-time truthy", 1) {
    SearchParamsContext.displayName = 'SearchParamsContext';
    PathnameContext.displayName = 'PathnameContext';
    PathParamsContext.displayName = 'PathParamsContext';
} //# sourceMappingURL=hooks-client-context.shared-runtime.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/is-thenable.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * Check to see if a value is Thenable.
 *
 * @param promise the maybe-thenable value
 * @returns true if the value is thenable
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isThenable", {
    enumerable: true,
    get: function() {
        return isThenable;
    }
});
function isThenable(promise) {
    return promise !== null && typeof promise === 'object' && 'then' in promise && typeof promise.then === 'function';
} //# sourceMappingURL=is-thenable.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DEFAULT_SEGMENT_KEY: null,
    PAGE_SEGMENT_KEY: null,
    addSearchParamsIfPageSegment: null,
    isGroupSegment: null,
    isParallelRouteSegment: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DEFAULT_SEGMENT_KEY: function() {
        return DEFAULT_SEGMENT_KEY;
    },
    PAGE_SEGMENT_KEY: function() {
        return PAGE_SEGMENT_KEY;
    },
    addSearchParamsIfPageSegment: function() {
        return addSearchParamsIfPageSegment;
    },
    isGroupSegment: function() {
        return isGroupSegment;
    },
    isParallelRouteSegment: function() {
        return isParallelRouteSegment;
    }
});
function isGroupSegment(segment) {
    // Use array[0] for performant purpose
    return segment[0] === '(' && segment.endsWith(')');
}
function isParallelRouteSegment(segment) {
    return segment.startsWith('@') && segment !== '@children';
}
function addSearchParamsIfPageSegment(segment, searchParams) {
    const isPageSegment = segment.includes(PAGE_SEGMENT_KEY);
    if (isPageSegment) {
        const stringifiedQuery = JSON.stringify(searchParams);
        return stringifiedQuery !== '{}' ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery : PAGE_SEGMENT_KEY;
    }
    return segment;
}
const PAGE_SEGMENT_KEY = '__PAGE__';
const DEFAULT_SEGMENT_KEY = '__DEFAULT__'; //# sourceMappingURL=segment.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/hash.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// http://www.cse.yorku.ca/~oz/hash.html
// More specifically, 32-bit hash via djbxor
// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)
// This is due to number type differences between rust for turbopack to js number types,
// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching
// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation
// as can gaurantee determinstic output from 32bit hash.
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    djb2Hash: null,
    hexHash: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    djb2Hash: function() {
        return djb2Hash;
    },
    hexHash: function() {
        return hexHash;
    }
});
function djb2Hash(str) {
    let hash = 5381;
    for(let i = 0; i < str.length; i++){
        const char = str.charCodeAt(i);
        hash = (hash << 5) + hash + char & 0xffffffff;
    }
    return hash >>> 0;
}
function hexHash(str) {
    return djb2Hash(str).toString(36).slice(0, 5);
} //# sourceMappingURL=hash.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/cache-busting-search-param.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "computeCacheBustingSearchParam", {
    enumerable: true,
    get: function() {
        return computeCacheBustingSearchParam;
    }
});
const _hash = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/hash.js [app-client] (ecmascript)");
function computeCacheBustingSearchParam(prefetchHeader, segmentPrefetchHeader, stateTreeHeader, nextUrlHeader) {
    if (prefetchHeader === undefined && segmentPrefetchHeader === undefined && stateTreeHeader === undefined && nextUrlHeader === undefined) {
        return '';
    }
    return (0, _hash.hexHash)([
        prefetchHeader || '0',
        segmentPrefetchHeader || '0',
        stateTreeHeader || '0',
        nextUrlHeader || '0'
    ].join(','));
} //# sourceMappingURL=cache-busting-search-param.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * For a given page path, this function ensures that there is a leading slash.
 * If there is not a leading slash, one is added, otherwise it is noop.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ensureLeadingSlash", {
    enumerable: true,
    get: function() {
        return ensureLeadingSlash;
    }
});
function ensureLeadingSlash(path) {
    return path.startsWith('/') ? path : "/" + path;
} //# sourceMappingURL=ensure-leading-slash.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    normalizeAppPath: null,
    normalizeRscURL: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    normalizeAppPath: function() {
        return normalizeAppPath;
    },
    normalizeRscURL: function() {
        return normalizeRscURL;
    }
});
const _ensureleadingslash = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js [app-client] (ecmascript)");
const _segment = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)");
function normalizeAppPath(route) {
    return (0, _ensureleadingslash.ensureLeadingSlash)(route.split('/').reduce((pathname, segment, index, segments)=>{
        // Empty segments are ignored.
        if (!segment) {
            return pathname;
        }
        // Groups are ignored.
        if ((0, _segment.isGroupSegment)(segment)) {
            return pathname;
        }
        // Parallel segments are ignored.
        if (segment[0] === '@') {
            return pathname;
        }
        // The last segment (if it's a leaf) should be ignored.
        if ((segment === 'page' || segment === 'route') && index === segments.length - 1) {
            return pathname;
        }
        return pathname + "/" + segment;
    }, ''));
}
function normalizeRscURL(url) {
    return url.replace(/\.rsc($|\?)/, '$1');
} //# sourceMappingURL=app-paths.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    INTERCEPTION_ROUTE_MARKERS: null,
    extractInterceptionRouteInformation: null,
    isInterceptionRouteAppPath: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    INTERCEPTION_ROUTE_MARKERS: function() {
        return INTERCEPTION_ROUTE_MARKERS;
    },
    extractInterceptionRouteInformation: function() {
        return extractInterceptionRouteInformation;
    },
    isInterceptionRouteAppPath: function() {
        return isInterceptionRouteAppPath;
    }
});
const _apppaths = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/app-paths.js [app-client] (ecmascript)");
const INTERCEPTION_ROUTE_MARKERS = [
    '(..)(..)',
    '(.)',
    '(..)',
    '(...)'
];
function isInterceptionRouteAppPath(path) {
    // TODO-APP: add more serious validation
    return path.split('/').find((segment)=>INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m))) !== undefined;
}
function extractInterceptionRouteInformation(path) {
    let interceptingRoute, marker, interceptedRoute;
    for (const segment of path.split('/')){
        marker = INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));
        if (marker) {
            ;
            [interceptingRoute, interceptedRoute] = path.split(marker, 2);
            break;
        }
    }
    if (!interceptingRoute || !marker || !interceptedRoute) {
        throw Object.defineProperty(new Error("Invalid interception route: " + path + ". Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>"), "__NEXT_ERROR_CODE", {
            value: "E269",
            enumerable: false,
            configurable: true
        });
    }
    interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed
    ;
    switch(marker){
        case '(.)':
            // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route
            if (interceptingRoute === '/') {
                interceptedRoute = "/" + interceptedRoute;
            } else {
                interceptedRoute = interceptingRoute + '/' + interceptedRoute;
            }
            break;
        case '(..)':
            // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route
            if (interceptingRoute === '/') {
                throw Object.defineProperty(new Error("Invalid interception route: " + path + ". Cannot use (..) marker at the root level, use (.) instead."), "__NEXT_ERROR_CODE", {
                    value: "E207",
                    enumerable: false,
                    configurable: true
                });
            }
            interceptedRoute = interceptingRoute.split('/').slice(0, -1).concat(interceptedRoute).join('/');
            break;
        case '(...)':
            // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route
            interceptedRoute = '/' + interceptedRoute;
            break;
        case '(..)(..)':
            // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route
            const splitInterceptingRoute = interceptingRoute.split('/');
            if (splitInterceptingRoute.length <= 2) {
                throw Object.defineProperty(new Error("Invalid interception route: " + path + ". Cannot use (..)(..) marker at the root level or one level up."), "__NEXT_ERROR_CODE", {
                    value: "E486",
                    enumerable: false,
                    configurable: true
                });
            }
            interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join('/');
            break;
        default:
            throw Object.defineProperty(new Error('Invariant: unexpected marker'), "__NEXT_ERROR_CODE", {
                value: "E112",
                enumerable: false,
                configurable: true
            });
    }
    return {
        interceptingRoute,
        interceptedRoute
    };
} //# sourceMappingURL=interception-routes.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    AppRouterContext: null,
    GlobalLayoutRouterContext: null,
    LayoutRouterContext: null,
    MissingSlotContext: null,
    TemplateContext: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AppRouterContext: function() {
        return AppRouterContext;
    },
    GlobalLayoutRouterContext: function() {
        return GlobalLayoutRouterContext;
    },
    LayoutRouterContext: function() {
        return LayoutRouterContext;
    },
    MissingSlotContext: function() {
        return MissingSlotContext;
    },
    TemplateContext: function() {
        return TemplateContext;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const AppRouterContext = _react.default.createContext(null);
const LayoutRouterContext = _react.default.createContext(null);
const GlobalLayoutRouterContext = _react.default.createContext(null);
const TemplateContext = _react.default.createContext(null);
if ("TURBOPACK compile-time truthy", 1) {
    AppRouterContext.displayName = 'AppRouterContext';
    LayoutRouterContext.displayName = 'LayoutRouterContext';
    GlobalLayoutRouterContext.displayName = 'GlobalLayoutRouterContext';
    TemplateContext.displayName = 'TemplateContext';
}
const MissingSlotContext = _react.default.createContext(new Set()); //# sourceMappingURL=app-router-context.shared-runtime.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/html-bots.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// This regex contains the bots that we need to do a blocking render for and can't safely stream the response
// due to how they parse the DOM. For example, they might explicitly check for metadata in the `head` tag, so we can't stream metadata tags after the `head` was sent.
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "HTML_LIMITED_BOT_UA_RE", {
    enumerable: true,
    get: function() {
        return HTML_LIMITED_BOT_UA_RE;
    }
});
const HTML_LIMITED_BOT_UA_RE = /Mediapartners-Google|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti/i; //# sourceMappingURL=html-bots.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    HTML_LIMITED_BOT_UA_RE: null,
    HTML_LIMITED_BOT_UA_RE_STRING: null,
    getBotType: null,
    isBot: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    HTML_LIMITED_BOT_UA_RE: function() {
        return _htmlbots.HTML_LIMITED_BOT_UA_RE;
    },
    HTML_LIMITED_BOT_UA_RE_STRING: function() {
        return HTML_LIMITED_BOT_UA_RE_STRING;
    },
    getBotType: function() {
        return getBotType;
    },
    isBot: function() {
        return isBot;
    }
});
const _htmlbots = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/html-bots.js [app-client] (ecmascript)");
// Bot crawler that will spin up a headless browser and execute JS.
// By default, only googlebots are considered as DOM bots. Blow is where the regex is computed from:
// x-ref: https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers
const HEADLESS_BROWSER_BOT_UA_RE = /google/i;
const HTML_LIMITED_BOT_UA_RE_STRING = _htmlbots.HTML_LIMITED_BOT_UA_RE.source;
function isDomBotUA(userAgent) {
    return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent);
}
function isHtmlLimitedBotUA(userAgent) {
    return _htmlbots.HTML_LIMITED_BOT_UA_RE.test(userAgent);
}
function isBot(userAgent) {
    return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent);
}
function getBotType(userAgent) {
    if (isDomBotUA(userAgent)) {
        return 'dom';
    }
    if (isHtmlLimitedBotUA(userAgent)) {
        return 'html';
    }
    return undefined;
} //# sourceMappingURL=is-bot.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * Given a path this function will find the pathname, query and hash and return
 * them. This is useful to parse full paths on the client side.
 * @param path A path to parse e.g. /foo/bar?id=1#hash
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "parsePath", {
    enumerable: true,
    get: function() {
        return parsePath;
    }
});
function parsePath(path) {
    const hashIndex = path.indexOf('#');
    const queryIndex = path.indexOf('?');
    const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);
    if (hasQuery || hashIndex > -1) {
        return {
            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),
            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : '',
            hash: hashIndex > -1 ? path.slice(hashIndex) : ''
        };
    }
    return {
        pathname: path,
        query: '',
        hash: ''
    };
} //# sourceMappingURL=parse-path.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "addPathPrefix", {
    enumerable: true,
    get: function() {
        return addPathPrefix;
    }
});
const _parsepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-client] (ecmascript)");
function addPathPrefix(path, prefix) {
    if (!path.startsWith('/') || !prefix) {
        return path;
    }
    const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
    return "" + prefix + pathname + query + hash;
} //# sourceMappingURL=add-path-prefix.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * Removes the trailing slash for a given route or page path. Preserves the
 * root page. Examples:
 *   - `/foo/bar/` -> `/foo/bar`
 *   - `/foo/bar` -> `/foo/bar`
 *   - `/` -> `/`
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "removeTrailingSlash", {
    enumerable: true,
    get: function() {
        return removeTrailingSlash;
    }
});
function removeTrailingSlash(route) {
    return route.replace(/\/$/, '') || '/';
} //# sourceMappingURL=remove-trailing-slash.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/server-inserted-html.shared-runtime.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ServerInsertedHTMLContext: null,
    useServerInsertedHTML: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ServerInsertedHTMLContext: function() {
        return ServerInsertedHTMLContext;
    },
    useServerInsertedHTML: function() {
        return useServerInsertedHTML;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const ServerInsertedHTMLContext = /*#__PURE__*/ _react.default.createContext(null);
function useServerInsertedHTML(callback) {
    const addInsertedServerHTMLCallback = (0, _react.useContext)(ServerInsertedHTMLContext);
    // Should have no effects on client where there's no flush effects provider
    if (addInsertedServerHTMLCallback) {
        addInsertedServerHTMLCallback(callback);
    }
} //# sourceMappingURL=server-inserted-html.shared-runtime.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "pathHasPrefix", {
    enumerable: true,
    get: function() {
        return pathHasPrefix;
    }
});
const _parsepath = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-client] (ecmascript)");
function pathHasPrefix(path, prefix) {
    if (typeof path !== 'string') {
        return false;
    }
    const { pathname } = (0, _parsepath.parsePath)(path);
    return pathname === prefix || pathname.startsWith(prefix + '/');
} //# sourceMappingURL=path-has-prefix.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "warnOnce", {
    enumerable: true,
    get: function() {
        return warnOnce;
    }
});
let warnOnce = (_)=>{};
if ("TURBOPACK compile-time truthy", 1) {
    const warnings = new Set();
    warnOnce = (msg)=>{
        if (!warnings.has(msg)) {
            console.warn(msg);
        }
        warnings.add(msg);
    };
} //# sourceMappingURL=warn-once.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/format-webpack-messages.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
MIT License

Copyright (c) 2015-present, Facebook, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return formatWebpackMessages;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _stripansi = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/strip-ansi/index.js [app-client] (ecmascript)"));
// This file is based on https://github.com/facebook/create-react-app/blob/7b1a32be6ec9f99a6c9a3c66813f3ac09c4736b9/packages/react-dev-utils/formatWebpackMessages.js
// It's been edited to remove chalk and CRA-specific logic
const friendlySyntaxErrorLabel = 'Syntax error:';
const WEBPACK_BREAKING_CHANGE_POLYFILLS = '\n\nBREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.';
function isLikelyASyntaxError(message) {
    return (0, _stripansi.default)(message).includes(friendlySyntaxErrorLabel);
}
let hadMissingSassError = false;
// Cleans up webpack error messages.
function formatMessage(message, verbose, importTraceNote) {
    // TODO: Replace this once webpack 5 is stable
    if (typeof message === 'object' && message.message) {
        const filteredModuleTrace = message.moduleTrace && message.moduleTrace.filter((trace)=>!/next-(middleware|client-pages|route|edge-function)-loader\.js/.test(trace.originName));
        let body = message.message;
        const breakingChangeIndex = body.indexOf(WEBPACK_BREAKING_CHANGE_POLYFILLS);
        if (breakingChangeIndex >= 0) {
            body = body.slice(0, breakingChangeIndex);
        }
        message = (message.moduleName ? (0, _stripansi.default)(message.moduleName) + '\n' : '') + (message.file ? (0, _stripansi.default)(message.file) + '\n' : '') + body + (message.details && verbose ? '\n' + message.details : '') + (filteredModuleTrace && filteredModuleTrace.length ? (importTraceNote || '\n\nImport trace for requested module:') + filteredModuleTrace.map((trace)=>"\n" + trace.moduleName).join('') : '') + (message.stack && verbose ? '\n' + message.stack : '');
    }
    let lines = message.split('\n');
    // Strip Webpack-added headers off errors/warnings
    // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js
    lines = lines.filter((line)=>!/Module [A-z ]+\(from/.test(line));
    // Transform parsing error into syntax error
    // TODO: move this to our ESLint formatter?
    lines = lines.map((line)=>{
        const parsingError = /Line (\d+):(?:(\d+):)?\s*Parsing error: (.+)$/.exec(line);
        if (!parsingError) {
            return line;
        }
        const [, errorLine, errorColumn, errorMessage] = parsingError;
        return friendlySyntaxErrorLabel + " " + errorMessage + " (" + errorLine + ":" + errorColumn + ")";
    });
    message = lines.join('\n');
    // Smoosh syntax errors (commonly found in CSS)
    message = message.replace(/SyntaxError\s+\((\d+):(\d+)\)\s*(.+?)\n/g, "" + friendlySyntaxErrorLabel + " $3 ($1:$2)\n");
    // Clean up export errors
    message = message.replace(/^.*export '(.+?)' was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$2'.");
    message = message.replace(/^.*export 'default' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$2' does not contain a default export (imported as '$1').");
    message = message.replace(/^.*export '(.+?)' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$3' (imported as '$2').");
    lines = message.split('\n');
    // Remove leading newline
    if (lines.length > 2 && lines[1].trim() === '') {
        lines.splice(1, 1);
    }
    // Cleans up verbose "module not found" messages for files and packages.
    if (lines[1] && lines[1].startsWith('Module not found: ')) {
        lines = [
            lines[0],
            lines[1].replace('Error: ', '').replace('Module not found: Cannot find file:', 'Cannot find file:'),
            ...lines.slice(2)
        ];
    }
    // Add helpful message for users trying to use Sass for the first time
    if (lines[1] && lines[1].match(/Cannot find module.+sass/)) {
        // ./file.module.scss (<<loader info>>) => ./file.module.scss
        const firstLine = lines[0].split('!');
        lines[0] = firstLine[firstLine.length - 1];
        lines[1] = "To use Next.js' built-in Sass support, you first need to install `sass`.\n";
        lines[1] += 'Run `npm i sass` or `yarn add sass` inside your workspace.\n';
        lines[1] += '\nLearn more: https://nextjs.org/docs/messages/install-sass';
        // dispose of unhelpful stack trace
        lines = lines.slice(0, 2);
        hadMissingSassError = true;
    } else if (hadMissingSassError && message.match(/(sass-loader|resolve-url-loader: CSS error)/)) {
        // dispose of unhelpful stack trace following missing sass module
        lines = [];
    }
    if (!verbose) {
        message = lines.join('\n');
        // Internal stacks are generally useless so we strip them... with the
        // exception of stacks containing `webpack:` because they're normally
        // from user code generated by Webpack. For more information see
        // https://github.com/facebook/create-react-app/pull/1050
        message = message.replace(/^\s*at\s((?!webpack:).)*:\d+:\d+[\s)]*(\n|$)/gm, '') // at ... ...:x:y
        ;
        message = message.replace(/^\s*at\s<anonymous>(\n|$)/gm, '') // at <anonymous>
        ;
        message = message.replace(/File was processed with these loaders:\n(.+[\\/](next[\\/]dist[\\/].+|@next[\\/]react-refresh-utils[\\/]loader)\.js\n)*You may need an additional loader to handle the result of these loaders.\n/g, '');
        lines = message.split('\n');
    }
    // Remove duplicated newlines
    lines = lines.filter((line, index, arr)=>index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim());
    // Reassemble the message
    message = lines.join('\n');
    return message.trim();
}
function formatWebpackMessages(json, verbose) {
    const formattedErrors = json.errors.map((message)=>{
        const isUnknownNextFontError = message.message.includes('An error occurred in `next/font`.');
        return formatMessage(message, isUnknownNextFontError || verbose);
    });
    const formattedWarnings = json.warnings.map((message)=>{
        return formatMessage(message, verbose);
    });
    // Reorder errors to put the most relevant ones first.
    let reactServerComponentsError = -1;
    for(let i = 0; i < formattedErrors.length; i++){
        const error = formattedErrors[i];
        if (error.includes('ReactServerComponentsError')) {
            reactServerComponentsError = i;
            break;
        }
    }
    // Move the reactServerComponentsError to the top if it exists
    if (reactServerComponentsError !== -1) {
        const error = formattedErrors.splice(reactServerComponentsError, 1);
        formattedErrors.unshift(error[0]);
    }
    const result = {
        ...json,
        errors: formattedErrors,
        warnings: formattedWarnings
    };
    if (!verbose && result.errors.some(isLikelyASyntaxError)) {
        // If there are any syntax errors, show just them.
        result.errors = result.errors.filter(isLikelyASyntaxError);
        result.warnings = [];
    }
    return result;
} //# sourceMappingURL=format-webpack-messages.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/errors/constants.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "MISSING_ROOT_TAGS_ERROR", {
    enumerable: true,
    get: function() {
        return MISSING_ROOT_TAGS_ERROR;
    }
});
const MISSING_ROOT_TAGS_ERROR = 'NEXT_MISSING_ROOT_TAGS';
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=constants.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/normalized-asset-prefix.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "normalizedAssetPrefix", {
    enumerable: true,
    get: function() {
        return normalizedAssetPrefix;
    }
});
function normalizedAssetPrefix(assetPrefix) {
    // remove all leading slashes and trailing slashes
    const escapedAssetPrefix = (assetPrefix == null ? void 0 : assetPrefix.replace(/^\/+|\/+$/g, '')) || false;
    // if an assetPrefix was '/', we return empty string
    // because it could be an unnecessary trailing slash
    if (!escapedAssetPrefix) {
        return '';
    }
    if (URL.canParse(escapedAssetPrefix)) {
        const url = new URL(escapedAssetPrefix).toString();
        return url.endsWith('/') ? url.slice(0, -1) : url;
    }
    // assuming assetPrefix here is a pathname-style,
    // restore the leading slash
    return "/" + escapedAssetPrefix;
} //# sourceMappingURL=normalized-asset-prefix.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/server-reference-info.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    extractInfoFromServerReferenceId: null,
    omitUnusedArgs: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    extractInfoFromServerReferenceId: function() {
        return extractInfoFromServerReferenceId;
    },
    omitUnusedArgs: function() {
        return omitUnusedArgs;
    }
});
function extractInfoFromServerReferenceId(id) {
    const infoByte = parseInt(id.slice(0, 2), 16);
    const typeBit = infoByte >> 7 & 0x1;
    const argMask = infoByte >> 1 & 0x3f;
    const restArgs = infoByte & 0x1;
    const usedArgs = Array(6);
    for(let index = 0; index < 6; index++){
        const bitPosition = 5 - index;
        const bit = argMask >> bitPosition & 0x1;
        usedArgs[index] = bit === 1;
    }
    return {
        type: typeBit === 1 ? 'use-cache' : 'server-action',
        usedArgs: usedArgs,
        hasRestArgs: restArgs === 1
    };
}
function omitUnusedArgs(args, info) {
    const filteredArgs = new Array(args.length);
    for(let index = 0; index < args.length; index++){
        if (index < 6 && info.usedArgs[index] || // This assumes that the server reference info byte has the restArgs bit
        // set to 1 if there are more than 6 args.
        index >= 6 && info.hasRestArgs) {
            filteredArgs[index] = args[index];
        }
    }
    return filteredArgs;
} //# sourceMappingURL=server-reference-info.js.map
}}),
"[project]/node_modules/next/dist/lib/is-error.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    getProperError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    /**
 * Checks whether the given value is a NextError.
 * This can be used to print a more detailed error message with properties like `code` & `digest`.
 */ default: function() {
        return isError;
    },
    getProperError: function() {
        return getProperError;
    }
});
const _isplainobject = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/is-plain-object.js [app-client] (ecmascript)");
function isError(err) {
    return typeof err === 'object' && err !== null && 'name' in err && 'message' in err;
}
function safeStringify(obj) {
    const seen = new WeakSet();
    return JSON.stringify(obj, (_key, value)=>{
        // If value is an object and already seen, replace with "[Circular]"
        if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
                return '[Circular]';
            }
            seen.add(value);
        }
        return value;
    });
}
function getProperError(err) {
    if (isError(err)) {
        return err;
    }
    if ("TURBOPACK compile-time truthy", 1) {
        // provide better error for case where `throw undefined`
        // is called in development
        if (typeof err === 'undefined') {
            return Object.defineProperty(new Error('An undefined error was thrown, ' + 'see here for more info: https://nextjs.org/docs/messages/threw-undefined'), "__NEXT_ERROR_CODE", {
                value: "E98",
                enumerable: false,
                configurable: true
            });
        }
        if (err === null) {
            return Object.defineProperty(new Error('A null error was thrown, ' + 'see here for more info: https://nextjs.org/docs/messages/threw-undefined'), "__NEXT_ERROR_CODE", {
                value: "E336",
                enumerable: false,
                configurable: true
            });
        }
    }
    return Object.defineProperty(new Error((0, _isplainobject.isPlainObject)(err) ? safeStringify(err) : err + ''), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
} //# sourceMappingURL=is-error.js.map
}}),
"[project]/node_modules/next/dist/lib/require-instrumentation-client.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * This module imports the client instrumentation hook from the project root.
 *
 * The `private-next-instrumentation-client` module is automatically aliased to
 * the `instrumentation-client.ts` file in the project root by webpack or turbopack.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
if ("TURBOPACK compile-time truthy", 1) {
    const measureName = 'Client Instrumentation Hook';
    const startTime = performance.now();
    // eslint-disable-next-line @next/internal/typechecked-require -- Not a module.
    module.exports = {};
    const endTime = performance.now();
    const duration = endTime - startTime;
    // Using 16ms threshold as it represents one frame (1000ms/60fps)
    // This helps identify if the instrumentation hook initialization
    // could potentially cause frame drops during development.
    const THRESHOLD = 16;
    if (duration > THRESHOLD) {
        console.log("[".concat(measureName, "] Slow execution detected: ").concat(duration.toFixed(0), "ms (Note: Code download overhead is not included in this measurement)"));
    }
} else //TURBOPACK unreachable
;
 //# sourceMappingURL=require-instrumentation-client.js.map
}}),
"[project]/node_modules/next/dist/lib/metadata/metadata-constants.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    METADATA_BOUNDARY_NAME: null,
    OUTLET_BOUNDARY_NAME: null,
    VIEWPORT_BOUNDARY_NAME: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    METADATA_BOUNDARY_NAME: function() {
        return METADATA_BOUNDARY_NAME;
    },
    OUTLET_BOUNDARY_NAME: function() {
        return OUTLET_BOUNDARY_NAME;
    },
    VIEWPORT_BOUNDARY_NAME: function() {
        return VIEWPORT_BOUNDARY_NAME;
    }
});
const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__';
const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__';
const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'; //# sourceMappingURL=metadata-constants.js.map
}}),
"[project]/node_modules/next/dist/lib/scheduler.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    atLeastOneTask: null,
    scheduleImmediate: null,
    scheduleOnNextTick: null,
    waitAtLeastOneReactRenderTask: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    atLeastOneTask: function() {
        return atLeastOneTask;
    },
    scheduleImmediate: function() {
        return scheduleImmediate;
    },
    scheduleOnNextTick: function() {
        return scheduleOnNextTick;
    },
    waitAtLeastOneReactRenderTask: function() {
        return waitAtLeastOneReactRenderTask;
    }
});
const scheduleOnNextTick = (cb)=>{
    // We use Promise.resolve().then() here so that the operation is scheduled at
    // the end of the promise job queue, we then add it to the next process tick
    // to ensure it's evaluated afterwards.
    //
    // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255
    //
    Promise.resolve().then(()=>{
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        else {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(cb);
        }
    });
};
const scheduleImmediate = (cb)=>{
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        setImmediate(cb);
    }
};
function atLeastOneTask() {
    return new Promise((resolve)=>scheduleImmediate(resolve));
}
function waitAtLeastOneReactRenderTask() {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        return new Promise((r)=>setImmediate(r));
    }
} //# sourceMappingURL=scheduler.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    coerceError: null,
    decorateDevError: null,
    getComponentStack: null,
    getOwnerStack: null,
    setComponentStack: null,
    setOwnerStack: null,
    setOwnerStackIfAvailable: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    coerceError: function() {
        return coerceError;
    },
    decorateDevError: function() {
        return decorateDevError;
    },
    getComponentStack: function() {
        return getComponentStack;
    },
    getOwnerStack: function() {
        return getOwnerStack;
    },
    setComponentStack: function() {
        return setComponentStack;
    },
    setOwnerStack: function() {
        return setOwnerStack;
    },
    setOwnerStackIfAvailable: function() {
        return setOwnerStackIfAvailable;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _iserror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/lib/is-error.js [app-client] (ecmascript)"));
const ownerStacks = new WeakMap();
const componentStacks = new WeakMap();
function getComponentStack(error) {
    return componentStacks.get(error);
}
function setComponentStack(error, stack) {
    componentStacks.set(error, stack);
}
function getOwnerStack(error) {
    return ownerStacks.get(error);
}
function setOwnerStack(error, stack) {
    ownerStacks.set(error, stack);
}
function coerceError(value) {
    return (0, _iserror.default)(value) ? value : Object.defineProperty(new Error('' + value), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
}
function setOwnerStackIfAvailable(error) {
    // React 18 and prod does not have `captureOwnerStack`
    if ('captureOwnerStack' in _react.default) {
        setOwnerStack(error, _react.default.captureOwnerStack());
    }
}
function decorateDevError(thrownValue, errorInfo) {
    const error = coerceError(thrownValue);
    setOwnerStackIfAvailable(error);
    // TODO: change to passing down errorInfo later
    // In development mode, pass along the component stack to the error
    if (errorInfo.componentStack) {
        setComponentStack(error, errorInfo.componentStack);
    }
    return error;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=stitched-error.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/shared/console-error.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
// To distinguish from React error.digest, we use a different symbol here to determine if the error is from console.error or unhandled promise rejection.
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    createConsoleError: null,
    isConsoleError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createConsoleError: function() {
        return createConsoleError;
    },
    isConsoleError: function() {
        return isConsoleError;
    }
});
const digestSym = Symbol.for('next.console.error.digest');
function createConsoleError(message, environmentName) {
    const error = typeof message === 'string' ? Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    }) : message;
    error[digestSym] = 'NEXT_CONSOLE_ERROR';
    if (environmentName && !error.environmentName) {
        error.environmentName = environmentName;
    }
    return error;
}
const isConsoleError = (error)=>{
    return error && error[digestSym] === 'NEXT_CONSOLE_ERROR';
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=console-error.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/terminal-logging-config.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getIsTerminalLoggingEnabled: null,
    getTerminalLoggingConfig: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getIsTerminalLoggingEnabled: function() {
        return getIsTerminalLoggingEnabled;
    },
    getTerminalLoggingConfig: function() {
        return getTerminalLoggingConfig;
    }
});
function getTerminalLoggingConfig() {
    try {
        return JSON.parse(("TURBOPACK compile-time value", "false") || 'false');
    } catch (e) {
        return false;
    }
}
function getIsTerminalLoggingEnabled() {
    const config = getTerminalLoggingConfig();
    return Boolean(config);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=terminal-logging-config.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/shared/forward-logs-shared.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    UNDEFINED_MARKER: null,
    patchConsoleMethod: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    UNDEFINED_MARKER: function() {
        return UNDEFINED_MARKER;
    },
    patchConsoleMethod: function() {
        return patchConsoleMethod;
    }
});
const UNDEFINED_MARKER = '__next_tagged_undefined';
function patchConsoleMethod(methodName, wrapper) {
    const descriptor = Object.getOwnPropertyDescriptor(console, methodName);
    if (descriptor && (descriptor.configurable || descriptor.writable) && typeof descriptor.value === 'function') {
        const originalMethod = descriptor.value;
        const originalName = Object.getOwnPropertyDescriptor(originalMethod, 'name');
        const wrapperMethod = function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            wrapper(methodName, ...args);
            originalMethod.apply(this, args);
        };
        if (originalName) {
            Object.defineProperty(wrapperMethod, 'name', originalName);
        }
        Object.defineProperty(console, methodName, {
            value: wrapperMethod
        });
        return ()=>{
            Object.defineProperty(console, methodName, {
                value: originalMethod,
                writable: descriptor.writable,
                configurable: descriptor.configurable
            });
        };
    }
    return ()=>{};
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=forward-logs-shared.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/forward-logs.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    PROMISE_MARKER: null,
    UNAVAILABLE_MARKER: null,
    forwardErrorLog: null,
    forwardUnhandledError: null,
    initializeDebugLogForwarding: null,
    isTerminalLoggingEnabled: null,
    logQueue: null,
    logStringify: null,
    logUnhandledRejection: null,
    preLogSerializationClone: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    PROMISE_MARKER: function() {
        return PROMISE_MARKER;
    },
    UNAVAILABLE_MARKER: function() {
        return UNAVAILABLE_MARKER;
    },
    forwardErrorLog: function() {
        return forwardErrorLog;
    },
    forwardUnhandledError: function() {
        return forwardUnhandledError;
    },
    initializeDebugLogForwarding: function() {
        return initializeDebugLogForwarding;
    },
    isTerminalLoggingEnabled: function() {
        return isTerminalLoggingEnabled;
    },
    logQueue: function() {
        return logQueue;
    },
    logStringify: function() {
        return logStringify;
    },
    logUnhandledRejection: function() {
        return logUnhandledRejection;
    },
    preLogSerializationClone: function() {
        return preLogSerializationClone;
    }
});
const _safestablestringify = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/safe-stable-stringify/index.js [app-client] (ecmascript)");
const _stitchederror = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [app-client] (ecmascript)");
const _errorsource = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/error-source.js [app-client] (ecmascript)");
const _terminalloggingconfig = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/terminal-logging-config.js [app-client] (ecmascript)");
const _forwardlogsshared = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/shared/forward-logs-shared.js [app-client] (ecmascript)");
const terminalLoggingConfig = (0, _terminalloggingconfig.getTerminalLoggingConfig)();
const PROMISE_MARKER = 'Promise {}';
const UNAVAILABLE_MARKER = '[Unable to view]';
const maximumDepth = typeof terminalLoggingConfig === 'object' && terminalLoggingConfig.depthLimit ? terminalLoggingConfig.depthLimit : 5;
const maximumBreadth = typeof terminalLoggingConfig === 'object' && terminalLoggingConfig.edgeLimit ? terminalLoggingConfig.edgeLimit : 100;
const stringify = (0, _safestablestringify.configure)({
    maximumDepth,
    maximumBreadth
});
const isTerminalLoggingEnabled = (0, _terminalloggingconfig.getIsTerminalLoggingEnabled)();
const methods = [
    'log',
    'info',
    'warn',
    'debug',
    'table',
    'assert',
    'dir',
    'dirxml',
    'group',
    'groupCollapsed',
    'groupEnd',
    'trace'
];
function preLogSerializationClone(value, seen) {
    if (seen === void 0) seen = new WeakMap();
    if (value === undefined) return _forwardlogsshared.UNDEFINED_MARKER;
    if (value === null || typeof value !== 'object') return value;
    if (seen.has(value)) return seen.get(value);
    try {
        Object.keys(value);
    } catch (e) {
        return UNAVAILABLE_MARKER;
    }
    try {
        if (typeof value.then === 'function') return PROMISE_MARKER;
    } catch (e) {
        return UNAVAILABLE_MARKER;
    }
    if (Array.isArray(value)) {
        const out = [];
        seen.set(value, out);
        for (const item of value){
            try {
                out.push(preLogSerializationClone(item, seen));
            } catch (e) {
                out.push(UNAVAILABLE_MARKER);
            }
        }
        return out;
    }
    const proto = Object.getPrototypeOf(value);
    if (proto === Object.prototype || proto === null) {
        const out = {};
        seen.set(value, out);
        for (const key of Object.keys(value)){
            try {
                out[key] = preLogSerializationClone(value[key], seen);
            } catch (e) {
                out[key] = UNAVAILABLE_MARKER;
            }
        }
        return out;
    }
    return Object.prototype.toString.call(value);
}
const logStringify = (data)=>{
    try {
        const result = stringify(data);
        return result != null ? result : '"' + UNAVAILABLE_MARKER + '"';
    } catch (e) {
        return '"' + UNAVAILABLE_MARKER + '"';
    }
};
const afterThisFrame = (cb)=>{
    let timeout;
    const rafId = requestAnimationFrame(()=>{
        timeout = setTimeout(()=>{
            cb();
        });
    });
    return ()=>{
        cancelAnimationFrame(rafId);
        clearTimeout(timeout);
    };
};
let isPatched = false;
const serializeEntries = (entries)=>entries.map((clientEntry)=>{
        switch(clientEntry.kind){
            case 'any-logged-error':
            case 'console':
                {
                    return {
                        ...clientEntry,
                        args: clientEntry.args.map(stringifyUserArg)
                    };
                }
            case 'formatted-error':
                {
                    return clientEntry;
                }
            default:
                {
                    return null;
                }
        }
    });
const logQueue = {
    entries: [],
    flushScheduled: false,
    cancelFlush: null,
    socket: null,
    sourceType: undefined,
    router: null,
    scheduleLogSend: (entry)=>{
        logQueue.entries.push(entry);
        if (logQueue.flushScheduled) {
            return;
        }
        // safe to deref and use in setTimeout closure since we cancel on new socket
        const socket = logQueue.socket;
        if (!socket) {
            return;
        }
        // we probably dont need this
        logQueue.flushScheduled = true;
        // non blocking log flush, runs at most once per frame
        logQueue.cancelFlush = afterThisFrame(()=>{
            logQueue.flushScheduled = false;
            // just incase
            try {
                const payload = JSON.stringify({
                    event: 'browser-logs',
                    entries: serializeEntries(logQueue.entries),
                    router: logQueue.router,
                    // needed for source mapping, we just assign the sourceType from the last error for the whole batch
                    sourceType: logQueue.sourceType
                });
                socket.send(payload);
                logQueue.entries = [];
                logQueue.sourceType = undefined;
            } catch (e) {
            // error (make sure u don't infinite loop)
            /* noop */ }
        });
    },
    onSocketReady: (socket)=>{
        if (socket.readyState !== WebSocket.OPEN) {
            // invariant
            return;
        }
        // incase an existing timeout was going to run with a stale socket
        logQueue.cancelFlush == null ? void 0 : logQueue.cancelFlush.call(logQueue);
        logQueue.socket = socket;
        try {
            const payload = JSON.stringify({
                event: 'browser-logs',
                entries: serializeEntries(logQueue.entries),
                router: logQueue.router,
                sourceType: logQueue.sourceType
            });
            socket.send(payload);
            logQueue.entries = [];
            logQueue.sourceType = undefined;
        } catch (e) {
        /** noop just incase */ }
    }
};
const stringifyUserArg = (arg)=>{
    if (arg.kind !== 'arg') {
        return arg;
    }
    return {
        ...arg,
        data: logStringify(arg.data)
    };
};
const createErrorArg = (error)=>{
    const stack = stackWithOwners(error);
    return {
        kind: 'formatted-error-arg',
        prefix: error.message ? error.name + ": " + error.message : "" + error.name,
        stack
    };
};
const createLogEntry = (level, args)=>{
    // do not abstract this, it implicitly relies on which functions call it. forcing the inlined implementation makes you think about callers
    // error capture stack trace maybe
    const stack = stackWithOwners(new Error());
    const stackLines = stack == null ? void 0 : stack.split('\n');
    const cleanStack = stackLines == null ? void 0 : stackLines.slice(3).join('\n') // this is probably ignored anyways
    ;
    const entry = {
        kind: 'console',
        consoleMethodStack: cleanStack != null ? cleanStack : null,
        method: level,
        args: args.map((arg)=>{
            if (arg instanceof Error) {
                return createErrorArg(arg);
            }
            return {
                kind: 'arg',
                data: preLogSerializationClone(arg)
            };
        })
    };
    logQueue.scheduleLogSend(entry);
};
const forwardErrorLog = (args)=>{
    const errorObjects = args.filter((arg)=>arg instanceof Error);
    const first = errorObjects.at(0);
    if (first) {
        const source = (0, _errorsource.getErrorSource)(first);
        if (source) {
            logQueue.sourceType = source;
        }
    }
    /**
   * browser shows stack regardless of type of data passed to console.error, so we should do the same
   *
   * do not abstract this, it implicitly relies on which functions call it. forcing the inlined implementation makes you think about callers
   */ const stack = stackWithOwners(new Error());
    const stackLines = stack == null ? void 0 : stack.split('\n');
    const cleanStack = stackLines == null ? void 0 : stackLines.slice(3).join('\n');
    const entry = {
        kind: 'any-logged-error',
        method: 'error',
        consoleErrorStack: cleanStack != null ? cleanStack : '',
        args: args.map((arg)=>{
            if (arg instanceof Error) {
                return createErrorArg(arg);
            }
            return {
                kind: 'arg',
                data: preLogSerializationClone(arg)
            };
        })
    };
    logQueue.scheduleLogSend(entry);
};
const createUncaughtErrorEntry = (errorName, errorMessage, fullStack)=>{
    const entry = {
        kind: 'formatted-error',
        prefix: "Uncaught " + errorName + ": " + errorMessage,
        stack: fullStack,
        method: 'error'
    };
    logQueue.scheduleLogSend(entry);
};
const stackWithOwners = (error)=>{
    let ownerStack = '';
    (0, _stitchederror.setOwnerStackIfAvailable)(error);
    ownerStack = (0, _stitchederror.getOwnerStack)(error) || '';
    const stack = (error.stack || '') + ownerStack;
    return stack;
};
function logUnhandledRejection(reason) {
    if (reason instanceof Error) {
        createUnhandledRejectionErrorEntry(reason, stackWithOwners(reason));
        return;
    }
    createUnhandledRejectionNonErrorEntry(reason);
}
const createUnhandledRejectionErrorEntry = (error, fullStack)=>{
    const source = (0, _errorsource.getErrorSource)(error);
    if (source) {
        logQueue.sourceType = source;
    }
    const entry = {
        kind: 'formatted-error',
        prefix: " unhandledRejection: " + error.name + ": " + error.message,
        stack: fullStack,
        method: 'error'
    };
    logQueue.scheduleLogSend(entry);
};
const createUnhandledRejectionNonErrorEntry = (reason)=>{
    const entry = {
        kind: 'any-logged-error',
        // we can't access the stack since the event is dispatched async and creating an inline error would be meaningless
        consoleErrorStack: '',
        method: 'error',
        args: [
            {
                kind: 'arg',
                data: " unhandledRejection:",
                isRejectionMessage: true
            },
            {
                kind: 'arg',
                data: preLogSerializationClone(reason)
            }
        ]
    };
    logQueue.scheduleLogSend(entry);
};
const isHMR = (args)=>{
    const firstArg = args[0];
    if (typeof firstArg !== 'string') {
        return false;
    }
    if (firstArg.startsWith('[Fast Refresh]')) {
        return true;
    }
    if (firstArg.startsWith('[HMR]')) {
        return true;
    }
    return false;
};
const isIgnoredLog = (args)=>{
    if (args.length < 3) {
        return false;
    }
    const [format, styles, label] = args;
    if (typeof format !== 'string' || typeof styles !== 'string' || typeof label !== 'string') {
        return false;
    }
    // kinda hacky, we should define a common format for these strings so we can safely ignore
    return format.startsWith('%c%s%c') && styles.includes('background:');
};
function forwardUnhandledError(error) {
    createUncaughtErrorEntry(error.name, error.message, stackWithOwners(error));
}
const initializeDebugLogForwarding = (router)=>{
    // probably don't need this
    if (isPatched) {
        return;
    }
    // TODO(rob): why does this break rendering on server, important to know incase the same bug appears in browser
    if (typeof window === 'undefined') {
        return;
    }
    // better to be safe than sorry
    try {
        methods.forEach((method)=>(0, _forwardlogsshared.patchConsoleMethod)(method, function(_) {
                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    args[_key - 1] = arguments[_key];
                }
                if (isHMR(args)) {
                    return;
                }
                if (isIgnoredLog(args)) {
                    return;
                }
                createLogEntry(method, args);
            }));
    } catch (e) {}
    logQueue.router = router;
    isPatched = true;
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=forward-logs.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-error-handler.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    handleClientError: null,
    handleConsoleError: null,
    handleGlobalErrors: null,
    useErrorHandler: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    handleClientError: function() {
        return handleClientError;
    },
    handleConsoleError: function() {
        return handleConsoleError;
    },
    handleGlobalErrors: function() {
        return handleGlobalErrors;
    },
    useErrorHandler: function() {
        return useErrorHandler;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
const _isnextroutererror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-client] (ecmascript)");
const _console = __turbopack_context__.r("[project]/node_modules/next/dist/client/lib/console.js [app-client] (ecmascript)");
const _iserror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/lib/is-error.js [app-client] (ecmascript)"));
const _consoleerror = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/shared/console-error.js [app-client] (ecmascript)");
const _stitchederror = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [app-client] (ecmascript)");
const _forwardlogs = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/forward-logs.js [app-client] (ecmascript)");
const queueMicroTask = globalThis.queueMicrotask || ((cb)=>Promise.resolve().then(cb));
const errorQueue = [];
const errorHandlers = [];
const rejectionQueue = [];
const rejectionHandlers = [];
function handleConsoleError(originError, consoleErrorArgs) {
    let error;
    const { environmentName } = (0, _console.parseConsoleArgs)(consoleErrorArgs);
    if ((0, _iserror.default)(originError)) {
        error = (0, _consoleerror.createConsoleError)(originError, environmentName);
    } else {
        error = (0, _consoleerror.createConsoleError)((0, _console.formatConsoleArgs)(consoleErrorArgs), environmentName);
    }
    (0, _stitchederror.setOwnerStackIfAvailable)(error);
    errorQueue.push(error);
    for (const handler of errorHandlers){
        // Delayed the error being passed to React Dev Overlay,
        // avoid the state being synchronously updated in the component.
        queueMicroTask(()=>{
            handler(error);
        });
    }
}
function handleClientError(error) {
    errorQueue.push(error);
    for (const handler of errorHandlers){
        // Delayed the error being passed to React Dev Overlay,
        // avoid the state being synchronously updated in the component.
        queueMicroTask(()=>{
            handler(error);
        });
    }
}
function useErrorHandler(handleOnUnhandledError, handleOnUnhandledRejection) {
    (0, _react.useEffect)(()=>{
        // Handle queued errors.
        errorQueue.forEach(handleOnUnhandledError);
        rejectionQueue.forEach(handleOnUnhandledRejection);
        // Listen to new errors.
        errorHandlers.push(handleOnUnhandledError);
        rejectionHandlers.push(handleOnUnhandledRejection);
        return ()=>{
            // Remove listeners.
            errorHandlers.splice(errorHandlers.indexOf(handleOnUnhandledError), 1);
            rejectionHandlers.splice(rejectionHandlers.indexOf(handleOnUnhandledRejection), 1);
            // Reset error queues.
            errorQueue.splice(0, errorQueue.length);
            rejectionQueue.splice(0, rejectionQueue.length);
        };
    }, [
        handleOnUnhandledError,
        handleOnUnhandledRejection
    ]);
}
function onUnhandledError(event) {
    const thrownValue = event.error;
    if ((0, _isnextroutererror.isNextRouterError)(thrownValue)) {
        event.preventDefault();
        return false;
    }
    // When there's an error property present, we log the error to error overlay.
    // Otherwise we don't do anything as it's not logging in the console either.
    if (thrownValue) {
        const error = (0, _stitchederror.coerceError)(thrownValue);
        (0, _stitchederror.setOwnerStackIfAvailable)(error);
        handleClientError(error);
        if (_forwardlogs.isTerminalLoggingEnabled) {
            (0, _forwardlogs.forwardUnhandledError)(error);
        }
    }
}
function onUnhandledRejection(ev) {
    const reason = ev == null ? void 0 : ev.reason;
    if ((0, _isnextroutererror.isNextRouterError)(reason)) {
        ev.preventDefault();
        return;
    }
    const error = (0, _stitchederror.coerceError)(reason);
    (0, _stitchederror.setOwnerStackIfAvailable)(error);
    rejectionQueue.push(error);
    for (const handler of rejectionHandlers){
        handler(error);
    }
    if (_forwardlogs.isTerminalLoggingEnabled) {
        (0, _forwardlogs.logUnhandledRejection)(reason);
    }
}
function handleGlobalErrors() {
    if (typeof window !== 'undefined') {
        try {
            // Increase the number of stack frames on the client
            Error.stackTraceLimit = 50;
        } catch (e) {}
        window.addEventListener('error', onUnhandledError);
        window.addEventListener('unhandledrejection', onUnhandledRejection);
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-error-handler.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    originConsoleError: null,
    patchConsoleError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    originConsoleError: function() {
        return originConsoleError;
    },
    patchConsoleError: function() {
        return patchConsoleError;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _iserror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/lib/is-error.js [app-client] (ecmascript)"));
const _isnextroutererror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-client] (ecmascript)");
const _useerrorhandler = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-error-handler.js [app-client] (ecmascript)");
const _console = __turbopack_context__.r("[project]/node_modules/next/dist/client/lib/console.js [app-client] (ecmascript)");
const _forwardlogs = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/forward-logs.js [app-client] (ecmascript)");
const originConsoleError = globalThis.console.error;
function patchConsoleError() {
    // Ensure it's only patched once
    if (typeof window === 'undefined') {
        return;
    }
    window.console.error = function error() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        let maybeError;
        if ("TURBOPACK compile-time truthy", 1) {
            const { error: replayedError } = (0, _console.parseConsoleArgs)(args);
            if (replayedError) {
                maybeError = replayedError;
            } else if ((0, _iserror.default)(args[0])) {
                maybeError = args[0];
            } else {
                // See https://github.com/facebook/react/blob/d50323eb845c5fde0d720cae888bf35dedd05506/packages/react-reconciler/src/ReactFiberErrorLogger.js#L78
                maybeError = args[1];
            }
        } else //TURBOPACK unreachable
        ;
        if (!(0, _isnextroutererror.isNextRouterError)(maybeError)) {
            if ("TURBOPACK compile-time truthy", 1) {
                (0, _useerrorhandler.handleConsoleError)(// but if we pass the error directly, `handleClientError` will ignore it
                maybeError, args);
            }
            if (_forwardlogs.isTerminalLoggingEnabled) {
                (0, _forwardlogs.forwardErrorLog)(args);
            }
            originConsoleError.apply(window.console, args);
        }
    };
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=intercept-console-error.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-setup.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _interceptconsoleerror = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js [app-client] (ecmascript)");
const _useerrorhandler = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-error-handler.js [app-client] (ecmascript)");
const _forwardlogs = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/forward-logs.js [app-client] (ecmascript)");
(0, _useerrorhandler.handleGlobalErrors)();
(0, _interceptconsoleerror.patchConsoleError)();
if (_forwardlogs.isTerminalLoggingEnabled) {
    (0, _forwardlogs.initializeDebugLogForwarding)('app');
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-dev-overlay-setup.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    decorateDevError: null,
    handleClientError: null,
    originConsoleError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    decorateDevError: function() {
        return _stitchederror.decorateDevError;
    },
    handleClientError: function() {
        return _useerrorhandler.handleClientError;
    },
    originConsoleError: function() {
        return _interceptconsoleerror.originConsoleError;
    }
});
const _interceptconsoleerror = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/intercept-console-error.js [app-client] (ecmascript)");
const _useerrorhandler = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-error-handler.js [app-client] (ecmascript)");
const _stitchederror = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [app-client] (ecmascript)");
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE: null,
    SegmentBoundaryTriggerNode: null,
    SegmentStateProvider: null,
    SegmentViewNode: null,
    SegmentViewStateNode: null,
    useSegmentState: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE: function() {
        return SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE;
    },
    SegmentBoundaryTriggerNode: function() {
        return SegmentBoundaryTriggerNode;
    },
    SegmentStateProvider: function() {
        return SegmentStateProvider;
    },
    SegmentViewNode: function() {
        return SegmentViewNode;
    },
    SegmentViewStateNode: function() {
        return SegmentViewStateNode;
    },
    useSegmentState: function() {
        return useSegmentState;
    }
});
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
const _nextdevtools = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/next-devtools/index.js [app-client] (ecmascript)");
const _notfound = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/not-found.js [app-client] (ecmascript)");
const SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE = 'NEXT_DEVTOOLS_SIMULATED_ERROR';
function SegmentTrieNode(param) {
    let { type, pagePath } = param;
    const { boundaryType, setBoundaryType } = useSegmentState();
    const nodeState = (0, _react.useMemo)(()=>{
        return {
            type,
            pagePath,
            boundaryType,
            setBoundaryType
        };
    }, [
        type,
        pagePath,
        boundaryType,
        setBoundaryType
    ]);
    // Use `useLayoutEffect` to ensure the state is updated during suspense.
    // `useEffect` won't work as the state is preserved during suspense.
    (0, _react.useLayoutEffect)(()=>{
        _nextdevtools.dispatcher.segmentExplorerNodeAdd(nodeState);
        return ()=>{
            _nextdevtools.dispatcher.segmentExplorerNodeRemove(nodeState);
        };
    }, [
        nodeState
    ]);
    return null;
}
function NotFoundSegmentNode() {
    (0, _notfound.notFound)();
}
function ErrorSegmentNode() {
    throw Object.defineProperty(new Error(SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
}
const forever = new Promise(()=>{});
function LoadingSegmentNode() {
    (0, _react.use)(forever);
    return null;
}
function SegmentViewStateNode(param) {
    let { page } = param;
    (0, _react.useLayoutEffect)(()=>{
        _nextdevtools.dispatcher.segmentExplorerUpdateRouteState(page);
        return ()=>{
            _nextdevtools.dispatcher.segmentExplorerUpdateRouteState('');
        };
    }, [
        page
    ]);
    return null;
}
function SegmentBoundaryTriggerNode() {
    const { boundaryType } = useSegmentState();
    let segmentNode = null;
    if (boundaryType === 'loading') {
        segmentNode = /*#__PURE__*/ (0, _jsxruntime.jsx)(LoadingSegmentNode, {});
    } else if (boundaryType === 'not-found') {
        segmentNode = /*#__PURE__*/ (0, _jsxruntime.jsx)(NotFoundSegmentNode, {});
    } else if (boundaryType === 'error') {
        segmentNode = /*#__PURE__*/ (0, _jsxruntime.jsx)(ErrorSegmentNode, {});
    }
    return segmentNode;
}
function SegmentViewNode(param) {
    let { type, pagePath, children } = param;
    const segmentNode = /*#__PURE__*/ (0, _jsxruntime.jsx)(SegmentTrieNode, {
        type: type,
        pagePath: pagePath
    }, type);
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            segmentNode,
            children
        ]
    });
}
const SegmentStateContext = /*#__PURE__*/ (0, _react.createContext)({
    boundaryType: null,
    setBoundaryType: ()=>{}
});
function SegmentStateProvider(param) {
    let { children } = param;
    const [boundaryType, setBoundaryType] = (0, _react.useState)(null);
    const [errorBoundaryKey, setErrorBoundaryKey] = (0, _react.useState)(0);
    const reloadBoundary = (0, _react.useCallback)(()=>setErrorBoundaryKey((prev)=>prev + 1), []);
    const setBoundaryTypeAndReload = (0, _react.useCallback)((type)=>{
        if (type === null) {
            reloadBoundary();
        }
        setBoundaryType(type);
    }, [
        reloadBoundary
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(SegmentStateContext.Provider, {
        value: {
            boundaryType,
            setBoundaryType: setBoundaryTypeAndReload
        },
        children: children
    }, errorBoundaryKey);
}
function useSegmentState() {
    return (0, _react.useContext)(SegmentStateContext);
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=segment-explorer-node.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-error-boundary.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AppDevOverlayErrorBoundary", {
    enumerable: true,
    get: function() {
        return AppDevOverlayErrorBoundary;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
const _nextdevtools = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/next-devtools/index.js [app-client] (ecmascript)");
const _runtimeerrorhandler = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/runtime-error-handler.js [app-client] (ecmascript)");
const _errorboundary = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/error-boundary.js [app-client] (ecmascript)");
const _globalerror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-client] (ecmascript)"));
const _segmentexplorernode = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js [app-client] (ecmascript)");
function ErroredHtml(param) {
    let { globalError: [GlobalError, globalErrorStyles], error } = param;
    if (!error) {
        return /*#__PURE__*/ (0, _jsxruntime.jsxs)("html", {
            children: [
                /*#__PURE__*/ (0, _jsxruntime.jsx)("head", {}),
                /*#__PURE__*/ (0, _jsxruntime.jsx)("body", {})
            ]
        });
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_errorboundary.ErrorBoundary, {
        errorComponent: _globalerror.default,
        children: [
            globalErrorStyles,
            /*#__PURE__*/ (0, _jsxruntime.jsx)(GlobalError, {
                error: error
            })
        ]
    });
}
class AppDevOverlayErrorBoundary extends _react.PureComponent {
    static getDerivedStateFromError(error) {
        _runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError = true;
        return {
            reactError: error
        };
    }
    componentDidCatch(err) {
        if (("TURBOPACK compile-time value", "development") === 'development' && err.message === _segmentexplorernode.SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE) {
            return;
        }
        _nextdevtools.dispatcher.openErrorOverlay();
    }
    render() {
        const { children, globalError } = this.props;
        const { reactError } = this.state;
        const fallback = /*#__PURE__*/ (0, _jsxruntime.jsx)(ErroredHtml, {
            globalError: globalError,
            error: reactError
        });
        return reactError !== null ? fallback : children;
    }
    constructor(...args){
        super(...args), this.state = {
            reactError: null
        };
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-dev-overlay-error-boundary.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/use-app-dev-rendering-indicator.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useAppDevRenderingIndicator", {
    enumerable: true,
    get: function() {
        return useAppDevRenderingIndicator;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
const _nextdevtools = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/next-devtools/index.js [app-client] (ecmascript)");
const useAppDevRenderingIndicator = ()=>{
    const [isPending, startTransition] = (0, _react.useTransition)();
    (0, _react.useEffect)(()=>{
        if (isPending) {
            _nextdevtools.dispatcher.renderingIndicatorShow();
        } else {
            _nextdevtools.dispatcher.renderingIndicatorHide();
        }
    }, [
        isPending
    ]);
    return startTransition;
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-app-dev-rendering-indicator.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/replay-ssr-only-errors.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ReplaySsrOnlyErrors", {
    enumerable: true,
    get: function() {
        return ReplaySsrOnlyErrors;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
const _useerrorhandler = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-error-handler.js [app-client] (ecmascript)");
const _isnextroutererror = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-client] (ecmascript)");
const _constants = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/errors/constants.js [app-client] (ecmascript)");
function readSsrError() {
    if (typeof document === 'undefined') {
        return null;
    }
    const ssrErrorTemplateTag = document.querySelector('template[data-next-error-message]');
    if (ssrErrorTemplateTag) {
        const message = ssrErrorTemplateTag.getAttribute('data-next-error-message');
        const stack = ssrErrorTemplateTag.getAttribute('data-next-error-stack');
        const digest = ssrErrorTemplateTag.getAttribute('data-next-error-digest');
        const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
        });
        if (digest) {
            ;
            error.digest = digest;
        }
        // Skip Next.js SSR'd internal errors that which will be handled by the error boundaries.
        if ((0, _isnextroutererror.isNextRouterError)(error)) {
            return null;
        }
        error.stack = stack || '';
        return error;
    }
    return null;
}
function ReplaySsrOnlyErrors(param) {
    let { onBlockingError } = param;
    if ("TURBOPACK compile-time truthy", 1) {
        // Need to read during render. The attributes will be gone after commit.
        const ssrError = readSsrError();
        // eslint-disable-next-line react-hooks/rules-of-hooks
        (0, _react.useEffect)(()=>{
            if (ssrError !== null) {
                // TODO(veil): Include original Owner Stack (NDX-905)
                // TODO(veil): Mark as recoverable error
                // TODO(veil): console.error
                (0, _useerrorhandler.handleClientError)(ssrError);
                // If it's missing root tags, we can't recover, make it blocking.
                if (ssrError.digest === _constants.MISSING_ROOT_TAGS_ERROR) {
                    onBlockingError();
                }
            }
        }, [
            ssrError,
            onBlockingError
        ]);
    }
    return null;
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=replay-ssr-only-errors.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-forward-console-log.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useForwardConsoleLog", {
    enumerable: true,
    get: function() {
        return useForwardConsoleLog;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
const _forwardlogs = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/forward-logs.js [app-client] (ecmascript)");
const useForwardConsoleLog = (socketRef)=>{
    (0, _react.useEffect)(()=>{
        if (!_forwardlogs.isTerminalLoggingEnabled) {
            return;
        }
        const socket = socketRef.current;
        if (!socket) {
            return;
        }
        const onOpen = ()=>{
            _forwardlogs.logQueue.onSocketReady(socket);
        };
        socket.addEventListener('open', onOpen);
        return ()=>{
            socket.removeEventListener('open', onOpen);
        };
    }, [
        socketRef
    ]);
};
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-forward-console-log.js.map
}}),
"[project]/node_modules/next/dist/next-devtools/userspace/app/client-entry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createRootLevelDevOverlayElement", {
    enumerable: true,
    get: function() {
        return createRootLevelDevOverlayElement;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _getsocketurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/dev/hot-reloader/get-socket-url.js [app-client] (ecmascript)");
const _hotreloadertypes = __turbopack_context__.r("[project]/node_modules/next/dist/server/dev/hot-reloader-types.js [app-client] (ecmascript)");
const _globalerror = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-client] (ecmascript)"));
const _appdevoverlayerrorboundary = __turbopack_context__.r("[project]/node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-error-boundary.js [app-client] (ecmascript)");
function createRootLevelDevOverlayElement(reactEl) {
    const socketUrl = (0, _getsocketurl.getSocketUrl)(("TURBOPACK compile-time value", "") || '');
    const socket = new window.WebSocket("" + socketUrl + "/_next/webpack-hmr");
    // add minimal "hot reload" support for RSC errors
    const handler = (event)=>{
        let obj;
        try {
            obj = JSON.parse(event.data);
        } catch (e) {}
        if (!obj || !('action' in obj)) {
            return;
        }
        if (obj.action === _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES) {
            window.location.reload();
        }
    };
    socket.addEventListener('message', handler);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_appdevoverlayerrorboundary.AppDevOverlayErrorBoundary, {
        globalError: [
            _globalerror.default,
            null
        ],
        children: reactEl
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=client-entry.js.map
}}),
"[project]/node_modules/next/dist/server/app-render/async-local-storage.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    bindSnapshot: null,
    createAsyncLocalStorage: null,
    createSnapshot: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    bindSnapshot: function() {
        return bindSnapshot;
    },
    createAsyncLocalStorage: function() {
        return createAsyncLocalStorage;
    },
    createSnapshot: function() {
        return createSnapshot;
    }
});
const sharedAsyncLocalStorageNotAvailableError = Object.defineProperty(new Error('Invariant: AsyncLocalStorage accessed in runtime where it is not available'), "__NEXT_ERROR_CODE", {
    value: "E504",
    enumerable: false,
    configurable: true
});
class FakeAsyncLocalStorage {
    disable() {
        throw sharedAsyncLocalStorageNotAvailableError;
    }
    getStore() {
        // This fake implementation of AsyncLocalStorage always returns `undefined`.
        return undefined;
    }
    run() {
        throw sharedAsyncLocalStorageNotAvailableError;
    }
    exit() {
        throw sharedAsyncLocalStorageNotAvailableError;
    }
    enterWith() {
        throw sharedAsyncLocalStorageNotAvailableError;
    }
    static bind(fn) {
        return fn;
    }
}
const maybeGlobalAsyncLocalStorage = typeof globalThis !== 'undefined' && globalThis.AsyncLocalStorage;
function createAsyncLocalStorage() {
    if (maybeGlobalAsyncLocalStorage) {
        return new maybeGlobalAsyncLocalStorage();
    }
    return new FakeAsyncLocalStorage();
}
function bindSnapshot(fn) {
    if (maybeGlobalAsyncLocalStorage) {
        return maybeGlobalAsyncLocalStorage.bind(fn);
    }
    return FakeAsyncLocalStorage.bind(fn);
}
function createSnapshot() {
    if (maybeGlobalAsyncLocalStorage) {
        return maybeGlobalAsyncLocalStorage.snapshot();
    }
    return function(fn) {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            args[_key - 1] = arguments[_key];
        }
        return fn(...args);
    };
} //# sourceMappingURL=async-local-storage.js.map
}}),
"[project]/node_modules/next/dist/server/app-render/work-async-storage-instance.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "workAsyncStorageInstance", {
    enumerable: true,
    get: function() {
        return workAsyncStorageInstance;
    }
});
const _asynclocalstorage = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/async-local-storage.js [app-client] (ecmascript)");
const workAsyncStorageInstance = (0, _asynclocalstorage.createAsyncLocalStorage)(); //# sourceMappingURL=work-async-storage-instance.js.map
}}),
"[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "workAsyncStorage", {
    enumerable: true,
    get: function() {
        return _workasyncstorageinstance.workAsyncStorageInstance;
    }
});
const _workasyncstorageinstance = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-async-storage-instance.js [app-client] (ecmascript)"); //# sourceMappingURL=work-async-storage.external.js.map
}}),
"[project]/node_modules/next/dist/server/app-render/action-async-storage-instance.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "actionAsyncStorageInstance", {
    enumerable: true,
    get: function() {
        return actionAsyncStorageInstance;
    }
});
const _asynclocalstorage = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/async-local-storage.js [app-client] (ecmascript)");
const actionAsyncStorageInstance = (0, _asynclocalstorage.createAsyncLocalStorage)(); //# sourceMappingURL=action-async-storage-instance.js.map
}}),
"[project]/node_modules/next/dist/server/app-render/action-async-storage.external.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "actionAsyncStorage", {
    enumerable: true,
    get: function() {
        return _actionasyncstorageinstance.actionAsyncStorageInstance;
    }
});
const _actionasyncstorageinstance = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/action-async-storage-instance.js [app-client] (ecmascript)"); //# sourceMappingURL=action-async-storage.external.js.map
}}),
"[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    isHangingPromiseRejectionError: null,
    makeHangingPromise: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    isHangingPromiseRejectionError: function() {
        return isHangingPromiseRejectionError;
    },
    makeHangingPromise: function() {
        return makeHangingPromise;
    }
});
function isHangingPromiseRejectionError(err) {
    if (typeof err !== 'object' || err === null || !('digest' in err)) {
        return false;
    }
    return err.digest === HANGING_PROMISE_REJECTION;
}
const HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION';
class HangingPromiseRejectionError extends Error {
    constructor(expression){
        super("During prerendering, ".concat(expression, " rejects when the prerender is complete. Typically these errors are handled by React but if you move ").concat(expression, " to a different context by using `setTimeout`, `after`, or similar functions you may observe this error and you should handle it in that context.")), this.expression = expression, this.digest = HANGING_PROMISE_REJECTION;
    }
}
const abortListenersBySignal = new WeakMap();
function makeHangingPromise(signal, expression) {
    if (signal.aborted) {
        return Promise.reject(new HangingPromiseRejectionError(expression));
    } else {
        const hangingPromise = new Promise((_, reject)=>{
            const boundRejection = reject.bind(null, new HangingPromiseRejectionError(expression));
            let currentListeners = abortListenersBySignal.get(signal);
            if (currentListeners) {
                currentListeners.push(boundRejection);
            } else {
                const listeners = [
                    boundRejection
                ];
                abortListenersBySignal.set(signal, listeners);
                signal.addEventListener('abort', ()=>{
                    for(let i = 0; i < listeners.length; i++){
                        listeners[i]();
                    }
                }, {
                    once: true
                });
            }
        });
        // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so
        // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct
        // your own promise out of it you'll need to ensure you handle the error when it rejects.
        hangingPromise.catch(ignoreReject);
        return hangingPromise;
    }
}
function ignoreReject() {} //# sourceMappingURL=dynamic-rendering-utils.js.map
}}),
"[project]/node_modules/next/dist/server/lib/router-utils/is-postpone.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isPostpone", {
    enumerable: true,
    get: function() {
        return isPostpone;
    }
});
const REACT_POSTPONE_TYPE = Symbol.for('react.postpone');
function isPostpone(error) {
    return typeof error === 'object' && error !== null && error.$$typeof === REACT_POSTPONE_TYPE;
} //# sourceMappingURL=is-postpone.js.map
}}),
"[project]/node_modules/next/dist/server/app-render/work-unit-async-storage-instance.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "workUnitAsyncStorageInstance", {
    enumerable: true,
    get: function() {
        return workUnitAsyncStorageInstance;
    }
});
const _asynclocalstorage = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/async-local-storage.js [app-client] (ecmascript)");
const workUnitAsyncStorageInstance = (0, _asynclocalstorage.createAsyncLocalStorage)(); //# sourceMappingURL=work-unit-async-storage-instance.js.map
}}),
"[project]/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    getDraftModeProviderForCacheScope: null,
    getExpectedRequestStore: null,
    getHmrRefreshHash: null,
    getPrerenderResumeDataCache: null,
    getRenderResumeDataCache: null,
    throwForMissingRequestStore: null,
    workUnitAsyncStorage: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getDraftModeProviderForCacheScope: function() {
        return getDraftModeProviderForCacheScope;
    },
    getExpectedRequestStore: function() {
        return getExpectedRequestStore;
    },
    getHmrRefreshHash: function() {
        return getHmrRefreshHash;
    },
    getPrerenderResumeDataCache: function() {
        return getPrerenderResumeDataCache;
    },
    getRenderResumeDataCache: function() {
        return getRenderResumeDataCache;
    },
    throwForMissingRequestStore: function() {
        return throwForMissingRequestStore;
    },
    workUnitAsyncStorage: function() {
        return _workunitasyncstorageinstance.workUnitAsyncStorageInstance;
    }
});
const _workunitasyncstorageinstance = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-unit-async-storage-instance.js [app-client] (ecmascript)");
const _approuterheaders = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-headers.js [app-client] (ecmascript)");
function getExpectedRequestStore(callingExpression) {
    const workUnitStore = _workunitasyncstorageinstance.workUnitAsyncStorageInstance.getStore();
    if (!workUnitStore) {
        throwForMissingRequestStore(callingExpression);
    }
    switch(workUnitStore.type){
        case 'request':
            return workUnitStore;
        case 'prerender':
        case 'prerender-client':
        case 'prerender-ppr':
        case 'prerender-legacy':
            // This should not happen because we should have checked it already.
            throw Object.defineProperty(new Error("`".concat(callingExpression, "` cannot be called inside a prerender. This is a bug in Next.js.")), "__NEXT_ERROR_CODE", {
                value: "E401",
                enumerable: false,
                configurable: true
            });
        case 'cache':
            throw Object.defineProperty(new Error("`".concat(callingExpression, '` cannot be called inside "use cache". Call it outside and pass an argument instead. Read more: https://nextjs.org/docs/messages/next-request-in-use-cache')), "__NEXT_ERROR_CODE", {
                value: "E37",
                enumerable: false,
                configurable: true
            });
        case 'unstable-cache':
            throw Object.defineProperty(new Error("`".concat(callingExpression, "` cannot be called inside unstable_cache. Call it outside and pass an argument instead. Read more: https://nextjs.org/docs/app/api-reference/functions/unstable_cache")), "__NEXT_ERROR_CODE", {
                value: "E69",
                enumerable: false,
                configurable: true
            });
        default:
            const _exhaustiveCheck = workUnitStore;
            return _exhaustiveCheck;
    }
}
function throwForMissingRequestStore(callingExpression) {
    throw Object.defineProperty(new Error("`".concat(callingExpression, "` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context")), "__NEXT_ERROR_CODE", {
        value: "E251",
        enumerable: false,
        configurable: true
    });
}
function getPrerenderResumeDataCache(workUnitStore) {
    if (workUnitStore.type === 'prerender' || // TODO eliminate fetch caching in client scope and stop exposing this data cache during SSR
    workUnitStore.type === 'prerender-client' || workUnitStore.type === 'prerender-ppr') {
        return workUnitStore.prerenderResumeDataCache;
    }
    return null;
}
function getRenderResumeDataCache(workUnitStore) {
    switch(workUnitStore.type){
        case 'request':
            return workUnitStore.renderResumeDataCache;
        case 'prerender':
        case 'prerender-client':
            if (workUnitStore.renderResumeDataCache) {
                // If we are in a prerender, we might have a render resume data cache
                // that is used to read from prefilled caches.
                return workUnitStore.renderResumeDataCache;
            }
        // fallthrough
        case 'prerender-ppr':
            // Otherwise we return the mutable resume data cache here as an immutable
            // version of the cache as it can also be used for reading.
            return workUnitStore.prerenderResumeDataCache;
        default:
            return null;
    }
}
function getHmrRefreshHash(workStore, workUnitStore) {
    var _workUnitStore_cookies_get;
    if (!workStore.dev) {
        return undefined;
    }
    return workUnitStore.type === 'cache' || workUnitStore.type === 'prerender' ? workUnitStore.hmrRefreshHash : workUnitStore.type === 'request' ? (_workUnitStore_cookies_get = workUnitStore.cookies.get(_approuterheaders.NEXT_HMR_REFRESH_HASH_COOKIE)) == null ? void 0 : _workUnitStore_cookies_get.value : undefined;
}
function getDraftModeProviderForCacheScope(workStore, workUnitStore) {
    if (workStore.isDraftMode) {
        switch(workUnitStore.type){
            case 'cache':
            case 'unstable-cache':
            case 'request':
                return workUnitStore.draftMode;
            default:
                return undefined;
        }
    }
    return undefined;
} //# sourceMappingURL=work-unit-async-storage.external.js.map
}}),
"[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * The functions provided by this module are used to communicate certain properties
 * about the currently running code so that Next.js can make decisions on how to handle
 * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.
 *
 * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.
 * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts
 * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of
 * Dynamic indications.
 *
 * The first is simply an intention to be dynamic. unstable_noStore is an example of this where
 * the currently executing code simply declares that the current scope is dynamic but if you use it
 * inside unstable_cache it can still be cached. This type of indication can be removed if we ever
 * make the default dynamic to begin with because the only way you would ever be static is inside
 * a cache scope which this indication does not affect.
 *
 * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic
 * because it means that it is inappropriate to cache this at all. using a dynamic data source inside
 * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should
 * read that data outside the cache and pass it in as an argument to the cached function.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    Postpone: null,
    PreludeState: null,
    abortAndThrowOnSynchronousRequestDataAccess: null,
    abortOnSynchronousPlatformIOAccess: null,
    accessedDynamicData: null,
    annotateDynamicAccess: null,
    consumeDynamicAccess: null,
    createDynamicTrackingState: null,
    createDynamicValidationState: null,
    createHangingInputAbortSignal: null,
    createPostponedAbortSignal: null,
    formatDynamicAPIAccesses: null,
    getFirstDynamicReason: null,
    isDynamicPostpone: null,
    isPrerenderInterruptedError: null,
    markCurrentScopeAsDynamic: null,
    postponeWithTracking: null,
    throwIfDisallowedDynamic: null,
    throwToInterruptStaticGeneration: null,
    trackAllowedDynamicAccess: null,
    trackDynamicDataInDynamicRender: null,
    trackFallbackParamAccessed: null,
    trackSynchronousPlatformIOAccessInDev: null,
    trackSynchronousRequestDataAccessInDev: null,
    useDynamicRouteParams: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    Postpone: function() {
        return Postpone;
    },
    PreludeState: function() {
        return PreludeState;
    },
    abortAndThrowOnSynchronousRequestDataAccess: function() {
        return abortAndThrowOnSynchronousRequestDataAccess;
    },
    abortOnSynchronousPlatformIOAccess: function() {
        return abortOnSynchronousPlatformIOAccess;
    },
    accessedDynamicData: function() {
        return accessedDynamicData;
    },
    annotateDynamicAccess: function() {
        return annotateDynamicAccess;
    },
    consumeDynamicAccess: function() {
        return consumeDynamicAccess;
    },
    createDynamicTrackingState: function() {
        return createDynamicTrackingState;
    },
    createDynamicValidationState: function() {
        return createDynamicValidationState;
    },
    createHangingInputAbortSignal: function() {
        return createHangingInputAbortSignal;
    },
    createPostponedAbortSignal: function() {
        return createPostponedAbortSignal;
    },
    formatDynamicAPIAccesses: function() {
        return formatDynamicAPIAccesses;
    },
    getFirstDynamicReason: function() {
        return getFirstDynamicReason;
    },
    isDynamicPostpone: function() {
        return isDynamicPostpone;
    },
    isPrerenderInterruptedError: function() {
        return isPrerenderInterruptedError;
    },
    markCurrentScopeAsDynamic: function() {
        return markCurrentScopeAsDynamic;
    },
    postponeWithTracking: function() {
        return postponeWithTracking;
    },
    throwIfDisallowedDynamic: function() {
        return throwIfDisallowedDynamic;
    },
    throwToInterruptStaticGeneration: function() {
        return throwToInterruptStaticGeneration;
    },
    trackAllowedDynamicAccess: function() {
        return trackAllowedDynamicAccess;
    },
    trackDynamicDataInDynamicRender: function() {
        return trackDynamicDataInDynamicRender;
    },
    trackFallbackParamAccessed: function() {
        return trackFallbackParamAccessed;
    },
    trackSynchronousPlatformIOAccessInDev: function() {
        return trackSynchronousPlatformIOAccessInDev;
    },
    trackSynchronousRequestDataAccessInDev: function() {
        return trackSynchronousRequestDataAccessInDev;
    },
    useDynamicRouteParams: function() {
        return useDynamicRouteParams;
    }
});
const _react = /*#__PURE__*/ _interop_require_default(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _hooksservercontext = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-client] (ecmascript)");
const _staticgenerationbailout = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-client] (ecmascript)");
const _workunitasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js [app-client] (ecmascript)");
const _workasyncstorageexternal = __turbopack_context__.r("[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)");
const _dynamicrenderingutils = __turbopack_context__.r("[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-client] (ecmascript)");
const _metadataconstants = __turbopack_context__.r("[project]/node_modules/next/dist/lib/metadata/metadata-constants.js [app-client] (ecmascript)");
const _scheduler = __turbopack_context__.r("[project]/node_modules/next/dist/lib/scheduler.js [app-client] (ecmascript)");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const hasPostpone = typeof _react.default.unstable_postpone === 'function';
function createDynamicTrackingState(isDebugDynamicAccesses) {
    return {
        isDebugDynamicAccesses,
        dynamicAccesses: [],
        syncDynamicErrorWithStack: null
    };
}
function createDynamicValidationState() {
    return {
        hasSuspenseAboveBody: false,
        hasDynamicMetadata: false,
        hasDynamicViewport: false,
        hasAllowedDynamic: false,
        dynamicErrors: []
    };
}
function getFirstDynamicReason(trackingState) {
    var _trackingState_dynamicAccesses_;
    return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null ? void 0 : _trackingState_dynamicAccesses_.expression;
}
function markCurrentScopeAsDynamic(store, workUnitStore, expression) {
    if (workUnitStore) {
        if (workUnitStore.type === 'cache' || workUnitStore.type === 'unstable-cache') {
            // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope
            // creates a cache boundary. This is subtly different from reading a dynamic data source which is
            // forbidden inside a cache scope.
            return;
        }
    }
    // If we're forcing dynamic rendering or we're forcing static rendering, we
    // don't need to do anything here because the entire page is already dynamic
    // or it's static and it should not throw or postpone here.
    if (store.forceDynamic || store.forceStatic) return;
    if (store.dynamicShouldError) {
        throw Object.defineProperty(new _staticgenerationbailout.StaticGenBailoutError("Route ".concat(store.route, ' with `dynamic = "error"` couldn\'t be rendered statically because it used `').concat(expression, "`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering")), "__NEXT_ERROR_CODE", {
            value: "E553",
            enumerable: false,
            configurable: true
        });
    }
    if (workUnitStore) {
        if (workUnitStore.type === 'prerender-ppr') {
            postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);
        } else if (workUnitStore.type === 'prerender-legacy') {
            workUnitStore.revalidate = 0;
            // We aren't prerendering but we are generating a static page. We need to bail out of static generation
            const err = Object.defineProperty(new _hooksservercontext.DynamicServerError("Route ".concat(store.route, " couldn't be rendered statically because it used ").concat(expression, ". See more info here: https://nextjs.org/docs/messages/dynamic-server-error")), "__NEXT_ERROR_CODE", {
                value: "E550",
                enumerable: false,
                configurable: true
            });
            store.dynamicUsageDescription = expression;
            store.dynamicUsageStack = err.stack;
            throw err;
        } else if (("TURBOPACK compile-time value", "development") === 'development' && workUnitStore && workUnitStore.type === 'request') {
            workUnitStore.usedDynamic = true;
        }
    }
}
function trackFallbackParamAccessed(store, expression) {
    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    if (!prerenderStore || prerenderStore.type !== 'prerender-ppr') return;
    postponeWithTracking(store.route, expression, prerenderStore.dynamicTracking);
}
function throwToInterruptStaticGeneration(expression, store, prerenderStore) {
    // We aren't prerendering but we are generating a static page. We need to bail out of static generation
    const err = Object.defineProperty(new _hooksservercontext.DynamicServerError("Route ".concat(store.route, " couldn't be rendered statically because it used `").concat(expression, "`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error")), "__NEXT_ERROR_CODE", {
        value: "E558",
        enumerable: false,
        configurable: true
    });
    prerenderStore.revalidate = 0;
    store.dynamicUsageDescription = expression;
    store.dynamicUsageStack = err.stack;
    throw err;
}
function trackDynamicDataInDynamicRender(_store, workUnitStore) {
    if (workUnitStore) {
        if (workUnitStore.type === 'cache' || workUnitStore.type === 'unstable-cache') {
            // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope
            // creates a cache boundary. This is subtly different from reading a dynamic data source which is
            // forbidden inside a cache scope.
            return;
        }
        // TODO: it makes no sense to have these work unit store types during a dev render.
        if (workUnitStore.type === 'prerender' || workUnitStore.type === 'prerender-client' || workUnitStore.type === 'prerender-legacy') {
            workUnitStore.revalidate = 0;
        }
        if (("TURBOPACK compile-time value", "development") === 'development' && workUnitStore.type === 'request') {
            workUnitStore.usedDynamic = true;
        }
    }
}
function abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {
    const reason = "Route ".concat(route, " needs to bail out of prerendering at this point because it used ").concat(expression, ".");
    const error = createPrerenderInterruptedError(reason);
    prerenderStore.controller.abort(error);
    const dynamicTracking = prerenderStore.dynamicTracking;
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            // When we aren't debugging, we don't need to create another error for the
            // stack trace.
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
}
function abortOnSynchronousPlatformIOAccess(route, expression, errorWithStack, prerenderStore) {
    const dynamicTracking = prerenderStore.dynamicTracking;
    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
    // It is important that we set this tracking value after aborting. Aborts are executed
    // synchronously except for the case where you abort during render itself. By setting this
    // value late we can use it to determine if any of the aborted tasks are the task that
    // called the sync IO expression in the first place.
    if (dynamicTracking) {
        if (dynamicTracking.syncDynamicErrorWithStack === null) {
            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
        }
    }
}
function trackSynchronousPlatformIOAccessInDev(requestStore) {
    // We don't actually have a controller to abort but we do the semantic equivalent by
    // advancing the request store out of prerender mode
    requestStore.prerenderPhase = false;
}
function abortAndThrowOnSynchronousRequestDataAccess(route, expression, errorWithStack, prerenderStore) {
    const prerenderSignal = prerenderStore.controller.signal;
    if (prerenderSignal.aborted === false) {
        // TODO it would be better to move this aborted check into the callsite so we can avoid making
        // the error object when it isn't relevant to the aborting of the prerender however
        // since we need the throw semantics regardless of whether we abort it is easier to land
        // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer
        // to ideal implementation
        abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
        // It is important that we set this tracking value after aborting. Aborts are executed
        // synchronously except for the case where you abort during render itself. By setting this
        // value late we can use it to determine if any of the aborted tasks are the task that
        // called the sync IO expression in the first place.
        const dynamicTracking = prerenderStore.dynamicTracking;
        if (dynamicTracking) {
            if (dynamicTracking.syncDynamicErrorWithStack === null) {
                dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
            }
        }
    }
    throw createPrerenderInterruptedError("Route ".concat(route, " needs to bail out of prerendering at this point because it used ").concat(expression, "."));
}
const trackSynchronousRequestDataAccessInDev = trackSynchronousPlatformIOAccessInDev;
function Postpone(param) {
    let { reason, route } = param;
    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
    const dynamicTracking = prerenderStore && prerenderStore.type === 'prerender-ppr' ? prerenderStore.dynamicTracking : null;
    postponeWithTracking(route, reason, dynamicTracking);
}
function postponeWithTracking(route, expression, dynamicTracking) {
    assertPostpone();
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            // When we aren't debugging, we don't need to create another error for the
            // stack trace.
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
    _react.default.unstable_postpone(createPostponeReason(route, expression));
}
function createPostponeReason(route, expression) {
    return "Route ".concat(route, " needs to bail out of prerendering at this point because it used ").concat(expression, ". ") + "React throws this special object to indicate where. It should not be caught by " + "your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error";
}
function isDynamicPostpone(err) {
    if (typeof err === 'object' && err !== null && typeof err.message === 'string') {
        return isDynamicPostponeReason(err.message);
    }
    return false;
}
function isDynamicPostponeReason(reason) {
    return reason.includes('needs to bail out of prerendering at this point because it used') && reason.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error');
}
if (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {
    throw Object.defineProperty(new Error('Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'), "__NEXT_ERROR_CODE", {
        value: "E296",
        enumerable: false,
        configurable: true
    });
}
const NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED';
function createPrerenderInterruptedError(message) {
    const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.digest = NEXT_PRERENDER_INTERRUPTED;
    return error;
}
function isPrerenderInterruptedError(error) {
    return typeof error === 'object' && error !== null && error.digest === NEXT_PRERENDER_INTERRUPTED && 'name' in error && 'message' in error && error instanceof Error;
}
function accessedDynamicData(dynamicAccesses) {
    return dynamicAccesses.length > 0;
}
function consumeDynamicAccess(serverDynamic, clientDynamic) {
    // We mutate because we only call this once we are no longer writing
    // to the dynamicTrackingState and it's more efficient than creating a new
    // array.
    serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);
    return serverDynamic.dynamicAccesses;
}
function formatDynamicAPIAccesses(dynamicAccesses) {
    return dynamicAccesses.filter((access)=>typeof access.stack === 'string' && access.stack.length > 0).map((param)=>{
        let { expression, stack } = param;
        stack = stack.split('\n') // Remove the "Error: " prefix from the first line of the stack trace as
        // well as the first 4 lines of the stack trace which is the distance
        // from the user code and the `new Error().stack` call.
        .slice(4).filter((line)=>{
            // Exclude Next.js internals from the stack trace.
            if (line.includes('node_modules/next/')) {
                return false;
            }
            // Exclude anonymous functions from the stack trace.
            if (line.includes(' (<anonymous>)')) {
                return false;
            }
            // Exclude Node.js internals from the stack trace.
            if (line.includes(' (node:')) {
                return false;
            }
            return true;
        }).join('\n');
        return "Dynamic API Usage Debug - ".concat(expression, ":\n").concat(stack);
    });
}
function assertPostpone() {
    if (!hasPostpone) {
        throw Object.defineProperty(new Error("Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js"), "__NEXT_ERROR_CODE", {
            value: "E224",
            enumerable: false,
            configurable: true
        });
    }
}
function createPostponedAbortSignal(reason) {
    assertPostpone();
    const controller = new AbortController();
    // We get our hands on a postpone instance by calling postpone and catching the throw
    try {
        _react.default.unstable_postpone(reason);
    } catch (x) {
        controller.abort(x);
    }
    return controller.signal;
}
function createHangingInputAbortSignal(workUnitStore) {
    const controller = new AbortController();
    if (workUnitStore.cacheSignal) {
        // If we have a cacheSignal it means we're in a prospective render. If the input
        // we're waiting on is coming from another cache, we do want to wait for it so that
        // we can resolve this cache entry too.
        workUnitStore.cacheSignal.inputReady().then(()=>{
            controller.abort();
        });
    } else {
        // Otherwise we're in the final render and we should already have all our caches
        // filled. We might still be waiting on some microtasks so we wait one tick before
        // giving up. When we give up, we still want to render the content of this cache
        // as deeply as we can so that we can suspend as deeply as possible in the tree
        // or not at all if we don't end up waiting for the input.
        (0, _scheduler.scheduleOnNextTick)(()=>controller.abort());
    }
    return controller.signal;
}
function annotateDynamicAccess(expression, prerenderStore) {
    const dynamicTracking = prerenderStore.dynamicTracking;
    if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,
            expression
        });
    }
}
function useDynamicRouteParams(expression) {
    const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
    if (workStore && workStore.isStaticGeneration && workStore.fallbackRouteParams && workStore.fallbackRouteParams.size > 0) {
        // There are fallback route params, we should track these as dynamic
        // accesses.
        const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
        if (workUnitStore) {
            // We're prerendering with dynamicIO or PPR or both
            if (workUnitStore.type === 'prerender-client') {
                // We are in a prerender with dynamicIO semantics
                // We are going to hang here and never resolve. This will cause the currently
                // rendering component to effectively be a dynamic hole
                _react.default.use((0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, expression));
            } else if (workUnitStore.type === 'prerender-ppr') {
                // We're prerendering with PPR
                postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);
            } else if (workUnitStore.type === 'prerender-legacy') {
                throwToInterruptStaticGeneration(expression, workStore, workUnitStore);
            }
        }
    }
}
const hasSuspenseRegex = /\n\s+at Suspense \(<anonymous>\)/;
const hasSuspenseAfterBodyOrHtmlRegex = /\n\s+at (?:body|html) \(<anonymous>\)[\s\S]*?\n\s+at Suspense \(<anonymous>\)/;
const hasMetadataRegex = new RegExp("\\n\\s+at ".concat(_metadataconstants.METADATA_BOUNDARY_NAME, "[\\n\\s]"));
const hasViewportRegex = new RegExp("\\n\\s+at ".concat(_metadataconstants.VIEWPORT_BOUNDARY_NAME, "[\\n\\s]"));
const hasOutletRegex = new RegExp("\\n\\s+at ".concat(_metadataconstants.OUTLET_BOUNDARY_NAME, "[\\n\\s]"));
function trackAllowedDynamicAccess(workStore, componentStack, dynamicValidation, clientDynamic) {
    if (hasOutletRegex.test(componentStack)) {
        // We don't need to track that this is dynamic. It is only so when something else is also dynamic.
        return;
    } else if (hasMetadataRegex.test(componentStack)) {
        dynamicValidation.hasDynamicMetadata = true;
        return;
    } else if (hasViewportRegex.test(componentStack)) {
        dynamicValidation.hasDynamicViewport = true;
        return;
    } else if (hasSuspenseAfterBodyOrHtmlRegex.test(componentStack)) {
        // This prerender has a Suspense boundary above the body which
        // effectively opts the page into allowing 100% dynamic rendering
        dynamicValidation.hasAllowedDynamic = true;
        dynamicValidation.hasSuspenseAboveBody = true;
        return;
    } else if (hasSuspenseRegex.test(componentStack)) {
        // this error had a Suspense boundary above it so we don't need to report it as a source
        // of disallowed
        dynamicValidation.hasAllowedDynamic = true;
        return;
    } else if (clientDynamic.syncDynamicErrorWithStack) {
        // This task was the task that called the sync error.
        dynamicValidation.dynamicErrors.push(clientDynamic.syncDynamicErrorWithStack);
        return;
    } else {
        const message = 'Route "'.concat(workStore.route, '": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a "use cache" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense');
        const error = createErrorWithComponentOrOwnerStack(message, componentStack);
        dynamicValidation.dynamicErrors.push(error);
        return;
    }
}
/**
 * In dev mode, we prefer using the owner stack, otherwise the provided
 * component stack is used.
 */ function createErrorWithComponentOrOwnerStack(message, componentStack) {
    const ownerStack = ("TURBOPACK compile-time value", "development") !== 'production' && _react.default.captureOwnerStack ? _react.default.captureOwnerStack() : null;
    const error = Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
    });
    error.stack = error.name + ': ' + message + (ownerStack !== null && ownerStack !== void 0 ? ownerStack : componentStack);
    return error;
}
var PreludeState = /*#__PURE__*/ function(PreludeState) {
    PreludeState[PreludeState["Full"] = 0] = "Full";
    PreludeState[PreludeState["Empty"] = 1] = "Empty";
    PreludeState[PreludeState["Errored"] = 2] = "Errored";
    return PreludeState;
}({});
function logDisallowedDynamicError(workStore, error) {
    console.error(error);
    if (!workStore.dev) {
        if (workStore.hasReadableErrorStacks) {
            console.error('To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running `next dev`, then open "'.concat(workStore.route, '" in your browser to investigate the error.'));
        } else {
            console.error('To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running `next dev`, then open "'.concat(workStore.route, '" in your browser to investigate the error.\n  - Rerun the production build with `next build --debug-prerender` to generate better stack traces.'));
        }
    }
}
function throwIfDisallowedDynamic(workStore, prelude, dynamicValidation, serverDynamic) {
    if (workStore.invalidDynamicUsageError) {
        logDisallowedDynamicError(workStore, workStore.invalidDynamicUsageError);
        throw new _staticgenerationbailout.StaticGenBailoutError();
    }
    if (prelude !== 0) {
        if (dynamicValidation.hasSuspenseAboveBody) {
            // This route has opted into allowing fully dynamic rendering
            // by including a Suspense boundary above the body. In this case
            // a lack of a shell is not considered disallowed so we simply return
            return;
        }
        if (serverDynamic.syncDynamicErrorWithStack) {
            // There is no shell and the server did something sync dynamic likely
            // leading to an early termination of the prerender before the shell
            // could be completed. We terminate the build/validating render.
            logDisallowedDynamicError(workStore, serverDynamic.syncDynamicErrorWithStack);
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
        // We didn't have any sync bailouts but there may be user code which
        // blocked the root. We would have captured these during the prerender
        // and can log them here and then terminate the build/validating render
        const dynamicErrors = dynamicValidation.dynamicErrors;
        if (dynamicErrors.length > 0) {
            for(let i = 0; i < dynamicErrors.length; i++){
                logDisallowedDynamicError(workStore, dynamicErrors[i]);
            }
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
        // If we got this far then the only other thing that could be blocking
        // the root is dynamic Viewport. If this is dynamic then
        // you need to opt into that by adding a Suspense boundary above the body
        // to indicate your are ok with fully dynamic rendering.
        if (dynamicValidation.hasDynamicViewport) {
            console.error('Route "'.concat(workStore.route, '" has a `generateViewport` that depends on Request data (`cookies()`, etc...) or uncached external data (`fetch(...)`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport'));
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
        if (prelude === 1) {
            // If we ever get this far then we messed up the tracking of invalid dynamic.
            // We still adhere to the constraint that you must produce a shell but invite the
            // user to report this as a bug in Next.js.
            console.error('Route "'.concat(workStore.route, '" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.'));
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
    } else {
        if (dynamicValidation.hasAllowedDynamic === false && dynamicValidation.hasDynamicMetadata) {
            console.error('Route "'.concat(workStore.route, '" has a `generateMetadata` that depends on Request data (`cookies()`, etc...) or uncached external data (`fetch(...)`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata'));
            throw new _staticgenerationbailout.StaticGenBailoutError();
        }
    }
} //# sourceMappingURL=dynamic-rendering.js.map
}}),
"[project]/node_modules/next/dist/server/dev/hot-reloader-types.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "HMR_ACTIONS_SENT_TO_BROWSER", {
    enumerable: true,
    get: function() {
        return HMR_ACTIONS_SENT_TO_BROWSER;
    }
});
var HMR_ACTIONS_SENT_TO_BROWSER = /*#__PURE__*/ function(HMR_ACTIONS_SENT_TO_BROWSER) {
    HMR_ACTIONS_SENT_TO_BROWSER["ADDED_PAGE"] = "addedPage";
    HMR_ACTIONS_SENT_TO_BROWSER["REMOVED_PAGE"] = "removedPage";
    HMR_ACTIONS_SENT_TO_BROWSER["RELOAD_PAGE"] = "reloadPage";
    HMR_ACTIONS_SENT_TO_BROWSER["SERVER_COMPONENT_CHANGES"] = "serverComponentChanges";
    HMR_ACTIONS_SENT_TO_BROWSER["MIDDLEWARE_CHANGES"] = "middlewareChanges";
    HMR_ACTIONS_SENT_TO_BROWSER["CLIENT_CHANGES"] = "clientChanges";
    HMR_ACTIONS_SENT_TO_BROWSER["SERVER_ONLY_CHANGES"] = "serverOnlyChanges";
    HMR_ACTIONS_SENT_TO_BROWSER["SYNC"] = "sync";
    HMR_ACTIONS_SENT_TO_BROWSER["BUILT"] = "built";
    HMR_ACTIONS_SENT_TO_BROWSER["BUILDING"] = "building";
    HMR_ACTIONS_SENT_TO_BROWSER["DEV_PAGES_MANIFEST_UPDATE"] = "devPagesManifestUpdate";
    HMR_ACTIONS_SENT_TO_BROWSER["TURBOPACK_MESSAGE"] = "turbopack-message";
    HMR_ACTIONS_SENT_TO_BROWSER["SERVER_ERROR"] = "serverError";
    HMR_ACTIONS_SENT_TO_BROWSER["TURBOPACK_CONNECTED"] = "turbopack-connected";
    HMR_ACTIONS_SENT_TO_BROWSER["ISR_MANIFEST"] = "isrManifest";
    HMR_ACTIONS_SENT_TO_BROWSER["DEV_INDICATOR"] = "devIndicator";
    return HMR_ACTIONS_SENT_TO_BROWSER;
}({}); //# sourceMappingURL=hot-reloader-types.js.map
}}),
}]);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFtdLAogICJzZWN0aW9ucyI6IFsKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9idWlsZC9wb2x5ZmlsbHMvcHJvY2Vzcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9XG4gIGdsb2JhbC5wcm9jZXNzPy5lbnYgJiYgdHlwZW9mIGdsb2JhbC5wcm9jZXNzPy5lbnYgPT09ICdvYmplY3QnXG4gICAgPyBnbG9iYWwucHJvY2Vzc1xuICAgIDogKHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzJykgYXMgdHlwZW9mIGltcG9ydCgnbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MnKSlcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJtb2R1bGUiLCJleHBvcnRzIiwicHJvY2VzcyIsImVudiIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiJJQUNFQSxpQkFBOEJBO0FBRGhDQyxPQUFPQyxPQUFPLEdBQ1pGLENBQUFBLENBQUFBLGtCQUFBQSw0Q0FBT0csT0FBTyxLQUFBLE9BQUEsS0FBQSxJQUFkSCxnQkFBZ0JJLEdBQUcsS0FBSSxPQUFBLENBQUEsQ0FBT0osbUJBQUFBLDRDQUFPRyxPQUFPLEtBQUEsT0FBQSxLQUFBLElBQWRILGlCQUFnQkksR0FBRyxNQUFLLFdBQ2xESiw0Q0FBT0csT0FBTyxHQUNiRSxRQUFRIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvcG9seWZpbGwtbW9kdWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidHJpbVN0YXJ0XCJpbiBTdHJpbmcucHJvdG90eXBlfHwoU3RyaW5nLnByb3RvdHlwZS50cmltU3RhcnQ9U3RyaW5nLnByb3RvdHlwZS50cmltTGVmdCksXCJ0cmltRW5kXCJpbiBTdHJpbmcucHJvdG90eXBlfHwoU3RyaW5nLnByb3RvdHlwZS50cmltRW5kPVN0cmluZy5wcm90b3R5cGUudHJpbVJpZ2h0KSxcImRlc2NyaXB0aW9uXCJpbiBTeW1ib2wucHJvdG90eXBlfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoU3ltYm9sLnByb3RvdHlwZSxcImRlc2NyaXB0aW9uXCIse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXt2YXIgdD0vXFwoKC4qKVxcKS8uZXhlYyh0aGlzLnRvU3RyaW5nKCkpO3JldHVybiB0P3RbMV06dm9pZCAwfX0pLEFycmF5LnByb3RvdHlwZS5mbGF0fHwoQXJyYXkucHJvdG90eXBlLmZsYXQ9ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj10aGlzLmNvbmNhdC5hcHBseShbXSx0aGlzKSx0PjEmJnIuc29tZShBcnJheS5pc0FycmF5KT9yLmZsYXQodC0xKTpyfSxBcnJheS5wcm90b3R5cGUuZmxhdE1hcD1mdW5jdGlvbih0LHIpe3JldHVybiB0aGlzLm1hcCh0LHIpLmZsYXQoKX0pLFByb21pc2UucHJvdG90eXBlLmZpbmFsbHl8fChQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5PWZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpcmV0dXJuIHRoaXMudGhlbih0LHQpO3ZhciByPXRoaXMuY29uc3RydWN0b3J8fFByb21pc2U7cmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbihuKXtyZXR1cm4gci5yZXNvbHZlKHQoKSkudGhlbihmdW5jdGlvbigpe3JldHVybiBufSl9LGZ1bmN0aW9uKG4pe3JldHVybiByLnJlc29sdmUodCgpKS50aGVuKGZ1bmN0aW9uKCl7dGhyb3cgbn0pfSl9KSxPYmplY3QuZnJvbUVudHJpZXN8fChPYmplY3QuZnJvbUVudHJpZXM9ZnVuY3Rpb24odCl7cmV0dXJuIEFycmF5LmZyb20odCkucmVkdWNlKGZ1bmN0aW9uKHQscil7cmV0dXJuIHRbclswXV09clsxXSx0fSx7fSl9KSxBcnJheS5wcm90b3R5cGUuYXR8fChBcnJheS5wcm90b3R5cGUuYXQ9ZnVuY3Rpb24odCl7dmFyIHI9TWF0aC50cnVuYyh0KXx8MDtpZihyPDAmJihyKz10aGlzLmxlbmd0aCksIShyPDB8fHI+PXRoaXMubGVuZ3RoKSlyZXR1cm4gdGhpc1tyXX0pLE9iamVjdC5oYXNPd258fChPYmplY3QuaGFzT3duPWZ1bmN0aW9uKHQscil7aWYobnVsbD09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XCIpO3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoT2JqZWN0KHQpLHIpfSksXCJjYW5QYXJzZVwiaW4gVVJMfHwoVVJMLmNhblBhcnNlPWZ1bmN0aW9uKHQscil7dHJ5e3JldHVybiEhbmV3IFVSTCh0LHIpfWNhdGNoKHQpe3JldHVybiExfX0pO1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGVBQWMsT0FBTyxTQUFTLElBQUUsQ0FBQyxPQUFPLFNBQVMsQ0FBQyxTQUFTLEdBQUMsT0FBTyxTQUFTLENBQUMsUUFBUSxHQUFFLGFBQVksT0FBTyxTQUFTLElBQUUsQ0FBQyxPQUFPLFNBQVMsQ0FBQyxPQUFPLEdBQUMsT0FBTyxTQUFTLENBQUMsU0FBUyxHQUFFLGlCQUFnQixPQUFPLFNBQVMsSUFBRSxPQUFPLGNBQWMsQ0FBQyxPQUFPLFNBQVMsRUFBQyxlQUFjO0lBQUMsY0FBYSxDQUFDO0lBQUUsS0FBSTtRQUFXLElBQUksSUFBRSxXQUFXLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUTtRQUFJLE9BQU8sSUFBRSxDQUFDLENBQUMsRUFBRSxHQUFDLEtBQUs7SUFBQztBQUFDLElBQUcsTUFBTSxTQUFTLENBQUMsSUFBSSxJQUFFLENBQUMsTUFBTSxTQUFTLENBQUMsSUFBSSxHQUFDLFNBQVMsQ0FBQyxFQUFDLENBQUM7SUFBRSxPQUFPLElBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFDLElBQUksR0FBRSxJQUFFLEtBQUcsRUFBRSxJQUFJLENBQUMsTUFBTSxPQUFPLElBQUUsRUFBRSxJQUFJLENBQUMsSUFBRSxLQUFHO0FBQUMsR0FBRSxNQUFNLFNBQVMsQ0FBQyxPQUFPLEdBQUMsU0FBUyxDQUFDLEVBQUMsQ0FBQztJQUFFLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFFLEdBQUcsSUFBSTtBQUFFLENBQUMsR0FBRSxRQUFRLFNBQVMsQ0FBQyxPQUFPLElBQUUsQ0FBQyxRQUFRLFNBQVMsQ0FBQyxPQUFPLEdBQUMsU0FBUyxDQUFDO0lBQUUsSUFBRyxjQUFZLE9BQU8sR0FBRSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRTtJQUFHLElBQUksSUFBRSxJQUFJLENBQUMsV0FBVyxJQUFFO0lBQVEsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsS0FBSyxJQUFJLENBQUM7WUFBVyxPQUFPO1FBQUM7SUFBRSxHQUFFLFNBQVMsQ0FBQztRQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsS0FBSyxJQUFJLENBQUM7WUFBVyxNQUFNO1FBQUM7SUFBRTtBQUFFLENBQUMsR0FBRSxPQUFPLFdBQVcsSUFBRSxDQUFDLE9BQU8sV0FBVyxHQUFDLFNBQVMsQ0FBQztJQUFFLE9BQU8sTUFBTSxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUMsQ0FBQztRQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFDO0lBQUMsR0FBRSxDQUFDO0FBQUUsQ0FBQyxHQUFFLE1BQU0sU0FBUyxDQUFDLEVBQUUsSUFBRSxDQUFDLE1BQU0sU0FBUyxDQUFDLEVBQUUsR0FBQyxTQUFTLENBQUM7SUFBRSxJQUFJLElBQUUsS0FBSyxLQUFLLENBQUMsTUFBSTtJQUFFLElBQUcsSUFBRSxLQUFHLENBQUMsS0FBRyxJQUFJLENBQUMsTUFBTSxHQUFFLENBQUMsQ0FBQyxJQUFFLEtBQUcsS0FBRyxJQUFJLENBQUMsTUFBTSxHQUFFLE9BQU8sSUFBSSxDQUFDLEVBQUU7QUFBQSxDQUFDLEdBQUUsT0FBTyxNQUFNLElBQUUsQ0FBQyxPQUFPLE1BQU0sR0FBQyxTQUFTLENBQUMsRUFBQyxDQUFDO0lBQUUsSUFBRyxRQUFNLEdBQUUsTUFBTSxJQUFJLFVBQVU7SUFBOEMsT0FBTyxPQUFPLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBRztBQUFFLENBQUMsR0FBRSxjQUFhLE9BQUssQ0FBQyxJQUFJLFFBQVEsR0FBQyxTQUFTLENBQUMsRUFBQyxDQUFDO0lBQUUsSUFBRztRQUFDLE9BQU0sQ0FBQyxDQUFDLElBQUksSUFBSSxHQUFFO0lBQUUsRUFBQyxPQUFNLEdBQUU7UUFBQyxPQUFNLENBQUM7SUFBQztBQUFDLENBQUMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNTksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9pcy1wbGFpbi1vYmplY3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGdldE9iamVjdENsYXNzTGFiZWwodmFsdWU6IGFueSk6IHN0cmluZyB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgaWYgKGdldE9iamVjdENsYXNzTGFiZWwodmFsdWUpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKVxuXG4gIC8qKlxuICAgKiB0aGlzIHVzZWQgdG8gYmUgcHJldmlvdXNseTpcbiAgICpcbiAgICogYHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlYFxuICAgKlxuICAgKiBidXQgRWRnZSBSdW50aW1lIGV4cG9zZSBPYmplY3QgZnJvbSB2bSwgYmVpbmcgdGhhdCBraW5kIG9mIHR5cGUtY2hlY2tpbmcgd3JvbmdseSBmYWlsLlxuICAgKlxuICAgKiBJdCB3YXMgY2hhbmdlZCB0byB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBzaW5jZSBpdCdzIHJlc2lsaWVudCB0byBzZXJpYWxpemF0aW9uLlxuICAgKi9cbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKVxufVxuIl0sIm5hbWVzIjpbImdldE9iamVjdENsYXNzTGFiZWwiLCJpc1BsYWluT2JqZWN0IiwidmFsdWUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJnZXRQcm90b3R5cGVPZiIsImhhc093blByb3BlcnR5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQUFnQkEsbUJBQW1CLEVBQUE7ZUFBbkJBOztJQUlBQyxhQUFhLEVBQUE7ZUFBYkE7OztBQUpULFNBQVNELG9CQUFvQkUsS0FBVTtJQUM1QyxPQUFPQyxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDSjtBQUN4QztBQUVPLFNBQVNELGNBQWNDLEtBQVU7SUFDdEMsSUFBSUYsb0JBQW9CRSxXQUFXLG1CQUFtQjtRQUNwRCxPQUFPO0lBQ1Q7SUFFQSxNQUFNRSxZQUFZRCxPQUFPSSxjQUFjLENBQUNMO0lBRXhDOzs7Ozs7OztHQVFDLEdBQ0QsT0FBT0UsY0FBYyxRQUFRQSxVQUFVSSxjQUFjLENBQUM7QUFDeEQiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTA0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvbGF6eS1keW5hbWljL2JhaWxvdXQtdG8tY3NyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgaGFzIHRvIGJlIGEgc2hhcmVkIG1vZHVsZSB3aGljaCBpcyBzaGFyZWQgYmV0d2VlbiBjbGllbnQgY29tcG9uZW50IGVycm9yIGJvdW5kYXJ5IGFuZCBkeW5hbWljIGNvbXBvbmVudFxuY29uc3QgQkFJTE9VVF9UT19DU1IgPSAnQkFJTE9VVF9UT19DTElFTlRfU0lERV9SRU5ERVJJTkcnXG5cbi8qKiBBbiBlcnJvciB0aGF0IHNob3VsZCBiZSB0aHJvd24gd2hlbiB3ZSB3YW50IHRvIGJhaWwgb3V0IHRvIGNsaWVudC1zaWRlIHJlbmRlcmluZy4gKi9cbmV4cG9ydCBjbGFzcyBCYWlsb3V0VG9DU1JFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHVibGljIHJlYWRvbmx5IGRpZ2VzdCA9IEJBSUxPVVRfVE9fQ1NSXG5cbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHJlYXNvbjogc3RyaW5nKSB7XG4gICAgc3VwZXIoYEJhaWwgb3V0IHRvIGNsaWVudC1zaWRlIHJlbmRlcmluZzogJHtyZWFzb259YClcbiAgfVxufVxuXG4vKiogQ2hlY2tzIGlmIGEgcGFzc2VkIGFyZ3VtZW50IGlzIGFuIGVycm9yIHRoYXQgaXMgdGhyb3duIGlmIHdlIHdhbnQgdG8gYmFpbCBvdXQgdG8gY2xpZW50LXNpZGUgcmVuZGVyaW5nLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmFpbG91dFRvQ1NSRXJyb3IoZXJyOiB1bmtub3duKTogZXJyIGlzIEJhaWxvdXRUb0NTUkVycm9yIHtcbiAgaWYgKHR5cGVvZiBlcnIgIT09ICdvYmplY3QnIHx8IGVyciA9PT0gbnVsbCB8fCAhKCdkaWdlc3QnIGluIGVycikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBlcnIuZGlnZXN0ID09PSBCQUlMT1VUX1RPX0NTUlxufVxuIl0sIm5hbWVzIjpbIkJhaWxvdXRUb0NTUkVycm9yIiwiaXNCYWlsb3V0VG9DU1JFcnJvciIsIkJBSUxPVVRfVE9fQ1NSIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsInJlYXNvbiIsImRpZ2VzdCIsImVyciJdLCJtYXBwaW5ncyI6IkFBQUEsK0dBQStHOzs7Ozs7Ozs7Ozs7Ozs7SUFJbEdBLGlCQUFpQixFQUFBO2VBQWpCQTs7SUFTR0MsbUJBQW1CLEVBQUE7ZUFBbkJBOzs7QUFaaEIsTUFBTUMsaUJBQWlCO0FBR2hCLE1BQU1GLDBCQUEwQkc7SUFHckNDLFlBQTRCQyxNQUFjLENBQUU7UUFDMUMsS0FBSyxDQUFFLHdDQUFxQ0EsU0FBQUEsSUFBQUEsQ0FEbEJBLE1BQUFBLEdBQUFBLFFBQUFBLElBQUFBLENBRlpDLE1BQUFBLEdBQVNKO0lBSXpCO0FBQ0Y7QUFHTyxTQUFTRCxvQkFBb0JNLEdBQVk7SUFDOUMsSUFBSSxPQUFPQSxRQUFRLFlBQVlBLFFBQVEsUUFBUSxDQUFFLENBQUEsWUFBWUEsR0FBRSxHQUFJO1FBQ2pFLE9BQU87SUFDVDtJQUVBLE9BQU9BLElBQUlELE1BQU0sS0FBS0o7QUFDeEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTQ0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvZXJyb3Itc291cmNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHN5bWJvbEVycm9yID0gU3ltYm9sLmZvcignTmV4dGpzRXJyb3InKVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXJyb3JTb3VyY2UoZXJyb3I6IEVycm9yKTogJ3NlcnZlcicgfCAnZWRnZS1zZXJ2ZXInIHwgbnVsbCB7XG4gIHJldHVybiAoZXJyb3IgYXMgYW55KVtzeW1ib2xFcnJvcl0gfHwgbnVsbFxufVxuXG5leHBvcnQgdHlwZSBFcnJvclNvdXJjZVR5cGUgPSAnZWRnZS1zZXJ2ZXInIHwgJ3NlcnZlcidcblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29yYXRlU2VydmVyRXJyb3IoZXJyb3I6IEVycm9yLCB0eXBlOiBFcnJvclNvdXJjZVR5cGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9yLCBzeW1ib2xFcnJvciwge1xuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB0eXBlLFxuICB9KVxufVxuIl0sIm5hbWVzIjpbImRlY29yYXRlU2VydmVyRXJyb3IiLCJnZXRFcnJvclNvdXJjZSIsInN5bWJvbEVycm9yIiwiU3ltYm9sIiwiZm9yIiwiZXJyb3IiLCJ0eXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ2YWx1ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUFRZ0JBLG1CQUFtQixFQUFBO2VBQW5CQTs7SUFOQUMsY0FBYyxFQUFBO2VBQWRBOzs7QUFGaEIsTUFBTUMsY0FBY0MsT0FBT0MsR0FBRyxDQUFDO0FBRXhCLFNBQVNILGVBQWVJLEtBQVk7SUFDekMsT0FBUUEsS0FBYSxDQUFDSCxZQUFZLElBQUk7QUFDeEM7QUFJTyxTQUFTRixvQkFBb0JLLEtBQVksRUFBRUMsSUFBcUI7SUFDckVDLE9BQU9DLGNBQWMsQ0FBQ0gsT0FBT0gsYUFBYTtRQUN4Q08sVUFBVTtRQUNWQyxZQUFZO1FBQ1pDLGNBQWM7UUFDZEMsT0FBT047SUFDVDtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE4MywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL2hlYWQtbWFuYWdlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IEhlYWRNYW5hZ2VyQ29udGV4dDogUmVhY3QuQ29udGV4dDx7XG4gIHVwZGF0ZUhlYWQ/OiAoc3RhdGU6IGFueSkgPT4gdm9pZFxuICBtb3VudGVkSW5zdGFuY2VzPzogYW55XG4gIHVwZGF0ZVNjcmlwdHM/OiAoc3RhdGU6IGFueSkgPT4gdm9pZFxuICBzY3JpcHRzPzogYW55XG4gIGdldElzU3NyPzogKCkgPT4gYm9vbGVhblxuXG4gIC8vIFVzZWQgaW4gYXBwIGRpcmVjdG9yeSwgdG8gcmVuZGVyIHNjcmlwdCB0YWdzIGFzIHNlcnZlciBjb21wb25lbnRzLlxuICBhcHBEaXI/OiBib29sZWFuXG4gIG5vbmNlPzogc3RyaW5nXG59PiA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIEhlYWRNYW5hZ2VyQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdIZWFkTWFuYWdlckNvbnRleHQnXG59XG4iXSwibmFtZXMiOlsiSGVhZE1hbmFnZXJDb250ZXh0IiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZGlzcGxheU5hbWUiXSwibWFwcGluZ3MiOiJBQWNJRyxRQUFRQyxHQUFHLENBQUNDLFFBQVEsS0FBSzs7Ozs7K0JBWmhCTCxzQkFBQUE7OztlQUFBQTs7OztnRUFGSztBQUVYLE1BQU1BLHFCQVVSQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBQyxDQUFDO0FBRTFCLHdDQUEyQztJQUN6Q0YsbUJBQW1CTSxXQUFXLEdBQUc7QUFDbkMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjA2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgUGFyYW1zIH0gZnJvbSAnLi4vLi4vc2VydmVyL3JlcXVlc3QvcGFyYW1zJ1xuXG5leHBvcnQgY29uc3QgU2VhcmNoUGFyYW1zQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VVJMU2VhcmNoUGFyYW1zIHwgbnVsbD4obnVsbClcbmV4cG9ydCBjb25zdCBQYXRobmFtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PHN0cmluZyB8IG51bGw+KG51bGwpXG5leHBvcnQgY29uc3QgUGF0aFBhcmFtc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFBhcmFtcyB8IG51bGw+KG51bGwpXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFNlYXJjaFBhcmFtc0NvbnRleHQuZGlzcGxheU5hbWUgPSAnU2VhcmNoUGFyYW1zQ29udGV4dCdcbiAgUGF0aG5hbWVDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1BhdGhuYW1lQ29udGV4dCdcbiAgUGF0aFBhcmFtc0NvbnRleHQuZGlzcGxheU5hbWUgPSAnUGF0aFBhcmFtc0NvbnRleHQnXG59XG4iXSwibmFtZXMiOlsiUGF0aFBhcmFtc0NvbnRleHQiLCJQYXRobmFtZUNvbnRleHQiLCJTZWFyY2hQYXJhbXNDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRpc3BsYXlOYW1lIl0sIm1hcHBpbmdzIjoiQUFTSUksUUFBUUMsR0FBRyxDQUFDQyxRQUFRLEtBQUs7QUFUN0I7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBT2FOLGlCQUFpQixFQUFBO2VBQWpCQTs7SUFEQUMsZUFBZSxFQUFBO2VBQWZBOztJQURBQyxtQkFBbUIsRUFBQTtlQUFuQkE7Ozt1QkFIaUI7QUFHdkIsTUFBTUEsc0JBQXNCQyxDQUFBQSxHQUFBQSxPQUFBQSxhQUFhLEVBQXlCO0FBQ2xFLE1BQU1GLGtCQUFrQkUsQ0FBQUEsR0FBQUEsT0FBQUEsYUFBYSxFQUFnQjtBQUNyRCxNQUFNSCxvQkFBb0JHLENBQUFBLEdBQUFBLE9BQUFBLGFBQWEsRUFBZ0I7QUFFOUQsd0NBQTJDO0lBQ3pDRCxvQkFBb0JLLFdBQVcsR0FBRztJQUNsQ04sZ0JBQWdCTSxXQUFXLEdBQUc7SUFDOUJQLGtCQUFrQk8sV0FBVyxHQUFHO0FBQ2xDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI0OSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL2lzLXRoZW5hYmxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIGEgdmFsdWUgaXMgVGhlbmFibGUuXG4gKlxuICogQHBhcmFtIHByb21pc2UgdGhlIG1heWJlLXRoZW5hYmxlIHZhbHVlXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyB0aGVuYWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUaGVuYWJsZTxUID0gdW5rbm93bj4oXG4gIHByb21pc2U6IFByb21pc2U8VD4gfCBUXG4pOiBwcm9taXNlIGlzIFByb21pc2U8VD4ge1xuICByZXR1cm4gKFxuICAgIHByb21pc2UgIT09IG51bGwgJiZcbiAgICB0eXBlb2YgcHJvbWlzZSA9PT0gJ29iamVjdCcgJiZcbiAgICAndGhlbicgaW4gcHJvbWlzZSAmJlxuICAgIHR5cGVvZiBwcm9taXNlLnRoZW4gPT09ICdmdW5jdGlvbidcbiAgKVxufVxuIl0sIm5hbWVzIjpbImlzVGhlbmFibGUiLCJwcm9taXNlIiwidGhlbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0M7OzsrQkFDZUEsY0FBQUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsV0FDZEMsT0FBdUI7SUFFdkIsT0FDRUEsWUFBWSxRQUNaLE9BQU9BLFlBQVksWUFDbkIsVUFBVUEsV0FDVixPQUFPQSxRQUFRQyxJQUFJLEtBQUs7QUFFNUIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjcyLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvc2VnbWVudC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFNlZ21lbnQgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIGlzR3JvdXBTZWdtZW50KHNlZ21lbnQ6IHN0cmluZykge1xuICAvLyBVc2UgYXJyYXlbMF0gZm9yIHBlcmZvcm1hbnQgcHVycG9zZVxuICByZXR1cm4gc2VnbWVudFswXSA9PT0gJygnICYmIHNlZ21lbnQuZW5kc1dpdGgoJyknKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXJhbGxlbFJvdXRlU2VnbWVudChzZWdtZW50OiBzdHJpbmcpIHtcbiAgcmV0dXJuIHNlZ21lbnQuc3RhcnRzV2l0aCgnQCcpICYmIHNlZ21lbnQgIT09ICdAY2hpbGRyZW4nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRTZWFyY2hQYXJhbXNJZlBhZ2VTZWdtZW50KFxuICBzZWdtZW50OiBTZWdtZW50LFxuICBzZWFyY2hQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkPlxuKSB7XG4gIGNvbnN0IGlzUGFnZVNlZ21lbnQgPSBzZWdtZW50LmluY2x1ZGVzKFBBR0VfU0VHTUVOVF9LRVkpXG5cbiAgaWYgKGlzUGFnZVNlZ21lbnQpIHtcbiAgICBjb25zdCBzdHJpbmdpZmllZFF1ZXJ5ID0gSlNPTi5zdHJpbmdpZnkoc2VhcmNoUGFyYW1zKVxuICAgIHJldHVybiBzdHJpbmdpZmllZFF1ZXJ5ICE9PSAne30nXG4gICAgICA/IFBBR0VfU0VHTUVOVF9LRVkgKyAnPycgKyBzdHJpbmdpZmllZFF1ZXJ5XG4gICAgICA6IFBBR0VfU0VHTUVOVF9LRVlcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50XG59XG5cbmV4cG9ydCBjb25zdCBQQUdFX1NFR01FTlRfS0VZID0gJ19fUEFHRV9fJ1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VHTUVOVF9LRVkgPSAnX19ERUZBVUxUX18nXG4iXSwibmFtZXMiOlsiREVGQVVMVF9TRUdNRU5UX0tFWSIsIlBBR0VfU0VHTUVOVF9LRVkiLCJhZGRTZWFyY2hQYXJhbXNJZlBhZ2VTZWdtZW50IiwiaXNHcm91cFNlZ21lbnQiLCJpc1BhcmFsbGVsUm91dGVTZWdtZW50Iiwic2VnbWVudCIsImVuZHNXaXRoIiwic3RhcnRzV2l0aCIsInNlYXJjaFBhcmFtcyIsImlzUGFnZVNlZ21lbnQiLCJpbmNsdWRlcyIsInN0cmluZ2lmaWVkUXVlcnkiLCJKU09OIiwic3RyaW5naWZ5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztJQTRCYUEsbUJBQW1CLEVBQUE7ZUFBbkJBOztJQURBQyxnQkFBZ0IsRUFBQTtlQUFoQkE7O0lBaEJHQyw0QkFBNEIsRUFBQTtlQUE1QkE7O0lBVEFDLGNBQWMsRUFBQTtlQUFkQTs7SUFLQUMsc0JBQXNCLEVBQUE7ZUFBdEJBOzs7QUFMVCxTQUFTRCxlQUFlRSxPQUFlO0lBQzVDLHNDQUFzQztJQUN0QyxPQUFPQSxPQUFPLENBQUMsRUFBRSxLQUFLLE9BQU9BLFFBQVFDLFFBQVEsQ0FBQztBQUNoRDtBQUVPLFNBQVNGLHVCQUF1QkMsT0FBZTtJQUNwRCxPQUFPQSxRQUFRRSxVQUFVLENBQUMsUUFBUUYsWUFBWTtBQUNoRDtBQUVPLFNBQVNILDZCQUNkRyxPQUFnQixFQUNoQkcsWUFBMkQ7SUFFM0QsTUFBTUMsZ0JBQWdCSixRQUFRSyxRQUFRLENBQUNUO0lBRXZDLElBQUlRLGVBQWU7UUFDakIsTUFBTUUsbUJBQW1CQyxLQUFLQyxTQUFTLENBQUNMO1FBQ3hDLE9BQU9HLHFCQUFxQixPQUN4QlYsbUJBQW1CLE1BQU1VLG1CQUN6QlY7SUFDTjtJQUVBLE9BQU9JO0FBQ1Q7QUFFTyxNQUFNSixtQkFBbUI7QUFDekIsTUFBTUQsc0JBQXNCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDMyOCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL2hhc2gudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cDovL3d3dy5jc2UueW9ya3UuY2Evfm96L2hhc2guaHRtbFxuLy8gTW9yZSBzcGVjaWZpY2FsbHksIDMyLWJpdCBoYXNoIHZpYSBkamJ4b3Jcbi8vIChyZWY6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2VwbGF3bGVzcy81MjgxM2IxZDhhZDlhZjUxMGQ4NT9wZXJtYWxpbmtfY29tbWVudF9pZD0zMzY3NzY1I2dpc3Rjb21tZW50LTMzNjc3NjUpXG4vLyBUaGlzIGlzIGR1ZSB0byBudW1iZXIgdHlwZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHJ1c3QgZm9yIHR1cmJvcGFjayB0byBqcyBudW1iZXIgdHlwZXMsXG4vLyB3aGVyZSBydXN0IGRvZXMgbm90IGhhdmUgZWFzeSB3YXkgdG8gcmVwcmVlc250IGpzJ3MgNTMtYml0IGZsb2F0IG51bWJlciB0eXBlIGZvciB0aGUgbWF0Y2hpbmdcbi8vIG92ZXJmbG93IGJlaGF2aW9yLiBUaGlzIGlzIG1vcmUgYGNvcnJlY3RgIGluIHRlcm1zIG9mIGhhdmluZyBjYW5vbmljYWwgaGFzaCBhY3Jvc3MgZGlmZmVyZW50IHJ1bnRpbWUgLyBpbXBsZW1lbnRhdGlvblxuLy8gYXMgY2FuIGdhdXJhbnRlZSBkZXRlcm1pbnN0aWMgb3V0cHV0IGZyb20gMzJiaXQgaGFzaC5cbmV4cG9ydCBmdW5jdGlvbiBkamIySGFzaChzdHI6IHN0cmluZykge1xuICBsZXQgaGFzaCA9IDUzODFcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoYXNoID0gKChoYXNoIDw8IDUpICsgaGFzaCArIGNoYXIpICYgMHhmZmZmZmZmZlxuICB9XG4gIHJldHVybiBoYXNoID4+PiAwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoZXhIYXNoKHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBkamIySGFzaChzdHIpLnRvU3RyaW5nKDM2KS5zbGljZSgwLCA1KVxufVxuIl0sIm5hbWVzIjpbImRqYjJIYXNoIiwiaGV4SGFzaCIsInN0ciIsImhhc2giLCJpIiwibGVuZ3RoIiwiY2hhciIsImNoYXJDb2RlQXQiLCJ0b1N0cmluZyIsInNsaWNlIl0sIm1hcHBpbmdzIjoiQUFBQSx3Q0FBd0M7QUFDeEMsNENBQTRDO0FBQzVDLGlIQUFpSDtBQUNqSCx3RkFBd0Y7QUFDeEYsZ0dBQWdHO0FBQ2hHLHdIQUF3SDtBQUN4SCx3REFBd0Q7Ozs7Ozs7Ozs7Ozs7OztJQUN4Q0EsUUFBUSxFQUFBO2VBQVJBOztJQVNBQyxPQUFPLEVBQUE7ZUFBUEE7OztBQVRULFNBQVNELFNBQVNFLEdBQVc7SUFDbEMsSUFBSUMsT0FBTztJQUNYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixJQUFJRyxNQUFNLEVBQUVELElBQUs7UUFDbkMsTUFBTUUsT0FBT0osSUFBSUssVUFBVSxDQUFDSDtRQUM1QkQsT0FBU0EsQ0FBQUEsUUFBUSxDQUFBLElBQUtBLE9BQU9HLE9BQVE7SUFDdkM7SUFDQSxPQUFPSCxTQUFTO0FBQ2xCO0FBRU8sU0FBU0YsUUFBUUMsR0FBVztJQUNqQyxPQUFPRixTQUFTRSxLQUFLTSxRQUFRLENBQUMsSUFBSUMsS0FBSyxDQUFDLEdBQUc7QUFDN0MiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzczLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2NhY2hlLWJ1c3Rpbmctc2VhcmNoLXBhcmFtLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhleEhhc2ggfSBmcm9tICcuLi8uLi9oYXNoJ1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUNhY2hlQnVzdGluZ1NlYXJjaFBhcmFtKFxuICBwcmVmZXRjaEhlYWRlcjogc3RyaW5nIHwgc3RyaW5nW10gfCB1bmRlZmluZWQsXG4gIHNlZ21lbnRQcmVmZXRjaEhlYWRlcjogc3RyaW5nIHwgc3RyaW5nW10gfCB1bmRlZmluZWQsXG4gIHN0YXRlVHJlZUhlYWRlcjogc3RyaW5nIHwgc3RyaW5nW10gfCB1bmRlZmluZWQsXG4gIG5leHRVcmxIZWFkZXI6IHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkXG4pOiBzdHJpbmcge1xuICBpZiAoXG4gICAgcHJlZmV0Y2hIZWFkZXIgPT09IHVuZGVmaW5lZCAmJlxuICAgIHNlZ21lbnRQcmVmZXRjaEhlYWRlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgc3RhdGVUcmVlSGVhZGVyID09PSB1bmRlZmluZWQgJiZcbiAgICBuZXh0VXJsSGVhZGVyID09PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbiAgcmV0dXJuIGhleEhhc2goXG4gICAgW1xuICAgICAgcHJlZmV0Y2hIZWFkZXIgfHwgJzAnLFxuICAgICAgc2VnbWVudFByZWZldGNoSGVhZGVyIHx8ICcwJyxcbiAgICAgIHN0YXRlVHJlZUhlYWRlciB8fCAnMCcsXG4gICAgICBuZXh0VXJsSGVhZGVyIHx8ICcwJyxcbiAgICBdLmpvaW4oJywnKVxuICApXG59XG4iXSwibmFtZXMiOlsiY29tcHV0ZUNhY2hlQnVzdGluZ1NlYXJjaFBhcmFtIiwicHJlZmV0Y2hIZWFkZXIiLCJzZWdtZW50UHJlZmV0Y2hIZWFkZXIiLCJzdGF0ZVRyZWVIZWFkZXIiLCJuZXh0VXJsSGVhZGVyIiwidW5kZWZpbmVkIiwiaGV4SGFzaCIsImpvaW4iXSwibWFwcGluZ3MiOiI7OzsrQkFFZ0JBLGtDQUFBQTs7O2VBQUFBOzs7c0JBRlE7QUFFakIsU0FBU0EsK0JBQ2RDLGNBQTZDLEVBQzdDQyxxQkFBb0QsRUFDcERDLGVBQThDLEVBQzlDQyxhQUE0QztJQUU1QyxJQUNFSCxtQkFBbUJJLGFBQ25CSCwwQkFBMEJHLGFBQzFCRixvQkFBb0JFLGFBQ3BCRCxrQkFBa0JDLFdBQ2xCO1FBQ0EsT0FBTztJQUNUO0lBQ0EsT0FBT0MsQ0FBQUEsR0FBQUEsTUFBQUEsT0FBTyxFQUNaO1FBQ0VMLGtCQUFrQjtRQUNsQkMseUJBQXlCO1FBQ3pCQyxtQkFBbUI7UUFDbkJDLGlCQUFpQjtLQUNsQixDQUFDRyxJQUFJLENBQUM7QUFFWCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0MDAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9wYWdlLXBhdGgvZW5zdXJlLWxlYWRpbmctc2xhc2gudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBGb3IgYSBnaXZlbiBwYWdlIHBhdGgsIHRoaXMgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IHRoZXJlIGlzIGEgbGVhZGluZyBzbGFzaC5cbiAqIElmIHRoZXJlIGlzIG5vdCBhIGxlYWRpbmcgc2xhc2gsIG9uZSBpcyBhZGRlZCwgb3RoZXJ3aXNlIGl0IGlzIG5vb3AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVMZWFkaW5nU2xhc2gocGF0aDogc3RyaW5nKSB7XG4gIHJldHVybiBwYXRoLnN0YXJ0c1dpdGgoJy8nKSA/IHBhdGggOiBgLyR7cGF0aH1gXG59XG4iXSwibmFtZXMiOlsiZW5zdXJlTGVhZGluZ1NsYXNoIiwicGF0aCIsInN0YXJ0c1dpdGgiXSwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQzs7OytCQUNlQSxzQkFBQUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsbUJBQW1CQyxJQUFZO0lBQzdDLE9BQU9BLEtBQUtDLFVBQVUsQ0FBQyxPQUFPRCxPQUFRLE1BQUdBO0FBQzNDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDQyMSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hcHAtcGF0aHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZW5zdXJlTGVhZGluZ1NsYXNoIH0gZnJvbSAnLi4vLi4vcGFnZS1wYXRoL2Vuc3VyZS1sZWFkaW5nLXNsYXNoJ1xuaW1wb3J0IHsgaXNHcm91cFNlZ21lbnQgfSBmcm9tICcuLi8uLi9zZWdtZW50J1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYW4gYXBwIHJvdXRlIHNvIGl0IHJlcHJlc2VudHMgdGhlIGFjdHVhbCByZXF1ZXN0IHBhdGguIEVzc2VudGlhbGx5XG4gKiBwZXJmb3JtaW5nIHRoZSBmb2xsb3dpbmcgdHJhbnNmb3JtYXRpb25zOlxuICpcbiAqIC0gYC8oZGFzaGJvYXJkKS91c2VyL1tpZF0vcGFnZWAgdG8gYC91c2VyL1tpZF1gXG4gKiAtIGAvKGRhc2hib2FyZCkvYWNjb3VudC9wYWdlYCB0byBgL2FjY291bnRgXG4gKiAtIGAvdXNlci9baWRdL3BhZ2VgIHRvIGAvdXNlci9baWRdYFxuICogLSBgL2FjY291bnQvcGFnZWAgdG8gYC9hY2NvdW50YFxuICogLSBgL3BhZ2VgIHRvIGAvYFxuICogLSBgLyhkYXNoYm9hcmQpL3VzZXIvW2lkXS9yb3V0ZWAgdG8gYC91c2VyL1tpZF1gXG4gKiAtIGAvKGRhc2hib2FyZCkvYWNjb3VudC9yb3V0ZWAgdG8gYC9hY2NvdW50YFxuICogLSBgL3VzZXIvW2lkXS9yb3V0ZWAgdG8gYC91c2VyL1tpZF1gXG4gKiAtIGAvYWNjb3VudC9yb3V0ZWAgdG8gYC9hY2NvdW50YFxuICogLSBgL3JvdXRlYCB0byBgL2BcbiAqIC0gYC9gIHRvIGAvYFxuICpcbiAqIEBwYXJhbSByb3V0ZSB0aGUgYXBwIHJvdXRlIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMgdGhlIG5vcm1hbGl6ZWQgcGF0aG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUFwcFBhdGgocm91dGU6IHN0cmluZykge1xuICByZXR1cm4gZW5zdXJlTGVhZGluZ1NsYXNoKFxuICAgIHJvdXRlLnNwbGl0KCcvJykucmVkdWNlKChwYXRobmFtZSwgc2VnbWVudCwgaW5kZXgsIHNlZ21lbnRzKSA9PiB7XG4gICAgICAvLyBFbXB0eSBzZWdtZW50cyBhcmUgaWdub3JlZC5cbiAgICAgIGlmICghc2VnbWVudCkge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWVcbiAgICAgIH1cblxuICAgICAgLy8gR3JvdXBzIGFyZSBpZ25vcmVkLlxuICAgICAgaWYgKGlzR3JvdXBTZWdtZW50KHNlZ21lbnQpKSB7XG4gICAgICAgIHJldHVybiBwYXRobmFtZVxuICAgICAgfVxuXG4gICAgICAvLyBQYXJhbGxlbCBzZWdtZW50cyBhcmUgaWdub3JlZC5cbiAgICAgIGlmIChzZWdtZW50WzBdID09PSAnQCcpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lXG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBsYXN0IHNlZ21lbnQgKGlmIGl0J3MgYSBsZWFmKSBzaG91bGQgYmUgaWdub3JlZC5cbiAgICAgIGlmIChcbiAgICAgICAgKHNlZ21lbnQgPT09ICdwYWdlJyB8fCBzZWdtZW50ID09PSAncm91dGUnKSAmJlxuICAgICAgICBpbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoIC0gMVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBwYXRobmFtZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYCR7cGF0aG5hbWV9LyR7c2VnbWVudH1gXG4gICAgfSwgJycpXG4gIClcbn1cblxuLyoqXG4gKiBTdHJpcHMgdGhlIGAucnNjYCBleHRlbnNpb24gaWYgaXQncyBpbiB0aGUgcGF0aG5hbWUuXG4gKiBTaW5jZSB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgb24gZnVsbCB1cmxzIGl0IGNoZWNrcyBgP2AgZm9yIHNlYXJjaFBhcmFtcyBoYW5kbGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVJzY1VSTCh1cmw6IHN0cmluZykge1xuICByZXR1cm4gdXJsLnJlcGxhY2UoXG4gICAgL1xcLnJzYygkfFxcPykvLFxuICAgIC8vICQxIGVuc3VyZXMgYD9gIGlzIHByZXNlcnZlZFxuICAgICckMSdcbiAgKVxufVxuIl0sIm5hbWVzIjpbIm5vcm1hbGl6ZUFwcFBhdGgiLCJub3JtYWxpemVSc2NVUkwiLCJyb3V0ZSIsImVuc3VyZUxlYWRpbmdTbGFzaCIsInNwbGl0IiwicmVkdWNlIiwicGF0aG5hbWUiLCJzZWdtZW50IiwiaW5kZXgiLCJzZWdtZW50cyIsImlzR3JvdXBTZWdtZW50IiwibGVuZ3RoIiwidXJsIiwicmVwbGFjZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUFzQmdCQSxnQkFBZ0IsRUFBQTtlQUFoQkE7O0lBbUNBQyxlQUFlLEVBQUE7ZUFBZkE7OztvQ0F6RG1CO3lCQUNKO0FBcUJ4QixTQUFTRCxpQkFBaUJFLEtBQWE7SUFDNUMsT0FBT0MsQ0FBQUEsR0FBQUEsb0JBQUFBLGtCQUFrQixFQUN2QkQsTUFBTUUsS0FBSyxDQUFDLEtBQUtDLE1BQU0sQ0FBQyxDQUFDQyxVQUFVQyxTQUFTQyxPQUFPQztRQUNqRCw4QkFBOEI7UUFDOUIsSUFBSSxDQUFDRixTQUFTO1lBQ1osT0FBT0Q7UUFDVDtRQUVBLHNCQUFzQjtRQUN0QixJQUFJSSxDQUFBQSxHQUFBQSxTQUFBQSxjQUFjLEVBQUNILFVBQVU7WUFDM0IsT0FBT0Q7UUFDVDtRQUVBLGlDQUFpQztRQUNqQyxJQUFJQyxPQUFPLENBQUMsRUFBRSxLQUFLLEtBQUs7WUFDdEIsT0FBT0Q7UUFDVDtRQUVBLHVEQUF1RDtRQUN2RCxJQUNHQyxDQUFBQSxZQUFZLFVBQVVBLFlBQVksT0FBTSxLQUN6Q0MsVUFBVUMsU0FBU0UsTUFBTSxHQUFHLEdBQzVCO1lBQ0EsT0FBT0w7UUFDVDtRQUVBLE9BQVVBLFdBQVMsTUFBR0M7SUFDeEIsR0FBRztBQUVQO0FBTU8sU0FBU04sZ0JBQWdCVyxHQUFXO0lBQ3pDLE9BQU9BLElBQUlDLE9BQU8sQ0FDaEIsZUFDQSxBQUNBLDhCQUQ4QjtBQUdsQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA0NzQsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJjZXB0aW9uLXJvdXRlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBub3JtYWxpemVBcHBQYXRoIH0gZnJvbSAnLi9hcHAtcGF0aHMnXG5cbi8vIG9yZGVyIG1hdHRlcnMgaGVyZSwgdGhlIGZpcnN0IG1hdGNoIHdpbGwgYmUgdXNlZFxuZXhwb3J0IGNvbnN0IElOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTID0gW1xuICAnKC4uKSguLiknLFxuICAnKC4pJyxcbiAgJyguLiknLFxuICAnKC4uLiknLFxuXSBhcyBjb25zdFxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIFRPRE8tQVBQOiBhZGQgbW9yZSBzZXJpb3VzIHZhbGlkYXRpb25cbiAgcmV0dXJuIChcbiAgICBwYXRoXG4gICAgICAuc3BsaXQoJy8nKVxuICAgICAgLmZpbmQoKHNlZ21lbnQpID0+XG4gICAgICAgIElOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLmZpbmQoKG0pID0+IHNlZ21lbnQuc3RhcnRzV2l0aChtKSlcbiAgICAgICkgIT09IHVuZGVmaW5lZFxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0SW50ZXJjZXB0aW9uUm91dGVJbmZvcm1hdGlvbihwYXRoOiBzdHJpbmcpIHtcbiAgbGV0IGludGVyY2VwdGluZ1JvdXRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgbWFya2VyOiAodHlwZW9mIElOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTKVtudW1iZXJdIHwgdW5kZWZpbmVkLFxuICAgIGludGVyY2VwdGVkUm91dGU6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBwYXRoLnNwbGl0KCcvJykpIHtcbiAgICBtYXJrZXIgPSBJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUy5maW5kKChtKSA9PiBzZWdtZW50LnN0YXJ0c1dpdGgobSkpXG4gICAgaWYgKG1hcmtlcikge1xuICAgICAgO1tpbnRlcmNlcHRpbmdSb3V0ZSwgaW50ZXJjZXB0ZWRSb3V0ZV0gPSBwYXRoLnNwbGl0KG1hcmtlciwgMilcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKCFpbnRlcmNlcHRpbmdSb3V0ZSB8fCAhbWFya2VyIHx8ICFpbnRlcmNlcHRlZFJvdXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgaW50ZXJjZXB0aW9uIHJvdXRlOiAke3BhdGh9LiBNdXN0IGJlIGluIHRoZSBmb3JtYXQgLzxpbnRlcmNlcHRpbmcgcm91dGU+LyguLnwuLi58Li4pKC4uKS88aW50ZXJjZXB0ZWQgcm91dGU+YFxuICAgIClcbiAgfVxuXG4gIGludGVyY2VwdGluZ1JvdXRlID0gbm9ybWFsaXplQXBwUGF0aChpbnRlcmNlcHRpbmdSb3V0ZSkgLy8gbm9ybWFsaXplIHRoZSBwYXRoLCBlLmcuIC8oYmxvZykvZmVlZCAtPiAvZmVlZFxuXG4gIHN3aXRjaCAobWFya2VyKSB7XG4gICAgY2FzZSAnKC4pJzpcbiAgICAgIC8vICguKSBpbmRpY2F0ZXMgdGhhdCB3ZSBzaG91bGQgbWF0Y2ggd2l0aCBzaWJsaW5nIHJvdXRlcywgc28gd2UganVzdCBuZWVkIHRvIGFwcGVuZCB0aGUgaW50ZXJjZXB0ZWQgcm91dGUgdG8gdGhlIGludGVyY2VwdGluZyByb3V0ZVxuICAgICAgaWYgKGludGVyY2VwdGluZ1JvdXRlID09PSAnLycpIHtcbiAgICAgICAgaW50ZXJjZXB0ZWRSb3V0ZSA9IGAvJHtpbnRlcmNlcHRlZFJvdXRlfWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVyY2VwdGVkUm91dGUgPSBpbnRlcmNlcHRpbmdSb3V0ZSArICcvJyArIGludGVyY2VwdGVkUm91dGVcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnKC4uKSc6XG4gICAgICAvLyAoLi4pIGluZGljYXRlcyB0aGF0IHdlIHNob3VsZCBtYXRjaCBhdCBvbmUgbGV2ZWwgdXAsIHNvIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGludGVyY2VwdGluZyByb3V0ZVxuICAgICAgaWYgKGludGVyY2VwdGluZ1JvdXRlID09PSAnLycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIGludGVyY2VwdGlvbiByb3V0ZTogJHtwYXRofS4gQ2Fubm90IHVzZSAoLi4pIG1hcmtlciBhdCB0aGUgcm9vdCBsZXZlbCwgdXNlICguKSBpbnN0ZWFkLmBcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaW50ZXJjZXB0ZWRSb3V0ZSA9IGludGVyY2VwdGluZ1JvdXRlXG4gICAgICAgIC5zcGxpdCgnLycpXG4gICAgICAgIC5zbGljZSgwLCAtMSlcbiAgICAgICAgLmNvbmNhdChpbnRlcmNlcHRlZFJvdXRlKVxuICAgICAgICAuam9pbignLycpXG4gICAgICBicmVha1xuICAgIGNhc2UgJyguLi4pJzpcbiAgICAgIC8vICguLi4pIHdpbGwgbWF0Y2ggdGhlIHJvdXRlIHNlZ21lbnQgaW4gdGhlIHJvb3QgZGlyZWN0b3J5LCBzbyB3ZSBuZWVkIHRvIHVzZSB0aGUgcm9vdCBkaXJlY3RvcnkgdG8gcHJlcGVuZCB0aGUgaW50ZXJjZXB0ZWQgcm91dGVcbiAgICAgIGludGVyY2VwdGVkUm91dGUgPSAnLycgKyBpbnRlcmNlcHRlZFJvdXRlXG4gICAgICBicmVha1xuICAgIGNhc2UgJyguLikoLi4pJzpcbiAgICAgIC8vICguLikoLi4pIGluZGljYXRlcyB0aGF0IHdlIHNob3VsZCBtYXRjaCBhdCB0d28gbGV2ZWxzIHVwLCBzbyB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgbGFzdCB0d28gc2VnbWVudHMgb2YgdGhlIGludGVyY2VwdGluZyByb3V0ZVxuXG4gICAgICBjb25zdCBzcGxpdEludGVyY2VwdGluZ1JvdXRlID0gaW50ZXJjZXB0aW5nUm91dGUuc3BsaXQoJy8nKVxuICAgICAgaWYgKHNwbGl0SW50ZXJjZXB0aW5nUm91dGUubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIGludGVyY2VwdGlvbiByb3V0ZTogJHtwYXRofS4gQ2Fubm90IHVzZSAoLi4pKC4uKSBtYXJrZXIgYXQgdGhlIHJvb3QgbGV2ZWwgb3Igb25lIGxldmVsIHVwLmBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpbnRlcmNlcHRlZFJvdXRlID0gc3BsaXRJbnRlcmNlcHRpbmdSb3V0ZVxuICAgICAgICAuc2xpY2UoMCwgLTIpXG4gICAgICAgIC5jb25jYXQoaW50ZXJjZXB0ZWRSb3V0ZSlcbiAgICAgICAgLmpvaW4oJy8nKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhcmlhbnQ6IHVuZXhwZWN0ZWQgbWFya2VyJylcbiAgfVxuXG4gIHJldHVybiB7IGludGVyY2VwdGluZ1JvdXRlLCBpbnRlcmNlcHRlZFJvdXRlIH1cbn1cbiJdLCJuYW1lcyI6WyJJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUyIsImV4dHJhY3RJbnRlcmNlcHRpb25Sb3V0ZUluZm9ybWF0aW9uIiwiaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgiLCJwYXRoIiwic3BsaXQiLCJmaW5kIiwic2VnbWVudCIsIm0iLCJzdGFydHNXaXRoIiwidW5kZWZpbmVkIiwiaW50ZXJjZXB0aW5nUm91dGUiLCJtYXJrZXIiLCJpbnRlcmNlcHRlZFJvdXRlIiwiRXJyb3IiLCJub3JtYWxpemVBcHBQYXRoIiwic2xpY2UiLCJjb25jYXQiLCJqb2luIiwic3BsaXRJbnRlcmNlcHRpbmdSb3V0ZSIsImxlbmd0aCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0lBR2FBLDBCQUEwQixFQUFBO2VBQTFCQTs7SUFrQkdDLG1DQUFtQyxFQUFBO2VBQW5DQTs7SUFYQUMsMEJBQTBCLEVBQUE7ZUFBMUJBOzs7MEJBVmlCO0FBRzFCLE1BQU1GLDZCQUE2QjtJQUN4QztJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRU0sU0FBU0UsMkJBQTJCQyxJQUFZO0lBQ3JELHdDQUF3QztJQUN4QyxPQUNFQSxLQUNHQyxLQUFLLENBQUMsS0FDTkMsSUFBSSxDQUFDLENBQUNDLFVBQ0xOLDJCQUEyQkssSUFBSSxDQUFDLENBQUNFLElBQU1ELFFBQVFFLFVBQVUsQ0FBQ0QsU0FDdERFO0FBRVo7QUFFTyxTQUFTUixvQ0FBb0NFLElBQVk7SUFDOUQsSUFBSU8sbUJBQ0ZDLFFBQ0FDO0lBRUYsS0FBSyxNQUFNTixXQUFXSCxLQUFLQyxLQUFLLENBQUMsS0FBTTtRQUNyQ08sU0FBU1gsMkJBQTJCSyxJQUFJLENBQUMsQ0FBQ0UsSUFBTUQsUUFBUUUsVUFBVSxDQUFDRDtRQUNuRSxJQUFJSSxRQUFROztZQUNULENBQUNELG1CQUFtQkUsaUJBQWlCLEdBQUdULEtBQUtDLEtBQUssQ0FBQ08sUUFBUTtZQUM1RDtRQUNGO0lBQ0Y7SUFFQSxJQUFJLENBQUNELHFCQUFxQixDQUFDQyxVQUFVLENBQUNDLGtCQUFrQjtRQUN0RCxNQUFNLE9BQUEsY0FFTCxDQUZLLElBQUlDLE1BQ1AsaUNBQThCVixPQUFLLHNGQURoQyxxQkFBQTttQkFBQTt3QkFBQTswQkFBQTtRQUVOO0lBQ0Y7SUFFQU8sb0JBQW9CSSxDQUFBQSxHQUFBQSxVQUFBQSxnQkFBZ0IsRUFBQ0osbUJBQW1CLGlEQUFpRDs7SUFFekcsT0FBUUM7UUFDTixLQUFLO1lBQ0gsb0lBQW9JO1lBQ3BJLElBQUlELHNCQUFzQixLQUFLO2dCQUM3QkUsbUJBQW9CLE1BQUdBO1lBQ3pCLE9BQU87Z0JBQ0xBLG1CQUFtQkYsb0JBQW9CLE1BQU1FO1lBQy9DO1lBQ0E7UUFDRixLQUFLO1lBQ0gsdUhBQXVIO1lBQ3ZILElBQUlGLHNCQUFzQixLQUFLO2dCQUM3QixNQUFNLE9BQUEsY0FFTCxDQUZLLElBQUlHLE1BQ1AsaUNBQThCVixPQUFLLGlFQURoQyxxQkFBQTsyQkFBQTtnQ0FBQTtrQ0FBQTtnQkFFTjtZQUNGO1lBQ0FTLG1CQUFtQkYsa0JBQ2hCTixLQUFLLENBQUMsS0FDTlcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUNWQyxNQUFNLENBQUNKLGtCQUNQSyxJQUFJLENBQUM7WUFDUjtRQUNGLEtBQUs7WUFDSCxrSUFBa0k7WUFDbElMLG1CQUFtQixNQUFNQTtZQUN6QjtRQUNGLEtBQUs7WUFDSCxpSUFBaUk7WUFFakksTUFBTU0seUJBQXlCUixrQkFBa0JOLEtBQUssQ0FBQztZQUN2RCxJQUFJYyx1QkFBdUJDLE1BQU0sSUFBSSxHQUFHO2dCQUN0QyxNQUFNLE9BQUEsY0FFTCxDQUZLLElBQUlOLE1BQ1AsaUNBQThCVixPQUFLLG9FQURoQyxxQkFBQTsyQkFBQTtnQ0FBQTtrQ0FBQTtnQkFFTjtZQUNGO1lBRUFTLG1CQUFtQk0sdUJBQ2hCSCxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQ1ZDLE1BQU0sQ0FBQ0osa0JBQ1BLLElBQUksQ0FBQztZQUNSO1FBQ0Y7WUFDRSxNQUFNLE9BQUEsY0FBeUMsQ0FBekMsSUFBSUosTUFBTSxpQ0FBVixxQkFBQTt1QkFBQTs0QkFBQTs4QkFBQTtZQUF3QztJQUNsRDtJQUVBLE9BQU87UUFBRUg7UUFBbUJFO0lBQWlCO0FBQy9DIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDU4MywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHR5cGUgeyBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0IH0gZnJvbSAnLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuaW1wb3J0IHR5cGUge1xuICBGb2N1c0FuZFNjcm9sbFJlZixcbiAgUHJlZmV0Y2hLaW5kLFxufSBmcm9tICcuLi8uLi9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB0eXBlIHtcbiAgRmxpZ2h0Um91dGVyU3RhdGUsXG4gIEZsaWdodFNlZ21lbnRQYXRoLFxufSBmcm9tICcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IHR5cGUgQ2hpbGRTZWdtZW50TWFwID0gTWFwPHN0cmluZywgQ2FjaGVOb2RlPlxuXG4vKipcbiAqIENhY2hlIG5vZGUgdXNlZCBpbiBhcHAtcm91dGVyIC8gbGF5b3V0LXJvdXRlci5cbiAqL1xuZXhwb3J0IHR5cGUgQ2FjaGVOb2RlID0gUmVhZHlDYWNoZU5vZGUgfCBMYXp5Q2FjaGVOb2RlXG5cbmV4cG9ydCB0eXBlIExvYWRpbmdNb2R1bGVEYXRhID1cbiAgfCBbUmVhY3QuSlNYLkVsZW1lbnQsIFJlYWN0LlJlYWN0Tm9kZSwgUmVhY3QuUmVhY3ROb2RlXVxuICB8IG51bGxcblxuLyoqIHZpZXdwb3J0IG1ldGFkYXRhIG5vZGUgKi9cbmV4cG9ydCB0eXBlIEhlYWREYXRhID0gUmVhY3QuUmVhY3ROb2RlXG5cbmV4cG9ydCB0eXBlIExhenlDYWNoZU5vZGUgPSB7XG4gIC8qKlxuICAgKiBXaGVuIHJzYyBpcyBudWxsLCB0aGlzIGlzIGEgbGF6aWx5LWluaXRpYWxpemVkIGNhY2hlIG5vZGUuXG4gICAqXG4gICAqIElmIHRoZSBhcHAgYXR0ZW1wdHMgdG8gcmVuZGVyIGl0LCBpdCB0cmlnZ2VycyBhIGxhenkgZGF0YSBmZXRjaCxcbiAgICogcG9zdHBvbmVzIHRoZSByZW5kZXIsIGFuZCBzY2hlZHVsZXMgYW4gdXBkYXRlIHRvIGEgbmV3IHRyZWUuXG4gICAqXG4gICAqIFRPRE86IFRoaXMgbWVjaGFuaXNtIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIFBQUiBpcyBlbmFibGVkLCB0aG91Z2ggaXRcbiAgICogY3VycmVudGx5IGlzIGluIHNvbWUgY2FzZXMgdW50aWwgd2UndmUgaW1wbGVtZW50ZWQgcGFydGlhbFxuICAgKiBzZWdtZW50IGZldGNoaW5nLlxuICAgKi9cbiAgcnNjOiBudWxsXG5cbiAgLyoqXG4gICAqIEEgcHJlZmV0Y2hlZCB2ZXJzaW9uIG9mIHRoZSBzZWdtZW50IGRhdGEuIFNlZSBleHBsYW5hdGlvbiBpbiBjb3JyZXNwb25kaW5nXG4gICAqIGZpZWxkIG9mIFJlYWR5Q2FjaGVOb2RlIChiZWxvdykuXG4gICAqXG4gICAqIFNpbmNlIExhenlDYWNoZU5vZGUgbW9zdGx5IG9ubHkgZXhpc3RzIGluIHRoZSBub24tUFBSIGltcGxlbWVudGF0aW9uLCB0aGlzXG4gICAqIHdpbGwgdXN1YWxseSBiZSBudWxsLCBidXQgaXQgY291bGQgaGF2ZSBiZWVuIGNsb25lZCBmcm9tIGEgcHJldmlvdXNcbiAgICogQ2FjaGVOb2RlIHRoYXQgd2FzIGNyZWF0ZWQgYnkgdGhlIFBQUiBpbXBsZW1lbnRhdGlvbi4gRXZlbnR1YWxseSB3ZSB3YW50XG4gICAqIHRvIG1pZ3JhdGUgZXZlcnl0aGluZyBhd2F5IGZyb20gTGF6eUNhY2hlTm9kZSBlbnRpcmVseS5cbiAgICovXG4gIHByZWZldGNoUnNjOiBSZWFjdC5SZWFjdE5vZGVcblxuICAvKipcbiAgICogQSBwZW5kaW5nIHJlc3BvbnNlIGZvciB0aGUgbGF6eSBkYXRhIGZldGNoLiBJZiB0aGlzIGlzIG5vdCBwcmVzZW50XG4gICAqIGR1cmluZyByZW5kZXIsIGl0IGlzIGxhemlseSBjcmVhdGVkLlxuICAgKi9cbiAgbGF6eURhdGE6IFByb21pc2U8RmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdD4gfCBudWxsXG5cbiAgcHJlZmV0Y2hIZWFkOiBIZWFkRGF0YSB8IG51bGxcblxuICBoZWFkOiBIZWFkRGF0YVxuXG4gIGxvYWRpbmc6IExvYWRpbmdNb2R1bGVEYXRhIHwgUHJvbWlzZTxMb2FkaW5nTW9kdWxlRGF0YT5cblxuICAvKipcbiAgICogQ2hpbGQgcGFyYWxsZWwgcm91dGVzLlxuICAgKi9cbiAgcGFyYWxsZWxSb3V0ZXM6IE1hcDxzdHJpbmcsIENoaWxkU2VnbWVudE1hcD5cblxuICAvKipcbiAgICogVGhlIHRpbWVzdGFtcCBvZiB0aGUgbmF2aWdhdGlvbiB0aGF0IGxhc3QgdXBkYXRlZCB0aGUgQ2FjaGVOb2RlJ3MgZGF0YS4gSWZcbiAgICogYSBDYWNoZU5vZGUgaXMgcmV1c2VkIGZyb20gYSBwcmV2aW91cyBuYXZpZ2F0aW9uLCB0aGlzIHZhbHVlIGlzIG5vdFxuICAgKiB1cGRhdGVkLiBVc2VkIHRvIHRyYWNrIHRoZSBzdGFsZW5lc3Mgb2YgdGhlIGRhdGEuXG4gICAqL1xuICBuYXZpZ2F0ZWRBdDogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIFJlYWR5Q2FjaGVOb2RlID0ge1xuICAvKipcbiAgICogV2hlbiByc2MgaXMgbm90IG51bGwsIGl0IHJlcHJlc2VudHMgdGhlIFJTQyBkYXRhIGZvciB0aGVcbiAgICogY29ycmVzcG9uZGluZyBzZWdtZW50LlxuICAgKlxuICAgKiBgbnVsbGAgaXMgYSB2YWxpZCBSZWFjdCBOb2RlIGJ1dCBiZWNhdXNlIHNlZ21lbnQgZGF0YSBpcyBhbHdheXMgYVxuICAgKiA8TGF5b3V0Um91dGVyPiBjb21wb25lbnQsIHdlIGNhbiB1c2UgYG51bGxgIHRvIHJlcHJlc2VudCBlbXB0eS5cbiAgICpcbiAgICogVE9ETzogRm9yIGFkZGl0aW9uYWwgdHlwZSBzYWZldHksIHVwZGF0ZSB0aGlzIHR5cGUgdG9cbiAgICogRXhjbHVkZTxSZWFjdC5SZWFjdE5vZGUsIG51bGw+LiBOZWVkIHRvIHVwZGF0ZSBjcmVhdGVFbXB0eUNhY2hlTm9kZSB0b1xuICAgKiBhY2NlcHQgcnNjIGFzIGFuIGFyZ3VtZW50LCBvciBqdXN0IGlubGluZSB0aGUgY2FsbGVycy5cbiAgICovXG4gIHJzYzogUmVhY3QuUmVhY3ROb2RlXG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzdGF0aWMgdmVyc2lvbiBvZiB0aGUgc2VnbWVudCB0aGF0IGNhbiBiZSBzaG93biBpbW1lZGlhdGVseSxcbiAgICogYW5kIG1heSBvciBtYXkgbm90IGNvbnRhaW4gZHluYW1pYyBob2xlcy4gSXQncyBwcmVmZXRjaGVkIGJlZm9yZSBhXG4gICAqIG5hdmlnYXRpb24gb2NjdXJzLlxuICAgKlxuICAgKiBEdXJpbmcgcmVuZGVyaW5nLCB3ZSB3aWxsIGNob29zZSB3aGV0aGVyIHRvIHJlbmRlciBgcnNjYCBvciBgcHJlZmV0Y2hSc2NgXG4gICAqIHdpdGggYHVzZURlZmVycmVkVmFsdWVgLiBBcyB3aXRoIHRoZSBgcnNjYCBmaWVsZCwgYSB2YWx1ZSBvZiBgbnVsbGAgbWVhbnNcbiAgICogbm8gdmFsdWUgd2FzIHByb3ZpZGVkLiBJbiB0aGlzIGNhc2UsIHRoZSBMYXlvdXRSb3V0ZXIgd2lsbCBnbyBzdHJhaWdodCB0b1xuICAgKiByZW5kZXJpbmcgdGhlIGByc2NgIHZhbHVlOyBpZiB0aGF0IG9uZSBpcyBhbHNvIG1pc3NpbmcsIGl0IHdpbGwgc3VzcGVuZCBhbmRcbiAgICogdHJpZ2dlciBhIGxhenkgZmV0Y2guXG4gICAqL1xuICBwcmVmZXRjaFJzYzogUmVhY3QuUmVhY3ROb2RlXG5cbiAgLyoqXG4gICAqIFRoZXJlIHNob3VsZCBuZXZlciBiZSBhIGxhenkgZGF0YSByZXF1ZXN0IGluIHRoaXMgY2FzZS5cbiAgICovXG4gIGxhenlEYXRhOiBudWxsXG4gIHByZWZldGNoSGVhZDogSGVhZERhdGEgfCBudWxsXG5cbiAgaGVhZDogSGVhZERhdGFcblxuICBsb2FkaW5nOiBMb2FkaW5nTW9kdWxlRGF0YSB8IFByb21pc2U8TG9hZGluZ01vZHVsZURhdGE+XG5cbiAgcGFyYWxsZWxSb3V0ZXM6IE1hcDxzdHJpbmcsIENoaWxkU2VnbWVudE1hcD5cblxuICBuYXZpZ2F0ZWRBdDogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVPcHRpb25zIHtcbiAgc2Nyb2xsPzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByZWZldGNoT3B0aW9ucyB7XG4gIGtpbmQ6IFByZWZldGNoS2luZFxuICBvbkludmFsaWRhdGU/OiAoKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXBwUm91dGVySW5zdGFuY2Uge1xuICAvKipcbiAgICogTmF2aWdhdGUgdG8gdGhlIHByZXZpb3VzIGhpc3RvcnkgZW50cnkuXG4gICAqL1xuICBiYWNrKCk6IHZvaWRcbiAgLyoqXG4gICAqIE5hdmlnYXRlIHRvIHRoZSBuZXh0IGhpc3RvcnkgZW50cnkuXG4gICAqL1xuICBmb3J3YXJkKCk6IHZvaWRcbiAgLyoqXG4gICAqIFJlZnJlc2ggdGhlIGN1cnJlbnQgcGFnZS5cbiAgICovXG4gIHJlZnJlc2goKTogdm9pZFxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgY3VycmVudCBwYWdlLiBVc2UgaW4gZGV2ZWxvcG1lbnQgb25seS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBobXJSZWZyZXNoKCk6IHZvaWRcbiAgLyoqXG4gICAqIE5hdmlnYXRlIHRvIHRoZSBwcm92aWRlZCBocmVmLlxuICAgKiBQdXNoZXMgYSBuZXcgaGlzdG9yeSBlbnRyeS5cbiAgICovXG4gIHB1c2goaHJlZjogc3RyaW5nLCBvcHRpb25zPzogTmF2aWdhdGVPcHRpb25zKTogdm9pZFxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gdGhlIHByb3ZpZGVkIGhyZWYuXG4gICAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IGhpc3RvcnkgZW50cnkuXG4gICAqL1xuICByZXBsYWNlKGhyZWY6IHN0cmluZywgb3B0aW9ucz86IE5hdmlnYXRlT3B0aW9ucyk6IHZvaWRcbiAgLyoqXG4gICAqIFByZWZldGNoIHRoZSBwcm92aWRlZCBocmVmLlxuICAgKi9cbiAgcHJlZmV0Y2goaHJlZjogc3RyaW5nLCBvcHRpb25zPzogUHJlZmV0Y2hPcHRpb25zKTogdm9pZFxufVxuXG5leHBvcnQgY29uc3QgQXBwUm91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8QXBwUm91dGVySW5zdGFuY2UgfCBudWxsPihcbiAgbnVsbFxuKVxuZXhwb3J0IGNvbnN0IExheW91dFJvdXRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PHtcbiAgcGFyZW50VHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgcGFyZW50Q2FjaGVOb2RlOiBDYWNoZU5vZGVcbiAgcGFyZW50U2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoIHwgbnVsbFxuICB1cmw6IHN0cmluZ1xufSB8IG51bGw+KG51bGwpXG5cbmV4cG9ydCBjb25zdCBHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDx7XG4gIHRyZWU6IEZsaWdodFJvdXRlclN0YXRlXG4gIGZvY3VzQW5kU2Nyb2xsUmVmOiBGb2N1c0FuZFNjcm9sbFJlZlxuICBuZXh0VXJsOiBzdHJpbmcgfCBudWxsXG59PihudWxsIGFzIGFueSlcblxuZXhwb3J0IGNvbnN0IFRlbXBsYXRlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8UmVhY3QuUmVhY3ROb2RlPihudWxsIGFzIGFueSlcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgQXBwUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdBcHBSb3V0ZXJDb250ZXh0J1xuICBMYXlvdXRSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0xheW91dFJvdXRlckNvbnRleHQnXG4gIEdsb2JhbExheW91dFJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCdcbiAgVGVtcGxhdGVDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1RlbXBsYXRlQ29udGV4dCdcbn1cblxuZXhwb3J0IGNvbnN0IE1pc3NpbmdTbG90Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8U2V0PHN0cmluZz4+KG5ldyBTZXQoKSlcbiJdLCJuYW1lcyI6WyJBcHBSb3V0ZXJDb250ZXh0IiwiR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsIkxheW91dFJvdXRlckNvbnRleHQiLCJNaXNzaW5nU2xvdENvbnRleHQiLCJUZW1wbGF0ZUNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJkaXNwbGF5TmFtZSIsIlNldCJdLCJtYXBwaW5ncyI6IkFBbUxJTyxRQUFRQyxHQUFHLENBQUNDLFFBQVEsS0FBSztBQW5MN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFpS2FULGdCQUFnQixFQUFBO2VBQWhCQTs7SUFVQUMseUJBQXlCLEVBQUE7ZUFBekJBOztJQVBBQyxtQkFBbUIsRUFBQTtlQUFuQkE7O0lBc0JBQyxrQkFBa0IsRUFBQTtlQUFsQkE7O0lBVEFDLGVBQWUsRUFBQTtlQUFmQTs7OztnRUF0S0s7QUFzSlgsTUFBTUosbUJBQW1CSyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FDakQ7QUFFSyxNQUFNSixzQkFBc0JHLE9BQUFBLE9BQUssQ0FBQ0MsYUFBYSxDQUs1QztBQUVILE1BQU1MLDRCQUE0QkksT0FBQUEsT0FBSyxDQUFDQyxhQUFhLENBSXpEO0FBRUksTUFBTUYsa0JBQWtCQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBa0I7QUFFcEUsd0NBQTJDO0lBQ3pDTixpQkFBaUJVLFdBQVcsR0FBRztJQUMvQlIsb0JBQW9CUSxXQUFXLEdBQUc7SUFDbENULDBCQUEwQlMsV0FBVyxHQUFHO0lBQ3hDTixnQkFBZ0JNLFdBQVcsR0FBRztBQUNoQztBQUVPLE1BQU1QLHFCQUFxQkUsT0FBQUEsT0FBSyxDQUFDQyxhQUFhLENBQWMsSUFBSUsiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNjM4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2h0bWwtYm90cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIHJlZ2V4IGNvbnRhaW5zIHRoZSBib3RzIHRoYXQgd2UgbmVlZCB0byBkbyBhIGJsb2NraW5nIHJlbmRlciBmb3IgYW5kIGNhbid0IHNhZmVseSBzdHJlYW0gdGhlIHJlc3BvbnNlXG4vLyBkdWUgdG8gaG93IHRoZXkgcGFyc2UgdGhlIERPTS4gRm9yIGV4YW1wbGUsIHRoZXkgbWlnaHQgZXhwbGljaXRseSBjaGVjayBmb3IgbWV0YWRhdGEgaW4gdGhlIGBoZWFkYCB0YWcsIHNvIHdlIGNhbid0IHN0cmVhbSBtZXRhZGF0YSB0YWdzIGFmdGVyIHRoZSBgaGVhZGAgd2FzIHNlbnQuXG5leHBvcnQgY29uc3QgSFRNTF9MSU1JVEVEX0JPVF9VQV9SRSA9XG4gIC9NZWRpYXBhcnRuZXJzLUdvb2dsZXxDaHJvbWUtTGlnaHRob3VzZXxTbHVycHxEdWNrRHVja0JvdHxiYWlkdXNwaWRlcnx5YW5kZXh8c29nb3V8Yml0bHlib3R8dHVtYmxyfHZrU2hhcmV8cXVvcmEgbGluayBwcmV2aWV3fHJlZGRpdGJvdHxpYV9hcmNoaXZlcnxCaW5nYm90fEJpbmdQcmV2aWV3fGFwcGxlYm90fGZhY2Vib29rZXh0ZXJuYWxoaXR8ZmFjZWJvb2tjYXRhbG9nfFR3aXR0ZXJib3R8TGlua2VkSW5Cb3R8U2xhY2tib3R8RGlzY29yZGJvdHxXaGF0c0FwcHxTa3lwZVVyaVByZXZpZXd8WWV0aS9pXG4iXSwibmFtZXMiOlsiSFRNTF9MSU1JVEVEX0JPVF9VQV9SRSJdLCJtYXBwaW5ncyI6IkFBQUEsNkdBQTZHO0FBQzdHLHNLQUFzSzs7OzsrQkFDekpBLDBCQUFBQTs7O2VBQUFBOzs7QUFBTixNQUFNQSx5QkFDWCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA2NTYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtYm90LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhUTUxfTElNSVRFRF9CT1RfVUFfUkUgfSBmcm9tICcuL2h0bWwtYm90cydcblxuLy8gQm90IGNyYXdsZXIgdGhhdCB3aWxsIHNwaW4gdXAgYSBoZWFkbGVzcyBicm93c2VyIGFuZCBleGVjdXRlIEpTLlxuLy8gQnkgZGVmYXVsdCwgb25seSBnb29nbGVib3RzIGFyZSBjb25zaWRlcmVkIGFzIERPTSBib3RzLiBCbG93IGlzIHdoZXJlIHRoZSByZWdleCBpcyBjb21wdXRlZCBmcm9tOlxuLy8geC1yZWY6IGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3NlYXJjaC9kb2NzL2NyYXdsaW5nLWluZGV4aW5nL2dvb2dsZS1jb21tb24tY3Jhd2xlcnNcbmNvbnN0IEhFQURMRVNTX0JST1dTRVJfQk9UX1VBX1JFID0gL2dvb2dsZS9pXG5cbmV4cG9ydCBjb25zdCBIVE1MX0xJTUlURURfQk9UX1VBX1JFX1NUUklORyA9IEhUTUxfTElNSVRFRF9CT1RfVUFfUkUuc291cmNlXG5cbmV4cG9ydCB7IEhUTUxfTElNSVRFRF9CT1RfVUFfUkUgfVxuXG5mdW5jdGlvbiBpc0RvbUJvdFVBKHVzZXJBZ2VudDogc3RyaW5nKSB7XG4gIHJldHVybiBIRUFETEVTU19CUk9XU0VSX0JPVF9VQV9SRS50ZXN0KHVzZXJBZ2VudClcbn1cblxuZnVuY3Rpb24gaXNIdG1sTGltaXRlZEJvdFVBKHVzZXJBZ2VudDogc3RyaW5nKSB7XG4gIHJldHVybiBIVE1MX0xJTUlURURfQk9UX1VBX1JFLnRlc3QodXNlckFnZW50KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCb3QodXNlckFnZW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzRG9tQm90VUEodXNlckFnZW50KSB8fCBpc0h0bWxMaW1pdGVkQm90VUEodXNlckFnZW50KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm90VHlwZSh1c2VyQWdlbnQ6IHN0cmluZyk6ICdkb20nIHwgJ2h0bWwnIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGlzRG9tQm90VUEodXNlckFnZW50KSkge1xuICAgIHJldHVybiAnZG9tJ1xuICB9XG4gIGlmIChpc0h0bWxMaW1pdGVkQm90VUEodXNlckFnZW50KSkge1xuICAgIHJldHVybiAnaHRtbCdcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkXG59XG4iXSwibmFtZXMiOlsiSFRNTF9MSU1JVEVEX0JPVF9VQV9SRSIsIkhUTUxfTElNSVRFRF9CT1RfVUFfUkVfU1RSSU5HIiwiZ2V0Qm90VHlwZSIsImlzQm90IiwiSEVBRExFU1NfQlJPV1NFUl9CT1RfVUFfUkUiLCJzb3VyY2UiLCJpc0RvbUJvdFVBIiwidXNlckFnZW50IiwidGVzdCIsImlzSHRtbExpbWl0ZWRCb3RVQSIsInVuZGVmaW5lZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztJQVNTQSxzQkFBc0IsRUFBQTtlQUF0QkEsVUFBQUEsc0JBQXNCOztJQUZsQkMsNkJBQTZCLEVBQUE7ZUFBN0JBOztJQWdCR0MsVUFBVSxFQUFBO2VBQVZBOztJQUpBQyxLQUFLLEVBQUE7ZUFBTEE7OzswQkFuQnVCO0FBRXZDLG1FQUFtRTtBQUNuRSxvR0FBb0c7QUFDcEcsNEZBQTRGO0FBQzVGLE1BQU1DLDZCQUE2QjtBQUU1QixNQUFNSCxnQ0FBZ0NELFVBQUFBLHNCQUFzQixDQUFDSyxNQUFNO0FBSTFFLFNBQVNDLFdBQVdDLFNBQWlCO0lBQ25DLE9BQU9ILDJCQUEyQkksSUFBSSxDQUFDRDtBQUN6QztBQUVBLFNBQVNFLG1CQUFtQkYsU0FBaUI7SUFDM0MsT0FBT1AsVUFBQUEsc0JBQXNCLENBQUNRLElBQUksQ0FBQ0Q7QUFDckM7QUFFTyxTQUFTSixNQUFNSSxTQUFpQjtJQUNyQyxPQUFPRCxXQUFXQyxjQUFjRSxtQkFBbUJGO0FBQ3JEO0FBRU8sU0FBU0wsV0FBV0ssU0FBaUI7SUFDMUMsSUFBSUQsV0FBV0MsWUFBWTtRQUN6QixPQUFPO0lBQ1Q7SUFDQSxJQUFJRSxtQkFBbUJGLFlBQVk7UUFDakMsT0FBTztJQUNUO0lBQ0EsT0FBT0c7QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA3MTUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcGF0aC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdpdmVuIGEgcGF0aCB0aGlzIGZ1bmN0aW9uIHdpbGwgZmluZCB0aGUgcGF0aG5hbWUsIHF1ZXJ5IGFuZCBoYXNoIGFuZCByZXR1cm5cbiAqIHRoZW0uIFRoaXMgaXMgdXNlZnVsIHRvIHBhcnNlIGZ1bGwgcGF0aHMgb24gdGhlIGNsaWVudCBzaWRlLlxuICogQHBhcmFtIHBhdGggQSBwYXRoIHRvIHBhcnNlIGUuZy4gL2Zvby9iYXI/aWQ9MSNoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aDogc3RyaW5nKSB7XG4gIGNvbnN0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZignIycpXG4gIGNvbnN0IHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKVxuICBjb25zdCBoYXNRdWVyeSA9IHF1ZXJ5SW5kZXggPiAtMSAmJiAoaGFzaEluZGV4IDwgMCB8fCBxdWVyeUluZGV4IDwgaGFzaEluZGV4KVxuXG4gIGlmIChoYXNRdWVyeSB8fCBoYXNoSW5kZXggPiAtMSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRobmFtZTogcGF0aC5zdWJzdHJpbmcoMCwgaGFzUXVlcnkgPyBxdWVyeUluZGV4IDogaGFzaEluZGV4KSxcbiAgICAgIHF1ZXJ5OiBoYXNRdWVyeVxuICAgICAgICA/IHBhdGguc3Vic3RyaW5nKHF1ZXJ5SW5kZXgsIGhhc2hJbmRleCA+IC0xID8gaGFzaEluZGV4IDogdW5kZWZpbmVkKVxuICAgICAgICA6ICcnLFxuICAgICAgaGFzaDogaGFzaEluZGV4ID4gLTEgPyBwYXRoLnNsaWNlKGhhc2hJbmRleCkgOiAnJyxcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBwYXRobmFtZTogcGF0aCwgcXVlcnk6ICcnLCBoYXNoOiAnJyB9XG59XG4iXSwibmFtZXMiOlsicGFyc2VQYXRoIiwicGF0aCIsImhhc2hJbmRleCIsImluZGV4T2YiLCJxdWVyeUluZGV4IiwiaGFzUXVlcnkiLCJwYXRobmFtZSIsInN1YnN0cmluZyIsInF1ZXJ5IiwidW5kZWZpbmVkIiwiaGFzaCIsInNsaWNlIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDOzs7K0JBQ2VBLGFBQUFBOzs7ZUFBQUE7OztBQUFULFNBQVNBLFVBQVVDLElBQVk7SUFDcEMsTUFBTUMsWUFBWUQsS0FBS0UsT0FBTyxDQUFDO0lBQy9CLE1BQU1DLGFBQWFILEtBQUtFLE9BQU8sQ0FBQztJQUNoQyxNQUFNRSxXQUFXRCxhQUFhLENBQUMsS0FBTUYsQ0FBQUEsWUFBWSxLQUFLRSxhQUFhRixTQUFRO0lBRTNFLElBQUlHLFlBQVlILFlBQVksQ0FBQyxHQUFHO1FBQzlCLE9BQU87WUFDTEksVUFBVUwsS0FBS00sU0FBUyxDQUFDLEdBQUdGLFdBQVdELGFBQWFGO1lBQ3BETSxPQUFPSCxXQUNISixLQUFLTSxTQUFTLENBQUNILFlBQVlGLFlBQVksQ0FBQyxJQUFJQSxZQUFZTyxhQUN4RDtZQUNKQyxNQUFNUixZQUFZLENBQUMsSUFBSUQsS0FBS1UsS0FBSyxDQUFDVCxhQUFhO1FBQ2pEO0lBQ0Y7SUFFQSxPQUFPO1FBQUVJLFVBQVVMO1FBQU1PLE9BQU87UUFBSUUsTUFBTTtJQUFHO0FBQy9DIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDc1MSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtcGF0aC1wcmVmaXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VQYXRoIH0gZnJvbSAnLi9wYXJzZS1wYXRoJ1xuXG4vKipcbiAqIEFkZHMgdGhlIHByb3ZpZGVkIHByZWZpeCB0byB0aGUgZ2l2ZW4gcGF0aC4gSXQgZmlyc3QgZW5zdXJlcyB0aGF0IHRoZSBwYXRoXG4gKiBpcyBpbmRlZWQgc3RhcnRpbmcgd2l0aCBhIHNsYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUGF0aFByZWZpeChwYXRoOiBzdHJpbmcsIHByZWZpeD86IHN0cmluZykge1xuICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpIHx8ICFwcmVmaXgpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgY29uc3QgeyBwYXRobmFtZSwgcXVlcnksIGhhc2ggfSA9IHBhcnNlUGF0aChwYXRoKVxuICByZXR1cm4gYCR7cHJlZml4fSR7cGF0aG5hbWV9JHtxdWVyeX0ke2hhc2h9YFxufVxuIl0sIm5hbWVzIjpbImFkZFBhdGhQcmVmaXgiLCJwYXRoIiwicHJlZml4Iiwic3RhcnRzV2l0aCIsInBhdGhuYW1lIiwicXVlcnkiLCJoYXNoIiwicGFyc2VQYXRoIl0sIm1hcHBpbmdzIjoiOzs7K0JBTWdCQSxpQkFBQUE7OztlQUFBQTs7OzJCQU5VO0FBTW5CLFNBQVNBLGNBQWNDLElBQVksRUFBRUMsTUFBZTtJQUN6RCxJQUFJLENBQUNELEtBQUtFLFVBQVUsQ0FBQyxRQUFRLENBQUNELFFBQVE7UUFDcEMsT0FBT0Q7SUFDVDtJQUVBLE1BQU0sRUFBRUcsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxXQUFBQSxTQUFTLEVBQUNOO0lBQzVDLE9BQVEsS0FBRUMsU0FBU0UsV0FBV0MsUUFBUUM7QUFDeEMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzc0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JlbW92ZS10cmFpbGluZy1zbGFzaC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlbW92ZXMgdGhlIHRyYWlsaW5nIHNsYXNoIGZvciBhIGdpdmVuIHJvdXRlIG9yIHBhZ2UgcGF0aC4gUHJlc2VydmVzIHRoZVxuICogcm9vdCBwYWdlLiBFeGFtcGxlczpcbiAqICAgLSBgL2Zvby9iYXIvYCAtPiBgL2Zvby9iYXJgXG4gKiAgIC0gYC9mb28vYmFyYCAtPiBgL2Zvby9iYXJgXG4gKiAgIC0gYC9gIC0+IGAvYFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdTbGFzaChyb3V0ZTogc3RyaW5nKSB7XG4gIHJldHVybiByb3V0ZS5yZXBsYWNlKC9cXC8kLywgJycpIHx8ICcvJ1xufVxuIl0sIm5hbWVzIjpbInJlbW92ZVRyYWlsaW5nU2xhc2giLCJyb3V0ZSIsInJlcGxhY2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQzs7OytCQUNlQSx1QkFBQUE7OztlQUFBQTs7O0FBQVQsU0FBU0Esb0JBQW9CQyxLQUFhO0lBQy9DLE9BQU9BLE1BQU1DLE9BQU8sQ0FBQyxPQUFPLE9BQU87QUFDckMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzk4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvc2VydmVyLWluc2VydGVkLWh0bWwuc2hhcmVkLXJ1bnRpbWUudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgdHlwZSBTZXJ2ZXJJbnNlcnRlZEhUTUxIb29rID0gKGNhbGxiYWNrczogKCkgPT4gUmVhY3QuUmVhY3ROb2RlKSA9PiB2b2lkXG5cbi8vIFVzZSBgUmVhY3QuY3JlYXRlQ29udGV4dGAgdG8gYXZvaWQgZXJyb3JzIGZyb20gdGhlIFJTQyBjaGVja3MgYmVjYXVzZVxuLy8gaXQgY2FuJ3QgYmUgaW1wb3J0ZWQgZGlyZWN0bHkgaW4gU2VydmVyIENvbXBvbmVudHM6XG4vL1xuLy8gICBpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnXG4vL1xuLy8gTW9yZSBpbmZvOiBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvcHVsbC80MDY4NlxuZXhwb3J0IGNvbnN0IFNlcnZlckluc2VydGVkSFRNTENvbnRleHQgPVxuICBSZWFjdC5jcmVhdGVDb250ZXh0PFNlcnZlckluc2VydGVkSFRNTEhvb2sgfCBudWxsPihudWxsIGFzIGFueSlcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNlcnZlckluc2VydGVkSFRNTChjYWxsYmFjazogKCkgPT4gUmVhY3QuUmVhY3ROb2RlKTogdm9pZCB7XG4gIGNvbnN0IGFkZEluc2VydGVkU2VydmVySFRNTENhbGxiYWNrID0gdXNlQ29udGV4dChTZXJ2ZXJJbnNlcnRlZEhUTUxDb250ZXh0KVxuICAvLyBTaG91bGQgaGF2ZSBubyBlZmZlY3RzIG9uIGNsaWVudCB3aGVyZSB0aGVyZSdzIG5vIGZsdXNoIGVmZmVjdHMgcHJvdmlkZXJcbiAgaWYgKGFkZEluc2VydGVkU2VydmVySFRNTENhbGxiYWNrKSB7XG4gICAgYWRkSW5zZXJ0ZWRTZXJ2ZXJIVE1MQ2FsbGJhY2soY2FsbGJhY2spXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJTZXJ2ZXJJbnNlcnRlZEhUTUxDb250ZXh0IiwidXNlU2VydmVySW5zZXJ0ZWRIVE1MIiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwiY2FsbGJhY2siLCJhZGRJbnNlcnRlZFNlcnZlckhUTUxDYWxsYmFjayIsInVzZUNvbnRleHQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBWWFBLHlCQUF5QixFQUFBO2VBQXpCQTs7SUFHR0MscUJBQXFCLEVBQUE7ZUFBckJBOzs7O2lFQWJrQjtBQVUzQixNQUFNRCw0QkFBQUEsV0FBQUEsR0FDWEUsT0FBQUEsT0FBSyxDQUFDQyxhQUFhLENBQWdDO0FBRTlDLFNBQVNGLHNCQUFzQkcsUUFBK0I7SUFDbkUsTUFBTUMsZ0NBQWdDQyxDQUFBQSxHQUFBQSxPQUFBQSxVQUFVLEVBQUNOO0lBQ2pELDJFQUEyRTtJQUMzRSxJQUFJSywrQkFBK0I7UUFDakNBLDhCQUE4QkQ7SUFDaEM7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA4MzUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGF0aC1oYXMtcHJlZml4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlUGF0aCB9IGZyb20gJy4vcGFyc2UtcGF0aCdcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBwYXRoIHN0YXJ0cyB3aXRoIGEgZ2l2ZW4gcHJlZml4LiBJdCBlbnN1cmVzIGl0IG1hdGNoZXNcbiAqIGV4YWN0bHkgd2l0aG91dCBjb250YWluaW5nIGV4dHJhIGNoYXJzLiBlLmcuIHByZWZpeCAvZG9jcyBzaG91bGQgcmVwbGFjZVxuICogZm9yIC9kb2NzLCAvZG9jcy8sIC9kb2NzL2EgYnV0IG5vdCAvZG9jc3NzXG4gKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSBwcmVmaXggVGhlIHByZWZpeCB0byBjaGVjayBhZ2FpbnN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF0aEhhc1ByZWZpeChwYXRoOiBzdHJpbmcsIHByZWZpeDogc3RyaW5nKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IHsgcGF0aG5hbWUgfSA9IHBhcnNlUGF0aChwYXRoKVxuICByZXR1cm4gcGF0aG5hbWUgPT09IHByZWZpeCB8fCBwYXRobmFtZS5zdGFydHNXaXRoKHByZWZpeCArICcvJylcbn1cbiJdLCJuYW1lcyI6WyJwYXRoSGFzUHJlZml4IiwicGF0aCIsInByZWZpeCIsInBhdGhuYW1lIiwicGFyc2VQYXRoIiwic3RhcnRzV2l0aCJdLCJtYXBwaW5ncyI6Ijs7OytCQVNnQkEsaUJBQUFBOzs7ZUFBQUE7OzsyQkFUVTtBQVNuQixTQUFTQSxjQUFjQyxJQUFZLEVBQUVDLE1BQWM7SUFDeEQsSUFBSSxPQUFPRCxTQUFTLFVBQVU7UUFDNUIsT0FBTztJQUNUO0lBRUEsTUFBTSxFQUFFRSxRQUFRLEVBQUUsR0FBR0MsQ0FBQUEsR0FBQUEsV0FBQUEsU0FBUyxFQUFDSDtJQUMvQixPQUFPRSxhQUFhRCxVQUFVQyxTQUFTRSxVQUFVLENBQUNILFNBQVM7QUFDN0QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODU4LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvdXRpbHMvd2Fybi1vbmNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImxldCB3YXJuT25jZSA9IChfOiBzdHJpbmcpID0+IHt9XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBjb25zdCB3YXJuaW5ncyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIHdhcm5PbmNlID0gKG1zZzogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF3YXJuaW5ncy5oYXMobXNnKSkge1xuICAgICAgY29uc29sZS53YXJuKG1zZylcbiAgICB9XG4gICAgd2FybmluZ3MuYWRkKG1zZylcbiAgfVxufVxuXG5leHBvcnQgeyB3YXJuT25jZSB9XG4iXSwibmFtZXMiOlsid2Fybk9uY2UiLCJfIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwid2FybmluZ3MiLCJTZXQiLCJtc2ciLCJoYXMiLCJjb25zb2xlIiwid2FybiIsImFkZCJdLCJtYXBwaW5ncyI6IkFBQ0lFLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLOzs7OzsrQkFVcEJKLFlBQUFBOzs7ZUFBQUE7OztBQVhULElBQUlBLFdBQVcsQ0FBQ0MsS0FBZTtBQUMvQix3Q0FBMkM7SUFDekMsTUFBTUksV0FBVyxJQUFJQztJQUNyQk4sV0FBVyxDQUFDTztRQUNWLElBQUksQ0FBQ0YsU0FBU0csR0FBRyxDQUFDRCxNQUFNO1lBQ3RCRSxRQUFRQyxJQUFJLENBQUNIO1FBQ2Y7UUFDQUYsU0FBU00sR0FBRyxDQUFDSjtJQUNmO0FBQ0YiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogODg1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvZm9ybWF0LXdlYnBhY2stbWVzc2FnZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5NSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbmNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblNPRlRXQVJFLlxuKi9cbmltcG9ydCBzdHJpcEFuc2kgZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3N0cmlwLWFuc2knXG4vLyBUaGlzIGZpbGUgaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2NyZWF0ZS1yZWFjdC1hcHAvYmxvYi83YjFhMzJiZTZlYzlmOTlhNmM5YTNjNjY4MTNmM2FjMDljNDczNmI5L3BhY2thZ2VzL3JlYWN0LWRldi11dGlscy9mb3JtYXRXZWJwYWNrTWVzc2FnZXMuanNcbi8vIEl0J3MgYmVlbiBlZGl0ZWQgdG8gcmVtb3ZlIGNoYWxrIGFuZCBDUkEtc3BlY2lmaWMgbG9naWNcblxuY29uc3QgZnJpZW5kbHlTeW50YXhFcnJvckxhYmVsID0gJ1N5bnRheCBlcnJvcjonXG5cbmNvbnN0IFdFQlBBQ0tfQlJFQUtJTkdfQ0hBTkdFX1BPTFlGSUxMUyA9XG4gICdcXG5cXG5CUkVBS0lORyBDSEFOR0U6IHdlYnBhY2sgPCA1IHVzZWQgdG8gaW5jbHVkZSBwb2x5ZmlsbHMgZm9yIG5vZGUuanMgY29yZSBtb2R1bGVzIGJ5IGRlZmF1bHQuJ1xuXG5mdW5jdGlvbiBpc0xpa2VseUFTeW50YXhFcnJvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmlwQW5zaShtZXNzYWdlKS5pbmNsdWRlcyhmcmllbmRseVN5bnRheEVycm9yTGFiZWwpXG59XG5cbmxldCBoYWRNaXNzaW5nU2Fzc0Vycm9yID0gZmFsc2VcblxuLy8gQ2xlYW5zIHVwIHdlYnBhY2sgZXJyb3IgbWVzc2FnZXMuXG5mdW5jdGlvbiBmb3JtYXRNZXNzYWdlKFxuICBtZXNzYWdlOiBhbnksXG4gIHZlcmJvc2U/OiBib29sZWFuLFxuICBpbXBvcnRUcmFjZU5vdGU/OiBib29sZWFuXG4pIHtcbiAgLy8gVE9ETzogUmVwbGFjZSB0aGlzIG9uY2Ugd2VicGFjayA1IGlzIHN0YWJsZVxuICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnICYmIG1lc3NhZ2UubWVzc2FnZSkge1xuICAgIGNvbnN0IGZpbHRlcmVkTW9kdWxlVHJhY2UgPVxuICAgICAgbWVzc2FnZS5tb2R1bGVUcmFjZSAmJlxuICAgICAgbWVzc2FnZS5tb2R1bGVUcmFjZS5maWx0ZXIoXG4gICAgICAgICh0cmFjZTogYW55KSA9PlxuICAgICAgICAgICEvbmV4dC0obWlkZGxld2FyZXxjbGllbnQtcGFnZXN8cm91dGV8ZWRnZS1mdW5jdGlvbiktbG9hZGVyXFwuanMvLnRlc3QoXG4gICAgICAgICAgICB0cmFjZS5vcmlnaW5OYW1lXG4gICAgICAgICAgKVxuICAgICAgKVxuXG4gICAgbGV0IGJvZHkgPSBtZXNzYWdlLm1lc3NhZ2VcbiAgICBjb25zdCBicmVha2luZ0NoYW5nZUluZGV4ID0gYm9keS5pbmRleE9mKFdFQlBBQ0tfQlJFQUtJTkdfQ0hBTkdFX1BPTFlGSUxMUylcbiAgICBpZiAoYnJlYWtpbmdDaGFuZ2VJbmRleCA+PSAwKSB7XG4gICAgICBib2R5ID0gYm9keS5zbGljZSgwLCBicmVha2luZ0NoYW5nZUluZGV4KVxuICAgIH1cblxuICAgIG1lc3NhZ2UgPVxuICAgICAgKG1lc3NhZ2UubW9kdWxlTmFtZSA/IHN0cmlwQW5zaShtZXNzYWdlLm1vZHVsZU5hbWUpICsgJ1xcbicgOiAnJykgK1xuICAgICAgKG1lc3NhZ2UuZmlsZSA/IHN0cmlwQW5zaShtZXNzYWdlLmZpbGUpICsgJ1xcbicgOiAnJykgK1xuICAgICAgYm9keSArXG4gICAgICAobWVzc2FnZS5kZXRhaWxzICYmIHZlcmJvc2UgPyAnXFxuJyArIG1lc3NhZ2UuZGV0YWlscyA6ICcnKSArXG4gICAgICAoZmlsdGVyZWRNb2R1bGVUcmFjZSAmJiBmaWx0ZXJlZE1vZHVsZVRyYWNlLmxlbmd0aFxuICAgICAgICA/IChpbXBvcnRUcmFjZU5vdGUgfHwgJ1xcblxcbkltcG9ydCB0cmFjZSBmb3IgcmVxdWVzdGVkIG1vZHVsZTonKSArXG4gICAgICAgICAgZmlsdGVyZWRNb2R1bGVUcmFjZVxuICAgICAgICAgICAgLm1hcCgodHJhY2U6IGFueSkgPT4gYFxcbiR7dHJhY2UubW9kdWxlTmFtZX1gKVxuICAgICAgICAgICAgLmpvaW4oJycpXG4gICAgICAgIDogJycpICtcbiAgICAgIChtZXNzYWdlLnN0YWNrICYmIHZlcmJvc2UgPyAnXFxuJyArIG1lc3NhZ2Uuc3RhY2sgOiAnJylcbiAgfVxuICBsZXQgbGluZXMgPSBtZXNzYWdlLnNwbGl0KCdcXG4nKVxuXG4gIC8vIFN0cmlwIFdlYnBhY2stYWRkZWQgaGVhZGVycyBvZmYgZXJyb3JzL3dhcm5pbmdzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2svYmxvYi9tYXN0ZXIvbGliL01vZHVsZUVycm9yLmpzXG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKChsaW5lOiBzdHJpbmcpID0+ICEvTW9kdWxlIFtBLXogXStcXChmcm9tLy50ZXN0KGxpbmUpKVxuXG4gIC8vIFRyYW5zZm9ybSBwYXJzaW5nIGVycm9yIGludG8gc3ludGF4IGVycm9yXG4gIC8vIFRPRE86IG1vdmUgdGhpcyB0byBvdXIgRVNMaW50IGZvcm1hdHRlcj9cbiAgbGluZXMgPSBsaW5lcy5tYXAoKGxpbmU6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHBhcnNpbmdFcnJvciA9IC9MaW5lIChcXGQrKTooPzooXFxkKyk6KT9cXHMqUGFyc2luZyBlcnJvcjogKC4rKSQvLmV4ZWMoXG4gICAgICBsaW5lXG4gICAgKVxuICAgIGlmICghcGFyc2luZ0Vycm9yKSB7XG4gICAgICByZXR1cm4gbGluZVxuICAgIH1cbiAgICBjb25zdCBbLCBlcnJvckxpbmUsIGVycm9yQ29sdW1uLCBlcnJvck1lc3NhZ2VdID0gcGFyc2luZ0Vycm9yXG4gICAgcmV0dXJuIGAke2ZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbH0gJHtlcnJvck1lc3NhZ2V9ICgke2Vycm9yTGluZX06JHtlcnJvckNvbHVtbn0pYFxuICB9KVxuXG4gIG1lc3NhZ2UgPSBsaW5lcy5qb2luKCdcXG4nKVxuICAvLyBTbW9vc2ggc3ludGF4IGVycm9ycyAoY29tbW9ubHkgZm91bmQgaW4gQ1NTKVxuICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKFxuICAgIC9TeW50YXhFcnJvclxccytcXCgoXFxkKyk6KFxcZCspXFwpXFxzKiguKz8pXFxuL2csXG4gICAgYCR7ZnJpZW5kbHlTeW50YXhFcnJvckxhYmVsfSAkMyAoJDE6JDIpXFxuYFxuICApXG4gIC8vIENsZWFuIHVwIGV4cG9ydCBlcnJvcnNcbiAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShcbiAgICAvXi4qZXhwb3J0ICcoLis/KScgd2FzIG5vdCBmb3VuZCBpbiAnKC4rPyknLiokL2dtLFxuICAgIGBBdHRlbXB0ZWQgaW1wb3J0IGVycm9yOiAnJDEnIGlzIG5vdCBleHBvcnRlZCBmcm9tICckMicuYFxuICApXG4gIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoXG4gICAgL14uKmV4cG9ydCAnZGVmYXVsdCcgXFwoaW1wb3J0ZWQgYXMgJyguKz8pJ1xcKSB3YXMgbm90IGZvdW5kIGluICcoLis/KScuKiQvZ20sXG4gICAgYEF0dGVtcHRlZCBpbXBvcnQgZXJyb3I6ICckMicgZG9lcyBub3QgY29udGFpbiBhIGRlZmF1bHQgZXhwb3J0IChpbXBvcnRlZCBhcyAnJDEnKS5gXG4gIClcbiAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShcbiAgICAvXi4qZXhwb3J0ICcoLis/KScgXFwoaW1wb3J0ZWQgYXMgJyguKz8pJ1xcKSB3YXMgbm90IGZvdW5kIGluICcoLis/KScuKiQvZ20sXG4gICAgYEF0dGVtcHRlZCBpbXBvcnQgZXJyb3I6ICckMScgaXMgbm90IGV4cG9ydGVkIGZyb20gJyQzJyAoaW1wb3J0ZWQgYXMgJyQyJykuYFxuICApXG4gIGxpbmVzID0gbWVzc2FnZS5zcGxpdCgnXFxuJylcblxuICAvLyBSZW1vdmUgbGVhZGluZyBuZXdsaW5lXG4gIGlmIChsaW5lcy5sZW5ndGggPiAyICYmIGxpbmVzWzFdLnRyaW0oKSA9PT0gJycpIHtcbiAgICBsaW5lcy5zcGxpY2UoMSwgMSlcbiAgfVxuXG4gIC8vIENsZWFucyB1cCB2ZXJib3NlIFwibW9kdWxlIG5vdCBmb3VuZFwiIG1lc3NhZ2VzIGZvciBmaWxlcyBhbmQgcGFja2FnZXMuXG4gIGlmIChsaW5lc1sxXSAmJiBsaW5lc1sxXS5zdGFydHNXaXRoKCdNb2R1bGUgbm90IGZvdW5kOiAnKSkge1xuICAgIGxpbmVzID0gW1xuICAgICAgbGluZXNbMF0sXG4gICAgICBsaW5lc1sxXVxuICAgICAgICAucmVwbGFjZSgnRXJyb3I6ICcsICcnKVxuICAgICAgICAucmVwbGFjZSgnTW9kdWxlIG5vdCBmb3VuZDogQ2Fubm90IGZpbmQgZmlsZTonLCAnQ2Fubm90IGZpbmQgZmlsZTonKSxcbiAgICAgIC4uLmxpbmVzLnNsaWNlKDIpLFxuICAgIF1cbiAgfVxuXG4gIC8vIEFkZCBoZWxwZnVsIG1lc3NhZ2UgZm9yIHVzZXJzIHRyeWluZyB0byB1c2UgU2FzcyBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgaWYgKGxpbmVzWzFdICYmIGxpbmVzWzFdLm1hdGNoKC9DYW5ub3QgZmluZCBtb2R1bGUuK3Nhc3MvKSkge1xuICAgIC8vIC4vZmlsZS5tb2R1bGUuc2NzcyAoPDxsb2FkZXIgaW5mbz4+KSA9PiAuL2ZpbGUubW9kdWxlLnNjc3NcbiAgICBjb25zdCBmaXJzdExpbmUgPSBsaW5lc1swXS5zcGxpdCgnIScpXG4gICAgbGluZXNbMF0gPSBmaXJzdExpbmVbZmlyc3RMaW5lLmxlbmd0aCAtIDFdXG5cbiAgICBsaW5lc1sxXSA9XG4gICAgICBcIlRvIHVzZSBOZXh0LmpzJyBidWlsdC1pbiBTYXNzIHN1cHBvcnQsIHlvdSBmaXJzdCBuZWVkIHRvIGluc3RhbGwgYHNhc3NgLlxcblwiXG4gICAgbGluZXNbMV0gKz0gJ1J1biBgbnBtIGkgc2Fzc2Agb3IgYHlhcm4gYWRkIHNhc3NgIGluc2lkZSB5b3VyIHdvcmtzcGFjZS5cXG4nXG4gICAgbGluZXNbMV0gKz0gJ1xcbkxlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2luc3RhbGwtc2FzcydcblxuICAgIC8vIGRpc3Bvc2Ugb2YgdW5oZWxwZnVsIHN0YWNrIHRyYWNlXG4gICAgbGluZXMgPSBsaW5lcy5zbGljZSgwLCAyKVxuICAgIGhhZE1pc3NpbmdTYXNzRXJyb3IgPSB0cnVlXG4gIH0gZWxzZSBpZiAoXG4gICAgaGFkTWlzc2luZ1Nhc3NFcnJvciAmJlxuICAgIG1lc3NhZ2UubWF0Y2goLyhzYXNzLWxvYWRlcnxyZXNvbHZlLXVybC1sb2FkZXI6IENTUyBlcnJvcikvKVxuICApIHtcbiAgICAvLyBkaXNwb3NlIG9mIHVuaGVscGZ1bCBzdGFjayB0cmFjZSBmb2xsb3dpbmcgbWlzc2luZyBzYXNzIG1vZHVsZVxuICAgIGxpbmVzID0gW11cbiAgfVxuXG4gIGlmICghdmVyYm9zZSkge1xuICAgIG1lc3NhZ2UgPSBsaW5lcy5qb2luKCdcXG4nKVxuICAgIC8vIEludGVybmFsIHN0YWNrcyBhcmUgZ2VuZXJhbGx5IHVzZWxlc3Mgc28gd2Ugc3RyaXAgdGhlbS4uLiB3aXRoIHRoZVxuICAgIC8vIGV4Y2VwdGlvbiBvZiBzdGFja3MgY29udGFpbmluZyBgd2VicGFjazpgIGJlY2F1c2UgdGhleSdyZSBub3JtYWxseVxuICAgIC8vIGZyb20gdXNlciBjb2RlIGdlbmVyYXRlZCBieSBXZWJwYWNrLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9wdWxsLzEwNTBcbiAgICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKFxuICAgICAgL15cXHMqYXRcXHMoKD8hd2VicGFjazopLikqOlxcZCs6XFxkK1tcXHMpXSooXFxufCQpL2dtLFxuICAgICAgJydcbiAgICApIC8vIGF0IC4uLiAuLi46eDp5XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSgvXlxccyphdFxcczxhbm9ueW1vdXM+KFxcbnwkKS9nbSwgJycpIC8vIGF0IDxhbm9ueW1vdXM+XG5cbiAgICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKFxuICAgICAgL0ZpbGUgd2FzIHByb2Nlc3NlZCB3aXRoIHRoZXNlIGxvYWRlcnM6XFxuKC4rW1xcXFwvXShuZXh0W1xcXFwvXWRpc3RbXFxcXC9dLit8QG5leHRbXFxcXC9dcmVhY3QtcmVmcmVzaC11dGlsc1tcXFxcL11sb2FkZXIpXFwuanNcXG4pKllvdSBtYXkgbmVlZCBhbiBhZGRpdGlvbmFsIGxvYWRlciB0byBoYW5kbGUgdGhlIHJlc3VsdCBvZiB0aGVzZSBsb2FkZXJzLlxcbi9nLFxuICAgICAgJydcbiAgICApXG5cbiAgICBsaW5lcyA9IG1lc3NhZ2Uuc3BsaXQoJ1xcbicpXG4gIH1cblxuICAvLyBSZW1vdmUgZHVwbGljYXRlZCBuZXdsaW5lc1xuICBsaW5lcyA9IChsaW5lcyBhcyBzdHJpbmdbXSkuZmlsdGVyKFxuICAgIChsaW5lLCBpbmRleCwgYXJyKSA9PlxuICAgICAgaW5kZXggPT09IDAgfHwgbGluZS50cmltKCkgIT09ICcnIHx8IGxpbmUudHJpbSgpICE9PSBhcnJbaW5kZXggLSAxXS50cmltKClcbiAgKVxuXG4gIC8vIFJlYXNzZW1ibGUgdGhlIG1lc3NhZ2VcbiAgbWVzc2FnZSA9IGxpbmVzLmpvaW4oJ1xcbicpXG4gIHJldHVybiBtZXNzYWdlLnRyaW0oKVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXRXZWJwYWNrTWVzc2FnZXMoanNvbjogYW55LCB2ZXJib3NlPzogYm9vbGVhbikge1xuICBjb25zdCBmb3JtYXR0ZWRFcnJvcnMgPSBqc29uLmVycm9ycy5tYXAoKG1lc3NhZ2U6IGFueSkgPT4ge1xuICAgIGNvbnN0IGlzVW5rbm93bk5leHRGb250RXJyb3IgPSBtZXNzYWdlLm1lc3NhZ2UuaW5jbHVkZXMoXG4gICAgICAnQW4gZXJyb3Igb2NjdXJyZWQgaW4gYG5leHQvZm9udGAuJ1xuICAgIClcbiAgICByZXR1cm4gZm9ybWF0TWVzc2FnZShtZXNzYWdlLCBpc1Vua25vd25OZXh0Rm9udEVycm9yIHx8IHZlcmJvc2UpXG4gIH0pXG4gIGNvbnN0IGZvcm1hdHRlZFdhcm5pbmdzID0ganNvbi53YXJuaW5ncy5tYXAoKG1lc3NhZ2U6IGFueSkgPT4ge1xuICAgIHJldHVybiBmb3JtYXRNZXNzYWdlKG1lc3NhZ2UsIHZlcmJvc2UpXG4gIH0pXG5cbiAgLy8gUmVvcmRlciBlcnJvcnMgdG8gcHV0IHRoZSBtb3N0IHJlbGV2YW50IG9uZXMgZmlyc3QuXG4gIGxldCByZWFjdFNlcnZlckNvbXBvbmVudHNFcnJvciA9IC0xXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXR0ZWRFcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBlcnJvciA9IGZvcm1hdHRlZEVycm9yc1tpXVxuICAgIGlmIChlcnJvci5pbmNsdWRlcygnUmVhY3RTZXJ2ZXJDb21wb25lbnRzRXJyb3InKSkge1xuICAgICAgcmVhY3RTZXJ2ZXJDb21wb25lbnRzRXJyb3IgPSBpXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIE1vdmUgdGhlIHJlYWN0U2VydmVyQ29tcG9uZW50c0Vycm9yIHRvIHRoZSB0b3AgaWYgaXQgZXhpc3RzXG4gIGlmIChyZWFjdFNlcnZlckNvbXBvbmVudHNFcnJvciAhPT0gLTEpIHtcbiAgICBjb25zdCBlcnJvciA9IGZvcm1hdHRlZEVycm9ycy5zcGxpY2UocmVhY3RTZXJ2ZXJDb21wb25lbnRzRXJyb3IsIDEpXG4gICAgZm9ybWF0dGVkRXJyb3JzLnVuc2hpZnQoZXJyb3JbMF0pXG4gIH1cblxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLi4uanNvbixcbiAgICBlcnJvcnM6IGZvcm1hdHRlZEVycm9ycyxcbiAgICB3YXJuaW5nczogZm9ybWF0dGVkV2FybmluZ3MsXG4gIH1cbiAgaWYgKCF2ZXJib3NlICYmIHJlc3VsdC5lcnJvcnMuc29tZShpc0xpa2VseUFTeW50YXhFcnJvcikpIHtcbiAgICAvLyBJZiB0aGVyZSBhcmUgYW55IHN5bnRheCBlcnJvcnMsIHNob3cganVzdCB0aGVtLlxuICAgIHJlc3VsdC5lcnJvcnMgPSByZXN1bHQuZXJyb3JzLmZpbHRlcihpc0xpa2VseUFTeW50YXhFcnJvcilcbiAgICByZXN1bHQud2FybmluZ3MgPSBbXVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cbiJdLCJuYW1lcyI6WyJmb3JtYXRXZWJwYWNrTWVzc2FnZXMiLCJmcmllbmRseVN5bnRheEVycm9yTGFiZWwiLCJXRUJQQUNLX0JSRUFLSU5HX0NIQU5HRV9QT0xZRklMTFMiLCJpc0xpa2VseUFTeW50YXhFcnJvciIsIm1lc3NhZ2UiLCJzdHJpcEFuc2kiLCJpbmNsdWRlcyIsImhhZE1pc3NpbmdTYXNzRXJyb3IiLCJmb3JtYXRNZXNzYWdlIiwidmVyYm9zZSIsImltcG9ydFRyYWNlTm90ZSIsImZpbHRlcmVkTW9kdWxlVHJhY2UiLCJtb2R1bGVUcmFjZSIsImZpbHRlciIsInRyYWNlIiwidGVzdCIsIm9yaWdpbk5hbWUiLCJib2R5IiwiYnJlYWtpbmdDaGFuZ2VJbmRleCIsImluZGV4T2YiLCJzbGljZSIsIm1vZHVsZU5hbWUiLCJmaWxlIiwiZGV0YWlscyIsImxlbmd0aCIsIm1hcCIsImpvaW4iLCJzdGFjayIsImxpbmVzIiwic3BsaXQiLCJsaW5lIiwicGFyc2luZ0Vycm9yIiwiZXhlYyIsImVycm9yTGluZSIsImVycm9yQ29sdW1uIiwiZXJyb3JNZXNzYWdlIiwicmVwbGFjZSIsInRyaW0iLCJzcGxpY2UiLCJzdGFydHNXaXRoIiwibWF0Y2giLCJmaXJzdExpbmUiLCJpbmRleCIsImFyciIsImpzb24iLCJmb3JtYXR0ZWRFcnJvcnMiLCJlcnJvcnMiLCJpc1Vua25vd25OZXh0Rm9udEVycm9yIiwiZm9ybWF0dGVkV2FybmluZ3MiLCJ3YXJuaW5ncyIsInJlYWN0U2VydmVyQ29tcG9uZW50c0Vycm9yIiwiaSIsImVycm9yIiwidW5zaGlmdCIsInJlc3VsdCIsInNvbWUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBOzs7K0JBaUtBLFdBQUE7OztlQUF3QkE7Ozs7b0VBaEtGO0FBQ3RCLHFLQUFxSztBQUNySywwREFBMEQ7QUFFMUQsTUFBTUMsMkJBQTJCO0FBRWpDLE1BQU1DLG9DQUNKO0FBRUYsU0FBU0MscUJBQXFCQyxPQUFlO0lBQzNDLE9BQU9DLENBQUFBLEdBQUFBLFdBQUFBLE9BQVMsRUFBQ0QsU0FBU0UsUUFBUSxDQUFDTDtBQUNyQztBQUVBLElBQUlNLHNCQUFzQjtBQUUxQixvQ0FBb0M7QUFDcEMsU0FBU0MsY0FDUEosT0FBWSxFQUNaSyxPQUFpQixFQUNqQkMsZUFBeUI7SUFFekIsOENBQThDO0lBQzlDLElBQUksT0FBT04sWUFBWSxZQUFZQSxRQUFRQSxPQUFPLEVBQUU7UUFDbEQsTUFBTU8sc0JBQ0pQLFFBQVFRLFdBQVcsSUFDbkJSLFFBQVFRLFdBQVcsQ0FBQ0MsTUFBTSxDQUN4QixDQUFDQyxRQUNDLENBQUMsZ0VBQWdFQyxJQUFJLENBQ25FRCxNQUFNRSxVQUFVO1FBSXhCLElBQUlDLE9BQU9iLFFBQVFBLE9BQU87UUFDMUIsTUFBTWMsc0JBQXNCRCxLQUFLRSxPQUFPLENBQUNqQjtRQUN6QyxJQUFJZ0IsdUJBQXVCLEdBQUc7WUFDNUJELE9BQU9BLEtBQUtHLEtBQUssQ0FBQyxHQUFHRjtRQUN2QjtRQUVBZCxVQUNHQSxDQUFBQSxRQUFRaUIsVUFBVSxHQUFHaEIsQ0FBQUEsR0FBQUEsV0FBQUEsT0FBUyxFQUFDRCxRQUFRaUIsVUFBVSxJQUFJLE9BQU8sRUFBQyxJQUM3RGpCLENBQUFBLFFBQVFrQixJQUFJLEdBQUdqQixDQUFBQSxHQUFBQSxXQUFBQSxPQUFTLEVBQUNELFFBQVFrQixJQUFJLElBQUksT0FBTyxFQUFDLElBQ2xETCxPQUNDYixDQUFBQSxRQUFRbUIsT0FBTyxJQUFJZCxVQUFVLE9BQU9MLFFBQVFtQixPQUFPLEdBQUcsRUFBQyxJQUN2RFosQ0FBQUEsdUJBQXVCQSxvQkFBb0JhLE1BQU0sR0FDN0NkLENBQUFBLG1CQUFtQix3Q0FBdUMsSUFDM0RDLG9CQUNHYyxHQUFHLENBQUMsQ0FBQ1gsUUFBZ0IsT0FBSUEsTUFBTU8sVUFBVSxFQUN6Q0ssSUFBSSxDQUFDLE1BQ1IsRUFBQyxJQUNKdEIsQ0FBQUEsUUFBUXVCLEtBQUssSUFBSWxCLFVBQVUsT0FBT0wsUUFBUXVCLEtBQUssR0FBRyxFQUFDO0lBQ3hEO0lBQ0EsSUFBSUMsUUFBUXhCLFFBQVF5QixLQUFLLENBQUM7SUFFMUIsa0RBQWtEO0lBQ2xELG9FQUFvRTtJQUNwRUQsUUFBUUEsTUFBTWYsTUFBTSxDQUFDLENBQUNpQixPQUFpQixDQUFDLHVCQUF1QmYsSUFBSSxDQUFDZTtJQUVwRSw0Q0FBNEM7SUFDNUMsMkNBQTJDO0lBQzNDRixRQUFRQSxNQUFNSCxHQUFHLENBQUMsQ0FBQ0s7UUFDakIsTUFBTUMsZUFBZSxnREFBZ0RDLElBQUksQ0FDdkVGO1FBRUYsSUFBSSxDQUFDQyxjQUFjO1lBQ2pCLE9BQU9EO1FBQ1Q7UUFDQSxNQUFNLEdBQUdHLFdBQVdDLGFBQWFDLGFBQWEsR0FBR0o7UUFDakQsT0FBVTlCLDJCQUF5QixNQUFHa0MsZUFBYSxPQUFJRixZQUFVLE1BQUdDLGNBQVk7SUFDbEY7SUFFQTlCLFVBQVV3QixNQUFNRixJQUFJLENBQUM7SUFDckIsK0NBQStDO0lBQy9DdEIsVUFBVUEsUUFBUWdDLE9BQU8sQ0FDdkIsNENBQ0MsS0FBRW5DLDJCQUF5QjtJQUU5Qix5QkFBeUI7SUFDekJHLFVBQVVBLFFBQVFnQyxPQUFPLENBQ3ZCLG1EQUNDO0lBRUhoQyxVQUFVQSxRQUFRZ0MsT0FBTyxDQUN2Qiw2RUFDQztJQUVIaEMsVUFBVUEsUUFBUWdDLE9BQU8sQ0FDdkIsMkVBQ0M7SUFFSFIsUUFBUXhCLFFBQVF5QixLQUFLLENBQUM7SUFFdEIseUJBQXlCO0lBQ3pCLElBQUlELE1BQU1KLE1BQU0sR0FBRyxLQUFLSSxLQUFLLENBQUMsRUFBRSxDQUFDUyxJQUFJLE9BQU8sSUFBSTtRQUM5Q1QsTUFBTVUsTUFBTSxDQUFDLEdBQUc7SUFDbEI7SUFFQSx3RUFBd0U7SUFDeEUsSUFBSVYsS0FBSyxDQUFDLEVBQUUsSUFBSUEsS0FBSyxDQUFDLEVBQUUsQ0FBQ1csVUFBVSxDQUFDLHVCQUF1QjtRQUN6RFgsUUFBUTtZQUNOQSxLQUFLLENBQUMsRUFBRTtZQUNSQSxLQUFLLENBQUMsRUFBRSxDQUNMUSxPQUFPLENBQUMsV0FBVyxJQUNuQkEsT0FBTyxDQUFDLHVDQUF1QztlQUMvQ1IsTUFBTVIsS0FBSyxDQUFDO1NBQ2hCO0lBQ0g7SUFFQSxzRUFBc0U7SUFDdEUsSUFBSVEsS0FBSyxDQUFDLEVBQUUsSUFBSUEsS0FBSyxDQUFDLEVBQUUsQ0FBQ1ksS0FBSyxDQUFDLDZCQUE2QjtRQUMxRCw2REFBNkQ7UUFDN0QsTUFBTUMsWUFBWWIsS0FBSyxDQUFDLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO1FBQ2pDRCxLQUFLLENBQUMsRUFBRSxHQUFHYSxTQUFTLENBQUNBLFVBQVVqQixNQUFNLEdBQUcsRUFBRTtRQUUxQ0ksS0FBSyxDQUFDLEVBQUUsR0FDTjtRQUNGQSxLQUFLLENBQUMsRUFBRSxJQUFJO1FBQ1pBLEtBQUssQ0FBQyxFQUFFLElBQUk7UUFFWixtQ0FBbUM7UUFDbkNBLFFBQVFBLE1BQU1SLEtBQUssQ0FBQyxHQUFHO1FBQ3ZCYixzQkFBc0I7SUFDeEIsT0FBTyxJQUNMQSx1QkFDQUgsUUFBUW9DLEtBQUssQ0FBQyxnREFDZDtRQUNBLGlFQUFpRTtRQUNqRVosUUFBUSxFQUFFO0lBQ1o7SUFFQSxJQUFJLENBQUNuQixTQUFTO1FBQ1pMLFVBQVV3QixNQUFNRixJQUFJLENBQUM7UUFDckIscUVBQXFFO1FBQ3JFLHFFQUFxRTtRQUNyRSxnRUFBZ0U7UUFDaEUseURBQXlEO1FBQ3pEdEIsVUFBVUEsUUFBUWdDLE9BQU8sQ0FDdkIsa0RBQ0EsSUFDQSxpQkFBaUI7O1FBQ25CaEMsVUFBVUEsUUFBUWdDLE9BQU8sQ0FBQywrQkFBK0IsSUFBSSxpQkFBaUI7O1FBRTlFaEMsVUFBVUEsUUFBUWdDLE9BQU8sQ0FDdkIsc01BQ0E7UUFHRlIsUUFBUXhCLFFBQVF5QixLQUFLLENBQUM7SUFDeEI7SUFFQSw2QkFBNkI7SUFDN0JELFFBQVNBLE1BQW1CZixNQUFNLENBQ2hDLENBQUNpQixNQUFNWSxPQUFPQyxNQUNaRCxVQUFVLEtBQUtaLEtBQUtPLElBQUksT0FBTyxNQUFNUCxLQUFLTyxJQUFJLE9BQU9NLEdBQUcsQ0FBQ0QsUUFBUSxFQUFFLENBQUNMLElBQUk7SUFHNUUseUJBQXlCO0lBQ3pCakMsVUFBVXdCLE1BQU1GLElBQUksQ0FBQztJQUNyQixPQUFPdEIsUUFBUWlDLElBQUk7QUFDckI7QUFFZSxTQUFTckMsc0JBQXNCNEMsSUFBUyxFQUFFbkMsT0FBaUI7SUFDeEUsTUFBTW9DLGtCQUFrQkQsS0FBS0UsTUFBTSxDQUFDckIsR0FBRyxDQUFDLENBQUNyQjtRQUN2QyxNQUFNMkMseUJBQXlCM0MsUUFBUUEsT0FBTyxDQUFDRSxRQUFRLENBQ3JEO1FBRUYsT0FBT0UsY0FBY0osU0FBUzJDLDBCQUEwQnRDO0lBQzFEO0lBQ0EsTUFBTXVDLG9CQUFvQkosS0FBS0ssUUFBUSxDQUFDeEIsR0FBRyxDQUFDLENBQUNyQjtRQUMzQyxPQUFPSSxjQUFjSixTQUFTSztJQUNoQztJQUVBLHNEQUFzRDtJQUN0RCxJQUFJeUMsNkJBQTZCLENBQUM7SUFFbEMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlOLGdCQUFnQnJCLE1BQU0sRUFBRTJCLElBQUs7UUFDL0MsTUFBTUMsUUFBUVAsZUFBZSxDQUFDTSxFQUFFO1FBQ2hDLElBQUlDLE1BQU05QyxRQUFRLENBQUMsK0JBQStCO1lBQ2hENEMsNkJBQTZCQztZQUM3QjtRQUNGO0lBQ0Y7SUFFQSw4REFBOEQ7SUFDOUQsSUFBSUQsK0JBQStCLENBQUMsR0FBRztRQUNyQyxNQUFNRSxRQUFRUCxnQkFBZ0JQLE1BQU0sQ0FBQ1ksNEJBQTRCO1FBQ2pFTCxnQkFBZ0JRLE9BQU8sQ0FBQ0QsS0FBSyxDQUFDLEVBQUU7SUFDbEM7SUFFQSxNQUFNRSxTQUFTO1FBQ2IsR0FBR1YsSUFBSTtRQUNQRSxRQUFRRDtRQUNSSSxVQUFVRDtJQUNaO0lBQ0EsSUFBSSxDQUFDdkMsV0FBVzZDLE9BQU9SLE1BQU0sQ0FBQ1MsSUFBSSxDQUFDcEQsdUJBQXVCO1FBQ3hELGtEQUFrRDtRQUNsRG1ELE9BQU9SLE1BQU0sR0FBR1EsT0FBT1IsTUFBTSxDQUFDakMsTUFBTSxDQUFDVjtRQUNyQ21ELE9BQU9MLFFBQVEsR0FBRyxFQUFFO0lBQ3RCO0lBQ0EsT0FBT0s7QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxMDQ2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NoYXJlZC9saWIvZXJyb3JzL2NvbnN0YW50cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgTUlTU0lOR19ST09UX1RBR1NfRVJST1IgPSAnTkVYVF9NSVNTSU5HX1JPT1RfVEFHUydcbiJdLCJuYW1lcyI6WyJNSVNTSU5HX1JPT1RfVEFHU19FUlJPUiJdLCJtYXBwaW5ncyI6Ijs7OytCQUFhQSwyQkFBQUE7OztlQUFBQTs7O0FBQU4sTUFBTUEsMEJBQTBCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEwNjksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2hhcmVkL2xpYi9ub3JtYWxpemVkLWFzc2V0LXByZWZpeC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplZEFzc2V0UHJlZml4KGFzc2V0UHJlZml4OiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICAvLyByZW1vdmUgYWxsIGxlYWRpbmcgc2xhc2hlcyBhbmQgdHJhaWxpbmcgc2xhc2hlc1xuICBjb25zdCBlc2NhcGVkQXNzZXRQcmVmaXggPSBhc3NldFByZWZpeD8ucmVwbGFjZSgvXlxcLyt8XFwvKyQvZywgJycpIHx8IGZhbHNlXG5cbiAgLy8gaWYgYW4gYXNzZXRQcmVmaXggd2FzICcvJywgd2UgcmV0dXJuIGVtcHR5IHN0cmluZ1xuICAvLyBiZWNhdXNlIGl0IGNvdWxkIGJlIGFuIHVubmVjZXNzYXJ5IHRyYWlsaW5nIHNsYXNoXG4gIGlmICghZXNjYXBlZEFzc2V0UHJlZml4KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoVVJMLmNhblBhcnNlKGVzY2FwZWRBc3NldFByZWZpeCkpIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGVzY2FwZWRBc3NldFByZWZpeCkudG9TdHJpbmcoKVxuICAgIHJldHVybiB1cmwuZW5kc1dpdGgoJy8nKSA/IHVybC5zbGljZSgwLCAtMSkgOiB1cmxcbiAgfVxuXG4gIC8vIGFzc3VtaW5nIGFzc2V0UHJlZml4IGhlcmUgaXMgYSBwYXRobmFtZS1zdHlsZSxcbiAgLy8gcmVzdG9yZSB0aGUgbGVhZGluZyBzbGFzaFxuICByZXR1cm4gYC8ke2VzY2FwZWRBc3NldFByZWZpeH1gXG59XG4iXSwibmFtZXMiOlsibm9ybWFsaXplZEFzc2V0UHJlZml4IiwiYXNzZXRQcmVmaXgiLCJlc2NhcGVkQXNzZXRQcmVmaXgiLCJyZXBsYWNlIiwiVVJMIiwiY2FuUGFyc2UiLCJ1cmwiLCJ0b1N0cmluZyIsImVuZHNXaXRoIiwic2xpY2UiXSwibWFwcGluZ3MiOiI7OzsrQkFBZ0JBLHlCQUFBQTs7O2VBQUFBOzs7QUFBVCxTQUFTQSxzQkFBc0JDLFdBQStCO0lBQ25FLGtEQUFrRDtJQUNsRCxNQUFNQyxxQkFBcUJELENBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFlBQWFFLE9BQU8sQ0FBQyxjQUFjLEdBQUEsS0FBTztJQUVyRSxvREFBb0Q7SUFDcEQsb0RBQW9EO0lBQ3BELElBQUksQ0FBQ0Qsb0JBQW9CO1FBQ3ZCLE9BQU87SUFDVDtJQUVBLElBQUlFLElBQUlDLFFBQVEsQ0FBQ0gscUJBQXFCO1FBQ3BDLE1BQU1JLE1BQU0sSUFBSUYsSUFBSUYsb0JBQW9CSyxRQUFRO1FBQ2hELE9BQU9ELElBQUlFLFFBQVEsQ0FBQyxPQUFPRixJQUFJRyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUtIO0lBQ2hEO0lBRUEsaURBQWlEO0lBQ2pELDRCQUE0QjtJQUM1QixPQUFRLE1BQUdKO0FBQ2IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTEwMCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zaGFyZWQvbGliL3NlcnZlci1yZWZlcmVuY2UtaW5mby50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIFNlcnZlclJlZmVyZW5jZUluZm8ge1xuICB0eXBlOiAnc2VydmVyLWFjdGlvbicgfCAndXNlLWNhY2hlJ1xuICB1c2VkQXJnczogW2Jvb2xlYW4sIGJvb2xlYW4sIGJvb2xlYW4sIGJvb2xlYW4sIGJvb2xlYW4sIGJvb2xlYW5dXG4gIGhhc1Jlc3RBcmdzOiBib29sZWFuXG59XG5cbi8qKlxuICogRXh0cmFjdHMgaW5mbyBhYm91dCB0aGUgc2VydmVyIHJlZmVyZW5jZSBmb3IgdGhlIGdpdmVuIHNlcnZlciByZWZlcmVuY2UgSUQgYnlcbiAqIHBhcnNpbmcgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIGhleC1lbmNvZGVkIElELlxuICpcbiAqIGBgYFxuICogQml0IHBvc2l0aW9uczogWzddICAgICAgWzZdIFs1XSBbNF0gWzNdIFsyXSBbMV0gIFswXVxuICogQml0czogICAgICAgICAgdHlwZUJpdCAgYXJnTWFzayAgICAgICAgICAgICAgICAgIHJlc3RBcmdzXG4gKiBgYGBcbiAqXG4gKiBJZiB0aGUgYHR5cGVCaXRgIGlzIGAxYCB0aGUgc2VydmVyIHJlZmVyZW5jZSByZXByZXNlbnRzIGEgYFwidXNlIGNhY2hlXCJgXG4gKiBmdW5jdGlvbiwgb3RoZXJ3aXNlIGEgc2VydmVyIGFjdGlvbi5cbiAqXG4gKiBUaGUgYGFyZ01hc2tgIGVuY29kZXMgd2hldGhlciB0aGUgZnVuY3Rpb24gdXNlcyB0aGUgYXJndW1lbnQgYXQgdGhlXG4gKiByZXNwZWN0aXZlIHBvc2l0aW9uLlxuICpcbiAqIFRoZSBgcmVzdEFyZ3NgIGJpdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZnVuY3Rpb24gdXNlcyBhIHJlc3QgcGFyYW1ldGVyLiBJdCdzXG4gKiBhbHNvIHNldCB0byAxIGlmIHRoZSBmdW5jdGlvbiBoYXMgbW9yZSB0aGFuIDYgYXJncy5cbiAqXG4gKiBAcGFyYW0gaWQgaGV4LWVuY29kZWQgc2VydmVyIHJlZmVyZW5jZSBJRFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEluZm9Gcm9tU2VydmVyUmVmZXJlbmNlSWQoXG4gIGlkOiBzdHJpbmdcbik6IFNlcnZlclJlZmVyZW5jZUluZm8ge1xuICBjb25zdCBpbmZvQnl0ZSA9IHBhcnNlSW50KGlkLnNsaWNlKDAsIDIpLCAxNilcbiAgY29uc3QgdHlwZUJpdCA9IChpbmZvQnl0ZSA+PiA3KSAmIDB4MVxuICBjb25zdCBhcmdNYXNrID0gKGluZm9CeXRlID4+IDEpICYgMHgzZlxuICBjb25zdCByZXN0QXJncyA9IGluZm9CeXRlICYgMHgxXG4gIGNvbnN0IHVzZWRBcmdzID0gQXJyYXkoNilcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgNjsgaW5kZXgrKykge1xuICAgIGNvbnN0IGJpdFBvc2l0aW9uID0gNSAtIGluZGV4XG4gICAgY29uc3QgYml0ID0gKGFyZ01hc2sgPj4gYml0UG9zaXRpb24pICYgMHgxXG4gICAgdXNlZEFyZ3NbaW5kZXhdID0gYml0ID09PSAxXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGVCaXQgPT09IDEgPyAndXNlLWNhY2hlJyA6ICdzZXJ2ZXItYWN0aW9uJyxcbiAgICB1c2VkQXJnczogdXNlZEFyZ3MgYXMgW1xuICAgICAgYm9vbGVhbixcbiAgICAgIGJvb2xlYW4sXG4gICAgICBib29sZWFuLFxuICAgICAgYm9vbGVhbixcbiAgICAgIGJvb2xlYW4sXG4gICAgICBib29sZWFuLFxuICAgIF0sXG4gICAgaGFzUmVzdEFyZ3M6IHJlc3RBcmdzID09PSAxLFxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNwYXJzZSBhcnJheSBjb250YWluaW5nIG9ubHkgdGhlIHVzZWQgYXJndW1lbnRzIGJhc2VkIG9uIHRoZVxuICogcHJvdmlkZWQgYWN0aW9uIGluZm8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbWl0VW51c2VkQXJncyhcbiAgYXJnczogdW5rbm93bltdLFxuICBpbmZvOiBTZXJ2ZXJSZWZlcmVuY2VJbmZvXG4pOiB1bmtub3duW10ge1xuICBjb25zdCBmaWx0ZXJlZEFyZ3MgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgpXG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFyZ3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaWYgKFxuICAgICAgKGluZGV4IDwgNiAmJiBpbmZvLnVzZWRBcmdzW2luZGV4XSkgfHxcbiAgICAgIC8vIFRoaXMgYXNzdW1lcyB0aGF0IHRoZSBzZXJ2ZXIgcmVmZXJlbmNlIGluZm8gYnl0ZSBoYXMgdGhlIHJlc3RBcmdzIGJpdFxuICAgICAgLy8gc2V0IHRvIDEgaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiA2IGFyZ3MuXG4gICAgICAoaW5kZXggPj0gNiAmJiBpbmZvLmhhc1Jlc3RBcmdzKVxuICAgICkge1xuICAgICAgZmlsdGVyZWRBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbHRlcmVkQXJnc1xufVxuIl0sIm5hbWVzIjpbImV4dHJhY3RJbmZvRnJvbVNlcnZlclJlZmVyZW5jZUlkIiwib21pdFVudXNlZEFyZ3MiLCJpZCIsImluZm9CeXRlIiwicGFyc2VJbnQiLCJzbGljZSIsInR5cGVCaXQiLCJhcmdNYXNrIiwicmVzdEFyZ3MiLCJ1c2VkQXJncyIsIkFycmF5IiwiaW5kZXgiLCJiaXRQb3NpdGlvbiIsImJpdCIsInR5cGUiLCJoYXNSZXN0QXJncyIsImFyZ3MiLCJpbmZvIiwiZmlsdGVyZWRBcmdzIiwibGVuZ3RoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQTBCZ0JBLGdDQUFnQyxFQUFBO2VBQWhDQTs7SUFpQ0FDLGNBQWMsRUFBQTtlQUFkQTs7O0FBakNULFNBQVNELGlDQUNkRSxFQUFVO0lBRVYsTUFBTUMsV0FBV0MsU0FBU0YsR0FBR0csS0FBSyxDQUFDLEdBQUcsSUFBSTtJQUMxQyxNQUFNQyxVQUFXSCxZQUFZLElBQUs7SUFDbEMsTUFBTUksVUFBV0osWUFBWSxJQUFLO0lBQ2xDLE1BQU1LLFdBQVdMLFdBQVc7SUFDNUIsTUFBTU0sV0FBV0MsTUFBTTtJQUV2QixJQUFLLElBQUlDLFFBQVEsR0FBR0EsUUFBUSxHQUFHQSxRQUFTO1FBQ3RDLE1BQU1DLGNBQWMsSUFBSUQ7UUFDeEIsTUFBTUUsTUFBT04sV0FBV0ssY0FBZTtRQUN2Q0gsUUFBUSxDQUFDRSxNQUFNLEdBQUdFLFFBQVE7SUFDNUI7SUFFQSxPQUFPO1FBQ0xDLE1BQU1SLFlBQVksSUFBSSxjQUFjO1FBQ3BDRyxVQUFVQTtRQVFWTSxhQUFhUCxhQUFhO0lBQzVCO0FBQ0Y7QUFNTyxTQUFTUCxlQUNkZSxJQUFlLEVBQ2ZDLElBQXlCO0lBRXpCLE1BQU1DLGVBQWUsSUFBSVIsTUFBTU0sS0FBS0csTUFBTTtJQUUxQyxJQUFLLElBQUlSLFFBQVEsR0FBR0EsUUFBUUssS0FBS0csTUFBTSxFQUFFUixRQUFTO1FBQ2hELElBQ0dBLFFBQVEsS0FBS00sS0FBS1IsUUFBUSxDQUFDRSxNQUFNLElBQ2xDLHdFQUF3RTtRQUN4RSwwQ0FBMEM7UUFDekNBLFNBQVMsS0FBS00sS0FBS0YsV0FBVyxFQUMvQjtZQUNBRyxZQUFZLENBQUNQLE1BQU0sR0FBR0ssSUFBSSxDQUFDTCxNQUFNO1FBQ25DO0lBQ0Y7SUFFQSxPQUFPTztBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDExNTUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbGliL2lzLWVycm9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICcuLi9zaGFyZWQvbGliL2lzLXBsYWluLW9iamVjdCdcblxuLy8gV2UgYWxsb3cgc29tZSBhZGRpdGlvbmFsIGF0dGFjaGVkIHByb3BlcnRpZXMgZm9yIE5leHQuanMgZXJyb3JzXG5leHBvcnQgaW50ZXJmYWNlIE5leHRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgdHlwZT86IHN0cmluZ1xuICBwYWdlPzogc3RyaW5nXG4gIGNvZGU/OiBzdHJpbmcgfCBudW1iZXJcbiAgY2FuY2VsbGVkPzogYm9vbGVhblxuICBkaWdlc3Q/OiBudW1iZXJcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBOZXh0RXJyb3IuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIHByaW50IGEgbW9yZSBkZXRhaWxlZCBlcnJvciBtZXNzYWdlIHdpdGggcHJvcGVydGllcyBsaWtlIGBjb2RlYCAmIGBkaWdlc3RgLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0Vycm9yKGVycjogdW5rbm93bik6IGVyciBpcyBOZXh0RXJyb3Ige1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBlcnIgPT09ICdvYmplY3QnICYmIGVyciAhPT0gbnVsbCAmJiAnbmFtZScgaW4gZXJyICYmICdtZXNzYWdlJyBpbiBlcnJcbiAgKVxufVxuXG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5KG9iajogYW55KSB7XG4gIGNvbnN0IHNlZW4gPSBuZXcgV2Vha1NldCgpXG5cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgKF9rZXksIHZhbHVlKSA9PiB7XG4gICAgLy8gSWYgdmFsdWUgaXMgYW4gb2JqZWN0IGFuZCBhbHJlYWR5IHNlZW4sIHJlcGxhY2Ugd2l0aCBcIltDaXJjdWxhcl1cIlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSdcbiAgICAgIH1cbiAgICAgIHNlZW4uYWRkKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3BlckVycm9yKGVycjogdW5rbm93bik6IEVycm9yIHtcbiAgaWYgKGlzRXJyb3IoZXJyKSkge1xuICAgIHJldHVybiBlcnJcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIC8vIHByb3ZpZGUgYmV0dGVyIGVycm9yIGZvciBjYXNlIHdoZXJlIGB0aHJvdyB1bmRlZmluZWRgXG4gICAgLy8gaXMgY2FsbGVkIGluIGRldmVsb3BtZW50XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAnQW4gdW5kZWZpbmVkIGVycm9yIHdhcyB0aHJvd24sICcgK1xuICAgICAgICAgICdzZWUgaGVyZSBmb3IgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy90aHJldy11bmRlZmluZWQnXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgJ0EgbnVsbCBlcnJvciB3YXMgdGhyb3duLCAnICtcbiAgICAgICAgICAnc2VlIGhlcmUgZm9yIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvdGhyZXctdW5kZWZpbmVkJ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgRXJyb3IoaXNQbGFpbk9iamVjdChlcnIpID8gc2FmZVN0cmluZ2lmeShlcnIpIDogZXJyICsgJycpXG59XG4iXSwibmFtZXMiOlsiaXNFcnJvciIsImdldFByb3BlckVycm9yIiwiZXJyIiwic2FmZVN0cmluZ2lmeSIsIm9iaiIsInNlZW4iLCJXZWFrU2V0IiwiSlNPTiIsInN0cmluZ2lmeSIsIl9rZXkiLCJ2YWx1ZSIsImhhcyIsImFkZCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIkVycm9yIiwiaXNQbGFpbk9iamVjdCJdLCJtYXBwaW5ncyI6IkFBeUNNYSxRQUFRQyxHQUFHLENBQUNDLFFBQVEsS0FBSzs7Ozs7Ozs7Ozs7Ozs7OztJQTlCL0I7OztDQUdDLEdBQ0QsT0FJQyxFQUFBO2VBSnVCZjs7SUFxQlJDLGNBQWMsRUFBQTtlQUFkQTs7OytCQXBDYztBQWVmLFNBQVNELFFBQVFFLEdBQVk7SUFDMUMsT0FDRSxPQUFPQSxRQUFRLFlBQVlBLFFBQVEsUUFBUSxVQUFVQSxPQUFPLGFBQWFBO0FBRTdFO0FBRUEsU0FBU0MsY0FBY0MsR0FBUTtJQUM3QixNQUFNQyxPQUFPLElBQUlDO0lBRWpCLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ0osS0FBSyxDQUFDSyxNQUFNQztRQUNoQyxvRUFBb0U7UUFDcEUsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsTUFBTTtZQUMvQyxJQUFJTCxLQUFLTSxHQUFHLENBQUNELFFBQVE7Z0JBQ25CLE9BQU87WUFDVDtZQUNBTCxLQUFLTyxHQUFHLENBQUNGO1FBQ1g7UUFDQSxPQUFPQTtJQUNUO0FBQ0Y7QUFFTyxTQUFTVCxlQUFlQyxHQUFZO0lBQ3pDLElBQUlGLFFBQVFFLE1BQU07UUFDaEIsT0FBT0E7SUFDVDtJQUVBLHdDQUE0QztRQUMxQyx3REFBd0Q7UUFDeEQsMkJBQTJCO1FBQzNCLElBQUksT0FBT0EsUUFBUSxhQUFhO1lBQzlCLE9BQU8sT0FBQSxjQUdOLENBSE0sSUFBSWMsTUFDVCxvQ0FDRSw2RUFGRyxxQkFBQTt1QkFBQTs0QkFBQTs4QkFBQTtZQUdQO1FBQ0Y7UUFFQSxJQUFJZCxRQUFRLE1BQU07WUFDaEIsT0FBTyxPQUFBLGNBR04sQ0FITSxJQUFJYyxNQUNULDhCQUNFLDZFQUZHLHFCQUFBO3VCQUFBOzRCQUFBOzhCQUFBO1lBR1A7UUFDRjtJQUNGO0lBRUEsT0FBTyxPQUFBLGNBQTZELENBQTdELElBQUlBLE1BQU1DLENBQUFBLEdBQUFBLGVBQUFBLGFBQWEsRUFBQ2YsT0FBT0MsY0FBY0QsT0FBT0EsTUFBTSxLQUExRCxxQkFBQTtlQUFBO29CQUFBO3NCQUFBO0lBQTREO0FBQ3JFIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEyMzIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbGliL3JlcXVpcmUtaW5zdHJ1bWVudGF0aW9uLWNsaWVudC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgbW9kdWxlIGltcG9ydHMgdGhlIGNsaWVudCBpbnN0cnVtZW50YXRpb24gaG9vayBmcm9tIHRoZSBwcm9qZWN0IHJvb3QuXG4gKlxuICogVGhlIGBwcml2YXRlLW5leHQtaW5zdHJ1bWVudGF0aW9uLWNsaWVudGAgbW9kdWxlIGlzIGF1dG9tYXRpY2FsbHkgYWxpYXNlZCB0b1xuICogdGhlIGBpbnN0cnVtZW50YXRpb24tY2xpZW50LnRzYCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QgYnkgd2VicGFjayBvciB0dXJib3BhY2suXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICBjb25zdCBtZWFzdXJlTmFtZSA9ICdDbGllbnQgSW5zdHJ1bWVudGF0aW9uIEhvb2snXG4gIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAbmV4dC9pbnRlcm5hbC90eXBlY2hlY2tlZC1yZXF1aXJlIC0tIE5vdCBhIG1vZHVsZS5cbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdwcml2YXRlLW5leHQtaW5zdHJ1bWVudGF0aW9uLWNsaWVudCcpXG4gIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICBjb25zdCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWVcblxuICAvLyBVc2luZyAxNm1zIHRocmVzaG9sZCBhcyBpdCByZXByZXNlbnRzIG9uZSBmcmFtZSAoMTAwMG1zLzYwZnBzKVxuICAvLyBUaGlzIGhlbHBzIGlkZW50aWZ5IGlmIHRoZSBpbnN0cnVtZW50YXRpb24gaG9vayBpbml0aWFsaXphdGlvblxuICAvLyBjb3VsZCBwb3RlbnRpYWxseSBjYXVzZSBmcmFtZSBkcm9wcyBkdXJpbmcgZGV2ZWxvcG1lbnQuXG4gIGNvbnN0IFRIUkVTSE9MRCA9IDE2XG4gIGlmIChkdXJhdGlvbiA+IFRIUkVTSE9MRCkge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYFske21lYXN1cmVOYW1lfV0gU2xvdyBleGVjdXRpb24gZGV0ZWN0ZWQ6ICR7ZHVyYXRpb24udG9GaXhlZCgwKX1tcyAoTm90ZTogQ29kZSBkb3dubG9hZCBvdmVyaGVhZCBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBtZWFzdXJlbWVudClgXG4gICAgKVxuICB9XG59IGVsc2Uge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQG5leHQvaW50ZXJuYWwvdHlwZWNoZWNrZWQtcmVxdWlyZSAtLSBOb3QgYSBtb2R1bGUuXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgncHJpdmF0ZS1uZXh0LWluc3RydW1lbnRhdGlvbi1jbGllbnQnKVxufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm1lYXN1cmVOYW1lIiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsImVuZFRpbWUiLCJkdXJhdGlvbiIsIlRIUkVTSE9MRCIsImNvbnNvbGUiLCJsb2ciLCJ0b0ZpeGVkIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQyxHQUNHQSxRQUFRQyxHQUFHLENBQUNDLFFBQVEsS0FBSztBQUQ1QjtBQUNELHdDQUE0QztJQUMxQyxNQUFNQyxjQUFjO0lBQ3BCLE1BQU1DLFlBQVlDLFlBQVlDLEdBQUc7SUFDakMsK0VBQStFO0lBQy9FQyxPQUFPQyxPQUFPLEdBQUdDLFFBQVE7SUFDekIsTUFBTUMsVUFBVUwsWUFBWUMsR0FBRztJQUMvQixNQUFNSyxXQUFXRCxVQUFVTjtJQUUzQixpRUFBaUU7SUFDakUsaUVBQWlFO0lBQ2pFLDBEQUEwRDtJQUMxRCxNQUFNUSxZQUFZO0lBQ2xCLElBQUlELFdBQVdDLFdBQVc7UUFDeEJDLFFBQVFDLEdBQUcsQ0FDVCxBQUFDLENBQUMsVUFBRVgsYUFBWSwyQkFBMkIsV0FBRVEsU0FBU0ksT0FBTyxDQUFDLElBQUcscUVBQXFFLENBQUM7SUFFM0k7QUFDRixPQUFPIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEyNjIsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbGliL21ldGFkYXRhL21ldGFkYXRhLWNvbnN0YW50cy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IE1FVEFEQVRBX0JPVU5EQVJZX05BTUUgPSAnX19uZXh0X21ldGFkYXRhX2JvdW5kYXJ5X18nXG5leHBvcnQgY29uc3QgVklFV1BPUlRfQk9VTkRBUllfTkFNRSA9ICdfX25leHRfdmlld3BvcnRfYm91bmRhcnlfXydcbmV4cG9ydCBjb25zdCBPVVRMRVRfQk9VTkRBUllfTkFNRSA9ICdfX25leHRfb3V0bGV0X2JvdW5kYXJ5X18nXG4iXSwibmFtZXMiOlsiTUVUQURBVEFfQk9VTkRBUllfTkFNRSIsIk9VVExFVF9CT1VOREFSWV9OQU1FIiwiVklFV1BPUlRfQk9VTkRBUllfTkFNRSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0lBQWFBLHNCQUFzQixFQUFBO2VBQXRCQTs7SUFFQUMsb0JBQW9CLEVBQUE7ZUFBcEJBOztJQURBQyxzQkFBc0IsRUFBQTtlQUF0QkE7OztBQUROLE1BQU1GLHlCQUF5QjtBQUMvQixNQUFNRSx5QkFBeUI7QUFDL0IsTUFBTUQsdUJBQXVCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEyOTYsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbGliL3NjaGVkdWxlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdHlwZSBTY2hlZHVsZWRGbjxUID0gdm9pZD4gPSAoKSA9PiBUIHwgUHJvbWlzZUxpa2U8VD5cbmV4cG9ydCB0eXBlIFNjaGVkdWxlckZuPFQgPSB2b2lkPiA9IChjYjogU2NoZWR1bGVkRm48VD4pID0+IHZvaWRcblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gdGhlIG5leHQgdGljayBhZnRlciB0aGUgb3RoZXIgcHJvbWlzZXNcbiAqIGhhdmUgYmVlbiByZXNvbHZlZC5cbiAqXG4gKiBAcGFyYW0gY2IgdGhlIGZ1bmN0aW9uIHRvIHNjaGVkdWxlXG4gKi9cbmV4cG9ydCBjb25zdCBzY2hlZHVsZU9uTmV4dFRpY2sgPSAoY2I6IFNjaGVkdWxlZEZuPHZvaWQ+KSA9PiB7XG4gIC8vIFdlIHVzZSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCkgaGVyZSBzbyB0aGF0IHRoZSBvcGVyYXRpb24gaXMgc2NoZWR1bGVkIGF0XG4gIC8vIHRoZSBlbmQgb2YgdGhlIHByb21pc2Ugam9iIHF1ZXVlLCB3ZSB0aGVuIGFkZCBpdCB0byB0aGUgbmV4dCBwcm9jZXNzIHRpY2tcbiAgLy8gdG8gZW5zdXJlIGl0J3MgZXZhbHVhdGVkIGFmdGVyd2FyZHMuXG4gIC8vXG4gIC8vIFRoaXMgd2FzIGluc3BpcmVkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgRGF0YUxvYWRlciBpbnRlcmZhY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaHFsL2RhdGFsb2FkZXIvYmxvYi9kMzM2YmQxNTI4MjY2NGUwYmU0YjRhNjU3Y2I3OTZmMDliYWZiYzZiL3NyYy9pbmRleC5qcyNMMjEzLUwyNTVcbiAgLy9cbiAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gJ2VkZ2UnKSB7XG4gICAgICBzZXRUaW1lb3V0KGNiLCAwKVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgdXNpbmcgYHNldEltbWVkaWF0ZWAgb3IgYHNldFRpbWVvdXRgIGlmXG4gKiBgc2V0SW1tZWRpYXRlYCBpcyBub3QgYXZhaWxhYmxlIChsaWtlIGluIHRoZSBFZGdlIHJ1bnRpbWUpLlxuICpcbiAqIEBwYXJhbSBjYiB0aGUgZnVuY3Rpb24gdG8gc2NoZWR1bGVcbiAqL1xuZXhwb3J0IGNvbnN0IHNjaGVkdWxlSW1tZWRpYXRlID0gKGNiOiBTY2hlZHVsZWRGbjx2b2lkPik6IHZvaWQgPT4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSAnZWRnZScpIHtcbiAgICBzZXRUaW1lb3V0KGNiLCAwKVxuICB9IGVsc2Uge1xuICAgIHNldEltbWVkaWF0ZShjYilcbiAgfVxufVxuXG4vKipcbiAqIHJldHVybnMgYSBwcm9taXNlIHRoYW4gcmVzb2x2ZXMgaW4gYSBmdXR1cmUgdGFzay4gVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIHRhc2sgaXQgcmVzb2x2ZXMgaW5cbiAqIHdpbGwgYmUgdGhlIG5leHQgdGFzayBidXQgaWYgeW91IGF3YWl0IGl0IHlvdSBjYW4gYXQgbGVhc3QgYmUgc3VyZSB0aGF0IHRoZSBjdXJyZW50IHRhc2sgaXMgb3ZlciBhbmRcbiAqIG1vc3QgdXNlZnVsbHkgdGhhdCB0aGUgZW50aXJlIG1pY3JvdGFzayBxdWV1ZSBvZiB0aGUgY3VycmVudCB0YXNrIGhhcyBiZWVuIGVtcHRpZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdExlYXN0T25lVGFzaygpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiBzY2hlZHVsZUltbWVkaWF0ZShyZXNvbHZlKSlcbn1cblxuLyoqXG4gKiBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gaXMgZXh0cmFjdGVkIHRvIG1ha2UgaXQgZWFzaWVyIHRvIGZpbmQgcGxhY2VzIHdoZXJlIHdlIGFyZSBkb2luZ1xuICogc3BlY2lmaWMgdGltaW5nIHRyaWNrcyB0byB0cnkgdG8gc2NoZWR1bGUgd29yayBhZnRlciBSZWFjdCBoYXMgcmVuZGVyZWQuIFRoaXMgaXMgZXNwZWNpYWxseVxuICogaW1wb3J0YW50IGF0IHRoZSBtb21lbnQgYmVjYXVzZSBOZXh0LmpzIHVzZXMgdGhlIGVkZ2UgYnVpbGRzIG9mIFJlYWN0IHdoaWNoIHVzZSBzZXRUaW1lb3V0IHRvXG4gKiBzY2hlZHVsZSB3b3JrIHdoZW4geW91IG1pZ2h0IGV4cGVjdCB0aGF0IHNvbWV0aGluZyBsaWtlIHNldEltbWVkaWF0ZSB3b3VsZCBkbyB0aGUgdHJpY2suXG4gKlxuICogTG9uZyB0ZXJtIHdlIHNob3VsZCBzd2l0Y2ggdG8gdGhlIG5vZGUgdmVyc2lvbnMgb2YgUmVhY3QgcmVuZGVyaW5nIHdoZW4gcG9zc2libGUgYW5kIHRoZW5cbiAqIHVwZGF0ZSB0aGlzIHRvIHVzZSBzZXRJbW1lZGlhdGUgcmF0aGVyIHRoYW4gc2V0VGltZW91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gd2FpdEF0TGVhc3RPbmVSZWFjdFJlbmRlclRhc2soKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmIChwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPT09ICdlZGdlJykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCAwKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHIpID0+IHNldEltbWVkaWF0ZShyKSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbImF0TGVhc3RPbmVUYXNrIiwic2NoZWR1bGVJbW1lZGlhdGUiLCJzY2hlZHVsZU9uTmV4dFRpY2siLCJ3YWl0QXRMZWFzdE9uZVJlYWN0UmVuZGVyVGFzayIsImNiIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUlVOVElNRSIsInNldFRpbWVvdXQiLCJuZXh0VGljayIsInNldEltbWVkaWF0ZSIsInIiXSwibWFwcGluZ3MiOiJBQWlCUVEsUUFBUUMsR0FBRyxDQUFDQyxZQUFZLEtBQUssUUFBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMkI3QlYsY0FBYyxFQUFBO2VBQWRBOztJQWJIQyxpQkFBaUIsRUFBQTtlQUFqQkE7O0lBdEJBQyxrQkFBa0IsRUFBQTtlQUFsQkE7O0lBZ0RHQyw2QkFBNkIsRUFBQTtlQUE3QkE7OztBQWhEVCxNQUFNRCxxQkFBcUIsQ0FBQ0U7SUFDakMsNkVBQTZFO0lBQzdFLDRFQUE0RTtJQUM1RSx1Q0FBdUM7SUFDdkMsRUFBRTtJQUNGLGtMQUFrTDtJQUNsTCxFQUFFO0lBQ0ZDLFFBQVFDLE9BQU8sR0FBR0MsSUFBSSxDQUFDO1FBQ3JCOzthQUVPOzZLQUNMQyxVQUFBQSxDQUFRSSxRQUFRLENBQUNSO1FBQ25CO0lBQ0Y7QUFDRjtBQVFPLE1BQU1ILG9CQUFvQixDQUFDRztJQUNoQyxJQUFJSSxRQUFRQyxHQUFHLENBQUNDLFlBQVksS0FBSyxRQUFROztTQUVsQztRQUNMRyxhQUFhVDtJQUNmO0FBQ0Y7QUFPTyxTQUFTSjtJQUNkLE9BQU8sSUFBSUssUUFBYyxDQUFDQyxVQUFZTCxrQkFBa0JLO0FBQzFEO0FBV08sU0FBU0g7SUFDZCxJQUFJSyxRQUFRQyxHQUFHLENBQUNDLFlBQVksS0FBSyxRQUFROztTQUVsQztRQUNMLE9BQU8sSUFBSUwsUUFBUSxDQUFDUyxJQUFNRCxhQUFhQztJQUN6QztBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDEzNjUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2Vycm9ycy9zdGl0Y2hlZC1lcnJvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgaXNFcnJvciBmcm9tICcuLi8uLi8uLi8uLi9saWIvaXMtZXJyb3InXG5cbmNvbnN0IG93bmVyU3RhY2tzID0gbmV3IFdlYWtNYXA8RXJyb3IsIHN0cmluZyB8IG51bGw+KClcbmNvbnN0IGNvbXBvbmVudFN0YWNrcyA9IG5ldyBXZWFrTWFwPEVycm9yLCBzdHJpbmc+KClcblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbXBvbmVudFN0YWNrKGVycm9yOiBFcnJvcik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBjb21wb25lbnRTdGFja3MuZ2V0KGVycm9yKVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNldENvbXBvbmVudFN0YWNrKGVycm9yOiBFcnJvciwgc3RhY2s6IHN0cmluZykge1xuICBjb21wb25lbnRTdGFja3Muc2V0KGVycm9yLCBzdGFjaylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE93bmVyU3RhY2soZXJyb3I6IEVycm9yKTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBvd25lclN0YWNrcy5nZXQoZXJyb3IpXG59XG5leHBvcnQgZnVuY3Rpb24gc2V0T3duZXJTdGFjayhlcnJvcjogRXJyb3IsIHN0YWNrOiBzdHJpbmcgfCBudWxsKSB7XG4gIG93bmVyU3RhY2tzLnNldChlcnJvciwgc3RhY2spXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb2VyY2VFcnJvcih2YWx1ZTogdW5rbm93bik6IEVycm9yIHtcbiAgcmV0dXJuIGlzRXJyb3IodmFsdWUpID8gdmFsdWUgOiBuZXcgRXJyb3IoJycgKyB2YWx1ZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldE93bmVyU3RhY2tJZkF2YWlsYWJsZShlcnJvcjogRXJyb3IpOiB2b2lkIHtcbiAgLy8gUmVhY3QgMTggYW5kIHByb2QgZG9lcyBub3QgaGF2ZSBgY2FwdHVyZU93bmVyU3RhY2tgXG4gIGlmICgnY2FwdHVyZU93bmVyU3RhY2snIGluIFJlYWN0KSB7XG4gICAgc2V0T3duZXJTdGFjayhlcnJvciwgUmVhY3QuY2FwdHVyZU93bmVyU3RhY2soKSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb3JhdGVEZXZFcnJvcihcbiAgdGhyb3duVmFsdWU6IHVua25vd24sXG4gIGVycm9ySW5mbzogUmVhY3QuRXJyb3JJbmZvXG4pIHtcbiAgY29uc3QgZXJyb3IgPSBjb2VyY2VFcnJvcih0aHJvd25WYWx1ZSlcbiAgc2V0T3duZXJTdGFja0lmQXZhaWxhYmxlKGVycm9yKVxuICAvLyBUT0RPOiBjaGFuZ2UgdG8gcGFzc2luZyBkb3duIGVycm9ySW5mbyBsYXRlclxuICAvLyBJbiBkZXZlbG9wbWVudCBtb2RlLCBwYXNzIGFsb25nIHRoZSBjb21wb25lbnQgc3RhY2sgdG8gdGhlIGVycm9yXG4gIGlmIChlcnJvckluZm8uY29tcG9uZW50U3RhY2spIHtcbiAgICBzZXRDb21wb25lbnRTdGFjayhlcnJvciwgZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrKVxuICB9XG4gIHJldHVybiBlcnJvclxufVxuIl0sIm5hbWVzIjpbImNvZXJjZUVycm9yIiwiZGVjb3JhdGVEZXZFcnJvciIsImdldENvbXBvbmVudFN0YWNrIiwiZ2V0T3duZXJTdGFjayIsInNldENvbXBvbmVudFN0YWNrIiwic2V0T3duZXJTdGFjayIsInNldE93bmVyU3RhY2tJZkF2YWlsYWJsZSIsIm93bmVyU3RhY2tzIiwiV2Vha01hcCIsImNvbXBvbmVudFN0YWNrcyIsImVycm9yIiwiZ2V0Iiwic3RhY2siLCJzZXQiLCJ2YWx1ZSIsImlzRXJyb3IiLCJFcnJvciIsIlJlYWN0IiwiY2FwdHVyZU93bmVyU3RhY2siLCJ0aHJvd25WYWx1ZSIsImVycm9ySW5mbyIsImNvbXBvbmVudFN0YWNrIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBb0JnQkEsV0FBVyxFQUFBO2VBQVhBOztJQVdBQyxnQkFBZ0IsRUFBQTtlQUFoQkE7O0lBekJBQyxpQkFBaUIsRUFBQTtlQUFqQkE7O0lBT0FDLGFBQWEsRUFBQTtlQUFiQTs7SUFKQUMsaUJBQWlCLEVBQUE7ZUFBakJBOztJQU9BQyxhQUFhLEVBQUE7ZUFBYkE7O0lBUUFDLHdCQUF3QixFQUFBO2VBQXhCQTs7OztnRUF4QkU7a0VBQ0U7QUFFcEIsTUFBTUMsY0FBYyxJQUFJQztBQUN4QixNQUFNQyxrQkFBa0IsSUFBSUQ7QUFFckIsU0FBU04sa0JBQWtCUSxLQUFZO0lBQzVDLE9BQU9ELGdCQUFnQkUsR0FBRyxDQUFDRDtBQUM3QjtBQUNPLFNBQVNOLGtCQUFrQk0sS0FBWSxFQUFFRSxLQUFhO0lBQzNESCxnQkFBZ0JJLEdBQUcsQ0FBQ0gsT0FBT0U7QUFDN0I7QUFFTyxTQUFTVCxjQUFjTyxLQUFZO0lBQ3hDLE9BQU9ILFlBQVlJLEdBQUcsQ0FBQ0Q7QUFDekI7QUFDTyxTQUFTTCxjQUFjSyxLQUFZLEVBQUVFLEtBQW9CO0lBQzlETCxZQUFZTSxHQUFHLENBQUNILE9BQU9FO0FBQ3pCO0FBRU8sU0FBU1osWUFBWWMsS0FBYztJQUN4QyxPQUFPQyxDQUFBQSxHQUFBQSxTQUFBQSxPQUFPLEVBQUNELFNBQVNBLFFBQVEsT0FBQSxjQUFxQixDQUFyQixJQUFJRSxNQUFNLEtBQUtGLFFBQWYscUJBQUE7ZUFBQTtvQkFBQTtzQkFBQTtJQUFvQjtBQUN0RDtBQUVPLFNBQVNSLHlCQUF5QkksS0FBWTtJQUNuRCxzREFBc0Q7SUFDdEQsSUFBSSx1QkFBdUJPLE9BQUFBLE9BQUssRUFBRTtRQUNoQ1osY0FBY0ssT0FBT08sT0FBQUEsT0FBSyxDQUFDQyxpQkFBaUI7SUFDOUM7QUFDRjtBQUVPLFNBQVNqQixpQkFDZGtCLFdBQW9CLEVBQ3BCQyxTQUEwQjtJQUUxQixNQUFNVixRQUFRVixZQUFZbUI7SUFDMUJiLHlCQUF5Qkk7SUFDekIsK0NBQStDO0lBQy9DLG1FQUFtRTtJQUNuRSxJQUFJVSxVQUFVQyxjQUFjLEVBQUU7UUFDNUJqQixrQkFBa0JNLE9BQU9VLFVBQVVDLGNBQWM7SUFDbkQ7SUFDQSxPQUFPWDtBQUNUIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE0NTksICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbmV4dC1kZXZ0b29scy9zaGFyZWQvY29uc29sZS1lcnJvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUbyBkaXN0aW5ndWlzaCBmcm9tIFJlYWN0IGVycm9yLmRpZ2VzdCwgd2UgdXNlIGEgZGlmZmVyZW50IHN5bWJvbCBoZXJlIHRvIGRldGVybWluZSBpZiB0aGUgZXJyb3IgaXMgZnJvbSBjb25zb2xlLmVycm9yIG9yIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbi5cbmNvbnN0IGRpZ2VzdFN5bSA9IFN5bWJvbC5mb3IoJ25leHQuY29uc29sZS5lcnJvci5kaWdlc3QnKVxuXG4vLyBSZXByZXNlbnQgbm9uIEVycm9yIHNoYXBlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnMgb3IgY29uc29sZS5lcnJvciBlcnJvcnMuXG4vLyBUaG9zZSBlcnJvcnMgd2lsbCBiZSBjYXB0dXJlZCBhbmQgZGlzcGxheWVkIGluIEVycm9yIE92ZXJsYXkuXG5leHBvcnQgdHlwZSBDb25zb2xlRXJyb3IgPSBFcnJvciAmIHtcbiAgW2RpZ2VzdFN5bV06ICdORVhUX0NPTlNPTEVfRVJST1InXG4gIGVudmlyb25tZW50TmFtZTogc3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb25zb2xlRXJyb3IoXG4gIG1lc3NhZ2U6IHN0cmluZyB8IEVycm9yLFxuICBlbnZpcm9ubWVudE5hbWU/OiBzdHJpbmcgfCBudWxsXG4pOiBDb25zb2xlRXJyb3Ige1xuICBjb25zdCBlcnJvciA9IChcbiAgICB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyBuZXcgRXJyb3IobWVzc2FnZSkgOiBtZXNzYWdlXG4gICkgYXMgQ29uc29sZUVycm9yXG4gIGVycm9yW2RpZ2VzdFN5bV0gPSAnTkVYVF9DT05TT0xFX0VSUk9SJ1xuXG4gIGlmIChlbnZpcm9ubWVudE5hbWUgJiYgIWVycm9yLmVudmlyb25tZW50TmFtZSkge1xuICAgIGVycm9yLmVudmlyb25tZW50TmFtZSA9IGVudmlyb25tZW50TmFtZVxuICB9XG5cbiAgcmV0dXJuIGVycm9yXG59XG5cbmV4cG9ydCBjb25zdCBpc0NvbnNvbGVFcnJvciA9IChlcnJvcjogYW55KTogZXJyb3IgaXMgQ29uc29sZUVycm9yID0+IHtcbiAgcmV0dXJuIGVycm9yICYmIGVycm9yW2RpZ2VzdFN5bV0gPT09ICdORVhUX0NPTlNPTEVfRVJST1InXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29uc29sZUVycm9yIiwiaXNDb25zb2xlRXJyb3IiLCJkaWdlc3RTeW0iLCJTeW1ib2wiLCJmb3IiLCJtZXNzYWdlIiwiZW52aXJvbm1lbnROYW1lIiwiZXJyb3IiLCJFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUEseUpBQXlKOzs7Ozs7Ozs7Ozs7Ozs7SUFVeklBLGtCQUFrQixFQUFBO2VBQWxCQTs7SUFnQkhDLGNBQWMsRUFBQTtlQUFkQTs7O0FBekJiLE1BQU1DLFlBQVlDLE9BQU9DLEdBQUcsQ0FBQztBQVN0QixTQUFTSixtQkFDZEssT0FBdUIsRUFDdkJDLGVBQStCO0lBRS9CLE1BQU1DLFFBQ0osT0FBT0YsWUFBWSxXQUFXLE9BQUEsY0FBa0IsQ0FBbEIsSUFBSUcsTUFBTUgsVUFBVixxQkFBQTtlQUFBO29CQUFBO3NCQUFBO0lBQWlCLEtBQUlBO0lBRXJERSxLQUFLLENBQUNMLFVBQVUsR0FBRztJQUVuQixJQUFJSSxtQkFBbUIsQ0FBQ0MsTUFBTUQsZUFBZSxFQUFFO1FBQzdDQyxNQUFNRCxlQUFlLEdBQUdBO0lBQzFCO0lBRUEsT0FBT0M7QUFDVDtBQUVPLE1BQU1OLGlCQUFpQixDQUFDTTtJQUM3QixPQUFPQSxTQUFTQSxLQUFLLENBQUNMLFVBQVUsS0FBSztBQUN2QyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxNTEwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC90ZXJtaW5hbC1sb2dnaW5nLWNvbmZpZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZ2V0VGVybWluYWxMb2dnaW5nQ29uZmlnKCk6XG4gIHwgZmFsc2VcbiAgfCBib29sZWFuXG4gIHwge1xuICAgICAgZGVwdGhMaW1pdD86IG51bWJlclxuICAgICAgZWRnZUxpbWl0PzogbnVtYmVyXG4gICAgICBzaG93U291cmNlTG9jYXRpb24/OiBib29sZWFuXG4gICAgfSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoXG4gICAgICBwcm9jZXNzLmVudi5fX05FWFRfQlJPV1NFUl9ERUJVR19JTkZPX0lOX1RFUk1JTkFMIHx8ICdmYWxzZSdcbiAgICApXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQoKTogYm9vbGVhbiB7XG4gIGNvbnN0IGNvbmZpZyA9IGdldFRlcm1pbmFsTG9nZ2luZ0NvbmZpZygpXG4gIHJldHVybiBCb29sZWFuKGNvbmZpZylcbn1cbiJdLCJuYW1lcyI6WyJnZXRJc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQiLCJnZXRUZXJtaW5hbExvZ2dpbmdDb25maWciLCJKU09OIiwicGFyc2UiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0JST1dTRVJfREVCVUdfSU5GT19JTl9URVJNSU5BTCIsImNvbmZpZyIsIkJvb2xlYW4iXSwibWFwcGluZ3MiOiJBQVVNSSxRQUFRQyxHQUFHLENBQUNDLHFDQUFxQzs7Ozs7Ozs7Ozs7Ozs7OztJQU92Q04sMkJBQTJCLEVBQUE7ZUFBM0JBOztJQWpCQUMsd0JBQXdCLEVBQUE7ZUFBeEJBOzs7QUFBVCxTQUFTQTtJQVFkLElBQUk7UUFDRixPQUFPQyxLQUFLQyxLQUFLLDhDQUNzQztJQUV6RCxFQUFFLE9BQUEsR0FBTTtRQUNOLE9BQU87SUFDVDtBQUNGO0FBRU8sU0FBU0g7SUFDZCxNQUFNTyxTQUFTTjtJQUNmLE9BQU9PLFFBQVFEO0FBQ2pCIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE1NTcsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbmV4dC1kZXZ0b29scy9zaGFyZWQvZm9yd2FyZC1sb2dzLXNoYXJlZC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdHlwZSBMb2dNZXRob2QgPVxuICB8ICdsb2cnXG4gIHwgJ2luZm8nXG4gIHwgJ2RlYnVnJ1xuICB8ICd0YWJsZSdcbiAgfCAnZXJyb3InXG4gIHwgJ2Fzc2VydCdcbiAgfCAnZGlyJ1xuICB8ICdkaXJ4bWwnXG4gIHwgJ2dyb3VwJ1xuICB8ICdncm91cENvbGxhcHNlZCdcbiAgfCAnZ3JvdXBFbmQnXG4gIHwgJ3RyYWNlJ1xuICB8ICd3YXJuJ1xuXG5leHBvcnQgdHlwZSBDb25zb2xlRW50cnk8VD4gPSB7XG4gIGtpbmQ6ICdjb25zb2xlJ1xuICBtZXRob2Q6IExvZ01ldGhvZFxuICBjb25zb2xlTWV0aG9kU3RhY2s6IHN0cmluZyB8IG51bGxcbiAgYXJnczogQXJyYXk8XG4gICAgfCB7XG4gICAgICAgIGtpbmQ6ICdhcmcnXG4gICAgICAgIGRhdGE6IFRcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAga2luZDogJ2Zvcm1hdHRlZC1lcnJvci1hcmcnXG4gICAgICAgIHByZWZpeDogc3RyaW5nXG4gICAgICAgIHN0YWNrOiBzdHJpbmdcbiAgICAgIH1cbiAgPlxufVxuXG5leHBvcnQgdHlwZSBDb25zb2xlRXJyb3JFbnRyeTxUPiA9IHtcbiAga2luZDogJ2FueS1sb2dnZWQtZXJyb3InXG4gIG1ldGhvZDogJ2Vycm9yJ1xuICBjb25zb2xlRXJyb3JTdGFjazogc3RyaW5nXG4gIGFyZ3M6IEFycmF5PFxuICAgIHwge1xuICAgICAgICBraW5kOiAnYXJnJ1xuICAgICAgICBkYXRhOiBUXG4gICAgICAgIGlzUmVqZWN0aW9uTWVzc2FnZT86IGJvb2xlYW5cbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAga2luZDogJ2Zvcm1hdHRlZC1lcnJvci1hcmcnXG4gICAgICAgIHByZWZpeDogc3RyaW5nXG4gICAgICAgIHN0YWNrOiBzdHJpbmcgfCBudWxsXG4gICAgICB9XG4gID5cbn1cblxuZXhwb3J0IHR5cGUgRm9ybWF0dGVkRXJyb3JFbnRyeSA9IHtcbiAga2luZDogJ2Zvcm1hdHRlZC1lcnJvcidcbiAgcHJlZml4OiBzdHJpbmdcbiAgc3RhY2s6IHN0cmluZ1xuICBtZXRob2Q6ICdlcnJvcidcbn1cblxuZXhwb3J0IHR5cGUgQ2xpZW50TG9nRW50cnkgPVxuICB8IENvbnNvbGVFbnRyeTx1bmtub3duPlxuICB8IENvbnNvbGVFcnJvckVudHJ5PHVua25vd24+XG4gIHwgRm9ybWF0dGVkRXJyb3JFbnRyeVxuZXhwb3J0IHR5cGUgU2VydmVyTG9nRW50cnkgPVxuICB8IENvbnNvbGVFbnRyeTxzdHJpbmc+XG4gIHwgQ29uc29sZUVycm9yRW50cnk8c3RyaW5nPlxuICB8IEZvcm1hdHRlZEVycm9yRW50cnlcblxuZXhwb3J0IGNvbnN0IFVOREVGSU5FRF9NQVJLRVIgPSAnX19uZXh0X3RhZ2dlZF91bmRlZmluZWQnXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iLzI4ZGMwNzc2YmUyZTEzNzBmZTIxNzU0OWQzMmFlZTI1MTlmMGNmMDUvcGFja2FnZXMvcmVhY3Qtc2VydmVyL3NyYy9SZWFjdEZsaWdodFNlcnZlci5qcyNMMjQ4XG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hDb25zb2xlTWV0aG9kPFQgZXh0ZW5kcyBrZXlvZiBDb25zb2xlPihcbiAgbWV0aG9kTmFtZTogVCxcbiAgd3JhcHBlcjogKFxuICAgIG1ldGhvZE5hbWU6IFQsXG4gICAgLi4uYXJnczogQ29uc29sZVtUXSBleHRlbmRzICguLi5hcmdzOiBpbmZlciBQKSA9PiBhbnkgPyBQIDogbmV2ZXJbXVxuICApID0+IHZvaWRcbik6ICgpID0+IHZvaWQge1xuICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25zb2xlLCBtZXRob2ROYW1lKVxuICBpZiAoXG4gICAgZGVzY3JpcHRvciAmJlxuICAgIChkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSB8fCBkZXNjcmlwdG9yLndyaXRhYmxlKSAmJlxuICAgIHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZSBhcyBDb25zb2xlW1RdIGV4dGVuZHMgKFxuICAgICAgLi4uYXJnczogYW55W11cbiAgICApID0+IGFueVxuICAgICAgPyBDb25zb2xlW1RdXG4gICAgICA6IG5ldmVyXG4gICAgY29uc3Qgb3JpZ2luYWxOYW1lID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvcmlnaW5hbE1ldGhvZCwgJ25hbWUnKVxuICAgIGNvbnN0IHdyYXBwZXJNZXRob2QgPSBmdW5jdGlvbiAoXG4gICAgICB0aGlzOiB0eXBlb2YgY29uc29sZSxcbiAgICAgIC4uLmFyZ3M6IENvbnNvbGVbVF0gZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUCkgPT4gYW55ID8gUCA6IG5ldmVyW11cbiAgICApIHtcbiAgICAgIHdyYXBwZXIobWV0aG9kTmFtZSwgLi4uYXJncylcblxuICAgICAgb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgYXJncylcbiAgICB9XG4gICAgaWYgKG9yaWdpbmFsTmFtZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdyYXBwZXJNZXRob2QsICduYW1lJywgb3JpZ2luYWxOYW1lKVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc29sZSwgbWV0aG9kTmFtZSwge1xuICAgICAgdmFsdWU6IHdyYXBwZXJNZXRob2QsXG4gICAgfSlcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc29sZSwgbWV0aG9kTmFtZSwge1xuICAgICAgICB2YWx1ZTogb3JpZ2luYWxNZXRob2QsXG4gICAgICAgIHdyaXRhYmxlOiBkZXNjcmlwdG9yLndyaXRhYmxlLFxuICAgICAgICBjb25maWd1cmFibGU6IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKCkgPT4ge31cbn1cbiJdLCJuYW1lcyI6WyJVTkRFRklORURfTUFSS0VSIiwicGF0Y2hDb25zb2xlTWV0aG9kIiwibWV0aG9kTmFtZSIsIndyYXBwZXIiLCJkZXNjcmlwdG9yIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiY29uc29sZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJvcmlnaW5hbE1ldGhvZCIsIm9yaWdpbmFsTmFtZSIsIndyYXBwZXJNZXRob2QiLCJhcmdzIiwiYXBwbHkiLCJkZWZpbmVQcm9wZXJ0eSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUFrRWFBLGdCQUFnQixFQUFBO2VBQWhCQTs7SUFHR0Msa0JBQWtCLEVBQUE7ZUFBbEJBOzs7QUFIVCxNQUFNRCxtQkFBbUI7QUFHekIsU0FBU0MsbUJBQ2RDLFVBQWEsRUFDYkMsT0FHUztJQUVULE1BQU1DLGFBQWFDLE9BQU9DLHdCQUF3QixDQUFDQyxTQUFTTDtJQUM1RCxJQUNFRSxjQUNDQSxDQUFBQSxXQUFXSSxZQUFZLElBQUlKLFdBQVdLLFFBQU8sS0FDOUMsT0FBT0wsV0FBV00sS0FBSyxLQUFLLFlBQzVCO1FBQ0EsTUFBTUMsaUJBQWlCUCxXQUFXTSxLQUFLO1FBS3ZDLE1BQU1FLGVBQWVQLE9BQU9DLHdCQUF3QixDQUFDSyxnQkFBZ0I7UUFDckUsTUFBTUUsZ0JBQWdCO1lBRXBCLElBQUEsSUFBQSxPQUFBLFVBQUEsTUFBQSxFQUFHQyxPQUFILElBQUEsTUFBQSxPQUFBLE9BQUEsR0FBQSxPQUFBLE1BQUEsT0FBQTtnQkFBR0EsSUFBQUEsQ0FBSCxLQUFBLEdBQUEsU0FBQSxDQUFBLEtBQW1FOztZQUVuRVgsUUFBUUQsZUFBZVk7WUFFdkJILGVBQWVJLEtBQUssQ0FBQyxJQUFJLEVBQUVEO1FBQzdCO1FBQ0EsSUFBSUYsY0FBYztZQUNoQlAsT0FBT1csY0FBYyxDQUFDSCxlQUFlLFFBQVFEO1FBQy9DO1FBQ0FQLE9BQU9XLGNBQWMsQ0FBQ1QsU0FBU0wsWUFBWTtZQUN6Q1EsT0FBT0c7UUFDVDtRQUVBLE9BQU87WUFDTFIsT0FBT1csY0FBYyxDQUFDVCxTQUFTTCxZQUFZO2dCQUN6Q1EsT0FBT0M7Z0JBQ1BGLFVBQVVMLFdBQVdLLFFBQVE7Z0JBQzdCRCxjQUFjSixXQUFXSSxZQUFZO1lBQ3ZDO1FBQ0Y7SUFDRjtJQUVBLE9BQU8sS0FBTztBQUNoQiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxNjIwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9mb3J3YXJkLWxvZ3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29uZmlndXJlIH0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3NhZmUtc3RhYmxlLXN0cmluZ2lmeSdcbmltcG9ydCB7XG4gIGdldE93bmVyU3RhY2ssXG4gIHNldE93bmVyU3RhY2tJZkF2YWlsYWJsZSxcbn0gZnJvbSAnLi9lcnJvcnMvc3RpdGNoZWQtZXJyb3InXG5pbXBvcnQgeyBnZXRFcnJvclNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvZXJyb3Itc291cmNlJ1xuaW1wb3J0IHtcbiAgZ2V0VGVybWluYWxMb2dnaW5nQ29uZmlnLFxuICBnZXRJc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQsXG59IGZyb20gJy4vdGVybWluYWwtbG9nZ2luZy1jb25maWcnXG5pbXBvcnQge1xuICB0eXBlIENvbnNvbGVFbnRyeSxcbiAgdHlwZSBDb25zb2xlRXJyb3JFbnRyeSxcbiAgdHlwZSBGb3JtYXR0ZWRFcnJvckVudHJ5LFxuICB0eXBlIENsaWVudExvZ0VudHJ5LFxuICB0eXBlIExvZ01ldGhvZCxcbiAgcGF0Y2hDb25zb2xlTWV0aG9kLFxuICBVTkRFRklORURfTUFSS0VSLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvZm9yd2FyZC1sb2dzLXNoYXJlZCdcblxuY29uc3QgdGVybWluYWxMb2dnaW5nQ29uZmlnID0gZ2V0VGVybWluYWxMb2dnaW5nQ29uZmlnKClcbmV4cG9ydCBjb25zdCBQUk9NSVNFX01BUktFUiA9ICdQcm9taXNlIHt9J1xuZXhwb3J0IGNvbnN0IFVOQVZBSUxBQkxFX01BUktFUiA9ICdbVW5hYmxlIHRvIHZpZXddJ1xuXG5jb25zdCBtYXhpbXVtRGVwdGggPVxuICB0eXBlb2YgdGVybWluYWxMb2dnaW5nQ29uZmlnID09PSAnb2JqZWN0JyAmJiB0ZXJtaW5hbExvZ2dpbmdDb25maWcuZGVwdGhMaW1pdFxuICAgID8gdGVybWluYWxMb2dnaW5nQ29uZmlnLmRlcHRoTGltaXRcbiAgICA6IDVcbmNvbnN0IG1heGltdW1CcmVhZHRoID1cbiAgdHlwZW9mIHRlcm1pbmFsTG9nZ2luZ0NvbmZpZyA9PT0gJ29iamVjdCcgJiYgdGVybWluYWxMb2dnaW5nQ29uZmlnLmVkZ2VMaW1pdFxuICAgID8gdGVybWluYWxMb2dnaW5nQ29uZmlnLmVkZ2VMaW1pdFxuICAgIDogMTAwXG5cbmNvbnN0IHN0cmluZ2lmeSA9IGNvbmZpZ3VyZSh7XG4gIG1heGltdW1EZXB0aCxcbiAgbWF4aW11bUJyZWFkdGgsXG59KVxuXG5leHBvcnQgY29uc3QgaXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkID0gZ2V0SXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkKClcblxuY29uc3QgbWV0aG9kczogQXJyYXk8TG9nTWV0aG9kPiA9IFtcbiAgJ2xvZycsXG4gICdpbmZvJyxcbiAgJ3dhcm4nLFxuICAnZGVidWcnLFxuICAndGFibGUnLFxuICAnYXNzZXJ0JyxcbiAgJ2RpcicsXG4gICdkaXJ4bWwnLFxuICAnZ3JvdXAnLFxuICAnZ3JvdXBDb2xsYXBzZWQnLFxuICAnZ3JvdXBFbmQnLFxuICAndHJhY2UnLFxuXVxuLyoqXG4gKiBhbGxvd3MgdXMgdG86XG4gKiAtIHJldml2ZSB0aGUgdW5kZWZpbmVkIGxvZyBpbiB0aGUgc2VydmVyIGFzIGl0IHdvdWxkIGxvb2sgaW4gdGhlIGJyb3dzZXJcbiAqIC0gbm90IHJlYWQvYXR0ZW1wdCB0byBzZXJpYWxpemUgcHJvbWlzZXMgKG5leHQgd2lsbCBjb25zb2xlIGVycm9yIGlmIHlvdSBkbyB0aGF0LCBhbmQgd2lsbCBjYXVzZSB0aGlzIHByb2dyYW0gdG8gaW5maW5pdGVseSByZWN1cnNlKVxuICogLSBpZiB3ZSByZWFkIGEgcHJveHkgdGhhdCB0aHJvd3MgKG5vIHdheSB0byBkZXRlY3QgaWYgc29tZXRoaW5nIGlzIGEgcHJveHkpLCBleHBsYWluIHRvIHRoZSB1c2VyIHdlIGNhbid0IHJlYWQgdGhpcyBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVMb2dTZXJpYWxpemF0aW9uQ2xvbmU8VD4oXG4gIHZhbHVlOiBULFxuICBzZWVuID0gbmV3IFdlYWtNYXAoKVxuKTogYW55IHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBVTkRFRklORURfTUFSS0VSXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSByZXR1cm4gdmFsdWVcbiAgaWYgKHNlZW4uaGFzKHZhbHVlIGFzIG9iamVjdCkpIHJldHVybiBzZWVuLmdldCh2YWx1ZSBhcyBvYmplY3QpXG5cbiAgdHJ5IHtcbiAgICBPYmplY3Qua2V5cyh2YWx1ZSBhcyBvYmplY3QpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBVTkFWQUlMQUJMRV9NQVJLRVJcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUgYXMgYW55KS50aGVuID09PSAnZnVuY3Rpb24nKSByZXR1cm4gUFJPTUlTRV9NQVJLRVJcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFVOQVZBSUxBQkxFX01BUktFUlxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3Qgb3V0OiBhbnlbXSA9IFtdXG4gICAgc2Vlbi5zZXQodmFsdWUsIG91dClcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG91dC5wdXNoKHByZUxvZ1NlcmlhbGl6YXRpb25DbG9uZShpdGVtLCBzZWVuKSlcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICBvdXQucHVzaChVTkFWQUlMQUJMRV9NQVJLRVIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKVxuICBpZiAocHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUgfHwgcHJvdG8gPT09IG51bGwpIHtcbiAgICBjb25zdCBvdXQ6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge31cbiAgICBzZWVuLnNldCh2YWx1ZSBhcyBvYmplY3QsIG91dClcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWx1ZSBhcyBvYmplY3QpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBvdXRba2V5XSA9IHByZUxvZ1NlcmlhbGl6YXRpb25DbG9uZSgodmFsdWUgYXMgYW55KVtrZXldLCBzZWVuKVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIG91dFtrZXldID0gVU5BVkFJTEFCTEVfTUFSS0VSXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXG59XG5cbi8vIG9ubHkgc2FmZSBpZiBwYXNzZWQgc2FmZUNsb25lIGRhdGFcbmV4cG9ydCBjb25zdCBsb2dTdHJpbmdpZnkgPSAoZGF0YTogdW5rbm93bik6IHN0cmluZyA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3RyaW5naWZ5KGRhdGEpXG4gICAgcmV0dXJuIHJlc3VsdCA/PyBgXCIke1VOQVZBSUxBQkxFX01BUktFUn1cImBcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGBcIiR7VU5BVkFJTEFCTEVfTUFSS0VSfVwiYFxuICB9XG59XG5cbmNvbnN0IGFmdGVyVGhpc0ZyYW1lID0gKGNiOiAoKSA9PiB2b2lkKSA9PiB7XG4gIGxldCB0aW1lb3V0OiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IHVuZGVmaW5lZFxuXG4gIGNvbnN0IHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjYigpXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKVxuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICB9XG59XG5cbmxldCBpc1BhdGNoZWQgPSBmYWxzZVxuXG5jb25zdCBzZXJpYWxpemVFbnRyaWVzID0gKGVudHJpZXM6IEFycmF5PENsaWVudExvZ0VudHJ5PikgPT5cbiAgZW50cmllcy5tYXAoKGNsaWVudEVudHJ5KSA9PiB7XG4gICAgc3dpdGNoIChjbGllbnRFbnRyeS5raW5kKSB7XG4gICAgICBjYXNlICdhbnktbG9nZ2VkLWVycm9yJzpcbiAgICAgIGNhc2UgJ2NvbnNvbGUnOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY2xpZW50RW50cnksXG4gICAgICAgICAgYXJnczogY2xpZW50RW50cnkuYXJncy5tYXAoc3RyaW5naWZ5VXNlckFyZyksXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhc2UgJ2Zvcm1hdHRlZC1lcnJvcic6IHtcbiAgICAgICAgcmV0dXJuIGNsaWVudEVudHJ5XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJldHVybiBudWxsIVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuZXhwb3J0IGNvbnN0IGxvZ1F1ZXVlOiB7XG4gIGVudHJpZXM6IEFycmF5PENsaWVudExvZ0VudHJ5PlxuICBvblNvY2tldFJlYWR5OiAoc29ja2V0OiBXZWJTb2NrZXQpID0+IHZvaWRcbiAgZmx1c2hTY2hlZHVsZWQ6IGJvb2xlYW5cbiAgc29ja2V0OiBXZWJTb2NrZXQgfCBudWxsXG4gIGNhbmNlbEZsdXNoOiAoKCkgPT4gdm9pZCkgfCBudWxsXG4gIHNvdXJjZVR5cGU/OiAnc2VydmVyJyB8ICdlZGdlLXNlcnZlcidcbiAgcm91dGVyOiAnYXBwJyB8ICdwYWdlcycgfCBudWxsXG4gIHNjaGVkdWxlTG9nU2VuZDogKGVudHJ5OiBDbGllbnRMb2dFbnRyeSkgPT4gdm9pZFxufSA9IHtcbiAgZW50cmllczogW10sXG4gIGZsdXNoU2NoZWR1bGVkOiBmYWxzZSxcbiAgY2FuY2VsRmx1c2g6IG51bGwsXG4gIHNvY2tldDogbnVsbCxcbiAgc291cmNlVHlwZTogdW5kZWZpbmVkLFxuICByb3V0ZXI6IG51bGwsXG4gIHNjaGVkdWxlTG9nU2VuZDogKGVudHJ5OiBDbGllbnRMb2dFbnRyeSkgPT4ge1xuICAgIGxvZ1F1ZXVlLmVudHJpZXMucHVzaChlbnRyeSlcbiAgICBpZiAobG9nUXVldWUuZmx1c2hTY2hlZHVsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBzYWZlIHRvIGRlcmVmIGFuZCB1c2UgaW4gc2V0VGltZW91dCBjbG9zdXJlIHNpbmNlIHdlIGNhbmNlbCBvbiBuZXcgc29ja2V0XG4gICAgY29uc3Qgc29ja2V0ID0gbG9nUXVldWUuc29ja2V0XG4gICAgaWYgKCFzb2NrZXQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIHByb2JhYmx5IGRvbnQgbmVlZCB0aGlzXG4gICAgbG9nUXVldWUuZmx1c2hTY2hlZHVsZWQgPSB0cnVlXG5cbiAgICAvLyBub24gYmxvY2tpbmcgbG9nIGZsdXNoLCBydW5zIGF0IG1vc3Qgb25jZSBwZXIgZnJhbWVcbiAgICBsb2dRdWV1ZS5jYW5jZWxGbHVzaCA9IGFmdGVyVGhpc0ZyYW1lKCgpID0+IHtcbiAgICAgIGxvZ1F1ZXVlLmZsdXNoU2NoZWR1bGVkID0gZmFsc2VcblxuICAgICAgLy8ganVzdCBpbmNhc2VcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZXZlbnQ6ICdicm93c2VyLWxvZ3MnLFxuICAgICAgICAgIGVudHJpZXM6IHNlcmlhbGl6ZUVudHJpZXMobG9nUXVldWUuZW50cmllcyksXG4gICAgICAgICAgcm91dGVyOiBsb2dRdWV1ZS5yb3V0ZXIsXG4gICAgICAgICAgLy8gbmVlZGVkIGZvciBzb3VyY2UgbWFwcGluZywgd2UganVzdCBhc3NpZ24gdGhlIHNvdXJjZVR5cGUgZnJvbSB0aGUgbGFzdCBlcnJvciBmb3IgdGhlIHdob2xlIGJhdGNoXG4gICAgICAgICAgc291cmNlVHlwZTogbG9nUXVldWUuc291cmNlVHlwZSxcbiAgICAgICAgfSlcblxuICAgICAgICBzb2NrZXQuc2VuZChwYXlsb2FkKVxuICAgICAgICBsb2dRdWV1ZS5lbnRyaWVzID0gW11cbiAgICAgICAgbG9nUXVldWUuc291cmNlVHlwZSA9IHVuZGVmaW5lZFxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIGVycm9yIChtYWtlIHN1cmUgdSBkb24ndCBpbmZpbml0ZSBsb29wKVxuICAgICAgICAvKiBub29wICovXG4gICAgICB9XG4gICAgfSlcbiAgfSxcbiAgb25Tb2NrZXRSZWFkeTogKHNvY2tldDogV2ViU29ja2V0KSA9PiB7XG4gICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgLy8gaW52YXJpYW50XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBpbmNhc2UgYW4gZXhpc3RpbmcgdGltZW91dCB3YXMgZ29pbmcgdG8gcnVuIHdpdGggYSBzdGFsZSBzb2NrZXRcbiAgICBsb2dRdWV1ZS5jYW5jZWxGbHVzaD8uKClcbiAgICBsb2dRdWV1ZS5zb2NrZXQgPSBzb2NrZXRcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZXZlbnQ6ICdicm93c2VyLWxvZ3MnLFxuICAgICAgICBlbnRyaWVzOiBzZXJpYWxpemVFbnRyaWVzKGxvZ1F1ZXVlLmVudHJpZXMpLFxuICAgICAgICByb3V0ZXI6IGxvZ1F1ZXVlLnJvdXRlcixcbiAgICAgICAgc291cmNlVHlwZTogbG9nUXVldWUuc291cmNlVHlwZSxcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5zZW5kKHBheWxvYWQpXG4gICAgICBsb2dRdWV1ZS5lbnRyaWVzID0gW11cbiAgICAgIGxvZ1F1ZXVlLnNvdXJjZVR5cGUgPSB1bmRlZmluZWRcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8qKiBub29wIGp1c3QgaW5jYXNlICovXG4gICAgfVxuICB9LFxufVxuXG5jb25zdCBzdHJpbmdpZnlVc2VyQXJnID0gKFxuICBhcmc6XG4gICAgfCB7XG4gICAgICAgIGtpbmQ6ICdhcmcnXG4gICAgICAgIGRhdGE6IHVua25vd25cbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAga2luZDogJ2Zvcm1hdHRlZC1lcnJvci1hcmcnXG4gICAgICB9XG4pID0+IHtcbiAgaWYgKGFyZy5raW5kICE9PSAnYXJnJykge1xuICAgIHJldHVybiBhcmdcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmFyZyxcbiAgICBkYXRhOiBsb2dTdHJpbmdpZnkoYXJnLmRhdGEpLFxuICB9XG59XG5cbmNvbnN0IGNyZWF0ZUVycm9yQXJnID0gKGVycm9yOiBFcnJvcikgPT4ge1xuICBjb25zdCBzdGFjayA9IHN0YWNrV2l0aE93bmVycyhlcnJvcilcbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnZm9ybWF0dGVkLWVycm9yLWFyZycgYXMgY29uc3QsXG4gICAgcHJlZml4OiBlcnJvci5tZXNzYWdlID8gYCR7ZXJyb3IubmFtZX06ICR7ZXJyb3IubWVzc2FnZX1gIDogYCR7ZXJyb3IubmFtZX1gLFxuICAgIHN0YWNrLFxuICB9XG59XG5cbmNvbnN0IGNyZWF0ZUxvZ0VudHJ5ID0gKGxldmVsOiBMb2dNZXRob2QsIGFyZ3M6IGFueVtdKSA9PiB7XG4gIC8vIGRvIG5vdCBhYnN0cmFjdCB0aGlzLCBpdCBpbXBsaWNpdGx5IHJlbGllcyBvbiB3aGljaCBmdW5jdGlvbnMgY2FsbCBpdC4gZm9yY2luZyB0aGUgaW5saW5lZCBpbXBsZW1lbnRhdGlvbiBtYWtlcyB5b3UgdGhpbmsgYWJvdXQgY2FsbGVyc1xuICAvLyBlcnJvciBjYXB0dXJlIHN0YWNrIHRyYWNlIG1heWJlXG4gIGNvbnN0IHN0YWNrID0gc3RhY2tXaXRoT3duZXJzKG5ldyBFcnJvcigpKVxuICBjb25zdCBzdGFja0xpbmVzID0gc3RhY2s/LnNwbGl0KCdcXG4nKVxuICBjb25zdCBjbGVhblN0YWNrID0gc3RhY2tMaW5lcz8uc2xpY2UoMykuam9pbignXFxuJykgLy8gdGhpcyBpcyBwcm9iYWJseSBpZ25vcmVkIGFueXdheXNcbiAgY29uc3QgZW50cnk6IENvbnNvbGVFbnRyeTx1bmtub3duPiA9IHtcbiAgICBraW5kOiAnY29uc29sZScsXG4gICAgY29uc29sZU1ldGhvZFN0YWNrOiBjbGVhblN0YWNrID8/IG51bGwsIC8vIGRlcGVuZGluZyBvbiBicm93c2VyIHdlIG1pZ2h0IG5vdCBoYXZlIHN0YWNrXG4gICAgbWV0aG9kOiBsZXZlbCxcbiAgICBhcmdzOiBhcmdzLm1hcCgoYXJnKSA9PiB7XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVycm9yQXJnKGFyZylcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6ICdhcmcnLFxuICAgICAgICBkYXRhOiBwcmVMb2dTZXJpYWxpemF0aW9uQ2xvbmUoYXJnKSxcbiAgICAgIH1cbiAgICB9KSxcbiAgfVxuXG4gIGxvZ1F1ZXVlLnNjaGVkdWxlTG9nU2VuZChlbnRyeSlcbn1cblxuZXhwb3J0IGNvbnN0IGZvcndhcmRFcnJvckxvZyA9IChhcmdzOiBhbnlbXSkgPT4ge1xuICBjb25zdCBlcnJvck9iamVjdHMgPSBhcmdzLmZpbHRlcigoYXJnKSA9PiBhcmcgaW5zdGFuY2VvZiBFcnJvcilcbiAgY29uc3QgZmlyc3QgPSBlcnJvck9iamVjdHMuYXQoMClcbiAgaWYgKGZpcnN0KSB7XG4gICAgY29uc3Qgc291cmNlID0gZ2V0RXJyb3JTb3VyY2UoZmlyc3QpXG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgbG9nUXVldWUuc291cmNlVHlwZSA9IHNvdXJjZVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogYnJvd3NlciBzaG93cyBzdGFjayByZWdhcmRsZXNzIG9mIHR5cGUgb2YgZGF0YSBwYXNzZWQgdG8gY29uc29sZS5lcnJvciwgc28gd2Ugc2hvdWxkIGRvIHRoZSBzYW1lXG4gICAqXG4gICAqIGRvIG5vdCBhYnN0cmFjdCB0aGlzLCBpdCBpbXBsaWNpdGx5IHJlbGllcyBvbiB3aGljaCBmdW5jdGlvbnMgY2FsbCBpdC4gZm9yY2luZyB0aGUgaW5saW5lZCBpbXBsZW1lbnRhdGlvbiBtYWtlcyB5b3UgdGhpbmsgYWJvdXQgY2FsbGVyc1xuICAgKi9cbiAgY29uc3Qgc3RhY2sgPSBzdGFja1dpdGhPd25lcnMobmV3IEVycm9yKCkpXG4gIGNvbnN0IHN0YWNrTGluZXMgPSBzdGFjaz8uc3BsaXQoJ1xcbicpXG4gIGNvbnN0IGNsZWFuU3RhY2sgPSBzdGFja0xpbmVzPy5zbGljZSgzKS5qb2luKCdcXG4nKVxuXG4gIGNvbnN0IGVudHJ5OiBDb25zb2xlRXJyb3JFbnRyeTx1bmtub3duPiA9IHtcbiAgICBraW5kOiAnYW55LWxvZ2dlZC1lcnJvcicsXG4gICAgbWV0aG9kOiAnZXJyb3InLFxuICAgIGNvbnNvbGVFcnJvclN0YWNrOiBjbGVhblN0YWNrID8/ICcnLFxuICAgIGFyZ3M6IGFyZ3MubWFwKChhcmcpID0+IHtcbiAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRXJyb3JBcmcoYXJnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogJ2FyZycsXG4gICAgICAgIGRhdGE6IHByZUxvZ1NlcmlhbGl6YXRpb25DbG9uZShhcmcpLFxuICAgICAgfVxuICAgIH0pLFxuICB9XG5cbiAgbG9nUXVldWUuc2NoZWR1bGVMb2dTZW5kKGVudHJ5KVxufVxuXG5jb25zdCBjcmVhdGVVbmNhdWdodEVycm9yRW50cnkgPSAoXG4gIGVycm9yTmFtZTogc3RyaW5nLFxuICBlcnJvck1lc3NhZ2U6IHN0cmluZyxcbiAgZnVsbFN0YWNrOiBzdHJpbmdcbikgPT4ge1xuICBjb25zdCBlbnRyeTogRm9ybWF0dGVkRXJyb3JFbnRyeSA9IHtcbiAgICBraW5kOiAnZm9ybWF0dGVkLWVycm9yJyxcbiAgICBwcmVmaXg6IGBVbmNhdWdodCAke2Vycm9yTmFtZX06ICR7ZXJyb3JNZXNzYWdlfWAsXG4gICAgc3RhY2s6IGZ1bGxTdGFjayxcbiAgICBtZXRob2Q6ICdlcnJvcicsXG4gIH1cblxuICBsb2dRdWV1ZS5zY2hlZHVsZUxvZ1NlbmQoZW50cnkpXG59XG5cbmNvbnN0IHN0YWNrV2l0aE93bmVycyA9IChlcnJvcjogRXJyb3IpID0+IHtcbiAgbGV0IG93bmVyU3RhY2sgPSAnJ1xuICBzZXRPd25lclN0YWNrSWZBdmFpbGFibGUoZXJyb3IpXG4gIG93bmVyU3RhY2sgPSBnZXRPd25lclN0YWNrKGVycm9yKSB8fCAnJ1xuICBjb25zdCBzdGFjayA9IChlcnJvci5zdGFjayB8fCAnJykgKyBvd25lclN0YWNrXG4gIHJldHVybiBzdGFja1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nVW5oYW5kbGVkUmVqZWN0aW9uKHJlYXNvbjogdW5rbm93bikge1xuICBpZiAocmVhc29uIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBjcmVhdGVVbmhhbmRsZWRSZWplY3Rpb25FcnJvckVudHJ5KHJlYXNvbiwgc3RhY2tXaXRoT3duZXJzKHJlYXNvbikpXG4gICAgcmV0dXJuXG4gIH1cbiAgY3JlYXRlVW5oYW5kbGVkUmVqZWN0aW9uTm9uRXJyb3JFbnRyeShyZWFzb24pXG59XG5cbmNvbnN0IGNyZWF0ZVVuaGFuZGxlZFJlamVjdGlvbkVycm9yRW50cnkgPSAoXG4gIGVycm9yOiBFcnJvcixcbiAgZnVsbFN0YWNrOiBzdHJpbmdcbikgPT4ge1xuICBjb25zdCBzb3VyY2UgPSBnZXRFcnJvclNvdXJjZShlcnJvcilcbiAgaWYgKHNvdXJjZSkge1xuICAgIGxvZ1F1ZXVlLnNvdXJjZVR5cGUgPSBzb3VyY2VcbiAgfVxuXG4gIGNvbnN0IGVudHJ5OiBDbGllbnRMb2dFbnRyeSA9IHtcbiAgICBraW5kOiAnZm9ybWF0dGVkLWVycm9yJyxcbiAgICBwcmVmaXg6IGDiqK8gdW5oYW5kbGVkUmVqZWN0aW9uOiAke2Vycm9yLm5hbWV9OiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICBzdGFjazogZnVsbFN0YWNrLFxuICAgIG1ldGhvZDogJ2Vycm9yJyxcbiAgfVxuXG4gIGxvZ1F1ZXVlLnNjaGVkdWxlTG9nU2VuZChlbnRyeSlcbn1cblxuY29uc3QgY3JlYXRlVW5oYW5kbGVkUmVqZWN0aW9uTm9uRXJyb3JFbnRyeSA9IChyZWFzb246IHVua25vd24pID0+IHtcbiAgY29uc3QgZW50cnk6IENsaWVudExvZ0VudHJ5ID0ge1xuICAgIGtpbmQ6ICdhbnktbG9nZ2VkLWVycm9yJyxcbiAgICAvLyB3ZSBjYW4ndCBhY2Nlc3MgdGhlIHN0YWNrIHNpbmNlIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkIGFzeW5jIGFuZCBjcmVhdGluZyBhbiBpbmxpbmUgZXJyb3Igd291bGQgYmUgbWVhbmluZ2xlc3NcbiAgICBjb25zb2xlRXJyb3JTdGFjazogJycsXG4gICAgbWV0aG9kOiAnZXJyb3InLFxuICAgIGFyZ3M6IFtcbiAgICAgIHtcbiAgICAgICAga2luZDogJ2FyZycsXG4gICAgICAgIGRhdGE6IGDiqK8gdW5oYW5kbGVkUmVqZWN0aW9uOmAsXG4gICAgICAgIGlzUmVqZWN0aW9uTWVzc2FnZTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtpbmQ6ICdhcmcnLFxuICAgICAgICBkYXRhOiBwcmVMb2dTZXJpYWxpemF0aW9uQ2xvbmUocmVhc29uKSxcbiAgICAgIH0sXG4gICAgXSxcbiAgfVxuXG4gIGxvZ1F1ZXVlLnNjaGVkdWxlTG9nU2VuZChlbnRyeSlcbn1cblxuY29uc3QgaXNITVIgPSAoYXJnczogYW55W10pID0+IHtcbiAgY29uc3QgZmlyc3RBcmcgPSBhcmdzWzBdXG4gIGlmICh0eXBlb2YgZmlyc3RBcmcgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKGZpcnN0QXJnLnN0YXJ0c1dpdGgoJ1tGYXN0IFJlZnJlc2hdJykpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKGZpcnN0QXJnLnN0YXJ0c1dpdGgoJ1tITVJdJykpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmNvbnN0IGlzSWdub3JlZExvZyA9IChhcmdzOiBhbnlbXSkgPT4ge1xuICBpZiAoYXJncy5sZW5ndGggPCAzKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBbZm9ybWF0LCBzdHlsZXMsIGxhYmVsXSA9IGFyZ3NcblxuICBpZiAoXG4gICAgdHlwZW9mIGZvcm1hdCAhPT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2Ygc3R5bGVzICE9PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiBsYWJlbCAhPT0gJ3N0cmluZydcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBraW5kYSBoYWNreSwgd2Ugc2hvdWxkIGRlZmluZSBhIGNvbW1vbiBmb3JtYXQgZm9yIHRoZXNlIHN0cmluZ3Mgc28gd2UgY2FuIHNhZmVseSBpZ25vcmVcbiAgcmV0dXJuIGZvcm1hdC5zdGFydHNXaXRoKCclYyVzJWMnKSAmJiBzdHlsZXMuaW5jbHVkZXMoJ2JhY2tncm91bmQ6Jylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRVbmhhbmRsZWRFcnJvcihlcnJvcjogRXJyb3IpIHtcbiAgY3JlYXRlVW5jYXVnaHRFcnJvckVudHJ5KGVycm9yLm5hbWUsIGVycm9yLm1lc3NhZ2UsIHN0YWNrV2l0aE93bmVycyhlcnJvcikpXG59XG5cbi8vIFRPRE86IHRoaXMgcm91dGVyIGNoZWNrIGlzIGJyaXR0bGUsIHdlIG5lZWQgdG8gdXBkYXRlIGJhc2VkIG9uIHRoZSBjdXJyZW50IHJvdXRlciB0aGUgdXNlciBpcyB1c2luZ1xuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVEZWJ1Z0xvZ0ZvcndhcmRpbmcgPSAocm91dGVyOiAnYXBwJyB8ICdwYWdlcycpOiB2b2lkID0+IHtcbiAgLy8gcHJvYmFibHkgZG9uJ3QgbmVlZCB0aGlzXG4gIGlmIChpc1BhdGNoZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvLyBUT0RPKHJvYik6IHdoeSBkb2VzIHRoaXMgYnJlYWsgcmVuZGVyaW5nIG9uIHNlcnZlciwgaW1wb3J0YW50IHRvIGtub3cgaW5jYXNlIHRoZSBzYW1lIGJ1ZyBhcHBlYXJzIGluIGJyb3dzZXJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBiZXR0ZXIgdG8gYmUgc2FmZSB0aGFuIHNvcnJ5XG4gIHRyeSB7XG4gICAgbWV0aG9kcy5mb3JFYWNoKChtZXRob2QpID0+XG4gICAgICBwYXRjaENvbnNvbGVNZXRob2QobWV0aG9kLCAoXywgLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoaXNITVIoYXJncykpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJZ25vcmVkTG9nKGFyZ3MpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlTG9nRW50cnkobWV0aG9kLCBhcmdzKVxuICAgICAgfSlcbiAgICApXG4gIH0gY2F0Y2gge31cbiAgbG9nUXVldWUucm91dGVyID0gcm91dGVyXG4gIGlzUGF0Y2hlZCA9IHRydWVcbn1cbiJdLCJuYW1lcyI6WyJQUk9NSVNFX01BUktFUiIsIlVOQVZBSUxBQkxFX01BUktFUiIsImZvcndhcmRFcnJvckxvZyIsImZvcndhcmRVbmhhbmRsZWRFcnJvciIsImluaXRpYWxpemVEZWJ1Z0xvZ0ZvcndhcmRpbmciLCJpc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQiLCJsb2dRdWV1ZSIsImxvZ1N0cmluZ2lmeSIsImxvZ1VuaGFuZGxlZFJlamVjdGlvbiIsInByZUxvZ1NlcmlhbGl6YXRpb25DbG9uZSIsInRlcm1pbmFsTG9nZ2luZ0NvbmZpZyIsImdldFRlcm1pbmFsTG9nZ2luZ0NvbmZpZyIsIm1heGltdW1EZXB0aCIsImRlcHRoTGltaXQiLCJtYXhpbXVtQnJlYWR0aCIsImVkZ2VMaW1pdCIsInN0cmluZ2lmeSIsImNvbmZpZ3VyZSIsImdldElzVGVybWluYWxMb2dnaW5nRW5hYmxlZCIsIm1ldGhvZHMiLCJ2YWx1ZSIsInNlZW4iLCJXZWFrTWFwIiwidW5kZWZpbmVkIiwiVU5ERUZJTkVEX01BUktFUiIsImhhcyIsImdldCIsIk9iamVjdCIsImtleXMiLCJ0aGVuIiwiQXJyYXkiLCJpc0FycmF5Iiwib3V0Iiwic2V0IiwiaXRlbSIsInB1c2giLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwia2V5IiwidG9TdHJpbmciLCJjYWxsIiwiZGF0YSIsInJlc3VsdCIsImFmdGVyVGhpc0ZyYW1lIiwiY2IiLCJ0aW1lb3V0IiwicmFmSWQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzZXRUaW1lb3V0IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJjbGVhclRpbWVvdXQiLCJpc1BhdGNoZWQiLCJzZXJpYWxpemVFbnRyaWVzIiwiZW50cmllcyIsIm1hcCIsImNsaWVudEVudHJ5Iiwia2luZCIsImFyZ3MiLCJzdHJpbmdpZnlVc2VyQXJnIiwiZmx1c2hTY2hlZHVsZWQiLCJjYW5jZWxGbHVzaCIsInNvY2tldCIsInNvdXJjZVR5cGUiLCJyb3V0ZXIiLCJzY2hlZHVsZUxvZ1NlbmQiLCJlbnRyeSIsInBheWxvYWQiLCJKU09OIiwiZXZlbnQiLCJzZW5kIiwib25Tb2NrZXRSZWFkeSIsInJlYWR5U3RhdGUiLCJXZWJTb2NrZXQiLCJPUEVOIiwiYXJnIiwiY3JlYXRlRXJyb3JBcmciLCJlcnJvciIsInN0YWNrIiwic3RhY2tXaXRoT3duZXJzIiwicHJlZml4IiwibWVzc2FnZSIsIm5hbWUiLCJjcmVhdGVMb2dFbnRyeSIsImxldmVsIiwiRXJyb3IiLCJzdGFja0xpbmVzIiwic3BsaXQiLCJjbGVhblN0YWNrIiwic2xpY2UiLCJqb2luIiwiY29uc29sZU1ldGhvZFN0YWNrIiwibWV0aG9kIiwiZXJyb3JPYmplY3RzIiwiZmlsdGVyIiwiZmlyc3QiLCJhdCIsInNvdXJjZSIsImdldEVycm9yU291cmNlIiwiY29uc29sZUVycm9yU3RhY2siLCJjcmVhdGVVbmNhdWdodEVycm9yRW50cnkiLCJlcnJvck5hbWUiLCJlcnJvck1lc3NhZ2UiLCJmdWxsU3RhY2siLCJvd25lclN0YWNrIiwic2V0T3duZXJTdGFja0lmQXZhaWxhYmxlIiwiZ2V0T3duZXJTdGFjayIsInJlYXNvbiIsImNyZWF0ZVVuaGFuZGxlZFJlamVjdGlvbkVycm9yRW50cnkiLCJjcmVhdGVVbmhhbmRsZWRSZWplY3Rpb25Ob25FcnJvckVudHJ5IiwiaXNSZWplY3Rpb25NZXNzYWdlIiwiaXNITVIiLCJmaXJzdEFyZyIsInN0YXJ0c1dpdGgiLCJpc0lnbm9yZWRMb2ciLCJsZW5ndGgiLCJmb3JtYXQiLCJzdHlsZXMiLCJsYWJlbCIsImluY2x1ZGVzIiwid2luZG93IiwiZm9yRWFjaCIsInBhdGNoQ29uc29sZU1ldGhvZCIsIl8iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFxQmFBLGNBQWMsRUFBQTtlQUFkQTs7SUFDQUMsa0JBQWtCLEVBQUE7ZUFBbEJBOztJQXlRQUMsZUFBZSxFQUFBO2VBQWZBOztJQStJR0MscUJBQXFCLEVBQUE7ZUFBckJBOztJQUtIQyw0QkFBNEIsRUFBQTtlQUE1QkE7O0lBN1lBQyx3QkFBd0IsRUFBQTtlQUF4QkE7O0lBc0hBQyxRQUFRLEVBQUE7ZUFBUkE7O0lBN0NBQyxZQUFZLEVBQUE7ZUFBWkE7O0lBMk9HQyxxQkFBcUIsRUFBQTtlQUFyQkE7O0lBOVJBQyx3QkFBd0IsRUFBQTtlQUF4QkE7OztxQ0E1RFU7K0JBSW5COzZCQUN3Qjt1Q0FJeEI7bUNBU0E7QUFFUCxNQUFNQyx3QkFBd0JDLENBQUFBLEdBQUFBLHVCQUFBQSx3QkFBd0I7QUFDL0MsTUFBTVgsaUJBQWlCO0FBQ3ZCLE1BQU1DLHFCQUFxQjtBQUVsQyxNQUFNVyxlQUNK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QSxtQkFBQUEsa0JBQWtCLEVBQUM5QixRQUFRLFNBQUMrQixDQUFBQTtpREFBTWpFLE9BQUFBLElBQUFBLE1BQUFBLE9BQUFBLElBQUFBLE9BQUFBLElBQUFBLElBQUFBLE9BQUFBLEdBQUFBLE9BQUFBLE1BQUFBLE9BQUFBO29CQUFBQSxJQUFBQSxDQUFBQSxPQUFBQSxFQUFBQSxHQUFBQSxTQUFBQSxDQUFBQSxLQUFBQTs7Z0JBQ2hDLElBQUlxRCxNQUFNckQsT0FBTztvQkFDZjtnQkFDRjtnQkFDQSxJQUFJd0QsYUFBYXhELE9BQU87b0JBQ3RCO2dCQUNGO2dCQUNBeUIsZUFBZVMsUUFBUWxDO1lBQ3pCO0lBRUosRUFBRSxPQUFBLEdBQU0sQ0FBQztJQUNUcEQsU0FBUzBELE1BQU0sR0FBR0E7SUFDbEJaLFlBQVk7QUFDZCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyMDQxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9lcnJvcnMvdXNlLWVycm9yLWhhbmRsZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBpc05leHRSb3V0ZXJFcnJvciB9IGZyb20gJy4uLy4uLy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2lzLW5leHQtcm91dGVyLWVycm9yJ1xuaW1wb3J0IHtcbiAgZm9ybWF0Q29uc29sZUFyZ3MsXG4gIHBhcnNlQ29uc29sZUFyZ3MsXG59IGZyb20gJy4uLy4uLy4uLy4uL2NsaWVudC9saWIvY29uc29sZSdcbmltcG9ydCBpc0Vycm9yIGZyb20gJy4uLy4uLy4uLy4uL2xpYi9pcy1lcnJvcidcbmltcG9ydCB7IGNyZWF0ZUNvbnNvbGVFcnJvciB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zb2xlLWVycm9yJ1xuaW1wb3J0IHsgY29lcmNlRXJyb3IsIHNldE93bmVyU3RhY2tJZkF2YWlsYWJsZSB9IGZyb20gJy4vc3RpdGNoZWQtZXJyb3InXG5pbXBvcnQge1xuICBmb3J3YXJkVW5oYW5kbGVkRXJyb3IsXG4gIGlzVGVybWluYWxMb2dnaW5nRW5hYmxlZCxcbiAgbG9nVW5oYW5kbGVkUmVqZWN0aW9uLFxufSBmcm9tICcuLi9mb3J3YXJkLWxvZ3MnXG5cbmNvbnN0IHF1ZXVlTWljcm9UYXNrID1cbiAgZ2xvYmFsVGhpcy5xdWV1ZU1pY3JvdGFzayB8fCAoKGNiOiAoKSA9PiB2b2lkKSA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGNiKSlcblxuZXhwb3J0IHR5cGUgRXJyb3JIYW5kbGVyID0gKGVycm9yOiBFcnJvcikgPT4gdm9pZFxuXG5jb25zdCBlcnJvclF1ZXVlOiBBcnJheTxFcnJvcj4gPSBbXVxuY29uc3QgZXJyb3JIYW5kbGVyczogQXJyYXk8RXJyb3JIYW5kbGVyPiA9IFtdXG5jb25zdCByZWplY3Rpb25RdWV1ZTogQXJyYXk8RXJyb3I+ID0gW11cbmNvbnN0IHJlamVjdGlvbkhhbmRsZXJzOiBBcnJheTxFcnJvckhhbmRsZXI+ID0gW11cblxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUNvbnNvbGVFcnJvcihcbiAgb3JpZ2luRXJyb3I6IHVua25vd24sXG4gIGNvbnNvbGVFcnJvckFyZ3M6IGFueVtdXG4pIHtcbiAgbGV0IGVycm9yOiBFcnJvclxuICBjb25zdCB7IGVudmlyb25tZW50TmFtZSB9ID0gcGFyc2VDb25zb2xlQXJncyhjb25zb2xlRXJyb3JBcmdzKVxuICBpZiAoaXNFcnJvcihvcmlnaW5FcnJvcikpIHtcbiAgICBlcnJvciA9IGNyZWF0ZUNvbnNvbGVFcnJvcihvcmlnaW5FcnJvciwgZW52aXJvbm1lbnROYW1lKVxuICB9IGVsc2Uge1xuICAgIGVycm9yID0gY3JlYXRlQ29uc29sZUVycm9yKFxuICAgICAgZm9ybWF0Q29uc29sZUFyZ3MoY29uc29sZUVycm9yQXJncyksXG4gICAgICBlbnZpcm9ubWVudE5hbWVcbiAgICApXG4gIH1cbiAgc2V0T3duZXJTdGFja0lmQXZhaWxhYmxlKGVycm9yKVxuXG4gIGVycm9yUXVldWUucHVzaChlcnJvcilcbiAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGVycm9ySGFuZGxlcnMpIHtcbiAgICAvLyBEZWxheWVkIHRoZSBlcnJvciBiZWluZyBwYXNzZWQgdG8gUmVhY3QgRGV2IE92ZXJsYXksXG4gICAgLy8gYXZvaWQgdGhlIHN0YXRlIGJlaW5nIHN5bmNocm9ub3VzbHkgdXBkYXRlZCBpbiB0aGUgY29tcG9uZW50LlxuICAgIHF1ZXVlTWljcm9UYXNrKCgpID0+IHtcbiAgICAgIGhhbmRsZXIoZXJyb3IpXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlQ2xpZW50RXJyb3IoZXJyb3I6IEVycm9yKSB7XG4gIGVycm9yUXVldWUucHVzaChlcnJvcilcbiAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGVycm9ySGFuZGxlcnMpIHtcbiAgICAvLyBEZWxheWVkIHRoZSBlcnJvciBiZWluZyBwYXNzZWQgdG8gUmVhY3QgRGV2IE92ZXJsYXksXG4gICAgLy8gYXZvaWQgdGhlIHN0YXRlIGJlaW5nIHN5bmNocm9ub3VzbHkgdXBkYXRlZCBpbiB0aGUgY29tcG9uZW50LlxuICAgIHF1ZXVlTWljcm9UYXNrKCgpID0+IHtcbiAgICAgIGhhbmRsZXIoZXJyb3IpXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRXJyb3JIYW5kbGVyKFxuICBoYW5kbGVPblVuaGFuZGxlZEVycm9yOiBFcnJvckhhbmRsZXIsXG4gIGhhbmRsZU9uVW5oYW5kbGVkUmVqZWN0aW9uOiBFcnJvckhhbmRsZXJcbikge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEhhbmRsZSBxdWV1ZWQgZXJyb3JzLlxuICAgIGVycm9yUXVldWUuZm9yRWFjaChoYW5kbGVPblVuaGFuZGxlZEVycm9yKVxuICAgIHJlamVjdGlvblF1ZXVlLmZvckVhY2goaGFuZGxlT25VbmhhbmRsZWRSZWplY3Rpb24pXG5cbiAgICAvLyBMaXN0ZW4gdG8gbmV3IGVycm9ycy5cbiAgICBlcnJvckhhbmRsZXJzLnB1c2goaGFuZGxlT25VbmhhbmRsZWRFcnJvcilcbiAgICByZWplY3Rpb25IYW5kbGVycy5wdXNoKGhhbmRsZU9uVW5oYW5kbGVkUmVqZWN0aW9uKVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIFJlbW92ZSBsaXN0ZW5lcnMuXG4gICAgICBlcnJvckhhbmRsZXJzLnNwbGljZShlcnJvckhhbmRsZXJzLmluZGV4T2YoaGFuZGxlT25VbmhhbmRsZWRFcnJvciksIDEpXG4gICAgICByZWplY3Rpb25IYW5kbGVycy5zcGxpY2UoXG4gICAgICAgIHJlamVjdGlvbkhhbmRsZXJzLmluZGV4T2YoaGFuZGxlT25VbmhhbmRsZWRSZWplY3Rpb24pLFxuICAgICAgICAxXG4gICAgICApXG5cbiAgICAgIC8vIFJlc2V0IGVycm9yIHF1ZXVlcy5cbiAgICAgIGVycm9yUXVldWUuc3BsaWNlKDAsIGVycm9yUXVldWUubGVuZ3RoKVxuICAgICAgcmVqZWN0aW9uUXVldWUuc3BsaWNlKDAsIHJlamVjdGlvblF1ZXVlLmxlbmd0aClcbiAgICB9XG4gIH0sIFtoYW5kbGVPblVuaGFuZGxlZEVycm9yLCBoYW5kbGVPblVuaGFuZGxlZFJlamVjdGlvbl0pXG59XG5cbmZ1bmN0aW9uIG9uVW5oYW5kbGVkRXJyb3IoZXZlbnQ6IFdpbmRvd0V2ZW50TWFwWydlcnJvciddKTogdm9pZCB8IGJvb2xlYW4ge1xuICBjb25zdCB0aHJvd25WYWx1ZTogdW5rbm93biA9IGV2ZW50LmVycm9yXG4gIGlmIChpc05leHRSb3V0ZXJFcnJvcih0aHJvd25WYWx1ZSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgLy8gV2hlbiB0aGVyZSdzIGFuIGVycm9yIHByb3BlcnR5IHByZXNlbnQsIHdlIGxvZyB0aGUgZXJyb3IgdG8gZXJyb3Igb3ZlcmxheS5cbiAgLy8gT3RoZXJ3aXNlIHdlIGRvbid0IGRvIGFueXRoaW5nIGFzIGl0J3Mgbm90IGxvZ2dpbmcgaW4gdGhlIGNvbnNvbGUgZWl0aGVyLlxuICBpZiAodGhyb3duVmFsdWUpIHtcbiAgICBjb25zdCBlcnJvciA9IGNvZXJjZUVycm9yKHRocm93blZhbHVlKVxuICAgIHNldE93bmVyU3RhY2tJZkF2YWlsYWJsZShlcnJvcilcbiAgICBoYW5kbGVDbGllbnRFcnJvcihlcnJvcilcbiAgICBpZiAoaXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkKSB7XG4gICAgICBmb3J3YXJkVW5oYW5kbGVkRXJyb3IoZXJyb3IpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uVW5oYW5kbGVkUmVqZWN0aW9uKGV2OiBXaW5kb3dFdmVudE1hcFsndW5oYW5kbGVkcmVqZWN0aW9uJ10pOiB2b2lkIHtcbiAgY29uc3QgcmVhc29uOiB1bmtub3duID0gZXY/LnJlYXNvblxuICBpZiAoaXNOZXh0Um91dGVyRXJyb3IocmVhc29uKSkge1xuICAgIGV2LnByZXZlbnREZWZhdWx0KClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGVycm9yID0gY29lcmNlRXJyb3IocmVhc29uKVxuICBzZXRPd25lclN0YWNrSWZBdmFpbGFibGUoZXJyb3IpXG5cbiAgcmVqZWN0aW9uUXVldWUucHVzaChlcnJvcilcbiAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHJlamVjdGlvbkhhbmRsZXJzKSB7XG4gICAgaGFuZGxlcihlcnJvcilcbiAgfVxuXG4gIGlmIChpc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQpIHtcbiAgICBsb2dVbmhhbmRsZWRSZWplY3Rpb24ocmVhc29uKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVHbG9iYWxFcnJvcnMoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7XG4gICAgICAvLyBJbmNyZWFzZSB0aGUgbnVtYmVyIG9mIHN0YWNrIGZyYW1lcyBvbiB0aGUgY2xpZW50XG4gICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSA1MFxuICAgIH0gY2F0Y2gge31cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uVW5oYW5kbGVkRXJyb3IpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIG9uVW5oYW5kbGVkUmVqZWN0aW9uKVxuICB9XG59XG4iXSwibmFtZXMiOlsiaGFuZGxlQ2xpZW50RXJyb3IiLCJoYW5kbGVDb25zb2xlRXJyb3IiLCJoYW5kbGVHbG9iYWxFcnJvcnMiLCJ1c2VFcnJvckhhbmRsZXIiLCJxdWV1ZU1pY3JvVGFzayIsImdsb2JhbFRoaXMiLCJxdWV1ZU1pY3JvdGFzayIsImNiIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiZXJyb3JRdWV1ZSIsImVycm9ySGFuZGxlcnMiLCJyZWplY3Rpb25RdWV1ZSIsInJlamVjdGlvbkhhbmRsZXJzIiwib3JpZ2luRXJyb3IiLCJjb25zb2xlRXJyb3JBcmdzIiwiZXJyb3IiLCJlbnZpcm9ubWVudE5hbWUiLCJwYXJzZUNvbnNvbGVBcmdzIiwiaXNFcnJvciIsImNyZWF0ZUNvbnNvbGVFcnJvciIsImZvcm1hdENvbnNvbGVBcmdzIiwic2V0T3duZXJTdGFja0lmQXZhaWxhYmxlIiwicHVzaCIsImhhbmRsZXIiLCJoYW5kbGVPblVuaGFuZGxlZEVycm9yIiwiaGFuZGxlT25VbmhhbmRsZWRSZWplY3Rpb24iLCJ1c2VFZmZlY3QiLCJmb3JFYWNoIiwic3BsaWNlIiwiaW5kZXhPZiIsImxlbmd0aCIsIm9uVW5oYW5kbGVkRXJyb3IiLCJldmVudCIsInRocm93blZhbHVlIiwiaXNOZXh0Um91dGVyRXJyb3IiLCJwcmV2ZW50RGVmYXVsdCIsImNvZXJjZUVycm9yIiwiaXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkIiwiZm9yd2FyZFVuaGFuZGxlZEVycm9yIiwib25VbmhhbmRsZWRSZWplY3Rpb24iLCJldiIsInJlYXNvbiIsImxvZ1VuaGFuZGxlZFJlamVjdGlvbiIsIndpbmRvdyIsIkVycm9yIiwic3RhY2tUcmFjZUxpbWl0IiwiYWRkRXZlbnRMaXN0ZW5lciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztJQW1EZ0JBLGlCQUFpQixFQUFBO2VBQWpCQTs7SUExQkFDLGtCQUFrQixFQUFBO2VBQWxCQTs7SUF1R0FDLGtCQUFrQixFQUFBO2VBQWxCQTs7SUFsRUFDLGVBQWUsRUFBQTtlQUFmQTs7Ozt1QkE5RFU7bUNBQ1E7eUJBSTNCO2tFQUNhOzhCQUNlOytCQUNtQjs2QkFLL0M7QUFFUCxNQUFNQyxpQkFDSkMsV0FBV0MsY0FBYyxJQUFLLENBQUEsQ0FBQ0MsS0FBbUJDLFFBQVFDLE9BQU8sR0FBR0MsSUFBSSxDQUFDSCxHQUFFO0FBSTdFLE1BQU1JLGFBQTJCLEVBQUU7QUFDbkMsTUFBTUMsZ0JBQXFDLEVBQUU7QUFDN0MsTUFBTUMsaUJBQStCLEVBQUU7QUFDdkMsTUFBTUMsb0JBQXlDLEVBQUU7QUFFMUMsU0FBU2IsbUJBQ2RjLFdBQW9CLEVBQ3BCQyxnQkFBdUI7SUFFdkIsSUFBSUM7SUFDSixNQUFNLEVBQUVDLGVBQWUsRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxTQUFBQSxnQkFBZ0IsRUFBQ0g7SUFDN0MsSUFBSUksQ0FBQUEsR0FBQUEsU0FBQUEsT0FBTyxFQUFDTCxjQUFjO1FBQ3hCRSxRQUFRSSxDQUFBQSxHQUFBQSxjQUFBQSxrQkFBa0IsRUFBQ04sYUFBYUc7SUFDMUMsT0FBTztRQUNMRCxRQUFRSSxDQUFBQSxHQUFBQSxjQUFBQSxrQkFBa0IsRUFDeEJDLENBQUFBLEdBQUFBLFNBQUFBLGlCQUFpQixFQUFDTixtQkFDbEJFO0lBRUo7SUFDQUssQ0FBQUEsR0FBQUEsZUFBQUEsd0JBQXdCLEVBQUNOO0lBRXpCTixXQUFXYSxJQUFJLENBQUNQO0lBQ2hCLEtBQUssTUFBTVEsV0FBV2IsY0FBZTtRQUNuQyx1REFBdUQ7UUFDdkQsZ0VBQWdFO1FBQ2hFUixlQUFlO1lBQ2JxQixRQUFRUjtRQUNWO0lBQ0Y7QUFDRjtBQUVPLFNBQVNqQixrQkFBa0JpQixLQUFZO0lBQzVDTixXQUFXYSxJQUFJLENBQUNQO0lBQ2hCLEtBQUssTUFBTVEsV0FBV2IsY0FBZTtRQUNuQyx1REFBdUQ7UUFDdkQsZ0VBQWdFO1FBQ2hFUixlQUFlO1lBQ2JxQixRQUFRUjtRQUNWO0lBQ0Y7QUFDRjtBQUVPLFNBQVNkLGdCQUNkdUIsc0JBQW9DLEVBQ3BDQywwQkFBd0M7SUFFeENDLENBQUFBLEdBQUFBLE9BQUFBLFNBQVMsRUFBQztRQUNSLHdCQUF3QjtRQUN4QmpCLFdBQVdrQixPQUFPLENBQUNIO1FBQ25CYixlQUFlZ0IsT0FBTyxDQUFDRjtRQUV2Qix3QkFBd0I7UUFDeEJmLGNBQWNZLElBQUksQ0FBQ0U7UUFDbkJaLGtCQUFrQlUsSUFBSSxDQUFDRztRQUV2QixPQUFPO1lBQ0wsb0JBQW9CO1lBQ3BCZixjQUFja0IsTUFBTSxDQUFDbEIsY0FBY21CLE9BQU8sQ0FBQ0wseUJBQXlCO1lBQ3BFWixrQkFBa0JnQixNQUFNLENBQ3RCaEIsa0JBQWtCaUIsT0FBTyxDQUFDSiw2QkFDMUI7WUFHRixzQkFBc0I7WUFDdEJoQixXQUFXbUIsTUFBTSxDQUFDLEdBQUduQixXQUFXcUIsTUFBTTtZQUN0Q25CLGVBQWVpQixNQUFNLENBQUMsR0FBR2pCLGVBQWVtQixNQUFNO1FBQ2hEO0lBQ0YsR0FBRztRQUFDTjtRQUF3QkM7S0FBMkI7QUFDekQ7QUFFQSxTQUFTTSxpQkFBaUJDLEtBQThCO0lBQ3RELE1BQU1DLGNBQXVCRCxNQUFNakIsS0FBSztJQUN4QyxJQUFJbUIsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDRCxjQUFjO1FBQ2xDRCxNQUFNRyxjQUFjO1FBQ3BCLE9BQU87SUFDVDtJQUNBLDZFQUE2RTtJQUM3RSw0RUFBNEU7SUFDNUUsSUFBSUYsYUFBYTtRQUNmLE1BQU1sQixRQUFRcUIsQ0FBQUEsR0FBQUEsZUFBQUEsV0FBVyxFQUFDSDtRQUMxQlosQ0FBQUEsR0FBQUEsZUFBQUEsd0JBQXdCLEVBQUNOO1FBQ3pCakIsa0JBQWtCaUI7UUFDbEIsSUFBSXNCLGFBQUFBLHdCQUF3QixFQUFFO1lBQzVCQyxDQUFBQSxHQUFBQSxhQUFBQSxxQkFBcUIsRUFBQ3ZCO1FBQ3hCO0lBQ0Y7QUFDRjtBQUVBLFNBQVN3QixxQkFBcUJDLEVBQXdDO0lBQ3BFLE1BQU1DLFNBQWtCRCxNQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxHQUFJQyxNQUFNO0lBQ2xDLElBQUlQLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBaUIsRUFBQ08sU0FBUztRQUM3QkQsR0FBR0wsY0FBYztRQUNqQjtJQUNGO0lBRUEsTUFBTXBCLFFBQVFxQixDQUFBQSxHQUFBQSxlQUFBQSxXQUFXLEVBQUNLO0lBQzFCcEIsQ0FBQUEsR0FBQUEsZUFBQUEsd0JBQXdCLEVBQUNOO0lBRXpCSixlQUFlVyxJQUFJLENBQUNQO0lBQ3BCLEtBQUssTUFBTVEsV0FBV1gsa0JBQW1CO1FBQ3ZDVyxRQUFRUjtJQUNWO0lBRUEsSUFBSXNCLGFBQUFBLHdCQUF3QixFQUFFO1FBQzVCSyxDQUFBQSxHQUFBQSxhQUFBQSxxQkFBcUIsRUFBQ0Q7SUFDeEI7QUFDRjtBQUVPLFNBQVN6QztJQUNkLElBQUksT0FBTzJDLFdBQVcsYUFBYTtRQUNqQyxJQUFJO1lBQ0Ysb0RBQW9EO1lBQ3BEQyxNQUFNQyxlQUFlLEdBQUc7UUFDMUIsRUFBRSxPQUFBLEdBQU0sQ0FBQztRQUVURixPQUFPRyxnQkFBZ0IsQ0FBQyxTQUFTZjtRQUNqQ1ksT0FBT0csZ0JBQWdCLENBQUMsc0JBQXNCUDtJQUNoRDtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDIxODgsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2Vycm9ycy9pbnRlcmNlcHQtY29uc29sZS1lcnJvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaXNFcnJvciBmcm9tICcuLi8uLi8uLi8uLi9saWIvaXMtZXJyb3InXG5pbXBvcnQgeyBpc05leHRSb3V0ZXJFcnJvciB9IGZyb20gJy4uLy4uLy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2lzLW5leHQtcm91dGVyLWVycm9yJ1xuaW1wb3J0IHsgaGFuZGxlQ29uc29sZUVycm9yIH0gZnJvbSAnLi91c2UtZXJyb3ItaGFuZGxlcidcbmltcG9ydCB7IHBhcnNlQ29uc29sZUFyZ3MgfSBmcm9tICcuLi8uLi8uLi8uLi9jbGllbnQvbGliL2NvbnNvbGUnXG5pbXBvcnQgeyBmb3J3YXJkRXJyb3JMb2csIGlzVGVybWluYWxMb2dnaW5nRW5hYmxlZCB9IGZyb20gJy4uL2ZvcndhcmQtbG9ncydcblxuZXhwb3J0IGNvbnN0IG9yaWdpbkNvbnNvbGVFcnJvciA9IGdsb2JhbFRoaXMuY29uc29sZS5lcnJvclxuXG4vLyBQYXRjaCBjb25zb2xlLmVycm9yIHRvIGNvbGxlY3QgaW5mb3JtYXRpb24gYWJvdXQgaHlkcmF0aW9uIGVycm9yc1xuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoQ29uc29sZUVycm9yKCkge1xuICAvLyBFbnN1cmUgaXQncyBvbmx5IHBhdGNoZWQgb25jZVxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm5cbiAgfVxuICB3aW5kb3cuY29uc29sZS5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgbGV0IG1heWJlRXJyb3I6IHVua25vd25cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc3QgeyBlcnJvcjogcmVwbGF5ZWRFcnJvciB9ID0gcGFyc2VDb25zb2xlQXJncyhhcmdzKVxuICAgICAgaWYgKHJlcGxheWVkRXJyb3IpIHtcbiAgICAgICAgbWF5YmVFcnJvciA9IHJlcGxheWVkRXJyb3JcbiAgICAgIH0gZWxzZSBpZiAoaXNFcnJvcihhcmdzWzBdKSkge1xuICAgICAgICBtYXliZUVycm9yID0gYXJnc1swXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2Q1MDMyM2ViODQ1YzVmZGUwZDcyMGNhZTg4OGJmMzVkZWRkMDU1MDYvcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckVycm9yTG9nZ2VyLmpzI0w3OFxuICAgICAgICBtYXliZUVycm9yID0gYXJnc1sxXVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXliZUVycm9yID0gYXJnc1swXVxuICAgIH1cblxuICAgIGlmICghaXNOZXh0Um91dGVyRXJyb3IobWF5YmVFcnJvcikpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGhhbmRsZUNvbnNvbGVFcnJvcihcbiAgICAgICAgICAvLyByZXBsYXllZCBlcnJvcnMgaGF2ZSB0aGVpciBvd24gY29tcGxleCBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQsXG4gICAgICAgICAgLy8gYnV0IGlmIHdlIHBhc3MgdGhlIGVycm9yIGRpcmVjdGx5LCBgaGFuZGxlQ2xpZW50RXJyb3JgIHdpbGwgaWdub3JlIGl0XG4gICAgICAgICAgbWF5YmVFcnJvcixcbiAgICAgICAgICBhcmdzXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmIChpc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQpIHtcbiAgICAgICAgZm9yd2FyZEVycm9yTG9nKGFyZ3MpXG4gICAgICB9XG5cbiAgICAgIG9yaWdpbkNvbnNvbGVFcnJvci5hcHBseSh3aW5kb3cuY29uc29sZSwgYXJncylcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJvcmlnaW5Db25zb2xlRXJyb3IiLCJwYXRjaENvbnNvbGVFcnJvciIsImdsb2JhbFRoaXMiLCJjb25zb2xlIiwiZXJyb3IiLCJ3aW5kb3ciLCJhcmdzIiwibWF5YmVFcnJvciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInJlcGxheWVkRXJyb3IiLCJwYXJzZUNvbnNvbGVBcmdzIiwiaXNFcnJvciIsImlzTmV4dFJvdXRlckVycm9yIiwiaGFuZGxlQ29uc29sZUVycm9yIiwiaXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkIiwiZm9yd2FyZEVycm9yTG9nIiwiYXBwbHkiXSwibWFwcGluZ3MiOiJBQWdCUVEsUUFBUUMsR0FBRyxDQUFDQyxRQUFRLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFWcEJWLGtCQUFrQixFQUFBO2VBQWxCQTs7SUFHR0MsaUJBQWlCLEVBQUE7ZUFBakJBOzs7O2tFQVRJO21DQUNjO2lDQUNDO3lCQUNGOzZCQUN5QjtBQUVuRCxNQUFNRCxxQkFBcUJFLFdBQVdDLE9BQU8sQ0FBQ0MsS0FBSztBQUduRCxTQUFTSDtJQUNkLGdDQUFnQztJQUNoQyxJQUFJLE9BQU9JLFdBQVcsYUFBYTtRQUNqQztJQUNGO0lBQ0FBLE9BQU9GLE9BQU8sQ0FBQ0MsS0FBSyxHQUFHLFNBQVNBO1FBQU0sSUFBQSxJQUFBLE9BQUEsVUFBQSxNQUFBLEVBQUdFLE9BQUgsSUFBQSxNQUFBLE9BQUEsT0FBQSxHQUFBLE9BQUEsTUFBQSxPQUFBO1lBQUdBLElBQUFBLENBQUgsS0FBQSxHQUFBLFNBQUEsQ0FBQSxLQUFjOztRQUNsRCxJQUFJQztRQUNKLHdDQUEyQztZQUN6QyxNQUFNLEVBQUVILE9BQU9PLGFBQWEsRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxTQUFBQSxnQkFBZ0IsRUFBQ047WUFDbEQsSUFBSUssZUFBZTtnQkFDakJKLGFBQWFJO1lBQ2YsT0FBTyxJQUFJRSxDQUFBQSxHQUFBQSxTQUFBQSxPQUFPLEVBQUNQLElBQUksQ0FBQyxFQUFFLEdBQUc7Z0JBQzNCQyxhQUFhRCxJQUFJLENBQUMsRUFBRTtZQUN0QixPQUFPO2dCQUNMLGlKQUFpSjtnQkFDakpDLGFBQWFELElBQUksQ0FBQyxFQUFFO1lBQ3RCO1FBQ0YsT0FBTzs7UUFJUCxJQUFJLENBQUNRLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBaUIsRUFBQ1AsYUFBYTtZQUNsQyxJQUFJQyxRQUFRQyxHQUFHLENBQUNDLFFBQVEsS0FBSyxXQUFjO2dCQUN6Q0ssQ0FBQUEsR0FBQUEsaUJBQUFBLGtCQUFrQixFQUNoQixBQUNBLHdFQUF3RSxJQURJO2dCQUU1RVIsWUFDQUQ7WUFFSjtZQUNBLElBQUlVLGFBQUFBLHdCQUF3QixFQUFFO2dCQUM1QkMsQ0FBQUEsR0FBQUEsYUFBQUEsZUFBZSxFQUFDWDtZQUNsQjtZQUVBTixtQkFBbUJrQixLQUFLLENBQUNiLE9BQU9GLE9BQU8sRUFBRUc7UUFDM0M7SUFDRjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDIyNjUsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2FwcC1kZXYtb3ZlcmxheS1zZXR1cC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXRjaENvbnNvbGVFcnJvciB9IGZyb20gJy4vZXJyb3JzL2ludGVyY2VwdC1jb25zb2xlLWVycm9yJ1xuaW1wb3J0IHsgaGFuZGxlR2xvYmFsRXJyb3JzIH0gZnJvbSAnLi9lcnJvcnMvdXNlLWVycm9yLWhhbmRsZXInXG5pbXBvcnQge1xuICBpbml0aWFsaXplRGVidWdMb2dGb3J3YXJkaW5nLFxuICBpc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQsXG59IGZyb20gJy4vZm9yd2FyZC1sb2dzJ1xuXG5oYW5kbGVHbG9iYWxFcnJvcnMoKVxucGF0Y2hDb25zb2xlRXJyb3IoKVxuXG5pZiAoaXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkKSB7XG4gIGluaXRpYWxpemVEZWJ1Z0xvZ0ZvcndhcmRpbmcoJ2FwcCcpXG59XG4iXSwibmFtZXMiOlsiaGFuZGxlR2xvYmFsRXJyb3JzIiwicGF0Y2hDb25zb2xlRXJyb3IiLCJpc1Rlcm1pbmFsTG9nZ2luZ0VuYWJsZWQiLCJpbml0aWFsaXplRGVidWdMb2dGb3J3YXJkaW5nIl0sIm1hcHBpbmdzIjoiOzs7dUNBQWtDO2lDQUNDOzZCQUk1QjtBQUVQQSxDQUFBQSxHQUFBQSxpQkFBQUEsa0JBQWtCO0FBQ2xCQyxDQUFBQSxHQUFBQSx1QkFBQUEsaUJBQWlCO0FBRWpCLElBQUlDLGFBQUFBLHdCQUF3QixFQUFFO0lBQzVCQyxDQUFBQSxHQUFBQSxhQUFBQSw0QkFBNEIsRUFBQztBQUMvQiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyMjg5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9lcnJvcnMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgb3JpZ2luQ29uc29sZUVycm9yIH0gZnJvbSAnLi9pbnRlcmNlcHQtY29uc29sZS1lcnJvcidcbmV4cG9ydCB7IGhhbmRsZUNsaWVudEVycm9yIH0gZnJvbSAnLi91c2UtZXJyb3ItaGFuZGxlcidcbmV4cG9ydCB7IGRlY29yYXRlRGV2RXJyb3IgfSBmcm9tICcuL3N0aXRjaGVkLWVycm9yJ1xuIl0sIm5hbWVzIjpbImRlY29yYXRlRGV2RXJyb3IiLCJoYW5kbGVDbGllbnRFcnJvciIsIm9yaWdpbkNvbnNvbGVFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0lBRVNBLGdCQUFnQixFQUFBO2VBQWhCQSxlQUFBQSxnQkFBZ0I7O0lBRGhCQyxpQkFBaUIsRUFBQTtlQUFqQkEsaUJBQUFBLGlCQUFpQjs7SUFEakJDLGtCQUFrQixFQUFBO2VBQWxCQSx1QkFBQUEsa0JBQWtCOzs7dUNBQVE7aUNBQ0Q7K0JBQ0QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjMzMCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvc2VnbWVudC1leHBsb3Jlci1ub2RlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHR5cGUgeyBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7XG4gIHVzZVN0YXRlLFxuICBjcmVhdGVDb250ZXh0LFxuICB1c2VDb250ZXh0LFxuICB1c2UsXG4gIHVzZU1lbW8sXG4gIHVzZUNhbGxiYWNrLFxufSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgZGlzcGF0Y2hlciB9IGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9uZXh0LWRldnRvb2xzJ1xuaW1wb3J0IHsgbm90Rm91bmQgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvY29tcG9uZW50cy9ub3QtZm91bmQnXG5cbmV4cG9ydCBjb25zdCBTRUdNRU5UX0VYUExPUkVSX1NJTVVMQVRFRF9FUlJPUl9NRVNTQUdFID1cbiAgJ05FWFRfREVWVE9PTFNfU0lNVUxBVEVEX0VSUk9SJ1xuXG5leHBvcnQgdHlwZSBTZWdtZW50Tm9kZVN0YXRlID0ge1xuICB0eXBlOiBzdHJpbmdcbiAgcGFnZVBhdGg6IHN0cmluZ1xuICBib3VuZGFyeVR5cGU6IHN0cmluZyB8IG51bGxcbiAgc2V0Qm91bmRhcnlUeXBlOiAodHlwZTogJ2Vycm9yJyB8ICdub3QtZm91bmQnIHwgJ2xvYWRpbmcnIHwgbnVsbCkgPT4gdm9pZFxufVxuXG5mdW5jdGlvbiBTZWdtZW50VHJpZU5vZGUoe1xuICB0eXBlLFxuICBwYWdlUGF0aCxcbn06IHtcbiAgdHlwZTogc3RyaW5nXG4gIHBhZ2VQYXRoOiBzdHJpbmdcbn0pOiBSZWFjdC5SZWFjdE5vZGUge1xuICBjb25zdCB7IGJvdW5kYXJ5VHlwZSwgc2V0Qm91bmRhcnlUeXBlIH0gPSB1c2VTZWdtZW50U3RhdGUoKVxuICBjb25zdCBub2RlU3RhdGU6IFNlZ21lbnROb2RlU3RhdGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZSxcbiAgICAgIHBhZ2VQYXRoLFxuICAgICAgYm91bmRhcnlUeXBlLFxuICAgICAgc2V0Qm91bmRhcnlUeXBlLFxuICAgIH1cbiAgfSwgW3R5cGUsIHBhZ2VQYXRoLCBib3VuZGFyeVR5cGUsIHNldEJvdW5kYXJ5VHlwZV0pXG5cbiAgLy8gVXNlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGVuc3VyZSB0aGUgc3RhdGUgaXMgdXBkYXRlZCBkdXJpbmcgc3VzcGVuc2UuXG4gIC8vIGB1c2VFZmZlY3RgIHdvbid0IHdvcmsgYXMgdGhlIHN0YXRlIGlzIHByZXNlcnZlZCBkdXJpbmcgc3VzcGVuc2UuXG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgZGlzcGF0Y2hlci5zZWdtZW50RXhwbG9yZXJOb2RlQWRkKG5vZGVTdGF0ZSlcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGlzcGF0Y2hlci5zZWdtZW50RXhwbG9yZXJOb2RlUmVtb3ZlKG5vZGVTdGF0ZSlcbiAgICB9XG4gIH0sIFtub2RlU3RhdGVdKVxuXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIE5vdEZvdW5kU2VnbWVudE5vZGUoKTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgbm90Rm91bmQoKVxufVxuXG5mdW5jdGlvbiBFcnJvclNlZ21lbnROb2RlKCk6IFJlYWN0LlJlYWN0Tm9kZSB7XG4gIHRocm93IG5ldyBFcnJvcihTRUdNRU5UX0VYUExPUkVSX1NJTVVMQVRFRF9FUlJPUl9NRVNTQUdFKVxufVxuXG5jb25zdCBmb3JldmVyID0gbmV3IFByb21pc2UoKCkgPT4ge30pXG5mdW5jdGlvbiBMb2FkaW5nU2VnbWVudE5vZGUoKTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgdXNlKGZvcmV2ZXIpXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZWdtZW50Vmlld1N0YXRlTm9kZSh7IHBhZ2UgfTogeyBwYWdlOiBzdHJpbmcgfSkge1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGRpc3BhdGNoZXIuc2VnbWVudEV4cGxvcmVyVXBkYXRlUm91dGVTdGF0ZShwYWdlKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkaXNwYXRjaGVyLnNlZ21lbnRFeHBsb3JlclVwZGF0ZVJvdXRlU3RhdGUoJycpXG4gICAgfVxuICB9LCBbcGFnZV0pXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZWdtZW50Qm91bmRhcnlUcmlnZ2VyTm9kZSgpIHtcbiAgY29uc3QgeyBib3VuZGFyeVR5cGUgfSA9IHVzZVNlZ21lbnRTdGF0ZSgpXG4gIGxldCBzZWdtZW50Tm9kZTogUmVhY3QuUmVhY3ROb2RlID0gbnVsbFxuICBpZiAoYm91bmRhcnlUeXBlID09PSAnbG9hZGluZycpIHtcbiAgICBzZWdtZW50Tm9kZSA9IDxMb2FkaW5nU2VnbWVudE5vZGUgLz5cbiAgfSBlbHNlIGlmIChib3VuZGFyeVR5cGUgPT09ICdub3QtZm91bmQnKSB7XG4gICAgc2VnbWVudE5vZGUgPSA8Tm90Rm91bmRTZWdtZW50Tm9kZSAvPlxuICB9IGVsc2UgaWYgKGJvdW5kYXJ5VHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIHNlZ21lbnROb2RlID0gPEVycm9yU2VnbWVudE5vZGUgLz5cbiAgfVxuICByZXR1cm4gc2VnbWVudE5vZGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFNlZ21lbnRWaWV3Tm9kZSh7XG4gIHR5cGUsXG4gIHBhZ2VQYXRoLFxuICBjaGlsZHJlbixcbn06IHtcbiAgdHlwZTogc3RyaW5nXG4gIHBhZ2VQYXRoOiBzdHJpbmdcbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGVcbn0pOiBSZWFjdC5SZWFjdE5vZGUge1xuICBjb25zdCBzZWdtZW50Tm9kZSA9IChcbiAgICA8U2VnbWVudFRyaWVOb2RlIGtleT17dHlwZX0gdHlwZT17dHlwZX0gcGFnZVBhdGg9e3BhZ2VQYXRofSAvPlxuICApXG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge3NlZ21lbnROb2RlfVxuICAgICAge2NoaWxkcmVufVxuICAgIDwvPlxuICApXG59XG5cbmNvbnN0IFNlZ21lbnRTdGF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PHtcbiAgYm91bmRhcnlUeXBlOiAnbm90LWZvdW5kJyB8ICdlcnJvcicgfCAnbG9hZGluZycgfCBudWxsXG4gIHNldEJvdW5kYXJ5VHlwZTogKHR5cGU6ICdub3QtZm91bmQnIHwgJ2Vycm9yJyB8ICdsb2FkaW5nJyB8IG51bGwpID0+IHZvaWRcbn0+KHtcbiAgYm91bmRhcnlUeXBlOiBudWxsLFxuICBzZXRCb3VuZGFyeVR5cGU6ICgpID0+IHt9LFxufSlcblxuZXhwb3J0IGZ1bmN0aW9uIFNlZ21lbnRTdGF0ZVByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3ROb2RlIH0pIHtcbiAgY29uc3QgW2JvdW5kYXJ5VHlwZSwgc2V0Qm91bmRhcnlUeXBlXSA9IHVzZVN0YXRlPFxuICAgICdub3QtZm91bmQnIHwgJ2Vycm9yJyB8ICdsb2FkaW5nJyB8IG51bGxcbiAgPihudWxsKVxuXG4gIGNvbnN0IFtlcnJvckJvdW5kYXJ5S2V5LCBzZXRFcnJvckJvdW5kYXJ5S2V5XSA9IHVzZVN0YXRlKDApXG4gIGNvbnN0IHJlbG9hZEJvdW5kYXJ5ID0gdXNlQ2FsbGJhY2soXG4gICAgKCkgPT4gc2V0RXJyb3JCb3VuZGFyeUtleSgocHJldikgPT4gcHJldiArIDEpLFxuICAgIFtdXG4gIClcblxuICBjb25zdCBzZXRCb3VuZGFyeVR5cGVBbmRSZWxvYWQgPSB1c2VDYWxsYmFjayhcbiAgICAodHlwZTogJ25vdC1mb3VuZCcgfCAnZXJyb3InIHwgJ2xvYWRpbmcnIHwgbnVsbCkgPT4ge1xuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgcmVsb2FkQm91bmRhcnkoKVxuICAgICAgfVxuICAgICAgc2V0Qm91bmRhcnlUeXBlKHR5cGUpXG4gICAgfSxcbiAgICBbcmVsb2FkQm91bmRhcnldXG4gIClcblxuICByZXR1cm4gKFxuICAgIDxTZWdtZW50U3RhdGVDb250ZXh0LlByb3ZpZGVyXG4gICAgICBrZXk9e2Vycm9yQm91bmRhcnlLZXl9XG4gICAgICB2YWx1ZT17e1xuICAgICAgICBib3VuZGFyeVR5cGUsXG4gICAgICAgIHNldEJvdW5kYXJ5VHlwZTogc2V0Qm91bmRhcnlUeXBlQW5kUmVsb2FkLFxuICAgICAgfX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9TZWdtZW50U3RhdGVDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWdtZW50U3RhdGUoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KFNlZ21lbnRTdGF0ZUNvbnRleHQpXG59XG4iXSwibmFtZXMiOlsiU0VHTUVOVF9FWFBMT1JFUl9TSU1VTEFURURfRVJST1JfTUVTU0FHRSIsIlNlZ21lbnRCb3VuZGFyeVRyaWdnZXJOb2RlIiwiU2VnbWVudFN0YXRlUHJvdmlkZXIiLCJTZWdtZW50Vmlld05vZGUiLCJTZWdtZW50Vmlld1N0YXRlTm9kZSIsInVzZVNlZ21lbnRTdGF0ZSIsIlNlZ21lbnRUcmllTm9kZSIsInR5cGUiLCJwYWdlUGF0aCIsImJvdW5kYXJ5VHlwZSIsInNldEJvdW5kYXJ5VHlwZSIsIm5vZGVTdGF0ZSIsInVzZU1lbW8iLCJ1c2VMYXlvdXRFZmZlY3QiLCJkaXNwYXRjaGVyIiwic2VnbWVudEV4cGxvcmVyTm9kZUFkZCIsInNlZ21lbnRFeHBsb3Jlck5vZGVSZW1vdmUiLCJOb3RGb3VuZFNlZ21lbnROb2RlIiwibm90Rm91bmQiLCJFcnJvclNlZ21lbnROb2RlIiwiRXJyb3IiLCJmb3JldmVyIiwiUHJvbWlzZSIsIkxvYWRpbmdTZWdtZW50Tm9kZSIsInVzZSIsInBhZ2UiLCJzZWdtZW50RXhwbG9yZXJVcGRhdGVSb3V0ZVN0YXRlIiwic2VnbWVudE5vZGUiLCJjaGlsZHJlbiIsIlNlZ21lbnRTdGF0ZUNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlU3RhdGUiLCJlcnJvckJvdW5kYXJ5S2V5Iiwic2V0RXJyb3JCb3VuZGFyeUtleSIsInJlbG9hZEJvdW5kYXJ5IiwidXNlQ2FsbGJhY2siLCJwcmV2Iiwic2V0Qm91bmRhcnlUeXBlQW5kUmVsb2FkIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUNvbnRleHQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWVhQSx3Q0FBd0MsRUFBQTtlQUF4Q0E7O0lBK0RHQywwQkFBMEIsRUFBQTtlQUExQkE7O0lBMENBQyxvQkFBb0IsRUFBQTtlQUFwQkE7O0lBN0JBQyxlQUFlLEVBQUE7ZUFBZkE7O0lBdkJBQyxvQkFBb0IsRUFBQTtlQUFwQkE7O0lBc0ZBQyxlQUFlLEVBQUE7ZUFBZkE7Ozs7dUJBaEpUOzhCQUVvQjswQkFDRjtBQUVsQixNQUFNTCwyQ0FDWDtBQVNGLFNBQVNNLGdCQUFnQixLQU14QjtJQU53QixJQUFBLEVBQ3ZCQyxJQUFJLEVBQ0pDLFFBQVEsRUFJVCxHQU53QjtJQU92QixNQUFNLEVBQUVDLFlBQVksRUFBRUMsZUFBZSxFQUFFLEdBQUdMO0lBQzFDLE1BQU1NLFlBQThCQyxDQUFBQSxHQUFBQSxPQUFBQSxPQUFPLEVBQUM7UUFDMUMsT0FBTztZQUNMTDtZQUNBQztZQUNBQztZQUNBQztRQUNGO0lBQ0YsR0FBRztRQUFDSDtRQUFN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LENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ0wsb0JBQW9CUyxRQUFRLEVBQUE7UUFFM0JDLE9BQU87WUFDTDlCO1lBQ0FDLGlCQUFpQjJCO1FBQ25CO2tCQUVDVDtPQU5JSTtBQVNYO0FBRU8sU0FBUzNCO0lBQ2QsT0FBT21DLENBQUFBLEdBQUFBLE9BQUFBLFVBQVUsRUFBQ1g7QUFDcEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjQ5MywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvYXBwLWRldi1vdmVybGF5LWVycm9yLWJvdW5kYXJ5LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBkaXNwYXRjaGVyIH0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL25leHQtZGV2dG9vbHMnXG5pbXBvcnQgeyBSdW50aW1lRXJyb3JIYW5kbGVyIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L2Rldi9ydW50aW1lLWVycm9yLWhhbmRsZXInXG5pbXBvcnQgeyBFcnJvckJvdW5kYXJ5IH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvZXJyb3ItYm91bmRhcnknXG5pbXBvcnQgRGVmYXVsdEdsb2JhbEVycm9yIGZyb20gJy4uLy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2J1aWx0aW4vZ2xvYmFsLWVycm9yJ1xuaW1wb3J0IHR5cGUgeyBHbG9iYWxFcnJvclN0YXRlIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1pbnN0YW5jZSdcbmltcG9ydCB7IFNFR01FTlRfRVhQTE9SRVJfU0lNVUxBVEVEX0VSUk9SX01FU1NBR0UgfSBmcm9tICcuL3NlZ21lbnQtZXhwbG9yZXItbm9kZSdcblxudHlwZSBBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeVByb3BzID0ge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG4gIGdsb2JhbEVycm9yOiBHbG9iYWxFcnJvclN0YXRlXG59XG5cbnR5cGUgQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnlTdGF0ZSA9IHtcbiAgcmVhY3RFcnJvcjogdW5rbm93blxufVxuXG5mdW5jdGlvbiBFcnJvcmVkSHRtbCh7XG4gIGdsb2JhbEVycm9yOiBbR2xvYmFsRXJyb3IsIGdsb2JhbEVycm9yU3R5bGVzXSxcbiAgZXJyb3IsXG59OiB7XG4gIGdsb2JhbEVycm9yOiBHbG9iYWxFcnJvclN0YXRlXG4gIGVycm9yOiB1bmtub3duXG59KSB7XG4gIGlmICghZXJyb3IpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGh0bWw+XG4gICAgICAgIDxoZWFkIC8+XG4gICAgICAgIDxib2R5IC8+XG4gICAgICA8L2h0bWw+XG4gICAgKVxuICB9XG4gIHJldHVybiAoXG4gICAgPEVycm9yQm91bmRhcnkgZXJyb3JDb21wb25lbnQ9e0RlZmF1bHRHbG9iYWxFcnJvcn0+XG4gICAgICB7Z2xvYmFsRXJyb3JTdHlsZXN9XG4gICAgICA8R2xvYmFsRXJyb3IgZXJyb3I9e2Vycm9yfSAvPlxuICAgIDwvRXJyb3JCb3VuZGFyeT5cbiAgKVxufVxuXG5leHBvcnQgY2xhc3MgQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnkgZXh0ZW5kcyBQdXJlQ29tcG9uZW50PFxuICBBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeVByb3BzLFxuICBBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeVN0YXRlXG4+IHtcbiAgc3RhdGUgPSB7IHJlYWN0RXJyb3I6IG51bGwgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3I6IEVycm9yKSB7XG4gICAgUnVudGltZUVycm9ySGFuZGxlci5oYWRSdW50aW1lRXJyb3IgPSB0cnVlXG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVhY3RFcnJvcjogZXJyb3IsXG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyOiBFcnJvcikge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICBlcnIubWVzc2FnZSA9PT0gU0VHTUVOVF9FWFBMT1JFUl9TSU1VTEFURURfRVJST1JfTUVTU0FHRVxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGRpc3BhdGNoZXIub3BlbkVycm9yT3ZlcmxheSgpXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgZ2xvYmFsRXJyb3IgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCB7IHJlYWN0RXJyb3IgfSA9IHRoaXMuc3RhdGVcblxuICAgIGNvbnN0IGZhbGxiYWNrID0gKFxuICAgICAgPEVycm9yZWRIdG1sIGdsb2JhbEVycm9yPXtnbG9iYWxFcnJvcn0gZXJyb3I9e3JlYWN0RXJyb3J9IC8+XG4gICAgKVxuXG4gICAgcmV0dXJuIHJlYWN0RXJyb3IgIT09IG51bGwgPyBmYWxsYmFjayA6IGNoaWxkcmVuXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeSIsIkVycm9yZWRIdG1sIiwiZ2xvYmFsRXJyb3IiLCJHbG9iYWxFcnJvciIsImdsb2JhbEVycm9yU3R5bGVzIiwiZXJyb3IiLCJodG1sIiwiaGVhZCIsImJvZHkiLCJFcnJvckJvdW5kYXJ5IiwiZXJyb3JDb21wb25lbnQiLCJEZWZhdWx0R2xvYmFsRXJyb3IiLCJQdXJlQ29tcG9uZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiUnVudGltZUVycm9ySGFuZGxlciIsImhhZFJ1bnRpbWVFcnJvciIsInJlYWN0RXJyb3IiLCJjb21wb25lbnREaWRDYXRjaCIsImVyciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm1lc3NhZ2UiLCJTRUdNRU5UX0VYUExPUkVSX1NJTVVMQVRFRF9FUlJPUl9NRVNTQUdFIiwiZGlzcGF0Y2hlciIsIm9wZW5FcnJvck92ZXJsYXkiLCJyZW5kZXIiLCJjaGlsZHJlbiIsInByb3BzIiwic3RhdGUiLCJmYWxsYmFjayJdLCJtYXBwaW5ncyI6IkFBd0RNbUIsUUFBUUMsR0FBRyxDQUFDQyxRQUFROzs7OzsrQkFoQmJyQiw4QkFBQUE7OztlQUFBQTs7Ozs7dUJBeENpQjs4QkFDSDtxQ0FDUzsrQkFDTjtzRUFDQztxQ0FFMEI7QUFXekQsU0FBU0MsWUFBWSxLQU1wQjtJQU5vQixJQUFBLEVBQ25CQyxhQUFhLENBQUNDLGFBQWFDLGtCQUFrQixFQUM3Q0MsS0FBSyxFQUlOLEdBTm9CO0lBT25CLElBQUksQ0FBQ0EsT0FBTztRQUNWLE9BQUEsV0FBQSxHQUNFLENBQUEsR0FBQSxZQUFBLElBQUEsRUFBQ0MsUUFBQUE7OzhCQUNDLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQ0MsUUFBQUEsQ0FBQUE7OEJBQ0QsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDQyxRQUFBQSxDQUFBQTs7O0lBR1A7SUFDQSxPQUFBLFdBQUEsR0FDRSxDQUFBLEdBQUEsWUFBQSxJQUFBLEVBQUNDLGVBQUFBLGFBQWEsRUFBQTtRQUFDQyxnQkFBZ0JDLGFBQUFBLE9BQWtCOztZQUM5Q1A7MEJBQ0QsQ0FBQSxHQUFBLFlBQUEsR0FBQSxFQUFDRCxhQUFBQTtnQkFBWUUsT0FBT0E7Ozs7QUFHMUI7QUFFTyxNQUFNTCxtQ0FBbUNZLE9BQUFBLGFBQWE7SUFNM0QsT0FBT0MseUJBQXlCUixLQUFZLEVBQUU7UUFDNUNTLHFCQUFBQSxtQkFBbUIsQ0FBQ0MsZUFBZSxHQUFHO1FBRXRDLE9BQU87WUFDTEMsWUFBWVg7UUFDZDtJQUNGO0lBRUFZLGtCQUFrQkMsR0FBVSxFQUFFO1FBQzVCLHdEQUMyQixpQkFDekJBLElBQUlJLE9BQU8sS0FBS0MscUJBQUFBLHdDQUF3QyxFQUN4RDtZQUNBO1FBQ0Y7UUFDQUMsY0FBQUEsVUFBVSxDQUFDQyxnQkFBZ0I7SUFDN0I7SUFFQUMsU0FBUztRQUNQLE1BQU0sRUFBRUMsUUFBUSxFQUFFekIsV0FBVyxFQUFFLEdBQUcsSUFBSSxDQUFDMEIsS0FBSztRQUM1QyxNQUFNLEVBQUVaLFVBQVUsRUFBRSxHQUFHLElBQUksQ0FBQ2EsS0FBSztRQUVqQyxNQUFNQyxXQUFBQSxXQUFBQSxHQUNKLENBQUEsR0FBQSxZQUFBLEdBQUEsRUFBQzdCLGFBQUFBO1lBQVlDLGFBQWFBO1lBQWFHLE9BQU9XOztRQUdoRCxPQUFPQSxlQUFlLE9BQU9jLFdBQVdIO0lBQzFDOztRQWpDSyxLQUFBLElBQUEsT0FBQSxJQUFBLENBSUxFLEtBQUFBLEdBQVE7WUFBRWIsWUFBWTtRQUFLOztBQThCN0IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjU3MywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS91c2UtYXBwLWRldi1yZW5kZXJpbmctaW5kaWNhdG9yLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VUcmFuc2l0aW9uIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBkaXNwYXRjaGVyIH0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL25leHQtZGV2dG9vbHMnXG5cbmV4cG9ydCBjb25zdCB1c2VBcHBEZXZSZW5kZXJpbmdJbmRpY2F0b3IgPSAoKSA9PiB7XG4gIGNvbnN0IFtpc1BlbmRpbmcsIHN0YXJ0VHJhbnNpdGlvbl0gPSB1c2VUcmFuc2l0aW9uKClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc1BlbmRpbmcpIHtcbiAgICAgIGRpc3BhdGNoZXIucmVuZGVyaW5nSW5kaWNhdG9yU2hvdygpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3BhdGNoZXIucmVuZGVyaW5nSW5kaWNhdG9ySGlkZSgpXG4gICAgfVxuICB9LCBbaXNQZW5kaW5nXSlcblxuICByZXR1cm4gc3RhcnRUcmFuc2l0aW9uXG59XG4iXSwibmFtZXMiOlsidXNlQXBwRGV2UmVuZGVyaW5nSW5kaWNhdG9yIiwiaXNQZW5kaW5nIiwic3RhcnRUcmFuc2l0aW9uIiwidXNlVHJhbnNpdGlvbiIsInVzZUVmZmVjdCIsImRpc3BhdGNoZXIiLCJyZW5kZXJpbmdJbmRpY2F0b3JTaG93IiwicmVuZGVyaW5nSW5kaWNhdG9ySGlkZSJdLCJtYXBwaW5ncyI6Ijs7OytCQUthQSwrQkFBQUE7OztlQUFBQTs7O3VCQUg0Qjs4QkFDZDtBQUVwQixNQUFNQSw4QkFBOEI7SUFDekMsTUFBTSxDQUFDQyxXQUFXQyxnQkFBZ0IsR0FBR0MsQ0FBQUEsR0FBQUEsT0FBQUEsYUFBYTtJQUVsREMsQ0FBQUEsR0FBQUEsT0FBQUEsU0FBUyxFQUFDO1FBQ1IsSUFBSUgsV0FBVztZQUNiSSxjQUFBQSxVQUFVLENBQUNDLHNCQUFzQjtRQUNuQyxPQUFPO1lBQ0xELGNBQUFBLFVBQVUsQ0FBQ0Usc0JBQXNCO1FBQ25DO0lBQ0YsR0FBRztRQUFDTjtLQUFVO0lBRWQsT0FBT0M7QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyNjEwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9lcnJvcnMvcmVwbGF5LXNzci1vbmx5LWVycm9ycy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBoYW5kbGVDbGllbnRFcnJvciB9IGZyb20gJy4vdXNlLWVycm9yLWhhbmRsZXInXG5pbXBvcnQgeyBpc05leHRSb3V0ZXJFcnJvciB9IGZyb20gJy4uLy4uLy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2lzLW5leHQtcm91dGVyLWVycm9yJ1xuaW1wb3J0IHsgTUlTU0lOR19ST09UX1RBR1NfRVJST1IgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2Vycm9ycy9jb25zdGFudHMnXG5cbmZ1bmN0aW9uIHJlYWRTc3JFcnJvcigpOiAoRXJyb3IgJiB7IGRpZ2VzdD86IHN0cmluZyB9KSB8IG51bGwge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBzc3JFcnJvclRlbXBsYXRlVGFnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAndGVtcGxhdGVbZGF0YS1uZXh0LWVycm9yLW1lc3NhZ2VdJ1xuICApXG4gIGlmIChzc3JFcnJvclRlbXBsYXRlVGFnKSB7XG4gICAgY29uc3QgbWVzc2FnZTogc3RyaW5nID0gc3NyRXJyb3JUZW1wbGF0ZVRhZy5nZXRBdHRyaWJ1dGUoXG4gICAgICAnZGF0YS1uZXh0LWVycm9yLW1lc3NhZ2UnXG4gICAgKSFcbiAgICBjb25zdCBzdGFjayA9IHNzckVycm9yVGVtcGxhdGVUYWcuZ2V0QXR0cmlidXRlKCdkYXRhLW5leHQtZXJyb3Itc3RhY2snKVxuICAgIGNvbnN0IGRpZ2VzdCA9IHNzckVycm9yVGVtcGxhdGVUYWcuZ2V0QXR0cmlidXRlKCdkYXRhLW5leHQtZXJyb3ItZGlnZXN0JylcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIGlmIChkaWdlc3QpIHtcbiAgICAgIDsoZXJyb3IgYXMgYW55KS5kaWdlc3QgPSBkaWdlc3RcbiAgICB9XG4gICAgLy8gU2tpcCBOZXh0LmpzIFNTUidkIGludGVybmFsIGVycm9ycyB0aGF0IHdoaWNoIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgZXJyb3IgYm91bmRhcmllcy5cbiAgICBpZiAoaXNOZXh0Um91dGVyRXJyb3IoZXJyb3IpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBlcnJvci5zdGFjayA9IHN0YWNrIHx8ICcnXG4gICAgcmV0dXJuIGVycm9yXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG4vKipcbiAqIE5lZWRzIHRvIGJlIGluIHRoZSBzYW1lIGVycm9yIGJvdW5kYXJ5IGFzIHRoZSBzaGVsbC5cbiAqIElmIGl0IGNvbW1pdHMsIHdlIGtub3cgd2UgcmVjb3ZlcmVkIGZyb20gYW4gU1NSIGVycm9yLlxuICogSWYgaXQgZG9lc24ndCBjb21taXQsIHdlIGVycm9yZWQgYWdhaW4gYW5kIFJlYWN0IHdpbGwgdGFrZSBjYXJlIG9mIGVycm9yIHJlcG9ydGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlcGxheVNzck9ubHlFcnJvcnMoe1xuICBvbkJsb2NraW5nRXJyb3IsXG59OiB7XG4gIG9uQmxvY2tpbmdFcnJvcjogKCkgPT4gdm9pZFxufSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIE5lZWQgdG8gcmVhZCBkdXJpbmcgcmVuZGVyLiBUaGUgYXR0cmlidXRlcyB3aWxsIGJlIGdvbmUgYWZ0ZXIgY29tbWl0LlxuICAgIGNvbnN0IHNzckVycm9yID0gcmVhZFNzckVycm9yKClcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKHNzckVycm9yICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE8odmVpbCk6IEluY2x1ZGUgb3JpZ2luYWwgT3duZXIgU3RhY2sgKE5EWC05MDUpXG4gICAgICAgIC8vIFRPRE8odmVpbCk6IE1hcmsgYXMgcmVjb3ZlcmFibGUgZXJyb3JcbiAgICAgICAgLy8gVE9ETyh2ZWlsKTogY29uc29sZS5lcnJvclxuICAgICAgICBoYW5kbGVDbGllbnRFcnJvcihzc3JFcnJvcilcblxuICAgICAgICAvLyBJZiBpdCdzIG1pc3Npbmcgcm9vdCB0YWdzLCB3ZSBjYW4ndCByZWNvdmVyLCBtYWtlIGl0IGJsb2NraW5nLlxuICAgICAgICBpZiAoc3NyRXJyb3IuZGlnZXN0ID09PSBNSVNTSU5HX1JPT1RfVEFHU19FUlJPUikge1xuICAgICAgICAgIG9uQmxvY2tpbmdFcnJvcigpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbc3NyRXJyb3IsIG9uQmxvY2tpbmdFcnJvcl0pXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIl0sIm5hbWVzIjpbIlJlcGxheVNzck9ubHlFcnJvcnMiLCJyZWFkU3NyRXJyb3IiLCJkb2N1bWVudCIsInNzckVycm9yVGVtcGxhdGVUYWciLCJxdWVyeVNlbGVjdG9yIiwibWVzc2FnZSIsImdldEF0dHJpYnV0ZSIsInN0YWNrIiwiZGlnZXN0IiwiZXJyb3IiLCJFcnJvciIsImlzTmV4dFJvdXRlckVycm9yIiwib25CbG9ja2luZ0Vycm9yIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwic3NyRXJyb3IiLCJ1c2VFZmZlY3QiLCJoYW5kbGVDbGllbnRFcnJvciIsIk1JU1NJTkdfUk9PVF9UQUdTX0VSUk9SIl0sIm1hcHBpbmdzIjoiQUE0Q01hLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLOzs7OzsrQkFMZmYsdUJBQUFBOzs7ZUFBQUE7Ozt1QkF2Q1U7aUNBQ1E7bUNBQ0E7MkJBQ007QUFFeEMsU0FBU0M7SUFDUCxJQUFJLE9BQU9DLGFBQWEsYUFBYTtRQUNuQyxPQUFPO0lBQ1Q7SUFFQSxNQUFNQyxzQkFBc0JELFNBQVNFLGFBQWEsQ0FDaEQ7SUFFRixJQUFJRCxxQkFBcUI7UUFDdkIsTUFBTUUsVUFBa0JGLG9CQUFvQkcsWUFBWSxDQUN0RDtRQUVGLE1BQU1DLFFBQVFKLG9CQUFvQkcsWUFBWSxDQUFDO1FBQy9DLE1BQU1FLFNBQVNMLG9CQUFvQkcsWUFBWSxDQUFDO1FBQ2hELE1BQU1HLFFBQVEsT0FBQSxjQUFrQixDQUFsQixJQUFJQyxNQUFNTCxVQUFWLHFCQUFBO21CQUFBO3dCQUFBOzBCQUFBO1FBQWlCO1FBQy9CLElBQUlHLFFBQVE7O1lBQ1JDLE1BQWNELE1BQU0sR0FBR0E7UUFDM0I7UUFDQSx5RkFBeUY7UUFDekYsSUFBSUcsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFpQixFQUFDRixRQUFRO1lBQzVCLE9BQU87UUFDVDtRQUNBQSxNQUFNRixLQUFLLEdBQUdBLFNBQVM7UUFDdkIsT0FBT0U7SUFDVDtJQUVBLE9BQU87QUFDVDtBQU9PLFNBQVNULG9CQUFvQixLQUluQztJQUptQyxJQUFBLEVBQ2xDWSxlQUFlLEVBR2hCLEdBSm1DO0lBS2xDLHdDQUEyQztRQUN6Qyx3RUFBd0U7UUFDeEUsTUFBTUksV0FBV2Y7UUFDakIsc0RBQXNEO1FBQ3REZ0IsQ0FBQUEsR0FBQUEsT0FBQUEsU0FBUyxFQUFDO1lBQ1IsSUFBSUQsYUFBYSxNQUFNO2dCQUNyQixxREFBcUQ7Z0JBQ3JELHdDQUF3QztnQkFDeEMsNEJBQTRCO2dCQUM1QkUsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFpQixFQUFDRjtnQkFFbEIsaUVBQWlFO2dCQUNqRSxJQUFJQSxTQUFTUixNQUFNLEtBQUtXLFdBQUFBLHVCQUF1QixFQUFFO29CQUMvQ1A7Z0JBQ0Y7WUFDRjtRQUNGLEdBQUc7WUFBQ0k7WUFBVUo7U0FBZ0I7SUFDaEM7SUFFQSxPQUFPO0FBQ1QiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjY4OSwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvZXJyb3JzL3VzZS1mb3J3YXJkLWNvbnNvbGUtbG9nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgaXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkLCBsb2dRdWV1ZSB9IGZyb20gJy4uL2ZvcndhcmQtbG9ncydcbmltcG9ydCB0eXBlIHsgdXNlV2Vic29ja2V0IH0gZnJvbSAnLi4vLi4vLi4vLi4vY2xpZW50L2Rldi9ob3QtcmVsb2FkZXIvYXBwL3VzZS13ZWJzb2NrZXQnXG5cbmV4cG9ydCBjb25zdCB1c2VGb3J3YXJkQ29uc29sZUxvZyA9IChcbiAgc29ja2V0UmVmOiBSZXR1cm5UeXBlPHR5cGVvZiB1c2VXZWJzb2NrZXQ+XG4pID0+IHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzVGVybWluYWxMb2dnaW5nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHNvY2tldCA9IHNvY2tldFJlZi5jdXJyZW50XG4gICAgaWYgKCFzb2NrZXQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IG9uT3BlbiA9ICgpID0+IHtcbiAgICAgIGxvZ1F1ZXVlLm9uU29ja2V0UmVhZHkoc29ja2V0KVxuICAgIH1cbiAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIG9uT3BlbilcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIG9uT3BlbilcbiAgICB9XG4gIH0sIFtzb2NrZXRSZWZdKVxufVxuIl0sIm5hbWVzIjpbInVzZUZvcndhcmRDb25zb2xlTG9nIiwic29ja2V0UmVmIiwidXNlRWZmZWN0IiwiaXNUZXJtaW5hbExvZ2dpbmdFbmFibGVkIiwic29ja2V0IiwiY3VycmVudCIsIm9uT3BlbiIsImxvZ1F1ZXVlIiwib25Tb2NrZXRSZWFkeSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIl0sIm1hcHBpbmdzIjoiOzs7K0JBSWFBLHdCQUFBQTs7O2VBQUFBOzs7dUJBSmE7NkJBQ3lCO0FBRzVDLE1BQU1BLHVCQUF1QixDQUNsQ0M7SUFFQUMsQ0FBQUEsR0FBQUEsT0FBQUEsU0FBUyxFQUFDO1FBQ1IsSUFBSSxDQUFDQyxhQUFBQSx3QkFBd0IsRUFBRTtZQUM3QjtRQUNGO1FBQ0EsTUFBTUMsU0FBU0gsVUFBVUksT0FBTztRQUNoQyxJQUFJLENBQUNELFFBQVE7WUFDWDtRQUNGO1FBRUEsTUFBTUUsU0FBUztZQUNiQyxhQUFBQSxRQUFRLENBQUNDLGFBQWEsQ0FBQ0o7UUFDekI7UUFDQUEsT0FBT0ssZ0JBQWdCLENBQUMsUUFBUUg7UUFFaEMsT0FBTztZQUNMRixPQUFPTSxtQkFBbUIsQ0FBQyxRQUFRSjtRQUNyQztJQUNGLEdBQUc7UUFBQ0w7S0FBVTtBQUNoQiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyNzMzLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9jbGllbnQtZW50cnkudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGdldFNvY2tldFVybCB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9kZXYvaG90LXJlbG9hZGVyL2dldC1zb2NrZXQtdXJsJ1xuaW1wb3J0IHsgSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSIH0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2Rldi9ob3QtcmVsb2FkZXItdHlwZXMnXG5pbXBvcnQgRGVmYXVsdEdsb2JhbEVycm9yIGZyb20gJy4uLy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2J1aWx0aW4vZ2xvYmFsLWVycm9yJ1xuaW1wb3J0IHsgQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnkgfSBmcm9tICcuL2FwcC1kZXYtb3ZlcmxheS1lcnJvci1ib3VuZGFyeSdcblxuLy8gaWYgYW4gZXJyb3IgaXMgdGhyb3duIHdoaWxlIHJlbmRlcmluZyBhbiBSU0Mgc3RyZWFtLCB0aGlzIHdpbGwgY2F0Y2ggaXQgaW4gZGV2XG4vLyBhbmQgc2hvdyB0aGUgZXJyb3Igb3ZlcmxheVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvb3RMZXZlbERldk92ZXJsYXlFbGVtZW50KHJlYWN0RWw6IFJlYWN0LlJlYWN0RWxlbWVudCkge1xuICBjb25zdCBzb2NrZXRVcmwgPSBnZXRTb2NrZXRVcmwocHJvY2Vzcy5lbnYuX19ORVhUX0FTU0VUX1BSRUZJWCB8fCAnJylcbiAgY29uc3Qgc29ja2V0ID0gbmV3IHdpbmRvdy5XZWJTb2NrZXQoYCR7c29ja2V0VXJsfS9fbmV4dC93ZWJwYWNrLWhtcmApXG5cbiAgLy8gYWRkIG1pbmltYWwgXCJob3QgcmVsb2FkXCIgc3VwcG9ydCBmb3IgUlNDIGVycm9yc1xuICBjb25zdCBoYW5kbGVyID0gKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICBsZXQgb2JqXG4gICAgdHJ5IHtcbiAgICAgIG9iaiA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSlcbiAgICB9IGNhdGNoIHt9XG5cbiAgICBpZiAoIW9iaiB8fCAhKCdhY3Rpb24nIGluIG9iaikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChvYmouYWN0aW9uID09PSBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuU0VSVkVSX0NPTVBPTkVOVF9DSEFOR0VTKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICB9XG4gIH1cblxuICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZXIpXG5cbiAgcmV0dXJuIChcbiAgICA8QXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnkgZ2xvYmFsRXJyb3I9e1tEZWZhdWx0R2xvYmFsRXJyb3IsIG51bGxdfT5cbiAgICAgIHtyZWFjdEVsfVxuICAgIDwvQXBwRGV2T3ZlcmxheUVycm9yQm91bmRhcnk+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVSb290TGV2ZWxEZXZPdmVybGF5RWxlbWVudCIsInJlYWN0RWwiLCJzb2NrZXRVcmwiLCJnZXRTb2NrZXRVcmwiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0FTU0VUX1BSRUZJWCIsInNvY2tldCIsIndpbmRvdyIsIldlYlNvY2tldCIsImhhbmRsZXIiLCJldmVudCIsIm9iaiIsIkpTT04iLCJwYXJzZSIsImRhdGEiLCJhY3Rpb24iLCJITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIiLCJTRVJWRVJfQ09NUE9ORU5UX0NIQU5HRVMiLCJsb2NhdGlvbiIsInJlbG9hZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeSIsImdsb2JhbEVycm9yIiwiRGVmYXVsdEdsb2JhbEVycm9yIl0sIm1hcHBpbmdzIjoiQUFTaUNJLFFBQVFDLEdBQUcsQ0FBQ0MsbUJBQW1COzs7OzsrQkFEaEROLG9DQUFBQTs7O2VBQUFBOzs7OztnRUFSRTs4QkFDVztrQ0FDZTtzRUFDYjs0Q0FDWTtBQUlwQyxTQUFTQSxpQ0FBaUNDLE9BQTJCO0lBQzFFLE1BQU1DLFlBQVlDLENBQUFBLEdBQUFBLGNBQUFBLFlBQVksMENBQW9DO0lBQ2xFLE1BQU1JLFNBQVMsSUFBSUMsT0FBT0MsU0FBUyxDQUFFLEtBQUVQLFlBQVU7SUFFakQsa0RBQWtEO0lBQ2xELE1BQU1RLFVBQVUsQ0FBQ0M7UUFDZixJQUFJQztRQUNKLElBQUk7WUFDRkEsTUFBTUMsS0FBS0MsS0FBSyxDQUFDSCxNQUFNSSxJQUFJO1FBQzdCLEVBQUUsT0FBQSxHQUFNLENBQUM7UUFFVCxJQUFJLENBQUNILE9BQU8sQ0FBRSxDQUFBLFlBQVlBLEdBQUUsR0FBSTtZQUM5QjtRQUNGO1FBRUEsSUFBSUEsSUFBSUksTUFBTSxLQUFLQyxrQkFBQUEsMkJBQTJCLENBQUNDLHdCQUF3QixFQUFFO1lBQ3ZFVixPQUFPVyxRQUFRLENBQUNDLE1BQU07UUFDeEI7SUFDRjtJQUVBYixPQUFPYyxnQkFBZ0IsQ0FBQyxXQUFXWDtJQUVuQyxPQUFBLFdBQUEsR0FDRSxDQUFBLEdBQUEsWUFBQSxHQUFBLEVBQUNZLDRCQUFBQSwwQkFBMEIsRUFBQTtRQUFDQyxhQUFhO1lBQUNDLGFBQUFBLE9BQWtCO1lBQUU7U0FBSztrQkFDaEV2Qjs7QUFHUCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyNzg5LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NlcnZlci9hcHAtcmVuZGVyL2FzeW5jLWxvY2FsLXN0b3JhZ2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBBc3luY0xvY2FsU3RvcmFnZSB9IGZyb20gJ2FzeW5jX2hvb2tzJ1xuXG5jb25zdCBzaGFyZWRBc3luY0xvY2FsU3RvcmFnZU5vdEF2YWlsYWJsZUVycm9yID0gbmV3IEVycm9yKFxuICAnSW52YXJpYW50OiBBc3luY0xvY2FsU3RvcmFnZSBhY2Nlc3NlZCBpbiBydW50aW1lIHdoZXJlIGl0IGlzIG5vdCBhdmFpbGFibGUnXG4pXG5cbmNsYXNzIEZha2VBc3luY0xvY2FsU3RvcmFnZTxTdG9yZSBleHRlbmRzIHt9PlxuICBpbXBsZW1lbnRzIEFzeW5jTG9jYWxTdG9yYWdlPFN0b3JlPlxue1xuICBkaXNhYmxlKCk6IHZvaWQge1xuICAgIHRocm93IHNoYXJlZEFzeW5jTG9jYWxTdG9yYWdlTm90QXZhaWxhYmxlRXJyb3JcbiAgfVxuXG4gIGdldFN0b3JlKCk6IFN0b3JlIHwgdW5kZWZpbmVkIHtcbiAgICAvLyBUaGlzIGZha2UgaW1wbGVtZW50YXRpb24gb2YgQXN5bmNMb2NhbFN0b3JhZ2UgYWx3YXlzIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgcnVuPFI+KCk6IFIge1xuICAgIHRocm93IHNoYXJlZEFzeW5jTG9jYWxTdG9yYWdlTm90QXZhaWxhYmxlRXJyb3JcbiAgfVxuXG4gIGV4aXQ8Uj4oKTogUiB7XG4gICAgdGhyb3cgc2hhcmVkQXN5bmNMb2NhbFN0b3JhZ2VOb3RBdmFpbGFibGVFcnJvclxuICB9XG5cbiAgZW50ZXJXaXRoKCk6IHZvaWQge1xuICAgIHRocm93IHNoYXJlZEFzeW5jTG9jYWxTdG9yYWdlTm90QXZhaWxhYmxlRXJyb3JcbiAgfVxuXG4gIHN0YXRpYyBiaW5kPFQ+KGZuOiBUKTogVCB7XG4gICAgcmV0dXJuIGZuXG4gIH1cbn1cblxuY29uc3QgbWF5YmVHbG9iYWxBc3luY0xvY2FsU3RvcmFnZSA9XG4gIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiAoZ2xvYmFsVGhpcyBhcyBhbnkpLkFzeW5jTG9jYWxTdG9yYWdlXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBc3luY0xvY2FsU3RvcmFnZTxcbiAgU3RvcmUgZXh0ZW5kcyB7fSxcbj4oKTogQXN5bmNMb2NhbFN0b3JhZ2U8U3RvcmU+IHtcbiAgaWYgKG1heWJlR2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2UpIHtcbiAgICByZXR1cm4gbmV3IG1heWJlR2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2UoKVxuICB9XG4gIHJldHVybiBuZXcgRmFrZUFzeW5jTG9jYWxTdG9yYWdlKClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpbmRTbmFwc2hvdDxUPihmbjogVCk6IFQge1xuICBpZiAobWF5YmVHbG9iYWxBc3luY0xvY2FsU3RvcmFnZSkge1xuICAgIHJldHVybiBtYXliZUdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlLmJpbmQoZm4pXG4gIH1cbiAgcmV0dXJuIEZha2VBc3luY0xvY2FsU3RvcmFnZS5iaW5kKGZuKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU25hcHNob3QoKTogPFIsIFRBcmdzIGV4dGVuZHMgYW55W10+KFxuICBmbjogKC4uLmFyZ3M6IFRBcmdzKSA9PiBSLFxuICAuLi5hcmdzOiBUQXJnc1xuKSA9PiBSIHtcbiAgaWYgKG1heWJlR2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2UpIHtcbiAgICByZXR1cm4gbWF5YmVHbG9iYWxBc3luY0xvY2FsU3RvcmFnZS5zbmFwc2hvdCgpXG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbjogYW55LCAuLi5hcmdzOiBhbnlbXSkge1xuICAgIHJldHVybiBmbiguLi5hcmdzKVxuICB9XG59XG4iXSwibmFtZXMiOlsiYmluZFNuYXBzaG90IiwiY3JlYXRlQXN5bmNMb2NhbFN0b3JhZ2UiLCJjcmVhdGVTbmFwc2hvdCIsInNoYXJlZEFzeW5jTG9jYWxTdG9yYWdlTm90QXZhaWxhYmxlRXJyb3IiLCJFcnJvciIsIkZha2VBc3luY0xvY2FsU3RvcmFnZSIsImRpc2FibGUiLCJnZXRTdG9yZSIsInVuZGVmaW5lZCIsInJ1biIsImV4aXQiLCJlbnRlcldpdGgiLCJiaW5kIiwiZm4iLCJtYXliZUdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlIiwiZ2xvYmFsVGhpcyIsIkFzeW5jTG9jYWxTdG9yYWdlIiwic25hcHNob3QiLCJhcmdzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7SUErQ2dCQSxZQUFZLEVBQUE7ZUFBWkE7O0lBVEFDLHVCQUF1QixFQUFBO2VBQXZCQTs7SUFnQkFDLGNBQWMsRUFBQTtlQUFkQTs7O0FBcERoQixNQUFNQywyQ0FBMkMsT0FBQSxjQUVoRCxDQUZnRCxJQUFJQyxNQUNuRCwrRUFEK0MscUJBQUE7V0FBQTtnQkFBQTtrQkFBQTtBQUVqRDtBQUVBLE1BQU1DO0lBR0pDLFVBQWdCO1FBQ2QsTUFBTUg7SUFDUjtJQUVBSSxXQUE4QjtRQUM1Qiw0RUFBNEU7UUFDNUUsT0FBT0M7SUFDVDtJQUVBQyxNQUFZO1FBQ1YsTUFBTU47SUFDUjtJQUVBTyxPQUFhO1FBQ1gsTUFBTVA7SUFDUjtJQUVBUSxZQUFrQjtRQUNoQixNQUFNUjtJQUNSO0lBRUEsT0FBT1MsS0FBUUMsRUFBSyxFQUFLO1FBQ3ZCLE9BQU9BO0lBQ1Q7QUFDRjtBQUVBLE1BQU1DLCtCQUNKLE9BQU9DLGVBQWUsZUFBZ0JBLFdBQW1CQyxpQkFBaUI7QUFFckUsU0FBU2Y7SUFHZCxJQUFJYSw4QkFBOEI7UUFDaEMsT0FBTyxJQUFJQTtJQUNiO0lBQ0EsT0FBTyxJQUFJVDtBQUNiO0FBRU8sU0FBU0wsYUFBZ0JhLEVBQUs7SUFDbkMsSUFBSUMsOEJBQThCO1FBQ2hDLE9BQU9BLDZCQUE2QkYsSUFBSSxDQUFDQztJQUMzQztJQUNBLE9BQU9SLHNCQUFzQk8sSUFBSSxDQUFDQztBQUNwQztBQUVPLFNBQVNYO0lBSWQsSUFBSVksOEJBQThCO1FBQ2hDLE9BQU9BLDZCQUE2QkcsUUFBUTtJQUM5QztJQUNBLE9BQU8sU0FBVUosRUFBTzs7WUFBS0ssMkJBQUgsS0FBYzs7UUFDdEMsT0FBT0wsTUFBTUs7SUFDZjtBQUNGIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDI4NzAsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9zcmMvc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLWluc3RhbmNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgV29ya0FzeW5jU3RvcmFnZSB9IGZyb20gJy4vd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHsgY3JlYXRlQXN5bmNMb2NhbFN0b3JhZ2UgfSBmcm9tICcuL2FzeW5jLWxvY2FsLXN0b3JhZ2UnXG5cbmV4cG9ydCBjb25zdCB3b3JrQXN5bmNTdG9yYWdlSW5zdGFuY2U6IFdvcmtBc3luY1N0b3JhZ2UgPVxuICBjcmVhdGVBc3luY0xvY2FsU3RvcmFnZSgpXG4iXSwibmFtZXMiOlsid29ya0FzeW5jU3RvcmFnZUluc3RhbmNlIiwiY3JlYXRlQXN5bmNMb2NhbFN0b3JhZ2UiXSwibWFwcGluZ3MiOiI7OzsrQkFHYUEsNEJBQUFBOzs7ZUFBQUE7OzttQ0FGMkI7QUFFakMsTUFBTUEsMkJBQ1hDLENBQUFBLEdBQUFBLG1CQUFBQSx1QkFBdUIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjg4NywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBBc3luY0xvY2FsU3RvcmFnZSB9IGZyb20gJ2FzeW5jX2hvb2tzJ1xuaW1wb3J0IHR5cGUgeyBJbmNyZW1lbnRhbENhY2hlIH0gZnJvbSAnLi4vbGliL2luY3JlbWVudGFsLWNhY2hlJ1xuaW1wb3J0IHR5cGUgeyBGZXRjaE1ldHJpY3MgfSBmcm9tICcuLi9iYXNlLWh0dHAnXG5pbXBvcnQgdHlwZSB7IEZhbGxiYWNrUm91dGVQYXJhbXMgfSBmcm9tICcuLi9yZXF1ZXN0L2ZhbGxiYWNrLXBhcmFtcydcbmltcG9ydCB0eXBlIHsgRGVlcFJlYWRvbmx5IH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9kZWVwLXJlYWRvbmx5J1xuaW1wb3J0IHR5cGUgeyBBcHBTZWdtZW50Q29uZmlnIH0gZnJvbSAnLi4vLi4vYnVpbGQvc2VnbWVudC1jb25maWcvYXBwL2FwcC1zZWdtZW50LWNvbmZpZydcbmltcG9ydCB0eXBlIHsgQWZ0ZXJDb250ZXh0IH0gZnJvbSAnLi4vYWZ0ZXIvYWZ0ZXItY29udGV4dCdcbmltcG9ydCB0eXBlIHsgQ2FjaGVMaWZlIH0gZnJvbSAnLi4vdXNlLWNhY2hlL2NhY2hlLWxpZmUnXG5cbi8vIFNoYXJlIHRoZSBpbnN0YW5jZSBtb2R1bGUgaW4gdGhlIG5leHQtc2hhcmVkIGxheWVyXG5pbXBvcnQgeyB3b3JrQXN5bmNTdG9yYWdlSW5zdGFuY2UgfSBmcm9tICcuL3dvcmstYXN5bmMtc3RvcmFnZS1pbnN0YW5jZScgd2l0aCB7ICd0dXJib3BhY2stdHJhbnNpdGlvbic6ICduZXh0LXNoYXJlZCcgfVxuaW1wb3J0IHR5cGUgeyBMYXp5UmVzdWx0IH0gZnJvbSAnLi4vbGliL2xhenktcmVzdWx0J1xuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtTdG9yZSB7XG4gIHJlYWRvbmx5IGlzU3RhdGljR2VuZXJhdGlvbjogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBUaGUgcGFnZSB0aGF0IGlzIGJlaW5nIHJlbmRlcmVkLiBUaGlzIHJlbGF0ZXMgdG8gdGhlIHBhdGggdG8gdGhlIHBhZ2UgZmlsZS5cbiAgICovXG4gIHJlYWRvbmx5IHBhZ2U6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgcm91dGUgdGhhdCBpcyBiZWluZyByZW5kZXJlZC4gVGhpcyBpcyB0aGUgcGFnZSBwcm9wZXJ0eSB3aXRob3V0IHRoZVxuICAgKiB0cmFpbGluZyBgL3BhZ2VgIG9yIGAvcm91dGVgIHN1ZmZpeC5cbiAgICovXG4gIHJlYWRvbmx5IHJvdXRlOiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIHNldCBvZiB1bmtub3duIHJvdXRlIHBhcmFtZXRlcnMuIEFjY2Vzc2luZyB0aGVzZSB3aWxsIGJlIHRyYWNrZWQgYXNcbiAgICogYSBkeW5hbWljIGFjY2Vzcy5cbiAgICovXG4gIHJlYWRvbmx5IGZhbGxiYWNrUm91dGVQYXJhbXM6IEZhbGxiYWNrUm91dGVQYXJhbXMgfCBudWxsXG5cbiAgcmVhZG9ubHkgaW5jcmVtZW50YWxDYWNoZT86IEluY3JlbWVudGFsQ2FjaGVcbiAgcmVhZG9ubHkgY2FjaGVMaWZlUHJvZmlsZXM/OiB7IFtwcm9maWxlOiBzdHJpbmddOiBDYWNoZUxpZmUgfVxuXG4gIHJlYWRvbmx5IGlzT25EZW1hbmRSZXZhbGlkYXRlPzogYm9vbGVhblxuICByZWFkb25seSBpc0J1aWxkVGltZVByZXJlbmRlcmluZz86IGJvb2xlYW5cblxuICAvKipcbiAgICogVGhpcyBpcyB0cnVlIHdoZW46XG4gICAqIC0gc291cmNlIG1hcHMgYXJlIGdlbmVyYXRlZFxuICAgKiAtIHNvdXJjZSBtYXBzIGFyZSBhcHBsaWVkXG4gICAqIC0gbWluaWZpY2F0aW9uIGlzIGRpc2FibGVkXG4gICAqL1xuICByZWFkb25seSBoYXNSZWFkYWJsZUVycm9yU3RhY2tzPzogYm9vbGVhblxuXG4gIHJlYWRvbmx5IGlzUmV2YWxpZGF0ZT86IGJvb2xlYW5cblxuICBmb3JjZUR5bmFtaWM/OiBib29sZWFuXG4gIGZldGNoQ2FjaGU/OiBBcHBTZWdtZW50Q29uZmlnWydmZXRjaENhY2hlJ11cblxuICBmb3JjZVN0YXRpYz86IGJvb2xlYW5cbiAgZHluYW1pY1Nob3VsZEVycm9yPzogYm9vbGVhblxuICBwZW5kaW5nUmV2YWxpZGF0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBQcm9taXNlPGFueT4+XG4gIHBlbmRpbmdSZXZhbGlkYXRlV3JpdGVzPzogQXJyYXk8UHJvbWlzZTx2b2lkPj4gLy8gVGhpcyBpcyBsaWtlIHBlbmRpbmdSZXZhbGlkYXRlcyBidXQgaXNuJ3QgdXNlZCBmb3IgZGVkdXBpbmcuXG4gIHJlYWRvbmx5IGFmdGVyQ29udGV4dDogQWZ0ZXJDb250ZXh0XG5cbiAgZHluYW1pY1VzYWdlRGVzY3JpcHRpb24/OiBzdHJpbmdcbiAgZHluYW1pY1VzYWdlU3RhY2s/OiBzdHJpbmdcblxuICAvKipcbiAgICogSW52YWxpZCBkeW5hbWljIHVzYWdlIGVycm9ycyBtaWdodCBiZSBjYXVnaHQgaW4gdXNlcmxhbmQuIFdlIGF0dGFjaCB0aGVtIHRvXG4gICAqIHRoZSB3b3JrIHN0b3JlIHRvIGVuc3VyZSB3ZSBjYW4gc3RpbGwgZmFpbCB0aGUgYnVpbGQsIG9yIHNob3cgZW4gZXJyb3IgaW5cbiAgICogZGV2IG1vZGUuXG4gICAqL1xuICAvLyBUT0RPOiBDb2xsZWN0IGFuIGFycmF5IG9mIGVycm9ycywgYW5kIHRocm93IGFzIEFnZ3JlZ2F0ZUVycm9yIHdoZW5cbiAgLy8gYHNlcmlhbGl6ZUVycm9yYCBhbmQgdGhlIERldiBPdmVybGF5IHN1cHBvcnQgaXQuXG4gIGludmFsaWREeW5hbWljVXNhZ2VFcnJvcj86IEVycm9yXG5cbiAgbmV4dEZldGNoSWQ/OiBudW1iZXJcbiAgcGF0aFdhc1JldmFsaWRhdGVkPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBUYWdzIHRoYXQgd2VyZSByZXZhbGlkYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgcmVxdWVzdC4gVGhleSBuZWVkIHRvIGJlIHNlbnRcbiAgICogdG8gY2FjaGUgaGFuZGxlcnMgdG8gcHJvcGFnYXRlIHRoZWlyIHJldmFsaWRhdGlvbi5cbiAgICovXG4gIHBlbmRpbmdSZXZhbGlkYXRlZFRhZ3M/OiBzdHJpbmdbXVxuXG4gIC8qKlxuICAgKiBUYWdzIHRoYXQgd2VyZSBwcmV2aW91c2x5IHJldmFsaWRhdGVkIChlLmcuIGJ5IGEgcmVkaXJlY3Rpbmcgc2VydmVyIGFjdGlvbilcbiAgICogYW5kIGhhdmUgYWxyZWFkeSBiZWVuIHNlbnQgdG8gY2FjaGUgaGFuZGxlcnMuIFJldHJpZXZlZCBjYWNoZSBlbnRyaWVzIHRoYXRcbiAgICogaW5jbHVkZSBhbnkgb2YgdGhlc2UgdGFncyBtdXN0IGJlIGRpc2NhcmRlZC5cbiAgICovXG4gIHJlYWRvbmx5IHByZXZpb3VzbHlSZXZhbGlkYXRlZFRhZ3M6IHJlYWRvbmx5IHN0cmluZ1tdXG5cbiAgLyoqXG4gICAqIFRoaXMgbWFwIGNvbnRhaW5zIGxhenkgcmVzdWx0cyBzbyB0aGF0IHdlIGNhbiBldmFsdWF0ZSB0aGVtIHdoZW4gdGhlIGZpcnN0XG4gICAqIGNhY2hlIGVudHJ5IGlzIHJlYWQuIEl0IGFsbG93cyB1cyB0byBza2lwIHJlZnJlc2hpbmcgdGFncyBpZiBubyBjYWNoZXMgYXJlXG4gICAqIHJlYWQgYXQgYWxsLlxuICAgKi9cbiAgcmVhZG9ubHkgcmVmcmVzaFRhZ3NCeUNhY2hlS2luZDogTWFwPHN0cmluZywgTGF6eVJlc3VsdDx2b2lkPj5cblxuICBmZXRjaE1ldHJpY3M/OiBGZXRjaE1ldHJpY3NcblxuICBpc0RyYWZ0TW9kZT86IGJvb2xlYW5cbiAgaXNVbnN0YWJsZU5vU3RvcmU/OiBib29sZWFuXG4gIGlzUHJlZmV0Y2hSZXF1ZXN0PzogYm9vbGVhblxuXG4gIHJlcXVlc3RFbmRlZFN0YXRlPzogeyBlbmRlZD86IGJvb2xlYW4gfVxuXG4gIGJ1aWxkSWQ6IHN0cmluZ1xuXG4gIHJlYWRvbmx5IHJlYWN0TG9hZGFibGVNYW5pZmVzdD86IERlZXBSZWFkb25seTxcbiAgICBSZWNvcmQ8c3RyaW5nLCB7IGZpbGVzOiBzdHJpbmdbXSB9PlxuICA+XG4gIHJlYWRvbmx5IGFzc2V0UHJlZml4Pzogc3RyaW5nXG5cbiAgZHluYW1pY0lPRW5hYmxlZDogYm9vbGVhblxuICBkZXY6IGJvb2xlYW5cblxuICAvKipcbiAgICogUnVuIHRoZSBnaXZlbiBmdW5jdGlvbiBpbnNpZGUgYSBjbGVhbiBBc3luY0xvY2FsU3RvcmFnZSBzbmFwc2hvdC4gVGhpcyBpc1xuICAgKiB1c2VmdWwgd2hlbiBnZW5lcmF0aW5nIGNhY2hlIGVudHJpZXMsIHRvIGVuc3VyZSB0aGF0IHRoZSBjYWNoZSBnZW5lcmF0aW9uXG4gICAqIGNhbm5vdCByZWFkIGFueXRoaW5nIGZyb20gdGhlIGNvbnRleHQgd2UncmUgY3VycmVudGx5IGV4ZWN1dGluZyBpbiwgd2hpY2hcbiAgICogbWlnaHQgaW5jbHVkZSByZXF1ZXN0LXNwZWNpZmljIHRoaW5ncyBsaWtlIGBjb29raWVzKClgIGluc2lkZSBhXG4gICAqIGBSZWFjdC5jYWNoZSgpYC5cbiAgICovXG4gIHJ1bkluQ2xlYW5TbmFwc2hvdDogPFIsIFRBcmdzIGV4dGVuZHMgYW55W10+KFxuICAgIGZuOiAoLi4uYXJnczogVEFyZ3MpID0+IFIsXG4gICAgLi4uYXJnczogVEFyZ3NcbiAgKSA9PiBSXG59XG5cbmV4cG9ydCB0eXBlIFdvcmtBc3luY1N0b3JhZ2UgPSBBc3luY0xvY2FsU3RvcmFnZTxXb3JrU3RvcmU+XG5cbmV4cG9ydCB7IHdvcmtBc3luY1N0b3JhZ2VJbnN0YW5jZSBhcyB3b3JrQXN5bmNTdG9yYWdlIH1cbiJdLCJuYW1lcyI6WyJ3b3JrQXN5bmNTdG9yYWdlIiwid29ya0FzeW5jU3RvcmFnZUluc3RhbmNlIl0sIm1hcHBpbmdzIjoiOzs7K0JBOEhxQ0Esb0JBQUFBOzs7ZUFBNUJDLDBCQUFBQSx3QkFBd0I7OzswQ0FwSFEiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMjkwMywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvYXBwLXJlbmRlci9hY3Rpb24tYXN5bmMtc3RvcmFnZS1pbnN0YW5jZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEFjdGlvbkFzeW5jU3RvcmFnZSB9IGZyb20gJy4vYWN0aW9uLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQgeyBjcmVhdGVBc3luY0xvY2FsU3RvcmFnZSB9IGZyb20gJy4vYXN5bmMtbG9jYWwtc3RvcmFnZSdcblxuZXhwb3J0IGNvbnN0IGFjdGlvbkFzeW5jU3RvcmFnZUluc3RhbmNlOiBBY3Rpb25Bc3luY1N0b3JhZ2UgPVxuICBjcmVhdGVBc3luY0xvY2FsU3RvcmFnZSgpXG4iXSwibmFtZXMiOlsiYWN0aW9uQXN5bmNTdG9yYWdlSW5zdGFuY2UiLCJjcmVhdGVBc3luY0xvY2FsU3RvcmFnZSJdLCJtYXBwaW5ncyI6Ijs7OytCQUdhQSw4QkFBQUE7OztlQUFBQTs7O21DQUYyQjtBQUVqQyxNQUFNQSw2QkFDWEMsQ0FBQUEsR0FBQUEsbUJBQUFBLHVCQUF1QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyOTIwLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NlcnZlci9hcHAtcmVuZGVyL2FjdGlvbi1hc3luYy1zdG9yYWdlLmV4dGVybmFsLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQXN5bmNMb2NhbFN0b3JhZ2UgfSBmcm9tICdhc3luY19ob29rcydcblxuLy8gU2hhcmUgdGhlIGluc3RhbmNlIG1vZHVsZSBpbiB0aGUgbmV4dC1zaGFyZWQgbGF5ZXJcbmltcG9ydCB7IGFjdGlvbkFzeW5jU3RvcmFnZUluc3RhbmNlIH0gZnJvbSAnLi9hY3Rpb24tYXN5bmMtc3RvcmFnZS1pbnN0YW5jZScgd2l0aCB7ICd0dXJib3BhY2stdHJhbnNpdGlvbic6ICduZXh0LXNoYXJlZCcgfVxuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25TdG9yZSB7XG4gIHJlYWRvbmx5IGlzQWN0aW9uPzogYm9vbGVhblxuICByZWFkb25seSBpc0FwcFJvdXRlPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBBY3Rpb25Bc3luY1N0b3JhZ2UgPSBBc3luY0xvY2FsU3RvcmFnZTxBY3Rpb25TdG9yZT5cblxuZXhwb3J0IHsgYWN0aW9uQXN5bmNTdG9yYWdlSW5zdGFuY2UgYXMgYWN0aW9uQXN5bmNTdG9yYWdlIH1cbiJdLCJuYW1lcyI6WyJhY3Rpb25Bc3luY1N0b3JhZ2UiLCJhY3Rpb25Bc3luY1N0b3JhZ2VJbnN0YW5jZSJdLCJtYXBwaW5ncyI6Ijs7OytCQVd1Q0Esc0JBQUFBOzs7ZUFBOUJDLDRCQUFBQSwwQkFBMEI7Ozs0Q0FSUSIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAyOTM2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NlcnZlci9keW5hbWljLXJlbmRlcmluZy11dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNIYW5naW5nUHJvbWlzZVJlamVjdGlvbkVycm9yKFxuICBlcnI6IHVua25vd25cbik6IGVyciBpcyBIYW5naW5nUHJvbWlzZVJlamVjdGlvbkVycm9yIHtcbiAgaWYgKHR5cGVvZiBlcnIgIT09ICdvYmplY3QnIHx8IGVyciA9PT0gbnVsbCB8fCAhKCdkaWdlc3QnIGluIGVycikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBlcnIuZGlnZXN0ID09PSBIQU5HSU5HX1BST01JU0VfUkVKRUNUSU9OXG59XG5cbmNvbnN0IEhBTkdJTkdfUFJPTUlTRV9SRUpFQ1RJT04gPSAnSEFOR0lOR19QUk9NSVNFX1JFSkVDVElPTidcblxuY2xhc3MgSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHVibGljIHJlYWRvbmx5IGRpZ2VzdCA9IEhBTkdJTkdfUFJPTUlTRV9SRUpFQ1RJT05cblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgZXhwcmVzc2lvbjogc3RyaW5nKSB7XG4gICAgc3VwZXIoXG4gICAgICBgRHVyaW5nIHByZXJlbmRlcmluZywgJHtleHByZXNzaW9ufSByZWplY3RzIHdoZW4gdGhlIHByZXJlbmRlciBpcyBjb21wbGV0ZS4gVHlwaWNhbGx5IHRoZXNlIGVycm9ycyBhcmUgaGFuZGxlZCBieSBSZWFjdCBidXQgaWYgeW91IG1vdmUgJHtleHByZXNzaW9ufSB0byBhIGRpZmZlcmVudCBjb250ZXh0IGJ5IHVzaW5nIFxcYHNldFRpbWVvdXRcXGAsIFxcYGFmdGVyXFxgLCBvciBzaW1pbGFyIGZ1bmN0aW9ucyB5b3UgbWF5IG9ic2VydmUgdGhpcyBlcnJvciBhbmQgeW91IHNob3VsZCBoYW5kbGUgaXQgaW4gdGhhdCBjb250ZXh0LmBcbiAgICApXG4gIH1cbn1cblxudHlwZSBBYm9ydExpc3RlbmVycyA9IEFycmF5PChlcnI6IHVua25vd24pID0+IHZvaWQ+XG5jb25zdCBhYm9ydExpc3RlbmVyc0J5U2lnbmFsID0gbmV3IFdlYWtNYXA8QWJvcnRTaWduYWwsIEFib3J0TGlzdGVuZXJzPigpXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjb25zdHJ1Y3RzIGEgcHJvbWlzZSB0aGF0IHdpbGwgbmV2ZXIgcmVzb2x2ZS4gVGhpcyBpcyBwcmltYXJpbHlcbiAqIHVzZWZ1bCBmb3IgZHluYW1pY0lPIHdoZXJlIHdlIHVzZSBwcm9taXNlIHJlc29sdXRpb24gdGltaW5nIHRvIGRldGVybWluZSB3aGljaFxuICogcGFydHMgb2YgYSByZW5kZXIgY2FuIGJlIGluY2x1ZGVkIGluIGEgcHJlcmVuZGVyLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUhhbmdpbmdQcm9taXNlPFQ+KFxuICBzaWduYWw6IEFib3J0U2lnbmFsLFxuICBleHByZXNzaW9uOiBzdHJpbmdcbik6IFByb21pc2U8VD4ge1xuICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEhhbmdpbmdQcm9taXNlUmVqZWN0aW9uRXJyb3IoZXhwcmVzc2lvbikpXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaGFuZ2luZ1Byb21pc2UgPSBuZXcgUHJvbWlzZTxUPigoXywgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBib3VuZFJlamVjdGlvbiA9IHJlamVjdC5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBuZXcgSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvcihleHByZXNzaW9uKVxuICAgICAgKVxuICAgICAgbGV0IGN1cnJlbnRMaXN0ZW5lcnMgPSBhYm9ydExpc3RlbmVyc0J5U2lnbmFsLmdldChzaWduYWwpXG4gICAgICBpZiAoY3VycmVudExpc3RlbmVycykge1xuICAgICAgICBjdXJyZW50TGlzdGVuZXJzLnB1c2goYm91bmRSZWplY3Rpb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBbYm91bmRSZWplY3Rpb25dXG4gICAgICAgIGFib3J0TGlzdGVuZXJzQnlTaWduYWwuc2V0KHNpZ25hbCwgbGlzdGVuZXJzKVxuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAnYWJvcnQnLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGxpc3RlbmVyc1tpXSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG9uY2U6IHRydWUgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgfSlcbiAgICAvLyBXZSBhcmUgZmluZSBpZiBubyBvbmUgYWN0dWFsbHkgYXdhaXRzIHRoaXMgcHJvbWlzZS4gV2Ugc2hvdWxkbid0IGNvbnNpZGVyIHRoaXMgYW4gdW5oYW5kbGVkIHJlamVjdGlvbiBzb1xuICAgIC8vIHdlIGF0dGFjaCBhIG5vb3AgY2F0Y2ggaGFuZGxlciBoZXJlIHRvIHN1cHByZXNzIHRoaXMgd2FybmluZy4gSWYgeW91IGFjdHVhbGx5IGF3YWl0IHNvbWV3aGVyZSBvciBjb25zdHJ1Y3RcbiAgICAvLyB5b3VyIG93biBwcm9taXNlIG91dCBvZiBpdCB5b3UnbGwgbmVlZCB0byBlbnN1cmUgeW91IGhhbmRsZSB0aGUgZXJyb3Igd2hlbiBpdCByZWplY3RzLlxuICAgIGhhbmdpbmdQcm9taXNlLmNhdGNoKGlnbm9yZVJlamVjdClcbiAgICByZXR1cm4gaGFuZ2luZ1Byb21pc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBpZ25vcmVSZWplY3QoKSB7fVxuIl0sIm5hbWVzIjpbImlzSGFuZ2luZ1Byb21pc2VSZWplY3Rpb25FcnJvciIsIm1ha2VIYW5naW5nUHJvbWlzZSIsImVyciIsImRpZ2VzdCIsIkhBTkdJTkdfUFJPTUlTRV9SRUpFQ1RJT04iLCJIYW5naW5nUHJvbWlzZVJlamVjdGlvbkVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImV4cHJlc3Npb24iLCJhYm9ydExpc3RlbmVyc0J5U2lnbmFsIiwiV2Vha01hcCIsInNpZ25hbCIsImFib3J0ZWQiLCJQcm9taXNlIiwicmVqZWN0IiwiaGFuZ2luZ1Byb21pc2UiLCJfIiwiYm91bmRSZWplY3Rpb24iLCJiaW5kIiwiY3VycmVudExpc3RlbmVycyIsImdldCIsInB1c2giLCJsaXN0ZW5lcnMiLCJzZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiaSIsImxlbmd0aCIsIm9uY2UiLCJjYXRjaCIsImlnbm9yZVJlamVjdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7SUFBZ0JBLDhCQUE4QixFQUFBO2VBQTlCQTs7SUFnQ0FDLGtCQUFrQixFQUFBO2VBQWxCQTs7O0FBaENULFNBQVNELCtCQUNkRSxHQUFZO0lBRVosSUFBSSxPQUFPQSxRQUFRLFlBQVlBLFFBQVEsUUFBUSxDQUFFLENBQUEsWUFBWUEsR0FBRSxHQUFJO1FBQ2pFLE9BQU87SUFDVDtJQUVBLE9BQU9BLElBQUlDLE1BQU0sS0FBS0M7QUFDeEI7QUFFQSxNQUFNQSw0QkFBNEI7QUFFbEMsTUFBTUMscUNBQXFDQztJQUd6Q0MsWUFBNEJDLFVBQWtCLENBQUU7UUFDOUMsS0FBSyxDQUNILEFBQUMscUJBQXFCLFVBQUVBLFlBQVcscUdBQXFHLFdBQUVBLFlBQVcscUpBQXFKLENBQUMsQ0FBQSxJQUFBLENBRm5SQSxVQUFBQSxHQUFBQSxZQUFBQSxJQUFBQSxDQUZaTCxNQUFBQSxHQUFTQztJQU16QjtBQUNGO0FBR0EsTUFBTUsseUJBQXlCLElBQUlDO0FBUzVCLFNBQVNULG1CQUNkVSxNQUFtQixFQUNuQkgsVUFBa0I7SUFFbEIsSUFBSUcsT0FBT0MsT0FBTyxFQUFFO1FBQ2xCLE9BQU9DLFFBQVFDLE1BQU0sQ0FBQyxJQUFJVCw2QkFBNkJHO0lBQ3pELE9BQU87UUFDTCxNQUFNTyxpQkFBaUIsSUFBSUYsUUFBVyxDQUFDRyxHQUFHRjtZQUN4QyxNQUFNRyxpQkFBaUJILE9BQU9JLElBQUksQ0FDaEMsTUFDQSxJQUFJYiw2QkFBNkJHO1lBRW5DLElBQUlXLG1CQUFtQlYsdUJBQXVCVyxHQUFHLENBQUNUO1lBQ2xELElBQUlRLGtCQUFrQjtnQkFDcEJBLGlCQUFpQkUsSUFBSSxDQUFDSjtZQUN4QixPQUFPO2dCQUNMLE1BQU1LLFlBQVk7b0JBQUNMO2lCQUFlO2dCQUNsQ1IsdUJBQXVCYyxHQUFHLENBQUNaLFFBQVFXO2dCQUNuQ1gsT0FBT2EsZ0JBQWdCLENBQ3JCLFNBQ0E7b0JBQ0UsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILFVBQVVJLE1BQU0sRUFBRUQsSUFBSzt3QkFDekNILFNBQVMsQ0FBQ0csRUFBRTtvQkFDZDtnQkFDRixHQUNBO29CQUFFRSxNQUFNO2dCQUFLO1lBRWpCO1FBQ0Y7UUFDQSwyR0FBMkc7UUFDM0csNkdBQTZHO1FBQzdHLHlGQUF5RjtRQUN6RlosZUFBZWEsS0FBSyxDQUFDQztRQUNyQixPQUFPZDtJQUNUO0FBQ0Y7QUFFQSxTQUFTYyxnQkFBZ0IiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzAwNywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvbGliL3JvdXRlci11dGlscy9pcy1wb3N0cG9uZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBSRUFDVF9QT1NUUE9ORV9UWVBFOiBzeW1ib2wgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3N0cG9uZScpXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Bvc3Rwb25lKGVycm9yOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmXG4gICAgZXJyb3IgIT09IG51bGwgJiZcbiAgICBlcnJvci4kJHR5cGVvZiA9PT0gUkVBQ1RfUE9TVFBPTkVfVFlQRVxuICApXG59XG4iXSwibmFtZXMiOlsiaXNQb3N0cG9uZSIsIlJFQUNUX1BPU1RQT05FX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJlcnJvciIsIiQkdHlwZW9mIl0sIm1hcHBpbmdzIjoiOzs7K0JBRWdCQSxjQUFBQTs7O2VBQUFBOzs7QUFGaEIsTUFBTUMsc0JBQThCQyxPQUFPQyxHQUFHLENBQUM7QUFFeEMsU0FBU0gsV0FBV0ksS0FBVTtJQUNuQyxPQUNFLE9BQU9BLFVBQVUsWUFDakJBLFVBQVUsUUFDVkEsTUFBTUMsUUFBUSxLQUFLSjtBQUV2QiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzMDI2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NlcnZlci9hcHAtcmVuZGVyL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLWluc3RhbmNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUFzeW5jTG9jYWxTdG9yYWdlIH0gZnJvbSAnLi9hc3luYy1sb2NhbC1zdG9yYWdlJ1xuaW1wb3J0IHR5cGUgeyBXb3JrVW5pdEFzeW5jU3RvcmFnZSB9IGZyb20gJy4vd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5cbmV4cG9ydCBjb25zdCB3b3JrVW5pdEFzeW5jU3RvcmFnZUluc3RhbmNlOiBXb3JrVW5pdEFzeW5jU3RvcmFnZSA9XG4gIGNyZWF0ZUFzeW5jTG9jYWxTdG9yYWdlKClcbiJdLCJuYW1lcyI6WyJ3b3JrVW5pdEFzeW5jU3RvcmFnZUluc3RhbmNlIiwiY3JlYXRlQXN5bmNMb2NhbFN0b3JhZ2UiXSwibWFwcGluZ3MiOiI7OzsrQkFHYUEsZ0NBQUFBOzs7ZUFBQUE7OzttQ0FIMkI7QUFHakMsTUFBTUEsK0JBQ1hDLENBQUFBLEdBQUFBLG1CQUFBQSx1QkFBdUIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMzA0MywgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L3NyYy9zZXJ2ZXIvYXBwLXJlbmRlci93b3JrLXVuaXQtYXN5bmMtc3RvcmFnZS5leHRlcm5hbC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEFzeW5jTG9jYWxTdG9yYWdlIH0gZnJvbSAnYXN5bmNfaG9va3MnXG5pbXBvcnQgdHlwZSB7IERyYWZ0TW9kZVByb3ZpZGVyIH0gZnJvbSAnLi4vYXN5bmMtc3RvcmFnZS9kcmFmdC1tb2RlLXByb3ZpZGVyJ1xuaW1wb3J0IHR5cGUgeyBSZXNwb25zZUNvb2tpZXMgfSBmcm9tICcuLi93ZWIvc3BlYy1leHRlbnNpb24vY29va2llcydcbmltcG9ydCB0eXBlIHsgUmVhZG9ubHlIZWFkZXJzIH0gZnJvbSAnLi4vd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL2hlYWRlcnMnXG5pbXBvcnQgdHlwZSB7IFJlYWRvbmx5UmVxdWVzdENvb2tpZXMgfSBmcm9tICcuLi93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvcmVxdWVzdC1jb29raWVzJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZVNpZ25hbCB9IGZyb20gJy4vY2FjaGUtc2lnbmFsJ1xuaW1wb3J0IHR5cGUgeyBEeW5hbWljVHJhY2tpbmdTdGF0ZSB9IGZyb20gJy4vZHluYW1pYy1yZW5kZXJpbmcnXG5cbi8vIFNoYXJlIHRoZSBpbnN0YW5jZSBtb2R1bGUgaW4gdGhlIG5leHQtc2hhcmVkIGxheWVyXG5pbXBvcnQgeyB3b3JrVW5pdEFzeW5jU3RvcmFnZUluc3RhbmNlIH0gZnJvbSAnLi93b3JrLXVuaXQtYXN5bmMtc3RvcmFnZS1pbnN0YW5jZScgd2l0aCB7ICd0dXJib3BhY2stdHJhbnNpdGlvbic6ICduZXh0LXNoYXJlZCcgfVxuaW1wb3J0IHR5cGUgeyBTZXJ2ZXJDb21wb25lbnRzSG1yQ2FjaGUgfSBmcm9tICcuLi9yZXNwb25zZS1jYWNoZSdcbmltcG9ydCB0eXBlIHtcbiAgUmVuZGVyUmVzdW1lRGF0YUNhY2hlLFxuICBQcmVyZW5kZXJSZXN1bWVEYXRhQ2FjaGUsXG59IGZyb20gJy4uL3Jlc3VtZS1kYXRhLWNhY2hlL3Jlc3VtZS1kYXRhLWNhY2hlJ1xuaW1wb3J0IHR5cGUgeyBQYXJhbXMgfSBmcm9tICcuLi9yZXF1ZXN0L3BhcmFtcydcbmltcG9ydCB0eXBlIHsgSW1wbGljaXRUYWdzIH0gZnJvbSAnLi4vbGliL2ltcGxpY2l0LXRhZ3MnXG5pbXBvcnQgdHlwZSB7IFdvcmtTdG9yZSB9IGZyb20gJy4vd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHsgTkVYVF9ITVJfUkVGUkVTSF9IQVNIX0NPT0tJRSB9IGZyb20gJy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXItaGVhZGVycydcblxuZXhwb3J0IHR5cGUgV29ya1VuaXRQaGFzZSA9ICdhY3Rpb24nIHwgJ3JlbmRlcicgfCAnYWZ0ZXInXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tbW9uV29ya1VuaXRTdG9yZSB7XG4gIC8qKiBOT1RFOiBXaWxsIGJlIG11dGF0ZWQgYXMgcGhhc2VzIGNoYW5nZSAqL1xuICBwaGFzZTogV29ya1VuaXRQaGFzZVxuICByZWFkb25seSBpbXBsaWNpdFRhZ3M6IEltcGxpY2l0VGFnc1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlcXVlc3RTdG9yZSBleHRlbmRzIENvbW1vbldvcmtVbml0U3RvcmUge1xuICB0eXBlOiAncmVxdWVzdCdcblxuICAvKipcbiAgICogVGhlIFVSTCBvZiB0aGUgcmVxdWVzdC4gVGhpcyBvbmx5IHNwZWNpZmllcyB0aGUgcGF0aG5hbWUgYW5kIHRoZSBzZWFyY2hcbiAgICogcGFydCBvZiB0aGUgVVJMLlxuICAgKi9cbiAgcmVhZG9ubHkgdXJsOiB7XG4gICAgLyoqXG4gICAgICogVGhlIHBhdGhuYW1lIG9mIHRoZSByZXF1ZXN0ZWQgVVJMLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHBhdGhuYW1lOiBzdHJpbmdcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWFyY2ggcGFydCBvZiB0aGUgcmVxdWVzdGVkIFVSTC4gSWYgdGhlIHJlcXVlc3QgZGlkIG5vdCBwcm92aWRlIGFcbiAgICAgKiBzZWFyY2ggcGFydCwgdGhpcyB3aWxsIGJlIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKi9cbiAgICByZWFkb25seSBzZWFyY2g6IHN0cmluZ1xuICB9XG5cbiAgcmVhZG9ubHkgaGVhZGVyczogUmVhZG9ubHlIZWFkZXJzXG4gIC8vIFRoaXMgaXMgbXV0YWJsZSBiZWNhdXNlIHdlIG5lZWQgdG8gcmVhc3NpZ24gaXQgd2hlbiB0cmFuc2l0aW9uaW5nIGZyb20gdGhlIGFjdGlvbiBwaGFzZSB0byB0aGUgcmVuZGVyIHBoYXNlLlxuICAvLyBUaGUgY29va2llIG9iamVjdCBpdHNlbGYgaXMgZGVsaWJlcmF0ZWx5IHJlYWQgb25seSBhbmQgdGh1cyBjYW4ndCBiZSB1cGRhdGVkLlxuICBjb29raWVzOiBSZWFkb25seVJlcXVlc3RDb29raWVzXG4gIHJlYWRvbmx5IG11dGFibGVDb29raWVzOiBSZXNwb25zZUNvb2tpZXNcbiAgcmVhZG9ubHkgdXNlcnNwYWNlTXV0YWJsZUNvb2tpZXM6IFJlc3BvbnNlQ29va2llc1xuICByZWFkb25seSBkcmFmdE1vZGU6IERyYWZ0TW9kZVByb3ZpZGVyXG4gIHJlYWRvbmx5IGlzSG1yUmVmcmVzaD86IGJvb2xlYW5cbiAgcmVhZG9ubHkgc2VydmVyQ29tcG9uZW50c0htckNhY2hlPzogU2VydmVyQ29tcG9uZW50c0htckNhY2hlXG5cbiAgcmVhZG9ubHkgcm9vdFBhcmFtczogUGFyYW1zXG5cbiAgLyoqXG4gICAqIFRoZSByZXN1bWUgZGF0YSBjYWNoZSBmb3IgdGhpcyByZXF1ZXN0LiBUaGlzIHdpbGwgYmUgYSBpbW11dGFibGUgY2FjaGUuXG4gICAqL1xuICByZW5kZXJSZXN1bWVEYXRhQ2FjaGU6IFJlbmRlclJlc3VtZURhdGFDYWNoZSB8IG51bGxcblxuICAvLyBERVYtb25seVxuICB1c2VkRHluYW1pYz86IGJvb2xlYW5cbiAgcHJlcmVuZGVyUGhhc2U/OiBib29sZWFuXG59XG5cbi8qKlxuICogVGhlIFByZXJlbmRlciBzdG9yZSBpcyBmb3IgdHJhY2tpbmcgaW5mb3JtYXRpb24gcmVsYXRlZCB0byBwcmVyZW5kZXJzLlxuICpcbiAqIEl0IGNhbiBiZSB1c2VkIGZvciBib3RoIFJTQyBhbmQgU1NSIHByZXJlbmRlcmluZyBhbmQgc2hvdWxkIGJlIHNjb3BlZCBhcyBjbG9zZVxuICogdG8gdGhlIGluZGl2aWR1YWwgYHJlbmRlclRvLi4uYCBBUEkgY2FsbCBhcyBwb3NzaWJsZS4gVG8ga2VlcCB0aGUgdHlwZSBzaW1wbGVcbiAqIHdlIGRvbid0IGRpc3Rpbmd1aXNoIGJldHdlZW4gUlNDIGFuZCBTU1IgcHJlcmVuZGVyaW5nIGV4cGxpY2l0bHkgYnV0IGluc3RlYWRcbiAqIHVzZSBjb25kaXRpb25hbCBvYmplY3QgcHJvcGVydGllcyB0byBpbmZlciB3aGljaCBtb2RlIHdlIGFyZSBpbi4gRm9yIGluc3RhbmNlIGNhY2hlIHRyYWNraW5nXG4gKiBvbmx5IG5lZWRzIHRvIGhhcHBlbiBkdXJpbmcgdGhlIFJTQyBwcmVyZW5kZXIgd2hlbiB3ZSBhcmUgcHJvc3BlY3RpdmVseSBwcmVyZW5kZXJpbmdcbiAqIHRvIGZpbGwgYWxsIGNhY2hlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcmVyZW5kZXJTdG9yZU1vZGVybiBleHRlbmRzIENvbW1vbldvcmtVbml0U3RvcmUge1xuICAvLyBJbiB0aGUgZnV0dXJlIHRoZSBwcmVyZW5kZXItY2xpZW50IHZhcmlhbnQgd2lsbCBnZXQgaXQncyBvd24gdHlwZS5cbiAgLy8gcHJlcmVuZGVyIHJlcHJlc2VudHMgdGhlIFJTQyBzY29wZSBvZiB0aGUgcHJlcmVuZGVyLlxuICAvLyBwcmVyZW5kZXItY2xpZW50IHJlcHJlc2VudHMgdGhlIEhUTUwgc2NvcGUgb2YgdGhlIHByZXJlbmRlci5cbiAgdHlwZTogJ3ByZXJlbmRlcicgfCAncHJlcmVuZGVyLWNsaWVudCdcblxuICAvKipcbiAgICogVGhpcyBzaWduYWwgaXMgYWJvcnRlZCB3aGVuIHRoZSBSZWFjdCByZW5kZXIgaXMgY29tcGxldGUuIChpLmUuIGl0IGlzIHRoZSBzYW1lIHNpZ25hbCBwYXNzZWQgdG8gcmVhY3QpXG4gICAqL1xuICByZWFkb25seSByZW5kZXJTaWduYWw6IEFib3J0U2lnbmFsXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBBYm9ydENvbnRyb2xsZXIgd2hpY2ggcmVwcmVzZW50cyB0aGUgYm91bmRhcnkgYmV0d2VlbiBQcmVyZW5kZXIgYW5kIGR5bmFtaWMuIEluIHNvbWUgcmVuZGVycyBpdCBpc1xuICAgKiB0aGUgc2FtZSBhcyB0aGUgY29udHJvbGxlciBmb3IgdGhlIHJlbmRlclNpZ25hbCBidXQgaW4gb3RoZXJzIGl0IGlzIGEgc2VwYXJhdGUgY29udHJvbGxlci4gSXQgc2hvdWxkIGJlIGFib3J0ZWRcbiAgICogd2hlbmV2ZXIgdGhlIHdlIGFyZSBubyBsb25nZXIgaW4gdGhlIHByZXJlbmRlciBwaGFzZSBvZiByZW5kZXJpbmcuIFR5cGljYWxseSB0aGlzIGlzIGFmdGVyIG9uZSB0YXNrIG9yIHdoZW4geW91IGNhbGxcbiAgICogYSBzeW5jIEFQSSB3aGljaCByZXF1aXJlcyB0aGUgcHJlcmVuZGVyIHRvIGVuZCBpbW1lZGlhdGVseVxuICAgKi9cbiAgcmVhZG9ubHkgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyXG5cbiAgLyoqXG4gICAqIHdoZW4gbm90IG51bGwgdGhpcyBzaWduYWwgaXMgdXNlZCB0byB0cmFjayBjYWNoZSByZWFkcyBkdXJpbmcgcHJlcmVuZGVyaW5nIGFuZFxuICAgKiB0byBhd2FpdCBhbGwgY2FjaGUgcmVhZHMgY29tcGxldGluZyBiZWZvcmUgYWJvcnRpbmcgdGhlIHByZXJlbmRlci5cbiAgICovXG4gIHJlYWRvbmx5IGNhY2hlU2lnbmFsOiBudWxsIHwgQ2FjaGVTaWduYWxcblxuICAvKipcbiAgICogRHVyaW5nIHNvbWUgcHJlcmVuZGVycyB3ZSB3YW50IHRvIHRyYWNrIGR5bmFtaWMgYWNjZXNzLlxuICAgKi9cbiAgcmVhZG9ubHkgZHluYW1pY1RyYWNraW5nOiBudWxsIHwgRHluYW1pY1RyYWNraW5nU3RhdGVcblxuICByZWFkb25seSByb290UGFyYW1zOiBQYXJhbXNcblxuICAvKipcbiAgICogV2hlbiB0cnVlLCB0aGUgcGFnZSBpcyBwcmVyZW5kZXJlZCBhcyBhIGZhbGxiYWNrIHNoZWxsLCB3aGlsZSBhbGxvd2luZyBhbnlcbiAgICogZHluYW1pYyBhY2Nlc3NlcyB0byByZXN1bHQgaW4gYW4gZW1wdHkgc2hlbGwuIFRoaXMgaXMgdGhlIGNhc2Ugd2hlbiB0aGVyZVxuICAgKiBhcmUgYWxzbyByb3V0ZXMgcHJlcmVuZGVyZWQgd2l0aCBhIG1vcmUgY29tcGxldGUgc2V0IG9mIHBhcmFtcy5cbiAgICogUHJlcmVuZGVyaW5nIHRob3NlIHJvdXRlcyB3b3VsZCBjYXRjaCBhbnkgaW52YWxpZCBkeW5hbWljIGFjY2Vzc2VzLlxuICAgKi9cbiAgcmVhZG9ubHkgYWxsb3dFbXB0eVN0YXRpY1NoZWxsOiBib29sZWFuXG5cbiAgLy8gQ29sbGVjdGVkIHJldmFsaWRhdGUgdGltZXMgYW5kIHRhZ3MgZm9yIHRoaXMgZG9jdW1lbnQgZHVyaW5nIHRoZSBwcmVyZW5kZXIuXG4gIHJldmFsaWRhdGU6IG51bWJlciAvLyBpbiBzZWNvbmRzLiAwIG1lYW5zIGR5bmFtaWMuIElORklOSVRFX0NBQ0hFIGFuZCBoaWdoZXIgbWVhbnMgbmV2ZXIgcmV2YWxpZGF0ZS5cbiAgZXhwaXJlOiBudW1iZXIgLy8gc2VydmVyIGV4cGlyYXRpb24gdGltZVxuICBzdGFsZTogbnVtYmVyIC8vIGNsaWVudCBleHBpcmF0aW9uIHRpbWVcbiAgdGFnczogbnVsbCB8IHN0cmluZ1tdXG5cbiAgLyoqXG4gICAqIEEgbXV0YWJsZSByZXN1bWUgZGF0YSBjYWNoZSBmb3IgdGhpcyBwcmVyZW5kZXIuXG4gICAqL1xuICBwcmVyZW5kZXJSZXN1bWVEYXRhQ2FjaGU6IFByZXJlbmRlclJlc3VtZURhdGFDYWNoZSB8IG51bGxcblxuICAvKipcbiAgICogQW4gaW1tdXRhYmxlIHJlc3VtZSBkYXRhIGNhY2hlIGZvciB0aGlzIHByZXJlbmRlci4gVGhpcyBtYXkgYmUgcHJvdmlkZWRcbiAgICogaW5zdGVhZCBvZiB0aGUgYHByZXJlbmRlclJlc3VtZURhdGFDYWNoZWAgaWYgdGhlIHByZXJlbmRlciBpcyBub3Qgc3VwcG9zZWRcbiAgICogdG8gZmlsbCBjYWNoZXMsIGFuZCBvbmx5IHJlYWQgZnJvbSBwcmVmaWxsZWQgY2FjaGVzLCBlLmcuIHdoZW4gcHJlcmVuZGVyaW5nXG4gICAqIGFuIG9wdGlvbmFsIGZhbGxiYWNrIHNoZWxsLlxuICAgKi9cbiAgcmVuZGVyUmVzdW1lRGF0YUNhY2hlOiBSZW5kZXJSZXN1bWVEYXRhQ2FjaGUgfCBudWxsXG5cbiAgLyoqXG4gICAqIFRoZSBITVIgcmVmcmVzaCBoYXNoIGlzIG9ubHkgcHJvdmlkZWQgaW4gZGV2IG1vZGUuIEl0IGlzIG5lZWRlZCBmb3IgdGhlIGRldlxuICAgKiB3YXJtdXAgcmVuZGVyIHRvIGVuc3VyZSB0aGF0IHRoZSBjYWNoZSBrZXlzIHdpbGwgYmUgaWRlbnRpY2FsIGZvciB0aGVcbiAgICogc3Vic2VxdWVudCBkeW5hbWljIHJlbmRlci5cbiAgICovXG4gIHJlYWRvbmx5IGhtclJlZnJlc2hIYXNoOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAvKipcbiAgICogT25seSBhdmFpbGFibGUgaW4gZGV2IG1vZGUuXG4gICAqL1xuICByZWFkb25seSBjYXB0dXJlT3duZXJTdGFjazogdW5kZWZpbmVkIHwgKCgpID0+IHN0cmluZyB8IG51bGwpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJlcmVuZGVyU3RvcmVQUFIgZXh0ZW5kcyBDb21tb25Xb3JrVW5pdFN0b3JlIHtcbiAgdHlwZTogJ3ByZXJlbmRlci1wcHInXG4gIHJlYWRvbmx5IHJvb3RQYXJhbXM6IFBhcmFtc1xuICByZWFkb25seSBkeW5hbWljVHJhY2tpbmc6IG51bGwgfCBEeW5hbWljVHJhY2tpbmdTdGF0ZVxuICAvLyBDb2xsZWN0ZWQgcmV2YWxpZGF0ZSB0aW1lcyBhbmQgdGFncyBmb3IgdGhpcyBkb2N1bWVudCBkdXJpbmcgdGhlIHByZXJlbmRlci5cbiAgcmV2YWxpZGF0ZTogbnVtYmVyIC8vIGluIHNlY29uZHMuIDAgbWVhbnMgZHluYW1pYy4gSU5GSU5JVEVfQ0FDSEUgYW5kIGhpZ2hlciBtZWFucyBuZXZlciByZXZhbGlkYXRlLlxuICBleHBpcmU6IG51bWJlciAvLyBzZXJ2ZXIgZXhwaXJhdGlvbiB0aW1lXG4gIHN0YWxlOiBudW1iZXIgLy8gY2xpZW50IGV4cGlyYXRpb24gdGltZVxuICB0YWdzOiBudWxsIHwgc3RyaW5nW11cblxuICAvKipcbiAgICogVGhlIHJlc3VtZSBkYXRhIGNhY2hlIGZvciB0aGlzIHByZXJlbmRlci5cbiAgICovXG4gIHByZXJlbmRlclJlc3VtZURhdGFDYWNoZTogUHJlcmVuZGVyUmVzdW1lRGF0YUNhY2hlXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJlcmVuZGVyU3RvcmVMZWdhY3kgZXh0ZW5kcyBDb21tb25Xb3JrVW5pdFN0b3JlIHtcbiAgdHlwZTogJ3ByZXJlbmRlci1sZWdhY3knXG4gIHJlYWRvbmx5IHJvb3RQYXJhbXM6IFBhcmFtc1xuICAvLyBDb2xsZWN0ZWQgcmV2YWxpZGF0ZSB0aW1lcyBhbmQgdGFncyBmb3IgdGhpcyBkb2N1bWVudCBkdXJpbmcgdGhlIHByZXJlbmRlci5cbiAgcmV2YWxpZGF0ZTogbnVtYmVyIC8vIGluIHNlY29uZHMuIDAgbWVhbnMgZHluYW1pYy4gSU5GSU5JVEVfQ0FDSEUgYW5kIGhpZ2hlciBtZWFucyBuZXZlciByZXZhbGlkYXRlLlxuICBleHBpcmU6IG51bWJlciAvLyBzZXJ2ZXIgZXhwaXJhdGlvbiB0aW1lXG4gIHN0YWxlOiBudW1iZXIgLy8gY2xpZW50IGV4cGlyYXRpb24gdGltZVxuICB0YWdzOiBudWxsIHwgc3RyaW5nW11cbn1cblxuZXhwb3J0IHR5cGUgUHJlcmVuZGVyU3RvcmUgPVxuICB8IFByZXJlbmRlclN0b3JlTGVnYWN5XG4gIHwgUHJlcmVuZGVyU3RvcmVQUFJcbiAgfCBQcmVyZW5kZXJTdG9yZU1vZGVyblxuXG5leHBvcnQgaW50ZXJmYWNlIENvbW1vbkNhY2hlU3RvcmVcbiAgZXh0ZW5kcyBPbWl0PENvbW1vbldvcmtVbml0U3RvcmUsICdpbXBsaWNpdFRhZ3MnPiB7XG4gIC8qKlxuICAgKiBBIGNhY2hlIHdvcmsgdW5pdCBzdG9yZSBtaWdodCBub3QgYWx3YXlzIGhhdmUgYW4gb3V0ZXIgd29yayB1bml0IHN0b3JlLFxuICAgKiBmcm9tIHdoaWNoIGltcGxpY2l0IHRhZ3MgY291bGQgYmUgaW5oZXJpdGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgaW1wbGljaXRUYWdzOiBJbXBsaWNpdFRhZ3MgfCB1bmRlZmluZWRcbiAgLyoqXG4gICAqIERyYWZ0IG1vZGUgaXMgb25seSBhdmFpbGFibGUgaWYgdGhlIG91dGVyIHdvcmsgdW5pdCBzdG9yZSBpcyBhIHJlcXVlc3RcbiAgICogc3RvcmUgYW5kIGRyYWZ0IG1vZGUgaXMgZW5hYmxlZC5cbiAgICovXG4gIHJlYWRvbmx5IGRyYWZ0TW9kZTogRHJhZnRNb2RlUHJvdmlkZXIgfCB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDYWNoZVN0b3JlIGV4dGVuZHMgQ29tbW9uQ2FjaGVTdG9yZSB7XG4gIHR5cGU6ICdjYWNoZSdcbiAgLy8gQ29sbGVjdGVkIHJldmFsaWRhdGUgdGltZXMgYW5kIHRhZ3MgZm9yIHRoaXMgY2FjaGUgZW50cnkgZHVyaW5nIHRoZSBjYWNoZSByZW5kZXIuXG4gIHJldmFsaWRhdGU6IG51bWJlciAvLyBpbXBsaWNpdCByZXZhbGlkYXRlIHRpbWUgZnJvbSBpbm5lciBjYWNoZXMgLyBmZXRjaGVzXG4gIGV4cGlyZTogbnVtYmVyIC8vIHNlcnZlciBleHBpcmF0aW9uIHRpbWVcbiAgc3RhbGU6IG51bWJlciAvLyBjbGllbnQgZXhwaXJhdGlvbiB0aW1lXG4gIGV4cGxpY2l0UmV2YWxpZGF0ZTogdW5kZWZpbmVkIHwgbnVtYmVyIC8vIGV4cGxpY2l0IHJldmFsaWRhdGUgdGltZSBmcm9tIGNhY2hlTGlmZSgpIGNhbGxzXG4gIGV4cGxpY2l0RXhwaXJlOiB1bmRlZmluZWQgfCBudW1iZXIgLy8gc2VydmVyIGV4cGlyYXRpb24gdGltZVxuICBleHBsaWNpdFN0YWxlOiB1bmRlZmluZWQgfCBudW1iZXIgLy8gY2xpZW50IGV4cGlyYXRpb24gdGltZVxuICB0YWdzOiBudWxsIHwgc3RyaW5nW11cbiAgcmVhZG9ubHkgaG1yUmVmcmVzaEhhc2g6IHN0cmluZyB8IHVuZGVmaW5lZFxuICByZWFkb25seSBpc0htclJlZnJlc2g6IGJvb2xlYW5cbiAgcmVhZG9ubHkgc2VydmVyQ29tcG9uZW50c0htckNhY2hlOiBTZXJ2ZXJDb21wb25lbnRzSG1yQ2FjaGUgfCB1bmRlZmluZWRcbiAgcmVhZG9ubHkgZm9yY2VSZXZhbGlkYXRlOiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVW5zdGFibGVDYWNoZVN0b3JlIGV4dGVuZHMgQ29tbW9uQ2FjaGVTdG9yZSB7XG4gIHR5cGU6ICd1bnN0YWJsZS1jYWNoZSdcbn1cblxuLyoqXG4gKiBUaGUgQ2FjaGUgc3RvcmUgaXMgZm9yIHRyYWNraW5nIGluZm9ybWF0aW9uIGluc2lkZSBhIFwidXNlIGNhY2hlXCIgb3JcbiAqIHVuc3RhYmxlX2NhY2hlIGNvbnRleHQuIEEgY2FjaGUgc3RvcmUgc2hhZG93cyBhbiBvdXRlciByZXF1ZXN0IHN0b3JlIChpZlxuICogcHJlc2VudCkgYXMgYSB3b3JrIHVuaXQsIHNvIHRoYXQgd2UgbmV2ZXIgYWNjaWRlbnRhbGx5IGV4cG9zZSBhbnkgcmVxdWVzdCBvclxuICogcGFnZSBzcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjYWNoZSBmdW5jdGlvbnMsIHVubGVzcyBpdCdzIGV4cGxpY2l0bHkgZGVzaXJlZC5cbiAqIEZvciB0aG9zZSBleGNlcHRpb25zLCB0aGUgZGF0YSBpcyBjb3BpZWQgb3ZlciBmcm9tIHRoZSByZXF1ZXN0IHN0b3JlIHRvIHRoZVxuICogY2FjaGUgc3RvcmUsIGluc3RlYWQgb2YgZ2VuZXJhbGx5IG1ha2luZyB0aGUgcmVxdWVzdCBzdG9yZSBhdmFpbGFibGUgdG8gY2FjaGVcbiAqIGZ1bmN0aW9ucy5cbiAqL1xuZXhwb3J0IHR5cGUgQ2FjaGVTdG9yZSA9IFVzZUNhY2hlU3RvcmUgfCBVbnN0YWJsZUNhY2hlU3RvcmVcblxuZXhwb3J0IHR5cGUgV29ya1VuaXRTdG9yZSA9IFJlcXVlc3RTdG9yZSB8IENhY2hlU3RvcmUgfCBQcmVyZW5kZXJTdG9yZVxuXG5leHBvcnQgdHlwZSBXb3JrVW5pdEFzeW5jU3RvcmFnZSA9IEFzeW5jTG9jYWxTdG9yYWdlPFdvcmtVbml0U3RvcmU+XG5cbmV4cG9ydCB7IHdvcmtVbml0QXN5bmNTdG9yYWdlSW5zdGFuY2UgYXMgd29ya1VuaXRBc3luY1N0b3JhZ2UgfVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXhwZWN0ZWRSZXF1ZXN0U3RvcmUoXG4gIGNhbGxpbmdFeHByZXNzaW9uOiBzdHJpbmdcbik6IFJlcXVlc3RTdG9yZSB7XG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZUluc3RhbmNlLmdldFN0b3JlKClcblxuICBpZiAoIXdvcmtVbml0U3RvcmUpIHtcbiAgICB0aHJvd0Zvck1pc3NpbmdSZXF1ZXN0U3RvcmUoY2FsbGluZ0V4cHJlc3Npb24pXG4gIH1cblxuICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgIGNhc2UgJ3JlcXVlc3QnOlxuICAgICAgcmV0dXJuIHdvcmtVbml0U3RvcmVcblxuICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgY2FzZSAncHJlcmVuZGVyLWNsaWVudCc6XG4gICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgY2FzZSAncHJlcmVuZGVyLWxlZ2FjeSc6XG4gICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuIGJlY2F1c2Ugd2Ugc2hvdWxkIGhhdmUgY2hlY2tlZCBpdCBhbHJlYWR5LlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgXFxgJHtjYWxsaW5nRXhwcmVzc2lvbn1cXGAgY2Fubm90IGJlIGNhbGxlZCBpbnNpZGUgYSBwcmVyZW5kZXIuIFRoaXMgaXMgYSBidWcgaW4gTmV4dC5qcy5gXG4gICAgICApXG5cbiAgICBjYXNlICdjYWNoZSc6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBcXGAke2NhbGxpbmdFeHByZXNzaW9ufVxcYCBjYW5ub3QgYmUgY2FsbGVkIGluc2lkZSBcInVzZSBjYWNoZVwiLiBDYWxsIGl0IG91dHNpZGUgYW5kIHBhc3MgYW4gYXJndW1lbnQgaW5zdGVhZC4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LXJlcXVlc3QtaW4tdXNlLWNhY2hlYFxuICAgICAgKVxuXG4gICAgY2FzZSAndW5zdGFibGUtY2FjaGUnOlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgXFxgJHtjYWxsaW5nRXhwcmVzc2lvbn1cXGAgY2Fubm90IGJlIGNhbGxlZCBpbnNpZGUgdW5zdGFibGVfY2FjaGUuIENhbGwgaXQgb3V0c2lkZSBhbmQgcGFzcyBhbiBhcmd1bWVudCBpbnN0ZWFkLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91bnN0YWJsZV9jYWNoZWBcbiAgICAgIClcblxuICAgIGRlZmF1bHQ6XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrOiBuZXZlciA9IHdvcmtVbml0U3RvcmVcbiAgICAgIHJldHVybiBfZXhoYXVzdGl2ZUNoZWNrXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRocm93Rm9yTWlzc2luZ1JlcXVlc3RTdG9yZShjYWxsaW5nRXhwcmVzc2lvbjogc3RyaW5nKTogbmV2ZXIge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYFxcYCR7Y2FsbGluZ0V4cHJlc3Npb259XFxgIHdhcyBjYWxsZWQgb3V0c2lkZSBhIHJlcXVlc3Qgc2NvcGUuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1keW5hbWljLWFwaS13cm9uZy1jb250ZXh0YFxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcmVyZW5kZXJSZXN1bWVEYXRhQ2FjaGUoXG4gIHdvcmtVbml0U3RvcmU6IFdvcmtVbml0U3RvcmVcbik6IFByZXJlbmRlclJlc3VtZURhdGFDYWNoZSB8IG51bGwge1xuICBpZiAoXG4gICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyJyB8fFxuICAgIC8vIFRPRE8gZWxpbWluYXRlIGZldGNoIGNhY2hpbmcgaW4gY2xpZW50IHNjb3BlIGFuZCBzdG9wIGV4cG9zaW5nIHRoaXMgZGF0YSBjYWNoZSBkdXJpbmcgU1NSXG4gICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLWNsaWVudCcgfHxcbiAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJ1xuICApIHtcbiAgICByZXR1cm4gd29ya1VuaXRTdG9yZS5wcmVyZW5kZXJSZXN1bWVEYXRhQ2FjaGVcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZW5kZXJSZXN1bWVEYXRhQ2FjaGUoXG4gIHdvcmtVbml0U3RvcmU6IFdvcmtVbml0U3RvcmVcbik6IFJlbmRlclJlc3VtZURhdGFDYWNoZSB8IG51bGwge1xuICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgIGNhc2UgJ3JlcXVlc3QnOlxuICAgICAgcmV0dXJuIHdvcmtVbml0U3RvcmUucmVuZGVyUmVzdW1lRGF0YUNhY2hlXG4gICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICBjYXNlICdwcmVyZW5kZXItY2xpZW50JzpcbiAgICAgIGlmICh3b3JrVW5pdFN0b3JlLnJlbmRlclJlc3VtZURhdGFDYWNoZSkge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgaW4gYSBwcmVyZW5kZXIsIHdlIG1pZ2h0IGhhdmUgYSByZW5kZXIgcmVzdW1lIGRhdGEgY2FjaGVcbiAgICAgICAgLy8gdGhhdCBpcyB1c2VkIHRvIHJlYWQgZnJvbSBwcmVmaWxsZWQgY2FjaGVzLlxuICAgICAgICByZXR1cm4gd29ya1VuaXRTdG9yZS5yZW5kZXJSZXN1bWVEYXRhQ2FjaGVcbiAgICAgIH1cbiAgICAvLyBmYWxsdGhyb3VnaFxuICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgLy8gT3RoZXJ3aXNlIHdlIHJldHVybiB0aGUgbXV0YWJsZSByZXN1bWUgZGF0YSBjYWNoZSBoZXJlIGFzIGFuIGltbXV0YWJsZVxuICAgICAgLy8gdmVyc2lvbiBvZiB0aGUgY2FjaGUgYXMgaXQgY2FuIGFsc28gYmUgdXNlZCBmb3IgcmVhZGluZy5cbiAgICAgIHJldHVybiB3b3JrVW5pdFN0b3JlLnByZXJlbmRlclJlc3VtZURhdGFDYWNoZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIbXJSZWZyZXNoSGFzaChcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmUsXG4gIHdvcmtVbml0U3RvcmU6IFdvcmtVbml0U3RvcmVcbik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmICghd29ya1N0b3JlLmRldikge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHJldHVybiB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdjYWNoZScgfHwgd29ya1VuaXRTdG9yZS50eXBlID09PSAncHJlcmVuZGVyJ1xuICAgID8gd29ya1VuaXRTdG9yZS5obXJSZWZyZXNoSGFzaFxuICAgIDogd29ya1VuaXRTdG9yZS50eXBlID09PSAncmVxdWVzdCdcbiAgICAgID8gd29ya1VuaXRTdG9yZS5jb29raWVzLmdldChORVhUX0hNUl9SRUZSRVNIX0hBU0hfQ09PS0lFKT8udmFsdWVcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbi8qKlxuICogUmV0dXJucyBhIGRyYWZ0IG1vZGUgcHJvdmlkZXIgb25seSBpZiBkcmFmdCBtb2RlIGlzIGVuYWJsZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREcmFmdE1vZGVQcm92aWRlckZvckNhY2hlU2NvcGUoXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlLFxuICB3b3JrVW5pdFN0b3JlOiBXb3JrVW5pdFN0b3JlXG4pOiBEcmFmdE1vZGVQcm92aWRlciB8IHVuZGVmaW5lZCB7XG4gIGlmICh3b3JrU3RvcmUuaXNEcmFmdE1vZGUpIHtcbiAgICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgICAgY2FzZSAnY2FjaGUnOlxuICAgICAgY2FzZSAndW5zdGFibGUtY2FjaGUnOlxuICAgICAgY2FzZSAncmVxdWVzdCc6XG4gICAgICAgIHJldHVybiB3b3JrVW5pdFN0b3JlLmRyYWZ0TW9kZVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWRcbn1cbiJdLCJuYW1lcyI6WyJnZXREcmFmdE1vZGVQcm92aWRlckZvckNhY2hlU2NvcGUiLCJnZXRFeHBlY3RlZFJlcXVlc3RTdG9yZSIsImdldEhtclJlZnJlc2hIYXNoIiwiZ2V0UHJlcmVuZGVyUmVzdW1lRGF0YUNhY2hlIiwiZ2V0UmVuZGVyUmVzdW1lRGF0YUNhY2hlIiwidGhyb3dGb3JNaXNzaW5nUmVxdWVzdFN0b3JlIiwid29ya1VuaXRBc3luY1N0b3JhZ2UiLCJ3b3JrVW5pdEFzeW5jU3RvcmFnZUluc3RhbmNlIiwiY2FsbGluZ0V4cHJlc3Npb24iLCJ3b3JrVW5pdFN0b3JlIiwiZ2V0U3RvcmUiLCJ0eXBlIiwiRXJyb3IiLCJfZXhoYXVzdGl2ZUNoZWNrIiwicHJlcmVuZGVyUmVzdW1lRGF0YUNhY2hlIiwicmVuZGVyUmVzdW1lRGF0YUNhY2hlIiwid29ya1N0b3JlIiwiZGV2IiwidW5kZWZpbmVkIiwiaG1yUmVmcmVzaEhhc2giLCJjb29raWVzIiwiZ2V0IiwiTkVYVF9ITVJfUkVGUkVTSF9IQVNIX0NPT0tJRSIsInZhbHVlIiwiaXNEcmFmdE1vZGUiLCJkcmFmdE1vZGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE2VWdCQSxpQ0FBaUMsRUFBQTtlQUFqQ0E7O0lBcEdBQyx1QkFBdUIsRUFBQTtlQUF2QkE7O0lBa0ZBQyxpQkFBaUIsRUFBQTtlQUFqQkE7O0lBdENBQywyQkFBMkIsRUFBQTtlQUEzQkE7O0lBZUFDLHdCQUF3QixFQUFBO2VBQXhCQTs7SUFyQkFDLDJCQUEyQixFQUFBO2VBQTNCQTs7SUF4Q3lCQyxvQkFBb0IsRUFBQTtlQUFwREMsOEJBQUFBLDRCQUE0Qjs7OzhDQTlOUTtrQ0FTQTtBQXVOdEMsU0FBU04sd0JBQ2RPLGlCQUF5QjtJQUV6QixNQUFNQyxnQkFBZ0JGLDhCQUFBQSw0QkFBNEIsQ0FBQ0csUUFBUTtJQUUzRCxJQUFJLENBQUNELGVBQWU7UUFDbEJKLDRCQUE0Qkc7SUFDOUI7SUFFQSxPQUFRQyxjQUFjRSxJQUFJO1FBQ3hCLEtBQUs7WUFDSCxPQUFPRjtRQUVULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxvRUFBb0U7WUFDcEUsTUFBTSxPQUFBLGNBRUwsQ0FGSyxJQUFJRyxNQUNSLEFBQUMsRUFBRSxTQUFFSixtQkFBa0IsaUVBQWlFLENBQUMsSUFEckYscUJBQUE7dUJBQUE7NEJBQUE7OEJBQUE7WUFFTjtRQUVGLEtBQUs7WUFDSCxNQUFNLE9BQUEsY0FFTCxDQUZLLElBQUlJLE1BQ1IsQUFBQyxFQUFFLFNBQUVKLG1CQUFrQiwySkFBMkosQ0FBQyxJQUQvSyxxQkFBQTt1QkFBQTs0QkFBQTs4QkFBQTtZQUVOO1FBRUYsS0FBSztZQUNILE1BQU0sT0FBQSxjQUVMLENBRkssSUFBSUksTUFDUixBQUFDLEVBQUUsU0FBRUosbUJBQWtCLHNLQUFzSyxDQUFDLElBRDFMLHFCQUFBO3VCQUFBOzRCQUFBOzhCQUFBO1lBRU47UUFFRjtZQUNFLE1BQU1LLG1CQUEwQko7WUFDaEMsT0FBT0k7SUFDWDtBQUNGO0FBRU8sU0FBU1IsNEJBQTRCRyxpQkFBeUI7SUFDbkUsTUFBTSxPQUFBLGNBRUwsQ0FGSyxJQUFJSSxNQUNSLEFBQUMsRUFBRSxFQUFvQixPQUFsQkosMEdBQW1JLENBQUMsOEJBRHJJLHFCQUFBO2VBQUE7b0JBQUE7c0JBQUE7SUFFTjtBQUNGO0FBRU8sU0FBU0wsNEJBQ2RNLGFBQTRCO0lBRTVCLElBQ0VBLGNBQWNFLElBQUksS0FBSyxlQUN2Qiw0RkFBNEY7SUFDNUZGLGNBQWNFLElBQUksS0FBSyxzQkFDdkJGLGNBQWNFLElBQUksS0FBSyxpQkFDdkI7UUFDQSxPQUFPRixjQUFjSyx3QkFBd0I7SUFDL0M7SUFFQSxPQUFPO0FBQ1Q7QUFFTyxTQUFTVix5QkFDZEssYUFBNEI7SUFFNUIsT0FBUUEsY0FBY0UsSUFBSTtRQUN4QixLQUFLO1lBQ0gsT0FBT0YsY0FBY00scUJBQXFCO1FBQzVDLEtBQUs7UUFDTCxLQUFLO1lBQ0gsSUFBSU4sY0FBY00scUJBQXFCLEVBQUU7Z0JBQ3ZDLHFFQUFxRTtnQkFDckUsOENBQThDO2dCQUM5QyxPQUFPTixjQUFjTSxxQkFBcUI7WUFDNUM7UUFDRixjQUFjO1FBQ2QsS0FBSztZQUNILHlFQUF5RTtZQUN6RSwyREFBMkQ7WUFDM0QsT0FBT04sY0FBY0ssd0JBQXdCO1FBQy9DO1lBQ0UsT0FBTztJQUNYO0FBQ0Y7QUFFTyxTQUFTWixrQkFDZGMsU0FBb0IsRUFDcEJQLGFBQTRCO1FBU3RCQTtJQVBOLElBQUksQ0FBQ08sVUFBVUMsR0FBRyxFQUFFO1FBQ2xCLE9BQU9DO0lBQ1Q7SUFFQSxPQUFPVCxjQUFjRSxJQUFJLEtBQUssV0FBV0YsY0FBY0UsSUFBSSxLQUFLLGNBQzVERixjQUFjVSxjQUFjLEdBQzVCVixjQUFjRSxJQUFJLEtBQUssWUFBQSxDQUNyQkYsNkJBQUFBLGNBQWNXLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDQyxrQkFBQUEsNEJBQTRCLENBQUEsS0FBQSxPQUFBLEtBQUEsSUFBdERiLDJCQUF5RGMsS0FBSyxHQUM5REw7QUFDUjtBQUtPLFNBQVNsQixrQ0FDZGdCLFNBQW9CLEVBQ3BCUCxhQUE0QjtJQUU1QixJQUFJTyxVQUFVUSxXQUFXLEVBQUU7UUFDekIsT0FBUWYsY0FBY0UsSUFBSTtZQUN4QixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsT0FBT0YsY0FBY2dCLFNBQVM7WUFDaEM7Z0JBQ0UsT0FBT1A7UUFDWDtJQUNGO0lBRUEsT0FBT0E7QUFDVCIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzMTgxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NlcnZlci9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhlIGZ1bmN0aW9ucyBwcm92aWRlZCBieSB0aGlzIG1vZHVsZSBhcmUgdXNlZCB0byBjb21tdW5pY2F0ZSBjZXJ0YWluIHByb3BlcnRpZXNcbiAqIGFib3V0IHRoZSBjdXJyZW50bHkgcnVubmluZyBjb2RlIHNvIHRoYXQgTmV4dC5qcyBjYW4gbWFrZSBkZWNpc2lvbnMgb24gaG93IHRvIGhhbmRsZVxuICogdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGluIGRpZmZlcmVudCByZW5kZXJpbmcgbW9kZXMgc3VjaCBhcyBwcmUtcmVuZGVyaW5nLCByZXN1bWluZywgYW5kIFNTUi5cbiAqXG4gKiBUb2RheSBOZXh0LmpzIHRyZWF0cyBhbGwgY29kZSBhcyBwb3RlbnRpYWxseSBzdGF0aWMuIENlcnRhaW4gQVBJcyBtYXkgb25seSBtYWtlIHNlbnNlIHdoZW4gZHluYW1pY2FsbHkgcmVuZGVyaW5nLlxuICogVHJhZGl0aW9uYWxseSB0aGlzIG1lYW50IGRlb3B0aW5nIHRoZSBlbnRpcmUgcmVuZGVyIHRvIGR5bmFtaWMgaG93ZXZlciB3aXRoIFBQUiB3ZSBjYW4gbm93IGRlb3B0IHBhcnRzXG4gKiBvZiBhIFJlYWN0IHRyZWUgYXMgZHluYW1pYyB3aGlsZSBzdGlsbCBrZWVwaW5nIG90aGVyIHBhcnRzIHN0YXRpYy4gVGhlcmUgYXJlIHJlYWxseSB0d28gZGlmZmVyZW50IGtpbmRzIG9mXG4gKiBEeW5hbWljIGluZGljYXRpb25zLlxuICpcbiAqIFRoZSBmaXJzdCBpcyBzaW1wbHkgYW4gaW50ZW50aW9uIHRvIGJlIGR5bmFtaWMuIHVuc3RhYmxlX25vU3RvcmUgaXMgYW4gZXhhbXBsZSBvZiB0aGlzIHdoZXJlXG4gKiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBjb2RlIHNpbXBseSBkZWNsYXJlcyB0aGF0IHRoZSBjdXJyZW50IHNjb3BlIGlzIGR5bmFtaWMgYnV0IGlmIHlvdSB1c2UgaXRcbiAqIGluc2lkZSB1bnN0YWJsZV9jYWNoZSBpdCBjYW4gc3RpbGwgYmUgY2FjaGVkLiBUaGlzIHR5cGUgb2YgaW5kaWNhdGlvbiBjYW4gYmUgcmVtb3ZlZCBpZiB3ZSBldmVyXG4gKiBtYWtlIHRoZSBkZWZhdWx0IGR5bmFtaWMgdG8gYmVnaW4gd2l0aCBiZWNhdXNlIHRoZSBvbmx5IHdheSB5b3Ugd291bGQgZXZlciBiZSBzdGF0aWMgaXMgaW5zaWRlXG4gKiBhIGNhY2hlIHNjb3BlIHdoaWNoIHRoaXMgaW5kaWNhdGlvbiBkb2VzIG5vdCBhZmZlY3QuXG4gKlxuICogVGhlIHNlY29uZCBpcyBhbiBpbmRpY2F0aW9uIHRoYXQgYSBkeW5hbWljIGRhdGEgc291cmNlIHdhcyByZWFkLiBUaGlzIGlzIGEgc3Ryb25nZXIgZm9ybSBvZiBkeW5hbWljXG4gKiBiZWNhdXNlIGl0IG1lYW5zIHRoYXQgaXQgaXMgaW5hcHByb3ByaWF0ZSB0byBjYWNoZSB0aGlzIGF0IGFsbC4gdXNpbmcgYSBkeW5hbWljIGRhdGEgc291cmNlIGluc2lkZVxuICogdW5zdGFibGVfY2FjaGUgc2hvdWxkIGVycm9yLiBJZiB5b3Ugd2FudCB0byB1c2Ugc29tZSBkeW5hbWljIGRhdGEgaW5zaWRlIHVuc3RhYmxlX2NhY2hlIHlvdSBzaG91bGRcbiAqIHJlYWQgdGhhdCBkYXRhIG91dHNpZGUgdGhlIGNhY2hlIGFuZCBwYXNzIGl0IGluIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBjYWNoZWQgZnVuY3Rpb24uXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBXb3JrU3RvcmUgfSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB0eXBlIHtcbiAgV29ya1VuaXRTdG9yZSxcbiAgUmVxdWVzdFN0b3JlLFxuICBQcmVyZW5kZXJTdG9yZUxlZ2FjeSxcbiAgUHJlcmVuZGVyU3RvcmVNb2Rlcm4sXG59IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5cbi8vIE9uY2UgcG9zdHBvbmUgaXMgaW4gc3RhYmxlIHdlIHNob3VsZCBzd2l0Y2ggdG8gaW1wb3J0aW5nIHRoZSBwb3N0cG9uZSBleHBvcnQgZGlyZWN0bHlcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHsgRHluYW1pY1NlcnZlckVycm9yIH0gZnJvbSAnLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvaG9va3Mtc2VydmVyLWNvbnRleHQnXG5pbXBvcnQgeyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IgfSBmcm9tICcuLi8uLi9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0J1xuaW1wb3J0IHsgd29ya1VuaXRBc3luY1N0b3JhZ2UgfSBmcm9tICcuL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHsgd29ya0FzeW5jU3RvcmFnZSB9IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHsgbWFrZUhhbmdpbmdQcm9taXNlIH0gZnJvbSAnLi4vZHluYW1pYy1yZW5kZXJpbmctdXRpbHMnXG5pbXBvcnQge1xuICBNRVRBREFUQV9CT1VOREFSWV9OQU1FLFxuICBWSUVXUE9SVF9CT1VOREFSWV9OQU1FLFxuICBPVVRMRVRfQk9VTkRBUllfTkFNRSxcbn0gZnJvbSAnLi4vLi4vbGliL21ldGFkYXRhL21ldGFkYXRhLWNvbnN0YW50cydcbmltcG9ydCB7IHNjaGVkdWxlT25OZXh0VGljayB9IGZyb20gJy4uLy4uL2xpYi9zY2hlZHVsZXInXG5cbmNvbnN0IGhhc1Bvc3Rwb25lID0gdHlwZW9mIFJlYWN0LnVuc3RhYmxlX3Bvc3Rwb25lID09PSAnZnVuY3Rpb24nXG5cbmV4cG9ydCB0eXBlIER5bmFtaWNBY2Nlc3MgPSB7XG4gIC8qKlxuICAgKiBJZiBkZWJ1Z2dpbmcsIHRoaXMgd2lsbCBjb250YWluIHRoZSBzdGFjayB0cmFjZSBvZiB3aGVyZSB0aGUgZHluYW1pYyBhY2Nlc3NcbiAgICogb2NjdXJyZWQuIFRoaXMgaXMgdXNlZCB0byBwcm92aWRlIG1vcmUgaW5mb3JtYXRpb24gdG8gdGhlIHVzZXIgYWJvdXQgd2h5XG4gICAqIHRoZWlyIHBhZ2UgaXMgYmVpbmcgcmVuZGVyZWQgZHluYW1pY2FsbHkuXG4gICAqL1xuICBzdGFjaz86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgZXhwcmVzc2lvbiB0aGF0IHdhcyBhY2Nlc3NlZCBkeW5hbWljYWxseS5cbiAgICovXG4gIGV4cHJlc3Npb246IHN0cmluZ1xufVxuXG4vLyBTdG9yZXMgZHluYW1pYyByZWFzb25zIHVzZWQgZHVyaW5nIGFuIFJTQyByZW5kZXIuXG5leHBvcnQgdHlwZSBEeW5hbWljVHJhY2tpbmdTdGF0ZSA9IHtcbiAgLyoqXG4gICAqIFdoZW4gdHJ1ZSwgc3RhY2sgaW5mb3JtYXRpb24gd2lsbCBhbHNvIGJlIHRyYWNrZWQgZHVyaW5nIGR5bmFtaWMgYWNjZXNzLlxuICAgKi9cbiAgcmVhZG9ubHkgaXNEZWJ1Z0R5bmFtaWNBY2Nlc3NlczogYm9vbGVhbiB8IHVuZGVmaW5lZFxuXG4gIC8qKlxuICAgKiBUaGUgZHluYW1pYyBhY2Nlc3NlcyB0aGF0IG9jY3VycmVkIGR1cmluZyB0aGUgcmVuZGVyLlxuICAgKi9cbiAgcmVhZG9ubHkgZHluYW1pY0FjY2Vzc2VzOiBBcnJheTxEeW5hbWljQWNjZXNzPlxuXG4gIHN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2s6IG51bGwgfCBFcnJvclxufVxuXG4vLyBTdG9yZXMgZHluYW1pYyByZWFzb25zIHVzZWQgZHVyaW5nIGFuIFNTUiByZW5kZXIuXG5leHBvcnQgdHlwZSBEeW5hbWljVmFsaWRhdGlvblN0YXRlID0ge1xuICBoYXNTdXNwZW5zZUFib3ZlQm9keTogYm9vbGVhblxuICBoYXNEeW5hbWljTWV0YWRhdGE6IGJvb2xlYW5cbiAgaGFzRHluYW1pY1ZpZXdwb3J0OiBib29sZWFuXG4gIGhhc0FsbG93ZWREeW5hbWljOiBib29sZWFuXG4gIGR5bmFtaWNFcnJvcnM6IEFycmF5PEVycm9yPlxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRHluYW1pY1RyYWNraW5nU3RhdGUoXG4gIGlzRGVidWdEeW5hbWljQWNjZXNzZXM6IGJvb2xlYW4gfCB1bmRlZmluZWRcbik6IER5bmFtaWNUcmFja2luZ1N0YXRlIHtcbiAgcmV0dXJuIHtcbiAgICBpc0RlYnVnRHluYW1pY0FjY2Vzc2VzLFxuICAgIGR5bmFtaWNBY2Nlc3NlczogW10sXG4gICAgc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjazogbnVsbCxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRHluYW1pY1ZhbGlkYXRpb25TdGF0ZSgpOiBEeW5hbWljVmFsaWRhdGlvblN0YXRlIHtcbiAgcmV0dXJuIHtcbiAgICBoYXNTdXNwZW5zZUFib3ZlQm9keTogZmFsc2UsXG4gICAgaGFzRHluYW1pY01ldGFkYXRhOiBmYWxzZSxcbiAgICBoYXNEeW5hbWljVmlld3BvcnQ6IGZhbHNlLFxuICAgIGhhc0FsbG93ZWREeW5hbWljOiBmYWxzZSxcbiAgICBkeW5hbWljRXJyb3JzOiBbXSxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rmlyc3REeW5hbWljUmVhc29uKFxuICB0cmFja2luZ1N0YXRlOiBEeW5hbWljVHJhY2tpbmdTdGF0ZVxuKTogdW5kZWZpbmVkIHwgc3RyaW5nIHtcbiAgcmV0dXJuIHRyYWNraW5nU3RhdGUuZHluYW1pY0FjY2Vzc2VzWzBdPy5leHByZXNzaW9uXG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjb21tdW5pY2F0ZXMgdGhhdCB0aGUgY3VycmVudCBzY29wZSBzaG91bGQgYmUgdHJlYXRlZCBhcyBkeW5hbWljLlxuICpcbiAqIEluIG1vc3QgY2FzZXMgdGhpcyBmdW5jdGlvbiBpcyBhIG5vLW9wIGJ1dCBpZiBjYWxsZWQgZHVyaW5nXG4gKiBhIFBQUiBwcmVyZW5kZXIgaXQgd2lsbCBwb3N0cG9uZSB0aGUgY3VycmVudCBzdWItdHJlZSBhbmQgY2FsbGluZ1xuICogaXQgZHVyaW5nIGEgbm9ybWFsIHByZXJlbmRlciB3aWxsIGNhdXNlIHRoZSBlbnRpcmUgcHJlcmVuZGVyIHRvIGFib3J0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrQ3VycmVudFNjb3BlQXNEeW5hbWljKFxuICBzdG9yZTogV29ya1N0b3JlLFxuICB3b3JrVW5pdFN0b3JlOiB1bmRlZmluZWQgfCBFeGNsdWRlPFdvcmtVbml0U3RvcmUsIFByZXJlbmRlclN0b3JlTW9kZXJuPixcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pOiB2b2lkIHtcbiAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICBpZiAoXG4gICAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdjYWNoZScgfHxcbiAgICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3Vuc3RhYmxlLWNhY2hlJ1xuICAgICkge1xuICAgICAgLy8gaW5zaWRlIGNhY2hlIHNjb3BlcyBtYXJraW5nIGEgc2NvcGUgYXMgZHluYW1pYyBoYXMgbm8gZWZmZWN0IGJlY2F1c2UgdGhlIG91dGVyIGNhY2hlIHNjb3BlXG4gICAgICAvLyBjcmVhdGVzIGEgY2FjaGUgYm91bmRhcnkuIFRoaXMgaXMgc3VidGx5IGRpZmZlcmVudCBmcm9tIHJlYWRpbmcgYSBkeW5hbWljIGRhdGEgc291cmNlIHdoaWNoIGlzXG4gICAgICAvLyBmb3JiaWRkZW4gaW5zaWRlIGEgY2FjaGUgc2NvcGUuXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBmb3JjaW5nIGR5bmFtaWMgcmVuZGVyaW5nIG9yIHdlJ3JlIGZvcmNpbmcgc3RhdGljIHJlbmRlcmluZywgd2VcbiAgLy8gZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyBoZXJlIGJlY2F1c2UgdGhlIGVudGlyZSBwYWdlIGlzIGFscmVhZHkgZHluYW1pY1xuICAvLyBvciBpdCdzIHN0YXRpYyBhbmQgaXQgc2hvdWxkIG5vdCB0aHJvdyBvciBwb3N0cG9uZSBoZXJlLlxuICBpZiAoc3RvcmUuZm9yY2VEeW5hbWljIHx8IHN0b3JlLmZvcmNlU3RhdGljKSByZXR1cm5cblxuICBpZiAoc3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgdGhyb3cgbmV3IFN0YXRpY0dlbkJhaWxvdXRFcnJvcihcbiAgICAgIGBSb3V0ZSAke3N0b3JlLnJvdXRlfSB3aXRoIFxcYGR5bmFtaWMgPSBcImVycm9yXCJcXGAgY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgXFxgJHtleHByZXNzaW9ufVxcYC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvc3RhdGljLWFuZC1keW5hbWljI2R5bmFtaWMtcmVuZGVyaW5nYFxuICAgIClcbiAgfVxuXG4gIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgICAgICAgc3RvcmUucm91dGUsXG4gICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgIHdvcmtVbml0U3RvcmUuZHluYW1pY1RyYWNraW5nXG4gICAgICApXG4gICAgfSBlbHNlIGlmICh3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItbGVnYWN5Jykge1xuICAgICAgd29ya1VuaXRTdG9yZS5yZXZhbGlkYXRlID0gMFxuXG4gICAgICAvLyBXZSBhcmVuJ3QgcHJlcmVuZGVyaW5nIGJ1dCB3ZSBhcmUgZ2VuZXJhdGluZyBhIHN0YXRpYyBwYWdlLiBXZSBuZWVkIHRvIGJhaWwgb3V0IG9mIHN0YXRpYyBnZW5lcmF0aW9uXG4gICAgICBjb25zdCBlcnIgPSBuZXcgRHluYW1pY1NlcnZlckVycm9yKFxuICAgICAgICBgUm91dGUgJHtzdG9yZS5yb3V0ZX0gY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgJHtleHByZXNzaW9ufS4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9keW5hbWljLXNlcnZlci1lcnJvcmBcbiAgICAgIClcbiAgICAgIHN0b3JlLmR5bmFtaWNVc2FnZURlc2NyaXB0aW9uID0gZXhwcmVzc2lvblxuICAgICAgc3RvcmUuZHluYW1pY1VzYWdlU3RhY2sgPSBlcnIuc3RhY2tcblxuICAgICAgdGhyb3cgZXJyXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICB3b3JrVW5pdFN0b3JlICYmXG4gICAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdyZXF1ZXN0J1xuICAgICkge1xuICAgICAgd29ya1VuaXRTdG9yZS51c2VkRHluYW1pYyA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNvbW11bmljYXRlcyB0aGF0IHNvbWUgZHluYW1pYyBwYXRoIHBhcmFtZXRlciB3YXMgcmVhZC4gVGhpc1xuICogZGlmZmVycyBmcm9tIHRoZSBtb3JlIGdlbmVyYWwgYHRyYWNrRHluYW1pY0RhdGFBY2Nlc3NlZGAgaW4gdGhhdCBpdCBpcyB3aWxsXG4gKiBub3QgZXJyb3Igd2hlbiBgZHluYW1pYyA9IFwiZXJyb3JcImAgaXMgc2V0LlxuICpcbiAqIEBwYXJhbSBzdG9yZSBUaGUgc3RhdGljIGdlbmVyYXRpb24gc3RvcmVcbiAqIEBwYXJhbSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHRoYXQgd2FzIGFjY2Vzc2VkIGR5bmFtaWNhbGx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFja0ZhbGxiYWNrUGFyYW1BY2Nlc3NlZChcbiAgc3RvcmU6IFdvcmtTdG9yZSxcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pOiB2b2lkIHtcbiAgY29uc3QgcHJlcmVuZGVyU3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGlmICghcHJlcmVuZGVyU3RvcmUgfHwgcHJlcmVuZGVyU3RvcmUudHlwZSAhPT0gJ3ByZXJlbmRlci1wcHInKSByZXR1cm5cblxuICBwb3N0cG9uZVdpdGhUcmFja2luZyhzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbiwgcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nKVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbWVhbnQgdG8gYmUgdXNlZCB3aGVuIHByZXJlbmRlcmluZyB3aXRob3V0IGR5bmFtaWNJTyBvciBQUFIuXG4gKiBXaGVuIGNhbGxlZCBkdXJpbmcgYSBidWlsZCBpdCB3aWxsIGNhdXNlIE5leHQuanMgdG8gY29uc2lkZXIgdGhlIHJvdXRlIGFzIGR5bmFtaWMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbihcbiAgZXhwcmVzc2lvbjogc3RyaW5nLFxuICBzdG9yZTogV29ya1N0b3JlLFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVMZWdhY3lcbik6IG5ldmVyIHtcbiAgLy8gV2UgYXJlbid0IHByZXJlbmRlcmluZyBidXQgd2UgYXJlIGdlbmVyYXRpbmcgYSBzdGF0aWMgcGFnZS4gV2UgbmVlZCB0byBiYWlsIG91dCBvZiBzdGF0aWMgZ2VuZXJhdGlvblxuICBjb25zdCBlcnIgPSBuZXcgRHluYW1pY1NlcnZlckVycm9yKFxuICAgIGBSb3V0ZSAke3N0b3JlLnJvdXRlfSBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCBcXGAke2V4cHJlc3Npb259XFxgLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2R5bmFtaWMtc2VydmVyLWVycm9yYFxuICApXG5cbiAgcHJlcmVuZGVyU3RvcmUucmV2YWxpZGF0ZSA9IDBcblxuICBzdG9yZS5keW5hbWljVXNhZ2VEZXNjcmlwdGlvbiA9IGV4cHJlc3Npb25cbiAgc3RvcmUuZHluYW1pY1VzYWdlU3RhY2sgPSBlcnIuc3RhY2tcblxuICB0aHJvdyBlcnJcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB1c2VkIHRvIHRyYWNrIHdoZXRoZXIgc29tZXRoaW5nIGR5bmFtaWMgaGFwcGVuZWQgZXZlbiB3aGVuXG4gKiB3ZSBhcmUgaW4gYSBkeW5hbWljIHJlbmRlci4gVGhpcyBpcyB1c2VmdWwgZm9yIERldiB3aGVyZSBhbGwgcmVuZGVycyBhcmUgZHluYW1pYyBidXRcbiAqIHdlIHN0aWxsIHRyYWNrIHdoZXRoZXIgZHluYW1pYyBBUElzIHdlcmUgYWNjZXNzZWQgZm9yIGhlbHBmdWwgbWVzc2FnaW5nXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFja0R5bmFtaWNEYXRhSW5EeW5hbWljUmVuZGVyKFxuICBfc3RvcmU6IFdvcmtTdG9yZSxcbiAgd29ya1VuaXRTdG9yZTogdm9pZCB8IFdvcmtVbml0U3RvcmVcbikge1xuICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgIGlmIChcbiAgICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ2NhY2hlJyB8fFxuICAgICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAndW5zdGFibGUtY2FjaGUnXG4gICAgKSB7XG4gICAgICAvLyBpbnNpZGUgY2FjaGUgc2NvcGVzIG1hcmtpbmcgYSBzY29wZSBhcyBkeW5hbWljIGhhcyBubyBlZmZlY3QgYmVjYXVzZSB0aGUgb3V0ZXIgY2FjaGUgc2NvcGVcbiAgICAgIC8vIGNyZWF0ZXMgYSBjYWNoZSBib3VuZGFyeS4gVGhpcyBpcyBzdWJ0bHkgZGlmZmVyZW50IGZyb20gcmVhZGluZyBhIGR5bmFtaWMgZGF0YSBzb3VyY2Ugd2hpY2ggaXNcbiAgICAgIC8vIGZvcmJpZGRlbiBpbnNpZGUgYSBjYWNoZSBzY29wZS5cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBUT0RPOiBpdCBtYWtlcyBubyBzZW5zZSB0byBoYXZlIHRoZXNlIHdvcmsgdW5pdCBzdG9yZSB0eXBlcyBkdXJpbmcgYSBkZXYgcmVuZGVyLlxuICAgIGlmIChcbiAgICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcicgfHxcbiAgICAgIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1jbGllbnQnIHx8XG4gICAgICB3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItbGVnYWN5J1xuICAgICkge1xuICAgICAgd29ya1VuaXRTdG9yZS5yZXZhbGlkYXRlID0gMFxuICAgIH1cbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJlxuICAgICAgd29ya1VuaXRTdG9yZS50eXBlID09PSAncmVxdWVzdCdcbiAgICApIHtcbiAgICAgIHdvcmtVbml0U3RvcmUudXNlZER5bmFtaWMgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFib3J0T25TeW5jaHJvbm91c0R5bmFtaWNEYXRhQWNjZXNzKFxuICByb3V0ZTogc3RyaW5nLFxuICBleHByZXNzaW9uOiBzdHJpbmcsXG4gIHByZXJlbmRlclN0b3JlOiBQcmVyZW5kZXJTdG9yZU1vZGVyblxuKTogdm9pZCB7XG4gIGNvbnN0IHJlYXNvbiA9IGBSb3V0ZSAke3JvdXRlfSBuZWVkcyB0byBiYWlsIG91dCBvZiBwcmVyZW5kZXJpbmcgYXQgdGhpcyBwb2ludCBiZWNhdXNlIGl0IHVzZWQgJHtleHByZXNzaW9ufS5gXG5cbiAgY29uc3QgZXJyb3IgPSBjcmVhdGVQcmVyZW5kZXJJbnRlcnJ1cHRlZEVycm9yKHJlYXNvbilcblxuICBwcmVyZW5kZXJTdG9yZS5jb250cm9sbGVyLmFib3J0KGVycm9yKVxuXG4gIGNvbnN0IGR5bmFtaWNUcmFja2luZyA9IHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICBpZiAoZHluYW1pY1RyYWNraW5nKSB7XG4gICAgZHluYW1pY1RyYWNraW5nLmR5bmFtaWNBY2Nlc3Nlcy5wdXNoKHtcbiAgICAgIC8vIFdoZW4gd2UgYXJlbid0IGRlYnVnZ2luZywgd2UgZG9uJ3QgbmVlZCB0byBjcmVhdGUgYW5vdGhlciBlcnJvciBmb3IgdGhlXG4gICAgICAvLyBzdGFjayB0cmFjZS5cbiAgICAgIHN0YWNrOiBkeW5hbWljVHJhY2tpbmcuaXNEZWJ1Z0R5bmFtaWNBY2Nlc3Nlc1xuICAgICAgICA/IG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgZXhwcmVzc2lvbixcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhYm9ydE9uU3luY2hyb25vdXNQbGF0Zm9ybUlPQWNjZXNzKFxuICByb3V0ZTogc3RyaW5nLFxuICBleHByZXNzaW9uOiBzdHJpbmcsXG4gIGVycm9yV2l0aFN0YWNrOiBFcnJvcixcbiAgcHJlcmVuZGVyU3RvcmU6IFByZXJlbmRlclN0b3JlTW9kZXJuXG4pOiB2b2lkIHtcbiAgY29uc3QgZHluYW1pY1RyYWNraW5nID0gcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nXG4gIGFib3J0T25TeW5jaHJvbm91c0R5bmFtaWNEYXRhQWNjZXNzKHJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZSlcbiAgLy8gSXQgaXMgaW1wb3J0YW50IHRoYXQgd2Ugc2V0IHRoaXMgdHJhY2tpbmcgdmFsdWUgYWZ0ZXIgYWJvcnRpbmcuIEFib3J0cyBhcmUgZXhlY3V0ZWRcbiAgLy8gc3luY2hyb25vdXNseSBleGNlcHQgZm9yIHRoZSBjYXNlIHdoZXJlIHlvdSBhYm9ydCBkdXJpbmcgcmVuZGVyIGl0c2VsZi4gQnkgc2V0dGluZyB0aGlzXG4gIC8vIHZhbHVlIGxhdGUgd2UgY2FuIHVzZSBpdCB0byBkZXRlcm1pbmUgaWYgYW55IG9mIHRoZSBhYm9ydGVkIHRhc2tzIGFyZSB0aGUgdGFzayB0aGF0XG4gIC8vIGNhbGxlZCB0aGUgc3luYyBJTyBleHByZXNzaW9uIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgaWYgKGR5bmFtaWNUcmFja2luZykge1xuICAgIGlmIChkeW5hbWljVHJhY2tpbmcuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjayA9PT0gbnVsbCkge1xuICAgICAgZHluYW1pY1RyYWNraW5nLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2sgPSBlcnJvcldpdGhTdGFja1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhY2tTeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3NJbkRldihcbiAgcmVxdWVzdFN0b3JlOiBSZXF1ZXN0U3RvcmVcbik6IHZvaWQge1xuICAvLyBXZSBkb24ndCBhY3R1YWxseSBoYXZlIGEgY29udHJvbGxlciB0byBhYm9ydCBidXQgd2UgZG8gdGhlIHNlbWFudGljIGVxdWl2YWxlbnQgYnlcbiAgLy8gYWR2YW5jaW5nIHRoZSByZXF1ZXN0IHN0b3JlIG91dCBvZiBwcmVyZW5kZXIgbW9kZVxuICByZXF1ZXN0U3RvcmUucHJlcmVuZGVyUGhhc2UgPSBmYWxzZVxufVxuXG4vKipcbiAqIHVzZSB0aGlzIGZ1bmN0aW9uIHdoZW4gcHJlcmVuZGVyaW5nIHdpdGggZHluYW1pY0lPLiBJZiB3ZSBhcmUgZG9pbmcgYVxuICogcHJvc3BlY3RpdmUgcHJlcmVuZGVyIHdlIGRvbid0IGFjdHVhbGx5IGFib3J0IGJlY2F1c2Ugd2Ugd2FudCB0byBkaXNjb3ZlclxuICogYWxsIGNhY2hlcyBmb3IgdGhlIHNoZWxsLiBJZiB0aGlzIGlzIHRoZSBhY3R1YWwgcHJlcmVuZGVyIHdlIGRvIGFib3J0LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhIHByZXJlbmRlclN0b3JlIGJ1dCB0aGUgY2FsbGVyIHNob3VsZCBlbnN1cmUgd2UncmVcbiAqIGFjdHVhbGx5IHJ1bm5pbmcgaW4gZHluYW1pY0lPIG1vZGUuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhYm9ydEFuZFRocm93T25TeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzKFxuICByb3V0ZTogc3RyaW5nLFxuICBleHByZXNzaW9uOiBzdHJpbmcsXG4gIGVycm9yV2l0aFN0YWNrOiBFcnJvcixcbiAgcHJlcmVuZGVyU3RvcmU6IFByZXJlbmRlclN0b3JlTW9kZXJuXG4pOiBuZXZlciB7XG4gIGNvbnN0IHByZXJlbmRlclNpZ25hbCA9IHByZXJlbmRlclN0b3JlLmNvbnRyb2xsZXIuc2lnbmFsXG4gIGlmIChwcmVyZW5kZXJTaWduYWwuYWJvcnRlZCA9PT0gZmFsc2UpIHtcbiAgICAvLyBUT0RPIGl0IHdvdWxkIGJlIGJldHRlciB0byBtb3ZlIHRoaXMgYWJvcnRlZCBjaGVjayBpbnRvIHRoZSBjYWxsc2l0ZSBzbyB3ZSBjYW4gYXZvaWQgbWFraW5nXG4gICAgLy8gdGhlIGVycm9yIG9iamVjdCB3aGVuIGl0IGlzbid0IHJlbGV2YW50IHRvIHRoZSBhYm9ydGluZyBvZiB0aGUgcHJlcmVuZGVyIGhvd2V2ZXJcbiAgICAvLyBzaW5jZSB3ZSBuZWVkIHRoZSB0aHJvdyBzZW1hbnRpY3MgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHdlIGFib3J0IGl0IGlzIGVhc2llciB0byBsYW5kXG4gICAgLy8gdGhpcyB3YXkuIFNlZSBob3cgdGhpcyB3YXMgaGFuZGxlZCB3aXRoIGBhYm9ydE9uU3luY2hyb25vdXNQbGF0Zm9ybUlPQWNjZXNzYCBmb3IgYSBjbG9zZXJcbiAgICAvLyB0byBpZGVhbCBpbXBsZW1lbnRhdGlvblxuICAgIGFib3J0T25TeW5jaHJvbm91c0R5bmFtaWNEYXRhQWNjZXNzKHJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZSlcbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdGhhdCB3ZSBzZXQgdGhpcyB0cmFja2luZyB2YWx1ZSBhZnRlciBhYm9ydGluZy4gQWJvcnRzIGFyZSBleGVjdXRlZFxuICAgIC8vIHN5bmNocm9ub3VzbHkgZXhjZXB0IGZvciB0aGUgY2FzZSB3aGVyZSB5b3UgYWJvcnQgZHVyaW5nIHJlbmRlciBpdHNlbGYuIEJ5IHNldHRpbmcgdGhpc1xuICAgIC8vIHZhbHVlIGxhdGUgd2UgY2FuIHVzZSBpdCB0byBkZXRlcm1pbmUgaWYgYW55IG9mIHRoZSBhYm9ydGVkIHRhc2tzIGFyZSB0aGUgdGFzayB0aGF0XG4gICAgLy8gY2FsbGVkIHRoZSBzeW5jIElPIGV4cHJlc3Npb24gaW4gdGhlIGZpcnN0IHBsYWNlLlxuICAgIGNvbnN0IGR5bmFtaWNUcmFja2luZyA9IHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgIGlmIChkeW5hbWljVHJhY2tpbmcpIHtcbiAgICAgIGlmIChkeW5hbWljVHJhY2tpbmcuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjayA9PT0gbnVsbCkge1xuICAgICAgICBkeW5hbWljVHJhY2tpbmcuc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjayA9IGVycm9yV2l0aFN0YWNrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRocm93IGNyZWF0ZVByZXJlbmRlckludGVycnVwdGVkRXJyb3IoXG4gICAgYFJvdXRlICR7cm91dGV9IG5lZWRzIHRvIGJhaWwgb3V0IG9mIHByZXJlbmRlcmluZyBhdCB0aGlzIHBvaW50IGJlY2F1c2UgaXQgdXNlZCAke2V4cHJlc3Npb259LmBcbiAgKVxufVxuXG4vLyBGb3Igbm93IHRoZXNlIGltcGxlbWVudGF0aW9ucyBhcmUgdGhlIHNhbWUgc28gd2UganVzdCByZWV4cG9ydFxuZXhwb3J0IGNvbnN0IHRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2ID1cbiAgdHJhY2tTeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3NJbkRldlxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHdpbGwgY2FsbCBgUmVhY3QucG9zdHBvbmVgIHRoYXQgdGhyb3dzIHRoZSBwb3N0cG9uZWQgZXJyb3IuXG4gKi9cbnR5cGUgUG9zdHBvbmVQcm9wcyA9IHtcbiAgcmVhc29uOiBzdHJpbmdcbiAgcm91dGU6IHN0cmluZ1xufVxuZXhwb3J0IGZ1bmN0aW9uIFBvc3Rwb25lKHsgcmVhc29uLCByb3V0ZSB9OiBQb3N0cG9uZVByb3BzKTogbmV2ZXIge1xuICBjb25zdCBwcmVyZW5kZXJTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcbiAgY29uc3QgZHluYW1pY1RyYWNraW5nID1cbiAgICBwcmVyZW5kZXJTdG9yZSAmJiBwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcidcbiAgICAgID8gcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nXG4gICAgICA6IG51bGxcbiAgcG9zdHBvbmVXaXRoVHJhY2tpbmcocm91dGUsIHJlYXNvbiwgZHluYW1pY1RyYWNraW5nKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zdHBvbmVXaXRoVHJhY2tpbmcoXG4gIHJvdXRlOiBzdHJpbmcsXG4gIGV4cHJlc3Npb246IHN0cmluZyxcbiAgZHluYW1pY1RyYWNraW5nOiBudWxsIHwgRHluYW1pY1RyYWNraW5nU3RhdGVcbik6IG5ldmVyIHtcbiAgYXNzZXJ0UG9zdHBvbmUoKVxuICBpZiAoZHluYW1pY1RyYWNraW5nKSB7XG4gICAgZHluYW1pY1RyYWNraW5nLmR5bmFtaWNBY2Nlc3Nlcy5wdXNoKHtcbiAgICAgIC8vIFdoZW4gd2UgYXJlbid0IGRlYnVnZ2luZywgd2UgZG9uJ3QgbmVlZCB0byBjcmVhdGUgYW5vdGhlciBlcnJvciBmb3IgdGhlXG4gICAgICAvLyBzdGFjayB0cmFjZS5cbiAgICAgIHN0YWNrOiBkeW5hbWljVHJhY2tpbmcuaXNEZWJ1Z0R5bmFtaWNBY2Nlc3Nlc1xuICAgICAgICA/IG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgZXhwcmVzc2lvbixcbiAgICB9KVxuICB9XG5cbiAgUmVhY3QudW5zdGFibGVfcG9zdHBvbmUoY3JlYXRlUG9zdHBvbmVSZWFzb24ocm91dGUsIGV4cHJlc3Npb24pKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQb3N0cG9uZVJlYXNvbihyb3V0ZTogc3RyaW5nLCBleHByZXNzaW9uOiBzdHJpbmcpIHtcbiAgcmV0dXJuIChcbiAgICBgUm91dGUgJHtyb3V0ZX0gbmVlZHMgdG8gYmFpbCBvdXQgb2YgcHJlcmVuZGVyaW5nIGF0IHRoaXMgcG9pbnQgYmVjYXVzZSBpdCB1c2VkICR7ZXhwcmVzc2lvbn0uIGAgK1xuICAgIGBSZWFjdCB0aHJvd3MgdGhpcyBzcGVjaWFsIG9iamVjdCB0byBpbmRpY2F0ZSB3aGVyZS4gSXQgc2hvdWxkIG5vdCBiZSBjYXVnaHQgYnkgYCArXG4gICAgYHlvdXIgb3duIHRyeS9jYXRjaC4gTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcHByLWNhdWdodC1lcnJvcmBcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEeW5hbWljUG9zdHBvbmUoZXJyOiB1bmtub3duKSB7XG4gIGlmIChcbiAgICB0eXBlb2YgZXJyID09PSAnb2JqZWN0JyAmJlxuICAgIGVyciAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiAoZXJyIGFzIGFueSkubWVzc2FnZSA9PT0gJ3N0cmluZydcbiAgKSB7XG4gICAgcmV0dXJuIGlzRHluYW1pY1Bvc3Rwb25lUmVhc29uKChlcnIgYXMgYW55KS5tZXNzYWdlKVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBpc0R5bmFtaWNQb3N0cG9uZVJlYXNvbihyZWFzb246IHN0cmluZykge1xuICByZXR1cm4gKFxuICAgIHJlYXNvbi5pbmNsdWRlcyhcbiAgICAgICduZWVkcyB0byBiYWlsIG91dCBvZiBwcmVyZW5kZXJpbmcgYXQgdGhpcyBwb2ludCBiZWNhdXNlIGl0IHVzZWQnXG4gICAgKSAmJlxuICAgIHJlYXNvbi5pbmNsdWRlcyhcbiAgICAgICdMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wcHItY2F1Z2h0LWVycm9yJ1xuICAgIClcbiAgKVxufVxuXG5pZiAoaXNEeW5hbWljUG9zdHBvbmVSZWFzb24oY3JlYXRlUG9zdHBvbmVSZWFzb24oJyUlJScsICdeXl4nKSkgPT09IGZhbHNlKSB7XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnSW52YXJpYW50OiBpc0R5bmFtaWNQb3N0cG9uZSBtaXNpZGVudGlmaWVkIGEgcG9zdHBvbmUgcmVhc29uLiBUaGlzIGlzIGEgYnVnIGluIE5leHQuanMnXG4gIClcbn1cblxuY29uc3QgTkVYVF9QUkVSRU5ERVJfSU5URVJSVVBURUQgPSAnTkVYVF9QUkVSRU5ERVJfSU5URVJSVVBURUQnXG5cbmZ1bmN0aW9uIGNyZWF0ZVByZXJlbmRlckludGVycnVwdGVkRXJyb3IobWVzc2FnZTogc3RyaW5nKTogRXJyb3Ige1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICA7KGVycm9yIGFzIGFueSkuZGlnZXN0ID0gTkVYVF9QUkVSRU5ERVJfSU5URVJSVVBURURcbiAgcmV0dXJuIGVycm9yXG59XG5cbnR5cGUgRGlnZXN0RXJyb3IgPSBFcnJvciAmIHtcbiAgZGlnZXN0OiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJlcmVuZGVySW50ZXJydXB0ZWRFcnJvcihcbiAgZXJyb3I6IHVua25vd25cbik6IGVycm9yIGlzIERpZ2VzdEVycm9yIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmXG4gICAgZXJyb3IgIT09IG51bGwgJiZcbiAgICAoZXJyb3IgYXMgYW55KS5kaWdlc3QgPT09IE5FWFRfUFJFUkVOREVSX0lOVEVSUlVQVEVEICYmXG4gICAgJ25hbWUnIGluIGVycm9yICYmXG4gICAgJ21lc3NhZ2UnIGluIGVycm9yICYmXG4gICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhY2Nlc3NlZER5bmFtaWNEYXRhKFxuICBkeW5hbWljQWNjZXNzZXM6IEFycmF5PER5bmFtaWNBY2Nlc3M+XG4pOiBib29sZWFuIHtcbiAgcmV0dXJuIGR5bmFtaWNBY2Nlc3Nlcy5sZW5ndGggPiAwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdW1lRHluYW1pY0FjY2VzcyhcbiAgc2VydmVyRHluYW1pYzogRHluYW1pY1RyYWNraW5nU3RhdGUsXG4gIGNsaWVudER5bmFtaWM6IER5bmFtaWNUcmFja2luZ1N0YXRlXG4pOiBEeW5hbWljVHJhY2tpbmdTdGF0ZVsnZHluYW1pY0FjY2Vzc2VzJ10ge1xuICAvLyBXZSBtdXRhdGUgYmVjYXVzZSB3ZSBvbmx5IGNhbGwgdGhpcyBvbmNlIHdlIGFyZSBubyBsb25nZXIgd3JpdGluZ1xuICAvLyB0byB0aGUgZHluYW1pY1RyYWNraW5nU3RhdGUgYW5kIGl0J3MgbW9yZSBlZmZpY2llbnQgdGhhbiBjcmVhdGluZyBhIG5ld1xuICAvLyBhcnJheS5cbiAgc2VydmVyRHluYW1pYy5keW5hbWljQWNjZXNzZXMucHVzaCguLi5jbGllbnREeW5hbWljLmR5bmFtaWNBY2Nlc3NlcylcbiAgcmV0dXJuIHNlcnZlckR5bmFtaWMuZHluYW1pY0FjY2Vzc2VzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREeW5hbWljQVBJQWNjZXNzZXMoXG4gIGR5bmFtaWNBY2Nlc3NlczogQXJyYXk8RHluYW1pY0FjY2Vzcz5cbik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIGR5bmFtaWNBY2Nlc3Nlc1xuICAgIC5maWx0ZXIoXG4gICAgICAoYWNjZXNzKTogYWNjZXNzIGlzIFJlcXVpcmVkPER5bmFtaWNBY2Nlc3M+ID0+XG4gICAgICAgIHR5cGVvZiBhY2Nlc3Muc3RhY2sgPT09ICdzdHJpbmcnICYmIGFjY2Vzcy5zdGFjay5sZW5ndGggPiAwXG4gICAgKVxuICAgIC5tYXAoKHsgZXhwcmVzc2lvbiwgc3RhY2sgfSkgPT4ge1xuICAgICAgc3RhY2sgPSBzdGFja1xuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgXCJFcnJvcjogXCIgcHJlZml4IGZyb20gdGhlIGZpcnN0IGxpbmUgb2YgdGhlIHN0YWNrIHRyYWNlIGFzXG4gICAgICAgIC8vIHdlbGwgYXMgdGhlIGZpcnN0IDQgbGluZXMgb2YgdGhlIHN0YWNrIHRyYWNlIHdoaWNoIGlzIHRoZSBkaXN0YW5jZVxuICAgICAgICAvLyBmcm9tIHRoZSB1c2VyIGNvZGUgYW5kIHRoZSBgbmV3IEVycm9yKCkuc3RhY2tgIGNhbGwuXG4gICAgICAgIC5zbGljZSg0KVxuICAgICAgICAuZmlsdGVyKChsaW5lKSA9PiB7XG4gICAgICAgICAgLy8gRXhjbHVkZSBOZXh0LmpzIGludGVybmFscyBmcm9tIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgICAgICBpZiAobGluZS5pbmNsdWRlcygnbm9kZV9tb2R1bGVzL25leHQvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEV4Y2x1ZGUgYW5vbnltb3VzIGZ1bmN0aW9ucyBmcm9tIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgICAgICBpZiAobGluZS5pbmNsdWRlcygnICg8YW5vbnltb3VzPiknKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRXhjbHVkZSBOb2RlLmpzIGludGVybmFscyBmcm9tIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgICAgICBpZiAobGluZS5pbmNsdWRlcygnIChub2RlOicpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICAgIHJldHVybiBgRHluYW1pYyBBUEkgVXNhZ2UgRGVidWcgLSAke2V4cHJlc3Npb259OlxcbiR7c3RhY2t9YFxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIGFzc2VydFBvc3Rwb25lKCkge1xuICBpZiAoIWhhc1Bvc3Rwb25lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFyaWFudDogUmVhY3QudW5zdGFibGVfcG9zdHBvbmUgaXMgbm90IGRlZmluZWQuIFRoaXMgc3VnZ2VzdHMgdGhlIHdyb25nIHZlcnNpb24gb2YgUmVhY3Qgd2FzIGxvYWRlZC4gVGhpcyBpcyBhIGJ1ZyBpbiBOZXh0LmpzYFxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrIHRvIGFsbG93IHVzIHRvIGFib3J0IGEgcmVuZGVyIHVzaW5nIGEgUG9zdHBvbmUgaW5zdGFuY2UgaW5zdGVhZCBvZiBhbiBFcnJvciB3aGljaCBjaGFuZ2VzIFJlYWN0J3NcbiAqIGFib3J0IHNlbWFudGljcyBzbGlnaHRseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBvc3Rwb25lZEFib3J0U2lnbmFsKHJlYXNvbjogc3RyaW5nKTogQWJvcnRTaWduYWwge1xuICBhc3NlcnRQb3N0cG9uZSgpXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgLy8gV2UgZ2V0IG91ciBoYW5kcyBvbiBhIHBvc3Rwb25lIGluc3RhbmNlIGJ5IGNhbGxpbmcgcG9zdHBvbmUgYW5kIGNhdGNoaW5nIHRoZSB0aHJvd1xuICB0cnkge1xuICAgIFJlYWN0LnVuc3RhYmxlX3Bvc3Rwb25lKHJlYXNvbilcbiAgfSBjYXRjaCAoeDogdW5rbm93bikge1xuICAgIGNvbnRyb2xsZXIuYWJvcnQoeClcbiAgfVxuICByZXR1cm4gY29udHJvbGxlci5zaWduYWxcbn1cblxuLyoqXG4gKiBJbiBhIHByZXJlbmRlciwgd2UgbWF5IGVuZCB1cCB3aXRoIGhhbmdpbmcgUHJvbWlzZXMgYXMgaW5wdXRzIGR1ZSB0aGVtXG4gKiBzdGFsbGluZyBvbiBjb25uZWN0aW9uKCkgb3IgYmVjYXVzZSB0aGV5J3JlIGxvYWRpbmcgZHluYW1pYyBkYXRhLiBJbiB0aGF0XG4gKiBjYXNlIHdlIG5lZWQgdG8gYWJvcnQgdGhlIGVuY29kaW5nIG9mIGFyZ3VtZW50cyBzaW5jZSB0aGV5J2xsIG5ldmVyIGNvbXBsZXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFuZ2luZ0lucHV0QWJvcnRTaWduYWwoXG4gIHdvcmtVbml0U3RvcmU6IFByZXJlbmRlclN0b3JlTW9kZXJuXG4pOiBBYm9ydFNpZ25hbCB7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblxuICBpZiAod29ya1VuaXRTdG9yZS5jYWNoZVNpZ25hbCkge1xuICAgIC8vIElmIHdlIGhhdmUgYSBjYWNoZVNpZ25hbCBpdCBtZWFucyB3ZSdyZSBpbiBhIHByb3NwZWN0aXZlIHJlbmRlci4gSWYgdGhlIGlucHV0XG4gICAgLy8gd2UncmUgd2FpdGluZyBvbiBpcyBjb21pbmcgZnJvbSBhbm90aGVyIGNhY2hlLCB3ZSBkbyB3YW50IHRvIHdhaXQgZm9yIGl0IHNvIHRoYXRcbiAgICAvLyB3ZSBjYW4gcmVzb2x2ZSB0aGlzIGNhY2hlIGVudHJ5IHRvby5cbiAgICB3b3JrVW5pdFN0b3JlLmNhY2hlU2lnbmFsLmlucHV0UmVhZHkoKS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlIHdlJ3JlIGluIHRoZSBmaW5hbCByZW5kZXIgYW5kIHdlIHNob3VsZCBhbHJlYWR5IGhhdmUgYWxsIG91ciBjYWNoZXNcbiAgICAvLyBmaWxsZWQuIFdlIG1pZ2h0IHN0aWxsIGJlIHdhaXRpbmcgb24gc29tZSBtaWNyb3Rhc2tzIHNvIHdlIHdhaXQgb25lIHRpY2sgYmVmb3JlXG4gICAgLy8gZ2l2aW5nIHVwLiBXaGVuIHdlIGdpdmUgdXAsIHdlIHN0aWxsIHdhbnQgdG8gcmVuZGVyIHRoZSBjb250ZW50IG9mIHRoaXMgY2FjaGVcbiAgICAvLyBhcyBkZWVwbHkgYXMgd2UgY2FuIHNvIHRoYXQgd2UgY2FuIHN1c3BlbmQgYXMgZGVlcGx5IGFzIHBvc3NpYmxlIGluIHRoZSB0cmVlXG4gICAgLy8gb3Igbm90IGF0IGFsbCBpZiB3ZSBkb24ndCBlbmQgdXAgd2FpdGluZyBmb3IgdGhlIGlucHV0LlxuICAgIHNjaGVkdWxlT25OZXh0VGljaygoKSA9PiBjb250cm9sbGVyLmFib3J0KCkpXG4gIH1cblxuICByZXR1cm4gY29udHJvbGxlci5zaWduYWxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFubm90YXRlRHluYW1pY0FjY2VzcyhcbiAgZXhwcmVzc2lvbjogc3RyaW5nLFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVNb2Rlcm5cbikge1xuICBjb25zdCBkeW5hbWljVHJhY2tpbmcgPSBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgaWYgKGR5bmFtaWNUcmFja2luZykge1xuICAgIGR5bmFtaWNUcmFja2luZy5keW5hbWljQWNjZXNzZXMucHVzaCh7XG4gICAgICBzdGFjazogZHluYW1pY1RyYWNraW5nLmlzRGVidWdEeW5hbWljQWNjZXNzZXNcbiAgICAgICAgPyBuZXcgRXJyb3IoKS5zdGFja1xuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIGV4cHJlc3Npb24sXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRHluYW1pY1JvdXRlUGFyYW1zKGV4cHJlc3Npb246IHN0cmluZykge1xuICBjb25zdCB3b3JrU3RvcmUgPSB3b3JrQXN5bmNTdG9yYWdlLmdldFN0b3JlKClcblxuICBpZiAoXG4gICAgd29ya1N0b3JlICYmXG4gICAgd29ya1N0b3JlLmlzU3RhdGljR2VuZXJhdGlvbiAmJlxuICAgIHdvcmtTdG9yZS5mYWxsYmFja1JvdXRlUGFyYW1zICYmXG4gICAgd29ya1N0b3JlLmZhbGxiYWNrUm91dGVQYXJhbXMuc2l6ZSA+IDBcbiAgKSB7XG4gICAgLy8gVGhlcmUgYXJlIGZhbGxiYWNrIHJvdXRlIHBhcmFtcywgd2Ugc2hvdWxkIHRyYWNrIHRoZXNlIGFzIGR5bmFtaWNcbiAgICAvLyBhY2Nlc3Nlcy5cbiAgICBjb25zdCB3b3JrVW5pdFN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICAgIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgICAvLyBXZSdyZSBwcmVyZW5kZXJpbmcgd2l0aCBkeW5hbWljSU8gb3IgUFBSIG9yIGJvdGhcbiAgICAgIGlmICh3b3JrVW5pdFN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItY2xpZW50Jykge1xuICAgICAgICAvLyBXZSBhcmUgaW4gYSBwcmVyZW5kZXIgd2l0aCBkeW5hbWljSU8gc2VtYW50aWNzXG4gICAgICAgIC8vIFdlIGFyZSBnb2luZyB0byBoYW5nIGhlcmUgYW5kIG5ldmVyIHJlc29sdmUuIFRoaXMgd2lsbCBjYXVzZSB0aGUgY3VycmVudGx5XG4gICAgICAgIC8vIHJlbmRlcmluZyBjb21wb25lbnQgdG8gZWZmZWN0aXZlbHkgYmUgYSBkeW5hbWljIGhvbGVcbiAgICAgICAgUmVhY3QudXNlKG1ha2VIYW5naW5nUHJvbWlzZSh3b3JrVW5pdFN0b3JlLnJlbmRlclNpZ25hbCwgZXhwcmVzc2lvbikpXG4gICAgICB9IGVsc2UgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICAgIC8vIFdlJ3JlIHByZXJlbmRlcmluZyB3aXRoIFBQUlxuICAgICAgICBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgICAgICAgICB3b3JrU3RvcmUucm91dGUsXG4gICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICB3b3JrVW5pdFN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1sZWdhY3knKSB7XG4gICAgICAgIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKGV4cHJlc3Npb24sIHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaGFzU3VzcGVuc2VSZWdleCA9IC9cXG5cXHMrYXQgU3VzcGVuc2UgXFwoPGFub255bW91cz5cXCkvXG5jb25zdCBoYXNTdXNwZW5zZUFmdGVyQm9keU9ySHRtbFJlZ2V4ID1cbiAgL1xcblxccythdCAoPzpib2R5fGh0bWwpIFxcKDxhbm9ueW1vdXM+XFwpW1xcc1xcU10qP1xcblxccythdCBTdXNwZW5zZSBcXCg8YW5vbnltb3VzPlxcKS9cbmNvbnN0IGhhc01ldGFkYXRhUmVnZXggPSBuZXcgUmVnRXhwKFxuICBgXFxcXG5cXFxccythdCAke01FVEFEQVRBX0JPVU5EQVJZX05BTUV9W1xcXFxuXFxcXHNdYFxuKVxuY29uc3QgaGFzVmlld3BvcnRSZWdleCA9IG5ldyBSZWdFeHAoXG4gIGBcXFxcblxcXFxzK2F0ICR7VklFV1BPUlRfQk9VTkRBUllfTkFNRX1bXFxcXG5cXFxcc11gXG4pXG5jb25zdCBoYXNPdXRsZXRSZWdleCA9IG5ldyBSZWdFeHAoYFxcXFxuXFxcXHMrYXQgJHtPVVRMRVRfQk9VTkRBUllfTkFNRX1bXFxcXG5cXFxcc11gKVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhY2tBbGxvd2VkRHluYW1pY0FjY2VzcyhcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmUsXG4gIGNvbXBvbmVudFN0YWNrOiBzdHJpbmcsXG4gIGR5bmFtaWNWYWxpZGF0aW9uOiBEeW5hbWljVmFsaWRhdGlvblN0YXRlLFxuICBjbGllbnREeW5hbWljOiBEeW5hbWljVHJhY2tpbmdTdGF0ZVxuKSB7XG4gIGlmIChoYXNPdXRsZXRSZWdleC50ZXN0KGNvbXBvbmVudFN0YWNrKSkge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gdHJhY2sgdGhhdCB0aGlzIGlzIGR5bmFtaWMuIEl0IGlzIG9ubHkgc28gd2hlbiBzb21ldGhpbmcgZWxzZSBpcyBhbHNvIGR5bmFtaWMuXG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAoaGFzTWV0YWRhdGFSZWdleC50ZXN0KGNvbXBvbmVudFN0YWNrKSkge1xuICAgIGR5bmFtaWNWYWxpZGF0aW9uLmhhc0R5bmFtaWNNZXRhZGF0YSA9IHRydWVcbiAgICByZXR1cm5cbiAgfSBlbHNlIGlmIChoYXNWaWV3cG9ydFJlZ2V4LnRlc3QoY29tcG9uZW50U3RhY2spKSB7XG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzRHluYW1pY1ZpZXdwb3J0ID0gdHJ1ZVxuICAgIHJldHVyblxuICB9IGVsc2UgaWYgKGhhc1N1c3BlbnNlQWZ0ZXJCb2R5T3JIdG1sUmVnZXgudGVzdChjb21wb25lbnRTdGFjaykpIHtcbiAgICAvLyBUaGlzIHByZXJlbmRlciBoYXMgYSBTdXNwZW5zZSBib3VuZGFyeSBhYm92ZSB0aGUgYm9keSB3aGljaFxuICAgIC8vIGVmZmVjdGl2ZWx5IG9wdHMgdGhlIHBhZ2UgaW50byBhbGxvd2luZyAxMDAlIGR5bmFtaWMgcmVuZGVyaW5nXG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzQWxsb3dlZER5bmFtaWMgPSB0cnVlXG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzU3VzcGVuc2VBYm92ZUJvZHkgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAoaGFzU3VzcGVuc2VSZWdleC50ZXN0KGNvbXBvbmVudFN0YWNrKSkge1xuICAgIC8vIHRoaXMgZXJyb3IgaGFkIGEgU3VzcGVuc2UgYm91bmRhcnkgYWJvdmUgaXQgc28gd2UgZG9uJ3QgbmVlZCB0byByZXBvcnQgaXQgYXMgYSBzb3VyY2VcbiAgICAvLyBvZiBkaXNhbGxvd2VkXG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzQWxsb3dlZER5bmFtaWMgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAoY2xpZW50RHluYW1pYy5zeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrKSB7XG4gICAgLy8gVGhpcyB0YXNrIHdhcyB0aGUgdGFzayB0aGF0IGNhbGxlZCB0aGUgc3luYyBlcnJvci5cbiAgICBkeW5hbWljVmFsaWRhdGlvbi5keW5hbWljRXJyb3JzLnB1c2goXG4gICAgICBjbGllbnREeW5hbWljLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2tcbiAgICApXG4gICAgcmV0dXJuXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBSb3V0ZSBcIiR7d29ya1N0b3JlLnJvdXRlfVwiOiBBIGNvbXBvbmVudCBhY2Nlc3NlZCBkYXRhLCBoZWFkZXJzLCBwYXJhbXMsIHNlYXJjaFBhcmFtcywgb3IgYSBzaG9ydC1saXZlZCBjYWNoZSB3aXRob3V0IGEgU3VzcGVuc2UgYm91bmRhcnkgbm9yIGEgXCJ1c2UgY2FjaGVcIiBhYm92ZSBpdC4gU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1wcmVyZW5kZXItbWlzc2luZy1zdXNwZW5zZWBcbiAgICBjb25zdCBlcnJvciA9IGNyZWF0ZUVycm9yV2l0aENvbXBvbmVudE9yT3duZXJTdGFjayhtZXNzYWdlLCBjb21wb25lbnRTdGFjaylcbiAgICBkeW5hbWljVmFsaWRhdGlvbi5keW5hbWljRXJyb3JzLnB1c2goZXJyb3IpXG4gICAgcmV0dXJuXG4gIH1cbn1cblxuLyoqXG4gKiBJbiBkZXYgbW9kZSwgd2UgcHJlZmVyIHVzaW5nIHRoZSBvd25lciBzdGFjaywgb3RoZXJ3aXNlIHRoZSBwcm92aWRlZFxuICogY29tcG9uZW50IHN0YWNrIGlzIHVzZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yV2l0aENvbXBvbmVudE9yT3duZXJTdGFjayhcbiAgbWVzc2FnZTogc3RyaW5nLFxuICBjb21wb25lbnRTdGFjazogc3RyaW5nXG4pIHtcbiAgY29uc3Qgb3duZXJTdGFjayA9XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBSZWFjdC5jYXB0dXJlT3duZXJTdGFja1xuICAgICAgPyBSZWFjdC5jYXB0dXJlT3duZXJTdGFjaygpXG4gICAgICA6IG51bGxcblxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICBlcnJvci5zdGFjayA9IGVycm9yLm5hbWUgKyAnOiAnICsgbWVzc2FnZSArIChvd25lclN0YWNrID8/IGNvbXBvbmVudFN0YWNrKVxuICByZXR1cm4gZXJyb3Jcbn1cblxuZXhwb3J0IGVudW0gUHJlbHVkZVN0YXRlIHtcbiAgRnVsbCA9IDAsXG4gIEVtcHR5ID0gMSxcbiAgRXJyb3JlZCA9IDIsXG59XG5cbmZ1bmN0aW9uIGxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3Iod29ya1N0b3JlOiBXb3JrU3RvcmUsIGVycm9yOiBFcnJvcik6IHZvaWQge1xuICBjb25zb2xlLmVycm9yKGVycm9yKVxuXG4gIGlmICghd29ya1N0b3JlLmRldikge1xuICAgIGlmICh3b3JrU3RvcmUuaGFzUmVhZGFibGVFcnJvclN0YWNrcykge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYFRvIGdldCBhIG1vcmUgZGV0YWlsZWQgc3RhY2sgdHJhY2UgYW5kIHBpbnBvaW50IHRoZSBpc3N1ZSwgc3RhcnQgdGhlIGFwcCBpbiBkZXZlbG9wbWVudCBtb2RlIGJ5IHJ1bm5pbmcgXFxgbmV4dCBkZXZcXGAsIHRoZW4gb3BlbiBcIiR7d29ya1N0b3JlLnJvdXRlfVwiIGluIHlvdXIgYnJvd3NlciB0byBpbnZlc3RpZ2F0ZSB0aGUgZXJyb3IuYFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBUbyBnZXQgYSBtb3JlIGRldGFpbGVkIHN0YWNrIHRyYWNlIGFuZCBwaW5wb2ludCB0aGUgaXNzdWUsIHRyeSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgLSBTdGFydCB0aGUgYXBwIGluIGRldmVsb3BtZW50IG1vZGUgYnkgcnVubmluZyBcXGBuZXh0IGRldlxcYCwgdGhlbiBvcGVuIFwiJHt3b3JrU3RvcmUucm91dGV9XCIgaW4geW91ciBicm93c2VyIHRvIGludmVzdGlnYXRlIHRoZSBlcnJvci5cbiAgLSBSZXJ1biB0aGUgcHJvZHVjdGlvbiBidWlsZCB3aXRoIFxcYG5leHQgYnVpbGQgLS1kZWJ1Zy1wcmVyZW5kZXJcXGAgdG8gZ2VuZXJhdGUgYmV0dGVyIHN0YWNrIHRyYWNlcy5gKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dJZkRpc2FsbG93ZWREeW5hbWljKFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZSxcbiAgcHJlbHVkZTogUHJlbHVkZVN0YXRlLFxuICBkeW5hbWljVmFsaWRhdGlvbjogRHluYW1pY1ZhbGlkYXRpb25TdGF0ZSxcbiAgc2VydmVyRHluYW1pYzogRHluYW1pY1RyYWNraW5nU3RhdGVcbik6IHZvaWQge1xuICBpZiAod29ya1N0b3JlLmludmFsaWREeW5hbWljVXNhZ2VFcnJvcikge1xuICAgIGxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3Iod29ya1N0b3JlLCB3b3JrU3RvcmUuaW52YWxpZER5bmFtaWNVc2FnZUVycm9yKVxuICAgIHRocm93IG5ldyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IoKVxuICB9XG5cbiAgaWYgKHByZWx1ZGUgIT09IFByZWx1ZGVTdGF0ZS5GdWxsKSB7XG4gICAgaWYgKGR5bmFtaWNWYWxpZGF0aW9uLmhhc1N1c3BlbnNlQWJvdmVCb2R5KSB7XG4gICAgICAvLyBUaGlzIHJvdXRlIGhhcyBvcHRlZCBpbnRvIGFsbG93aW5nIGZ1bGx5IGR5bmFtaWMgcmVuZGVyaW5nXG4gICAgICAvLyBieSBpbmNsdWRpbmcgYSBTdXNwZW5zZSBib3VuZGFyeSBhYm92ZSB0aGUgYm9keS4gSW4gdGhpcyBjYXNlXG4gICAgICAvLyBhIGxhY2sgb2YgYSBzaGVsbCBpcyBub3QgY29uc2lkZXJlZCBkaXNhbGxvd2VkIHNvIHdlIHNpbXBseSByZXR1cm5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChzZXJ2ZXJEeW5hbWljLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2spIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIHNoZWxsIGFuZCB0aGUgc2VydmVyIGRpZCBzb21ldGhpbmcgc3luYyBkeW5hbWljIGxpa2VseVxuICAgICAgLy8gbGVhZGluZyB0byBhbiBlYXJseSB0ZXJtaW5hdGlvbiBvZiB0aGUgcHJlcmVuZGVyIGJlZm9yZSB0aGUgc2hlbGxcbiAgICAgIC8vIGNvdWxkIGJlIGNvbXBsZXRlZC4gV2UgdGVybWluYXRlIHRoZSBidWlsZC92YWxpZGF0aW5nIHJlbmRlci5cbiAgICAgIGxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3IoXG4gICAgICAgIHdvcmtTdG9yZSxcbiAgICAgICAgc2VydmVyRHluYW1pYy5zeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrXG4gICAgICApXG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKClcbiAgICB9XG5cbiAgICAvLyBXZSBkaWRuJ3QgaGF2ZSBhbnkgc3luYyBiYWlsb3V0cyBidXQgdGhlcmUgbWF5IGJlIHVzZXIgY29kZSB3aGljaFxuICAgIC8vIGJsb2NrZWQgdGhlIHJvb3QuIFdlIHdvdWxkIGhhdmUgY2FwdHVyZWQgdGhlc2UgZHVyaW5nIHRoZSBwcmVyZW5kZXJcbiAgICAvLyBhbmQgY2FuIGxvZyB0aGVtIGhlcmUgYW5kIHRoZW4gdGVybWluYXRlIHRoZSBidWlsZC92YWxpZGF0aW5nIHJlbmRlclxuICAgIGNvbnN0IGR5bmFtaWNFcnJvcnMgPSBkeW5hbWljVmFsaWRhdGlvbi5keW5hbWljRXJyb3JzXG4gICAgaWYgKGR5bmFtaWNFcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3Iod29ya1N0b3JlLCBkeW5hbWljRXJyb3JzW2ldKVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKClcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIgdGhlbiB0aGUgb25seSBvdGhlciB0aGluZyB0aGF0IGNvdWxkIGJlIGJsb2NraW5nXG4gICAgLy8gdGhlIHJvb3QgaXMgZHluYW1pYyBWaWV3cG9ydC4gSWYgdGhpcyBpcyBkeW5hbWljIHRoZW5cbiAgICAvLyB5b3UgbmVlZCB0byBvcHQgaW50byB0aGF0IGJ5IGFkZGluZyBhIFN1c3BlbnNlIGJvdW5kYXJ5IGFib3ZlIHRoZSBib2R5XG4gICAgLy8gdG8gaW5kaWNhdGUgeW91ciBhcmUgb2sgd2l0aCBmdWxseSBkeW5hbWljIHJlbmRlcmluZy5cbiAgICBpZiAoZHluYW1pY1ZhbGlkYXRpb24uaGFzRHluYW1pY1ZpZXdwb3J0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgUm91dGUgXCIke3dvcmtTdG9yZS5yb3V0ZX1cIiBoYXMgYSBcXGBnZW5lcmF0ZVZpZXdwb3J0XFxgIHRoYXQgZGVwZW5kcyBvbiBSZXF1ZXN0IGRhdGEgKFxcYGNvb2tpZXMoKVxcYCwgZXRjLi4uKSBvciB1bmNhY2hlZCBleHRlcm5hbCBkYXRhIChcXGBmZXRjaCguLi4pXFxgLCBldGMuLi4pIHdpdGhvdXQgZXhwbGljaXRseSBhbGxvd2luZyBmdWxseSBkeW5hbWljIHJlbmRlcmluZy4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LXByZXJlbmRlci1keW5hbWljLXZpZXdwb3J0YFxuICAgICAgKVxuICAgICAgdGhyb3cgbmV3IFN0YXRpY0dlbkJhaWxvdXRFcnJvcigpXG4gICAgfVxuXG4gICAgaWYgKHByZWx1ZGUgPT09IFByZWx1ZGVTdGF0ZS5FbXB0eSkge1xuICAgICAgLy8gSWYgd2UgZXZlciBnZXQgdGhpcyBmYXIgdGhlbiB3ZSBtZXNzZWQgdXAgdGhlIHRyYWNraW5nIG9mIGludmFsaWQgZHluYW1pYy5cbiAgICAgIC8vIFdlIHN0aWxsIGFkaGVyZSB0byB0aGUgY29uc3RyYWludCB0aGF0IHlvdSBtdXN0IHByb2R1Y2UgYSBzaGVsbCBidXQgaW52aXRlIHRoZVxuICAgICAgLy8gdXNlciB0byByZXBvcnQgdGhpcyBhcyBhIGJ1ZyBpbiBOZXh0LmpzLlxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYFJvdXRlIFwiJHt3b3JrU3RvcmUucm91dGV9XCIgZGlkIG5vdCBwcm9kdWNlIGEgc3RhdGljIHNoZWxsIGFuZCBOZXh0LmpzIHdhcyB1bmFibGUgdG8gZGV0ZXJtaW5lIGEgcmVhc29uLiBUaGlzIGlzIGEgYnVnIGluIE5leHQuanMuYFxuICAgICAgKVxuICAgICAgdGhyb3cgbmV3IFN0YXRpY0dlbkJhaWxvdXRFcnJvcigpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChcbiAgICAgIGR5bmFtaWNWYWxpZGF0aW9uLmhhc0FsbG93ZWREeW5hbWljID09PSBmYWxzZSAmJlxuICAgICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzRHluYW1pY01ldGFkYXRhXG4gICAgKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgUm91dGUgXCIke3dvcmtTdG9yZS5yb3V0ZX1cIiBoYXMgYSBcXGBnZW5lcmF0ZU1ldGFkYXRhXFxgIHRoYXQgZGVwZW5kcyBvbiBSZXF1ZXN0IGRhdGEgKFxcYGNvb2tpZXMoKVxcYCwgZXRjLi4uKSBvciB1bmNhY2hlZCBleHRlcm5hbCBkYXRhIChcXGBmZXRjaCguLi4pXFxgLCBldGMuLi4pIHdoZW4gdGhlIHJlc3Qgb2YgdGhlIHJvdXRlIGRvZXMgbm90LiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtcHJlcmVuZGVyLWR5bmFtaWMtbWV0YWRhdGFgXG4gICAgICApXG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKClcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJQb3N0cG9uZSIsIlByZWx1ZGVTdGF0ZSIsImFib3J0QW5kVGhyb3dPblN5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3MiLCJhYm9ydE9uU3luY2hyb25vdXNQbGF0Zm9ybUlPQWNjZXNzIiwiYWNjZXNzZWREeW5hbWljRGF0YSIsImFubm90YXRlRHluYW1pY0FjY2VzcyIsImNvbnN1bWVEeW5hbWljQWNjZXNzIiwiY3JlYXRlRHluYW1pY1RyYWNraW5nU3RhdGUiLCJjcmVhdGVEeW5hbWljVmFsaWRhdGlvblN0YXRlIiwiY3JlYXRlSGFuZ2luZ0lucHV0QWJvcnRTaWduYWwiLCJjcmVhdGVQb3N0cG9uZWRBYm9ydFNpZ25hbCIsImZvcm1hdER5bmFtaWNBUElBY2Nlc3NlcyIsImdldEZpcnN0RHluYW1pY1JlYXNvbiIsImlzRHluYW1pY1Bvc3Rwb25lIiwiaXNQcmVyZW5kZXJJbnRlcnJ1cHRlZEVycm9yIiwibWFya0N1cnJlbnRTY29wZUFzRHluYW1pYyIsInBvc3Rwb25lV2l0aFRyYWNraW5nIiwidGhyb3dJZkRpc2FsbG93ZWREeW5hbWljIiwidGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24iLCJ0cmFja0FsbG93ZWREeW5hbWljQWNjZXNzIiwidHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlciIsInRyYWNrRmFsbGJhY2tQYXJhbUFjY2Vzc2VkIiwidHJhY2tTeW5jaHJvbm91c1BsYXRmb3JtSU9BY2Nlc3NJbkRldiIsInRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2IiwidXNlRHluYW1pY1JvdXRlUGFyYW1zIiwiaGFzUG9zdHBvbmUiLCJSZWFjdCIsInVuc3RhYmxlX3Bvc3Rwb25lIiwiaXNEZWJ1Z0R5bmFtaWNBY2Nlc3NlcyIsImR5bmFtaWNBY2Nlc3NlcyIsInN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2siLCJoYXNTdXNwZW5zZUFib3ZlQm9keSIsImhhc0R5bmFtaWNNZXRhZGF0YSIsImhhc0R5bmFtaWNWaWV3cG9ydCIsImhhc0FsbG93ZWREeW5hbWljIiwiZHluYW1pY0Vycm9ycyIsInRyYWNraW5nU3RhdGUiLCJleHByZXNzaW9uIiwic3RvcmUiLCJ3b3JrVW5pdFN0b3JlIiwidHlwZSIsImZvcmNlRHluYW1pYyIsImZvcmNlU3RhdGljIiwiZHluYW1pY1Nob3VsZEVycm9yIiwiU3RhdGljR2VuQmFpbG91dEVycm9yIiwicm91dGUiLCJkeW5hbWljVHJhY2tpbmciLCJyZXZhbGlkYXRlIiwiZXJyIiwiRHluYW1pY1NlcnZlckVycm9yIiwiZHluYW1pY1VzYWdlRGVzY3JpcHRpb24iLCJkeW5hbWljVXNhZ2VTdGFjayIsInN0YWNrIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwidXNlZER5bmFtaWMiLCJwcmVyZW5kZXJTdG9yZSIsIndvcmtVbml0QXN5bmNTdG9yYWdlIiwiZ2V0U3RvcmUiLCJfc3RvcmUiLCJhYm9ydE9uU3luY2hyb25vdXNEeW5hbWljRGF0YUFjY2VzcyIsInJlYXNvbiIsImVycm9yIiwiY3JlYXRlUHJlcmVuZGVySW50ZXJydXB0ZWRFcnJvciIsImNvbnRyb2xsZXIiLCJhYm9ydCIsInB1c2giLCJFcnJvciIsInVuZGVmaW5lZCIsImVycm9yV2l0aFN0YWNrIiwicmVxdWVzdFN0b3JlIiwicHJlcmVuZGVyUGhhc2UiLCJwcmVyZW5kZXJTaWduYWwiLCJzaWduYWwiLCJhYm9ydGVkIiwiYXNzZXJ0UG9zdHBvbmUiLCJjcmVhdGVQb3N0cG9uZVJlYXNvbiIsIm1lc3NhZ2UiLCJpc0R5bmFtaWNQb3N0cG9uZVJlYXNvbiIsImluY2x1ZGVzIiwiTkVYVF9QUkVSRU5ERVJfSU5URVJSVVBURUQiLCJkaWdlc3QiLCJsZW5ndGgiLCJzZXJ2ZXJEeW5hbWljIiwiY2xpZW50RHluYW1pYyIsImZpbHRlciIsImFjY2VzcyIsIm1hcCIsInNwbGl0Iiwic2xpY2UiLCJsaW5lIiwiam9pbiIsIkFib3J0Q29udHJvbGxlciIsIngiLCJjYWNoZVNpZ25hbCIsImlucHV0UmVhZHkiLCJ0aGVuIiwic2NoZWR1bGVPbk5leHRUaWNrIiwid29ya1N0b3JlIiwid29ya0FzeW5jU3RvcmFnZSIsImlzU3RhdGljR2VuZXJhdGlvbiIsImZhbGxiYWNrUm91dGVQYXJhbXMiLCJzaXplIiwidXNlIiwibWFrZUhhbmdpbmdQcm9taXNlIiwicmVuZGVyU2lnbmFsIiwiaGFzU3VzcGVuc2VSZWdleCIsImhhc1N1c3BlbnNlQWZ0ZXJCb2R5T3JIdG1sUmVnZXgiLCJoYXNNZXRhZGF0YVJlZ2V4IiwiUmVnRXhwIiwiTUVUQURBVEFfQk9VTkRBUllfTkFNRSIsImhhc1ZpZXdwb3J0UmVnZXgiLCJWSUVXUE9SVF9CT1VOREFSWV9OQU1FIiwiaGFzT3V0bGV0UmVnZXgiLCJPVVRMRVRfQk9VTkRBUllfTkFNRSIsImNvbXBvbmVudFN0YWNrIiwiZHluYW1pY1ZhbGlkYXRpb24iLCJ0ZXN0IiwiY3JlYXRlRXJyb3JXaXRoQ29tcG9uZW50T3JPd25lclN0YWNrIiwib3duZXJTdGFjayIsImNhcHR1cmVPd25lclN0YWNrIiwibmFtZSIsImxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3IiLCJjb25zb2xlIiwiZGV2IiwiaGFzUmVhZGFibGVFcnJvclN0YWNrcyIsInByZWx1ZGUiLCJpbnZhbGlkRHluYW1pY1VzYWdlRXJyb3IiLCJpIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQkMsR0FpSktxRCxRQUFRQyxHQUFHLENBQUNDLFFBQVE7QUFqSnpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWdWZXZELFFBQVEsRUFBQTtlQUFSQTs7SUEyVEpDLFlBQVksRUFBQTtlQUFaQTs7SUFwV0lDLDJDQUEyQyxFQUFBO2VBQTNDQTs7SUFyQ0FDLGtDQUFrQyxFQUFBO2VBQWxDQTs7SUF3S0FDLG1CQUFtQixFQUFBO2VBQW5CQTs7SUE0R0FDLHFCQUFxQixFQUFBO2VBQXJCQTs7SUF0R0FDLG9CQUFvQixFQUFBO2VBQXBCQTs7SUEvV0FDLDBCQUEwQixFQUFBO2VBQTFCQTs7SUFVQUMsNEJBQTRCLEVBQUE7ZUFBNUJBOztJQW1iQUMsNkJBQTZCLEVBQUE7ZUFBN0JBOztJQWpCQUMsMEJBQTBCLEVBQUE7ZUFBMUJBOztJQWxEQUMsd0JBQXdCLEVBQUE7ZUFBeEJBOztJQXRXQUMscUJBQXFCLEVBQUE7ZUFBckJBOztJQWdTQUMsaUJBQWlCLEVBQUE7ZUFBakJBOztJQXdDQUMsMkJBQTJCLEVBQUE7ZUFBM0JBOztJQTNUQUMseUJBQXlCLEVBQUE7ZUFBekJBOztJQXVQQUMsb0JBQW9CLEVBQUE7ZUFBcEJBOztJQXdVQUMsd0JBQXdCLEVBQUE7ZUFBeEJBOztJQS9lQUMsZ0NBQWdDLEVBQUE7ZUFBaENBOztJQStaQUMseUJBQXlCLEVBQUE7ZUFBekJBOztJQXRZQUMsK0JBQStCLEVBQUE7ZUFBL0JBOztJQXpDQUMsMEJBQTBCLEVBQUE7ZUFBMUJBOztJQW1IQUMscUNBQXFDLEVBQUE7ZUFBckNBOztJQWlESEMsc0NBQXNDLEVBQUE7ZUFBdENBOztJQStOR0MscUJBQXFCLEVBQUE7ZUFBckJBOzs7OERBMWhCRTtvQ0FFaUI7eUNBQ0c7OENBQ0Q7MENBQ0o7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Q21GLGtCQUFrQnJGLGtCQUFrQixFQUNwQztZQUNBNEYsUUFBUTdELEtBQUssQ0FDWCxBQUFDLE9BQU8sVUFBRW9DLFVBQVV0RCxLQUFLLEVBQUMsOFBBQThQLENBQUM7WUFFM1IsTUFBTSxJQUFJRCx5QkFBQUEscUJBQXFCO1FBQ2pDO0lBQ0Y7QUFDRiIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAzNzU1LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvc3JjL3NlcnZlci9kZXYvaG90LXJlbG9hZGVyLXR5cGVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgSW5jb21pbmdNZXNzYWdlLCBTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJ2h0dHAnXG5pbXBvcnQgdHlwZSB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB0eXBlIHsgRHVwbGV4IH0gZnJvbSAnc3RyZWFtJ1xuaW1wb3J0IHR5cGUgeyB3ZWJwYWNrIH0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3dlYnBhY2svd2VicGFjaydcbmltcG9ydCB0eXBlIGdldEJhc2VXZWJwYWNrQ29uZmlnIGZyb20gJy4uLy4uL2J1aWxkL3dlYnBhY2stY29uZmlnJ1xuaW1wb3J0IHR5cGUgeyBSb3V0ZURlZmluaXRpb24gfSBmcm9tICcuLi9yb3V0ZS1kZWZpbml0aW9ucy9yb3V0ZS1kZWZpbml0aW9uJ1xuaW1wb3J0IHR5cGUgeyBQcm9qZWN0LCBVcGRhdGUgYXMgVHVyYm9wYWNrVXBkYXRlIH0gZnJvbSAnLi4vLi4vYnVpbGQvc3djL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBWZXJzaW9uSW5mbyB9IGZyb20gJy4vcGFyc2UtdmVyc2lvbi1pbmZvJ1xuaW1wb3J0IHR5cGUgeyBEZWJ1Z0luZm8gfSBmcm9tICcuLi8uLi9uZXh0LWRldnRvb2xzL3NoYXJlZC90eXBlcydcbmltcG9ydCB0eXBlIHsgRGV2SW5kaWNhdG9yU2VydmVyU3RhdGUgfSBmcm9tICcuL2Rldi1pbmRpY2F0b3Itc2VydmVyLXN0YXRlJ1xuXG5leHBvcnQgY29uc3QgZW51bSBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIge1xuICBBRERFRF9QQUdFID0gJ2FkZGVkUGFnZScsXG4gIFJFTU9WRURfUEFHRSA9ICdyZW1vdmVkUGFnZScsXG4gIFJFTE9BRF9QQUdFID0gJ3JlbG9hZFBhZ2UnLFxuICBTRVJWRVJfQ09NUE9ORU5UX0NIQU5HRVMgPSAnc2VydmVyQ29tcG9uZW50Q2hhbmdlcycsXG4gIE1JRERMRVdBUkVfQ0hBTkdFUyA9ICdtaWRkbGV3YXJlQ2hhbmdlcycsXG4gIENMSUVOVF9DSEFOR0VTID0gJ2NsaWVudENoYW5nZXMnLFxuICBTRVJWRVJfT05MWV9DSEFOR0VTID0gJ3NlcnZlck9ubHlDaGFuZ2VzJyxcbiAgU1lOQyA9ICdzeW5jJyxcbiAgQlVJTFQgPSAnYnVpbHQnLFxuICBCVUlMRElORyA9ICdidWlsZGluZycsXG4gIERFVl9QQUdFU19NQU5JRkVTVF9VUERBVEUgPSAnZGV2UGFnZXNNYW5pZmVzdFVwZGF0ZScsXG4gIFRVUkJPUEFDS19NRVNTQUdFID0gJ3R1cmJvcGFjay1tZXNzYWdlJyxcbiAgU0VSVkVSX0VSUk9SID0gJ3NlcnZlckVycm9yJyxcbiAgVFVSQk9QQUNLX0NPTk5FQ1RFRCA9ICd0dXJib3BhY2stY29ubmVjdGVkJyxcbiAgSVNSX01BTklGRVNUID0gJ2lzck1hbmlmZXN0JyxcbiAgREVWX0lORElDQVRPUiA9ICdkZXZJbmRpY2F0b3InLFxufVxuXG5pbnRlcmZhY2UgU2VydmVyRXJyb3JBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5TRVJWRVJfRVJST1JcbiAgZXJyb3JKU09OOiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUdXJib3BhY2tNZXNzYWdlQWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuVFVSQk9QQUNLX01FU1NBR0VcbiAgZGF0YTogVHVyYm9wYWNrVXBkYXRlIHwgVHVyYm9wYWNrVXBkYXRlW11cbn1cblxuaW50ZXJmYWNlIEJ1aWxkaW5nQWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuQlVJTERJTkdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21waWxhdGlvbkVycm9yIHtcbiAgbW9kdWxlTmFtZT86IHN0cmluZ1xuICBtZXNzYWdlOiBzdHJpbmdcbiAgZGV0YWlscz86IHN0cmluZ1xuICBtb2R1bGVUcmFjZT86IEFycmF5PHsgbW9kdWxlTmFtZT86IHN0cmluZyB9PlxuICBzdGFjaz86IHN0cmluZ1xufVxuZXhwb3J0IGludGVyZmFjZSBTeW5jQWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuU1lOQ1xuICBoYXNoOiBzdHJpbmdcbiAgZXJyb3JzOiBSZWFkb25seUFycmF5PENvbXBpbGF0aW9uRXJyb3I+XG4gIHdhcm5pbmdzOiBSZWFkb25seUFycmF5PENvbXBpbGF0aW9uRXJyb3I+XG4gIHZlcnNpb25JbmZvOiBWZXJzaW9uSW5mb1xuICB1cGRhdGVkTW9kdWxlcz86IFJlYWRvbmx5QXJyYXk8c3RyaW5nPlxuICBkZWJ1Zz86IERlYnVnSW5mb1xuICBkZXZJbmRpY2F0b3I6IERldkluZGljYXRvclNlcnZlclN0YXRlXG59XG5pbnRlcmZhY2UgQnVpbHRBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5CVUlMVFxuICBoYXNoOiBzdHJpbmdcbiAgZXJyb3JzOiBSZWFkb25seUFycmF5PENvbXBpbGF0aW9uRXJyb3I+XG4gIHdhcm5pbmdzOiBSZWFkb25seUFycmF5PENvbXBpbGF0aW9uRXJyb3I+XG4gIHVwZGF0ZWRNb2R1bGVzPzogUmVhZG9ubHlBcnJheTxzdHJpbmc+XG59XG5cbmludGVyZmFjZSBBZGRlZFBhZ2VBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5BRERFRF9QQUdFXG4gIGRhdGE6IFtwYWdlOiBzdHJpbmcgfCBudWxsXVxufVxuXG5pbnRlcmZhY2UgUmVtb3ZlZFBhZ2VBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5SRU1PVkVEX1BBR0VcbiAgZGF0YTogW3BhZ2U6IHN0cmluZyB8IG51bGxdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVsb2FkUGFnZUFjdGlvbiB7XG4gIGFjdGlvbjogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlJFTE9BRF9QQUdFXG4gIGRhdGE6IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgU2VydmVyQ29tcG9uZW50Q2hhbmdlc0FjdGlvbiB7XG4gIGFjdGlvbjogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlNFUlZFUl9DT01QT05FTlRfQ0hBTkdFU1xuICBoYXNoOiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIE1pZGRsZXdhcmVDaGFuZ2VzQWN0aW9uIHtcbiAgZXZlbnQ6IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5NSURETEVXQVJFX0NIQU5HRVNcbn1cblxuaW50ZXJmYWNlIENsaWVudENoYW5nZXNBY3Rpb24ge1xuICBldmVudDogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLkNMSUVOVF9DSEFOR0VTXG59XG5cbmludGVyZmFjZSBTZXJ2ZXJPbmx5Q2hhbmdlc0FjdGlvbiB7XG4gIGV2ZW50OiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuU0VSVkVSX09OTFlfQ0hBTkdFU1xuICBwYWdlczogUmVhZG9ubHlBcnJheTxzdHJpbmc+XG59XG5cbmludGVyZmFjZSBEZXZQYWdlc01hbmlmZXN0VXBkYXRlQWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuREVWX1BBR0VTX01BTklGRVNUX1VQREFURVxuICBkYXRhOiBbXG4gICAge1xuICAgICAgZGV2UGFnZXNNYW5pZmVzdDogdHJ1ZVxuICAgIH0sXG4gIF1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBUdXJib3BhY2tDb25uZWN0ZWRBY3Rpb24ge1xuICBhY3Rpb246IEhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5UVVJCT1BBQ0tfQ09OTkVDVEVEXG4gIGRhdGE6IHsgc2Vzc2lvbklkOiBudW1iZXIgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFwcElzck1hbmlmZXN0QWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuSVNSX01BTklGRVNUXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGV2SW5kaWNhdG9yQWN0aW9uIHtcbiAgYWN0aW9uOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuREVWX0lORElDQVRPUlxuICBkZXZJbmRpY2F0b3I6IERldkluZGljYXRvclNlcnZlclN0YXRlXG59XG5cbmV4cG9ydCB0eXBlIEhNUl9BQ1RJT05fVFlQRVMgPVxuICB8IFR1cmJvcGFja01lc3NhZ2VBY3Rpb25cbiAgfCBUdXJib3BhY2tDb25uZWN0ZWRBY3Rpb25cbiAgfCBCdWlsZGluZ0FjdGlvblxuICB8IFN5bmNBY3Rpb25cbiAgfCBCdWlsdEFjdGlvblxuICB8IEFkZGVkUGFnZUFjdGlvblxuICB8IFJlbW92ZWRQYWdlQWN0aW9uXG4gIHwgUmVsb2FkUGFnZUFjdGlvblxuICB8IFNlcnZlckNvbXBvbmVudENoYW5nZXNBY3Rpb25cbiAgfCBDbGllbnRDaGFuZ2VzQWN0aW9uXG4gIHwgTWlkZGxld2FyZUNoYW5nZXNBY3Rpb25cbiAgfCBTZXJ2ZXJPbmx5Q2hhbmdlc0FjdGlvblxuICB8IERldlBhZ2VzTWFuaWZlc3RVcGRhdGVBY3Rpb25cbiAgfCBTZXJ2ZXJFcnJvckFjdGlvblxuICB8IEFwcElzck1hbmlmZXN0QWN0aW9uXG4gIHwgRGV2SW5kaWNhdG9yQWN0aW9uXG5cbmV4cG9ydCB0eXBlIFR1cmJvcGFja01zZ1RvQnJvd3NlciA9XG4gIHwgeyB0eXBlOiBITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuVFVSQk9QQUNLX01FU1NBR0U7IGRhdGE6IGFueSB9XG4gIHwge1xuICAgICAgdHlwZTogSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlRVUkJPUEFDS19DT05ORUNURURcbiAgICAgIGRhdGE6IHsgc2Vzc2lvbklkOiBudW1iZXIgfVxuICAgIH1cblxuZXhwb3J0IGludGVyZmFjZSBOZXh0SnNIb3RSZWxvYWRlckludGVyZmFjZSB7XG4gIHR1cmJvcGFja1Byb2plY3Q/OiBQcm9qZWN0XG4gIGFjdGl2ZVdlYnBhY2tDb25maWdzPzogQXJyYXk8QXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiBnZXRCYXNlV2VicGFja0NvbmZpZz4+PlxuICBzZXJ2ZXJTdGF0czogd2VicGFjay5TdGF0cyB8IG51bGxcbiAgZWRnZVNlcnZlclN0YXRzOiB3ZWJwYWNrLlN0YXRzIHwgbnVsbFxuICBydW4oXG4gICAgcmVxOiBJbmNvbWluZ01lc3NhZ2UsXG4gICAgcmVzOiBTZXJ2ZXJSZXNwb25zZSxcbiAgICBwYXJzZWRVcmw6IFVybE9iamVjdFxuICApOiBQcm9taXNlPHsgZmluaXNoZWQ/OiB0cnVlIH0+XG5cbiAgc2V0SG1yU2VydmVyRXJyb3IoZXJyb3I6IEVycm9yIHwgbnVsbCk6IHZvaWRcbiAgY2xlYXJIbXJTZXJ2ZXJFcnJvcigpOiB2b2lkXG4gIHN0YXJ0KCk6IFByb21pc2U8dm9pZD5cbiAgc2VuZChhY3Rpb246IEhNUl9BQ1RJT05fVFlQRVMpOiB2b2lkXG4gIGdldENvbXBpbGF0aW9uRXJyb3JzKHBhZ2U6IHN0cmluZyk6IFByb21pc2U8YW55W10+XG4gIG9uSE1SKFxuICAgIHJlcTogSW5jb21pbmdNZXNzYWdlLFxuICAgIF9zb2NrZXQ6IER1cGxleCxcbiAgICBoZWFkOiBCdWZmZXIsXG4gICAgb25VcGdyYWRlOiAoY2xpZW50OiB7IHNlbmQoZGF0YTogc3RyaW5nKTogdm9pZCB9KSA9PiB2b2lkXG4gICk6IHZvaWRcbiAgaW52YWxpZGF0ZSh7XG4gICAgcmVsb2FkQWZ0ZXJJbnZhbGlkYXRpb24sXG4gIH06IHtcbiAgICByZWxvYWRBZnRlckludmFsaWRhdGlvbjogYm9vbGVhblxuICB9KTogUHJvbWlzZTx2b2lkPiB8IHZvaWRcbiAgYnVpbGRGYWxsYmFja0Vycm9yKCk6IFByb21pc2U8dm9pZD5cbiAgZW5zdXJlUGFnZSh7XG4gICAgcGFnZSxcbiAgICBjbGllbnRPbmx5LFxuICAgIGFwcFBhdGhzLFxuICAgIGRlZmluaXRpb24sXG4gICAgaXNBcHAsXG4gICAgdXJsLFxuICB9OiB7XG4gICAgcGFnZTogc3RyaW5nXG4gICAgY2xpZW50T25seTogYm9vbGVhblxuICAgIGFwcFBhdGhzPzogUmVhZG9ubHlBcnJheTxzdHJpbmc+IHwgbnVsbFxuICAgIGlzQXBwPzogYm9vbGVhblxuICAgIGRlZmluaXRpb246IFJvdXRlRGVmaW5pdGlvbiB8IHVuZGVmaW5lZFxuICAgIHVybD86IHN0cmluZ1xuICB9KTogUHJvbWlzZTx2b2lkPlxuICBjbG9zZSgpOiB2b2lkXG59XG4iXSwibmFtZXMiOlsiSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSIl0sIm1hcHBpbmdzIjoiOzs7K0JBV2tCQSwrQkFBQUE7OztlQUFBQTs7O0FBQVgsSUFBV0EsOEJBQUFBLFdBQUFBLEdBQUFBLFNBQUFBLDJCQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7V0FBQUEiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fV0KfQ==