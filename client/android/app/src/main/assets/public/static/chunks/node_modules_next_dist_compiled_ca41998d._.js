(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/next/dist/compiled/process/browser.js [client] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
(function() {
    var e = {
        229: function(e) {
            var t = e.exports = {};
            var r;
            var n;
            function defaultSetTimout() {
                throw new Error("setTimeout has not been defined");
            }
            function defaultClearTimeout() {
                throw new Error("clearTimeout has not been defined");
            }
            (function() {
                try {
                    if (typeof setTimeout === "function") {
                        r = setTimeout;
                    } else {
                        r = defaultSetTimout;
                    }
                } catch (e) {
                    r = defaultSetTimout;
                }
                try {
                    if (typeof clearTimeout === "function") {
                        n = clearTimeout;
                    } else {
                        n = defaultClearTimeout;
                    }
                } catch (e) {
                    n = defaultClearTimeout;
                }
            })();
            function runTimeout(e) {
                if (r === setTimeout) {
                    return setTimeout(e, 0);
                }
                if ((r === defaultSetTimout || !r) && setTimeout) {
                    r = setTimeout;
                    return setTimeout(e, 0);
                }
                try {
                    return r(e, 0);
                } catch (t) {
                    try {
                        return r.call(null, e, 0);
                    } catch (t) {
                        return r.call(this, e, 0);
                    }
                }
            }
            function runClearTimeout(e) {
                if (n === clearTimeout) {
                    return clearTimeout(e);
                }
                if ((n === defaultClearTimeout || !n) && clearTimeout) {
                    n = clearTimeout;
                    return clearTimeout(e);
                }
                try {
                    return n(e);
                } catch (t) {
                    try {
                        return n.call(null, e);
                    } catch (t) {
                        return n.call(this, e);
                    }
                }
            }
            var i = [];
            var o = false;
            var u;
            var a = -1;
            function cleanUpNextTick() {
                if (!o || !u) {
                    return;
                }
                o = false;
                if (u.length) {
                    i = u.concat(i);
                } else {
                    a = -1;
                }
                if (i.length) {
                    drainQueue();
                }
            }
            function drainQueue() {
                if (o) {
                    return;
                }
                var e = runTimeout(cleanUpNextTick);
                o = true;
                var t = i.length;
                while(t){
                    u = i;
                    i = [];
                    while(++a < t){
                        if (u) {
                            u[a].run();
                        }
                    }
                    a = -1;
                    t = i.length;
                }
                u = null;
                o = false;
                runClearTimeout(e);
            }
            t.nextTick = function(e) {
                var t = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for(var r = 1; r < arguments.length; r++){
                        t[r - 1] = arguments[r];
                    }
                }
                i.push(new Item(e, t));
                if (i.length === 1 && !o) {
                    runTimeout(drainQueue);
                }
            };
            function Item(e, t) {
                this.fun = e;
                this.array = t;
            }
            Item.prototype.run = function() {
                this.fun.apply(null, this.array);
            };
            t.title = "browser";
            t.browser = true;
            t.env = {};
            t.argv = [];
            t.version = "";
            t.versions = {};
            function noop() {}
            t.on = noop;
            t.addListener = noop;
            t.once = noop;
            t.off = noop;
            t.removeListener = noop;
            t.removeAllListeners = noop;
            t.emit = noop;
            t.prependListener = noop;
            t.prependOnceListener = noop;
            t.listeners = function(e) {
                return [];
            };
            t.binding = function(e) {
                throw new Error("process.binding is not supported");
            };
            t.cwd = function() {
                return "/";
            };
            t.chdir = function(e) {
                throw new Error("process.chdir is not supported");
            };
            t.umask = function() {
                return 0;
            };
        }
    };
    var t = {};
    function __nccwpck_require__(r) {
        var n = t[r];
        if (n !== undefined) {
            return n.exports;
        }
        var i = t[r] = {
            exports: {}
        };
        var o = true;
        try {
            e[r](i, i.exports, __nccwpck_require__);
            o = false;
        } finally{
            if (o) delete t[r];
        }
        return i.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/process") + "/";
    var r = __nccwpck_require__(229);
    module.exports = r;
})();
}}),
"[project]/node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-refresh-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        // ATTENTION
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.
        // It's OK to reference families, but use WeakMap/Set for types.
        var allFamiliesByID = new Map();
        var allFamiliesByType = new PossiblyWeakMap();
        var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families
        // that have actually been edited here. This keeps checks fast.
        // $FlowIssue
        var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.
        // It is an array of [Family, NextType] tuples.
        var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.
        var helpersByRendererID = new Map();
        var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.
        var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.
        var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.
        // It needs to be weak because we do this even for roots that failed to mount.
        // If there is no WeakMap, we won't attempt to do retrying.
        // $FlowIssue
        var rootElements = typeof WeakMap === 'function' ? new WeakMap() : null;
        var isPerformingRefresh = false;
        function computeFullKey(signature) {
            if (signature.fullKey !== null) {
                return signature.fullKey;
            }
            var fullKey = signature.ownKey;
            var hooks;
            try {
                hooks = signature.getCustomHooks();
            } catch (err) {
                // This can happen in an edge case, e.g. if expression like Foo.useSomething
                // depends on Foo which is lazily initialized during rendering.
                // In that case just assume we'll have to remount.
                signature.forceReset = true;
                signature.fullKey = fullKey;
                return fullKey;
            }
            for(var i = 0; i < hooks.length; i++){
                var hook = hooks[i];
                if (typeof hook !== 'function') {
                    // Something's wrong. Assume we need to remount.
                    signature.forceReset = true;
                    signature.fullKey = fullKey;
                    return fullKey;
                }
                var nestedHookSignature = allSignaturesByType.get(hook);
                if (nestedHookSignature === undefined) {
                    continue;
                }
                var nestedHookKey = computeFullKey(nestedHookSignature);
                if (nestedHookSignature.forceReset) {
                    signature.forceReset = true;
                }
                fullKey += '\n---\n' + nestedHookKey;
            }
            signature.fullKey = fullKey;
            return fullKey;
        }
        function haveEqualSignatures(prevType, nextType) {
            var prevSignature = allSignaturesByType.get(prevType);
            var nextSignature = allSignaturesByType.get(nextType);
            if (prevSignature === undefined && nextSignature === undefined) {
                return true;
            }
            if (prevSignature === undefined || nextSignature === undefined) {
                return false;
            }
            if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {
                return false;
            }
            if (nextSignature.forceReset) {
                return false;
            }
            return true;
        }
        function isReactClass(type) {
            return type.prototype && type.prototype.isReactComponent;
        }
        function canPreserveStateBetween(prevType, nextType) {
            if (isReactClass(prevType) || isReactClass(nextType)) {
                return false;
            }
            if (haveEqualSignatures(prevType, nextType)) {
                return true;
            }
            return false;
        }
        function resolveFamily(type) {
            // Only check updated types to keep lookups fast.
            return updatedFamiliesByType.get(type);
        } // If we didn't care about IE11, we could use new Map/Set(iterable).
        function cloneMap(map) {
            var clone = new Map();
            map.forEach(function(value, key) {
                clone.set(key, value);
            });
            return clone;
        }
        function cloneSet(set) {
            var clone = new Set();
            set.forEach(function(value) {
                clone.add(value);
            });
            return clone;
        } // This is a safety mechanism to protect against rogue getters and Proxies.
        function getProperty(object, property) {
            try {
                return object[property];
            } catch (err) {
                // Intentionally ignore.
                return undefined;
            }
        }
        function performReactRefresh() {
            if (pendingUpdates.length === 0) {
                return null;
            }
            if (isPerformingRefresh) {
                return null;
            }
            isPerformingRefresh = true;
            try {
                var staleFamilies = new Set();
                var updatedFamilies = new Set();
                var updates = pendingUpdates;
                pendingUpdates = [];
                updates.forEach(function(_ref) {
                    var family = _ref[0], nextType = _ref[1];
                    // Now that we got a real edit, we can create associations
                    // that will be read by the React reconciler.
                    var prevType = family.current;
                    updatedFamiliesByType.set(prevType, family);
                    updatedFamiliesByType.set(nextType, family);
                    family.current = nextType; // Determine whether this should be a re-render or a re-mount.
                    if (canPreserveStateBetween(prevType, nextType)) {
                        updatedFamilies.add(family);
                    } else {
                        staleFamilies.add(family);
                    }
                }); // TODO: rename these fields to something more meaningful.
                var update = {
                    updatedFamilies: updatedFamilies,
                    // Families that will re-render preserving state
                    staleFamilies: staleFamilies // Families that will be remounted
                };
                helpersByRendererID.forEach(function(helpers) {
                    // Even if there are no roots, set the handler on first update.
                    // This ensures that if *new* roots are mounted, they'll use the resolve handler.
                    helpers.setRefreshHandler(resolveFamily);
                });
                var didError = false;
                var firstError = null; // We snapshot maps and sets that are mutated during commits.
                // If we don't do this, there is a risk they will be mutated while
                // we iterate over them. For example, trying to recover a failed root
                // may cause another root to be added to the failed list -- an infinite loop.
                var failedRootsSnapshot = cloneSet(failedRoots);
                var mountedRootsSnapshot = cloneSet(mountedRoots);
                var helpersByRootSnapshot = cloneMap(helpersByRoot);
                failedRootsSnapshot.forEach(function(root) {
                    var helpers = helpersByRootSnapshot.get(root);
                    if (helpers === undefined) {
                        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
                    }
                    if (!failedRoots.has(root)) {}
                    if (rootElements === null) {
                        return;
                    }
                    if (!rootElements.has(root)) {
                        return;
                    }
                    var element = rootElements.get(root);
                    try {
                        helpers.scheduleRoot(root, element);
                    } catch (err) {
                        if (!didError) {
                            didError = true;
                            firstError = err;
                        } // Keep trying other roots.
                    }
                });
                mountedRootsSnapshot.forEach(function(root) {
                    var helpers = helpersByRootSnapshot.get(root);
                    if (helpers === undefined) {
                        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
                    }
                    if (!mountedRoots.has(root)) {}
                    try {
                        helpers.scheduleRefresh(root, update);
                    } catch (err) {
                        if (!didError) {
                            didError = true;
                            firstError = err;
                        } // Keep trying other roots.
                    }
                });
                if (didError) {
                    throw firstError;
                }
                return update;
            } finally{
                isPerformingRefresh = false;
            }
        }
        function register(type, id) {
            {
                if (type === null) {
                    return;
                }
                if (typeof type !== 'function' && typeof type !== 'object') {
                    return;
                } // This can happen in an edge case, e.g. if we register
                // return value of a HOC but it returns a cached component.
                // Ignore anything but the first registration for each type.
                if (allFamiliesByType.has(type)) {
                    return;
                } // Create family or remember to update it.
                // None of this bookkeeping affects reconciliation
                // until the first performReactRefresh() call above.
                var family = allFamiliesByID.get(id);
                if (family === undefined) {
                    family = {
                        current: type
                    };
                    allFamiliesByID.set(id, family);
                } else {
                    pendingUpdates.push([
                        family,
                        type
                    ]);
                }
                allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.
                if (typeof type === 'object' && type !== null) {
                    switch(getProperty(type, '$$typeof')){
                        case REACT_FORWARD_REF_TYPE:
                            register(type.render, id + '$render');
                            break;
                        case REACT_MEMO_TYPE:
                            register(type.type, id + '$type');
                            break;
                    }
                }
            }
        }
        function setSignature(type, key) {
            var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;
            {
                if (!allSignaturesByType.has(type)) {
                    allSignaturesByType.set(type, {
                        forceReset: forceReset,
                        ownKey: key,
                        fullKey: null,
                        getCustomHooks: getCustomHooks || function() {
                            return [];
                        }
                    });
                } // Visit inner types because we might not have signed them.
                if (typeof type === 'object' && type !== null) {
                    switch(getProperty(type, '$$typeof')){
                        case REACT_FORWARD_REF_TYPE:
                            setSignature(type.render, key, forceReset, getCustomHooks);
                            break;
                        case REACT_MEMO_TYPE:
                            setSignature(type.type, key, forceReset, getCustomHooks);
                            break;
                    }
                }
            }
        } // This is lazily called during first render for a type.
        // It captures Hook list at that time so inline requires don't break comparisons.
        function collectCustomHooksForSignature(type) {
            {
                var signature = allSignaturesByType.get(type);
                if (signature !== undefined) {
                    computeFullKey(signature);
                }
            }
        }
        function getFamilyByID(id) {
            {
                return allFamiliesByID.get(id);
            }
        }
        function getFamilyByType(type) {
            {
                return allFamiliesByType.get(type);
            }
        }
        function findAffectedHostInstances(families) {
            {
                var affectedInstances = new Set();
                mountedRoots.forEach(function(root) {
                    var helpers = helpersByRoot.get(root);
                    if (helpers === undefined) {
                        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
                    }
                    var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);
                    instancesForRoot.forEach(function(inst) {
                        affectedInstances.add(inst);
                    });
                });
                return affectedInstances;
            }
        }
        function injectIntoGlobalHook(globalObject) {
            {
                // For React Native, the global hook will be set up by require('react-devtools-core').
                // That code will run before us. So we need to monkeypatch functions on existing hook.
                // For React Web, the global hook will be set up by the extension.
                // This will also run before us.
                var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;
                if (hook === undefined) {
                    // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.
                    // Note that in this case it's important that renderer code runs *after* this method call.
                    // Otherwise, the renderer will think that there is no global hook, and won't do the injection.
                    var nextID = 0;
                    globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {
                        renderers: new Map(),
                        supportsFiber: true,
                        inject: function(injected) {
                            return nextID++;
                        },
                        onScheduleFiberRoot: function(id, root, children) {},
                        onCommitFiberRoot: function(id, root, maybePriorityLevel, didError) {},
                        onCommitFiberUnmount: function() {}
                    };
                }
                if (hook.isDisabled) {
                    // This isn't a real property on the hook, but it can be set to opt out
                    // of DevTools integration and associated warnings and logs.
                    // Using console['warn'] to evade Babel and ESLint
                    console['warn']('Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' + 'Fast Refresh is not compatible with this shim and will be disabled.');
                    return;
                } // Here, we just want to get a reference to scheduleRefresh.
                var oldInject = hook.inject;
                hook.inject = function(injected) {
                    var id = oldInject.apply(this, arguments);
                    if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {
                        // This version supports React Refresh.
                        helpersByRendererID.set(id, injected);
                    }
                    return id;
                }; // Do the same for any already injected roots.
                // This is useful if ReactDOM has already been initialized.
                // https://github.com/facebook/react/issues/17626
                hook.renderers.forEach(function(injected, id) {
                    if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {
                        // This version supports React Refresh.
                        helpersByRendererID.set(id, injected);
                    }
                }); // We also want to track currently mounted roots.
                var oldOnCommitFiberRoot = hook.onCommitFiberRoot;
                var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function() {};
                hook.onScheduleFiberRoot = function(id, root, children) {
                    if (!isPerformingRefresh) {
                        // If it was intentionally scheduled, don't attempt to restore.
                        // This includes intentionally scheduled unmounts.
                        failedRoots.delete(root);
                        if (rootElements !== null) {
                            rootElements.set(root, children);
                        }
                    }
                    return oldOnScheduleFiberRoot.apply(this, arguments);
                };
                hook.onCommitFiberRoot = function(id, root, maybePriorityLevel, didError) {
                    var helpers = helpersByRendererID.get(id);
                    if (helpers !== undefined) {
                        helpersByRoot.set(root, helpers);
                        var current = root.current;
                        var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.
                        // This logic is copy-pasted from similar logic in the DevTools backend.
                        // If this breaks with some refactoring, you'll want to update DevTools too.
                        if (alternate !== null) {
                            var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);
                            var isMounted = current.memoizedState != null && current.memoizedState.element != null;
                            if (!wasMounted && isMounted) {
                                // Mount a new root.
                                mountedRoots.add(root);
                                failedRoots.delete(root);
                            } else if (wasMounted && isMounted) ;
                            else if (wasMounted && !isMounted) {
                                // Unmount an existing root.
                                mountedRoots.delete(root);
                                if (didError) {
                                    // We'll remount it on future edits.
                                    failedRoots.add(root);
                                } else {
                                    helpersByRoot.delete(root);
                                }
                            } else if (!wasMounted && !isMounted) {
                                if (didError) {
                                    // We'll remount it on future edits.
                                    failedRoots.add(root);
                                }
                            }
                        } else {
                            // Mount a new root.
                            mountedRoots.add(root);
                        }
                    } // Always call the decorated DevTools hook.
                    return oldOnCommitFiberRoot.apply(this, arguments);
                };
            }
        }
        function hasUnrecoverableErrors() {
            // TODO: delete this after removing dependency in RN.
            return false;
        } // Exposed for testing.
        function _getMountedRootCount() {
            {
                return mountedRoots.size;
            }
        } // This is a wrapper over more primitive functions for setting signature.
        // Signatures let us decide whether the Hook order has changed on refresh.
        //
        // This function is intended to be used as a transform target, e.g.:
        // var _s = createSignatureFunctionForTransform()
        //
        // function Hello() {
        //   const [foo, setFoo] = useState(0);
        //   const value = useCustomHook();
        //   _s(); /* Call without arguments triggers collecting the custom Hook list.
        //          * This doesn't happen during the module evaluation because we
        //          * don't want to change the module order with inline requires.
        //          * Next calls are noops. */
        //   return <h1>Hi</h1>;
        // }
        //
        // /* Call with arguments attaches the signature to the type: */
        // _s(
        //   Hello,
        //   'useState{[foo, setFoo]}(0)',
        //   () => [useCustomHook], /* Lazy to avoid triggering inline requires */
        // );
        function createSignatureFunctionForTransform() {
            {
                var savedType;
                var hasCustomHooks;
                var didCollectHooks = false;
                return function(type, key, forceReset, getCustomHooks) {
                    if (typeof key === 'string') {
                        // We're in the initial phase that associates signatures
                        // with the functions. Note this may be called multiple times
                        // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).
                        if (!savedType) {
                            // We're in the innermost call, so this is the actual type.
                            savedType = type;
                            hasCustomHooks = typeof getCustomHooks === 'function';
                        } // Set the signature for all types (even wrappers!) in case
                        // they have no signatures of their own. This is to prevent
                        // problems like https://github.com/facebook/react/issues/20417.
                        if (type != null && (typeof type === 'function' || typeof type === 'object')) {
                            setSignature(type, key, forceReset, getCustomHooks);
                        }
                        return type;
                    } else {
                        // We're in the _s() call without arguments, which means
                        // this is the time to collect custom Hook signatures.
                        // Only do this once. This path is hot and runs *inside* every render!
                        if (!didCollectHooks && hasCustomHooks) {
                            didCollectHooks = true;
                            collectCustomHooksForSignature(savedType);
                        }
                    }
                };
            }
        }
        function isLikelyComponentType(type) {
            {
                switch(typeof type){
                    case 'function':
                        {
                            // First, deal with classes.
                            if (type.prototype != null) {
                                if (type.prototype.isReactComponent) {
                                    // React class.
                                    return true;
                                }
                                var ownNames = Object.getOwnPropertyNames(type.prototype);
                                if (ownNames.length > 1 || ownNames[0] !== 'constructor') {
                                    // This looks like a class.
                                    return false;
                                } // eslint-disable-next-line no-proto
                                if (type.prototype.__proto__ !== Object.prototype) {
                                    // It has a superclass.
                                    return false;
                                } // Pass through.
                            // This looks like a regular function with empty prototype.
                            } // For plain functions and arrows, use name as a heuristic.
                            var name = type.name || type.displayName;
                            return typeof name === 'string' && /^[A-Z]/.test(name);
                        }
                    case 'object':
                        {
                            if (type != null) {
                                switch(getProperty(type, '$$typeof')){
                                    case REACT_FORWARD_REF_TYPE:
                                    case REACT_MEMO_TYPE:
                                        // Definitely React components.
                                        return true;
                                    default:
                                        return false;
                                }
                            }
                            return false;
                        }
                    default:
                        {
                            return false;
                        }
                }
            }
        }
        exports._getMountedRootCount = _getMountedRootCount;
        exports.collectCustomHooksForSignature = collectCustomHooksForSignature;
        exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;
        exports.findAffectedHostInstances = findAffectedHostInstances;
        exports.getFamilyByID = getFamilyByID;
        exports.getFamilyByType = getFamilyByType;
        exports.hasUnrecoverableErrors = hasUnrecoverableErrors;
        exports.injectIntoGlobalHook = injectIntoGlobalHook;
        exports.isLikelyComponentType = isLikelyComponentType;
        exports.performReactRefresh = performReactRefresh;
        exports.register = register;
        exports.setSignature = setSignature;
    })();
}
}}),
"[project]/node_modules/next/dist/compiled/react-refresh/runtime.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-runtime.development.js [client] (ecmascript)");
}
}}),
"[project]/node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/helpers.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * MIT License
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */ var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
// This file is copied from the Metro JavaScript bundler, with minor tweaks for
// webpack 4 compatibility.
//
// https://github.com/facebook/metro/blob/d6b9685c730d0d63577db40f41369157f28dfa3a/packages/metro/src/lib/polyfills/require.js
const runtime_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-refresh/runtime.js [client] (ecmascript)"));
function isSafeExport(key) {
    return key === '__esModule' || key === '__N_SSG' || key === '__N_SSP' || // TODO: remove this key from page config instead of allow listing it
    key === 'config';
}
function registerExportsForReactRefresh(moduleExports, moduleID) {
    runtime_1.default.register(moduleExports, moduleID + ' %exports%');
    if (moduleExports == null || typeof moduleExports !== 'object') {
        // Exit if we can't iterate over exports.
        // (This is important for legacy environments.)
        return;
    }
    for(var key in moduleExports){
        if (isSafeExport(key)) {
            continue;
        }
        try {
            var exportValue = moduleExports[key];
        } catch (_a) {
            continue;
        }
        var typeID = moduleID + ' %exports% ' + key;
        runtime_1.default.register(exportValue, typeID);
    }
}
function getRefreshBoundarySignature(moduleExports) {
    var signature = [];
    signature.push(runtime_1.default.getFamilyByType(moduleExports));
    if (moduleExports == null || typeof moduleExports !== 'object') {
        // Exit if we can't iterate over exports.
        // (This is important for legacy environments.)
        return signature;
    }
    for(var key in moduleExports){
        if (isSafeExport(key)) {
            continue;
        }
        try {
            var exportValue = moduleExports[key];
        } catch (_a) {
            continue;
        }
        signature.push(key);
        signature.push(runtime_1.default.getFamilyByType(exportValue));
    }
    return signature;
}
function isReactRefreshBoundary(moduleExports) {
    if (runtime_1.default.isLikelyComponentType(moduleExports)) {
        return true;
    }
    if (moduleExports == null || typeof moduleExports !== 'object') {
        // Exit if we can't iterate over exports.
        return false;
    }
    var hasExports = false;
    var areAllExportsComponents = true;
    for(var key in moduleExports){
        hasExports = true;
        if (isSafeExport(key)) {
            continue;
        }
        try {
            var exportValue = moduleExports[key];
        } catch (_a) {
            // This might fail due to circular dependencies
            return false;
        }
        if (!runtime_1.default.isLikelyComponentType(exportValue)) {
            areAllExportsComponents = false;
        }
    }
    return hasExports && areAllExportsComponents;
}
function shouldInvalidateReactRefreshBoundary(prevSignature, nextSignature) {
    if (prevSignature.length !== nextSignature.length) {
        return true;
    }
    for(var i = 0; i < nextSignature.length; i++){
        if (prevSignature[i] !== nextSignature[i]) {
            return true;
        }
    }
    return false;
}
var isUpdateScheduled = false;
// This function aggregates updates from multiple modules into a single React Refresh call.
function scheduleUpdate() {
    if (isUpdateScheduled) {
        return;
    }
    isUpdateScheduled = true;
    function canApplyUpdate(status) {
        return status === 'idle';
    }
    function applyUpdate() {
        isUpdateScheduled = false;
        try {
            runtime_1.default.performReactRefresh();
        } catch (err) {
            console.warn('Warning: Failed to re-render. We will retry on the next Fast Refresh event.\n' + err);
        }
    }
    if (canApplyUpdate(module.hot.status())) {
        // Apply update on the next tick.
        Promise.resolve().then(()=>{
            applyUpdate();
        });
        return;
    }
    const statusHandler = (status)=>{
        if (canApplyUpdate(status)) {
            module.hot.removeStatusHandler(statusHandler);
            applyUpdate();
        }
    };
    // Apply update once the HMR runtime's status is idle.
    module.hot.addStatusHandler(statusHandler);
}
// Needs to be compatible with IE11
exports.default = {
    registerExportsForReactRefresh: registerExportsForReactRefresh,
    isReactRefreshBoundary: isReactRefreshBoundary,
    shouldInvalidateReactRefreshBoundary: shouldInvalidateReactRefreshBoundary,
    getRefreshBoundarySignature: getRefreshBoundarySignature,
    scheduleUpdate: scheduleUpdate
}; //# sourceMappingURL=helpers.js.map
}}),
"[project]/node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const runtime_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-refresh/runtime.js [client] (ecmascript)"));
const helpers_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/@next/react-refresh-utils/dist/internal/helpers.js [client] (ecmascript)"));
// Hook into ReactDOM initialization
runtime_1.default.injectIntoGlobalHook(self);
// Register global helpers
self.$RefreshHelpers$ = helpers_1.default;
// Register a helper for module execution interception
self.$RefreshInterceptModuleExecution$ = function(webpackModuleId) {
    var prevRefreshReg = self.$RefreshReg$;
    var prevRefreshSig = self.$RefreshSig$;
    self.$RefreshReg$ = function(type, id) {
        runtime_1.default.register(type, webpackModuleId + ' ' + id);
    };
    self.$RefreshSig$ = runtime_1.default.createSignatureFunctionForTransform;
    // Modeled after `useEffect` cleanup pattern:
    // https://react.dev/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed
    return function() {
        self.$RefreshReg$ = prevRefreshReg;
        self.$RefreshSig$ = prevRefreshSig;
    };
}; //# sourceMappingURL=runtime.js.map
}}),
"[project]/node_modules/next/dist/compiled/react-is/cjs/react-is.development.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function typeOf(object) {
        if ("object" === typeof object && null !== object) {
            var $$typeof = object.$$typeof;
            switch($$typeof){
                case REACT_ELEMENT_TYPE:
                    switch(object = object.type, object){
                        case REACT_FRAGMENT_TYPE:
                        case REACT_PROFILER_TYPE:
                        case REACT_STRICT_MODE_TYPE:
                        case REACT_SUSPENSE_TYPE:
                        case REACT_SUSPENSE_LIST_TYPE:
                        case REACT_VIEW_TRANSITION_TYPE:
                            return object;
                        default:
                            switch(object = object && object.$$typeof, object){
                                case REACT_CONTEXT_TYPE:
                                case REACT_FORWARD_REF_TYPE:
                                case REACT_LAZY_TYPE:
                                case REACT_MEMO_TYPE:
                                    return object;
                                case REACT_CONSUMER_TYPE:
                                    return object;
                                default:
                                    return $$typeof;
                            }
                    }
                case REACT_PORTAL_TYPE:
                    return $$typeof;
            }
        }
    }
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    exports.ContextConsumer = REACT_CONSUMER_TYPE;
    exports.ContextProvider = REACT_CONTEXT_TYPE;
    exports.Element = REACT_ELEMENT_TYPE;
    exports.ForwardRef = REACT_FORWARD_REF_TYPE;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Lazy = REACT_LAZY_TYPE;
    exports.Memo = REACT_MEMO_TYPE;
    exports.Portal = REACT_PORTAL_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
    exports.isContextConsumer = function(object) {
        return typeOf(object) === REACT_CONSUMER_TYPE;
    };
    exports.isContextProvider = function(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
    };
    exports.isElement = function(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    };
    exports.isForwardRef = function(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
    };
    exports.isFragment = function(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
    };
    exports.isLazy = function(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
    };
    exports.isMemo = function(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
    };
    exports.isPortal = function(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
    };
    exports.isProfiler = function(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
    };
    exports.isStrictMode = function(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
    };
    exports.isSuspense = function(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
    };
    exports.isSuspenseList = function(object) {
        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
    };
    exports.isValidElementType = function(type) {
        return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? !0 : !1;
    };
    exports.typeOf = typeOf;
}();
}}),
"[project]/node_modules/next/dist/compiled/react-is/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-is/cjs/react-is.development.js [client] (ecmascript)");
}
}}),
"[project]/node_modules/next/dist/compiled/safe-stable-stringify/index.js [client] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
(function() {
    "use strict";
    var e = {
        879: function(e, t) {
            const { hasOwnProperty: n } = Object.prototype;
            const r = configure();
            r.configure = configure;
            r.stringify = r;
            r.default = r;
            t.stringify = r;
            t.configure = configure;
            e.exports = r;
            const i = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
            function strEscape(e) {
                if (e.length < 5e3 && !i.test(e)) {
                    return '"'.concat(e, '"');
                }
                return JSON.stringify(e);
            }
            function sort(e, t) {
                if (e.length > 200 || t) {
                    return e.sort(t);
                }
                for(let t = 1; t < e.length; t++){
                    const n = e[t];
                    let r = t;
                    while(r !== 0 && e[r - 1] > n){
                        e[r] = e[r - 1];
                        r--;
                    }
                    e[r] = n;
                }
                return e;
            }
            const f = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array)), Symbol.toStringTag).get;
            function isTypedArrayWithEntries(e) {
                return f.call(e) !== undefined && e.length !== 0;
            }
            function stringifyTypedArray(e, t, n) {
                if (e.length < n) {
                    n = e.length;
                }
                const r = t === "," ? "" : " ";
                let i = '"0":'.concat(r).concat(e[0]);
                for(let f = 1; f < n; f++){
                    i += "".concat(t, '"').concat(f, '":').concat(r).concat(e[f]);
                }
                return i;
            }
            function getCircularValueOption(e) {
                if (n.call(e, "circularValue")) {
                    const t = e.circularValue;
                    if (typeof t === "string") {
                        return '"'.concat(t, '"');
                    }
                    if (t == null) {
                        return t;
                    }
                    if (t === Error || t === TypeError) {
                        return {
                            toString () {
                                throw new TypeError("Converting circular structure to JSON");
                            }
                        };
                    }
                    throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
                }
                return '"[Circular]"';
            }
            function getDeterministicOption(e) {
                let t;
                if (n.call(e, "deterministic")) {
                    t = e.deterministic;
                    if (typeof t !== "boolean" && typeof t !== "function") {
                        throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
                    }
                }
                return t === undefined ? true : t;
            }
            function getBooleanOption(e, t) {
                let r;
                if (n.call(e, t)) {
                    r = e[t];
                    if (typeof r !== "boolean") {
                        throw new TypeError('The "'.concat(t, '" argument must be of type boolean'));
                    }
                }
                return r === undefined ? true : r;
            }
            function getPositiveIntegerOption(e, t) {
                let r;
                if (n.call(e, t)) {
                    r = e[t];
                    if (typeof r !== "number") {
                        throw new TypeError('The "'.concat(t, '" argument must be of type number'));
                    }
                    if (!Number.isInteger(r)) {
                        throw new TypeError('The "'.concat(t, '" argument must be an integer'));
                    }
                    if (r < 1) {
                        throw new RangeError('The "'.concat(t, '" argument must be >= 1'));
                    }
                }
                return r === undefined ? Infinity : r;
            }
            function getItemCount(e) {
                if (e === 1) {
                    return "1 item";
                }
                return "".concat(e, " items");
            }
            function getUniqueReplacerSet(e) {
                const t = new Set;
                for (const n of e){
                    if (typeof n === "string" || typeof n === "number") {
                        t.add(String(n));
                    }
                }
                return t;
            }
            function getStrictOption(e) {
                if (n.call(e, "strict")) {
                    const t = e.strict;
                    if (typeof t !== "boolean") {
                        throw new TypeError('The "strict" argument must be of type boolean');
                    }
                    if (t) {
                        return (e)=>{
                            let t = "Object can not safely be stringified. Received type ".concat(typeof e);
                            if (typeof e !== "function") t += " (".concat(e.toString(), ")");
                            throw new Error(t);
                        };
                    }
                }
            }
            function configure(e) {
                e = {
                    ...e
                };
                const t = getStrictOption(e);
                if (t) {
                    if (e.bigint === undefined) {
                        e.bigint = false;
                    }
                    if (!("circularValue" in e)) {
                        e.circularValue = Error;
                    }
                }
                const n = getCircularValueOption(e);
                const r = getBooleanOption(e, "bigint");
                const i = getDeterministicOption(e);
                const f = typeof i === "function" ? i : undefined;
                const u = getPositiveIntegerOption(e, "maximumDepth");
                const o = getPositiveIntegerOption(e, "maximumBreadth");
                function stringifyFnReplacer(e, s, l, c, a, g) {
                    let p = s[e];
                    if (typeof p === "object" && p !== null && typeof p.toJSON === "function") {
                        p = p.toJSON(e);
                    }
                    p = c.call(s, e, p);
                    switch(typeof p){
                        case "string":
                            return strEscape(p);
                        case "object":
                            {
                                if (p === null) {
                                    return "null";
                                }
                                if (l.indexOf(p) !== -1) {
                                    return n;
                                }
                                let e = "";
                                let t = ",";
                                const r = g;
                                if (Array.isArray(p)) {
                                    if (p.length === 0) {
                                        return "[]";
                                    }
                                    if (u < l.length + 1) {
                                        return '"[Array]"';
                                    }
                                    l.push(p);
                                    if (a !== "") {
                                        g += a;
                                        e += "\n".concat(g);
                                        t = ",\n".concat(g);
                                    }
                                    const n = Math.min(p.length, o);
                                    let i = 0;
                                    for(; i < n - 1; i++){
                                        const n = stringifyFnReplacer(String(i), p, l, c, a, g);
                                        e += n !== undefined ? n : "null";
                                        e += t;
                                    }
                                    const f = stringifyFnReplacer(String(i), p, l, c, a, g);
                                    e += f !== undefined ? f : "null";
                                    if (p.length - 1 > o) {
                                        const n = p.length - o - 1;
                                        e += "".concat(t, '"... ').concat(getItemCount(n), ' not stringified"');
                                    }
                                    if (a !== "") {
                                        e += "\n".concat(r);
                                    }
                                    l.pop();
                                    return "[".concat(e, "]");
                                }
                                let s = Object.keys(p);
                                const y = s.length;
                                if (y === 0) {
                                    return "{}";
                                }
                                if (u < l.length + 1) {
                                    return '"[Object]"';
                                }
                                let d = "";
                                let h = "";
                                if (a !== "") {
                                    g += a;
                                    t = ",\n".concat(g);
                                    d = " ";
                                }
                                const $ = Math.min(y, o);
                                if (i && !isTypedArrayWithEntries(p)) {
                                    s = sort(s, f);
                                }
                                l.push(p);
                                for(let n = 0; n < $; n++){
                                    const r = s[n];
                                    const i = stringifyFnReplacer(r, p, l, c, a, g);
                                    if (i !== undefined) {
                                        e += "".concat(h).concat(strEscape(r), ":").concat(d).concat(i);
                                        h = t;
                                    }
                                }
                                if (y > o) {
                                    const n = y - o;
                                    e += "".concat(h, '"...":').concat(d, '"').concat(getItemCount(n), ' not stringified"');
                                    h = t;
                                }
                                if (a !== "" && h.length > 1) {
                                    e = "\n".concat(g).concat(e, "\n").concat(r);
                                }
                                l.pop();
                                return "{".concat(e, "}");
                            }
                        case "number":
                            return isFinite(p) ? String(p) : t ? t(p) : "null";
                        case "boolean":
                            return p === true ? "true" : "false";
                        case "undefined":
                            return undefined;
                        case "bigint":
                            if (r) {
                                return String(p);
                            }
                        default:
                            return t ? t(p) : undefined;
                    }
                }
                function stringifyArrayReplacer(e, i, f, s, l, c) {
                    if (typeof i === "object" && i !== null && typeof i.toJSON === "function") {
                        i = i.toJSON(e);
                    }
                    switch(typeof i){
                        case "string":
                            return strEscape(i);
                        case "object":
                            {
                                if (i === null) {
                                    return "null";
                                }
                                if (f.indexOf(i) !== -1) {
                                    return n;
                                }
                                const e = c;
                                let t = "";
                                let r = ",";
                                if (Array.isArray(i)) {
                                    if (i.length === 0) {
                                        return "[]";
                                    }
                                    if (u < f.length + 1) {
                                        return '"[Array]"';
                                    }
                                    f.push(i);
                                    if (l !== "") {
                                        c += l;
                                        t += "\n".concat(c);
                                        r = ",\n".concat(c);
                                    }
                                    const n = Math.min(i.length, o);
                                    let a = 0;
                                    for(; a < n - 1; a++){
                                        const e = stringifyArrayReplacer(String(a), i[a], f, s, l, c);
                                        t += e !== undefined ? e : "null";
                                        t += r;
                                    }
                                    const g = stringifyArrayReplacer(String(a), i[a], f, s, l, c);
                                    t += g !== undefined ? g : "null";
                                    if (i.length - 1 > o) {
                                        const e = i.length - o - 1;
                                        t += "".concat(r, '"... ').concat(getItemCount(e), ' not stringified"');
                                    }
                                    if (l !== "") {
                                        t += "\n".concat(e);
                                    }
                                    f.pop();
                                    return "[".concat(t, "]");
                                }
                                f.push(i);
                                let a = "";
                                if (l !== "") {
                                    c += l;
                                    r = ",\n".concat(c);
                                    a = " ";
                                }
                                let g = "";
                                for (const e of s){
                                    const n = stringifyArrayReplacer(e, i[e], f, s, l, c);
                                    if (n !== undefined) {
                                        t += "".concat(g).concat(strEscape(e), ":").concat(a).concat(n);
                                        g = r;
                                    }
                                }
                                if (l !== "" && g.length > 1) {
                                    t = "\n".concat(c).concat(t, "\n").concat(e);
                                }
                                f.pop();
                                return "{".concat(t, "}");
                            }
                        case "number":
                            return isFinite(i) ? String(i) : t ? t(i) : "null";
                        case "boolean":
                            return i === true ? "true" : "false";
                        case "undefined":
                            return undefined;
                        case "bigint":
                            if (r) {
                                return String(i);
                            }
                        default:
                            return t ? t(i) : undefined;
                    }
                }
                function stringifyIndent(e, s, l, c, a) {
                    switch(typeof s){
                        case "string":
                            return strEscape(s);
                        case "object":
                            {
                                if (s === null) {
                                    return "null";
                                }
                                if (typeof s.toJSON === "function") {
                                    s = s.toJSON(e);
                                    if (typeof s !== "object") {
                                        return stringifyIndent(e, s, l, c, a);
                                    }
                                    if (s === null) {
                                        return "null";
                                    }
                                }
                                if (l.indexOf(s) !== -1) {
                                    return n;
                                }
                                const t = a;
                                if (Array.isArray(s)) {
                                    if (s.length === 0) {
                                        return "[]";
                                    }
                                    if (u < l.length + 1) {
                                        return '"[Array]"';
                                    }
                                    l.push(s);
                                    a += c;
                                    let e = "\n".concat(a);
                                    const n = ",\n".concat(a);
                                    const r = Math.min(s.length, o);
                                    let i = 0;
                                    for(; i < r - 1; i++){
                                        const t = stringifyIndent(String(i), s[i], l, c, a);
                                        e += t !== undefined ? t : "null";
                                        e += n;
                                    }
                                    const f = stringifyIndent(String(i), s[i], l, c, a);
                                    e += f !== undefined ? f : "null";
                                    if (s.length - 1 > o) {
                                        const t = s.length - o - 1;
                                        e += "".concat(n, '"... ').concat(getItemCount(t), ' not stringified"');
                                    }
                                    e += "\n".concat(t);
                                    l.pop();
                                    return "[".concat(e, "]");
                                }
                                let r = Object.keys(s);
                                const g = r.length;
                                if (g === 0) {
                                    return "{}";
                                }
                                if (u < l.length + 1) {
                                    return '"[Object]"';
                                }
                                a += c;
                                const p = ",\n".concat(a);
                                let y = "";
                                let d = "";
                                let h = Math.min(g, o);
                                if (isTypedArrayWithEntries(s)) {
                                    y += stringifyTypedArray(s, p, o);
                                    r = r.slice(s.length);
                                    h -= s.length;
                                    d = p;
                                }
                                if (i) {
                                    r = sort(r, f);
                                }
                                l.push(s);
                                for(let e = 0; e < h; e++){
                                    const t = r[e];
                                    const n = stringifyIndent(t, s[t], l, c, a);
                                    if (n !== undefined) {
                                        y += "".concat(d).concat(strEscape(t), ": ").concat(n);
                                        d = p;
                                    }
                                }
                                if (g > o) {
                                    const e = g - o;
                                    y += "".concat(d, '"...": "').concat(getItemCount(e), ' not stringified"');
                                    d = p;
                                }
                                if (d !== "") {
                                    y = "\n".concat(a).concat(y, "\n").concat(t);
                                }
                                l.pop();
                                return "{".concat(y, "}");
                            }
                        case "number":
                            return isFinite(s) ? String(s) : t ? t(s) : "null";
                        case "boolean":
                            return s === true ? "true" : "false";
                        case "undefined":
                            return undefined;
                        case "bigint":
                            if (r) {
                                return String(s);
                            }
                        default:
                            return t ? t(s) : undefined;
                    }
                }
                function stringifySimple(e, s, l) {
                    switch(typeof s){
                        case "string":
                            return strEscape(s);
                        case "object":
                            {
                                if (s === null) {
                                    return "null";
                                }
                                if (typeof s.toJSON === "function") {
                                    s = s.toJSON(e);
                                    if (typeof s !== "object") {
                                        return stringifySimple(e, s, l);
                                    }
                                    if (s === null) {
                                        return "null";
                                    }
                                }
                                if (l.indexOf(s) !== -1) {
                                    return n;
                                }
                                let t = "";
                                const r = s.length !== undefined;
                                if (r && Array.isArray(s)) {
                                    if (s.length === 0) {
                                        return "[]";
                                    }
                                    if (u < l.length + 1) {
                                        return '"[Array]"';
                                    }
                                    l.push(s);
                                    const e = Math.min(s.length, o);
                                    let n = 0;
                                    for(; n < e - 1; n++){
                                        const e = stringifySimple(String(n), s[n], l);
                                        t += e !== undefined ? e : "null";
                                        t += ",";
                                    }
                                    const r = stringifySimple(String(n), s[n], l);
                                    t += r !== undefined ? r : "null";
                                    if (s.length - 1 > o) {
                                        const e = s.length - o - 1;
                                        t += ',"... '.concat(getItemCount(e), ' not stringified"');
                                    }
                                    l.pop();
                                    return "[".concat(t, "]");
                                }
                                let c = Object.keys(s);
                                const a = c.length;
                                if (a === 0) {
                                    return "{}";
                                }
                                if (u < l.length + 1) {
                                    return '"[Object]"';
                                }
                                let g = "";
                                let p = Math.min(a, o);
                                if (r && isTypedArrayWithEntries(s)) {
                                    t += stringifyTypedArray(s, ",", o);
                                    c = c.slice(s.length);
                                    p -= s.length;
                                    g = ",";
                                }
                                if (i) {
                                    c = sort(c, f);
                                }
                                l.push(s);
                                for(let e = 0; e < p; e++){
                                    const n = c[e];
                                    const r = stringifySimple(n, s[n], l);
                                    if (r !== undefined) {
                                        t += "".concat(g).concat(strEscape(n), ":").concat(r);
                                        g = ",";
                                    }
                                }
                                if (a > o) {
                                    const e = a - o;
                                    t += "".concat(g, '"...":"').concat(getItemCount(e), ' not stringified"');
                                }
                                l.pop();
                                return "{".concat(t, "}");
                            }
                        case "number":
                            return isFinite(s) ? String(s) : t ? t(s) : "null";
                        case "boolean":
                            return s === true ? "true" : "false";
                        case "undefined":
                            return undefined;
                        case "bigint":
                            if (r) {
                                return String(s);
                            }
                        default:
                            return t ? t(s) : undefined;
                    }
                }
                function stringify(e, t, n) {
                    if (arguments.length > 1) {
                        let r = "";
                        if (typeof n === "number") {
                            r = " ".repeat(Math.min(n, 10));
                        } else if (typeof n === "string") {
                            r = n.slice(0, 10);
                        }
                        if (t != null) {
                            if (typeof t === "function") {
                                return stringifyFnReplacer("", {
                                    "": e
                                }, [], t, r, "");
                            }
                            if (Array.isArray(t)) {
                                return stringifyArrayReplacer("", e, [], getUniqueReplacerSet(t), r, "");
                            }
                        }
                        if (r.length !== 0) {
                            return stringifyIndent("", e, [], r, "");
                        }
                    }
                    return stringifySimple("", e, []);
                }
                return stringify;
            }
        }
    };
    var t = {};
    function __nccwpck_require__(n) {
        var r = t[n];
        if (r !== undefined) {
            return r.exports;
        }
        var i = t[n] = {
            exports: {}
        };
        var f = true;
        try {
            e[n](i, i.exports, __nccwpck_require__);
            f = false;
        } finally{
            if (f) delete t[n];
        }
        return i.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/safe-stable-stringify") + "/";
    var n = __nccwpck_require__(879);
    module.exports = n;
})();
}}),
"[project]/node_modules/next/dist/compiled/strip-ansi/index.js [client] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
(()=>{
    "use strict";
    var e = {
        511: (e)=>{
            e.exports = function() {
                let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                const r = [
                    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
                    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
                ].join("|");
                return new RegExp(r, e ? undefined : "g");
            };
        },
        532: (e, r, _)=>{
            const t = _(511);
            e.exports = (e)=>typeof e === "string" ? e.replace(t(), "") : e;
        }
    };
    var r = {};
    function __nccwpck_require__(_) {
        var t = r[_];
        if (t !== undefined) {
            return t.exports;
        }
        var a = r[_] = {
            exports: {}
        };
        var n = true;
        try {
            e[_](a, a.exports, __nccwpck_require__);
            n = false;
        } finally{
            if (n) delete r[_];
        }
        return a.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/strip-ansi") + "/";
    var _ = __nccwpck_require__(532);
    module.exports = _;
})();
}}),
"[project]/node_modules/next/dist/compiled/stacktrace-parser/stack-trace-parser.cjs.js [client] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
(()=>{
    "use strict";
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/stacktrace-parser") + "/";
    var e = {};
    (()=>{
        var r = e;
        Object.defineProperty(r, "__esModule", {
            value: true
        });
        var n = "<unknown>";
        function parse(e) {
            var r = e.split("\n");
            return r.reduce(function(e, r) {
                var n = parseChrome(r) || parseWinjs(r) || parseGecko(r) || parseNode(r) || parseJSC(r);
                if (n) {
                    e.push(n);
                }
                return e;
            }, []);
        }
        var a = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|webpack-internal|rsc|turbopack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
        var l = /\((\S*)(?::(\d+))(?::(\d+))\)/;
        function parseChrome(e) {
            var r = a.exec(e);
            if (!r) {
                return null;
            }
            var u = r[2] && r[2].indexOf("native") === 0;
            var t = r[2] && r[2].indexOf("eval") === 0;
            var i = l.exec(r[2]);
            if (t && i != null) {
                r[2] = i[1];
                r[3] = i[2];
                r[4] = i[3];
            }
            return {
                file: !u ? r[2] : null,
                methodName: r[1] || n,
                arguments: u ? [
                    r[2]
                ] : [],
                lineNumber: r[3] ? +r[3] : null,
                column: r[4] ? +r[4] : null
            };
        }
        var u = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|webpack-internal|rsc|turbopack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
        function parseWinjs(e) {
            var r = u.exec(e);
            if (!r) {
                return null;
            }
            return {
                file: r[2],
                methodName: r[1] || n,
                arguments: [],
                lineNumber: +r[3],
                column: r[4] ? +r[4] : null
            };
        }
        var t = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|webpack-internal|rsc|turbopack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
        var i = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
        function parseGecko(e) {
            var r = t.exec(e);
            if (!r) {
                return null;
            }
            var a = r[3] && r[3].indexOf(" > eval") > -1;
            var l = i.exec(r[3]);
            if (a && l != null) {
                r[3] = l[1];
                r[4] = l[2];
                r[5] = null;
            }
            return {
                file: r[3],
                methodName: r[1] || n,
                arguments: r[2] ? r[2].split(",") : [],
                lineNumber: r[4] ? +r[4] : null,
                column: r[5] ? +r[5] : null
            };
        }
        var s = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
        function parseJSC(e) {
            var r = s.exec(e);
            if (!r) {
                return null;
            }
            return {
                file: r[3],
                methodName: r[1] || n,
                arguments: [],
                lineNumber: +r[4],
                column: r[5] ? +r[5] : null
            };
        }
        var c = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
        function parseNode(e) {
            var r = c.exec(e);
            if (!r) {
                return null;
            }
            return {
                file: r[2],
                methodName: r[1] || n,
                arguments: [],
                lineNumber: +r[3],
                column: r[4] ? +r[4] : null
            };
        }
        r.parse = parse;
    })();
    module.exports = e;
})();
}}),
}]);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFtdLAogICJzZWN0aW9ucyI6IFsKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNiwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhw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QUUsRUFBRSxLQUFLLEdBQUM7Z0JBQVcsT0FBTztZQUFDO1FBQUM7SUFBQztJQUFFLElBQUksSUFBRSxDQUFDO0lBQUUsU0FBUyxvQkFBb0IsQ0FBQztRQUFFLElBQUksSUFBRSxDQUFDLENBQUMsRUFBRTtRQUFDLElBQUcsTUFBSSxXQUFVO1lBQUMsT0FBTyxFQUFFLE9BQU87UUFBQTtRQUFDLElBQUksSUFBRSxDQUFDLENBQUMsRUFBRSxHQUFDO1lBQUMsU0FBUSxDQUFDO1FBQUM7UUFBRSxJQUFJLElBQUU7UUFBSyxJQUFHO1lBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFFLEVBQUUsT0FBTyxFQUFDO1lBQXFCLElBQUU7UUFBSyxTQUFRO1lBQUMsSUFBRyxHQUFFLE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFBQTtRQUFDLE9BQU8sRUFBRSxPQUFPO0lBQUE7SUFBQyxJQUFHLE9BQU8sd0JBQXNCLGFBQVksb0JBQW9CLEVBQUUsR0FBQyxvRkFBVTtJQUFJLElBQUksSUFBRSxvQkFBb0I7SUFBSyxPQUFPLE9BQU8sR0FBQztBQUFDLENBQUMiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTk0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1yZWZyZXNoL2Nqcy9yZWFjdC1yZWZyZXNoLXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtcmVmcmVzaC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gQVRURU5USU9OXG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xuXG52YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwOyAvLyBXZSBuZXZlciByZW1vdmUgdGhlc2UgYXNzb2NpYXRpb25zLlxuLy8gSXQncyBPSyB0byByZWZlcmVuY2UgZmFtaWxpZXMsIGJ1dCB1c2UgV2Vha01hcC9TZXQgZm9yIHR5cGVzLlxuXG52YXIgYWxsRmFtaWxpZXNCeUlEID0gbmV3IE1hcCgpO1xudmFyIGFsbEZhbWlsaWVzQnlUeXBlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xudmFyIGFsbFNpZ25hdHVyZXNCeVR5cGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7IC8vIFRoaXMgV2Vha01hcCBpcyByZWFkIGJ5IFJlYWN0LCBzbyB3ZSBvbmx5IHB1dCBmYW1pbGllc1xuLy8gdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gZWRpdGVkIGhlcmUuIFRoaXMga2VlcHMgY2hlY2tzIGZhc3QuXG4vLyAkRmxvd0lzc3VlXG5cbnZhciB1cGRhdGVkRmFtaWxpZXNCeVR5cGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7IC8vIFRoaXMgaXMgY2xlYXJlZCBvbiBldmVyeSBwZXJmb3JtUmVhY3RSZWZyZXNoKCkgY2FsbC5cbi8vIEl0IGlzIGFuIGFycmF5IG9mIFtGYW1pbHksIE5leHRUeXBlXSB0dXBsZXMuXG5cbnZhciBwZW5kaW5nVXBkYXRlcyA9IFtdOyAvLyBUaGlzIGlzIGluamVjdGVkIGJ5IHRoZSByZW5kZXJlciB2aWEgRGV2VG9vbHMgZ2xvYmFsIGhvb2suXG5cbnZhciBoZWxwZXJzQnlSZW5kZXJlcklEID0gbmV3IE1hcCgpO1xudmFyIGhlbHBlcnNCeVJvb3QgPSBuZXcgTWFwKCk7IC8vIFdlIGtlZXAgdHJhY2sgb2YgbW91bnRlZCByb290cyBzbyB3ZSBjYW4gc2NoZWR1bGUgdXBkYXRlcy5cblxudmFyIG1vdW50ZWRSb290cyA9IG5ldyBTZXQoKTsgLy8gSWYgYSByb290IGNhcHR1cmVzIGFuIGVycm9yLCB3ZSByZW1lbWJlciBpdCBzbyB3ZSBjYW4gcmV0cnkgb24gZWRpdC5cblxudmFyIGZhaWxlZFJvb3RzID0gbmV3IFNldCgpOyAvLyBJbiBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IFdlYWtNYXAsIHdlIGFsc28gcmVtZW1iZXIgdGhlIGxhc3QgZWxlbWVudCBmb3IgZXZlcnkgcm9vdC5cbi8vIEl0IG5lZWRzIHRvIGJlIHdlYWsgYmVjYXVzZSB3ZSBkbyB0aGlzIGV2ZW4gZm9yIHJvb3RzIHRoYXQgZmFpbGVkIHRvIG1vdW50LlxuLy8gSWYgdGhlcmUgaXMgbm8gV2Vha01hcCwgd2Ugd29uJ3QgYXR0ZW1wdCB0byBkbyByZXRyeWluZy5cbi8vICRGbG93SXNzdWVcblxudmFyIHJvb3RFbGVtZW50cyA9IC8vICRGbG93SXNzdWVcbnR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gbmV3IFdlYWtNYXAoKSA6IG51bGw7XG52YXIgaXNQZXJmb3JtaW5nUmVmcmVzaCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjb21wdXRlRnVsbEtleShzaWduYXR1cmUpIHtcbiAgaWYgKHNpZ25hdHVyZS5mdWxsS2V5ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNpZ25hdHVyZS5mdWxsS2V5O1xuICB9XG5cbiAgdmFyIGZ1bGxLZXkgPSBzaWduYXR1cmUub3duS2V5O1xuICB2YXIgaG9va3M7XG5cbiAgdHJ5IHtcbiAgICBob29rcyA9IHNpZ25hdHVyZS5nZXRDdXN0b21Ib29rcygpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaW4gYW4gZWRnZSBjYXNlLCBlLmcuIGlmIGV4cHJlc3Npb24gbGlrZSBGb28udXNlU29tZXRoaW5nXG4gICAgLy8gZGVwZW5kcyBvbiBGb28gd2hpY2ggaXMgbGF6aWx5IGluaXRpYWxpemVkIGR1cmluZyByZW5kZXJpbmcuXG4gICAgLy8gSW4gdGhhdCBjYXNlIGp1c3QgYXNzdW1lIHdlJ2xsIGhhdmUgdG8gcmVtb3VudC5cbiAgICBzaWduYXR1cmUuZm9yY2VSZXNldCA9IHRydWU7XG4gICAgc2lnbmF0dXJlLmZ1bGxLZXkgPSBmdWxsS2V5O1xuICAgIHJldHVybiBmdWxsS2V5O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBob29rID0gaG9va3NbaV07XG5cbiAgICBpZiAodHlwZW9mIGhvb2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFNvbWV0aGluZydzIHdyb25nLiBBc3N1bWUgd2UgbmVlZCB0byByZW1vdW50LlxuICAgICAgc2lnbmF0dXJlLmZvcmNlUmVzZXQgPSB0cnVlO1xuICAgICAgc2lnbmF0dXJlLmZ1bGxLZXkgPSBmdWxsS2V5O1xuICAgICAgcmV0dXJuIGZ1bGxLZXk7XG4gICAgfVxuXG4gICAgdmFyIG5lc3RlZEhvb2tTaWduYXR1cmUgPSBhbGxTaWduYXR1cmVzQnlUeXBlLmdldChob29rKTtcblxuICAgIGlmIChuZXN0ZWRIb29rU2lnbmF0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE5vIHNpZ25hdHVyZSBtZWFucyBIb29rIHdhc24ndCBpbiB0aGUgc291cmNlIGNvZGUsIGUuZy4gaW4gYSBsaWJyYXJ5LlxuICAgICAgLy8gV2UnbGwgc2tpcCBpdCBiZWNhdXNlIHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgY2hhbmdlIGR1cmluZyB0aGlzIHNlc3Npb24uXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbmVzdGVkSG9va0tleSA9IGNvbXB1dGVGdWxsS2V5KG5lc3RlZEhvb2tTaWduYXR1cmUpO1xuXG4gICAgaWYgKG5lc3RlZEhvb2tTaWduYXR1cmUuZm9yY2VSZXNldCkge1xuICAgICAgc2lnbmF0dXJlLmZvcmNlUmVzZXQgPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bGxLZXkgKz0gJ1xcbi0tLVxcbicgKyBuZXN0ZWRIb29rS2V5O1xuICB9XG5cbiAgc2lnbmF0dXJlLmZ1bGxLZXkgPSBmdWxsS2V5O1xuICByZXR1cm4gZnVsbEtleTtcbn1cblxuZnVuY3Rpb24gaGF2ZUVxdWFsU2lnbmF0dXJlcyhwcmV2VHlwZSwgbmV4dFR5cGUpIHtcbiAgdmFyIHByZXZTaWduYXR1cmUgPSBhbGxTaWduYXR1cmVzQnlUeXBlLmdldChwcmV2VHlwZSk7XG4gIHZhciBuZXh0U2lnbmF0dXJlID0gYWxsU2lnbmF0dXJlc0J5VHlwZS5nZXQobmV4dFR5cGUpO1xuXG4gIGlmIChwcmV2U2lnbmF0dXJlID09PSB1bmRlZmluZWQgJiYgbmV4dFNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAocHJldlNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkIHx8IG5leHRTaWduYXR1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChjb21wdXRlRnVsbEtleShwcmV2U2lnbmF0dXJlKSAhPT0gY29tcHV0ZUZ1bGxLZXkobmV4dFNpZ25hdHVyZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobmV4dFNpZ25hdHVyZS5mb3JjZVJlc2V0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzUmVhY3RDbGFzcyh0eXBlKSB7XG4gIHJldHVybiB0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBjYW5QcmVzZXJ2ZVN0YXRlQmV0d2VlbihwcmV2VHlwZSwgbmV4dFR5cGUpIHtcbiAgaWYgKGlzUmVhY3RDbGFzcyhwcmV2VHlwZSkgfHwgaXNSZWFjdENsYXNzKG5leHRUeXBlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChoYXZlRXF1YWxTaWduYXR1cmVzKHByZXZUeXBlLCBuZXh0VHlwZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZhbWlseSh0eXBlKSB7XG4gIC8vIE9ubHkgY2hlY2sgdXBkYXRlZCB0eXBlcyB0byBrZWVwIGxvb2t1cHMgZmFzdC5cbiAgcmV0dXJuIHVwZGF0ZWRGYW1pbGllc0J5VHlwZS5nZXQodHlwZSk7XG59IC8vIElmIHdlIGRpZG4ndCBjYXJlIGFib3V0IElFMTEsIHdlIGNvdWxkIHVzZSBuZXcgTWFwL1NldChpdGVyYWJsZSkuXG5cblxuZnVuY3Rpb24gY2xvbmVNYXAobWFwKSB7XG4gIHZhciBjbG9uZSA9IG5ldyBNYXAoKTtcbiAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICBjbG9uZS5zZXQoa2V5LCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gY2xvbmU7XG59XG5cbmZ1bmN0aW9uIGNsb25lU2V0KHNldCkge1xuICB2YXIgY2xvbmUgPSBuZXcgU2V0KCk7XG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGNsb25lLmFkZCh2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gY2xvbmU7XG59IC8vIFRoaXMgaXMgYSBzYWZldHkgbWVjaGFuaXNtIHRvIHByb3RlY3QgYWdhaW5zdCByb2d1ZSBnZXR0ZXJzIGFuZCBQcm94aWVzLlxuXG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gb2JqZWN0W3Byb3BlcnR5XTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSW50ZW50aW9uYWxseSBpZ25vcmUuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtUmVhY3RSZWZyZXNoKCkge1xuXG4gIGlmIChwZW5kaW5nVXBkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChpc1BlcmZvcm1pbmdSZWZyZXNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpc1BlcmZvcm1pbmdSZWZyZXNoID0gdHJ1ZTtcblxuICB0cnkge1xuICAgIHZhciBzdGFsZUZhbWlsaWVzID0gbmV3IFNldCgpO1xuICAgIHZhciB1cGRhdGVkRmFtaWxpZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHVwZGF0ZXMgPSBwZW5kaW5nVXBkYXRlcztcbiAgICBwZW5kaW5nVXBkYXRlcyA9IFtdO1xuICAgIHVwZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIGZhbWlseSA9IF9yZWZbMF0sXG4gICAgICAgICAgbmV4dFR5cGUgPSBfcmVmWzFdO1xuICAgICAgLy8gTm93IHRoYXQgd2UgZ290IGEgcmVhbCBlZGl0LCB3ZSBjYW4gY3JlYXRlIGFzc29jaWF0aW9uc1xuICAgICAgLy8gdGhhdCB3aWxsIGJlIHJlYWQgYnkgdGhlIFJlYWN0IHJlY29uY2lsZXIuXG4gICAgICB2YXIgcHJldlR5cGUgPSBmYW1pbHkuY3VycmVudDtcbiAgICAgIHVwZGF0ZWRGYW1pbGllc0J5VHlwZS5zZXQocHJldlR5cGUsIGZhbWlseSk7XG4gICAgICB1cGRhdGVkRmFtaWxpZXNCeVR5cGUuc2V0KG5leHRUeXBlLCBmYW1pbHkpO1xuICAgICAgZmFtaWx5LmN1cnJlbnQgPSBuZXh0VHlwZTsgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBzaG91bGQgYmUgYSByZS1yZW5kZXIgb3IgYSByZS1tb3VudC5cblxuICAgICAgaWYgKGNhblByZXNlcnZlU3RhdGVCZXR3ZWVuKHByZXZUeXBlLCBuZXh0VHlwZSkpIHtcbiAgICAgICAgdXBkYXRlZEZhbWlsaWVzLmFkZChmYW1pbHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhbGVGYW1pbGllcy5hZGQoZmFtaWx5KTtcbiAgICAgIH1cbiAgICB9KTsgLy8gVE9ETzogcmVuYW1lIHRoZXNlIGZpZWxkcyB0byBzb21ldGhpbmcgbW9yZSBtZWFuaW5nZnVsLlxuXG4gICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgIHVwZGF0ZWRGYW1pbGllczogdXBkYXRlZEZhbWlsaWVzLFxuICAgICAgLy8gRmFtaWxpZXMgdGhhdCB3aWxsIHJlLXJlbmRlciBwcmVzZXJ2aW5nIHN0YXRlXG4gICAgICBzdGFsZUZhbWlsaWVzOiBzdGFsZUZhbWlsaWVzIC8vIEZhbWlsaWVzIHRoYXQgd2lsbCBiZSByZW1vdW50ZWRcblxuICAgIH07XG4gICAgaGVscGVyc0J5UmVuZGVyZXJJRC5mb3JFYWNoKGZ1bmN0aW9uIChoZWxwZXJzKSB7XG4gICAgICAvLyBFdmVuIGlmIHRoZXJlIGFyZSBubyByb290cywgc2V0IHRoZSBoYW5kbGVyIG9uIGZpcnN0IHVwZGF0ZS5cbiAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGlmICpuZXcqIHJvb3RzIGFyZSBtb3VudGVkLCB0aGV5J2xsIHVzZSB0aGUgcmVzb2x2ZSBoYW5kbGVyLlxuICAgICAgaGVscGVycy5zZXRSZWZyZXNoSGFuZGxlcihyZXNvbHZlRmFtaWx5KTtcbiAgICB9KTtcbiAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgZmlyc3RFcnJvciA9IG51bGw7IC8vIFdlIHNuYXBzaG90IG1hcHMgYW5kIHNldHMgdGhhdCBhcmUgbXV0YXRlZCBkdXJpbmcgY29tbWl0cy5cbiAgICAvLyBJZiB3ZSBkb24ndCBkbyB0aGlzLCB0aGVyZSBpcyBhIHJpc2sgdGhleSB3aWxsIGJlIG11dGF0ZWQgd2hpbGVcbiAgICAvLyB3ZSBpdGVyYXRlIG92ZXIgdGhlbS4gRm9yIGV4YW1wbGUsIHRyeWluZyB0byByZWNvdmVyIGEgZmFpbGVkIHJvb3RcbiAgICAvLyBtYXkgY2F1c2UgYW5vdGhlciByb290IHRvIGJlIGFkZGVkIHRvIHRoZSBmYWlsZWQgbGlzdCAtLSBhbiBpbmZpbml0ZSBsb29wLlxuXG4gICAgdmFyIGZhaWxlZFJvb3RzU25hcHNob3QgPSBjbG9uZVNldChmYWlsZWRSb290cyk7XG4gICAgdmFyIG1vdW50ZWRSb290c1NuYXBzaG90ID0gY2xvbmVTZXQobW91bnRlZFJvb3RzKTtcbiAgICB2YXIgaGVscGVyc0J5Um9vdFNuYXBzaG90ID0gY2xvbmVNYXAoaGVscGVyc0J5Um9vdCk7XG4gICAgZmFpbGVkUm9vdHNTbmFwc2hvdC5mb3JFYWNoKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICB2YXIgaGVscGVycyA9IGhlbHBlcnNCeVJvb3RTbmFwc2hvdC5nZXQocm9vdCk7XG5cbiAgICAgIGlmIChoZWxwZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBoZWxwZXJzIGZvciBhIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QgUmVmcmVzaC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmYWlsZWRSb290cy5oYXMocm9vdCkpIHsvLyBObyBsb25nZXIgZmFpbGVkLlxuICAgICAgfVxuXG4gICAgICBpZiAocm9vdEVsZW1lbnRzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb290RWxlbWVudHMuaGFzKHJvb3QpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSByb290RWxlbWVudHMuZ2V0KHJvb3QpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBoZWxwZXJzLnNjaGVkdWxlUm9vdChyb290LCBlbGVtZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWRpZEVycm9yKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGZpcnN0RXJyb3IgPSBlcnI7XG4gICAgICAgIH0gLy8gS2VlcCB0cnlpbmcgb3RoZXIgcm9vdHMuXG5cbiAgICAgIH1cbiAgICB9KTtcbiAgICBtb3VudGVkUm9vdHNTbmFwc2hvdC5mb3JFYWNoKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICB2YXIgaGVscGVycyA9IGhlbHBlcnNCeVJvb3RTbmFwc2hvdC5nZXQocm9vdCk7XG5cbiAgICAgIGlmIChoZWxwZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBoZWxwZXJzIGZvciBhIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QgUmVmcmVzaC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtb3VudGVkUm9vdHMuaGFzKHJvb3QpKSB7Ly8gTm8gbG9uZ2VyIG1vdW50ZWQuXG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGhlbHBlcnMuc2NoZWR1bGVSZWZyZXNoKHJvb3QsIHVwZGF0ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCFkaWRFcnJvcikge1xuICAgICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBmaXJzdEVycm9yID0gZXJyO1xuICAgICAgICB9IC8vIEtlZXAgdHJ5aW5nIG90aGVyIHJvb3RzLlxuXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgIHRocm93IGZpcnN0RXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc1BlcmZvcm1pbmdSZWZyZXNoID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyKHR5cGUsIGlkKSB7XG4gIHtcbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBhbiBlZGdlIGNhc2UsIGUuZy4gaWYgd2UgcmVnaXN0ZXJcbiAgICAvLyByZXR1cm4gdmFsdWUgb2YgYSBIT0MgYnV0IGl0IHJldHVybnMgYSBjYWNoZWQgY29tcG9uZW50LlxuICAgIC8vIElnbm9yZSBhbnl0aGluZyBidXQgdGhlIGZpcnN0IHJlZ2lzdHJhdGlvbiBmb3IgZWFjaCB0eXBlLlxuXG5cbiAgICBpZiAoYWxsRmFtaWxpZXNCeVR5cGUuaGFzKHR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDcmVhdGUgZmFtaWx5IG9yIHJlbWVtYmVyIHRvIHVwZGF0ZSBpdC5cbiAgICAvLyBOb25lIG9mIHRoaXMgYm9va2tlZXBpbmcgYWZmZWN0cyByZWNvbmNpbGlhdGlvblxuICAgIC8vIHVudGlsIHRoZSBmaXJzdCBwZXJmb3JtUmVhY3RSZWZyZXNoKCkgY2FsbCBhYm92ZS5cblxuXG4gICAgdmFyIGZhbWlseSA9IGFsbEZhbWlsaWVzQnlJRC5nZXQoaWQpO1xuXG4gICAgaWYgKGZhbWlseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmYW1pbHkgPSB7XG4gICAgICAgIGN1cnJlbnQ6IHR5cGVcbiAgICAgIH07XG4gICAgICBhbGxGYW1pbGllc0J5SUQuc2V0KGlkLCBmYW1pbHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nVXBkYXRlcy5wdXNoKFtmYW1pbHksIHR5cGVdKTtcbiAgICB9XG5cbiAgICBhbGxGYW1pbGllc0J5VHlwZS5zZXQodHlwZSwgZmFtaWx5KTsgLy8gVmlzaXQgaW5uZXIgdHlwZXMgYmVjYXVzZSB3ZSBtaWdodCBub3QgaGF2ZSByZWdpc3RlcmVkIHRoZW0uXG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAoZ2V0UHJvcGVydHkodHlwZSwgJyQkdHlwZW9mJykpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgIHJlZ2lzdGVyKHR5cGUucmVuZGVyLCBpZCArICckcmVuZGVyJyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgcmVnaXN0ZXIodHlwZS50eXBlLCBpZCArICckdHlwZScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0U2lnbmF0dXJlKHR5cGUsIGtleSkge1xuICB2YXIgZm9yY2VSZXNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIHZhciBnZXRDdXN0b21Ib29rcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuXG4gIHtcbiAgICBpZiAoIWFsbFNpZ25hdHVyZXNCeVR5cGUuaGFzKHR5cGUpKSB7XG4gICAgICBhbGxTaWduYXR1cmVzQnlUeXBlLnNldCh0eXBlLCB7XG4gICAgICAgIGZvcmNlUmVzZXQ6IGZvcmNlUmVzZXQsXG4gICAgICAgIG93bktleToga2V5LFxuICAgICAgICBmdWxsS2V5OiBudWxsLFxuICAgICAgICBnZXRDdXN0b21Ib29rczogZ2V0Q3VzdG9tSG9va3MgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSAvLyBWaXNpdCBpbm5lciB0eXBlcyBiZWNhdXNlIHdlIG1pZ2h0IG5vdCBoYXZlIHNpZ25lZCB0aGVtLlxuXG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAoZ2V0UHJvcGVydHkodHlwZSwgJyQkdHlwZW9mJykpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgIHNldFNpZ25hdHVyZSh0eXBlLnJlbmRlciwga2V5LCBmb3JjZVJlc2V0LCBnZXRDdXN0b21Ib29rcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgc2V0U2lnbmF0dXJlKHR5cGUudHlwZSwga2V5LCBmb3JjZVJlc2V0LCBnZXRDdXN0b21Ib29rcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59IC8vIFRoaXMgaXMgbGF6aWx5IGNhbGxlZCBkdXJpbmcgZmlyc3QgcmVuZGVyIGZvciBhIHR5cGUuXG4vLyBJdCBjYXB0dXJlcyBIb29rIGxpc3QgYXQgdGhhdCB0aW1lIHNvIGlubGluZSByZXF1aXJlcyBkb24ndCBicmVhayBjb21wYXJpc29ucy5cblxuZnVuY3Rpb24gY29sbGVjdEN1c3RvbUhvb2tzRm9yU2lnbmF0dXJlKHR5cGUpIHtcbiAge1xuICAgIHZhciBzaWduYXR1cmUgPSBhbGxTaWduYXR1cmVzQnlUeXBlLmdldCh0eXBlKTtcblxuICAgIGlmIChzaWduYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29tcHV0ZUZ1bGxLZXkoc2lnbmF0dXJlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZhbWlseUJ5SUQoaWQpIHtcbiAge1xuICAgIHJldHVybiBhbGxGYW1pbGllc0J5SUQuZ2V0KGlkKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RmFtaWx5QnlUeXBlKHR5cGUpIHtcbiAge1xuICAgIHJldHVybiBhbGxGYW1pbGllc0J5VHlwZS5nZXQodHlwZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRBZmZlY3RlZEhvc3RJbnN0YW5jZXMoZmFtaWxpZXMpIHtcbiAge1xuICAgIHZhciBhZmZlY3RlZEluc3RhbmNlcyA9IG5ldyBTZXQoKTtcbiAgICBtb3VudGVkUm9vdHMuZm9yRWFjaChmdW5jdGlvbiAocm9vdCkge1xuICAgICAgdmFyIGhlbHBlcnMgPSBoZWxwZXJzQnlSb290LmdldChyb290KTtcblxuICAgICAgaWYgKGhlbHBlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGhlbHBlcnMgZm9yIGEgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCBSZWZyZXNoLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5zdGFuY2VzRm9yUm9vdCA9IGhlbHBlcnMuZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoKHJvb3QsIGZhbWlsaWVzKTtcbiAgICAgIGluc3RhbmNlc0ZvclJvb3QuZm9yRWFjaChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICBhZmZlY3RlZEluc3RhbmNlcy5hZGQoaW5zdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWZmZWN0ZWRJbnN0YW5jZXM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluamVjdEludG9HbG9iYWxIb29rKGdsb2JhbE9iamVjdCkge1xuICB7XG4gICAgLy8gRm9yIFJlYWN0IE5hdGl2ZSwgdGhlIGdsb2JhbCBob29rIHdpbGwgYmUgc2V0IHVwIGJ5IHJlcXVpcmUoJ3JlYWN0LWRldnRvb2xzLWNvcmUnKS5cbiAgICAvLyBUaGF0IGNvZGUgd2lsbCBydW4gYmVmb3JlIHVzLiBTbyB3ZSBuZWVkIHRvIG1vbmtleXBhdGNoIGZ1bmN0aW9ucyBvbiBleGlzdGluZyBob29rLlxuICAgIC8vIEZvciBSZWFjdCBXZWIsIHRoZSBnbG9iYWwgaG9vayB3aWxsIGJlIHNldCB1cCBieSB0aGUgZXh0ZW5zaW9uLlxuICAgIC8vIFRoaXMgd2lsbCBhbHNvIHJ1biBiZWZvcmUgdXMuXG4gICAgdmFyIGhvb2sgPSBnbG9iYWxPYmplY3QuX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4gICAgaWYgKGhvb2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gSG93ZXZlciwgaWYgdGhlcmUgaXMgbm8gRGV2VG9vbHMgZXh0ZW5zaW9uLCB3ZSdsbCBuZWVkIHRvIHNldCB1cCB0aGUgZ2xvYmFsIGhvb2sgb3Vyc2VsdmVzLlxuICAgICAgLy8gTm90ZSB0aGF0IGluIHRoaXMgY2FzZSBpdCdzIGltcG9ydGFudCB0aGF0IHJlbmRlcmVyIGNvZGUgcnVucyAqYWZ0ZXIqIHRoaXMgbWV0aG9kIGNhbGwuXG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSByZW5kZXJlciB3aWxsIHRoaW5rIHRoYXQgdGhlcmUgaXMgbm8gZ2xvYmFsIGhvb2ssIGFuZCB3b24ndCBkbyB0aGUgaW5qZWN0aW9uLlxuICAgICAgdmFyIG5leHRJRCA9IDA7XG4gICAgICBnbG9iYWxPYmplY3QuX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID0gaG9vayA9IHtcbiAgICAgICAgcmVuZGVyZXJzOiBuZXcgTWFwKCksXG4gICAgICAgIHN1cHBvcnRzRmliZXI6IHRydWUsXG4gICAgICAgIGluamVjdDogZnVuY3Rpb24gKGluamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHRJRCsrO1xuICAgICAgICB9LFxuICAgICAgICBvblNjaGVkdWxlRmliZXJSb290OiBmdW5jdGlvbiAoaWQsIHJvb3QsIGNoaWxkcmVuKSB7fSxcbiAgICAgICAgb25Db21taXRGaWJlclJvb3Q6IGZ1bmN0aW9uIChpZCwgcm9vdCwgbWF5YmVQcmlvcml0eUxldmVsLCBkaWRFcnJvcikge30sXG4gICAgICAgIG9uQ29tbWl0RmliZXJVbm1vdW50OiBmdW5jdGlvbiAoKSB7fVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaG9vay5pc0Rpc2FibGVkKSB7XG4gICAgICAvLyBUaGlzIGlzbid0IGEgcmVhbCBwcm9wZXJ0eSBvbiB0aGUgaG9vaywgYnV0IGl0IGNhbiBiZSBzZXQgdG8gb3B0IG91dFxuICAgICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgICAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuICAgICAgY29uc29sZVsnd2FybiddKCdTb21ldGhpbmcgaGFzIHNoaW1tZWQgdGhlIFJlYWN0IERldlRvb2xzIGdsb2JhbCBob29rIChfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pLiAnICsgJ0Zhc3QgUmVmcmVzaCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoaXMgc2hpbSBhbmQgd2lsbCBiZSBkaXNhYmxlZC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEhlcmUsIHdlIGp1c3Qgd2FudCB0byBnZXQgYSByZWZlcmVuY2UgdG8gc2NoZWR1bGVSZWZyZXNoLlxuXG5cbiAgICB2YXIgb2xkSW5qZWN0ID0gaG9vay5pbmplY3Q7XG5cbiAgICBob29rLmluamVjdCA9IGZ1bmN0aW9uIChpbmplY3RlZCkge1xuICAgICAgdmFyIGlkID0gb2xkSW5qZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5qZWN0ZWQuc2NoZWR1bGVSZWZyZXNoID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbmplY3RlZC5zZXRSZWZyZXNoSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUaGlzIHZlcnNpb24gc3VwcG9ydHMgUmVhY3QgUmVmcmVzaC5cbiAgICAgICAgaGVscGVyc0J5UmVuZGVyZXJJRC5zZXQoaWQsIGluamVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlkO1xuICAgIH07IC8vIERvIHRoZSBzYW1lIGZvciBhbnkgYWxyZWFkeSBpbmplY3RlZCByb290cy5cbiAgICAvLyBUaGlzIGlzIHVzZWZ1bCBpZiBSZWFjdERPTSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTc2MjZcblxuXG4gICAgaG9vay5yZW5kZXJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5qZWN0ZWQsIGlkKSB7XG4gICAgICBpZiAodHlwZW9mIGluamVjdGVkLnNjaGVkdWxlUmVmcmVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5qZWN0ZWQuc2V0UmVmcmVzaEhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVGhpcyB2ZXJzaW9uIHN1cHBvcnRzIFJlYWN0IFJlZnJlc2guXG4gICAgICAgIGhlbHBlcnNCeVJlbmRlcmVySUQuc2V0KGlkLCBpbmplY3RlZCk7XG4gICAgICB9XG4gICAgfSk7IC8vIFdlIGFsc28gd2FudCB0byB0cmFjayBjdXJyZW50bHkgbW91bnRlZCByb290cy5cblxuICAgIHZhciBvbGRPbkNvbW1pdEZpYmVyUm9vdCA9IGhvb2sub25Db21taXRGaWJlclJvb3Q7XG5cbiAgICB2YXIgb2xkT25TY2hlZHVsZUZpYmVyUm9vdCA9IGhvb2sub25TY2hlZHVsZUZpYmVyUm9vdCB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgIGhvb2sub25TY2hlZHVsZUZpYmVyUm9vdCA9IGZ1bmN0aW9uIChpZCwgcm9vdCwgY2hpbGRyZW4pIHtcbiAgICAgIGlmICghaXNQZXJmb3JtaW5nUmVmcmVzaCkge1xuICAgICAgICAvLyBJZiBpdCB3YXMgaW50ZW50aW9uYWxseSBzY2hlZHVsZWQsIGRvbid0IGF0dGVtcHQgdG8gcmVzdG9yZS5cbiAgICAgICAgLy8gVGhpcyBpbmNsdWRlcyBpbnRlbnRpb25hbGx5IHNjaGVkdWxlZCB1bm1vdW50cy5cbiAgICAgICAgZmFpbGVkUm9vdHMuZGVsZXRlKHJvb3QpO1xuXG4gICAgICAgIGlmIChyb290RWxlbWVudHMgIT09IG51bGwpIHtcbiAgICAgICAgICByb290RWxlbWVudHMuc2V0KHJvb3QsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2xkT25TY2hlZHVsZUZpYmVyUm9vdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBob29rLm9uQ29tbWl0RmliZXJSb290ID0gZnVuY3Rpb24gKGlkLCByb290LCBtYXliZVByaW9yaXR5TGV2ZWwsIGRpZEVycm9yKSB7XG4gICAgICB2YXIgaGVscGVycyA9IGhlbHBlcnNCeVJlbmRlcmVySUQuZ2V0KGlkKTtcblxuICAgICAgaWYgKGhlbHBlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoZWxwZXJzQnlSb290LnNldChyb290LCBoZWxwZXJzKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSByb290LmN1cnJlbnQ7XG4gICAgICAgIHZhciBhbHRlcm5hdGUgPSBjdXJyZW50LmFsdGVybmF0ZTsgLy8gV2UgbmVlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGlzIHJvb3QgaGFzIGp1c3QgKHVuKW1vdW50ZWQuXG4gICAgICAgIC8vIFRoaXMgbG9naWMgaXMgY29weS1wYXN0ZWQgZnJvbSBzaW1pbGFyIGxvZ2ljIGluIHRoZSBEZXZUb29scyBiYWNrZW5kLlxuICAgICAgICAvLyBJZiB0aGlzIGJyZWFrcyB3aXRoIHNvbWUgcmVmYWN0b3JpbmcsIHlvdSdsbCB3YW50IHRvIHVwZGF0ZSBEZXZUb29scyB0b28uXG5cbiAgICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciB3YXNNb3VudGVkID0gYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUgIT0gbnVsbCAmJiBhbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5lbGVtZW50ICE9IG51bGwgJiYgbW91bnRlZFJvb3RzLmhhcyhyb290KTtcbiAgICAgICAgICB2YXIgaXNNb3VudGVkID0gY3VycmVudC5tZW1vaXplZFN0YXRlICE9IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlLmVsZW1lbnQgIT0gbnVsbDtcblxuICAgICAgICAgIGlmICghd2FzTW91bnRlZCAmJiBpc01vdW50ZWQpIHtcbiAgICAgICAgICAgIC8vIE1vdW50IGEgbmV3IHJvb3QuXG4gICAgICAgICAgICBtb3VudGVkUm9vdHMuYWRkKHJvb3QpO1xuICAgICAgICAgICAgZmFpbGVkUm9vdHMuZGVsZXRlKHJvb3QpO1xuICAgICAgICAgIH0gZWxzZSBpZiAod2FzTW91bnRlZCAmJiBpc01vdW50ZWQpIDsgZWxzZSBpZiAod2FzTW91bnRlZCAmJiAhaXNNb3VudGVkKSB7XG4gICAgICAgICAgICAvLyBVbm1vdW50IGFuIGV4aXN0aW5nIHJvb3QuXG4gICAgICAgICAgICBtb3VudGVkUm9vdHMuZGVsZXRlKHJvb3QpO1xuXG4gICAgICAgICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gV2UnbGwgcmVtb3VudCBpdCBvbiBmdXR1cmUgZWRpdHMuXG4gICAgICAgICAgICAgIGZhaWxlZFJvb3RzLmFkZChyb290KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhlbHBlcnNCeVJvb3QuZGVsZXRlKHJvb3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoIXdhc01vdW50ZWQgJiYgIWlzTW91bnRlZCkge1xuICAgICAgICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIFdlJ2xsIHJlbW91bnQgaXQgb24gZnV0dXJlIGVkaXRzLlxuICAgICAgICAgICAgICBmYWlsZWRSb290cy5hZGQocm9vdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE1vdW50IGEgbmV3IHJvb3QuXG4gICAgICAgICAgbW91bnRlZFJvb3RzLmFkZChyb290KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBBbHdheXMgY2FsbCB0aGUgZGVjb3JhdGVkIERldlRvb2xzIGhvb2suXG5cblxuICAgICAgcmV0dXJuIG9sZE9uQ29tbWl0RmliZXJSb290LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzVW5yZWNvdmVyYWJsZUVycm9ycygpIHtcbiAgLy8gVE9ETzogZGVsZXRlIHRoaXMgYWZ0ZXIgcmVtb3ZpbmcgZGVwZW5kZW5jeSBpbiBSTi5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBFeHBvc2VkIGZvciB0ZXN0aW5nLlxuXG5mdW5jdGlvbiBfZ2V0TW91bnRlZFJvb3RDb3VudCgpIHtcbiAge1xuICAgIHJldHVybiBtb3VudGVkUm9vdHMuc2l6ZTtcbiAgfVxufSAvLyBUaGlzIGlzIGEgd3JhcHBlciBvdmVyIG1vcmUgcHJpbWl0aXZlIGZ1bmN0aW9ucyBmb3Igc2V0dGluZyBzaWduYXR1cmUuXG4vLyBTaWduYXR1cmVzIGxldCB1cyBkZWNpZGUgd2hldGhlciB0aGUgSG9vayBvcmRlciBoYXMgY2hhbmdlZCBvbiByZWZyZXNoLlxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyBhIHRyYW5zZm9ybSB0YXJnZXQsIGUuZy46XG4vLyB2YXIgX3MgPSBjcmVhdGVTaWduYXR1cmVGdW5jdGlvbkZvclRyYW5zZm9ybSgpXG4vL1xuLy8gZnVuY3Rpb24gSGVsbG8oKSB7XG4vLyAgIGNvbnN0IFtmb28sIHNldEZvb10gPSB1c2VTdGF0ZSgwKTtcbi8vICAgY29uc3QgdmFsdWUgPSB1c2VDdXN0b21Ib29rKCk7XG4vLyAgIF9zKCk7IC8qIENhbGwgd2l0aG91dCBhcmd1bWVudHMgdHJpZ2dlcnMgY29sbGVjdGluZyB0aGUgY3VzdG9tIEhvb2sgbGlzdC5cbi8vICAgICAgICAgICogVGhpcyBkb2Vzbid0IGhhcHBlbiBkdXJpbmcgdGhlIG1vZHVsZSBldmFsdWF0aW9uIGJlY2F1c2Ugd2Vcbi8vICAgICAgICAgICogZG9uJ3Qgd2FudCB0byBjaGFuZ2UgdGhlIG1vZHVsZSBvcmRlciB3aXRoIGlubGluZSByZXF1aXJlcy5cbi8vICAgICAgICAgICogTmV4dCBjYWxscyBhcmUgbm9vcHMuICovXG4vLyAgIHJldHVybiA8aDE+SGk8L2gxPjtcbi8vIH1cbi8vXG4vLyAvKiBDYWxsIHdpdGggYXJndW1lbnRzIGF0dGFjaGVzIHRoZSBzaWduYXR1cmUgdG8gdGhlIHR5cGU6ICovXG4vLyBfcyhcbi8vICAgSGVsbG8sXG4vLyAgICd1c2VTdGF0ZXtbZm9vLCBzZXRGb29dfSgwKScsXG4vLyAgICgpID0+IFt1c2VDdXN0b21Ib29rXSwgLyogTGF6eSB0byBhdm9pZCB0cmlnZ2VyaW5nIGlubGluZSByZXF1aXJlcyAqL1xuLy8gKTtcblxuZnVuY3Rpb24gY3JlYXRlU2lnbmF0dXJlRnVuY3Rpb25Gb3JUcmFuc2Zvcm0oKSB7XG4gIHtcbiAgICB2YXIgc2F2ZWRUeXBlO1xuICAgIHZhciBoYXNDdXN0b21Ib29rcztcbiAgICB2YXIgZGlkQ29sbGVjdEhvb2tzID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0eXBlLCBrZXksIGZvcmNlUmVzZXQsIGdldEN1c3RvbUhvb2tzKSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gV2UncmUgaW4gdGhlIGluaXRpYWwgcGhhc2UgdGhhdCBhc3NvY2lhdGVzIHNpZ25hdHVyZXNcbiAgICAgICAgLy8gd2l0aCB0aGUgZnVuY3Rpb25zLiBOb3RlIHRoaXMgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAvLyBpbiBIT0MgY2hhaW5zIGxpa2UgX3MoaG9jMShfcyhob2MyKF9zKGFjdHVhbEZ1bmN0aW9uKSkpKSkuXG4gICAgICAgIGlmICghc2F2ZWRUeXBlKSB7XG4gICAgICAgICAgLy8gV2UncmUgaW4gdGhlIGlubmVybW9zdCBjYWxsLCBzbyB0aGlzIGlzIHRoZSBhY3R1YWwgdHlwZS5cbiAgICAgICAgICBzYXZlZFR5cGUgPSB0eXBlO1xuICAgICAgICAgIGhhc0N1c3RvbUhvb2tzID0gdHlwZW9mIGdldEN1c3RvbUhvb2tzID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB9IC8vIFNldCB0aGUgc2lnbmF0dXJlIGZvciBhbGwgdHlwZXMgKGV2ZW4gd3JhcHBlcnMhKSBpbiBjYXNlXG4gICAgICAgIC8vIHRoZXkgaGF2ZSBubyBzaWduYXR1cmVzIG9mIHRoZWlyIG93bi4gVGhpcyBpcyB0byBwcmV2ZW50XG4gICAgICAgIC8vIHByb2JsZW1zIGxpa2UgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDQxNy5cblxuXG4gICAgICAgIGlmICh0eXBlICE9IG51bGwgJiYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICBzZXRTaWduYXR1cmUodHlwZSwga2V5LCBmb3JjZVJlc2V0LCBnZXRDdXN0b21Ib29rcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlJ3JlIGluIHRoZSBfcygpIGNhbGwgd2l0aG91dCBhcmd1bWVudHMsIHdoaWNoIG1lYW5zXG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIHRpbWUgdG8gY29sbGVjdCBjdXN0b20gSG9vayBzaWduYXR1cmVzLlxuICAgICAgICAvLyBPbmx5IGRvIHRoaXMgb25jZS4gVGhpcyBwYXRoIGlzIGhvdCBhbmQgcnVucyAqaW5zaWRlKiBldmVyeSByZW5kZXIhXG4gICAgICAgIGlmICghZGlkQ29sbGVjdEhvb2tzICYmIGhhc0N1c3RvbUhvb2tzKSB7XG4gICAgICAgICAgZGlkQ29sbGVjdEhvb2tzID0gdHJ1ZTtcbiAgICAgICAgICBjb2xsZWN0Q3VzdG9tSG9va3NGb3JTaWduYXR1cmUoc2F2ZWRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTGlrZWx5Q29tcG9uZW50VHlwZSh0eXBlKSB7XG4gIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB0eXBlKSB7XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBGaXJzdCwgZGVhbCB3aXRoIGNsYXNzZXMuXG4gICAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIC8vIFJlYWN0IGNsYXNzLlxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG93bk5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModHlwZS5wcm90b3R5cGUpO1xuXG4gICAgICAgICAgICBpZiAob3duTmFtZXMubGVuZ3RoID4gMSB8fCBvd25OYW1lc1swXSAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgICAgICAvLyBUaGlzIGxvb2tzIGxpa2UgYSBjbGFzcy5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG9cblxuXG4gICAgICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUuX19wcm90b19fICE9PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgIC8vIEl0IGhhcyBhIHN1cGVyY2xhc3MuXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gLy8gUGFzcyB0aHJvdWdoLlxuICAgICAgICAgICAgLy8gVGhpcyBsb29rcyBsaWtlIGEgcmVndWxhciBmdW5jdGlvbiB3aXRoIGVtcHR5IHByb3RvdHlwZS5cblxuICAgICAgICAgIH0gLy8gRm9yIHBsYWluIGZ1bmN0aW9ucyBhbmQgYXJyb3dzLCB1c2UgbmFtZSBhcyBhIGhldXJpc3RpYy5cblxuXG4gICAgICAgICAgdmFyIG5hbWUgPSB0eXBlLm5hbWUgfHwgdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIC9eW0EtWl0vLnRlc3QobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZ2V0UHJvcGVydHkodHlwZSwgJyQkdHlwZW9mJykpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgICAvLyBEZWZpbml0ZWx5IFJlYWN0IGNvbXBvbmVudHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5fZ2V0TW91bnRlZFJvb3RDb3VudCA9IF9nZXRNb3VudGVkUm9vdENvdW50O1xuZXhwb3J0cy5jb2xsZWN0Q3VzdG9tSG9va3NGb3JTaWduYXR1cmUgPSBjb2xsZWN0Q3VzdG9tSG9va3NGb3JTaWduYXR1cmU7XG5leHBvcnRzLmNyZWF0ZVNpZ25hdHVyZUZ1bmN0aW9uRm9yVHJhbnNmb3JtID0gY3JlYXRlU2lnbmF0dXJlRnVuY3Rpb25Gb3JUcmFuc2Zvcm07XG5leHBvcnRzLmZpbmRBZmZlY3RlZEhvc3RJbnN0YW5jZXMgPSBmaW5kQWZmZWN0ZWRIb3N0SW5zdGFuY2VzO1xuZXhwb3J0cy5nZXRGYW1pbHlCeUlEID0gZ2V0RmFtaWx5QnlJRDtcbmV4cG9ydHMuZ2V0RmFtaWx5QnlUeXBlID0gZ2V0RmFtaWx5QnlUeXBlO1xuZXhwb3J0cy5oYXNVbnJlY292ZXJhYmxlRXJyb3JzID0gaGFzVW5yZWNvdmVyYWJsZUVycm9ycztcbmV4cG9ydHMuaW5qZWN0SW50b0dsb2JhbEhvb2sgPSBpbmplY3RJbnRvR2xvYmFsSG9vaztcbmV4cG9ydHMuaXNMaWtlbHlDb21wb25lbnRUeXBlID0gaXNMaWtlbHlDb21wb25lbnRUeXBlO1xuZXhwb3J0cy5wZXJmb3JtUmVhY3RSZWZyZXNoID0gcGVyZm9ybVJlYWN0UmVmcmVzaDtcbmV4cG9ydHMucmVnaXN0ZXIgPSByZWdpc3RlcjtcbmV4cG9ydHMuc2V0U2lnbmF0dXJlID0gc2V0U2lnbmF0dXJlO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBSUc7QUFGSjtBQUVBLHdDQUEyQztJQUN6QyxDQUFDO1FBQ0g7UUFFQSxZQUFZO1FBQ1osSUFBSSx5QkFBeUIsT0FBTyxHQUFHLENBQUM7UUFDeEMsSUFBSSxrQkFBa0IsT0FBTyxHQUFHLENBQUM7UUFFakMsSUFBSSxrQkFBa0IsT0FBTyxZQUFZLGFBQWEsVUFBVSxLQUFLLHNDQUFzQztRQUMzRyxnRUFBZ0U7UUFFaEUsSUFBSSxrQkFBa0IsSUFBSTtRQUMxQixJQUFJLG9CQUFvQixJQUFJO1FBQzVCLElBQUksc0JBQXNCLElBQUksbUJBQW1CLHlEQUF5RDtRQUMxRywrREFBK0Q7UUFDL0QsYUFBYTtRQUViLElBQUksd0JBQXdCLElBQUksbUJBQW1CLHVEQUF1RDtRQUMxRywrQ0FBK0M7UUFFL0MsSUFBSSxpQkFBaUIsRUFBRSxFQUFFLDZEQUE2RDtRQUV0RixJQUFJLHNCQUFzQixJQUFJO1FBQzlCLElBQUksZ0JBQWdCLElBQUksT0FBTyw2REFBNkQ7UUFFNUYsSUFBSSxlQUFlLElBQUksT0FBTyx1RUFBdUU7UUFFckcsSUFBSSxjQUFjLElBQUksT0FBTywwRkFBMEY7UUFDdkgsOEVBQThFO1FBQzlFLDJEQUEyRDtRQUMzRCxhQUFhO1FBRWIsSUFBSSxlQUNKLE9BQU8sWUFBWSxhQUFhLElBQUksWUFBWTtRQUNoRCxJQUFJLHNCQUFzQjtRQUUxQixTQUFTLGVBQWUsU0FBUztZQUMvQixJQUFJLFVBQVUsT0FBTyxLQUFL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UUFBUSxzQkFBc0IsR0FBRztRQUNqQyxRQUFRLG9CQUFvQixHQUFHO1FBQy9CLFFBQVEscUJBQXFCLEdBQUc7UUFDaEMsUUFBUSxtQkFBbUIsR0FBRztRQUM5QixRQUFRLFFBQVEsR0FBRztRQUNuQixRQUFRLFlBQVksR0FBRztJQUNyQixDQUFDO0FBQ0giLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzQxLCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1yZWZyZXNoL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlZnJlc2gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWZyZXNoLXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFSTtBQUZKO0FBRUE7O0tBRU87SUFDTCxPQUFPLE9BQU87QUFDaEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogNzU0LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsImZpbGUiOiJ0dXJib3BhY2s6Ly8vW3Byb2plY3RdL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvQG5leHQvcmVhY3QtcmVmcmVzaC11dGlscy9kaXN0L2ludGVybmFsL2hlbHBlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9pbnRlcm5hbC9oZWxwZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FzQkc7Ozs7Ozs7O0FBRUgsK0VBQStFO0FBQy9FLDJCQUEyQjtBQUMzQixFQUFFO0FBQ0YsOEhBQThIO0FBRTlILE1BQUEsWUFBQSxrREFBa0Q7QUFzQmxELFNBQVMsWUFBWSxDQUFDLEdBQVc7SUFDL0IsT0FBTyxBQUNMLEdBQUcsS0FBSyxZQUFZLElBQ3BCLEdBQUcsS0FBSyxTQUFTLElBQ2pCLEdBQUcsS0FBSyxTQUFTLElBQ2pCLHFFQUFxRTtJQUNyRSxHQUFHLEtBQUssUUFBUSxDQUNqQixDQUFBO0FBQ0gsQ0FBQztBQUVELFNBQVMsOEJBQThCLENBQ3JDLGFBQXNCLEVBQ3RCLFFBQWdCO0lBRWhCLFVBQUEsT0FBYyxDQUFDLFFBQVEsQ0FBQyxhQUFhLEVBQUUsUUFBUSxHQUFHLFlBQVksQ0FBQyxDQUFBO0lBQy9ELElBQUksYUFBYSxJQUFJLElBQUksSUFBSSxPQUFPLGFBQWEsS0FBSyxRQUFRLEVBQUUsQ0FBQztRQUMvRCx5Q0FBeUM7UUFDekMsK0NBQStDO1FBQy9DLE9BQU07SUFDUixDQUFDO0lBQ0QsSUFBSyxJQUFJLEdBQUcsSUFBSSxhQUFhLENBQUUsQ0FBQztRQUM5QixJQUFJLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ3RCLFNBQVE7UUFDVixDQUFDO1FBQ0QsSUFBSSxDQUFDO1lBQ0gsSUFBSSxXQUFXLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFBO1FBQ3RDLENBQUMsQ0FBQyxPQUFBLElBQU0sQ0FBQztZQUVQLFNBQVE7UUFDVixDQUFDO1FBQ0QsSUFBSSxNQUFNLEdBQUcsUUFBUSxHQUFHLGFBQWEsR0FBRyxHQUFHLENBQUE7UUFDM0MsVUFBQSxPQUFjLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQTtJQUM5QyxD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IiwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiA5MjEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6MywiZmlsZSI6InR1cmJvcGFjazovLy9bcHJvamVjdF0vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9AbmV4dC9yZWFjdC1yZWZyZXNoLXV0aWxzL2Rpc3QvcnVudGltZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3J1bnRpbWUudHMiXSwic291cmNlc0NvbnRlbnQiOltdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLE1BQUEsWUFBQSxrREFBa0Q7QUFDbEQsTUFBQSxZQUFBLCtDQUErQztBQVcvQyxvQ0FBb0M7QUFDcEMsVUFBQSxPQUFjLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQUE7QUFFekMsMEJBQTBCO0FBQzFCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxVQUFBLE9BQWMsQ0FBQTtBQUV0QyxzREFBc0Q7QUFDdEQsSUFBSSxDQUFDLGlDQUFpQyxHQUFHLFNBQVUsZUFBZTtJQUNoRSxJQUFJLGNBQWMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFBO0lBQ3RDLElBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUE7SUFFdEMsSUFBSSxDQUFDLFlBQVksR0FBRyxTQUFVLElBQUksRUFBRSxFQUFFO1FBQ3BDLFVBQUEsT0FBYyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsZUFBZSxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQTtJQUMzRCxDQUFDLENBQUE7SUFDRCxJQUFJLENBQUMsWUFBWSxHQUFHLFVBQUEsT0FBYyxDQUFDLG1DQUFtQyxDQUFBO0lBRXRFLDZDQUE2QztJQUM3QyxrRkFBa0Y7SUFDbEYsT0FBTztRQUNMLElBQUksQ0FBQyxZQUFZLEdBQUcsY0FBYyxDQUFBO1FBQ2xDLElBQUksQ0FBQyxZQUFZLEdBQUcsY0FBYyxDQUFBO0lBQ3BDLENBQUMsQ0FBQTtBQUNILENBQUMsQ0FBQSIsImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogOTU2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBvYmplY3QgJiYgbnVsbCAhPT0gb2JqZWN0KSB7XG4gICAgICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcbiAgICAgICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgc3dpdGNoICgoKG9iamVjdCA9IG9iamVjdC50eXBlKSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1ZJRVdfVFJBTlNJVElPTl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgc3dpdGNoICgoKG9iamVjdCA9IG9iamVjdCAmJiBvYmplY3QuJCR0eXBlb2YpLCBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgICAgIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfVklFV19UUkFOU0lUSU9OX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qudmlld190cmFuc2l0aW9uXCIpLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpO1xuICAgIGV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OU1VNRVJfVFlQRTtcbiAgICBleHBvcnRzLkNvbnRleHRQcm92aWRlciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbiAgICBleHBvcnRzLkVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gICAgZXhwb3J0cy5Gb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLkxhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG4gICAgZXhwb3J0cy5NZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xuICAgIGV4cG9ydHMuUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG4gICAgZXhwb3J0cy5Qcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG4gICAgZXhwb3J0cy5TdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbiAgICBleHBvcnRzLlN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbiAgICBleHBvcnRzLlN1c3BlbnNlTGlzdCA9IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTtcbiAgICBleHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05TVU1FUl9UWVBFO1xuICAgIH07XG4gICAgZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xuICAgIH07XG4gICAgZXhwb3J0cy5pc0VsZW1lbnQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuaXNGb3J3YXJkUmVmID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xuICAgIH07XG4gICAgZXhwb3J0cy5pc0ZyYWdtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIH07XG4gICAgZXhwb3J0cy5pc0xhenkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbiAgICB9O1xuICAgIGV4cG9ydHMuaXNNZW1vID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG4gICAgfTtcbiAgICBleHBvcnRzLmlzUG9ydGFsID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbiAgICB9O1xuICAgIGV4cG9ydHMuaXNQcm9maWxlciA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgICB9O1xuICAgIGV4cG9ydHMuaXNTdHJpY3RNb2RlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuICAgIH07XG4gICAgZXhwb3J0cy5pc1N1c3BlbnNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuICAgIH07XG4gICAgZXhwb3J0cy5pc1N1c3BlbnNlTGlzdCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xuICAgIH07XG4gICAgZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHxcbiAgICAgICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICAgICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFIHx8XG4gICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuZ2V0TW9kdWxlSWQpKVxuICAgICAgICA/ICEwXG4gICAgICAgIDogITE7XG4gICAgfTtcbiAgICBleHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbiJd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Q0EsUUFBUSxjQUFjLEdBQUcsU0FBVSxNQUFNO1FBQ3ZDLE9BQU8sT0FBTyxZQUFZO0lBQzVCO0lBQ0EsUUFBUSxrQkFBa0IsR0FBRyxTQUFVLElBQUk7UUFDekMsT0FBTyxhQUFhLE9BQU8sUUFDekIsZUFBZSxPQUFPLFFBQ3RCLFNBQVMsdUJBQ1QsU0FBUyx1QkFDVCxTQUFTLDBCQUNULFNBQVMsdUJBQ1QsU0FBUyw0QkFDUixhQUFhLE9BQU8sUUFDbkIsU0FBUyxRQUNULENBQUMsS0FBSyxRQUFRLEtBQUssbUJBQ2pCLEtBQUssUUFBUSxLQUFLLG1CQUNsQixLQUFLLFFBQVEsS0FBSyxzQkFDbEIsS0FBSyxRQUFRLEtBQUssdUJBQ2xCLEtBQUssUUFBUSxLQUFLLDBCQUNsQixLQUFLLFFBQVEsS0FBSywwQkFDbEIsS0FBSyxNQUFNLEtBQUssV0FBVyxJQUM3QixDQUFDLElBQ0QsQ0FBQztJQUNQO0lBQ0EsUUFBUSxNQUFNLEdBQUc7QUFDbkIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTA1OCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFSTtBQUZKO0FBRUE7O0tBRU87SUFDTCxPQUFPLE9BQU87QUFDaEIiLCJpZ25vcmVMaXN0IjpbMF0sImRlYnVnSWQiOm51bGx9fSwKICAgIHsib2Zmc2V0IjogeyJsaW5lIjogMTA3MCwgImNvbHVtbiI6IDB9LCAibWFwIjogeyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vRDovRG9jdW1lbnRzL05ldyUyMGZvbGRlci9UYXNrLUZsb3cvY2xpZW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2FmZS1zdGFibGUtc3RyaW5naWZ5L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciBlPXs4Nzk6ZnVuY3Rpb24oZSx0KXtjb25zdHtoYXNPd25Qcm9wZXJ0eTpufT1PYmplY3QucHJvdG90eXBlO2NvbnN0IHI9Y29uZmlndXJlKCk7ci5jb25maWd1cmU9Y29uZmlndXJlO3Iuc3RyaW5naWZ5PXI7ci5kZWZhdWx0PXI7dC5zdHJpbmdpZnk9cjt0LmNvbmZpZ3VyZT1jb25maWd1cmU7ZS5leHBvcnRzPXI7Y29uc3QgaT0vW1xcdTAwMDAtXFx1MDAxZlxcdTAwMjJcXHUwMDVjXFx1ZDgwMC1cXHVkZmZmXS87ZnVuY3Rpb24gc3RyRXNjYXBlKGUpe2lmKGUubGVuZ3RoPDVlMyYmIWkudGVzdChlKSl7cmV0dXJuYFwiJHtlfVwiYH1yZXR1cm4gSlNPTi5zdHJpbmdpZnkoZSl9ZnVuY3Rpb24gc29ydChlLHQpe2lmKGUubGVuZ3RoPjIwMHx8dCl7cmV0dXJuIGUuc29ydCh0KX1mb3IobGV0IHQ9MTt0PGUubGVuZ3RoO3QrKyl7Y29uc3Qgbj1lW3RdO2xldCByPXQ7d2hpbGUociE9PTAmJmVbci0xXT5uKXtlW3JdPWVbci0xXTtyLS19ZVtyXT1ufXJldHVybiBlfWNvbnN0IGY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBJbnQ4QXJyYXkpKSxTeW1ib2wudG9TdHJpbmdUYWcpLmdldDtmdW5jdGlvbiBpc1R5cGVkQXJyYXlXaXRoRW50cmllcyhlKXtyZXR1cm4gZi5jYWxsKGUpIT09dW5kZWZpbmVkJiZlLmxlbmd0aCE9PTB9ZnVuY3Rpb24gc3RyaW5naWZ5VHlwZWRBcnJheShlLHQsbil7aWYoZS5sZW5ndGg8bil7bj1lLmxlbmd0aH1jb25zdCByPXQ9PT1cIixcIj9cIlwiOlwiIFwiO2xldCBpPWBcIjBcIjoke3J9JHtlWzBdfWA7Zm9yKGxldCBmPTE7ZjxuO2YrKyl7aSs9YCR7dH1cIiR7Zn1cIjoke3J9JHtlW2ZdfWB9cmV0dXJuIGl9ZnVuY3Rpb24gZ2V0Q2lyY3VsYXJWYWx1ZU9wdGlvbihlKXtpZihuLmNhbGwoZSxcImNpcmN1bGFyVmFsdWVcIikpe2NvbnN0IHQ9ZS5jaXJjdWxhclZhbHVlO2lmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7cmV0dXJuYFwiJHt0fVwiYH1pZih0PT1udWxsKXtyZXR1cm4gdH1pZih0PT09RXJyb3J8fHQ9PT1UeXBlRXJyb3Ipe3JldHVybnt0b1N0cmluZygpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OXCIpfX19dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiY2lyY3VsYXJWYWx1ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcgb3IgdGhlIHZhbHVlIG51bGwgb3IgdW5kZWZpbmVkJyl9cmV0dXJuJ1wiW0NpcmN1bGFyXVwiJ31mdW5jdGlvbiBnZXREZXRlcm1pbmlzdGljT3B0aW9uKGUpe2xldCB0O2lmKG4uY2FsbChlLFwiZGV0ZXJtaW5pc3RpY1wiKSl7dD1lLmRldGVybWluaXN0aWM7aWYodHlwZW9mIHQhPT1cImJvb2xlYW5cIiYmdHlwZW9mIHQhPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImRldGVybWluaXN0aWNcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgYm9vbGVhbiBvciBjb21wYXJhdG9yIGZ1bmN0aW9uJyl9fXJldHVybiB0PT09dW5kZWZpbmVkP3RydWU6dH1mdW5jdGlvbiBnZXRCb29sZWFuT3B0aW9uKGUsdCl7bGV0IHI7aWYobi5jYWxsKGUsdCkpe3I9ZVt0XTtpZih0eXBlb2YgciE9PVwiYm9vbGVhblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke3R9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW5gKX19cmV0dXJuIHI9PT11bmRlZmluZWQ/dHJ1ZTpyfWZ1bmN0aW9uIGdldFBvc2l0aXZlSW50ZWdlck9wdGlvbihlLHQpe2xldCByO2lmKG4uY2FsbChlLHQpKXtyPWVbdF07aWYodHlwZW9mIHIhPT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke3R9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcmApfWlmKCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke3R9XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBpbnRlZ2VyYCl9aWYocjwxKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlIFwiJHt0fVwiIGFyZ3VtZW50IG11c3QgYmUgPj0gMWApfX1yZXR1cm4gcj09PXVuZGVmaW5lZD9JbmZpbml0eTpyfWZ1bmN0aW9uIGdldEl0ZW1Db3VudChlKXtpZihlPT09MSl7cmV0dXJuXCIxIGl0ZW1cIn1yZXR1cm5gJHtlfSBpdGVtc2B9ZnVuY3Rpb24gZ2V0VW5pcXVlUmVwbGFjZXJTZXQoZSl7Y29uc3QgdD1uZXcgU2V0O2Zvcihjb25zdCBuIG9mIGUpe2lmKHR5cGVvZiBuPT09XCJzdHJpbmdcInx8dHlwZW9mIG49PT1cIm51bWJlclwiKXt0LmFkZChTdHJpbmcobikpfX1yZXR1cm4gdH1mdW5jdGlvbiBnZXRTdHJpY3RPcHRpb24oZSl7aWYobi5jYWxsKGUsXCJzdHJpY3RcIikpe2NvbnN0IHQ9ZS5zdHJpY3Q7aWYodHlwZW9mIHQhPT1cImJvb2xlYW5cIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW4nKX1pZih0KXtyZXR1cm4gZT0+e2xldCB0PWBPYmplY3QgY2FuIG5vdCBzYWZlbHkgYmUgc3RyaW5naWZpZWQuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgZX1gO2lmKHR5cGVvZiBlIT09XCJmdW5jdGlvblwiKXQrPWAgKCR7ZS50b1N0cmluZygpfSlgO3Rocm93IG5ldyBFcnJvcih0KX19fX1mdW5jdGlvbiBjb25maWd1cmUoZSl7ZT17Li4uZX07Y29uc3QgdD1nZXRTdHJpY3RPcHRpb24oZSk7aWYodCl7aWYoZS5iaWdpbnQ9PT11bmRlZmluZWQpe2UuYmlnaW50PWZhbHNlfWlmKCEoXCJjaXJjdWxhclZhbHVlXCJpbiBlKSl7ZS5jaXJjdWxhclZhbHVlPUVycm9yfX1jb25zdCBuPWdldENpcmN1bGFyVmFsdWVPcHRpb24oZSk7Y29uc3Qgcj1nZXRCb29sZWFuT3B0aW9uKGUsXCJiaWdpbnRcIik7Y29uc3QgaT1nZXREZXRlcm1pbmlzdGljT3B0aW9uKGUpO2NvbnN0IGY9dHlwZW9mIGk9PT1cImZ1bmN0aW9uXCI/aTp1bmRlZmluZWQ7Y29uc3QgdT1nZXRQb3NpdGl2ZUludGVnZXJPcHRpb24oZSxcIm1heGltdW1EZXB0aFwiKTtjb25zdCBvPWdldFBvc2l0aXZlSW50ZWdlck9wdGlvbihlLFwibWF4aW11bUJyZWFkdGhcIik7ZnVuY3Rpb24gc3RyaW5naWZ5Rm5SZXBsYWNlcihlLHMsbCxjLGEsZyl7bGV0IHA9c1tlXTtpZih0eXBlb2YgcD09PVwib2JqZWN0XCImJnAhPT1udWxsJiZ0eXBlb2YgcC50b0pTT049PT1cImZ1bmN0aW9uXCIpe3A9cC50b0pTT04oZSl9cD1jLmNhbGwocyxlLHApO3N3aXRjaCh0eXBlb2YgcCl7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIHN0ckVzY2FwZShwKTtjYXNlXCJvYmplY3RcIjp7aWYocD09PW51bGwpe3JldHVyblwibnVsbFwifWlmKGwuaW5kZXhPZihwKSE9PS0xKXtyZXR1cm4gbn1sZXQgZT1cIlwiO2xldCB0PVwiLFwiO2NvbnN0IHI9ZztpZihBcnJheS5pc0FycmF5KHApKXtpZihwLmxlbmd0aD09PTApe3JldHVyblwiW11cIn1pZih1PGwubGVuZ3RoKzEpe3JldHVybidcIltBcnJheV1cIid9bC5wdXNoKHApO2lmKGEhPT1cIlwiKXtnKz1hO2UrPWBcXG4ke2d9YDt0PWAsXFxuJHtnfWB9Y29uc3Qgbj1NYXRoLm1pbihwLmxlbmd0aCxvKTtsZXQgaT0wO2Zvcig7aTxuLTE7aSsrKXtjb25zdCBuPXN0cmluZ2lmeUZuUmVwbGFjZXIoU3RyaW5nKGkpLHAsbCxjLGEsZyk7ZSs9biE9PXVuZGVmaW5lZD9uOlwibnVsbFwiO2UrPXR9Y29uc3QgZj1zdHJpbmdpZnlGblJlcGxhY2VyKFN0cmluZyhpKSxwLGwsYyxhLGcpO2UrPWYhPT11bmRlZmluZWQ/ZjpcIm51bGxcIjtpZihwLmxlbmd0aC0xPm8pe2NvbnN0IG49cC5sZW5ndGgtby0xO2UrPWAke3R9XCIuLi4gJHtnZXRJdGVtQ291bnQobil9IG5vdCBzdHJpbmdpZmllZFwiYH1pZihhIT09XCJcIil7ZSs9YFxcbiR7cn1gfWwucG9wKCk7cmV0dXJuYFske2V9XWB9bGV0IHM9T2JqZWN0LmtleXMocCk7Y29uc3QgeT1zLmxlbmd0aDtpZih5PT09MCl7cmV0dXJuXCJ7fVwifWlmKHU8bC5sZW5ndGgrMSl7cmV0dXJuJ1wiW09iamVjdF1cIid9bGV0IGQ9XCJcIjtsZXQgaD1cIlwiO2lmKGEhPT1cIlwiKXtnKz1hO3Q9YCxcXG4ke2d9YDtkPVwiIFwifWNvbnN0ICQ9TWF0aC5taW4oeSxvKTtpZihpJiYhaXNUeXBlZEFycmF5V2l0aEVudHJpZXMocCkpe3M9c29ydChzLGYpfWwucHVzaChwKTtmb3IobGV0IG49MDtuPCQ7bisrKXtjb25zdCByPXNbbl07Y29uc3QgaT1zdHJpbmdpZnlGblJlcGxhY2VyKHIscCxsLGMsYSxnKTtpZihpIT09dW5kZWZpbmVkKXtlKz1gJHtofSR7c3RyRXNjYXBlKHIpfToke2R9JHtpfWA7aD10fX1pZih5Pm8pe2NvbnN0IG49eS1vO2UrPWAke2h9XCIuLi5cIjoke2R9XCIke2dldEl0ZW1Db3VudChuKX0gbm90IHN0cmluZ2lmaWVkXCJgO2g9dH1pZihhIT09XCJcIiYmaC5sZW5ndGg+MSl7ZT1gXFxuJHtnfSR7ZX1cXG4ke3J9YH1sLnBvcCgpO3JldHVybmB7JHtlfX1gfWNhc2VcIm51bWJlclwiOnJldHVybiBpc0Zpbml0ZShwKT9TdHJpbmcocCk6dD90KHApOlwibnVsbFwiO2Nhc2VcImJvb2xlYW5cIjpyZXR1cm4gcD09PXRydWU/XCJ0cnVlXCI6XCJmYWxzZVwiO2Nhc2VcInVuZGVmaW5lZFwiOnJldHVybiB1bmRlZmluZWQ7Y2FzZVwiYmlnaW50XCI6aWYocil7cmV0dXJuIFN0cmluZyhwKX1kZWZhdWx0OnJldHVybiB0P3QocCk6dW5kZWZpbmVkfX1mdW5jdGlvbiBzdHJpbmdpZnlBcnJheVJlcGxhY2VyKGUsaSxmLHMsbCxjKXtpZih0eXBlb2YgaT09PVwib2JqZWN0XCImJmkhPT1udWxsJiZ0eXBlb2YgaS50b0pTT049PT1cImZ1bmN0aW9uXCIpe2k9aS50b0pTT04oZSl9c3dpdGNoKHR5cGVvZiBpKXtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gc3RyRXNjYXBlKGkpO2Nhc2VcIm9iamVjdFwiOntpZihpPT09bnVsbCl7cmV0dXJuXCJudWxsXCJ9aWYoZi5pbmRleE9mKGkpIT09LTEpe3JldHVybiBufWNvbnN0IGU9YztsZXQgdD1cIlwiO2xldCByPVwiLFwiO2lmKEFycmF5LmlzQXJyYXkoaSkpe2lmKGkubGVuZ3RoPT09MCl7cmV0dXJuXCJbXVwifWlmKHU8Zi5sZW5ndGgrMSl7cmV0dXJuJ1wiW0FycmF5XVwiJ31mLnB1c2goaSk7aWYobCE9PVwiXCIpe2MrPWw7dCs9YFxcbiR7Y31gO3I9YCxcXG4ke2N9YH1jb25zdCBuPU1hdGgubWluKGkubGVuZ3RoLG8pO2xldCBhPTA7Zm9yKDthPG4tMTthKyspe2NvbnN0IGU9c3RyaW5naWZ5QXJyYXlSZXBsYWNlcihTdHJpbmcoYSksaVthXSxmLHMsbCxjKTt0Kz1lIT09dW5kZWZpbmVkP2U6XCJudWxsXCI7dCs9cn1jb25zdCBnPXN0cmluZ2lmeUFycmF5UmVwbGFjZXIoU3RyaW5nKGEpLGlbYV0sZixzLGwsYyk7dCs9ZyE9PXVuZGVmaW5lZD9nOlwibnVsbFwiO2lmKGkubGVuZ3RoLTE+byl7Y29uc3QgZT1pLmxlbmd0aC1vLTE7dCs9YCR7cn1cIi4uLiAke2dldEl0ZW1Db3VudChlKX0gbm90IHN0cmluZ2lmaWVkXCJgfWlmKGwhPT1cIlwiKXt0Kz1gXFxuJHtlfWB9Zi5wb3AoKTtyZXR1cm5gWyR7dH1dYH1mLnB1c2goaSk7bGV0IGE9XCJcIjtpZihsIT09XCJcIil7Yys9bDtyPWAsXFxuJHtjfWA7YT1cIiBcIn1sZXQgZz1cIlwiO2Zvcihjb25zdCBlIG9mIHMpe2NvbnN0IG49c3RyaW5naWZ5QXJyYXlSZXBsYWNlcihlLGlbZV0sZixzLGwsYyk7aWYobiE9PXVuZGVmaW5lZCl7dCs9YCR7Z30ke3N0ckVzY2FwZShlKX06JHthfSR7bn1gO2c9cn19aWYobCE9PVwiXCImJmcubGVuZ3RoPjEpe3Q9YFxcbiR7Y30ke3R9XFxuJHtlfWB9Zi5wb3AoKTtyZXR1cm5geyR7dH19YH1jYXNlXCJudW1iZXJcIjpyZXR1cm4gaXNGaW5pdGUoaSk/U3RyaW5nKGkpOnQ/dChpKTpcIm51bGxcIjtjYXNlXCJib29sZWFuXCI6cmV0dXJuIGk9PT10cnVlP1widHJ1ZVwiOlwiZmFsc2VcIjtjYXNlXCJ1bmRlZmluZWRcIjpyZXR1cm4gdW5kZWZpbmVkO2Nhc2VcImJpZ2ludFwiOmlmKHIpe3JldHVybiBTdHJpbmcoaSl9ZGVmYXVsdDpyZXR1cm4gdD90KGkpOnVuZGVmaW5lZH19ZnVuY3Rpb24gc3RyaW5naWZ5SW5kZW50KGUscyxsLGMsYSl7c3dpdGNoKHR5cGVvZiBzKXtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gc3RyRXNjYXBlKHMpO2Nhc2VcIm9iamVjdFwiOntpZihzPT09bnVsbCl7cmV0dXJuXCJudWxsXCJ9aWYodHlwZW9mIHMudG9KU09OPT09XCJmdW5jdGlvblwiKXtzPXMudG9KU09OKGUpO2lmKHR5cGVvZiBzIT09XCJvYmplY3RcIil7cmV0dXJuIHN0cmluZ2lmeUluZGVudChlLHMsbCxjLGEpfWlmKHM9PT1udWxsKXtyZXR1cm5cIm51bGxcIn19aWYobC5pbmRleE9mKHMpIT09LTEpe3JldHVybiBufWNvbnN0IHQ9YTtpZihBcnJheS5pc0FycmF5KHMpKXtpZihzLmxlbmd0aD09PTApe3JldHVyblwiW11cIn1pZih1PGwubGVuZ3RoKzEpe3JldHVybidcIltBcnJheV1cIid9bC5wdXNoKHMpO2ErPWM7bGV0IGU9YFxcbiR7YX1gO2NvbnN0IG49YCxcXG4ke2F9YDtjb25zdCByPU1hdGgubWluKHMubGVuZ3RoLG8pO2xldCBpPTA7Zm9yKDtpPHItMTtpKyspe2NvbnN0IHQ9c3RyaW5naWZ5SW5kZW50KFN0cmluZyhpKSxzW2ldLGwsYyxhKTtlKz10IT09dW5kZWZpbmVkP3Q6XCJudWxsXCI7ZSs9bn1jb25zdCBmPXN0cmluZ2lmeUluZGVudChTdHJpbmcoaSksc1tpXSxsLGMsYSk7ZSs9ZiE9PXVuZGVmaW5lZD9mOlwibnVsbFwiO2lmKHMubGVuZ3RoLTE+byl7Y29uc3QgdD1zLmxlbmd0aC1vLTE7ZSs9YCR7bn1cIi4uLiAke2dldEl0ZW1Db3VudCh0KX0gbm90IHN0cmluZ2lmaWVkXCJgfWUrPWBcXG4ke3R9YDtsLnBvcCgpO3JldHVybmBbJHtlfV1gfWxldCByPU9iamVjdC5rZXlzKHMpO2NvbnN0IGc9ci5sZW5ndGg7aWYoZz09PTApe3JldHVyblwie31cIn1pZih1PGwubGVuZ3RoKzEpe3JldHVybidcIltPYmplY3RdXCInfWErPWM7Y29uc3QgcD1gLFxcbiR7YX1gO2xldCB5PVwiXCI7bGV0IGQ9XCJcIjtsZXQgaD1NYXRoLm1pbihnLG8pO2lmKGlzVHlwZWRBcnJheVdpdGhFbnRyaWVzKHMpKXt5Kz1zdHJpbmdpZnlUeXBlZEFycmF5KHMscCxvKTtyPXIuc2xpY2Uocy5sZW5ndGgpO2gtPXMubGVuZ3RoO2Q9cH1pZihpKXtyPXNvcnQocixmKX1sLnB1c2gocyk7Zm9yKGxldCBlPTA7ZTxoO2UrKyl7Y29uc3QgdD1yW2VdO2NvbnN0IG49c3RyaW5naWZ5SW5kZW50KHQsc1t0XSxsLGMsYSk7aWYobiE9PXVuZGVmaW5lZCl7eSs9YCR7ZH0ke3N0ckVzY2FwZSh0KX06ICR7bn1gO2Q9cH19aWYoZz5vKXtjb25zdCBlPWctbzt5Kz1gJHtkfVwiLi4uXCI6IFwiJHtnZXRJdGVtQ291bnQoZSl9IG5vdCBzdHJpbmdpZmllZFwiYDtkPXB9aWYoZCE9PVwiXCIpe3k9YFxcbiR7YX0ke3l9XFxuJHt0fWB9bC5wb3AoKTtyZXR1cm5geyR7eX19YH1jYXNlXCJudW1iZXJcIjpyZXR1cm4gaXNGaW5pdGUocyk/U3RyaW5nKHMpOnQ/dChzKTpcIm51bGxcIjtjYXNlXCJib29sZWFuXCI6cmV0dXJuIHM9PT10cnVlP1widHJ1ZVwiOlwiZmFsc2VcIjtjYXNlXCJ1bmRlZmluZWRcIjpyZXR1cm4gdW5kZWZpbmVkO2Nhc2VcImJpZ2ludFwiOmlmKHIpe3JldHVybiBTdHJpbmcocyl9ZGVmYXVsdDpyZXR1cm4gdD90KHMpOnVuZGVmaW5lZH19ZnVuY3Rpb24gc3RyaW5naWZ5U2ltcGxlKGUscyxsKXtzd2l0Y2godHlwZW9mIHMpe2Nhc2VcInN0cmluZ1wiOnJldHVybiBzdHJFc2NhcGUocyk7Y2FzZVwib2JqZWN0XCI6e2lmKHM9PT1udWxsKXtyZXR1cm5cIm51bGxcIn1pZih0eXBlb2Ygcy50b0pTT049PT1cImZ1bmN0aW9uXCIpe3M9cy50b0pTT04oZSk7aWYodHlwZW9mIHMhPT1cIm9iamVjdFwiKXtyZXR1cm4gc3RyaW5naWZ5U2ltcGxlKGUscyxsKX1pZihzPT09bnVsbCl7cmV0dXJuXCJudWxsXCJ9fWlmKGwuaW5kZXhPZihzKSE9PS0xKXtyZXR1cm4gbn1sZXQgdD1cIlwiO2NvbnN0IHI9cy5sZW5ndGghPT11bmRlZmluZWQ7aWYociYmQXJyYXkuaXNBcnJheShzKSl7aWYocy5sZW5ndGg9PT0wKXtyZXR1cm5cIltdXCJ9aWYodTxsLmxlbmd0aCsxKXtyZXR1cm4nXCJbQXJyYXldXCInfWwucHVzaChzKTtjb25zdCBlPU1hdGgubWluKHMubGVuZ3RoLG8pO2xldCBuPTA7Zm9yKDtuPGUtMTtuKyspe2NvbnN0IGU9c3RyaW5naWZ5U2ltcGxlKFN0cmluZyhuKSxzW25dLGwpO3QrPWUhPT11bmRlZmluZWQ/ZTpcIm51bGxcIjt0Kz1cIixcIn1jb25zdCByPXN0cmluZ2lmeVNpbXBsZShTdHJpbmcobiksc1tuXSxsKTt0Kz1yIT09dW5kZWZpbmVkP3I6XCJudWxsXCI7aWYocy5sZW5ndGgtMT5vKXtjb25zdCBlPXMubGVuZ3RoLW8tMTt0Kz1gLFwiLi4uICR7Z2V0SXRlbUNvdW50KGUpfSBub3Qgc3RyaW5naWZpZWRcImB9bC5wb3AoKTtyZXR1cm5gWyR7dH1dYH1sZXQgYz1PYmplY3Qua2V5cyhzKTtjb25zdCBhPWMubGVuZ3RoO2lmKGE9PT0wKXtyZXR1cm5cInt9XCJ9aWYodTxsLmxlbmd0aCsxKXtyZXR1cm4nXCJbT2JqZWN0XVwiJ31sZXQgZz1cIlwiO2xldCBwPU1hdGgubWluKGEsbyk7aWYociYmaXNUeXBlZEFycmF5V2l0aEVudHJpZXMocykpe3QrPXN0cmluZ2lmeVR5cGVkQXJyYXkocyxcIixcIixvKTtjPWMuc2xpY2Uocy5sZW5ndGgpO3AtPXMubGVuZ3RoO2c9XCIsXCJ9aWYoaSl7Yz1zb3J0KGMsZil9bC5wdXNoKHMpO2ZvcihsZXQgZT0wO2U8cDtlKyspe2NvbnN0IG49Y1tlXTtjb25zdCByPXN0cmluZ2lmeVNpbXBsZShuLHNbbl0sbCk7aWYociE9PXVuZGVmaW5lZCl7dCs9YCR7Z30ke3N0ckVzY2FwZShuKX06JHtyfWA7Zz1cIixcIn19aWYoYT5vKXtjb25zdCBlPWEtbzt0Kz1gJHtnfVwiLi4uXCI6XCIke2dldEl0ZW1Db3VudChlKX0gbm90IHN0cmluZ2lmaWVkXCJgfWwucG9wKCk7cmV0dXJuYHske3R9fWB9Y2FzZVwibnVtYmVyXCI6cmV0dXJuIGlzRmluaXRlKHMpP1N0cmluZyhzKTp0P3Qocyk6XCJudWxsXCI7Y2FzZVwiYm9vbGVhblwiOnJldHVybiBzPT09dHJ1ZT9cInRydWVcIjpcImZhbHNlXCI7Y2FzZVwidW5kZWZpbmVkXCI6cmV0dXJuIHVuZGVmaW5lZDtjYXNlXCJiaWdpbnRcIjppZihyKXtyZXR1cm4gU3RyaW5nKHMpfWRlZmF1bHQ6cmV0dXJuIHQ/dChzKTp1bmRlZmluZWR9fWZ1bmN0aW9uIHN0cmluZ2lmeShlLHQsbil7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtsZXQgcj1cIlwiO2lmKHR5cGVvZiBuPT09XCJudW1iZXJcIil7cj1cIiBcIi5yZXBlYXQoTWF0aC5taW4obiwxMCkpfWVsc2UgaWYodHlwZW9mIG49PT1cInN0cmluZ1wiKXtyPW4uc2xpY2UoMCwxMCl9aWYodCE9bnVsbCl7aWYodHlwZW9mIHQ9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBzdHJpbmdpZnlGblJlcGxhY2VyKFwiXCIse1wiXCI6ZX0sW10sdCxyLFwiXCIpfWlmKEFycmF5LmlzQXJyYXkodCkpe3JldHVybiBzdHJpbmdpZnlBcnJheVJlcGxhY2VyKFwiXCIsZSxbXSxnZXRVbmlxdWVSZXBsYWNlclNldCh0KSxyLFwiXCIpfX1pZihyLmxlbmd0aCE9PTApe3JldHVybiBzdHJpbmdpZnlJbmRlbnQoXCJcIixlLFtdLHIsXCJcIil9fXJldHVybiBzdHJpbmdpZnlTaW1wbGUoXCJcIixlLFtdKX1yZXR1cm4gc3RyaW5naWZ5fX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18obil7dmFyIHI9dFtuXTtpZihyIT09dW5kZWZpbmVkKXtyZXR1cm4gci5leHBvcnRzfXZhciBpPXRbbl09e2V4cG9ydHM6e319O3ZhciBmPXRydWU7dHJ5e2Vbbl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7Zj1mYWxzZX1maW5hbGx5e2lmKGYpZGVsZXRlIHRbbl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIG49X19uY2N3cGNrX3JlcXVpcmVfXyg4NzkpO21vZHVsZS5leHBvcnRzPW59KSgpOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxDQUFDO0lBQVc7SUFBYSxJQUFJLElBQUU7UUFBQyxLQUFJLFNBQVMsQ0FBQyxFQUFDLENBQUM7WUFBRSxNQUFLLEVBQUMsZ0JBQWUsQ0FBQyxFQUFDLEdBQUMsT0FBTyxTQUFTO1lBQUMsTUFBTSxJQUFFO1lBQVksRUFBRSxTQUFTLEdBQUM7WUFBVSxFQUFFLFNBQVMsR0FBQztZQUFFLEVBQUUsT0FBTyxHQUFDO1lBQUUsRUFBRSxTQUFTLEdBQUM7WUFBRSxFQUFFLFNBQVMsR0FBQztZQUFVLEVBQUUsT0FBTyxHQUFDO1lBQUUsTUFBTSxJQUFFO1lBQTJDLFNBQVMsVUFBVSxDQUFDO2dCQUFFLElBQUcsRUFBRSxNQUFNLEdBQUMsT0FBSyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUc7b0JBQUMsT0FBTSxBQUFDLElBQUssT0FBRixHQUFFO2dCQUFFO2dCQUFDLE9BQU8sS0FBSyxTQUFTLENBQUM7WUFBRTtZQUFDLFNBQVMsS0FBSyxDQUFDLEVBQUMsQ0FBQztnQkFBRSxJQUFHLEVBQUUsTUFBTSxHQUFDLE9BQUssR0FBRTtvQkFBQyxPQUFPLEVBQUUsSUFBSSxDQUFDO2dCQUFFO2dCQUFDLElBQUksSUFBSSxJQUFFLEdBQUUsSUFBRSxFQUFFLE1BQU0sRUFBQyxJQUFJO29CQUFDLE1BQU0sSUFBRSxDQUFDLENBQUMsRUFBRTtvQkFBQyxJQUFJLElBQUU7b0JBQUUsTUFBTSxNQUFJLEtBQUcsQ0FBQyxDQUFDLElBQUUsRUFBRSxHQUFDLEVBQUU7d0JBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsSUFBRSxFQUFFO3dCQUFDO29CQUFHO29CQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUM7Z0JBQUM7Z0JBQUMsT0FBTztZQUFDO1lBQUMsTUFBTSxJQUFFLE9BQU8sd0JBQXdCLENBQUMsT0FBTyxjQUFjLENB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QUFFLENBQUMsR0FBRSxFQUFFLE9BQU8sRUFBQztZQUFxQixJQUFFO1FBQUssU0FBUTtZQUFDLElBQUcsR0FBRSxPQUFPLENBQUMsQ0FBQyxFQUFFO1FBQUE7UUFBQyxPQUFPLEVBQUUsT0FBTztJQUFBO0lBQUMsSUFBRyxPQUFPLHdCQUFzQixhQUFZLG9CQUFvQixFQUFFLEdBQUMsa0dBQVU7SUFBSSxJQUFJLElBQUUsb0JBQW9CO0lBQUssT0FBTyxPQUFPLEdBQUM7QUFBQyxDQUFDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX0sCiAgICB7Im9mZnNldCI6IHsibGluZSI6IDE2NzEsICJjb2x1bW4iOiAwfSwgIm1hcCI6IHsidmVyc2lvbiI6Mywic291cmNlcyI6WyJmaWxlOi8vL0Q6L0RvY3VtZW50cy9OZXclMjBmb2xkZXIvVGFzay1GbG93L2NsaWVudC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3N0cmlwLWFuc2kvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezUxMTplPT57ZS5leHBvcnRzPSh7b25seUZpcnN0OmU9ZmFsc2V9PXt9KT0+e2NvbnN0IHI9W1wiW1xcXFx1MDAxQlxcXFx1MDA5Ql1bW1xcXFxdKCkjOz9dKig/Oig/Oig/Oig/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSspKnxbYS16QS1aXFxcXGRdKyg/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSopKik/XFxcXHUwMDA3KVwiLFwiKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1udHFyeT0+PH5dKSlcIl0uam9pbihcInxcIik7cmV0dXJuIG5ldyBSZWdFeHAocixlP3VuZGVmaW5lZDpcImdcIil9fSw1MzI6KGUscixfKT0+e2NvbnN0IHQ9Xyg1MTEpO2UuZXhwb3J0cz1lPT50eXBlb2YgZT09PVwic3RyaW5nXCI/ZS5yZXBsYWNlKHQoKSxcIlwiKTplfX07dmFyIHI9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhfKXt2YXIgdD1yW19dO2lmKHQhPT11bmRlZmluZWQpe3JldHVybiB0LmV4cG9ydHN9dmFyIGE9cltfXT17ZXhwb3J0czp7fX07dmFyIG49dHJ1ZTt0cnl7ZVtfXShhLGEuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtuPWZhbHNlfWZpbmFsbHl7aWYobilkZWxldGUgcltfXX1yZXR1cm4gYS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgXz1fX25jY3dwY2tfcmVxdWlyZV9fKDUzMik7bW9kdWxlLmV4cG9ydHM9X30pKCk7Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLENBQUM7SUFBSztJQUFhLElBQUksSUFBRTtRQUFDLEtBQUksQ0FBQTtZQUFJLEVBQUUsT0FBTyxHQUFDO29CQUFDLEVBQUMsV0FBVSxJQUFFLEtBQUssRUFBQyxvRUFBQyxDQUFDO2dCQUFLLE1BQU0sSUFBRTtvQkFBQztvQkFBK0g7aUJBQTJELENBQUMsSUFBSSxDQUFDO2dCQUFLLE9BQU8sSUFBSSxPQUFPLEdBQUUsSUFBRSxZQUFVO1lBQUk7UUFBQztRQUFFLEtBQUksQ0FBQyxHQUFFLEdBQUU7WUFBSyxNQUFNLElBQUUsRUFBRTtZQUFLLEVBQUUsT0FBTyxHQUFDLENBQUEsSUFBRyxPQUFPLE1BQUksV0FBUyxFQUFFLE9BQU8sQ0FBQyxLQUFJLE1BQUk7UUFBQztJQUFDO0lBQUUsSUFBSSxJQUFFLENBQUM7SUFBRSxTQUFTLG9CQUFvQixDQUFDO1FBQUUsSUFBSSxJQUFFLENBQUMsQ0FBQyxFQUFFO1FBQUMsSUFBRyxNQUFJLFdBQVU7WUFBQyxPQUFPLEVBQUUsT0FBTztRQUFBO1FBQUMsSUFBSSxJQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUM7WUFBQyxTQUFRLENBQUM7UUFBQztRQUFFLElBQUksSUFBRTtRQUFLLElBQUc7WUFBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUUsRUFBRSxPQUFPLEVBQUM7WUFBcUIsSUFBRTtRQUFLLFNBQVE7WUFBQyxJQUFHLEdBQUUsT0FBTyxDQUFDLENBQUMsRUFBRTtRQUFBO1FBQUMsT0FBTyxFQUFFLE9BQU87SUFBQTtJQUFDLElBQUcsT0FBTyx3QkFBc0IsYUFBWSxvQkFBb0IsRUFBRSxHQUFDLHVGQUFVO0lBQUksSUFBSSxJQUFFLG9CQUFvQjtJQUFLLE9BQU8sT0FBTyxHQUFDO0FBQUMsQ0FBQyIsImlnbm9yZUxpc3QiOlswXSwiZGVidWdJZCI6bnVsbH19LAogICAgeyJvZmZzZXQiOiB7ImxpbmUiOiAxNzE2LCAiY29sdW1uIjogMH0sICJtYXAiOiB7InZlcnNpb24iOjMsInNvdXJjZXMiOlsiZmlsZTovLy9EOi9Eb2N1bWVudHMvTmV3JTIwZm9sZGVyL1Rhc2stRmxvdy9jbGllbnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zdGFja3RyYWNlLXBhcnNlci9zdGFjay10cmFjZS1wYXJzZXIuY2pzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO2lmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgZT17fTsoKCk9Pnt2YXIgcj1lO09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dmFyIG49XCI8dW5rbm93bj5cIjtmdW5jdGlvbiBwYXJzZShlKXt2YXIgcj1lLnNwbGl0KFwiXFxuXCIpO3JldHVybiByLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXt2YXIgbj1wYXJzZUNocm9tZShyKXx8cGFyc2VXaW5qcyhyKXx8cGFyc2VHZWNrbyhyKXx8cGFyc2VOb2RlKHIpfHxwYXJzZUpTQyhyKTtpZihuKXtlLnB1c2gobil9cmV0dXJuIGV9KSxbXSl9dmFyIGE9L15cXHMqYXQgKC4qPykgP1xcKCgoPzpmaWxlfGh0dHBzP3xibG9ifGNocm9tZS1leHRlbnNpb258bmF0aXZlfGV2YWx8d2VicGFja3x3ZWJwYWNrLWludGVybmFsfHJzY3x0dXJib3BhY2t8PGFub255bW91cz58XFwvfFthLXpdOlxcXFx8XFxcXFxcXFwpLio/KSg/OjooXFxkKykpPyg/OjooXFxkKykpP1xcKT9cXHMqJC9pO3ZhciBsPS9cXCgoXFxTKikoPzo6KFxcZCspKSg/OjooXFxkKykpXFwpLztmdW5jdGlvbiBwYXJzZUNocm9tZShlKXt2YXIgcj1hLmV4ZWMoZSk7aWYoIXIpe3JldHVybiBudWxsfXZhciB1PXJbMl0mJnJbMl0uaW5kZXhPZihcIm5hdGl2ZVwiKT09PTA7dmFyIHQ9clsyXSYmclsyXS5pbmRleE9mKFwiZXZhbFwiKT09PTA7dmFyIGk9bC5leGVjKHJbMl0pO2lmKHQmJmkhPW51bGwpe3JbMl09aVsxXTtyWzNdPWlbMl07cls0XT1pWzNdfXJldHVybntmaWxlOiF1P3JbMl06bnVsbCxtZXRob2ROYW1lOnJbMV18fG4sYXJndW1lbnRzOnU/W3JbMl1dOltdLGxpbmVOdW1iZXI6clszXT8rclszXTpudWxsLGNvbHVtbjpyWzRdPytyWzRdOm51bGx9fXZhciB1PS9eXFxzKmF0ICg/OigoPzpcXFtvYmplY3Qgb2JqZWN0XFxdKT8uKykgKT9cXCg/KCg/OmZpbGV8bXMtYXBweHxodHRwcz98d2VicGFja3x3ZWJwYWNrLWludGVybmFsfHJzY3x0dXJib3BhY2t8YmxvYik6Lio/KTooXFxkKykoPzo6KFxcZCspKT9cXCk/XFxzKiQvaTtmdW5jdGlvbiBwYXJzZVdpbmpzKGUpe3ZhciByPXUuZXhlYyhlKTtpZighcil7cmV0dXJuIG51bGx9cmV0dXJue2ZpbGU6clsyXSxtZXRob2ROYW1lOnJbMV18fG4sYXJndW1lbnRzOltdLGxpbmVOdW1iZXI6K3JbM10sY29sdW1uOnJbNF0/K3JbNF06bnVsbH19dmFyIHQ9L15cXHMqKC4qPykoPzpcXCgoLio/KVxcKSk/KD86XnxAKSgoPzpmaWxlfGh0dHBzP3xibG9ifGNocm9tZXx3ZWJwYWNrfHdlYnBhY2staW50ZXJuYWx8cnNjfHR1cmJvcGFja3xyZXNvdXJjZXxcXFtuYXRpdmUpLio/fFteQF0qYnVuZGxlKSg/OjooXFxkKykpPyg/OjooXFxkKykpP1xccyokL2k7dmFyIGk9LyhcXFMrKSBsaW5lIChcXGQrKSg/OiA+IGV2YWwgbGluZSBcXGQrKSogPiBldmFsL2k7ZnVuY3Rpb24gcGFyc2VHZWNrbyhlKXt2YXIgcj10LmV4ZWMoZSk7aWYoIXIpe3JldHVybiBudWxsfXZhciBhPXJbM10mJnJbM10uaW5kZXhPZihcIiA+IGV2YWxcIik+LTE7dmFyIGw9aS5leGVjKHJbM10pO2lmKGEmJmwhPW51bGwpe3JbM109bFsxXTtyWzRdPWxbMl07cls1XT1udWxsfXJldHVybntmaWxlOnJbM10sbWV0aG9kTmFtZTpyWzFdfHxuLGFyZ3VtZW50czpyWzJdP3JbMl0uc3BsaXQoXCIsXCIpOltdLGxpbmVOdW1iZXI6cls0XT8rcls0XTpudWxsLGNvbHVtbjpyWzVdPytyWzVdOm51bGx9fXZhciBzPS9eXFxzKig/OihbXkBdKikoPzpcXCgoLio/KVxcKSk/QCk/KFxcUy4qPyk6KFxcZCspKD86OihcXGQrKSk/XFxzKiQvaTtmdW5jdGlvbiBwYXJzZUpTQyhlKXt2YXIgcj1zLmV4ZWMoZSk7aWYoIXIpe3JldHVybiBudWxsfXJldHVybntmaWxlOnJbM10sbWV0aG9kTmFtZTpyWzFdfHxuLGFyZ3VtZW50czpbXSxsaW5lTnVtYmVyOityWzRdLGNvbHVtbjpyWzVdPytyWzVdOm51bGx9fXZhciBjPS9eXFxzKmF0ICg/OigoPzpcXFtvYmplY3Qgb2JqZWN0XFxdKT9bXlxcXFwvXSsoPzogXFxbYXMgXFxTK1xcXSk/KSApP1xcKD8oLio/KTooXFxkKykoPzo6KFxcZCspKT9cXCk/XFxzKiQvaTtmdW5jdGlvbiBwYXJzZU5vZGUoZSl7dmFyIHI9Yy5leGVjKGUpO2lmKCFyKXtyZXR1cm4gbnVsbH1yZXR1cm57ZmlsZTpyWzJdLG1ldGhvZE5hbWU6clsxXXx8bixhcmd1bWVudHM6W10sbGluZU51bWJlcjorclszXSxjb2x1bW46cls0XT8rcls0XTpudWxsfX1yLnBhcnNlPXBhcnNlfSkoKTttb2R1bGUuZXhwb3J0cz1lfSkoKTsiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsQ0FBQztJQUFLO0lBQWEsSUFBRyxPQUFPLHdCQUFzQixhQUFZLG9CQUFvQixFQUFFLEdBQUMsOEZBQVU7SUFBSSxJQUFJLElBQUUsQ0FBQztJQUFFLENBQUM7UUFBSyxJQUFJLElBQUU7UUFBRSxPQUFPLGNBQWMsQ0FBQyxHQUFFLGNBQWE7WUFBQyxPQUFNO1FBQUk7UUFBRyxJQUFJLElBQUU7UUFBWSxTQUFTLE1BQU0sQ0FBQztZQUFFLElBQUksSUFBRSxFQUFFLEtBQUssQ0FBQztZQUFNLE9BQU8sRUFBRSxNQUFNLENBQUUsU0FBUyxDQUFDLEVBQUMsQ0FBQztnQkFBRSxJQUFJLElBQUUsWUFBWSxNQUFJLFdBQVcsTUFBSSxXQUFXLE1BQUksVUFBVSxNQUFJLFNBQVM7Z0JBQUcsSUFBRyxHQUFFO29CQUFDLEVBQUUsSUFBSSxDQUFDO2dCQUFFO2dCQUFDLE9BQU87WUFBQyxHQUFHLEVBQUU7UUFBQztRQUFDLElBQUksSUFBRTtRQUEySyxJQUFJLElBQUU7UUFBZ0MsU0FBUyxZQUFZLENBQUM7WUFBRSxJQUFJLElBQUUsRUFBRSxJQUFJLENBQUM7WUFBRyxJQUFHLENBQUMsR0FBRTtnQkFBQyxPQUFPO1lBQUk7WUFBQyxJQUFJLElBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxjQUFZO1lBQUUsSUFBSSxJQUFFLENBQUMsQ0FBQyxFQUFFLElBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsWUFBVTtZQUFFLElBQUksSUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUFFLElBQUcsS0FBRyxLQUFHLE1BQUs7Z0JBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRTtnQkFBQyxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUU7WUFBQTtZQUFDLE9BQU07Z0JBQUMsTUFBSyxDQUFDLElBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBQztnQkFBSyxZQUFXLENBQUMsQ0FBQyxFQUFFLElBQUU7Z0JBQUUsV0FBVSxJQUFFO29CQUFDLENBQUMsQ0FBQyxFQUFFO2lCQUFDLEdBQUMsRUFBRTtnQkFBQyxZQUFXLENBQUMsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFDO2dCQUFLLFFBQU8sQ0FBQyxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUM7WUFBSTtRQUFDO1FBQUMsSUFBSSxJQUFFO1FBQStJLFNBQVMsV0FBVyxDQUFDO1lBQUUsSUFBSSxJQUFFLEVBQUUsSUFBSSxDQUFDO1lBQUcsSUFBRyxDQUFDLEdBQUU7Z0JBQUMsT0FBTztZQUFJO1lBQUMsT0FBTTtnQkFBQyxNQUFLLENBQUMsQ0FBQyxFQUFFO2dCQUFDLFlBQVcsQ0FBQyxDQUFDLEVBQUUsSUFBRTtnQkFBRSxXQUFVLEVBQUU7Z0JBQUMsWUFBVyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUFDLFFBQU8sQ0FBQyxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUM7WUFBSTtRQUFDO1FBQUMsSUFBSSxJQUFFO1FBQWlLLElBQUksSUFBRTtRQUFnRCxTQUFTLFdBQVcsQ0FBQztZQUFFLElBQUksSUFBRSxFQUFFLElBQUksQ0FBQztZQUFHLElBQUcsQ0FBQyxHQUFFO2dCQUFDLE9BQU87WUFBSTtZQUFDLElBQUksSUFBRSxDQUFDLENBQUMsRUFBRSxJQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLGFBQVcsQ0FBQztZQUFFLElBQUksSUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUFFLElBQUcsS0FBRyxLQUFHLE1BQUs7Z0JBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRTtnQkFBQyxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUM7WUFBSTtZQUFDLE9BQU07Z0JBQUMsTUFBSyxDQUFDLENBQUMsRUFBRTtnQkFBQyxZQUFXLENBQUMsQ0FBQyxFQUFFLElBQUU7Z0JBQUUsV0FBVSxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQUssRUFBRTtnQkFBQyxZQUFXLENBQUMsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFDO2dCQUFLLFFBQU8sQ0FBQyxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUM7WUFBSTtRQUFDO1FBQUMsSUFBSSxJQUFFO1FBQStELFNBQVMsU0FBUyxDQUFDO1lBQUUsSUFBSSxJQUFFLEVBQUUsSUFBSSxDQUFDO1lBQUcsSUFBRyxDQUFDLEdBQUU7Z0JBQUMsT0FBTztZQUFJO1lBQUMsT0FBTTtnQkFBQyxNQUFLLENBQUMsQ0FBQyxFQUFFO2dCQUFDLFlBQVcsQ0FBQyxDQUFDLEVBQUUsSUFBRTtnQkFBRSxXQUFVLEVBQUU7Z0JBQUMsWUFBVyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUFDLFFBQU8sQ0FBQyxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUM7WUFBSTtRQUFDO1FBQUMsSUFBSSxJQUFFO1FBQWdHLFNBQVMsVUFBVSxDQUFDO1lBQUUsSUFBSSxJQUFFLEVBQUUsSUFBSSxDQUFDO1lBQUcsSUFBRyxDQUFDLEdBQUU7Z0JBQUMsT0FBTztZQUFJO1lBQUMsT0FBTTtnQkFBQyxNQUFLLENBQUMsQ0FBQyxFQUFFO2dCQUFDLFlBQVcsQ0FBQyxDQUFDLEVBQUUsSUFBRTtnQkFBRSxXQUFVLEVBQUU7Z0JBQUMsWUFBVyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUFDLFFBQU8sQ0FBQyxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUM7WUFBSTtRQUFDO1FBQUMsRUFBRSxLQUFLLEdBQUM7SUFBSyxDQUFDO0lBQUksT0FBTyxPQUFPLEdBQUM7QUFBQyxDQUFDIiwiaWdub3JlTGlzdCI6WzBdLCJkZWJ1Z0lkIjpudWxsfX1dCn0=